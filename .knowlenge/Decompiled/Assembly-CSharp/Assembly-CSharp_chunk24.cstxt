using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Nexus.Models;
using Network;
using Network.Visibility;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust;
using Unity.Jobs.LowLevel.Unsafe;
using UnityEngine;
using UnityEngine.Profiling;
using UnityEngine.SceneManagement;

[Factory("global")]
public class Global : ConsoleSystem
{
	private static int _developer;

	[ClientVar]
	[ServerVar]
	public static int maxthreads = 8;

	[ServerVar]
	[ClientVar]
	public static bool forceUnloadBundles = true;

	[ServerVar]
	public static bool updateNetworkPositionWithDebugCameraWhileSpectating = false;

	public static readonly string TopOfBaseFlag = "--topofbase";

	public static readonly string UndergroundFlag = "--underground";

	[ClientVar(Saved = true)]
	[ServerVar(Saved = true)]
	public static int perf = 0;

	private static bool _god = false;

	private static bool _godforceoffoverlay = false;

	[ServerVar(ClientAdmin = true, ServerAdmin = true, Help = "When enabled a player wearing a gingerbread suit will gib like the gingerbread NPC's")]
	[ClientVar]
	public static bool cinematicGingerbreadCorpses = false;

	private static uint _gingerbreadMaterialID = 0u;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Multiplier applied to SprayDuration if a spray isn't in the sprayers auth (cannot go above 1f)")]
	public static float SprayOutOfAuthMultiplier = 0.5f;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Base time (in seconds) that sprays last")]
	public static float SprayDuration = 10800f;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "If a player sprays more than this, the oldest spray will be destroyed. 0 will disable")]
	public static int MaxSpraysPerPlayer = 40;

	[ServerVar(Help = "Disables the backpacks that appear after a corpse times out")]
	public static bool disableBagDropping = false;

	[ServerVar(Help = "Forces old monument event notification behaviour (UI popup, no sounds)")]
	public static bool legacymonumentnotifications = false;

	[ClientVar(Saved = true, Help = "Disables any emoji animations")]
	public static bool blockEmojiAnimations = false;

	[ClientVar(Saved = true, Help = "Blocks any emoji from appearing")]
	public static bool blockEmoji = false;

	[ClientVar(Saved = true, Help = "Blocks emoji provided by servers from appearing")]
	public static bool blockServerEmoji = false;

	[ClientVar(Saved = true, Help = "Displays any emoji rendering errors in the console")]
	public static bool showEmojiErrors = false;

	[ServerVar]
	[ClientVar]
	public static int developer
	{
		get
		{
			return _developer;
		}
		set
		{
			_developer = value;
			Array.Fill(RustLog.Levels, _developer);
		}
	}

	[ServerVar]
	[ClientVar]
	public static int job_system_threads
	{
		get
		{
			return JobsUtility.JobWorkerCount;
		}
		set
		{
			if (value < 1)
			{
				JobsUtility.ResetJobWorkerCount();
				return;
			}
			value = Mathf.Clamp(value, 1, JobsUtility.JobWorkerMaximumCount);
			JobsUtility.JobWorkerCount = value;
		}
	}

	[ClientVar(ClientInfo = true, Saved = true, Help = "If you're an admin this will enable god mode")]
	public static bool god
	{
		get
		{
			return _god;
		}
		set
		{
			_god = value;
		}
	}

	[ClientVar(ClientInfo = true, Saved = true, Help = "Media: Forces the global.god overlay to never show if enabled")]
	public static bool godforceoffoverlay
	{
		get
		{
			return _godforceoffoverlay;
		}
		set
		{
			_godforceoffoverlay = value;
		}
	}

	[ServerVar]
	public static void restart(Arg args)
	{
		ServerMgr.RestartServer(args.GetString(1, string.Empty), args.GetInt(0, 300));
	}

	[ServerVar]
	[ClientVar]
	public static void quit(Arg args)
	{
		if (args != null && args.HasArgs(1))
		{
			args.ReplyWith("Invalid quit command, quit only works if provided with no arguments.");
			return;
		}
		if (Application.isEditor)
		{
			Debug.LogWarning((object)"Aborting quit because we're in the editor");
			return;
		}
		if ((Object)(object)SingletonComponent<ServerMgr>.Instance != (Object)null)
		{
			SingletonComponent<ServerMgr>.Instance.Shutdown();
		}
		Application.isQuitting = true;
		Server sv = Net.sv;
		if (sv != null)
		{
			sv.Stop("quit");
		}
		Process.GetCurrentProcess().Kill();
		Debug.Log((object)"Quitting");
		Application.Quit();
	}

	[ServerVar]
	public static void report(Arg args)
	{
		ServerPerformance.DoReport();
	}

	[ClientVar]
	[ServerVar]
	public static void objects(Arg args)
	{
		Object[] array = Object.FindObjectsOfType<Object>();
		string text = "";
		Dictionary<Type, int> dictionary = new Dictionary<Type, int>();
		Dictionary<Type, long> dictionary2 = new Dictionary<Type, long>();
		Object[] array2 = array;
		foreach (Object val in array2)
		{
			int runtimeMemorySize = Profiler.GetRuntimeMemorySize(val);
			if (dictionary.ContainsKey(((object)val).GetType()))
			{
				dictionary[((object)val).GetType()]++;
			}
			else
			{
				dictionary.Add(((object)val).GetType(), 1);
			}
			if (dictionary2.ContainsKey(((object)val).GetType()))
			{
				dictionary2[((object)val).GetType()] += runtimeMemorySize;
			}
			else
			{
				dictionary2.Add(((object)val).GetType(), runtimeMemorySize);
			}
		}
		foreach (KeyValuePair<Type, long> item in dictionary2.OrderByDescending(delegate(KeyValuePair<Type, long> x)
		{
			KeyValuePair<Type, long> keyValuePair = x;
			return keyValuePair.Value;
		}))
		{
			text = text + dictionary[item.Key].ToString().PadLeft(10) + " " + NumberExtensions.FormatBytes<long>(item.Value, false).PadLeft(15) + "\t" + item.Key?.ToString() + "\n";
		}
		args.ReplyWith(text);
	}

	[ClientVar]
	[ServerVar]
	public static void textures(Arg args)
	{
		Texture[] array = Object.FindObjectsOfType<Texture>();
		string text = "";
		Texture[] array2 = array;
		foreach (Texture val in array2)
		{
			string text2 = NumberExtensions.FormatBytes<int>(Profiler.GetRuntimeMemorySize((Object)(object)val), false);
			text = text + ((object)val).ToString().PadRight(30) + ((Object)val).name.PadRight(30) + text2 + "\n";
		}
		args.ReplyWith(text);
	}

	[ClientVar]
	[ServerVar]
	public static void colliders(Arg args)
	{
		int num = (from x in Object.FindObjectsOfType<Collider>()
			where x.enabled
			select x).Count();
		int num2 = (from x in Object.FindObjectsOfType<Collider>()
			where !x.enabled
			select x).Count();
		string text = num + " colliders enabled, " + num2 + " disabled";
		args.ReplyWith(text);
	}

	[ServerVar]
	[ClientVar]
	public static void error(Arg args)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		((GameObject)null).transform.position = Vector3.zero;
	}

	[ClientVar]
	[ServerVar]
	public static void queue(Arg args)
	{
		string text = "";
		text = text + "stabilityCheckQueue:        " + ((ObjectWorkQueue<StabilityEntity>)StabilityEntity.stabilityCheckQueue).Info() + "\n";
		text = text + "updateSurroundingsQueue:    " + ((ObjectWorkQueue<Bounds>)StabilityEntity.updateSurroundingsQueue).Info() + "\n";
		args.ReplyWith(text);
	}

	[ServerUserVar]
	public static void setinfo(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			string @string = args.GetString(0, (string)null);
			string string2 = args.GetString(1, (string)null);
			if (@string != null && string2 != null)
			{
				basePlayer.SetInfo(@string, string2);
			}
		}
	}

	[ServerVar]
	public static void sleep(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsSleeping() && !basePlayer.IsSpectating() && !basePlayer.IsDead())
		{
			basePlayer.StartSleeping();
		}
	}

	[ServerVar]
	public static void sleeptarget(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			BasePlayer lookingAtPlayer = RelationshipManager.GetLookingAtPlayer(basePlayer);
			if (!((Object)(object)lookingAtPlayer == (Object)null))
			{
				lookingAtPlayer.StartSleeping();
			}
		}
	}

	[ServerUserVar]
	public static void kill(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer) || basePlayer.IsSpectating() || basePlayer.IsDead())
		{
			return;
		}
		if (basePlayer.IsRestrained)
		{
			Handcuffs handcuffs = basePlayer.Belt?.GetRestraintItem();
			if ((Object)(object)handcuffs != (Object)null && handcuffs.BlockSuicide)
			{
				return;
			}
		}
		if (basePlayer.CanSuicide())
		{
			basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
			if (basePlayer.IsDead())
			{
				basePlayer.MarkSuicide();
			}
		}
		else
		{
			basePlayer.ConsoleMessage("You can't suicide again so quickly, wait a while");
		}
	}

	[ServerUserVar]
	public static void respawn(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		if (!basePlayer.IsDead() && !basePlayer.IsSpectating())
		{
			if (developer > 0)
			{
				Debug.LogWarning((object)(((object)basePlayer)?.ToString() + " wanted to respawn but isn't dead or spectating"));
			}
			basePlayer.SendNetworkUpdate();
		}
		else if (basePlayer.CanRespawn())
		{
			basePlayer.MarkRespawn();
			basePlayer.Respawn();
		}
		else
		{
			basePlayer.ConsoleMessage("You can't respawn again so quickly, wait a while");
		}
	}

	[ServerVar]
	public static void injure(Arg args)
	{
		InjurePlayer(args.Player());
	}

	public static void InjurePlayer(BasePlayer ply)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ply == (Object)null || ply.IsDead())
		{
			return;
		}
		HitInfo hitInfo = Pool.Get<HitInfo>();
		hitInfo.Init(ply, ply, DamageType.Suicide, 1000f, ((Component)ply).transform.position);
		hitInfo.UseProtection = false;
		if (ConVar.Server.woundingenabled && !ply.IsIncapacitated() && !ply.IsSleeping() && !ply.isMounted)
		{
			if (ply.IsCrawling())
			{
				ply.GoToIncapacitated(hitInfo);
			}
			else
			{
				ply.BecomeWounded(hitInfo);
			}
		}
		else
		{
			ply.ConsoleMessage("Can't go to wounded state right now.");
		}
	}

	[ServerVar]
	public static void recover(Arg args)
	{
		RecoverPlayer(args.Player());
	}

	public static void RecoverPlayer(BasePlayer ply)
	{
		if (!((Object)(object)ply == (Object)null) && !ply.IsDead())
		{
			ply.StopWounded();
		}
	}

	[ServerVar]
	public static void spectate(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer.wantsSpectate = true;
			if (!basePlayer.IsDead())
			{
				basePlayer.DieInstantly();
			}
			string @string = args.GetString(0, "");
			if (basePlayer.IsDead())
			{
				basePlayer.StartSpectating();
				basePlayer.UpdateSpectateTarget(@string);
			}
			basePlayer.wantsSpectate = false;
		}
	}

	[ServerVar]
	public static void toggleSpectateTeamInfo(Arg args)
	{
		bool @bool = args.GetBool(0, false);
		BasePlayer basePlayer = args.Player();
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetSpectateTeamInfo(@bool);
			args.ReplyWith($"ToggleSpectateTeamInfo is now {@bool}");
		}
		else
		{
			args.ReplyWith("Invalid player or player is not spectating");
		}
	}

	[ServerVar]
	public static void spectateid(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer.wantsSpectate = true;
			if (!basePlayer.IsDead())
			{
				basePlayer.DieInstantly();
			}
			ulong uLong = args.GetULong(0, 0uL);
			if (basePlayer.IsDead())
			{
				basePlayer.StartSpectating();
				basePlayer.UpdateSpectateTarget(uLong);
			}
			basePlayer.wantsSpectate = false;
		}
	}

	[ServerUserVar]
	public static void respawn_sleepingbag(Arg args)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer) || !basePlayer.IsDead())
		{
			return;
		}
		NetworkableId entityID = args.GetEntityID(0);
		if (!((NetworkableId)(ref entityID)).IsValid)
		{
			args.ReplyWith("Missing sleeping bag ID");
			return;
		}
		string @string = args.GetString(1, "");
		string errorMessage;
		if (NexusServer.Started && !string.IsNullOrWhiteSpace(@string))
		{
			if (!ZoneController.Instance.CanRespawnAcrossZones(basePlayer))
			{
				args.ReplyWith("You cannot respawn to a different zone");
				return;
			}
			NexusZoneDetails val = NexusServer.FindZone(@string);
			if (val == null)
			{
				args.ReplyWith("Zone was not found");
			}
			else if (!basePlayer.CanRespawn())
			{
				args.ReplyWith("You can't respawn again so quickly, wait a while");
			}
			else
			{
				NexusRespawn(basePlayer, val, entityID);
			}
		}
		else if (!SleepingBag.TrySpawnPlayer(basePlayer, entityID, out errorMessage))
		{
			args.ReplyWith(errorMessage);
		}
		static async void NexusRespawn(BasePlayer player, NexusZoneDetails toZone, NetworkableId sleepingBag)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			_ = 1;
			try
			{
				player.nextRespawnTime = float.PositiveInfinity;
				Request val2 = Pool.Get<Request>();
				val2.respawnAtBag = Pool.Get<SleepingBagRespawnRequest>();
				val2.respawnAtBag.userId = player.userID;
				val2.respawnAtBag.sleepingBagId = sleepingBag;
				val2.respawnAtBag.secondaryData = player.SaveSecondaryData();
				Response val3 = await NexusServer.ZoneRpc(toZone.Key, val2);
				try
				{
					if (!val3.status.success)
					{
						if (player.IsConnected)
						{
							player.ConsoleMessage("RespawnAtBag failed: " + val3.status.errorMessage);
						}
						return;
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
				await NexusServer.ZoneClient.Assign(player.UserIDString, toZone.Key);
				if (player.IsConnected)
				{
					ConsoleNetwork.SendClientCommandImmediate(player.net.connection, "nexus.redirect", toZone.IpAddress, toZone.GamePort, toZone.ConnectionProtocol());
					player.Kick("Redirecting to another zone...");
				}
			}
			catch (Exception ex)
			{
				if (player.IsConnected)
				{
					player.ConsoleMessage(ex.ToString());
				}
			}
			finally
			{
				player.MarkRespawn();
			}
		}
	}

	[ServerUserVar]
	public static void respawn_sleepingbag_remove(Arg args)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		NetworkableId entityID = args.GetEntityID(0);
		if (!((NetworkableId)(ref entityID)).IsValid)
		{
			args.ReplyWith("Missing sleeping bag ID");
			return;
		}
		string @string = args.GetString(1, "");
		if (NexusServer.Started && !string.IsNullOrWhiteSpace(@string))
		{
			NexusZoneDetails val = NexusServer.FindZone(@string);
			if (val == null)
			{
				args.ReplyWith("Zone was not found");
			}
			else if (ZoneController.Instance.CanRespawnAcrossZones(basePlayer))
			{
				NexusRemoveBag(basePlayer, val.Key, entityID);
			}
		}
		else
		{
			SleepingBag.DestroyBag(basePlayer.userID, entityID);
		}
		static async void NexusRemoveBag(BasePlayer player, string zoneKey, NetworkableId sleepingBag)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			try
			{
				Request val2 = Pool.Get<Request>();
				val2.destroyBag = Pool.Get<SleepingBagDestroyRequest>();
				val2.destroyBag.userId = player.userID;
				val2.destroyBag.sleepingBagId = sleepingBag;
				(await NexusServer.ZoneRpc(zoneKey, val2)).Dispose();
			}
			catch (Exception ex)
			{
				if (player.IsConnected)
				{
					player.ConsoleMessage(ex.ToString());
				}
			}
		}
	}

	[ServerUserVar]
	public static void status_sv(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			args.ReplyWith(basePlayer.GetDebugStatus());
		}
	}

	[ClientVar]
	public static void status_cl(Arg args)
	{
	}

	[ServerVar]
	public static void teleport(Arg args)
	{
		if (args.HasArgs(2))
		{
			BasePlayer playerOrSleeperOrBot = args.GetPlayerOrSleeperOrBot(0);
			if (Object.op_Implicit((Object)(object)playerOrSleeperOrBot) && playerOrSleeperOrBot.IsAlive())
			{
				BasePlayer playerOrSleeperOrBot2 = args.GetPlayerOrSleeperOrBot(1);
				if (Object.op_Implicit((Object)(object)playerOrSleeperOrBot2) && playerOrSleeperOrBot2.IsAlive())
				{
					playerOrSleeperOrBot.Teleport(playerOrSleeperOrBot2);
				}
			}
			return;
		}
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			BasePlayer playerOrSleeperOrBot3 = args.GetPlayerOrSleeperOrBot(0);
			if (Object.op_Implicit((Object)(object)playerOrSleeperOrBot3) && playerOrSleeperOrBot3.IsAlive())
			{
				basePlayer.Teleport(playerOrSleeperOrBot3);
			}
		}
	}

	[ServerVar]
	public static void teleport2me(Arg args)
	{
		BasePlayer playerOrSleeperOrBot = args.GetPlayerOrSleeperOrBot(0);
		if ((Object)(object)playerOrSleeperOrBot == (Object)null)
		{
			args.ReplyWith("Player or bot not found");
			return;
		}
		if (!playerOrSleeperOrBot.IsAlive())
		{
			args.ReplyWith("Target is not alive");
			return;
		}
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			playerOrSleeperOrBot.Teleport(basePlayer);
		}
	}

	[ServerVar]
	public static void teleporteveryone2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			TeleportPlayersToMe(basePlayer, includeSleepers: true, includeNonSleepers: true, 0uL);
		}
	}

	[ServerVar]
	public static void teleportsleepers2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			TeleportPlayersToMe(basePlayer, includeSleepers: true, includeNonSleepers: false, 0uL);
		}
	}

	[ServerVar]
	public static void teleportnonsleepers2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			TeleportPlayersToMe(basePlayer, includeSleepers: false, includeNonSleepers: true, 0uL);
		}
	}

	[ServerVar]
	public static void teleportteam2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			if (basePlayer.Team == null)
			{
				args.ReplyWith("Player is not in a team");
			}
			else
			{
				TeleportPlayersToMe(basePlayer, includeSleepers: true, includeNonSleepers: true, basePlayer.Team.teamID);
			}
		}
	}

	[ServerVar]
	public static void teleporttargetteam2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			if (basePlayer.Team == null)
			{
				args.ReplyWith("Player is not in a team");
				return;
			}
			ulong uLong = args.GetULong(0, 0uL);
			TeleportPlayersToMe(basePlayer, includeSleepers: true, includeNonSleepers: true, uLong);
		}
	}

	private static void TeleportPlayersToMe(BasePlayer player, bool includeSleepers, bool includeNonSleepers, ulong filterByTeam = 0uL)
	{
		if ((Object)(object)player == (Object)null || !Object.op_Implicit((Object)(object)player) || !player.IsAlive())
		{
			return;
		}
		foreach (BasePlayer allPlayer in BasePlayer.allPlayerList)
		{
			if (allPlayer.IsAlive() && !((Object)(object)allPlayer == (Object)(object)player) && (!allPlayer.IsSleeping() || includeSleepers) && (allPlayer.IsSleeping() || includeNonSleepers) && (filterByTeam == 0L || (allPlayer.Team != null && allPlayer.Team.teamID == filterByTeam)))
			{
				allPlayer.Teleport(player);
			}
		}
	}

	[ServerVar]
	public static void teleportany(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			basePlayer.Teleport(args.GetString(0, ""), playersOnly: false);
		}
	}

	[Help("Teleport to the current closest entity matching the first argument name. Add second int argument to teleport to the nth closest entity (teleport2nearest horse 2 will teleport to the 3rd closest horse)")]
	[ServerVar]
	public static void teleport2nearest(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			string @string = args.GetString(0, "");
			int @int = args.GetInt(1, 0);
			basePlayer.TeleportToNearestTargetEntity(@string, @int);
		}
	}

	[ServerVar]
	public static void teleportpos(Arg args)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			bool num = args.HasArg(TopOfBaseFlag, false);
			bool flag = args.HasArg(UndergroundFlag, false);
			string text = args.FullString.Replace(", ", ",").Replace(TopOfBaseFlag, "").Replace(UndergroundFlag, "")
				.Trim('"');
			if (num)
			{
				TeleportToTopOfBase(basePlayer, StringExtensions.ToVector3(text));
			}
			else if (flag)
			{
				TeleportToUnderground(basePlayer, StringExtensions.ToVector3(text));
			}
			else
			{
				basePlayer.Teleport(StringExtensions.ToVector3(text));
			}
		}
	}

	[ServerVar]
	public static void teleportlos(Arg args)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			Ray val = basePlayer.eyes.HeadRay();
			int @int = args.GetInt(0, 1000);
			RaycastHit val2 = default(RaycastHit);
			if (Physics.Raycast(val, ref val2, (float)@int, 1218652417))
			{
				basePlayer.Teleport(((RaycastHit)(ref val2)).point);
			}
			else
			{
				basePlayer.Teleport(((Ray)(ref val)).origin + ((Ray)(ref val)).direction * (float)@int);
			}
		}
	}

	[ServerVar]
	public static void teleport2owneditem(Arg arg)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		ulong result;
		if ((Object)(object)playerOrSleeper != (Object)null)
		{
			result = playerOrSleeper.userID;
		}
		else if (!ulong.TryParse(arg.GetString(0, ""), out result))
		{
			arg.ReplyWith("No player with that id found");
			return;
		}
		string @string = arg.GetString(1, "");
		BaseEntity[] array = BaseEntity.Util.FindTargetsOwnedBy(result, @string);
		if (array.Length == 0)
		{
			arg.ReplyWith("No targets found");
			return;
		}
		int num = Random.Range(0, array.Length);
		arg.ReplyWith($"Teleporting to {array[num].ShortPrefabName} at {((Component)array[num]).transform.position}");
		basePlayer.Teleport(((Component)array[num]).transform.position);
	}

	[ServerVar(Help = "<steamID/name> <optional: filter> - Teleport to a random entity the player is authed on")]
	public static void teleport2autheditem(Arg arg)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		ulong result;
		if ((Object)(object)playerOrSleeper != (Object)null)
		{
			result = playerOrSleeper.userID;
		}
		else if (!ulong.TryParse(arg.GetString(0, ""), out result))
		{
			arg.ReplyWith("No player with that id found");
			return;
		}
		string @string = arg.GetString(1, "");
		BaseEntity[] array = BaseEntity.Util.FindTargetsAuthedTo(result, @string);
		if (array.Length == 0)
		{
			arg.ReplyWith("No targets found");
			return;
		}
		int num = Random.Range(0, array.Length);
		arg.ReplyWith($"Teleporting to {array[num].ShortPrefabName} at {((Component)array[num]).transform.position}");
		basePlayer.Teleport(((Component)array[num]).transform.position);
	}

	[ServerVar]
	public static void teleport2marker(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Must be called from a player");
			return;
		}
		if (basePlayer.State.pointsOfInterest == null || basePlayer.State.pointsOfInterest.Count == 0)
		{
			arg.ReplyWith("You don't have a marker set");
			return;
		}
		string @string = arg.GetString(0, "");
		if (arg.HasArgs(1) && @string != "True")
		{
			int num = arg.GetInt(0, 0);
			if (num == -1)
			{
				num = basePlayer.State.pointsOfInterest.Count - 1;
			}
			if (num >= 0 && num < basePlayer.State.pointsOfInterest.Count)
			{
				TeleportToMarker(basePlayer.State.pointsOfInterest[num], basePlayer);
				return;
			}
		}
		if (!string.IsNullOrEmpty(@string))
		{
			foreach (MapNote item in basePlayer.State.pointsOfInterest)
			{
				if (!string.IsNullOrEmpty(item.label) && string.Equals(item.label, @string, StringComparison.InvariantCultureIgnoreCase))
				{
					TeleportToMarker(item, basePlayer);
					return;
				}
			}
		}
		int debugMapMarkerIndex = basePlayer.DebugMapMarkerIndex;
		debugMapMarkerIndex++;
		if (debugMapMarkerIndex >= basePlayer.State.pointsOfInterest.Count)
		{
			debugMapMarkerIndex = 0;
		}
		TeleportToMarker(basePlayer.State.pointsOfInterest[debugMapMarkerIndex], basePlayer);
		basePlayer.DebugMapMarkerIndex = debugMapMarkerIndex;
	}

	private static void TeleportToMarker(MapNote marker, BasePlayer player)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		TeleportToTopOfBase(player, marker.worldPosition);
	}

	private static void TeleportToTopOfBase(BasePlayer player, Vector3 position)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		position.y = WaterLevel.GetWaterOrTerrainSurface(position, waves: true, volumes: true);
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(new Ray(position + Vector3.up * 100f, Vector3.down), ref val, 110f, 1218652417))
		{
			position.y = ((RaycastHit)(ref val)).point.y + 0.5f;
		}
		player.Teleport(position);
	}

	private static void TeleportToUnderground(BasePlayer player, Vector3 position)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		position.y = WaterLevel.GetWaterOrTerrainSurface(position, waves: true, volumes: true) - 10f;
		BufferList<RaycastHit> val = Pool.Get<BufferList<RaycastHit>>();
		val.Resize(10);
		int num = Physics.RaycastNonAlloc(new Ray(position, Vector3.down), val.Buffer, 200f, 1210263809);
		float num2 = 0f;
		for (int i = 0; i < num; i++)
		{
			RaycastHit val2 = val[i];
			float y = ((RaycastHit)(ref val2)).transform.position.y;
			if (y < num2)
			{
				position.y = y + 2f;
				if (!AntiHack.TestInsideTerrain(position))
				{
					flag = true;
					num2 = y;
				}
			}
		}
		if (flag)
		{
			position.y = num2 + 2f;
			player.Teleport(position);
		}
		else
		{
			TeleportToTopOfBase(player, position);
		}
		Pool.FreeUnmanaged<RaycastHit>(ref val);
	}

	[ServerVar]
	public static void teleport2grid(Arg arg)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Vector3? val = MapHelper.StringToPosition(arg.GetString(0, ""));
			if (!val.HasValue)
			{
				arg.ReplyWith("Invalid grid reference, should look like 'A1'");
			}
			else
			{
				TeleportToTopOfBase(basePlayer, val.Value);
			}
		}
	}

	[ServerVar]
	public static void teleport2death(Arg arg)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Must be called from a player");
			return;
		}
		if (basePlayer.State.deathMarker == null)
		{
			arg.ReplyWith("No death marker found");
			return;
		}
		Vector3 worldPosition = basePlayer.ServerCurrentDeathNote.worldPosition;
		basePlayer.Teleport(worldPosition);
	}

	[ServerVar]
	public static void teleport2mission(Arg arg)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.TryGetActiveMissionInstance(out var instance))
		{
			return;
		}
		for (int i = 0; i < instance.objectiveStatuses.Count; i++)
		{
			BaseMission.MissionInstance.ObjectiveStatus objectiveStatus = instance.objectiveStatuses[i];
			if (objectiveStatus.started && !objectiveStatus.completed && !objectiveStatus.failed && !(objectiveStatus.worldLocation == default(Vector3)))
			{
				TeleportToTopOfBase(basePlayer, objectiveStatus.worldLocation);
				break;
			}
		}
	}

	[ClientVar]
	[ServerVar]
	public static void free(Arg args)
	{
		Pool.clear_prefabs(args);
		Pool.clear_assets(args);
		Pool.clear_memory(args);
		ConVar.GC.collect();
		ConVar.GC.unload();
	}

	[ClientVar]
	[ServerVar(ServerUser = true)]
	public static void version(Arg arg)
	{
		arg.ReplyWith($"Protocol: {Protocol.printable}\nBuild Date: {BuildInfo.Current.BuildDate}\nUnity Version: {Application.unityVersion}\nChangeset: {BuildInfo.Current.Scm.ChangeId}\nBranch: {BuildInfo.Current.Scm.Branch}");
	}

	[ClientVar]
	[ServerVar]
	public static void sysinfo(Arg arg)
	{
		arg.ReplyWith(SystemInfoGeneralText.currentInfo);
	}

	[ClientVar]
	[ServerVar]
	public static void sysuid(Arg arg)
	{
		arg.ReplyWith(SystemInfo.deviceUniqueIdentifier);
	}

	[ServerVar]
	public static void breakitem(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Item activeItem = basePlayer.GetActiveItem();
			activeItem?.LoseCondition(activeItem.condition);
		}
	}

	[ServerVar]
	public static void breakclothing(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		foreach (Item item in basePlayer.inventory.containerWear.itemList)
		{
			item?.LoseCondition(item.condition);
		}
	}

	[ServerVar]
	[ClientVar]
	public static void subscriptions(Arg arg)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("realm");
			val.AddColumn("group");
			BasePlayer basePlayer = arg.Player();
			if (Object.op_Implicit((Object)(object)basePlayer))
			{
				Enumerator<Group> enumerator = basePlayer.net.subscriber.subscribed.GetEnumerator();
				try
				{
					while (enumerator.MoveNext())
					{
						Group current = enumerator.Current;
						val.AddRow(new string[2]
						{
							"sv",
							current.ID.ToString()
						});
					}
				}
				finally
				{
					((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
				}
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static uint GingerbreadMaterialID()
	{
		if (_gingerbreadMaterialID == 0)
		{
			_gingerbreadMaterialID = StringPool.Get("Gingerbread");
		}
		return _gingerbreadMaterialID;
	}

	[ServerVar]
	public static void ClearAllSprays()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		List<SprayCanSpray> list = Pool.Get<List<SprayCanSpray>>();
		Enumerator<SprayCanSpray> enumerator = SprayCanSpray.AllSprays.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				SprayCanSpray current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (SprayCanSpray item in list)
		{
			item.Kill();
		}
		Pool.FreeUnmanaged<SprayCanSpray>(ref list);
	}

	[ServerVar]
	public static void ClearAllSpraysByPlayer(Arg arg)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (!arg.HasArgs(1))
		{
			return;
		}
		ulong uLong = arg.GetULong(0, 0uL);
		List<SprayCanSpray> list = Pool.Get<List<SprayCanSpray>>();
		Enumerator<SprayCanSpray> enumerator = SprayCanSpray.AllSprays.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				SprayCanSpray current = enumerator.Current;
				if (current.sprayedByPlayer == uLong)
				{
					list.Add(current);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (SprayCanSpray item in list)
		{
			item.Kill();
		}
		int count = list.Count;
		Pool.FreeUnmanaged<SprayCanSpray>(ref list);
		arg.ReplyWith($"Deleted {count} sprays by {uLong}");
	}

	[ServerVar]
	public static void ClearSpraysInRadius(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			float @float = arg.GetFloat(0, 16f);
			int num = ClearSpraysInRadius(((Component)basePlayer).transform.position, @float);
			arg.ReplyWith($"Deleted {num} sprays within {@float} of {basePlayer.displayName}");
		}
	}

	private static int ClearSpraysInRadius(Vector3 position, float radius)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		List<SprayCanSpray> list = Pool.Get<List<SprayCanSpray>>();
		Enumerator<SprayCanSpray> enumerator = SprayCanSpray.AllSprays.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				SprayCanSpray current = enumerator.Current;
				if (current.Distance(position) <= radius)
				{
					list.Add(current);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (SprayCanSpray item in list)
		{
			item.Kill();
		}
		int count = list.Count;
		Pool.FreeUnmanaged<SprayCanSpray>(ref list);
		return count;
	}

	[ServerVar]
	public static void ClearSpraysAtPositionInRadius(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		float @float = arg.GetFloat(1, 0f);
		if (@float != 0f)
		{
			int num = ClearSpraysInRadius(vector, @float);
			arg.ReplyWith($"Deleted {num} sprays within {@float} of {vector}");
		}
	}

	[ServerVar]
	public static void ClearDroppedItems()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		List<DroppedItem> list = Pool.Get<List<DroppedItem>>();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is DroppedItem item)
				{
					list.Add(item);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (DroppedItem item2 in list)
		{
			item2.Kill();
		}
		Pool.FreeUnmanaged<DroppedItem>(ref list);
	}

	[ClientVar]
	[ServerVar]
	public static string printAllScenesInBuild(Arg args)
	{
		StringBuilder stringBuilder = new StringBuilder();
		int sceneCountInBuildSettings = SceneManager.sceneCountInBuildSettings;
		stringBuilder.AppendLine($"Scenes: {sceneCountInBuildSettings}");
		for (int i = 0; i < sceneCountInBuildSettings; i++)
		{
			stringBuilder.AppendLine(SceneUtility.GetScenePathByBuildIndex(i));
		}
		return stringBuilder.ToString();
	}

	[ServerVar(Clientside = true, Help = "Immediately update the manifest")]
	public static void UpdateManifest(Arg args)
	{
		Manifest.UpdateManifest();
	}
}


using Rust.Workshop;
using UnityEngine;

[Factory("graphics")]
public class Graphics : ConsoleSystem
{
	[ClientVar]
	public static bool detailed_postprocessing_profiling = false;

	[ClientVar(Saved = true)]
	public static int shadowmode = 2;

	[ClientVar(Saved = true)]
	public static int shadowlights = 1;

	private static int _shadowquality = 1;

	[ClientVar(Saved = true)]
	public static bool grassshadows = false;

	[ClientVar(Saved = true)]
	public static bool contactshadows = false;

	[ClientVar(Saved = true)]
	public static float drawdistance = 2500f;

	private static EncryptedValue<float> _fov = 75f;

	[ClientVar]
	public static bool hud = true;

	[ClientVar(Saved = true)]
	public static bool chat = true;

	[ClientVar(Saved = true)]
	public static bool branding = true;

	[ClientVar(Saved = true)]
	public static int compass = 1;

	[ClientVar(Saved = true)]
	public static bool dof = false;

	[ClientVar(Saved = true)]
	public static float dof_aper = 12f;

	[ClientVar(Saved = true)]
	public static float dof_blur = 1f;

	[ClientVar(Saved = true, Help = "0 = auto 1 = manual 2 = dynamic based on target")]
	public static int dof_mode = 0;

	[ClientVar(Saved = true, Help = "distance from camera to focus on")]
	public static float dof_focus_dist = 10f;

	[ClientVar(Saved = true)]
	public static float dof_focus_time = 0.2f;

	[ClientVar(Saved = true, ClientAdmin = true)]
	public static float dof_squeeze = 0f;

	[ClientVar(Saved = true, ClientAdmin = true)]
	public static float dof_barrel = 0f;

	[ClientVar(Saved = true, ClientAdmin = true)]
	public static bool dof_debug = false;

	[ClientVar(Saved = true, Help = "Goes from 0 - 3, higher = more dof samples but slower perf")]
	public static int dof_kernel_count = 0;

	public static BaseEntity dof_focus_target_entity = null;

	[ClientVar(Saved = true, Help = "Whether to scale vm models with fov")]
	public static bool vm_fov_scale = true;

	[ClientVar(Saved = true, Help = "FLips viewmodels horizontally (for left handed players)")]
	public static bool vm_horizontal_flip = false;

	private static float _uiscale = 1f;

	private static int _anisotropic = 1;

	private static int _parallax = 0;

	[ClientVar(Help = "Represents the number of vertical syncs that should pass between each frame. An integer in the range of 0-4. ", Saved = true)]
	public static int vsync
	{
		get
		{
			return QualitySettings.vSyncCount;
		}
		set
		{
			QualitySettings.vSyncCount = Mathf.Clamp(value, 0, 4);
		}
	}

	[ClientVar(Saved = true)]
	public static int shadowquality
	{
		get
		{
			return _shadowquality;
		}
		set
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Invalid comparison between Unknown and I4
			_shadowquality = Mathf.Clamp(value, 0, 3);
			shadowmode = _shadowquality + 1;
			bool flag = (int)SystemInfo.graphicsDeviceType == 17;
			KeywordUtil.EnsureKeywordState("SHADOW_QUALITY_HIGH", !flag && _shadowquality == 2);
			KeywordUtil.EnsureKeywordState("SHADOW_QUALITY_VERYHIGH", !flag && _shadowquality == 3);
			KeywordUtil.EnsureKeywordState("FORWARD_SHADOWS_MEDIUM", _shadowquality == 1);
			KeywordUtil.EnsureKeywordState("FORWARD_SHADOWS_HIGH", _shadowquality >= 2);
		}
	}

	[ClientVar(Saved = true)]
	public static float fov
	{
		get
		{
			return _fov;
		}
		set
		{
			_fov = Mathf.Clamp(value, 70f, 90f);
		}
	}

	[ClientVar(Help = "Global multiplier for the LOD's switching distance. A larger value leads to a longer view distance before a lower resolution LOD is picked.", Saved = true)]
	public static float lodBias
	{
		get
		{
			return QualitySettings.lodBias;
		}
		set
		{
			QualitySettings.lodBias = Mathf.Clamp(value, 0.5f, 5f);
		}
	}

	[ClientVar(Saved = true)]
	public static int shaderlod
	{
		get
		{
			int globalMaximumLOD = Shader.globalMaximumLOD;
			if (globalMaximumLOD >= 100 && globalMaximumLOD <= 199)
			{
				return 1;
			}
			if (globalMaximumLOD >= 200 && globalMaximumLOD <= 299)
			{
				return 2;
			}
			if (globalMaximumLOD >= 300 && globalMaximumLOD <= 399)
			{
				return 3;
			}
			if (globalMaximumLOD >= 400 && globalMaximumLOD <= 499)
			{
				return 4;
			}
			if (globalMaximumLOD >= 500 && globalMaximumLOD <= 599)
			{
				return 5;
			}
			_ = 600;
			return 6;
		}
		set
		{
			switch (Mathf.Clamp(value, 1, 6))
			{
			case 1:
				Shader.globalMaximumLOD = 100;
				break;
			case 2:
				Shader.globalMaximumLOD = 200;
				break;
			case 3:
				Shader.globalMaximumLOD = 300;
				break;
			case 4:
				Shader.globalMaximumLOD = 400;
				break;
			case 5:
				Shader.globalMaximumLOD = 500;
				break;
			case 6:
				Shader.globalMaximumLOD = 600;
				break;
			}
		}
	}

	[ClientVar(Saved = true)]
	public static float uiscale
	{
		get
		{
			return _uiscale;
		}
		set
		{
			_uiscale = Mathf.Clamp(value, 0.5f, 1f);
		}
	}

	[ClientVar(Saved = true)]
	public static int af
	{
		get
		{
			return _anisotropic;
		}
		set
		{
			value = Mathf.Clamp(value, 1, 16);
			Texture.SetGlobalAnisotropicFilteringLimits(1, value);
			if (value <= 1)
			{
				Texture.anisotropicFiltering = (AnisotropicFiltering)0;
			}
			if (value > 1)
			{
				Texture.anisotropicFiltering = (AnisotropicFiltering)1;
			}
			_anisotropic = value;
		}
	}

	[ClientVar(Saved = true)]
	public static int parallax
	{
		get
		{
			return _parallax;
		}
		set
		{
			switch (value)
			{
			default:
				Shader.DisableKeyword("TERRAIN_PARALLAX_OFFSET");
				Shader.DisableKeyword("TERRAIN_PARALLAX_OCCLUSION");
				break;
			case 1:
				Shader.EnableKeyword("TERRAIN_PARALLAX_OFFSET");
				Shader.DisableKeyword("TERRAIN_PARALLAX_OCCLUSION");
				break;
			case 2:
				Shader.DisableKeyword("TERRAIN_PARALLAX_OFFSET");
				Shader.EnableKeyword("TERRAIN_PARALLAX_OCCLUSION");
				break;
			}
			_parallax = value;
		}
	}

	[ClientVar(ClientAdmin = true)]
	public static bool itemskins
	{
		get
		{
			return WorkshopSkin.AllowApply;
		}
		set
		{
			WorkshopSkin.AllowApply = value;
		}
	}

	[ClientVar]
	public static bool itemskinunload
	{
		get
		{
			return WorkshopSkin.AllowUnload;
		}
		set
		{
			WorkshopSkin.AllowUnload = value;
		}
	}

	[ClientVar(ClientAdmin = true)]
	public static float itemskintimeout
	{
		get
		{
			return WorkshopSkin.DownloadTimeout;
		}
		set
		{
			WorkshopSkin.DownloadTimeout = value;
		}
	}

	[ClientVar(ClientAdmin = true)]
	public static void dof_focus_target(Arg arg)
	{
	}

	[ClientVar]
	public static void dof_nudge(Arg arg)
	{
		float @float = arg.GetFloat(0, 0f);
		dof_focus_dist += @float;
		if (dof_focus_dist < 0f)
		{
			dof_focus_dist = 0f;
		}
	}
}


using System.Linq;
using UnityEngine;

[Factory("graphicssettings")]
public class GraphicsSettings : ConsoleSystem
{
	private const float MinShadowDistance = 100f;

	private const float MaxShadowDistance2Split = 600f;

	private const float MaxShadowDistance4Split = 1000f;

	private static float _shadowDistancePercent = 100f;

	[ClientVar(Help = "The maximum number of pixel lights that should affect any object.", Saved = true)]
	public static int pixelLightCount
	{
		get
		{
			return QualitySettings.pixelLightCount;
		}
		set
		{
			QualitySettings.pixelLightCount = Mathf.Clamp(value, 0, 8);
		}
	}

	[ClientVar(Help = "Indicates how many of the highest-resolution mips of each texture Unity does not upload at the given quality level.", Saved = true)]
	public static int globalTextureMipmapLimit
	{
		get
		{
			return QualitySettings.globalTextureMipmapLimit;
		}
		set
		{
			value = Mathf.Clamp(value, 0, 3);
			bool num = QualitySettings.globalTextureMipmapLimit != value;
			QualitySettings.globalTextureMipmapLimit = value;
			if (num && (Object)(object)SingletonComponent<FoliageGrid>.Instance != (Object)null)
			{
				SingletonComponent<FoliageGrid>.Instance.OnGlobalTextureMipmapLimitChange();
			}
		}
	}

	[ClientVar(Help = "Global anisotropic filtering mode. 0-2. Disabled, enabled per-texture, force-enabled for all textures.", Saved = true)]
	public static int anisotropicFiltering
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)QualitySettings.anisotropicFiltering;
		}
		set
		{
			QualitySettings.anisotropicFiltering = (AnisotropicFiltering)Mathf.Clamp(value, 0, 2);
		}
	}

	[ClientVar(Help = "Should soft blending be used for particles?", Saved = true)]
	public static bool softParticles
	{
		get
		{
			return QualitySettings.softParticles;
		}
		set
		{
			QualitySettings.softParticles = value;
		}
	}

	[ClientVar(Help = "Budget for how many ray casts can be performed per frame for approximate collision testing.", Saved = true)]
	public static int particleRaycastBudget
	{
		get
		{
			return QualitySettings.particleRaycastBudget;
		}
		set
		{
			QualitySettings.particleRaycastBudget = value;
		}
	}

	[ClientVar(Help = "If enabled, billboards will face towards camera position rather than camera orientation.", Saved = true)]
	public static bool billboardsFaceCameraPosition
	{
		get
		{
			return QualitySettings.billboardsFaceCameraPosition;
		}
		set
		{
			QualitySettings.billboardsFaceCameraPosition = value;
		}
	}

	[ClientVar(Help = "The rendering mode of Shadowmask. 0 = Shadowmask 1 = Distance Shadowmask", Saved = true)]
	public static int shadowmaskMode
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)QualitySettings.shadowmaskMode;
		}
		set
		{
			QualitySettings.shadowmaskMode = (ShadowmaskMode)Mathf.Clamp(value, 0, 1);
		}
	}

	[ClientVar(Help = "The default resolution of shadow maps. 0 = Low, 1 = Medium, 2 = High, 3 = Very High", Saved = true)]
	public static int shadowResolution
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)QualitySettings.shadowResolution;
		}
		set
		{
			QualitySettings.shadowResolution = (ShadowResolution)Mathf.Clamp(value, 0, 3);
		}
	}

	[ClientVar(Help = "Shadow drawing distance percentage", Saved = true)]
	public static float shadowDistancePercent
	{
		get
		{
			return _shadowDistancePercent;
		}
		set
		{
			_shadowDistancePercent = Mathf.Clamp(value, 0f, 100f);
			EnforceShadowDistanceBounds();
		}
	}

	[ClientVar(Help = "Number of cascades to use for directional light shadows. 1 = None, 2 = Two, 4 = Four", Saved = true)]
	public static int shadowCascades
	{
		get
		{
			return QualitySettings.shadowCascades;
		}
		set
		{
			QualitySettings.shadowCascades = ForceOption(value, 2, 2, 4);
			EnforceShadowDistanceBounds();
		}
	}

	[ClientVar(Help = "Enables or disables LOD Cross Fade.", Saved = true)]
	public static bool enableLODCrossFade
	{
		get
		{
			return QualitySettings.enableLODCrossFade;
		}
		set
		{
			QualitySettings.enableLODCrossFade = value;
		}
	}

	public static void SetMandatoryDefaults()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		QualitySettings.useLegacyDetailDistribution = true;
		QualitySettings.terrainQualityOverrides = (TerrainQualityOverrides)0;
		QualitySettings.shadowNearPlaneOffset = 2f;
		QualitySettings.shadowCascade2Split = 0.1f;
		QualitySettings.shadowCascade4Split = new Vector3(0.01f, 0.03f, 0.1f);
		QualitySettings.asyncUploadTimeSlice = 2;
		QualitySettings.asyncUploadBufferSize = 4;
		QualitySettings.asyncUploadPersistentBuffer = true;
		QualitySettings.maximumLODLevel = 0;
		QualitySettings.enableLODCrossFade = true;
		QualitySettings.skinWeights = (SkinWeights)4;
		QualitySettings.resolutionScalingFixedDPIFactor = 1f;
		QualitySettings.shadows = (ShadowQuality)2;
		QualitySettings.shadowProjection = (ShadowProjection)1;
	}

	private static void EnforceShadowDistanceBounds()
	{
		float num = _shadowDistancePercent / 100f;
		float shadowDistance = ((QualitySettings.shadowCascades == 1) ? 100f : ((QualitySettings.shadowCascades != 2) ? (100f + 900f * num) : (100f + 500f * num)));
		QualitySettings.shadowDistance = shadowDistance;
	}

	private static int ForceOption(int value, int defaultValue, params int[] options)
	{
		if (options == null || options.Length == 0 || !options.Contains(value))
		{
			return defaultValue;
		}
		return value;
	}
}


using Development.Attributes;

[Factory("grass")]
[ResetStaticFields]
public class Grass : ConsoleSystem
{
}


[Factory("halloween")]
public class Halloween : ConsoleSystem
{
	[ServerVar]
	public static bool enabled = false;

	[ServerVar(Help = "Population active on the server, per square km")]
	public static float murdererpopulation = 0f;

	[ServerVar(Help = "Population active on the server, per square km")]
	public static float scarecrowpopulation = 0f;

	[ServerVar(Help = "Scarecrows can throw beancans (Default: true).")]
	public static bool scarecrows_throw_beancans = true;

	[ServerVar(Help = "The delay globally on a server between each time a scarecrow throws a beancan (Default: 8 seconds).")]
	public static float scarecrow_throw_beancan_global_delay = 8f;

	[ServerVar(Help = "Modified damage from beancan explosion vs players (Default: 0.1).")]
	public static float scarecrow_beancan_vs_player_dmg_modifier = 0.1f;

	[ServerVar(Help = "Modifier to how much damage scarecrows take to the body. (Default: 0.25)")]
	public static float scarecrow_body_dmg_modifier = 0.25f;

	[ServerVar(Help = "Stopping distance for destinations set while chasing a target (Default: 0.5)")]
	public static float scarecrow_chase_stopping_distance = 0.5f;
}


[Factory("harmony")]
public class Harmony : ConsoleSystem
{
	[ServerVar(Name = "load")]
	public static void Load(Arg args)
	{
		HarmonyLoader.TryLoadMod(args.GetString(0, ""));
	}

	[ServerVar(Name = "unload")]
	public static void Unload(Arg args)
	{
		HarmonyLoader.TryUnloadMod(args.GetString(0, ""));
	}
}


using UnityEngine;

[Factory("heli")]
public class PatrolHelicopter : ConsoleSystem
{
	private const string path = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";

	[ServerVar]
	public static float lifetimeMinutes = 30f;

	[ServerVar]
	public static int guns = 1;

	[ServerVar]
	public static float bulletDamageScale = 1f;

	[ServerVar]
	public static float bulletAccuracy = 2f;

	[ServerVar]
	public static void drop(Arg arg)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Vector3 pos = ((Component)basePlayer).transform.position;
			Debug.Log((object)("heli called to : " + ((object)(Vector3)(ref pos)/*cast due to .constrained prefix*/).ToString()));
			GameManager server = GameManager.server;
			pos = default(Vector3);
			BaseEntity baseEntity = server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", pos);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).GetComponent<PatrolHelicopterAI>().SetInitialDestination(((Component)basePlayer).transform.position + new Vector3(0f, 10f, 0f), 0f);
				baseEntity.Spawn();
			}
		}
	}

	[ServerVar]
	public static void calltome(Arg arg)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Vector3 pos = ((Component)basePlayer).transform.position;
			Debug.Log((object)("heli called to : " + ((object)(Vector3)(ref pos)/*cast due to .constrained prefix*/).ToString()));
			GameManager server = GameManager.server;
			pos = default(Vector3);
			BaseEntity baseEntity = server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", pos);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).GetComponent<PatrolHelicopterAI>().SetInitialDestination(((Component)basePlayer).transform.position + new Vector3(0f, 10f, 0f));
				baseEntity.Spawn();
			}
		}
	}

	[ServerVar]
	public static void call(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)arg.Player()))
		{
			Debug.Log((object)"Helicopter inbound");
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab");
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.Spawn();
			}
		}
	}

	[ServerVar]
	public static void strafe(Arg arg)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.strafe_target = basePlayer;
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Strafe_Enter(basePlayer);
		}
	}

	[ServerVar]
	public static void orbit(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Orbit_Enter(70f);
		}
	}

	[ServerVar]
	public static void orbitstrafe(Arg arg)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.strafe_target = basePlayer;
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_OrbitStrafe_Enter();
		}
	}

	[ServerVar]
	public static void move(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Move_Enter(((Component)basePlayer).transform.position);
		}
	}

	[ServerVar]
	public static void flee(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Flee_Enter();
		}
	}

	[ServerVar]
	public static void patrol(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Patrol_Enter();
		}
	}

	[ServerVar]
	public static void death(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Death_Enter();
		}
	}

	[ServerVar]
	public static void testpuzzle(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			_ = basePlayer.IsDeveloper;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[Factory("hierarchy")]
public class Hierarchy : ConsoleSystem
{
	private static GameObject currentDir;

	private static Transform[] GetCurrent()
	{
		if ((Object)(object)currentDir == (Object)null)
		{
			return TransformUtil.GetRootObjects().ToArray();
		}
		List<Transform> list = new List<Transform>();
		for (int i = 0; i < currentDir.transform.childCount; i++)
		{
			list.Add(currentDir.transform.GetChild(i));
		}
		return list.ToArray();
	}

	[ServerVar]
	public static void ls(Arg args)
	{
		string text = "";
		string filter = args.GetString(0, "");
		text = ((!Object.op_Implicit((Object)(object)currentDir)) ? (text + "Listing .\n\n") : (text + "Listing " + currentDir.transform.GetRecursiveName() + "\n\n"));
		foreach (Transform item in (from x in GetCurrent()
			where string.IsNullOrEmpty(filter) || ((Object)x).name.Contains(filter)
			select x).Take(40))
		{
			text += $"   {((Object)item).name} [{item.childCount}]\n";
		}
		text += "\n";
		args.ReplyWith(text);
	}

	[ServerVar]
	public static void cd(Arg args)
	{
		if (args.FullString == ".")
		{
			currentDir = null;
			args.ReplyWith("Changed to .");
			return;
		}
		if (args.FullString == "..")
		{
			if (Object.op_Implicit((Object)(object)currentDir))
			{
				currentDir = (Object.op_Implicit((Object)(object)currentDir.transform.parent) ? ((Component)currentDir.transform.parent).gameObject : null);
			}
			currentDir = null;
			if (Object.op_Implicit((Object)(object)currentDir))
			{
				args.ReplyWith("Changed to " + currentDir.transform.GetRecursiveName());
			}
			else
			{
				args.ReplyWith("Changed to .");
			}
			return;
		}
		Transform val = ((IEnumerable<Transform>)GetCurrent()).FirstOrDefault((Func<Transform, bool>)((Transform x) => ((Object)x).name.ToLower() == args.FullString.ToLower()));
		if ((Object)(object)val == (Object)null)
		{
			val = ((IEnumerable<Transform>)GetCurrent()).FirstOrDefault((Func<Transform, bool>)((Transform x) => ((Object)x).name.StartsWith(args.FullString, StringComparison.CurrentCultureIgnoreCase)));
		}
		if (Object.op_Implicit((Object)(object)val))
		{
			currentDir = ((Component)val).gameObject;
			args.ReplyWith("Changed to " + currentDir.transform.GetRecursiveName());
		}
		else
		{
			args.ReplyWith("Couldn't find \"" + args.FullString + "\"");
		}
	}

	[ServerVar]
	public static void del(Arg args)
	{
		if (!args.HasArgs(1))
		{
			return;
		}
		IEnumerable<Transform> enumerable = from x in GetCurrent()
			where ((Object)x).name.ToLower() == args.FullString.ToLower()
			select x;
		if (enumerable.Count() == 0)
		{
			enumerable = from x in GetCurrent()
				where ((Object)x).name.StartsWith(args.FullString, StringComparison.CurrentCultureIgnoreCase)
				select x;
		}
		if (enumerable.Count() == 0)
		{
			args.ReplyWith("Couldn't find  " + args.FullString);
			return;
		}
		foreach (Transform item in enumerable)
		{
			BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
			if (baseEntity.IsValid())
			{
				if (baseEntity.isServer)
				{
					baseEntity.Kill();
				}
			}
			else
			{
				GameManager.Destroy(((Component)item).gameObject);
			}
		}
		args.ReplyWith("Deleted " + enumerable.Count() + " objects");
	}
}


[Factory("input")]
public class Input : ConsoleSystem
{
}


[Factory("instruments")]
public class instruments : ConsoleSystem
{
	public const string InstrumentsFolder = "instruments";
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Newtonsoft.Json;
using Steamworks;
using UnityEngine;

[Factory("inventory")]
public class Inventory : ConsoleSystem
{
	public class SavedLoadout
	{
		public struct SavedItem
		{
			public int id;

			public int amount;

			public ulong skin;

			public int[] containedItems;

			public int blueprintTarget;
		}

		public SavedItem[] belt;

		public SavedItem[] wear;

		public SavedItem[] main;

		public SavedItem[] backpack;

		public int heldItemIndex;

		public SavedLoadout()
		{
		}

		public SavedLoadout(BasePlayer player)
		{
			belt = SaveItems(player.inventory.containerBelt);
			wear = SaveItems(player.inventory.containerWear);
			main = SaveItems(player.inventory.containerMain);
			Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
			if (backpackWithInventory != null)
			{
				backpack = SaveItems(backpackWithInventory.contents);
			}
			heldItemIndex = GetSlotIndex(player);
		}

		public SavedLoadout(PlayerInventoryProperties properties)
		{
			belt = SaveItems(properties.belt);
			wear = SaveItems(properties.wear);
			main = SaveItems(properties.main);
			heldItemIndex = 0;
		}

		private static SavedItem[] SaveItems(ItemContainer itemContainer)
		{
			List<SavedItem> list = new List<SavedItem>();
			for (int i = 0; i < itemContainer.capacity; i++)
			{
				Item slot = itemContainer.GetSlot(i);
				if (slot == null)
				{
					continue;
				}
				SavedItem savedItem = default(SavedItem);
				savedItem.id = slot.info.itemid;
				savedItem.amount = slot.amount;
				savedItem.skin = slot.skin;
				savedItem.blueprintTarget = slot.blueprintTarget;
				SavedItem item = savedItem;
				if (slot.contents != null && slot.contents.itemList != null)
				{
					List<int> list2 = new List<int>();
					foreach (Item item2 in slot.contents.itemList)
					{
						list2.Add(item2.info.itemid);
					}
					item.containedItems = list2.ToArray();
				}
				list.Add(item);
			}
			return list.ToArray();
		}

		private static SavedItem[] SaveItems(List<PlayerInventoryProperties.ItemAmountSkinned> items)
		{
			List<SavedItem> list = new List<SavedItem>();
			foreach (PlayerInventoryProperties.ItemAmountSkinned item2 in items)
			{
				SavedItem savedItem = default(SavedItem);
				savedItem.id = item2.itemid;
				savedItem.amount = (int)item2.amount;
				savedItem.skin = item2.skinOverride;
				SavedItem item = savedItem;
				if (item2.blueprint)
				{
					item.blueprintTarget = item.id;
					item.id = ItemManager.blueprintBaseDef.itemid;
				}
				list.Add(item);
			}
			return list.ToArray();
		}

		public void LoadItemsOnTo(BasePlayer player)
		{
			player.inventory.containerMain.Clear();
			player.inventory.containerBelt.Clear();
			player.inventory.containerWear.Clear();
			ItemManager.DoRemoves();
			LoadItems(belt, player.inventory.containerBelt);
			LoadItems(wear, player.inventory.containerWear);
			LoadItems(main, player.inventory.containerMain);
			if (backpack != null && backpack.Length != 0)
			{
				Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
				if (backpackWithInventory != null)
				{
					backpackWithInventory.contents.Clear();
					LoadItems(backpack, backpackWithInventory.contents);
				}
			}
			EquipItemInSlot(player, heldItemIndex);
			player.inventory.SendSnapshot();
			void LoadItems(SavedItem[] items, ItemContainer container)
			{
				foreach (SavedItem item in items)
				{
					player.inventory.GiveItem(LoadItem(item), container);
				}
			}
		}

		private Item LoadItem(SavedItem item)
		{
			Item item2 = ItemManager.CreateByItemID(item.id, item.amount, item.skin);
			if (item.blueprintTarget != 0)
			{
				item2.blueprintTarget = item.blueprintTarget;
			}
			if (item.containedItems != null && item.containedItems.Length != 0)
			{
				int[] containedItems = item.containedItems;
				foreach (int itemID in containedItems)
				{
					item2.contents.AddItem(ItemManager.FindItemDefinition(itemID), 1, 0uL);
				}
			}
			return item2;
		}
	}

	[ReplicatedVar(Help = "Disables all attire limitations, so NPC clothing and invalid overlaps can be equipped")]
	public static bool disableAttireLimitations;

	private const string LoadoutDirectory = "loadouts";

	[ServerVar]
	public static bool stackable_item_ownership;

	[ServerUserVar(Name = "lighttoggle")]
	public static void lighttoggle_sv(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead() && !basePlayer.IsSleeping() && !basePlayer.InGesture)
		{
			basePlayer.LightToggle();
		}
	}

	[ServerUserVar]
	public static void endloot(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead() && !basePlayer.IsSleeping())
		{
			basePlayer.inventory.loot.Clear();
		}
	}

	[ServerVar(Help = "{item} {amount} {condition} {skin} {container} {slot}")]
	public static void give(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		bool flag = arg.HasArg("--silent", true);
		Item item = ItemManager.CreateByPartialName(arg.GetString(0, ""), 1, arg.GetULong(3, 0uL));
		if (item == null)
		{
			arg.ReplyWith("Invalid Item!");
			return;
		}
		int num = (item.amount = arg.GetInt(1, 1));
		float @float = arg.GetFloat(2, 1f);
		item.conditionNormalized = @float;
		item.OnVirginSpawn();
		item.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		string @string = arg.GetString(4, "");
		int num2 = arg.GetInt(5, -1);
		ItemContainer itemContainer = null;
		switch (@string)
		{
		case "0":
		case "main":
			itemContainer = basePlayer.inventory.containerMain;
			break;
		case "1":
		case "belt":
			itemContainer = basePlayer.inventory.containerBelt;
			break;
		case "2":
		case "wear":
			itemContainer = basePlayer.inventory.containerWear;
			break;
		}
		if (itemContainer == null)
		{
			if (!basePlayer.inventory.GiveItem(item))
			{
				item.Remove();
				arg.ReplyWith("Couldn't give item (inventory full?)");
				return;
			}
		}
		else
		{
			if (num2 != -1)
			{
				Item slot = itemContainer.GetSlot(num2);
				if (slot != null && slot.contents != null)
				{
					itemContainer = slot.contents;
					num2 = -1;
				}
			}
			if (!item.MoveToContainer(itemContainer, num2))
			{
				item.Remove();
				arg.ReplyWith("Couldn't give item (inventory full?)");
				return;
			}
		}
		if (!flag)
		{
			basePlayer.Command("note.inv", item.info.itemid, num);
		}
		Debug.Log((object)("giving " + basePlayer.displayName + " " + num + " x " + item.info.displayName.english));
		if (basePlayer.IsDeveloper)
		{
			if (!flag)
			{
				basePlayer.ChatMessage("you silently gave yourself " + num + " x " + item.info.displayName.english);
			}
			return;
		}
		Chat.Broadcast(basePlayer.displayName + " gave themselves " + num + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
	}

	[ServerVar]
	public static void resetbp(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayer(0);
		if ((Object)(object)basePlayer == (Object)null)
		{
			if (arg.HasArgs(1))
			{
				arg.ReplyWith("Can't find player");
				return;
			}
			basePlayer = arg.Player();
		}
		basePlayer.blueprints.Reset();
	}

	[ServerVar]
	public static void unlockall(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayer(0);
		if ((Object)(object)basePlayer == (Object)null)
		{
			if (arg.HasArgs(1))
			{
				arg.ReplyWith("Can't find player");
				return;
			}
			basePlayer = arg.Player();
		}
		basePlayer.blueprints.UnlockAll();
	}

	[ServerVar]
	public static void giveall(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Item item = null;
		string text = "SERVER";
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null)
		{
			text = basePlayer.displayName;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				item = ItemManager.CreateByPartialName(arg.GetString(0, ""), 1, 0uL);
				if (item == null)
				{
					arg.ReplyWith("Invalid Item!");
					return;
				}
				int num = (item.amount = arg.GetInt(1, 1));
				item.OnVirginSpawn();
				item.SetItemOwnership(text, ItemOwnershipPhrases.SpawnedPhrase);
				if (!current.inventory.GiveItem(item))
				{
					item.Remove();
					arg.ReplyWith("Couldn't give item (inventory full?)");
					continue;
				}
				current.Command("note.inv", item.info.itemid, num);
				Debug.Log((object)(" [ServerVar] giving " + current.displayName + " " + item.amount + " x " + item.info.displayName.english));
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		if (item != null)
		{
			Chat.Broadcast(text + " gave everyone " + item.amount + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
		}
	}

	[ServerVar(Help = "{item} {player} {amount} {skin}")]
	public static void giveto(Arg arg)
	{
		string text = "SERVER";
		if ((Object)(object)arg.Player() != (Object)null)
		{
			text = arg.Player().displayName;
		}
		BasePlayer basePlayer = BasePlayer.Find(arg.GetString(0, ""));
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Couldn't find player!");
			return;
		}
		Item item = ItemManager.CreateByPartialName(arg.GetString(1, ""), 1, arg.GetULong(3, 0uL));
		if (item == null)
		{
			arg.ReplyWith("Invalid Item!");
			return;
		}
		int num = (item.amount = arg.GetInt(2, 1));
		item.OnVirginSpawn();
		item.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		if (!basePlayer.inventory.GiveItem(item))
		{
			item.Remove();
			arg.ReplyWith("Couldn't give item (inventory full?)");
			return;
		}
		basePlayer.Command("note.inv", item.info.itemid, num);
		Debug.Log((object)(" [ServerVar] giving " + basePlayer.displayName + " " + num + " x " + item.info.displayName.english));
		Chat.Broadcast(text + " gave " + basePlayer.displayName + " " + num + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
	}

	[ServerVar(Help = "{itemid} {amount}")]
	public static void giveid(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		Item item = ItemManager.CreateByItemID(arg.GetInt(0, 0), 1, 0uL);
		if (item == null)
		{
			arg.ReplyWith("Invalid Item!");
			return;
		}
		int num = (item.amount = arg.GetInt(1, 1));
		item.OnVirginSpawn();
		item.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		if (!basePlayer.inventory.GiveItem(item))
		{
			item.Remove();
			arg.ReplyWith("Couldn't give item (inventory full?)");
			return;
		}
		basePlayer.Command("note.inv", item.info.itemid, num);
		Debug.Log((object)(" [ServerVar] giving " + basePlayer.displayName + " " + num + " x " + item.info.displayName.english));
		if (basePlayer.IsDeveloper)
		{
			basePlayer.ChatMessage("you silently gave yourself " + num + " x " + item.info.displayName.english);
			return;
		}
		Chat.Broadcast(basePlayer.displayName + " gave themselves " + num + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
	}

	[ServerVar(Help = "{itemid} {amount}")]
	public static void givearm(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		Item item = ItemManager.CreateByItemID(arg.GetInt(0, 0), 1, 0uL);
		if (item == null)
		{
			arg.ReplyWith("Invalid Item!");
			return;
		}
		int num = (item.amount = arg.GetInt(1, 1));
		item.OnVirginSpawn();
		item.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		if (!basePlayer.inventory.GiveItem(item, basePlayer.inventory.containerBelt))
		{
			item.Remove();
			arg.ReplyWith("Couldn't give item (inventory full?)");
			return;
		}
		basePlayer.Command("note.inv", item.info.itemid, num);
		Debug.Log((object)(" [ServerVar] giving " + basePlayer.displayName + " " + item.amount + " x " + item.info.displayName.english));
		if (basePlayer.IsDeveloper)
		{
			basePlayer.ChatMessage("you silently gave yourself " + item.amount + " x " + item.info.displayName.english);
			return;
		}
		Chat.Broadcast(basePlayer.displayName + " gave themselves " + item.amount + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
	}

	[ServerVar(Help = "Set worn items to have maximum armor slots supported")]
	public static void setwornarmorslots(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		int @int = arg.GetInt(0, 4);
		foreach (Item item in basePlayer.inventory.containerWear.itemList)
		{
			ItemModContainerArmorSlot component = ((Component)item.info).GetComponent<ItemModContainerArmorSlot>();
			if ((Object)(object)component != (Object)null)
			{
				component.SetSlotAmount(item, Mathf.Min(@int, component.MaxSlots));
			}
		}
	}

	[ServerVar]
	public static void pipetteid(Arg arg)
	{
		BasePlayer ply = arg.Player();
		int itemId = arg.GetInt(0, 0);
		PooledList<Item> val = Pool.Get<PooledList<Item>>();
		try
		{
			ply.inventory.FindItemsByItemID((List<Item>)(object)val, itemId);
			ulong skinId = arg.GetULong(1, 1uL);
			bool flag = false;
			foreach (Item item in (List<Item>)(object)val)
			{
				if (item.skin == skinId)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemId);
				ply.Command($"give {itemDefinition.shortname} 1 1 {skinId}");
			}
			InvokeHandler.Invoke((Behaviour)(object)ply, (Action)delegate
			{
				ply.Command($"inventory.selectitem {itemId} {skinId}");
			}, 0.2f);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Copies the players inventory to the player in front of them")]
	public static void copyTo(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic) || (Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		BasePlayer basePlayer2 = null;
		if (arg.HasArgs(1) && arg.GetString(0, "").ToLower() != "true")
		{
			basePlayer2 = arg.GetPlayer(0);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				uint uInt = arg.GetUInt(0, 0u);
				basePlayer2 = BasePlayer.FindByID(uInt);
				if ((Object)(object)basePlayer2 == (Object)null)
				{
					basePlayer2 = BasePlayer.FindBot(uInt);
				}
			}
		}
		else
		{
			basePlayer2 = RelationshipManager.GetLookingAtPlayer(basePlayer);
		}
		if (!((Object)(object)basePlayer2 == (Object)null))
		{
			copyTo(basePlayer, basePlayer2);
		}
	}

	public static void copyTo(BasePlayer from, BasePlayer toply)
	{
		toply.inventory.containerBelt.Clear();
		toply.inventory.containerWear.Clear();
		int num = 0;
		foreach (Item item4 in from.inventory.containerBelt.itemList)
		{
			toply.inventory.containerBelt.AddItem(item4.info, item4.amount, item4.skin);
			if (item4.contents != null && !CopyArmorSlots(item4, toply.inventory.containerBelt.itemList[num], toply))
			{
				Item item = toply.inventory.containerBelt.itemList[num];
				foreach (Item item5 in item4.contents.itemList)
				{
					item.contents.AddItem(item5.info, item5.amount, item5.skin);
				}
			}
			num++;
		}
		foreach (Item item6 in from.inventory.containerWear.itemList)
		{
			toply.inventory.containerWear.AddItem(item6.info, item6.amount, item6.skin);
			if (item6.contents == null)
			{
				continue;
			}
			List<Item> itemList = toply.inventory.containerWear.itemList;
			Item item2 = itemList[itemList.Count - 1];
			if (item6.IsBackpack())
			{
				if (item2 == null)
				{
					continue;
				}
				foreach (Item item7 in item6.contents.itemList)
				{
					item2.contents.AddItem(item7.info, item7.amount, item7.skin);
					if (item7.contents == null)
					{
						continue;
					}
					List<Item> itemList2 = item2.contents.itemList;
					Item item3 = itemList2[itemList2.Count - 1];
					if (CopyArmorSlots(item7, item3, toply))
					{
						continue;
					}
					foreach (Item item8 in item7.contents.itemList)
					{
						item3.contents.AddItem(item8.info, item8.amount, item8.skin);
					}
				}
			}
			else
			{
				CopyArmorSlots(item6, item2, toply);
			}
		}
		if (from.IsDeveloper)
		{
			from.ChatMessage("you silently copied items to " + toply.displayName);
		}
		else
		{
			Chat.Broadcast(from.displayName + " copied their inventory to " + toply.displayName, "SERVER", "#eee", 0uL);
		}
	}

	private static bool CopyArmorSlots(Item sourceItem, Item destItem, BasePlayer player)
	{
		if (sourceItem == null)
		{
			return false;
		}
		if (sourceItem.contents == null)
		{
			return false;
		}
		if (destItem == null)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		ItemModContainerArmorSlot itemModContainerArmorSlot = default(ItemModContainerArmorSlot);
		if (!((Component)sourceItem.info).TryGetComponent<ItemModContainerArmorSlot>(ref itemModContainerArmorSlot))
		{
			return false;
		}
		int capacity = sourceItem.contents.capacity;
		if (capacity == 0)
		{
			return false;
		}
		((Component)destItem.info).GetComponent<ItemModContainerArmorSlot>().CreateAtCapacity(capacity, destItem);
		foreach (Item item in sourceItem.contents.itemList)
		{
			destItem.contents.AddItem(item.info, item.amount, item.skin);
		}
		return true;
	}

	[ServerVar(Help = "Deploys a loadout to players in a radius eg. inventory.deployLoadoutInRange testloadout 30")]
	public static void deployLoadoutInRange(Arg arg)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic) || (Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		string @string = arg.GetString(0, "");
		if (!LoadLoadout(@string, out var so))
		{
			arg.ReplyWith("Can't find loadout: " + @string);
			return;
		}
		float @float = arg.GetFloat(1, 0f);
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)basePlayer).transform.position, @float, list, 131072, (QueryTriggerInteraction)2);
		int num = 0;
		foreach (BasePlayer item in list)
		{
			if (!((Object)(object)item == (Object)(object)basePlayer) && !item.isClient)
			{
				so.LoadItemsOnTo(item);
				num++;
			}
		}
		arg.ReplyWith($"Applied loadout {@string} to {num} players");
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar(Help = "Deploys the given loadout to a target player. eg. inventory.deployLoadout testloadout jim")]
	public static void deployLoadout(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic))
		{
			string @string = arg.GetString(0, "");
			BasePlayer basePlayer2 = (string.IsNullOrEmpty(arg.GetString(1, "")) ? null : arg.GetPlayerOrSleeperOrBot(1));
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				basePlayer2 = basePlayer;
			}
			SavedLoadout so;
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				arg.ReplyWith("Could not find player " + arg.GetString(1, "") + " and no local player available");
			}
			else if (LoadLoadout(@string, out so))
			{
				so.LoadItemsOnTo(basePlayer2);
				arg.ReplyWith("Deployed loadout " + @string + " to " + basePlayer2.displayName);
			}
			else
			{
				arg.ReplyWith("Could not find loadout " + @string);
			}
		}
	}

	[ServerVar(Help = "Clears the inventory of a target player. eg. inventory.clearInventory jim. Can take container names as arguments: --belt --wear --backpack")]
	public static void clearInventory(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic))
		{
			return;
		}
		arg.TryRemoveKeyBindEventArgs();
		BasePlayer basePlayer2 = basePlayer;
		StringBuilder stringBuilder = new StringBuilder();
		bool flag = false;
		if (arg.Args == null || arg.Args.Length == 0)
		{
			flag = true;
		}
		else
		{
			int num = 0;
			basePlayer2 = arg.GetPlayerOrSleeperOrBot(0);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				switch (arg.GetString(0, "").ToLower())
				{
				case "--main":
				case "--belt":
				case "--wear":
				case "--backpack":
					break;
				default:
					arg.ReplyWith("Could not find player '" + arg.GetString(0, "") + "'");
					return;
				}
				basePlayer2 = basePlayer;
				num = 0;
			}
			else
			{
				num = 1;
			}
			if (num == 1 && arg.Args.Length == 1)
			{
				flag = true;
			}
			else
			{
				bool flag2 = false;
				bool flag3 = false;
				bool flag4 = false;
				bool flag5 = false;
				for (int i = num; i < arg.Args.Length; i++)
				{
					switch (arg.GetString(i, "").ToLower())
					{
					case "--main":
						flag2 = true;
						break;
					case "--belt":
						flag3 = true;
						break;
					case "--wear":
						flag4 = true;
						break;
					case "--backpack":
						flag5 = true;
						break;
					}
				}
				if (flag2)
				{
					basePlayer2.inventory.containerMain.Clear();
					stringBuilder.AppendLine("Cleared " + basePlayer2.displayName + "'s main inventory");
				}
				if (flag3)
				{
					basePlayer2.inventory.containerBelt.Clear();
					stringBuilder.AppendLine("Cleared " + basePlayer2.displayName + "'s belt");
				}
				if (flag4)
				{
					basePlayer2.inventory.containerWear.Clear();
					stringBuilder.AppendLine("Cleared " + basePlayer2.displayName + "'s clothings");
				}
				if (flag5 && basePlayer2.inventory.GetContainer(PlayerInventory.Type.BackpackContents) != null)
				{
					basePlayer2.inventory.GetContainer(PlayerInventory.Type.BackpackContents).Clear();
					stringBuilder.AppendLine("Cleared " + basePlayer2.displayName + "'s backpack");
				}
			}
		}
		if (flag)
		{
			basePlayer2.inventory.containerMain.Clear();
			basePlayer2.inventory.containerBelt.Clear();
			basePlayer2.inventory.containerWear.Clear();
			basePlayer2.inventory.GetContainer(PlayerInventory.Type.BackpackContents)?.Clear();
			stringBuilder.AppendLine(basePlayer2.displayName + "'s whole inventory cleared");
		}
		basePlayer2.SV_ClothingChanged();
		arg.ReplyWith(stringBuilder.ToString());
		ItemManager.DoRemoves();
	}

	private static string GetLoadoutPath(string loadoutName)
	{
		return Server.GetServerFolder("loadouts") + "/" + loadoutName + ".ldt";
	}

	[ServerVar(Help = "Saves the current equipped loadout of the calling player. eg. inventory.saveLoadout loaduoutname")]
	public static void saveloadout(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic))
		{
			string @string = arg.GetString(0, "");
			string contents = JsonConvert.SerializeObject((object)new SavedLoadout(basePlayer), (Formatting)1);
			string loadoutPath = GetLoadoutPath(@string);
			File.WriteAllText(loadoutPath, contents);
			arg.ReplyWith("Saved loadout to " + loadoutPath);
		}
	}

	public static bool LoadLoadout(string name, out SavedLoadout so)
	{
		PlayerInventoryProperties inventoryConfig = PlayerInventoryProperties.GetInventoryConfig(name);
		if (inventoryConfig != null)
		{
			Debug.Log((object)"Found builtin config!");
			so = new SavedLoadout(inventoryConfig);
			return true;
		}
		so = new SavedLoadout();
		string loadoutPath = GetLoadoutPath(name);
		if (!File.Exists(loadoutPath))
		{
			return false;
		}
		so = JsonConvert.DeserializeObject<SavedLoadout>(File.ReadAllText(loadoutPath));
		if (so == null)
		{
			return false;
		}
		return true;
	}

	[ServerVar(Help = "Prints all saved inventory loadouts")]
	public static void listloadouts(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic))
		{
			return;
		}
		string serverFolder = Server.GetServerFolder("loadouts");
		StringBuilder stringBuilder = new StringBuilder();
		foreach (string item in Directory.EnumerateFiles(serverFolder))
		{
			stringBuilder.AppendLine(item);
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	[ClientVar]
	public static void defs(Arg arg)
	{
		if (SteamInventory.Definitions == null)
		{
			arg.ReplyWith("no definitions");
			return;
		}
		if (SteamInventory.Definitions.Length == 0)
		{
			arg.ReplyWith("0 definitions");
			return;
		}
		string[] array = SteamInventory.Definitions.Select((InventoryDef x) => x.Name).ToArray();
		arg.ReplyWith((object)array);
	}

	[ServerVar]
	[ClientVar]
	public static void reloaddefs(Arg arg)
	{
		SteamInventory.LoadItemDefinitions();
	}

	[ServerVar]
	public static void equipslottarget(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic) && !((Object)(object)basePlayer == (Object)null))
		{
			BasePlayer lookingAtPlayer = RelationshipManager.GetLookingAtPlayer(basePlayer);
			if (!((Object)(object)lookingAtPlayer == (Object)null))
			{
				int @int = arg.GetInt(0, 0);
				EquipItemInSlot(lookingAtPlayer, @int);
				arg.ReplyWith($"Equipped slot {@int} on player {lookingAtPlayer.displayName}");
			}
		}
	}

	[ServerVar]
	public static void equipslot(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic) || (Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		BasePlayer basePlayer2 = null;
		if (arg.HasArgs(2))
		{
			basePlayer2 = arg.GetPlayer(1);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				uint uInt = arg.GetUInt(1, 0u);
				basePlayer2 = BasePlayer.FindByID(uInt);
				if ((Object)(object)basePlayer2 == (Object)null)
				{
					basePlayer2 = BasePlayer.FindBot(uInt);
				}
			}
		}
		if (!((Object)(object)basePlayer2 == (Object)null))
		{
			int @int = arg.GetInt(0, 0);
			EquipItemInSlot(basePlayer2, @int);
			Debug.Log((object)$"Equipped slot {@int} on player {basePlayer2.displayName}");
		}
	}

	public static void EquipItemInSlot(BasePlayer player, int slot)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		ItemId itemID = default(ItemId);
		for (int i = 0; i < player.inventory.containerBelt.itemList.Count; i++)
		{
			if (player.inventory.containerBelt.itemList[i] != null && i == slot)
			{
				itemID = player.inventory.containerBelt.itemList[i].uid;
				break;
			}
		}
		player.UpdateActiveItem(itemID);
	}

	private static int GetSlotIndex(BasePlayer player)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (player.GetActiveItem() == null)
		{
			return -1;
		}
		ItemId uid = player.GetActiveItem().uid;
		for (int i = 0; i < player.inventory.containerBelt.itemList.Count; i++)
		{
			if (player.inventory.containerBelt.itemList[i] != null && player.inventory.containerBelt.itemList[i].uid == uid)
			{
				return i;
			}
		}
		return -1;
	}

	[ServerVar]
	public static void giveBp(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindDefinitionByPartialName(arg.GetString(0, ""));
		if ((Object)(object)itemDefinition == (Object)null)
		{
			arg.ReplyWith("Could not find item: " + arg.GetString(0, ""));
			return;
		}
		if ((Object)(object)itemDefinition.Blueprint == (Object)null)
		{
			arg.ReplyWith(itemDefinition.shortname + " has no blueprint!");
			return;
		}
		Item item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);
		item.blueprintTarget = itemDefinition.itemid;
		item.OnVirginSpawn();
		if (!basePlayer.inventory.GiveItem(item))
		{
			item.Remove();
			arg.ReplyWith("Couldn't give item (inventory full?)");
			return;
		}
		basePlayer.Command("note.inv", item.info.itemid, 1);
		Debug.Log((object)("giving " + basePlayer.displayName + " 1 x " + item.blueprintTargetDef.shortname + " blueprint"));
		if (basePlayer.IsDeveloper)
		{
			basePlayer.ChatMessage("you silently gave yourself 1 x " + item.blueprintTargetDef.shortname + " blueprint");
		}
		else
		{
			Chat.Broadcast(basePlayer.displayName + " gave themselves 1 x " + item.blueprintTargetDef.shortname + " blueprint", "SERVER", "#eee", 0uL);
		}
	}

	[ServerVar]
	public static void set_item_image(Arg arg)
	{
		Item activeItem = arg.Player().GetActiveItem();
		if (activeItem == null)
		{
			arg.ReplyWith("No active item");
			return;
		}
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("No image id provided");
			return;
		}
		uint num = (activeItem.iconImageId = arg.GetUInt(0, 0u));
		activeItem.MarkDirty();
		arg.ReplyWith($"Set image id to {num}");
	}

	[ServerVar(Help = "Add ownership to item")]
	public static void addownership(Arg args)
	{
		Item activeItem = args.Player().GetActiveItem();
		if (activeItem == null)
		{
			args.ReplyWith("You must be holding an item to use this command");
			return;
		}
		if (!args.HasArgs(3))
		{
			args.ReplyWith("Usage: addownership {username} {reason} {amount}");
			return;
		}
		string @string = args.GetString(0, "");
		string string2 = args.GetString(1, "");
		int @int = args.GetInt(2, 1);
		activeItem.AddItemOwnership(@string, string2, @int);
		args.ReplyWith($"Added '{@int}' ownership to item");
	}

	[ServerVar(Help = "Reduce ownership to item to allow new ownership to be added")]
	public static void reduceownership(Arg args)
	{
		Item activeItem = args.Player().GetActiveItem();
		if (activeItem == null)
		{
			args.ReplyWith("You must be holding an item to use this command");
			return;
		}
		if (!args.HasArgs(1))
		{
			args.ReplyWith("Usage: reduceownership {amount}");
			return;
		}
		int @int = args.GetInt(0, 1);
		activeItem.ReduceItemOwnership(@int);
		args.ReplyWith($"Reduced ownership of item by '{@int}'");
	}

	[ServerVar(Help = "Reduce ownership to item to allow new ownership to be added")]
	public static void convertownership(Arg args)
	{
		Item activeItem = args.Player().GetActiveItem();
		if (activeItem == null)
		{
			args.ReplyWith("You must be holding an item to use this command");
			return;
		}
		if (!args.HasArgs(3))
		{
			args.ReplyWith("Usage: convertownership {username} {reason} {amount}");
			return;
		}
		string @string = args.GetString(0, "");
		string string2 = args.GetString(1, "");
		int @int = args.GetInt(2, 1);
		activeItem.ReduceItemOwnership(@int);
		activeItem.AddItemOwnership(@string, string2, @int);
		args.ReplyWith($"Converted '{@int}' ownership of item to '{@string}'");
	}
}


using System.Collections.Generic;

public class SavedLoadout
{
	public struct SavedItem
	{
		public int id;

		public int amount;

		public ulong skin;

		public int[] containedItems;

		public int blueprintTarget;
	}

	public SavedItem[] belt;

	public SavedItem[] wear;

	public SavedItem[] main;

	public SavedItem[] backpack;

	public int heldItemIndex;

	public SavedLoadout()
	{
	}

	public SavedLoadout(BasePlayer player)
	{
		belt = SaveItems(player.inventory.containerBelt);
		wear = SaveItems(player.inventory.containerWear);
		main = SaveItems(player.inventory.containerMain);
		Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
		if (backpackWithInventory != null)
		{
			backpack = SaveItems(backpackWithInventory.contents);
		}
		heldItemIndex = GetSlotIndex(player);
	}

	public SavedLoadout(PlayerInventoryProperties properties)
	{
		belt = SaveItems(properties.belt);
		wear = SaveItems(properties.wear);
		main = SaveItems(properties.main);
		heldItemIndex = 0;
	}

	private static SavedItem[] SaveItems(ItemContainer itemContainer)
	{
		List<SavedItem> list = new List<SavedItem>();
		for (int i = 0; i < itemContainer.capacity; i++)
		{
			Item slot = itemContainer.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			SavedItem savedItem = default(SavedItem);
			savedItem.id = slot.info.itemid;
			savedItem.amount = slot.amount;
			savedItem.skin = slot.skin;
			savedItem.blueprintTarget = slot.blueprintTarget;
			SavedItem item = savedItem;
			if (slot.contents != null && slot.contents.itemList != null)
			{
				List<int> list2 = new List<int>();
				foreach (Item item2 in slot.contents.itemList)
				{
					list2.Add(item2.info.itemid);
				}
				item.containedItems = list2.ToArray();
			}
			list.Add(item);
		}
		return list.ToArray();
	}

	private static SavedItem[] SaveItems(List<PlayerInventoryProperties.ItemAmountSkinned> items)
	{
		List<SavedItem> list = new List<SavedItem>();
		foreach (PlayerInventoryProperties.ItemAmountSkinned item2 in items)
		{
			SavedItem savedItem = default(SavedItem);
			savedItem.id = item2.itemid;
			savedItem.amount = (int)item2.amount;
			savedItem.skin = item2.skinOverride;
			SavedItem item = savedItem;
			if (item2.blueprint)
			{
				item.blueprintTarget = item.id;
				item.id = ItemManager.blueprintBaseDef.itemid;
			}
			list.Add(item);
		}
		return list.ToArray();
	}

	public void LoadItemsOnTo(BasePlayer player)
	{
		player.inventory.containerMain.Clear();
		player.inventory.containerBelt.Clear();
		player.inventory.containerWear.Clear();
		ItemManager.DoRemoves();
		LoadItems(belt, player.inventory.containerBelt);
		LoadItems(wear, player.inventory.containerWear);
		LoadItems(main, player.inventory.containerMain);
		if (backpack != null && backpack.Length != 0)
		{
			Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
			if (backpackWithInventory != null)
			{
				backpackWithInventory.contents.Clear();
				LoadItems(backpack, backpackWithInventory.contents);
			}
		}
		EquipItemInSlot(player, heldItemIndex);
		player.inventory.SendSnapshot();
		void LoadItems(SavedItem[] items, ItemContainer container)
		{
			foreach (SavedItem item in items)
			{
				player.inventory.GiveItem(LoadItem(item), container);
			}
		}
	}

	private Item LoadItem(SavedItem item)
	{
		Item item2 = ItemManager.CreateByItemID(item.id, item.amount, item.skin);
		if (item.blueprintTarget != 0)
		{
			item2.blueprintTarget = item.blueprintTarget;
		}
		if (item.containedItems != null && item.containedItems.Length != 0)
		{
			int[] containedItems = item.containedItems;
			foreach (int itemID in containedItems)
			{
				item2.contents.AddItem(ItemManager.FindItemDefinition(itemID), 1, 0uL);
			}
		}
		return item2;
	}
}


public struct SavedItem
{
	public int id;

	public int amount;

	public ulong skin;

	public int[] containedItems;

	public int blueprintTarget;
}


[Factory("layer")]
public class Layer : ConsoleSystem
{
}


[Factory("legs")]
public class Legs : ConsoleSystem
{
}


[Factory("lerp")]
public class Lerp : ConsoleSystem
{
}


[Factory("lod")]
public class LOD : ConsoleSystem
{
}


using Facepunch;

public class Manifest
{
	[ServerVar]
	[ClientVar]
	public static object PrintManifest()
	{
		return Application.Manifest;
	}

	[ServerVar]
	[ClientVar]
	public static object PrintManifestRaw()
	{
		return Manifest.Contents;
	}
}


using System;
using System.IO;
using Unity.Profiling.Memory;

[Factory("memsnap")]
public class MemSnap : ConsoleSystem
{
	private static string NeedProfileFolder()
	{
		string path = "profile";
		if (!Directory.Exists(path))
		{
			return Directory.CreateDirectory(path).FullName;
		}
		return new DirectoryInfo(path).FullName;
	}

	[ClientVar]
	[ServerVar]
	public static void managed(Arg arg)
	{
		MemoryProfiler.TakeSnapshot(NeedProfileFolder() + "/memdump-" + DateTime.Now.ToString("MM-dd-yyyy-h-mm-ss") + ".snap", (Action<string, bool>)null, (CaptureFlags)1);
	}

	[ClientVar]
	[ServerVar]
	public static void native(Arg arg)
	{
		MemoryProfiler.TakeSnapshot(NeedProfileFolder() + "/memdump-" + DateTime.Now.ToString("MM-dd-yyyy-h-mm-ss") + ".snap", (Action<string, bool>)null, (CaptureFlags)2);
	}

	[ClientVar]
	[ServerVar]
	public static void full(Arg arg)
	{
		MemoryProfiler.TakeSnapshot(NeedProfileFolder() + "/memdump-" + DateTime.Now.ToString("MM-dd-yyyy-h-mm-ss") + ".snap", (Action<string, bool>)null, (CaptureFlags)31);
	}
}


[Factory("mesh")]
public class Mesh : ConsoleSystem
{
}


using System.Text;
using UnityEngine;

[Factory("music")]
public class Music : ConsoleSystem
{
	[ClientVar]
	public static bool enabled = true;

	[ClientVar]
	public static int songGapMin = 240;

	[ClientVar]
	public static int songGapMax = 480;

	[ClientVar]
	public static void info(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		if ((Object)(object)SingletonComponent<MusicManager>.Instance == (Object)null)
		{
			stringBuilder.Append("No music manager was found");
		}
		else
		{
			stringBuilder.Append("Current music info: ");
			stringBuilder.AppendLine();
			stringBuilder.Append("  theme: " + (object)SingletonComponent<MusicManager>.Instance.currentTheme);
			stringBuilder.AppendLine();
			stringBuilder.Append("  intensity: " + SingletonComponent<MusicManager>.Instance.intensity);
			stringBuilder.AppendLine();
			stringBuilder.Append("  next music: " + SingletonComponent<MusicManager>.Instance.nextMusic);
			stringBuilder.AppendLine();
			stringBuilder.Append("  current time: " + Time.time);
			stringBuilder.AppendLine();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}
}


[Factory("net")]
public class Net : ConsoleSystem
{
	[ServerVar]
	public static bool visdebug = false;

	[ClientVar]
	public static bool debug = false;

	[ServerVar]
	public static int visibilityRadiusFarOverride = -1;

	[ServerVar]
	public static int visibilityRadiusNearOverride = -1;

	[ServerVar(Name = "global_networked_bases")]
	public static bool globalNetworkedBases = true;

	[ServerVar(Help = "Toggle printing time taken to send all global entities to client when they connect")]
	public static bool global_network_debug = false;

	[ServerVar(Help = "Toggle checking network group bounds whenever an entity changes its network group")]
	public static bool network_group_debug = false;

	[ServerVar(Help = "(default) true = only broadcast to clients with global networking enabled, false = broadcast to every client regardless")]
	public static bool limit_global_update_broadcast = true;
}


[Factory("netgraph")]
public class Netgraph : ConsoleSystem
{
}


using System;
using Facepunch;
using ProtoBuf.Nexus;
using UnityEngine;

[Factory("nexus")]
public class Nexus : ConsoleSystem
{
	public static readonly Phrase RedirectPhrase = new Phrase("loading.redirect", "Switching servers");

	private const string DefaultEndpoint = "https://api.facepunch.com/api/nexus/";

	[ReplicatedVar(Help = "URL endpoint to use for the Nexus API", Default = "https://api.facepunch.com/api/nexus/")]
	public static string endpoint = "https://api.facepunch.com/api/nexus/";

	[ServerVar(Clientside = true)]
	public static bool logging = true;

	[ServerVar]
	public static string secretKey = "";

	[ServerVar]
	public static string zoneController = "basic";

	[ServerVar(Help = "Time in seconds to allow the server to process nexus messages before re-sending (requires restart)")]
	public static int messageLockDuration = 5;

	[ServerVar(Help = "Maximum amount of time in seconds that transfers should be cached before auto-saving")]
	public static int transferFlushTime = 60;

	[ServerVar(Help = "How far away islands should be spawned, as a factor of the map size")]
	public static float islandSpawnDistance = 1.5f;

	[ServerVar(Help = "Default distance between zones to allow boat travel, if map.contactRadius isn't set in the nexus (uses normalized coordinates)")]
	public static float defaultZoneContactRadius = 0.33f;

	[ServerVar(Help = "Time offset in hours from the nexus clock")]
	public static float timeOffset = 0f;

	[ServerVar(Help = "Multiplier for nexus RPC timeout durations in case we expect different latencies")]
	public static float rpcTimeoutMultiplier = 1f;

	[ServerVar(Help = "Time in seconds to keep players in the loading state before going to sleep")]
	public static float loadingTimeout = 900f;

	[ServerVar(Help = "Time in seconds to wait between server status pings")]
	public static float pingInterval = 30f;

	[ServerVar(Help = "Maximum time in seconds to keep transfer protection enabled on entities")]
	public static float protectionDuration = 300f;

	[ServerVar(Help = "Maximum duration in seconds to batch clan chat messages to send to other servers on the nexus")]
	public static float clanClatBatchDuration = 1f;

	[ServerVar(Help = "Interval in seconds to broadcast the player manifest to other servers on the nexus")]
	public static float playerManifestInterval = 30f;

	[ServerVar(Help = "Scale of the map to render and upload to the nexus")]
	public static float mapImageScale = 0.5f;

	[ServerVar]
	public static void transfer(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
			return;
		}
		string text = arg.GetString(0, "")?.Trim();
		if (string.IsNullOrWhiteSpace(text))
		{
			arg.ReplyWith("Usage: nexus.transfer <target_zone>");
			return;
		}
		if (string.Equals(text, NexusServer.ZoneKey, StringComparison.InvariantCultureIgnoreCase))
		{
			arg.ReplyWith("You're already on the target zone");
			return;
		}
		BasePlayer basePlayer = arg.Connection.player as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Must be run as a player");
		}
		else
		{
			NexusServer.TransferEntity(basePlayer, text, "console", includeFerry: false);
		}
	}

	[ServerVar]
	public static void refreshislands(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
		}
		else
		{
			NexusServer.UpdateIslands();
		}
	}

	[ServerVar]
	public static void ping(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
			return;
		}
		string @string = arg.GetString(0, "");
		if (string.IsNullOrWhiteSpace(@string))
		{
			arg.ReplyWith("Usage: nexus.ping <target_zone>");
		}
		else
		{
			SendPing(arg.Player(), @string);
		}
		static async void SendPing(BasePlayer requester, string to)
		{
			Request val = Pool.Get<Request>();
			val.ping = Pool.Get<PingRequest>();
			float startTime = Time.realtimeSinceStartup;
			try
			{
				await NexusServer.ZoneRpc(to, val);
				float num = Time.realtimeSinceStartup - startTime;
				requester?.ConsoleMessage($"Ping took {num:F3}s");
			}
			catch (Exception arg2)
			{
				requester?.ConsoleMessage($"Failed to ping zone {to}: {arg2}");
			}
		}
	}

	[ServerVar]
	public static void broadcast_ping(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
		}
		else
		{
			SendBroadcastPing(arg.Player());
		}
		static async void SendBroadcastPing(BasePlayer requester)
		{
			Request val = Pool.Get<Request>();
			val.ping = Pool.Get<PingRequest>();
			float startTime = Time.realtimeSinceStartup;
			try
			{
				using NexusRpcResult nexusRpcResult = await NexusServer.BroadcastRpc(val);
				float num = Time.realtimeSinceStartup - startTime;
				string arg2 = string.Join(", ", nexusRpcResult.Responses.Keys);
				requester?.ConsoleMessage($"Broadcast ping took {num:F3}s, response received from zones: {arg2}");
			}
			catch (Exception arg3)
			{
				requester?.ConsoleMessage($"Failed to broadcast ping: {arg3}");
			}
		}
	}

	[ServerVar]
	public static void playeronline(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
			return;
		}
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt == 0L)
		{
			arg.ReplyWith("Usage: nexus.playeronline <steamID64>");
			return;
		}
		bool flag = NexusServer.IsOnline(uInt);
		arg.ReplyWith(flag ? "Online" : "Offline");
	}

	[ServerVar(Help = "Reupload the map image to the nexus. Normally happens automatically at server boot. WARNING: This will lag the server!")]
	public static void uploadmap(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
		}
		else
		{
			NexusServer.UploadMapImage(force: true);
		}
	}
}


[Factory("note")]
public class Note : ConsoleSystem
{
}


[Factory("npc")]
public class NPC_ConVars : ConsoleSystem
{
	[ReplicatedVar]
	public static bool vendor_minicopter_enabled = true;

	[ReplicatedVar]
	public static bool vendor_attack_heli_enabled = true;

	[ReplicatedVar]
	public static bool vendor_scrap_heli_enabled = true;

	[ReplicatedVar]
	public static bool vendor_hab_enabled = true;

	[ReplicatedVar]
	public static bool vendor_rowboat_enabled = true;

	[ReplicatedVar]
	public static bool vendor_rhib_enabled = true;

	[ReplicatedVar]
	public static bool vendor_sub_solo_enabled = true;

	[ReplicatedVar]
	public static bool vendor_sub_duo_enabled = true;
}


[Factory("particle")]
public class Particle : ConsoleSystem
{
}


public static class party
{
	[ServerVar]
	public static int maxpartyspawnattempts = 50;

	[ServerVar]
	public static int maxpartyspawndistance = 100;

	[ServerVar]
	public static bool nearbypartyspawns = true;
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using UnityEngine;

[Factory("physics")]
public class Physics : ConsoleSystem
{
	private class PhysxCell
	{
		public Bounds Bounds;

		public Vector2i GridPosition;

		public int Id;

		public List<Collider> Colliders;
	}

	[ServerVar(Help = "The collision detection mode that dropped items and corpses should use")]
	public static int droppedmode = 2;

	[ServerVar(Help = "Send effects to clients when physics objects collide")]
	public static bool sendeffects = true;

	[ServerVar]
	public static bool groundwatchdebug = false;

	[ServerVar]
	public static int groundwatchfails = 1;

	[ServerVar]
	public static float groundwatchdelay = 0.1f;

	[ServerVar(Help = "The collision detection mode that server-side ragdolls should use")]
	public static int serverragdollmode = 3;

	private const float baseGravity = -9.81f;

	private static bool _serversideragdolls = false;

	[ServerVar]
	public static float towingmaxlinearaccelfromjoint = 40f;

	[ServerVar]
	public static bool allowplayertempragdoll = true;

	[ServerVar]
	public static bool allowhorsetempragdoll = true;

	[ClientVar]
	[ServerVar]
	public static bool batchsynctransforms = true;

	private static bool _treecollision = true;

	private static Bounds _currentBounds;

	public static Bounds DeepSeaDisabledBounds;

	public static Bounds DeepSeaEnabledBounds;

	[ServerVar]
	public static float bouncethreshold
	{
		get
		{
			return Physics.bounceThreshold;
		}
		set
		{
			Physics.bounceThreshold = value;
		}
	}

	[ServerVar]
	public static float sleepthreshold
	{
		get
		{
			return Physics.sleepThreshold;
		}
		set
		{
			Physics.sleepThreshold = value;
		}
	}

	[ServerVar(Help = "The default solver iteration count permitted for any rigid bodies (default 7). Must be positive")]
	public static int solveriterationcount
	{
		get
		{
			return Physics.defaultSolverIterations;
		}
		set
		{
			Physics.defaultSolverIterations = value;
		}
	}

	[ReplicatedVar(Help = "Gravity multiplier", Default = "1.0")]
	public static float gravity
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			return Physics.gravity.y / -9.81f;
		}
		set
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			Physics.gravity = new Vector3(0f, value * -9.81f, 0f);
		}
	}

	[ReplicatedVar(Help = "Do ragdoll physics calculations on the server, or use the old client-side system", Saved = true, ShowInAdminUI = true)]
	public static bool serversideragdolls
	{
		get
		{
			return _serversideragdolls;
		}
		set
		{
			_serversideragdolls = value;
			Physics.IgnoreLayerCollision(9, 13, !_serversideragdolls);
			Physics.IgnoreLayerCollision(9, 11, !_serversideragdolls);
			Physics.IgnoreLayerCollision(9, 28, !_serversideragdolls);
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool autosynctransforms
	{
		get
		{
			return Physics.autoSyncTransforms;
		}
		set
		{
			Physics.autoSyncTransforms = value;
		}
	}

	[ReplicatedVar(Help = "Do players and vehicles collide with trees?", Saved = true, ShowInAdminUI = true)]
	public static bool treecollision
	{
		get
		{
			return _treecollision;
		}
		set
		{
			_treecollision = value;
			Physics.IgnoreLayerCollision(15, 30, !_treecollision);
			Physics.IgnoreLayerCollision(12, 30, !_treecollision);
		}
	}

	internal static void ApplyDropped(Rigidbody rigidBody)
	{
		if (droppedmode <= 0)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)0;
		}
		if (droppedmode == 1)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)1;
		}
		if (droppedmode == 2)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)2;
		}
		if (droppedmode >= 3)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)3;
		}
	}

	[ServerVar]
	public static void print_colliders_per_cell(Arg arg)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		List<PhysxCell> collidersPerBroadphaseCell = GetCollidersPerBroadphaseCell();
		if (collidersPerBroadphaseCell.Count == 0)
		{
			arg.ReplyWith("No colliders found");
		}
		int num = collidersPerBroadphaseCell.Sum((PhysxCell x) => x.Colliders.Count);
		StringBuilder stringBuilder = new StringBuilder();
		PhysxCell[] array = collidersPerBroadphaseCell.OrderByDescending((PhysxCell x) => x.Colliders.Count).ToArray();
		stringBuilder.AppendLine($"Found {num} in {array.Length} cells, cell size {((Bounds)(ref array[0].Bounds)).size}");
		PhysxCell[] array2 = array;
		foreach (PhysxCell physxCell in array2)
		{
			if (physxCell.Colliders.Count != 0)
			{
				stringBuilder.AppendLine($"Id: {physxCell.Id} Position: {physxCell.GridPosition} Center: {((Bounds)(ref physxCell.Bounds)).center} Count: {physxCell.Colliders.Count}");
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void print_colliders_per_prefab(Arg arg)
	{
		ICollection<Collider> collection = null;
		int cellId = arg.GetInt(0, -1);
		if (cellId >= 0 && cellId < 256)
		{
			PhysxCell physxCell = GetCollidersPerBroadphaseCell().FirstOrDefault((PhysxCell x) => x.Id == cellId);
			if (physxCell == null)
			{
				arg.ReplyWith($"Cell Id '{cellId}' not found");
				return;
			}
			collection = physxCell.Colliders;
		}
		if (collection == null)
		{
			collection = GetAllColliders();
		}
		Dictionary<string, int> dictionary = new Dictionary<string, int>();
		foreach (Collider item in collection)
		{
			BaseEntity baseEntity = item.ToBaseEntity();
			string text = "NULL";
			text = ((!((Object)(object)baseEntity == (Object)null) && !baseEntity.IsDestroyed) ? baseEntity.ShortPrefabName : ((Object)item).name);
			dictionary.TryGetValue(text, out var value);
			dictionary[text] = value + 1;
		}
		StringBuilder stringBuilder = new StringBuilder();
		if (collection.Count == 0)
		{
			Debug.Log((object)"No colliders found");
		}
		stringBuilder.AppendLine($"Found {collection.Count} colliders in {dictionary.Count} unique prefabs");
		foreach (KeyValuePair<string, int> item2 in dictionary.OrderByDescending((KeyValuePair<string, int> x) => x.Value))
		{
			stringBuilder.AppendLine($"Entity: {item2.Key} Count: {item2.Value}");
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	private static ICollection<Collider> GetAllColliders()
	{
		return (from collider in Object.FindObjectsByType<Collider>((FindObjectsInactive)0, (FindObjectsSortMode)0)
			where (Object)(object)collider != (Object)null && (Object)(object)((Component)collider).transform != (Object)null && collider.enabled
			select collider).ToArray();
	}

	private static List<PhysxCell> GetCollidersPerBroadphaseCell()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		ICollection<Collider> allColliders = GetAllColliders();
		int subdivisions = 16;
		Vector3 cellSize = new Vector3(((Bounds)(ref _currentBounds)).size.x / (float)subdivisions, ((Bounds)(ref _currentBounds)).size.y, ((Bounds)(ref _currentBounds)).size.z / (float)subdivisions);
		int num = 0;
		Dictionary<Vector2i, List<Collider>> dictionary = new Dictionary<Vector2i, List<Collider>>();
		foreach (Collider item in allColliders)
		{
			if ((Object)(object)item == (Object)null || (Object)(object)((Component)item).transform == (Object)null || !item.enabled)
			{
				continue;
			}
			Vector2i physxCell = GetPhysxCell(((Component)item).transform.position, cellSize);
			if (physxCell.x < 0 || physxCell.y < 0 || physxCell.x >= subdivisions || physxCell.y >= subdivisions)
			{
				num++;
				continue;
			}
			_ = subdivisions;
			if (!dictionary.TryGetValue(physxCell, out var value))
			{
				value = (dictionary[physxCell] = new List<Collider>());
			}
			value.Add(item);
		}
		return dictionary.Select((KeyValuePair<Vector2i, List<Collider>> x) => new PhysxCell
		{
			GridPosition = x.Key,
			Bounds = new Bounds(((Bounds)(ref _currentBounds)).min + new Vector3((float)x.Key.x * cellSize.x, ((Bounds)(ref _currentBounds)).size.y / 2f, (float)x.Key.y * cellSize.z), cellSize),
			Id = x.Key.x + x.Key.y * subdivisions,
			Colliders = x.Value
		}).ToList();
	}

	private static Vector2i GetPhysxCell(Vector3 position, Vector3 cellSize)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.FloorToInt((position.x - ((Bounds)(ref _currentBounds)).min.x) / cellSize.x);
		int num2 = Mathf.FloorToInt((position.z - ((Bounds)(ref _currentBounds)).min.z) / cellSize.z);
		return new Vector2i(num, num2);
	}

	[ServerVar(Help = "(center vec3) (extents vec3)")]
	public static void setbounds(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		Vector3 vector2 = arg.GetVector3(1, default(Vector3));
		Bounds val = default(Bounds);
		((Bounds)(ref val)).center = vector;
		((Bounds)(ref val)).extents = vector2;
		Bounds val2 = val;
		arg.ReplyWith($"Setting physics bounds to {val2}");
		try
		{
			SetBounds(val2);
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Failed to set physics bounds: " + ex.Message);
		}
	}

	[ServerVar]
	public static void getbounds(Arg arg)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = GetBounds();
		arg.ReplyWith($"Physics bounds (center={((Bounds)(ref bounds)).center}, extents={((Bounds)(ref bounds)).extents})");
	}

	public static Bounds GetBounds()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return _currentBounds;
	}

	public static void SetBounds(Bounds bounds)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (!(_currentBounds == bounds))
		{
			Physics.RebuildBroadphaseRegions(bounds, 16);
			_currentBounds = bounds;
		}
	}

	static Physics()
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		Bounds val = default(Bounds);
		((Bounds)(ref val)).center = new Vector3(-1500f, 0f, 0f);
		((Bounds)(ref val)).extents = new Vector3(6500f, 4000f, 5000f);
		_currentBounds = val;
		val = default(Bounds);
		((Bounds)(ref val)).center = new Vector3(0f, 0f, 0f);
		((Bounds)(ref val)).extents = new Vector3(5000f, 4000f, 5000f);
		DeepSeaDisabledBounds = val;
		val = default(Bounds);
		((Bounds)(ref val)).center = new Vector3(-1500f, 0f, 0f);
		((Bounds)(ref val)).extents = new Vector3(6500f, 4000f, 5000f);
		DeepSeaEnabledBounds = val;
	}
}


using System.Collections.Generic;
using UnityEngine;

private class PhysxCell
{
	public Bounds Bounds;

	public Vector2i GridPosition;

	public int Id;

	public List<Collider> Colliders;
}


using Facepunch.Ping;

[Factory("ping")]
public class Ping : ConsoleSystem
{
	[ServerVar]
	[ClientVar]
	public static int ping_samples
	{
		get
		{
			return PingEstimater.numSamples;
		}
		set
		{
			PingEstimater.numSamples = value;
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool ping_parallel
	{
		get
		{
			return PingEstimater.parallel;
		}
		set
		{
			PingEstimater.parallel = value;
		}
	}

	[ServerVar]
	[ClientVar]
	public static int ping_refresh_interval
	{
		get
		{
			return PingEstimater.refreshIntervalMinutes;
		}
		set
		{
			PingEstimater.refreshIntervalMinutes = value;
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool auto_refresh_region
	{
		get
		{
			return PingEstimater.AutoRefresh;
		}
		set
		{
			PingEstimater.AutoRefresh = value;
		}
	}

	[ServerVar]
	[ClientVar]
	public static bool ping_estimate_logging
	{
		get
		{
			return PingEstimater.logging;
		}
		set
		{
			PingEstimater.logging = value;
		}
	}

	[ServerVar]
	[ClientVar]
	public static bool ping_estimation
	{
		get
		{
			return PingEstimater.enabled;
		}
		set
		{
			PingEstimater.enabled = value;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

[Factory("player")]
public class Player : ConsoleSystem
{
	public const string serverTickRateDefaultString = "16";

	public static int serverTickRate = 16;

	public const int serverTickRateDefault = 16;

	public const int serverTickRateMin = 16;

	public const int serverTickRateMax = 128;

	public static float serverTickInterval = 0.0625f;

	public const string clientTickRateDefaultString = "32";

	public const int clientTickRateDefault = 32;

	public const int clientTickRateMin = 16;

	public const int clientTickRateMax = 128;

	public static EncryptedValue<int> clientTickRate = 32;

	public static EncryptedValue<float> clientTickInterval = 1f / 32f;

	[ClientVar(ClientInfo = true)]
	public static bool InfiniteAmmo = false;

	[ServerVar]
	public static bool keepteaondeath = false;

	[ServerVar]
	public static bool dropbackpackondeath = true;

	[ServerVar]
	public static bool dropbackpackondowned = true;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Whether the crawling state expires")]
	public static bool woundforever = false;

	[ReplicatedVar(Default = "16")]
	public static int tickrate_sv
	{
		get
		{
			return serverTickRate;
		}
		set
		{
			serverTickRate = Mathf.Clamp(value, 16, 128);
			serverTickInterval = 1f / (float)serverTickRate;
		}
	}

	[ReplicatedVar(Default = "32")]
	public static int tickrate_cl
	{
		get
		{
			return clientTickRate;
		}
		set
		{
			clientTickRate = Mathf.Clamp(value, 16, 128);
			clientTickInterval = 1f / (float)(int)clientTickRate;
		}
	}

	[ClientVar(AllowRunFromServer = true)]
	[ServerUserVar]
	public static void cinematic_play(Arg arg)
	{
		if (!arg.HasArgs(1) || !arg.IsServerside)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			string strCommand = string.Empty;
			if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				strCommand = arg.cmd.FullName + " " + arg.FullString + " " + basePlayer.UserIDString;
			}
			else if (Server.cinematic)
			{
				strCommand = arg.cmd.FullName + " " + arg.GetString(0, "") + " " + basePlayer.UserIDString;
			}
			if (Server.cinematic)
			{
				ConsoleNetwork.BroadcastToAllClients(strCommand);
			}
			else if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				ConsoleNetwork.SendClientCommand(arg.Connection, strCommand);
			}
		}
	}

	[ClientVar(AllowRunFromServer = true)]
	[ServerUserVar]
	public static void cinematic_stop(Arg arg)
	{
		if (!arg.IsServerside)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			string strCommand = string.Empty;
			if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				strCommand = arg.cmd.FullName + " " + arg.FullString + " " + basePlayer.UserIDString;
			}
			else if (Server.cinematic)
			{
				strCommand = arg.cmd.FullName + " " + basePlayer.UserIDString;
			}
			if (Server.cinematic)
			{
				ConsoleNetwork.BroadcastToAllClients(strCommand);
			}
			else if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				ConsoleNetwork.SendClientCommand(arg.Connection, strCommand);
			}
		}
	}

	[ServerUserVar]
	public static void cinematic_gesture(Arg arg)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (Server.cinematic)
		{
			string @string = arg.GetString(0, "");
			BasePlayer basePlayer = arg.GetPlayer(1);
			if ((Object)(object)basePlayer == (Object)null)
			{
				basePlayer = arg.Player();
			}
			basePlayer.UpdateActiveItem(default(ItemId));
			basePlayer.SignalBroadcast(BaseEntity.Signal.Gesture, @string);
		}
	}

	[ServerUserVar]
	public static void copyrotation(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic)
		{
			uint uInt = arg.GetUInt(0, 0u);
			BasePlayer basePlayer2 = BasePlayer.FindByID(uInt);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				basePlayer2 = BasePlayer.FindBot(uInt);
			}
			if ((Object)(object)basePlayer2 != (Object)null)
			{
				basePlayer2.CopyRotation(basePlayer);
				Debug.Log((object)("Copied rotation of " + basePlayer2.UserIDString));
			}
		}
	}

	[ServerUserVar]
	public static void abandonmission(Arg arg)
	{
		arg.Player().AbandonActiveMission();
	}

	[ServerUserVar]
	public static void mount(Arg arg)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		uint uInt = arg.GetUInt(0, 0u);
		BasePlayer basePlayer2 = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer2 == (Object)null)
		{
			basePlayer2 = BasePlayer.FindBot(uInt);
		}
		RaycastHit hit = default(RaycastHit);
		if (!Object.op_Implicit((Object)(object)basePlayer2) || !Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), ref hit, 5f, 10496, (QueryTriggerInteraction)1))
		{
			return;
		}
		BaseEntity entity = hit.GetEntity();
		if (!Object.op_Implicit((Object)(object)entity))
		{
			return;
		}
		BaseMountable baseMountable = ((Component)entity).GetComponent<BaseMountable>();
		if (!Object.op_Implicit((Object)(object)baseMountable))
		{
			BaseVehicle baseVehicle = ((Component)entity).GetComponentInParent<BaseVehicle>();
			if (Object.op_Implicit((Object)(object)baseVehicle))
			{
				if (!baseVehicle.isServer)
				{
					baseVehicle = BaseNetworkable.serverEntities.Find(baseVehicle.net.ID) as BaseVehicle;
				}
				baseVehicle.AttemptMount(basePlayer2);
				return;
			}
		}
		if (Object.op_Implicit((Object)(object)baseMountable) && !baseMountable.isServer)
		{
			baseMountable = BaseNetworkable.serverEntities.Find(baseMountable.net.ID) as BaseMountable;
		}
		if (Object.op_Implicit((Object)(object)baseMountable))
		{
			baseMountable.AttemptMount(basePlayer2);
		}
	}

	[ServerVar]
	public static void gotosleep(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		uint uInt = arg.GetUInt(0, 0u);
		BasePlayer basePlayer2 = BasePlayer.FindSleeping(uInt.ToString());
		if (!Object.op_Implicit((Object)(object)basePlayer2))
		{
			basePlayer2 = BasePlayer.FindBotClosestMatch(uInt.ToString());
			if (basePlayer2.IsSleeping())
			{
				basePlayer2 = null;
			}
		}
		if (Object.op_Implicit((Object)(object)basePlayer2))
		{
			basePlayer2.StartSleeping();
		}
	}

	[ServerVar(Help = "optional param {player}", ClientAdmin = true)]
	public static void ragdoll(Arg arg)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic)
		{
			BasePlayer basePlayer2 = arg.GetPlayerOrSleeperOrBot(0) ?? basePlayer;
			if (!((Object)(object)basePlayer2 == (Object)null))
			{
				basePlayer2.Ragdoll();
			}
		}
	}

	[ServerVar(Help = "Ragdolls a player you're looking at", ClientAdmin = true)]
	public static void ragdollother(Arg arg)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic) && GamePhysics.Trace(basePlayer.eyes.HeadRay(), 0.5f, out var hitInfo, 5f, 1218652417, (QueryTriggerInteraction)0, basePlayer) && hitInfo.GetEntity() is BasePlayer { isClient: false } basePlayer2)
		{
			basePlayer2.Ragdoll();
		}
	}

	[ServerVar(Help = "ragdolls")]
	public static void ragdollall(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Ragdoll();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.bots.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Ragdoll();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "ragdolls everyone except player")]
	public static void ragdollallbutme(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)(object)basePlayer))
				{
					current.Ragdoll();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.bots.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Ragdoll();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar]
	public static void dismount(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic)
		{
			uint uInt = arg.GetUInt(0, 0u);
			BasePlayer basePlayer2 = BasePlayer.FindByID(uInt);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				basePlayer2 = BasePlayer.FindBot(uInt);
			}
			if (Object.op_Implicit((Object)(object)basePlayer2) && Object.op_Implicit((Object)(object)basePlayer2) && basePlayer2.isMounted)
			{
				basePlayer2.GetMounted().DismountPlayer(basePlayer2);
			}
		}
	}

	[ServerVar]
	public static void swapseat(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		uint uInt = arg.GetUInt(0, 0u);
		BasePlayer basePlayer2 = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer2 == (Object)null)
		{
			basePlayer2 = BasePlayer.FindBot(uInt);
		}
		if (Object.op_Implicit((Object)(object)basePlayer2))
		{
			int @int = arg.GetInt(1, 0);
			if (Object.op_Implicit((Object)(object)basePlayer2) && basePlayer2.isMounted && Object.op_Implicit((Object)(object)basePlayer2.GetMounted().VehicleParent()))
			{
				basePlayer2.GetMounted().VehicleParent().SwapSeats(basePlayer2, @int);
			}
		}
	}

	[ServerVar]
	public static void wakeup(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic)
		{
			BasePlayer basePlayer2 = BasePlayer.FindSleeping(arg.GetUInt(0, 0u).ToString());
			if (Object.op_Implicit((Object)(object)basePlayer2))
			{
				basePlayer2.EndSleeping();
			}
		}
	}

	[ServerVar]
	public static void wakeupall(Arg arg)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Enumerator<BasePlayer> enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (BasePlayer item in list)
		{
			item.EndSleeping();
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar]
	public static void printstats(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsAlive:F1}s alive");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsSleeping:F1}s sleeping");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsSwimming:F1}s swimming");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsInBase:F1}s in base");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsWilderness:F1}s in wilderness");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsInMonument:F1}s in monuments");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsFlying:F1}s flying");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsBoating:F1}s boating");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsDriving:F1}s driving");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.metersRun:F1}m run");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.metersWalked:F1}m walked");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.totalDamageTaken:F1} damage taken");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.totalHealing:F1} damage healed");
		stringBuilder.AppendLine("===");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.killedPlayers} other players killed");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.killedScientists} scientists killed");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.killedAnimals} animals killed");
		stringBuilder.AppendLine("===");
		stringBuilder.AppendLine("Weapon stats:");
		if (basePlayer.lifeStory.weaponStats != null)
		{
			foreach (WeaponStats weaponStat in basePlayer.lifeStory.weaponStats)
			{
				float num = (float)weaponStat.shotsHit / (float)weaponStat.shotsFired;
				num *= 100f;
				stringBuilder.AppendLine($"{weaponStat.weaponName} - shots fired: {weaponStat.shotsFired} shots hit: {weaponStat.shotsHit} accuracy: {num:F1}%");
			}
		}
		stringBuilder.AppendLine("===");
		stringBuilder.AppendLine("Misc stats:");
		if (basePlayer.lifeStory.genericStats != null)
		{
			foreach (GenericStat genericStat in basePlayer.lifeStory.genericStats)
			{
				stringBuilder.AppendLine($"{genericStat.key} = {genericStat.value}");
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void printpresence(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		bool flag = (basePlayer.currentTimeCategory & 1) != 0;
		bool flag2 = (basePlayer.currentTimeCategory & 4) != 0;
		bool flag3 = (basePlayer.currentTimeCategory & 2) != 0;
		bool flag4 = (basePlayer.currentTimeCategory & 0x20) != 0;
		bool flag5 = (basePlayer.currentTimeCategory & 0x10) != 0;
		bool flag6 = (basePlayer.currentTimeCategory & 8) != 0;
		arg.ReplyWith($"Wilderness:{flag} Base:{flag2} Monument:{flag3} Swimming: {flag4} Boating: {flag5} Flying: {flag6}");
	}

	[ServerVar(Help = "Resets the PlayerState of the given player")]
	public static void resetstate(Arg args)
	{
		BasePlayer playerOrSleeper = args.GetPlayerOrSleeper(0);
		if ((Object)(object)playerOrSleeper == (Object)null)
		{
			args.ReplyWith("Player not found");
			return;
		}
		playerOrSleeper.ResetPlayerState();
		args.ReplyWith("Player state reset");
	}

	[ServerVar(Help = "<fresh/salt/rads> - Fills up liquid container items in your hotbar as well as any liquid containers you are looking at")]
	public static void fillwater(Arg arg)
	{
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Must be called from a player!");
			return;
		}
		string @string = arg.GetString(0, "");
		ItemDefinition itemDefinition = ((@string == "salt") ? WaterTypes.SaltWaterItemDef : ((!(@string == "rads")) ? WaterTypes.WaterItemDef : WaterTypes.RadioactiveWaterItemDef));
		ItemDefinition itemDefinition2 = itemDefinition;
		int num = 0;
		ItemModContainer itemModContainer = default(ItemModContainer);
		for (int i = 0; i < PlayerBelt.MaxBeltSlots; i++)
		{
			Item itemInSlot = basePlayer.Belt.GetItemInSlot(i);
			if (itemInSlot != null && itemInSlot.GetHeldEntity() is BaseLiquidVessel baseLiquidVessel && (baseLiquidVessel.hasLid || !Object.op_Implicit((Object)(object)basePlayer.GetHeldEntity()) != Object.op_Implicit((Object)(object)baseLiquidVessel)))
			{
				int amount = 999;
				if (((Component)itemInSlot.info).TryGetComponent<ItemModContainer>(ref itemModContainer))
				{
					amount = itemModContainer.maxStackSize;
				}
				itemInSlot.contents.Clear();
				baseLiquidVessel.AddLiquid(itemDefinition2, amount);
				num++;
			}
		}
		string text = $"Filled {num} items in the hotbar";
		if (GamePhysics.TraceRealmEntity(GamePhysics.Realm.Server, basePlayer.eyes.HeadRay(), 0f, 3f, 1218652417, (QueryTriggerInteraction)0) is LiquidContainer liquidContainer)
		{
			liquidContainer.inventory.Clear();
			Item item = ItemManager.Create(itemDefinition2, liquidContainer.inventory.maxStackSize, 0uL);
			if (liquidContainer.inventory.GiveItem(item))
			{
				text = text + "\nFilled up the " + liquidContainer.ShortPrefabName;
			}
			else
			{
				item.Remove();
				text = text + "\nThe " + liquidContainer.ShortPrefabName + " does not accept this water type";
			}
		}
		arg.ReplyWith(text);
	}

	[ServerVar(ServerAdmin = true)]
	public static void reloadweapons(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		for (int i = 0; i < PlayerBelt.MaxBeltSlots; i++)
		{
			Item itemInSlot = basePlayer.Belt.GetItemInSlot(i);
			if (itemInSlot == null)
			{
				continue;
			}
			if (itemInSlot.GetHeldEntity() is BaseProjectile baseProjectile)
			{
				if (baseProjectile.primaryMagazine != null)
				{
					baseProjectile.SetAmmoCount(baseProjectile.primaryMagazine.capacity);
					baseProjectile.SendNetworkUpdateImmediate();
				}
			}
			else if (itemInSlot.GetHeldEntity() is FlameThrower flameThrower)
			{
				flameThrower.ammo = flameThrower.maxAmmo;
				flameThrower.SendNetworkUpdateImmediate();
			}
			else if (itemInSlot.GetHeldEntity() is LiquidWeapon liquidWeapon)
			{
				liquidWeapon.AddLiquid(WaterTypes.WaterItemDef, 999);
			}
		}
	}

	[ServerVar(ServerAdmin = true)]
	public static void unloadweapons(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		for (int i = 0; i < PlayerBelt.MaxBeltSlots; i++)
		{
			Item itemInSlot = basePlayer.Belt.GetItemInSlot(i);
			if (itemInSlot == null)
			{
				continue;
			}
			if (itemInSlot.GetHeldEntity() is BaseProjectile baseProjectile)
			{
				if (baseProjectile.primaryMagazine != null)
				{
					baseProjectile.SetAmmoCount(0);
					baseProjectile.SendNetworkUpdateImmediate();
				}
			}
			else if (itemInSlot.GetHeldEntity() is FlameThrower flameThrower)
			{
				flameThrower.ammo = 0;
				flameThrower.SendNetworkUpdateImmediate();
			}
			else if (itemInSlot.GetHeldEntity() is LiquidWeapon liquidWeapon)
			{
				liquidWeapon.LoseWater(999);
			}
		}
	}

	[ServerVar]
	public static void createskull(Arg arg)
	{
		string text = arg.GetString(0, "");
		BasePlayer basePlayer = arg.Player();
		if (string.IsNullOrEmpty(text))
		{
			text = RandomUsernames.Get(Random.Range(0, 1000));
		}
		Item item = ItemManager.Create(ItemManager.FindItemDefinition("skull.human"), 1, 0uL);
		item.name = HumanBodyResourceDispenser.CreateSkullName(text);
		item.streamerName = item.name;
		basePlayer.inventory.GiveItem(item);
	}

	[ServerVar]
	public static string createTrophy(Arg arg)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		Entity.EntitySpawnRequest spawnEntityFromName = Entity.GetSpawnEntityFromName(arg.GetString(0, ""));
		if (!spawnEntityFromName.Valid)
		{
			return spawnEntityFromName.Error;
		}
		BaseCombatEntity baseCombatEntity = default(BaseCombatEntity);
		if (GameManager.server.FindPrefab(spawnEntityFromName.PrefabName).TryGetComponent<BaseCombatEntity>(ref baseCombatEntity))
		{
			Item item = ItemManager.CreateByName("head.bag", 1, 0uL);
			HeadEntity associatedEntity = ItemModAssociatedEntity<HeadEntity>.GetAssociatedEntity(item);
			if ((Object)(object)associatedEntity != (Object)null)
			{
				associatedEntity.SetupSourceId(baseCombatEntity.prefabID);
			}
			if (basePlayer.inventory.GiveItem(item))
			{
				basePlayer.Command("note.inv", item.info.itemid, 1);
			}
			else
			{
				item.DropAndTossUpwards(basePlayer.eyes.position);
			}
		}
		return "Created head";
	}

	[ServerVar]
	public static void trigger_wildlife_trap(Arg arg)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		if (GamePhysics.Trace(basePlayer.eyes.HeadRay(), 0.5f, out var hitInfo, 5f, 1218652417, (QueryTriggerInteraction)0, basePlayer))
		{
			WildlifeTrap wildlifeTrap = hitInfo.GetEntity() as WildlifeTrap;
			if (wildlifeTrap != null)
			{
				if (wildlifeTrap.isClient)
				{
					wildlifeTrap = BaseNetworkable.serverEntities.Find(wildlifeTrap.net.ID) as WildlifeTrap;
				}
				if (!wildlifeTrap.IsTrapActive())
				{
					arg.ReplyWith("Trap is not loaded or active");
					return;
				}
				wildlifeTrap.TrapThink();
				arg.ReplyWith("Trap think triggered");
				return;
			}
		}
		arg.ReplyWith("Not looking at a trap");
	}

	[ServerVar]
	public static void gesture_radius(Arg arg)
	{
		gesture_radius(arg, includeMe: true);
	}

	[ServerVar]
	public static void gesture_radius_notme(Arg arg)
	{
		gesture_radius(arg, includeMe: false);
	}

	public static void gesture_radius(Arg arg, bool includeMe)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		List<string> list = Pool.Get<List<string>>();
		for (int i = 0; i < 5; i++)
		{
			if (!string.IsNullOrEmpty(arg.GetString(i + 1, "")))
			{
				list.Add(arg.GetString(i + 1, ""));
			}
		}
		if (list.Count == 0)
		{
			arg.ReplyWith("No gestures provided. eg. player.gesture_radius 10f cabbagepatch raiseroof");
			return;
		}
		List<BasePlayer> list2 = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)basePlayer).transform.position, @float, list2, 131072, (QueryTriggerInteraction)2);
		foreach (BasePlayer item in list2)
		{
			if (includeMe || (!((Object)(object)item == (Object)(object)basePlayer) && !item.isClient))
			{
				GestureConfig toPlay = GestureCollection.Instance.StringToGesture(list[Random.Range(0, list.Count)]);
				item.Server_StartGesture(toPlay, BasePlayer.GestureStartSource.Player, bypassOwnershipCheck: true);
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list2);
	}

	[ServerVar]
	public static void stopgesture_radius(Arg arg)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)basePlayer).transform.position, @float, list, 131072, (QueryTriggerInteraction)2);
		foreach (BasePlayer item in list)
		{
			item.Server_CancelGesture();
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar]
	public static void markhostile(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.MarkHostileFor();
		}
	}
}


public class PlayerCull : ConsoleSystem
{
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using Facepunch;
using Facepunch.Extend;
using Network;
using UnityEngine;

[Factory("pool")]
public class Pool : ConsoleSystem
{
	[ClientVar(ClientAdmin = true)]
	[ServerVar]
	public static int mode = 2;

	[ServerVar]
	[ClientVar]
	public static bool prewarm = true;

	[ClientVar]
	[ServerVar]
	public static bool enabled = true;

	[ClientVar]
	[ServerVar]
	public static bool debug = false;

	[ServerVar]
	[ClientVar]
	public static void print_memory(Arg arg)
	{
		if (Pool.Directory.Count == 0)
		{
			arg.ReplyWith("Memory pool is empty.");
			return;
		}
		bool flag = arg.HasArg("--raw", true);
		bool flag2 = arg.HasArg("--json", true);
		string @string = arg.GetString(0, (string)null);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag2;
			val.AddColumn("type");
			val.AddColumn("capacity");
			val.AddColumn("pooled");
			val.AddColumn("active");
			val.AddColumn("max");
			val.AddColumn("hits");
			val.AddColumn("misses");
			val.AddColumn("spills");
			foreach (KeyValuePair<Type, IPoolCollection> item in Pool.Directory.OrderByDescending((KeyValuePair<Type, IPoolCollection> x) => x.Value.ItemsCreated))
			{
				Type key = item.Key;
				IPoolCollection value = item.Value;
				if (@string == null || key.ToString().Contains(@string))
				{
					val.AddRow(new string[8]
					{
						key.ToString().Replace("System.Collections.Generic.", ""),
						flag ? value.ItemsCapacity.ToString() : NumberExtensions.FormatNumberShort(value.ItemsCapacity),
						flag ? value.ItemsInStack.ToString() : NumberExtensions.FormatNumberShort(value.ItemsInStack),
						flag ? value.ItemsInUse.ToString() : NumberExtensions.FormatNumberShort(value.ItemsInUse),
						flag ? value.MaxItemsInUse.ToString() : NumberExtensions.FormatNumberShort(value.MaxItemsInUse),
						flag ? value.ItemsTaken.ToString() : NumberExtensions.FormatNumberShort(value.ItemsTaken),
						flag ? value.ItemsCreated.ToString() : NumberExtensions.FormatNumberShort(value.ItemsCreated),
						flag ? value.ItemsSpilled.ToString() : NumberExtensions.FormatNumberShort(value.ItemsSpilled)
					});
				}
			}
			arg.ReplyWith(flag2 ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void reset_max_pool_counter(Arg arg)
	{
		if (Pool.Directory.Count == 0)
		{
			arg.ReplyWith("Memory pool is empty.");
			return;
		}
		foreach (IPoolCollection value in Pool.Directory.Values)
		{
			value.ResetMaxUsageCounter();
		}
		arg.ReplyWith("Reset max item counter of pool");
	}

	[ServerVar]
	[ClientVar]
	public static void print_arraypool(Arg arg)
	{
		bool flag = arg.HasArg("--json", false);
		string text = (flag ? "[" : string.Empty);
		string table2 = PrintArrayPool<byte>(BaseNetwork.ArrayPool, flag);
		text += FormatTable("BaseNetwork.ArrayPool", table2, flag);
		text += (flag ? "," : "\n");
		string table3 = PrintArrayPool<byte>(Shared.ArrayPool, flag);
		text += FormatTable("ProtocolParser.ArrayPool", table3, flag);
		if (flag)
		{
			text += "]";
		}
		arg.ReplyWith(text);
		static string FormatTable(string name, string table, bool toJson)
		{
			if (!toJson)
			{
				return name + "\n" + table;
			}
			return "{\"name\":\"" + name + "\",\"content\":" + table + "}";
		}
		unsafe static string PrintArrayPool<T>(ArrayPool<T> pool, bool toJson) where T : unmanaged
		{
			ConcurrentQueue<T[]>[] buffer = pool.GetBuffer();
			TextTable val = Pool.Get<TextTable>();
			try
			{
				val.ShouldPadColumns = !toJson;
				val.ResizeColumns(5);
				val.AddColumn("index");
				val.AddColumn("size");
				val.AddColumn("bytes");
				val.AddColumn("count");
				val.AddColumn("memory");
				val.ResizeRows(buffer.Length);
				int num = 1;
				num = sizeof(T);
				for (int i = 0; i < buffer.Length; i++)
				{
					int num2 = pool.IndexToSize(i);
					int num3 = num2 * num;
					int count = buffer[i].Count;
					int num4 = num3 * count;
					val.AddValue(i);
					val.AddValue(num2);
					val.AddValue(NumberExtensions.FormatBytes<int>(num2, false));
					val.AddValue(count);
					val.AddValue(NumberExtensions.FormatBytes<int>(num4, false));
				}
				return toJson ? val.ToJson(false) : ((object)val).ToString();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	[ClientVar]
	[ServerVar]
	public static void print_prefabs(Arg arg)
	{
		PrefabPoolCollection pool = GameManager.server.pool;
		if (pool.storage.Count == 0)
		{
			arg.ReplyWith("Prefab pool is empty.");
			return;
		}
		string @string = arg.GetString(0, string.Empty);
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("id");
			val.AddColumn("name");
			val.AddColumn("missed");
			val.AddColumn("count");
			val.AddColumn("target");
			val.AddColumn("added");
			val.AddColumn("removed");
			foreach (PrefabPool item in pool.storage.Values.OrderByDescending((PrefabPool x) => x.Missed))
			{
				string text = StringPool.Get(item.PrefabName).ToString();
				string prefabName = item.PrefabName;
				string text2 = item.Count.ToString();
				if (string.IsNullOrEmpty(@string) || StringEx.Contains(prefabName, @string, CompareOptions.IgnoreCase))
				{
					val.AddRow(new string[7]
					{
						text,
						Path.GetFileNameWithoutExtension(prefabName),
						text2,
						item.TargetCapacity.ToString(),
						item.Missed.ToString(),
						item.Pushed.ToString(),
						item.Popped.ToString()
					});
				}
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	[ClientVar]
	public static void print_assets(Arg arg)
	{
		if (AssetPool.storage.Count == 0)
		{
			arg.ReplyWith("Asset pool is empty.");
			return;
		}
		string @string = arg.GetString(0, string.Empty);
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("type");
			val.AddColumn("allocated");
			val.AddColumn("available");
			foreach (KeyValuePair<Type, Pool> item in AssetPool.storage)
			{
				string text = item.Key.ToString();
				string text2 = item.Value.allocated.ToString();
				string text3 = item.Value.available.ToString();
				if (string.IsNullOrEmpty(@string) || StringEx.Contains(text, @string, CompareOptions.IgnoreCase))
				{
					val.AddRow(new string[3] { text, text2, text3 });
				}
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void clear_memory(Arg arg)
	{
		Pool.Clear(arg.GetString(0, string.Empty));
	}

	[ServerVar]
	[ClientVar]
	public static void clear_prefabs(Arg arg)
	{
		string @string = arg.GetString(0, string.Empty);
		GameManager.server.pool.Clear(@string);
	}

	[ServerVar]
	[ClientVar]
	public static void clear_assets(Arg arg)
	{
		AssetPool.Clear(arg.GetString(0, string.Empty));
	}

	[ServerVar]
	[ClientVar]
	public static void export_prefabs(Arg arg)
	{
		PrefabPoolCollection pool = GameManager.server.pool;
		if (pool.storage.Count == 0)
		{
			arg.ReplyWith("Prefab pool is empty.");
			return;
		}
		string @string = arg.GetString(0, string.Empty);
		StringBuilder stringBuilder = new StringBuilder();
		foreach (KeyValuePair<uint, PrefabPool> item in pool.storage)
		{
			string arg2 = item.Key.ToString();
			string text = StringPool.Get(item.Key);
			string arg3 = item.Value.Count.ToString();
			if (string.IsNullOrEmpty(@string) || StringEx.Contains(text, @string, CompareOptions.IgnoreCase))
			{
				stringBuilder.AppendLine($"{arg2},{Path.GetFileNameWithoutExtension(text)},{arg3}");
			}
		}
		File.WriteAllText("prefabs.csv", stringBuilder.ToString());
	}

	[ClientVar]
	[ServerVar]
	public static void fill_prefabs(Arg arg)
	{
		string @string = arg.GetString(0, string.Empty);
		int @int = arg.GetInt(1, 0);
		PrefabPoolWarmup.Run(@string, @int);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

[Factory("profile")]
public class Profile : ConsoleSystem
{
	private static Action delayedTakeSnapshot;

	private static bool exportDone = true;

	[ServerVar(Saved = true, Help = "Controls whether perfsnapshot commands emit chat messages")]
	public static bool Quiet = false;

	private const string PerfSnapshotHelp = "profile.perfsnapshot [delay=15, int] [name='Profile', str, no extension, max 32chars] [frames=10, int, max 10] [debug=false, dumps a binary snapshot as well]\nWill produce a JSON perf snapshot of <frames> that can be viewed in Perfetto or similar tools";

	private const string PerfSnapshot_StreamHelp = "profile.perfsnapshot_stream [name='Profile', str, no extension, max 32chars] [MainCap=32, int, max 256, buffer size for Main thread in Megabytes] [WorkerCap=8, int, max 256, buffer size for each Worker thread in Megabytes] [debug=false, dumps a binary snapshot as well]\nWill stream <mainCap>MB worth of data and generate a JSON snapshot that can be viewed in Perfetto or similar tools";

	private const string WatchAllocsHelp = "Params: [Name = 'Allocs'] [maxStackDepth = 16].\nStarts tracking of allocs, dumping a [Name].json.gz record once conditions are met";

	private static uint notifyOnTotalAllocCount = 16000u;

	private static uint notifyOnTotalMemKB = 12288u;

	private static uint notifyOnMainAllocCount = 0u;

	private static uint notifyOnMainMemKB = 0u;

	private static uint notifyOnWorkerAllocCount = 0u;

	private static uint notifyOnWorkerMemKB = 0u;

	[ClientVar(ClientAdmin = true, Help = "Log how long entities take to spawn on the client, use 'minloggedspawntime' to filter low spawn times")]
	public static bool LogEntitySpawnTime { get; set; }

	[ClientVar(ClientAdmin = true, Help = "Minimum spawn time before logging (in ms)")]
	public static int LogEntitySpawnTime_Min { get; set; }

	[ServerVar]
	public static int NotifyOnTotalAllocCount
	{
		get
		{
			return (int)notifyOnTotalAllocCount;
		}
		set
		{
			if (notifyOnTotalAllocCount != value)
			{
				notifyOnTotalAllocCount = (uint)value;
				ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.TotalAllocCount, notifyOnTotalAllocCount);
			}
		}
	}

	[ServerVar]
	public static int NotifyOnTotalMemKB
	{
		get
		{
			return (int)notifyOnTotalMemKB;
		}
		set
		{
			if (notifyOnTotalMemKB != value)
			{
				notifyOnTotalMemKB = (uint)value;
				ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.TotalMem, notifyOnTotalMemKB * 1024);
			}
		}
	}

	[ServerVar]
	public static int NotifyOnMainAllocCount
	{
		get
		{
			return (int)notifyOnMainAllocCount;
		}
		set
		{
			if (notifyOnMainAllocCount != value)
			{
				notifyOnMainAllocCount = (uint)value;
				ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.MainAllocCount, notifyOnMainAllocCount);
			}
		}
	}

	[ServerVar]
	public static int NotifyOnMainMemKB
	{
		get
		{
			return (int)notifyOnMainMemKB;
		}
		set
		{
			if (notifyOnMainMemKB != value)
			{
				notifyOnMainMemKB = (uint)value;
				ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.MainMem, notifyOnMainMemKB * 1024);
			}
		}
	}

	[ServerVar]
	public static int NotifyOnWorkerAllocCount
	{
		get
		{
			return (int)notifyOnWorkerAllocCount;
		}
		set
		{
			if (notifyOnWorkerAllocCount != value)
			{
				notifyOnWorkerAllocCount = (uint)value;
				ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.WorkerAllocCount, notifyOnWorkerAllocCount);
			}
		}
	}

	[ServerVar]
	public static int NotifyOnWorkerMemKB
	{
		get
		{
			return (int)notifyOnWorkerMemKB;
		}
		set
		{
			if (notifyOnWorkerMemKB != value)
			{
				notifyOnWorkerMemKB = (uint)value;
				ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.WorkerMem, notifyOnWorkerMemKB * 1024);
			}
		}
	}

	[ServerVar]
	public static bool ImmediateModeEnabled
	{
		get
		{
			return ServerProfiler.ImmediateModeEnabled;
		}
		set
		{
			ServerProfiler.ImmediateModeEnabled = value;
		}
	}

	[ServerVar]
	public static int ExportIntervalS
	{
		get
		{
			return ServerProfiler.ExportIntervalS;
		}
		set
		{
			ServerProfiler.ExportIntervalS = value;
		}
	}

	private static void NeedProfileFolder()
	{
		if (!Directory.Exists("profile"))
		{
			Directory.CreateDirectory("profile");
		}
	}

	[ClientVar]
	[ServerVar]
	public static void start(Arg arg)
	{
	}

	[ClientVar]
	[ServerVar]
	public static void stop(Arg arg)
	{
	}

	[ServerVar]
	[ClientVar]
	public static void flush_analytics(Arg arg)
	{
	}

	[ServerVar(Help = "profile.perfsnapshot [delay=15, int] [name='Profile', str, no extension, max 32chars] [frames=10, int, max 10] [debug=false, dumps a binary snapshot as well]\nWill produce a JSON perf snapshot of <frames> that can be viewed in Perfetto or similar tools")]
	public static void PerfSnapshot(Arg arg)
	{
		if (!ServerProfiler.IsEnabled())
		{
			arg.ReplyWith("ServerProfiler is disabled");
			return;
		}
		if (!exportDone)
		{
			arg.ReplyWith("Already taking snapshot!");
			return;
		}
		int delay = arg.GetInt(0, 15);
		string name = StringExtensions.Truncate(arg.GetString(1, "Profile"), 32, (string)null);
		int frames = arg.GetInt(2, 4);
		bool generateBinary = arg.GetBool(3, false);
		if (delay == 0 || Quiet)
		{
			if (!Quiet)
			{
				Chat.Broadcast("Server taking a perf snapshot", "SERVER", "#eee", 0uL);
			}
			ServerProfiler.RecordNextFrames(frames, delegate(IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
			{
				if (!Quiet)
				{
					Chat.Broadcast("Snapshot taken", "SERVER", "#eee", 0uL);
				}
				Task.Run(delegate
				{
					if (generateBinary)
					{
						ProfileExporter.Binary.Export(name, profiles);
					}
					ProfileExporter.JSON.Export(name, profiles, memState);
					ServerProfiler.ReleaseResources();
					exportDone = true;
				});
			});
			arg.ReplyWith("ServerProfiler is recording a perf snapshot");
			return;
		}
		Chat.Broadcast($"Server will be taking a perf snapshot, expect stutters in {delay} seconds", "SERVER", "#eee", 0uL);
		delayedTakeSnapshot = delegate
		{
			delay--;
			if (delay > 10 && delay % 5 == 0)
			{
				Chat.Broadcast($"Server will be taking a perf snapshot, expect stutters in {delay} seconds", "SERVER", "#eee", 0uL);
			}
			else if (delay > 0 && delay <= 10)
			{
				Chat.Broadcast($"{delay}...", "SERVER", "#eee", 0uL);
			}
			if (delay == 0)
			{
				ServerProfiler.RecordNextFrames(frames, delegate(IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
				{
					Chat.Broadcast("Snapshot taken", "SERVER", "#eee", 0uL);
					Task.Run(delegate
					{
						if (generateBinary)
						{
							ProfileExporter.Binary.Export(name, profiles);
						}
						ProfileExporter.JSON.Export(name, profiles, memState);
						ServerProfiler.ReleaseResources();
						exportDone = true;
					});
				});
				InvokeHandler.CancelInvoke((Behaviour)(object)SingletonComponent<InvokeHandler>.Instance, delayedTakeSnapshot);
				delayedTakeSnapshot = null;
			}
		};
		InvokeHandler.InvokeRepeating((Behaviour)(object)SingletonComponent<InvokeHandler>.Instance, delayedTakeSnapshot, 0f, 1f);
		arg.ReplyWith("ServerProfiler will record a perf snapshot after a delay");
	}

	[ServerVar(Help = "profile.perfsnapshot_stream [name='Profile', str, no extension, max 32chars] [MainCap=32, int, max 256, buffer size for Main thread in Megabytes] [WorkerCap=8, int, max 256, buffer size for each Worker thread in Megabytes] [debug=false, dumps a binary snapshot as well]\nWill stream <mainCap>MB worth of data and generate a JSON snapshot that can be viewed in Perfetto or similar tools")]
	public static void PerfSnapshot_Stream(Arg arg)
	{
		if (!ServerProfiler.IsEnabled())
		{
			arg.ReplyWith("ServerProfiler is disabled");
			return;
		}
		if (!exportDone)
		{
			arg.ReplyWith("Already taking snapshot!");
			return;
		}
		string name = StringExtensions.Truncate(arg.GetString(0, "Profile"), 32, (string)null);
		uint mainThreadCap = Math.Min(arg.GetUInt(1, 32u), 256u) * 1048576;
		uint workerThreadCap = Math.Min(arg.GetUInt(2, 8u), 256u) * 1048576;
		bool generateBinary = arg.GetBool(3, false);
		if (!Quiet)
		{
			Chat.Broadcast("Server taking a perf snapshot, there might be stutters", "SERVER", "#eee", 0uL);
		}
		ServerProfiler.RecordIntoBuffer(mainThreadCap, workerThreadCap, delegate(IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
		{
			if (!Quiet)
			{
				Chat.Broadcast("Snapshot taken", "SERVER", "#eee", 0uL);
			}
			Task.Run(delegate
			{
				if (generateBinary)
				{
					ProfileExporter.Binary.Export(name, profiles);
				}
				ProfileExporter.JSON.Export(name, profiles, memState);
				ServerProfiler.ReleaseResources();
				exportDone = true;
			});
		});
		arg.ReplyWith("ServerProfiler started recording a perf stream snapshot");
	}

	[ServerVar(Help = "Params: [Name = 'Allocs'] [maxStackDepth = 16].\nStarts tracking of allocs, dumping a [Name].json.gz record once conditions are met")]
	public static void WatchAllocs(Arg arg)
	{
		if (!ServerProfiler.IsEnabled())
		{
			arg.ReplyWith("ServerProfiler is disabled");
			return;
		}
		if (ServerProfiler.IsRunning)
		{
			arg.ReplyWith("ServerProfiler is busy with a previous task");
			return;
		}
		ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.TotalAllocCount, notifyOnTotalAllocCount);
		ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.TotalMem, notifyOnTotalMemKB * 1024);
		ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.MainAllocCount, notifyOnMainAllocCount);
		ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.MainMem, notifyOnMainMemKB * 1024);
		ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.WorkerAllocCount, notifyOnWorkerAllocCount);
		ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.WorkerMem, notifyOnWorkerMemKB * 1024);
		string name = arg.GetString(0, "Allocs");
		ServerProfiler.StartContinuousRecording((byte)arg.GetInt(1, 16), delegate(IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
		{
			Task.Run(delegate
			{
				if (ProfileExporter.JSON.Export(name, profiles, memState))
				{
					ServerProfiler.ResumeContinuousRecording();
				}
				else
				{
					Debug.Log((object)"Stopping watching allocations due to export error");
					ServerProfiler.StopContinuousRecording();
				}
			});
		});
		arg.ReplyWith("ServerProfiler started tracking allocations");
	}

	[ServerVar(Help = "Stops tracking of allocations")]
	public static void StopWatchingAllocs(Arg arg)
	{
		if (!ServerProfiler.IsEnabled())
		{
			arg.ReplyWith("ServerProfiler is disabled");
			return;
		}
		ServerProfiler.StopContinuousRecording();
		arg.ReplyWith("ServerProfiler stopped tracking allocations");
	}

	[ServerVar]
	public static void ResetExportInterval(Arg arg)
	{
		ServerProfiler.ResetExportInterval();
		arg.ReplyWith("Done");
	}

	[ServerVar]
	public static void CountSyncMoveEntities(Arg arg)
	{
		StringBuilder stringBuilder = Pool.Get<StringBuilder>();
		Dictionary<uint, uint> countPerPrefab = Pool.Get<Dictionary<uint, uint>>();
		if ((Object)(object)SingletonComponent<InvokeHandler>.Instance != (Object)null)
		{
			((InvokeHandlerBase<InvokeHandler>)(object)SingletonComponent<InvokeHandler>.Instance).ForEach((Action<InvokeAction>)Aggregate);
			stringBuilder.AppendLine("InvokeHandler");
			Print(countPerPrefab, stringBuilder);
			countPerPrefab.Clear();
		}
		if ((Object)(object)SingletonComponent<InvokeHandlerFixedTime>.Instance != (Object)null)
		{
			((InvokeHandlerBase<InvokeHandlerFixedTime>)(object)SingletonComponent<InvokeHandlerFixedTime>.Instance).ForEach((Action<InvokeAction>)Aggregate);
			stringBuilder.AppendLine("\nInvokeHandlerFixedTime");
			Print(countPerPrefab, stringBuilder);
		}
		Pool.FreeUnmanaged<uint, uint>(ref countPerPrefab);
		arg.ReplyWith(stringBuilder.ToString());
		Pool.FreeUnmanaged(ref stringBuilder);
		void Aggregate(InvokeAction action)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)action.sender != (Object)null && action.sender is BaseEntity baseEntity && action.action == baseEntity.NetworkPosTickCallback)
			{
				if (countPerPrefab.TryGetValue(baseEntity.prefabID, out var value))
				{
					countPerPrefab[baseEntity.prefabID] = value + 1;
				}
				else
				{
					countPerPrefab.Add(baseEntity.prefabID, 1u);
				}
			}
		}
		static void Print(Dictionary<uint, uint> counts, StringBuilder builder)
		{
			TextTable val = Pool.Get<TextTable>();
			val.ResizeColumns(2);
			val.AddColumn("Count");
			val.AddColumn("Prefab");
			val.ResizeRows(counts.Count);
			List<(uint, uint)> list = Pool.Get<List<(uint, uint)>>();
			foreach (KeyValuePair<uint, uint> count in counts)
			{
				list.Add((count.Key, count.Value));
			}
			list.Sort(((uint, uint) left, (uint, uint) right) => right.Item2.CompareTo(left.Item2));
			uint num = 0u;
			foreach (var item3 in list)
			{
				uint item = item3.Item1;
				uint item2 = item3.Item2;
				num += item2;
				val.AddValue(item2);
				val.AddValue(StringPool.Get(item));
			}
			Pool.FreeUnmanaged<(uint, uint)>(ref list);
			builder.Append(((object)val).ToString());
			builder.AppendLine($"Total: {num}");
			Pool.Free<TextTable>(ref val);
		}
	}
}


[Factory("reflection")]
public class Reflection : ConsoleSystem
{
}


using System.Collections.Generic;
using System.Linq;
using System.Text;
using ProtoBuf;

[Factory("render")]
public class Render : ConsoleSystem
{
	public static bool use_normal_rendering = false;

	[ClientVar(Saved = true, Help = "0 = off, 1 = on (must restart client for changes to take effect)")]
	public static int instanced_rendering = 0;

	[ClientVar(ClientAdmin = true, Help = "Developer command to toggle instanced rendering at runtime to measure performance impact")]
	public static bool instanced_toggle_all = true;

	[ClientVar(ClientAdmin = true, Help = "Toggle rendering of cliffs on / off")]
	public static bool instanced_toggle_cliffs = true;

	[ClientVar(ClientAdmin = true, Help = "Toggle rendering of buildings on / off")]
	public static bool instanced_toggle_buildings = true;

	[ClientVar(ClientAdmin = true, Help = "Toggle rendering of uncategorized meshes on / off")]
	public static bool instanced_toggle_other = true;

	[ClientVar(ClientAdmin = true, Help = "Allow unity to batch together multiple draw calls")]
	public static bool multidraw = true;

	[ClientVar(ClientAdmin = true, Help = "0 = CPU, 1 = GPU")]
	public static int upload_multidraw_meshes_mode = 0;

	[ClientVar(ClientAdmin = true)]
	public static bool render_shadows = true;

	[ClientVar(Help = "Whether to call ComputeBuffer.SetData immediately or at the end of the frame")]
	public static bool computebuffer_setdata_immediate = true;

	[ClientVar(ClientAdmin = true, Help = "Set the amount of instanced renderers to show for debugging")]
	public static int max_renderers = 0;

	[ClientVar(Saved = true, Help = "Max distance for instanced rendering, can be higher than normal render distance")]
	public static float instancing_render_distance = 1000f;

	public static bool IsInstancingDisabled => true;

	public static bool IsInstancingEnabled => !IsInstancingDisabled;

	[ClientVar(Name = "show_building_blocked", Saved = true)]
	public static bool show_building_blocked_client { get; set; } = true;

	[ClientVar(Name = "building_blocked_preview_distance", Help = "Distance from the border of building blocked to show the red preview")]
	public static float building_blocked_preview_distance { get; set; } = 100f;

	[ReplicatedVar]
	public static bool show_building_blocked_server { get; set; } = true;

	public static bool IsMultidrawEnabled => multidraw;

	[ClientVar(Name = "print_tree_counts", ClientAdmin = true, Help = "Print off count of trees to ensure server sent them all")]
	[ServerVar]
	public static void tree_entities(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Server Trees: {TreeManager.server.GetTreeCount()}");
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar(Name = "print_global_entities", Help = "Print off count of global building entities on the server")]
	[ClientVar(Name = "print_global_entities", ClientAdmin = true, Help = "Print off count of global building entities on the client")]
	public static void print_global_entities(Arg arg)
	{
		if (IsInstancingDisabled)
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("SERVER ENTITIES:");
		Dictionary<uint, int> dictionary = new Dictionary<uint, int>();
		foreach (GlobalEntityData value2 in GlobalNetworkHandler.server.serverData.Values)
		{
			dictionary.TryGetValue(value2.prefabId, out var value);
			dictionary[value2.prefabId] = value + 1;
		}
		KeyValuePair<uint, int>[] array = dictionary.OrderByDescending((KeyValuePair<uint, int> x) => x.Value).ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			KeyValuePair<uint, int> keyValuePair = array[i];
			stringBuilder.AppendLine($"{StringPool.Get(keyValuePair.Key)} - {keyValuePair.Value}");
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	private static void global_entities_client(StringBuilder builder)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(Name = "print_instanced_debug", Help = "Print off array size and memory usage to ensure no memory leaks & debug rendering system")]
	public static void instanced_memory_usage(Arg arg)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(ClientAdmin = true, Help = "Spawn (default 50k) prefabs spread across the map to quickly test instanced rendering system in isolation")]
	public static void test_instancing_culling(Arg arg)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(Name = "print_instanced_renderers", ClientAdmin = true, Help = "Print off number of each mesh inside instanced rendering system (including outside of render range)")]
	public static void instanced_renderers_debug(Arg arg)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(Name = "print_instanced_cell", ClientAdmin = true, Help = "Print number of meshes inside a single grid")]
	public static void print_instanced_grid(Arg arg)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(Name = "expand_instancing", ClientAdmin = true)]
	public static void expand_instancing(Arg arg)
	{
		_ = IsInstancingDisabled;
	}
}


using Facepunch;
using UnityEngine;

[Factory("reports")]
public class reports : ConsoleSystem
{
	[ServerVar(Default = "600")]
	[ClientVar(Default = "600")]
	public static int ExceptionReportMaxLength
	{
		get
		{
			return ExceptionReporter.ReportMessageMaxLength;
		}
		set
		{
			ExceptionReporter.ReportMessageMaxLength = Mathf.Max(value, 250);
		}
	}
}


[Factory("sentry")]
public class Sentry : ConsoleSystem
{
	[ServerVar(Help = "target everyone regardless of authorization")]
	public static bool targetall = false;

	[ServerVar(Help = "how long until something is considered hostile after it attacked")]
	public static float hostileduration = 120f;

	[ReplicatedVar(Help = "radius to check for other turrets")]
	public static float interferenceradius = 40f;

	[ReplicatedVar(Help = "max interference from other turrets")]
	public static int maxinterference = 12;

	[ServerVar(Help = "Prevents auto turrets getting added more than once to the IO queue")]
	public static bool debugPreventDuplicates = true;

	[ServerVar(Help = "How quickly can a turret acquire a potential target. Less is faster, but perf taxing")]
	public static float scantimer = 1f;
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Development.Attributes;
using Epic.OnlineServices.Logging;
using Epic.OnlineServices.Reports;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Rust;
using Network;
using Rust;
using UnityEngine;

[Factory("server")]
[ResetStaticFields]
public class Server : ConsoleSystem
{
	[ServerVar]
	public static string ip = "";

	[ServerVar]
	public static int port = 28015;

	[ServerVar]
	public static int queryport = 0;

	[ServerVar(ShowInAdminUI = true)]
	public static int maxplayers = 500;

	[ServerVar(ShowInAdminUI = true)]
	public static string hostname = "My Untitled Rust Server";

	[ServerVar]
	public static string identity = "my_server_identity";

	[ServerVar]
	public static string filefolderoverride = "";

	[ServerVar]
	public static string level = "Procedural Map";

	[ServerVar]
	public static string levelurl = "";

	[ServerVar]
	public static bool leveltransfer = true;

	[ServerVar]
	public static int seed = 1337;

	[ServerVar]
	public static int salt = 1;

	[ServerVar]
	public static int worldsize = 4500;

	[ServerVar]
	public static int saveinterval = 600;

	[ServerVar]
	public static int encryption = 2;

	[ServerVar]
	public static string anticheatid = "xyza7891h6UjNfd0eb2HQGtaul0WhfvS";

	[ServerVar]
	public static string anticheatkey = "OWUDFZmi9VNL/7VhGVSSmCWALKTltKw8ISepa0VXs60";

	[ServerVar]
	public static bool anticheattoken = true;

	[ServerVar]
	public static bool strictauth_eac = false;

	[ServerVar]
	public static bool strictauth_steam = false;

	[ServerVar]
	public static int tickrate = 10;

	[ServerVar]
	public static int entityrate = 16;

	[ServerVar]
	public static float schematime = 1800f;

	[ServerVar]
	public static float cycletime = 500f;

	[ServerVar]
	public static bool official = false;

	[ServerVar]
	public static bool stats = false;

	[ServerVar]
	public static bool stability = true;

	[ServerVar(ShowInAdminUI = true)]
	public static bool radiation = true;

	[ReplicatedVar]
	public static float max_explosive_protection = 0.75f;

	[ServerVar]
	public static float itemdespawn = 300f;

	[ServerVar]
	public static float itemdespawn_container_scale = 2f;

	[ServerVar]
	public static int itemdespawn_container_max_multiplier = 24;

	[ServerVar]
	public static float itemdespawn_quick = 30f;

	[ServerVar]
	public static float corpsedespawn = 300f;

	[ServerVar]
	public static float debrisdespawn = 30f;

	[ServerVar]
	public static bool pve = false;

	[ReplicatedVar]
	public static bool cinematic = false;

	[ServerVar(ShowInAdminUI = true)]
	public static string description = "No server description has been provided.";

	[ServerVar(ShowInAdminUI = true)]
	public static string url = "";

	[ServerVar]
	public static string branch = "";

	[ServerVar]
	public static int queriesPerSecond = 2000;

	[ServerVar]
	public static int ipQueriesPerMin = 30;

	[ServerVar]
	public static bool statBackup = false;

	[ServerVar]
	public static int rejoin_delay = 300;

	[ServerVar]
	public static string ping_region_code_override = "";

	private static string _favoritesEndpoint = "";

	[ServerVar(Saved = true, ShowInAdminUI = true)]
	public static string headerimage = "";

	[ServerVar(Saved = true, ShowInAdminUI = true)]
	public static string logoimage = "";

	[ServerVar(Saved = true, ShowInAdminUI = true)]
	public static int saveBackupCount = 2;

	[ReplicatedVar(Saved = true, ShowInAdminUI = true)]
	public static string motd = "";

	[ServerVar(Saved = true)]
	public static float meleedamage = 1f;

	[ServerVar(Saved = true)]
	public static float arrowdamage = 1f;

	[ServerVar(Saved = true)]
	public static float bulletdamage = 1f;

	[ServerVar(Saved = true)]
	public static float bleedingdamage = 1f;

	[ServerVar(Saved = true, Help = "How much to scale standard paintball damage (see paintballoverallsdamage for scaling damage for when players have overalls on)")]
	public static float paintballstandarddamage = 1f;

	[ServerVar(Saved = true, Help = "How much to scale paintball damage when both the hit player and initiator player have paintball overalls on (see paintballstandarddamage for scaling standard paintball damage)")]
	public static float paintballoverallsdamage = 1f;

	[ServerVar(Saved = true, Help = "How much to increase time to kill in pvp globally, 2.0 = twice as long, 0.5 = half as long")]
	public static float pvp_ttk_global = 1f;

	[ServerVar(Saved = true, Help = "How much to increase time to kill with melee in pvp globally, 2.0 = twice as long, 0.5 = half as long")]
	public static float pvp_ttk_melee = 1f;

	[ServerVar(Saved = true, Help = "How much to increase time to kill bullets in pvp globally, 2.0 = twice as long, 0.5 = half as long")]
	public static float pvp_ttk_bullet = 1f;

	[ServerVar(Help = "Lower damage of explosives to 1 and allow them to be triggered multiple times")]
	public static bool explosive_testing_mode = false;

	[ServerVar(Saved = true)]
	public static float oilrig_radiation_amount_scale = 1f;

	[ServerVar(Saved = true)]
	public static float oilrig_radiation_time_scale = 1f;

	[ServerVar]
	public static float oilrig_radiation_alarm_threshold = 0f;

	[ReplicatedVar(Saved = true)]
	public static float funWaterDamageThreshold = 0.8f;

	[ReplicatedVar(Saved = true)]
	public static float funWaterWetnessGain = 0.05f;

	[ServerVar(Saved = true)]
	public static float meleearmor = 1f;

	[ServerVar(Saved = true)]
	public static float arrowarmor = 1f;

	[ServerVar(Saved = true)]
	public static float bulletarmor = 1f;

	[ServerVar(Saved = true)]
	public static float bleedingarmor = 1f;

	[ServerVar(Saved = true)]
	public static float pvpBulletDamageMultiplier = 1f;

	[ServerVar(Saved = true)]
	public static float pveBulletDamageMultiplier = 1f;

	[ServerVar]
	public static int updatebatch = 512;

	[ServerVar]
	public static int updatebatchspawn = 1024;

	[ServerVar]
	public static int entitybatchsize = 100;

	[ServerVar]
	public static float entitybatchtime = 1f;

	[ServerVar]
	public static float composterUpdateInterval = 300f;

	[ReplicatedVar]
	public static float planttick = 60f;

	[ServerVar]
	public static float planttickscale = 1f;

	private static int _maxHttp = 32;

	[ServerVar]
	public static bool useMinimumPlantCondition = true;

	[ServerVar(Saved = true)]
	public static float nonPlanterDeathChancePerTick = 0.005f;

	[ServerVar(Saved = true)]
	public static float ceilingLightGrowableRange = 3f;

	[ReplicatedVar(Saved = true)]
	public static float artificialTemperatureGrowableRange = 4f;

	[ServerVar(Saved = true)]
	public static float ceilingLightHeightOffset = 3f;

	[ReplicatedVar(Saved = true)]
	public static float sprinklerRadius = 3f;

	[ServerVar(Saved = true)]
	public static float sprinklerEyeHeightOffset = 3f;

	[ServerVar(Saved = true)]
	public static bool useLegacySprinklerLoadProcess = false;

	[ServerVar(Saved = true)]
	public static float optimalPlanterQualitySaturation = 0.6f;

	[ServerVar]
	public static float metabolismtick = 1f;

	[ServerVar]
	public static float modifierTickRate = 1f;

	[ServerVar(Saved = true)]
	public static float rewounddelay = 60f;

	[ServerVar(Saved = true, Help = "Can players be wounded after receiving fatal damage")]
	public static bool woundingenabled = true;

	[ServerVar(Saved = true, Help = "Do players go into the crawling wounded state")]
	public static bool crawlingenabled = true;

	[ServerVar(Help = "Base chance of recovery after crawling wounded state", Saved = true)]
	public static float woundedrecoverchance = 0.2f;

	[ServerVar(Help = "Base chance of recovery after incapacitated wounded state", Saved = true)]
	public static float incapacitatedrecoverchance = 0.1f;

	[ServerVar(Help = "Maximum percent chance added to base wounded/incapacitated recovery chance, based on the player's food and water level", Saved = true)]
	public static float woundedmaxfoodandwaterbonus = 0.25f;

	[ServerVar(Help = "Minimum initial health given when a player dies and moves to crawling wounded state", Saved = false)]
	public static int crawlingminimumhealth = 7;

	[ServerVar(Help = "Maximum initial health given when a player dies and moves to crawling wounded state", Saved = false)]
	public static int crawlingmaximumhealth = 12;

	[ServerVar(Saved = true)]
	public static bool playerserverfall = true;

	[ServerVar]
	public static bool plantlightdetection = true;

	[ServerVar]
	public static float respawnresetrange = 50f;

	[ReplicatedVar]
	public static int max_sleeping_bags = 15;

	[ReplicatedVar]
	public static bool bag_quota_item_amount = true;

	[ServerVar]
	public static int maxunack = 4;

	[ServerVar]
	public static bool netcache = true;

	[ServerVar]
	public static bool corpses = true;

	[ServerVar]
	public static bool events = true;

	[ServerVar]
	public static bool dropitems = true;

	[ServerVar]
	public static int netcachesize = 0;

	[ServerVar]
	public static int savecachesize = 0;

	[ServerVar]
	public static int combatlogsize = 30;

	[ServerVar]
	public static int combatlogdelay = 10;

	[ServerVar]
	public static int authtimeout = 60;

	[ServerVar]
	public static int playertimeout = 60;

	[ServerVar(ShowInAdminUI = true)]
	public static int idlekick = 30;

	[ServerVar]
	public static int idlekickmode = 1;

	[ServerVar]
	public static int idlekickadmins = 0;

	[ServerVar]
	public static bool long_distance_sounds = true;

	private static string _gamemode;

	private static string _tags = "";

	[ServerVar(Help = "Censors the Steam player list to make player tracking more difficult")]
	public static bool censorplayerlist = true;

	[ServerVar(Help = "HTTP API endpoint for centralized banning (see wiki)")]
	public static string bansServerEndpoint = "";

	[ServerVar(Help = "Failure mode for centralized banning, set to 1 to reject players from joining if it's down (see wiki)")]
	public static int bansServerFailureMode = 0;

	[ServerVar(Help = "Timeout (in seconds) for centralized banning web server requests")]
	public static int bansServerTimeout = 5;

	[ServerVar(Help = "HTTP API endpoint for receiving F7 reports", Saved = true)]
	public static string reportsServerEndpoint = "";

	[ServerVar(Help = "If set, this key will be included with any reports sent via reportsServerEndpoint (for validation)", Saved = true)]
	public static string reportsServerEndpointKey = "";

	[ServerVar(Help = "Should F7 reports from players be printed to console", Saved = true)]
	public static bool printReportsToConsole = false;

	[ServerVar(Help = "If a player presses the respawn button, respawn at their death location (for trailer filming)")]
	public static bool respawnAtDeathPosition = false;

	[ServerVar(Help = "When a player respawns give them the loadout assigned to client.RespawnLoadout (created with inventory.saveloadout)")]
	public static bool respawnWithLoadout = false;

	[ServerVar(Help = "When transferring water, should containers keep 1 water behind. Enabling this should help performance if water IO is causing performance loss", Saved = true)]
	public static bool waterContainersLeaveWaterBehind = false;

	[ServerVar(Help = "How often industrial conveyors attempt to move items (value is an interval measured in seconds). Setting to 0 will disable all movement", Saved = true, ShowInAdminUI = true)]
	public static float conveyorMoveFrequency = 5f;

	[ServerVar(Help = "How often industrial crafters attempt to craft items (value is an interval measured in seconds). Setting to 0 will disable all crafting", Saved = true, ShowInAdminUI = true)]
	public static float industrialCrafterFrequency = 5f;

	[ReplicatedVar(Help = "How much scrap is required to research default blueprints", Saved = true, ShowInAdminUI = true)]
	public static int defaultBlueprintResearchCost = 10;

	[ServerVar(Help = "Whether to check for illegal industrial pipes when changing building block states (roof bunkers)", Saved = true, ShowInAdminUI = true)]
	public static bool enforcePipeChecksOnBuildingBlockChanges = true;

	[ServerVar(Help = "How many stacks a single conveyor can move in a single tick", Saved = true, ShowInAdminUI = true)]
	public static int maxItemStacksMovedPerTickIndustrial = 12;

	[ServerVar(Help = "How long per frame to spend on industrial jobs", Saved = true, ShowInAdminUI = true)]
	public static float industrialFrameBudgetMs = 0.5f;

	[ServerVar(Help = "Should indusrial be paused during autosaves")]
	public static bool pauseindustrialduringsave = true;

	[ServerVar(Help = "When enabled industrial transfers will abort if they start to take too long. Will lead to inconsistent splitting but should retain performance", Saved = true)]
	public static bool industrialTransferStrictTimeLimits = true;

	[ServerVar(Help = "Enables a faster way to move items around during conveyor transfers. Should be on unless there's a issue")]
	public static bool industrialAllowQuickMove = true;

	[ServerVar(Help = "How long per frame to spend animating items moving into the hopper (will be instant if <= 0)", Saved = true, ShowInAdminUI = true)]
	public static float hopperAnimationBudgetMs = 0.1f;

	[ServerVar(Help = "Set to false to disable the storage adaptor sorting functionality")]
	public static bool allowSorting = true;

	[ReplicatedVar(Help = "How many markers each player can place", Saved = true, ShowInAdminUI = true)]
	public static int maximumMapMarkers = 5;

	[ServerVar(Help = "How many pings can be placed by each player", Saved = true, ShowInAdminUI = true)]
	public static int maximumPings = 5;

	[ServerVar(Help = "How long a ping should last", Saved = true, ShowInAdminUI = true)]
	public static float pingDuration = 10f;

	[ServerVar(Help = "Allows backpack equipping while not grounded", Saved = true, ShowInAdminUI = true)]
	public static bool canEquipBackpacksInAir = false;

	[ReplicatedVar(Help = "How long it takes to pick up a used parachute in seconds", Saved = true, ShowInAdminUI = true)]
	public static float parachuteRepackTime = 8f;

	[ServerVar(Help = "Whether emoji ownership is checked server side. Could be performance draining in high chat volumes")]
	public static bool emojiOwnershipCheck = true;

	[ReplicatedVar(Help = "Skip death screen fade", Saved = false, ShowInAdminUI = false)]
	public static bool skipDeathScreenFade = false;

	[ReplicatedVar(Help = "Controls whether the tutorial is enabled on this server", Saved = true, ShowInAdminUI = true, Default = "false")]
	public static bool tutorialEnabled = false;

	[ReplicatedVar(Help = "How much of a tax to apply to tech unlocks at a level 1 workbench. 10 = additional 10% scrap cost", Saved = true)]
	public static float workbenchTaxRate1 = 0f;

	[ReplicatedVar(Help = "How much of a tax to apply to tech unlocks at a level 2 workbench. 10 = additional 10% scrap cost", Saved = true)]
	public static float workbenchTaxRate2 = 0f;

	[ReplicatedVar(Help = "How much of a tax to apply to tech unlocks at a level 3 workbench. 10 = additional 10% scrap cost", Saved = true)]
	public static float workbenchTaxRate3 = 0f;

	[ServerVar(Help = "Automatically upload procedurally generated maps so that players download them (faster) instead of re-generating them", Saved = true, ShowInAdminUI = true)]
	public static bool autoUploadMap = true;

	[ReplicatedVar(Help = "Can players use the in-game map")]
	public static bool mapenabled = true;

	[ReplicatedVar(Help = "Should the in-game map be covered by a fog of war")]
	public static bool fogofwar = false;

	[ReplicatedVar(Help = "Should the deep sea map be covered by fog of war")]
	public static bool deepSeaFogofwar = true;

	[ReplicatedVar(Help = "How much area around the player is revealed when using fog of war. Must be a multiple of 32")]
	public static int fogofwarrevealsize = 256;

	[ReplicatedVar(Help = "Will the in-game compass show at the top of the screen")]
	public static bool compassenabled = true;

	[ReplicatedVar(Help = "Should the player see their position on the map")]
	public static bool hideplayeronmap = false;

	[ReplicatedVar(Help = "Should hte player see their direction on the map")]
	public static bool hideplayermapdirection = false;

	[ServerVar(Help = "Automatically upload an image of the map, used to show the map in the server browser", Saved = true, ShowInAdminUI = true)]
	public static bool autoUploadMapImages = true;

	[ServerVar(Help = "How often (in hours) the water well NPC's update their sell orders")]
	public static float waterWellNpcSalesRefreshFrequency = 1f;

	[ReplicatedVar(Help = "Opens a loot panel when interacting with a workbench instead of going straight into the tech tree. Designed for backwards compatibility with mods.")]
	public static bool useLegacyWorkbenchInteraction = false;

	[ServerVar(Help = "If no players are in this range kayaks, boogie boards and inner tubes will switch to a cheaper buoyancy system")]
	public static float lowPriorityBuoyancyRange = 30f;

	[ServerVar(Help = "If true hot air balloons can be shot down with homing missiles")]
	public static bool homingMissileTargetsHab = false;

	[ServerVar(Help = "Require a premium status account to connect to this server")]
	public static bool premium = false;

	[ReplicatedVar(Help = "Whether to run the food spoiling system")]
	public static bool foodSpoiling = true;

	[ServerVar]
	public static float foodSpoilingBudgetMs = 0.05f;

	[ServerVar(Help = "Maximum difference (in seconds) that two items with spoil timers can have and still be stackable")]
	public static float maxFoodSpoilTimeDiffForItemStack = 180f;

	[ServerVar(Help = "If two spoiled food items are both above this threshold then we will allow them to be stacked")]
	public static float normalisedFoodSpoilTimeStackThreshold = 0.9f;

	[ServerVar(Help = "Whether to run local avoidance for chickens, disabling might get a slight performance improvement but chickens will clip", Saved = true, ShowInAdminUI = true)]
	public static bool farmChickenLocalAvoidance = true;

	[ServerVar(Help = "Endpoint to use to check if players have premium status")]
	public static string premiumVerifyEndpoint = "https://rust-api.facepunch.com/api/premium/verify";

	[ServerVar(Help = "Minimum time to recheck premium status for already connected players (in seconds)")]
	public static float premiumRecheckMinSeconds = 300f;

	[ServerVar(Help = "How often to do premium status rechecks")]
	public static float premiumRecheckInterval = 300f;

	[ServerVar(Help = "Maximum number of players to recheck at a time")]
	public static int premiumRecheckMaxBatchSize = 100;

	[ServerVar(Saved = true)]
	public static bool spawnVineTrees = true;

	[ServerVar(Saved = true)]
	public static bool allowVineSwinging = true;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Bags will increase their respawn time by this much")]
	public static float respawnTimeAdditionBag = 0f;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Beds will increase their respawn time by this much")]
	public static float respawnTimeAdditionBed = 0f;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "All ammo drops from NPC loot will be multiplied by this")]
	public static float npcAmmoLootMultiplier = 1f;

	[ReplicatedVar(Help = "Multiplies crafting cost of firearm ammunition", Saved = true, ShowInAdminUI = true)]
	public static float hardcoreFirearmAmmunitionCraftingMultiplier = 1f;

	[ServerVar(Help = "Allows radiation to flood monuments to force puzzles to reset")]
	public static bool monumentPuzzleResetRadiation = true;

	[ServerVar]
	public static float monumentPuzzleResetRadiationRadiusMultiplier = 1.5f;

	[ServerVar(Help = "Clamp radiation multiplier to this amount of meters, -1 = ignored")]
	public static float monumentPuzzleResetRadiationMaxRadiusIncrease = 20f;

	[ServerVar(Help = "How long before the reset happens do we start applying radiation")]
	public static float monumentPuzzleResetRadiationPreResetTime = 300f;

	[ServerVar(Help = "How long does a monument puzzle need to be empty with full rads before it can reset")]
	public static float monumentPuzzleResetRadiationPlayerEmptyTime = 120f;

	[ServerVar]
	public static float monumentPuzzleResetRadiationAmount = 3f;

	[ServerVar(Help = "Force enable radiation in monument puzzles to confirm they work")]
	public static bool monumentpuzzleresetradiationoverride = false;

	[ServerVar]
	public static bool drawpuzzleresets = false;

	[ServerVar]
	public static bool pauseunlootedpuzzles = true;

	[ServerVar(Saved = true)]
	public static bool monumentPuzzleResetWarnings = true;

	[ServerVar(Saved = true)]
	public static float ovenCookBudgetMs = 0.25f;

	[ServerVar(Saved = true)]
	public static bool showHolsteredItems = true;

	[ServerVar]
	public static int maxpacketspersecond_world = 1;

	[ServerVar]
	public static int maxpacketspersecond_rpc = 200;

	[ServerVar]
	public static int maxpacketspersecond_rpc_signal = 30;

	[ServerVar]
	public static int maxpacketspersecond_command = 100;

	[ServerVar]
	public static int maxpacketsize_command = 100000;

	[ServerVar]
	public static int maxpacketsize_globaltrees = 100;

	[ServerVar]
	public static int maxpacketsize_globalentities = 1000;

	[ServerVar]
	public static int maxpacketspersecond_tick = 300;

	[ServerVar]
	public static int maxpacketspersecond_voice = 100;

	[ServerVar]
	public static int maxpacketspersecond_syncvar = 200;

	[ServerVar]
	public static bool packetlog_enabled = false;

	[ServerVar]
	public static bool rpclog_enabled = false;

	[ServerVar(Help = "MS per frame to spend warming up entity save caches")]
	public static int saveframebudget = 5;

	[ServerVar(Help = "Player Update parallelism mode. 0 - serial(def); 1 - burst jobs; 2 - 1 + managed tasks")]
	public static int UsePlayerUpdateJobs = 0;

	[ServerVar(Help = "UsePlayerUpdateJobs 2 related - how many snapshot messages to batch into 1 task")]
	public static int SnapshotTaskBatchCount = 64;

	[ServerVar(Help = "UsePlayerUpdateJobs 2 related - how many destroy messages to batch into 1 task")]
	public static int DestroyTaskBatchCount = 128;

	[ServerVar(Help = "Runs extra validation checks to prevent crashes and instead switch back to vanilla processing")]
	public static bool EmergencyDisablePlayerJobs = true;

	[ServerVar(Saved = true)]
	public static string server_id
	{
		get
		{
			return DemoConVars.ServerId;
		}
		set
		{
			DemoConVars.ServerId = value;
		}
	}

	[ServerVar(ShowInAdminUI = true, Saved = true, Help = "Domain name to save when players favorite your server. The port can be omitted if using the default port or a SRV DNS record is created.")]
	public static string favoritesEndpoint
	{
		get
		{
			return _favoritesEndpoint;
		}
		set
		{
			if (string.IsNullOrWhiteSpace(value))
			{
				_favoritesEndpoint = "";
				return;
			}
			value = value.Trim();
			if (value.StartsWith("https://"))
			{
				string text = value;
				int length = "https://".Length;
				value = text.Substring(length, text.Length - length);
			}
			if (value.StartsWith("http://"))
			{
				string text = value;
				int length = "http://".Length;
				value = text.Substring(length, text.Length - length);
			}
			_favoritesEndpoint = value.Trim().ToLowerInvariant();
		}
	}

	[ServerVar]
	public static int anticheatlog
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)EOS.LogLevel;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			EOS.LogLevel = (LogLevel)value;
		}
	}

	[ServerVar]
	public static int http_connection_limit
	{
		get
		{
			return _maxHttp;
		}
		set
		{
			_maxHttp = value;
			HttpManager.UpdateMaxConnections();
		}
	}

	[ServerVar]
	public static string gamemode
	{
		get
		{
			return _gamemode;
		}
		set
		{
			_gamemode = value;
			ApplyGamemode();
		}
	}

	[ServerVar(Help = "Comma-separated server browser tag values (see wiki)", Saved = true, ShowInAdminUI = true)]
	public static string tags
	{
		get
		{
			return _tags;
		}
		set
		{
			_tags = AutoCorrectTags(value);
		}
	}

	[ServerVar]
	public static int maxclientinfosize
	{
		get
		{
			return Connection.MaxClientInfoSize;
		}
		set
		{
			Connection.MaxClientInfoSize = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxconnectionsperip
	{
		get
		{
			return Server.MaxConnectionsPerIP;
		}
		set
		{
			Server.MaxConnectionsPerIP = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxreceivetime
	{
		get
		{
			return Server.MaxReceiveTime;
		}
		set
		{
			Server.MaxReceiveTime = Mathf.Clamp(value, 10, 1000);
		}
	}

	[ServerVar]
	public static int maxmainthreadwait
	{
		get
		{
			return Server.MaxMainThreadWait;
		}
		set
		{
			Server.MaxMainThreadWait = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxreadthreadwait
	{
		get
		{
			return Server.MaxReadThreadWait;
		}
		set
		{
			Server.MaxReadThreadWait = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxwritethreadwait
	{
		get
		{
			return Server.MaxWriteThreadWait;
		}
		set
		{
			Server.MaxWriteThreadWait = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxdecryptthreadwait
	{
		get
		{
			return Server.MaxDecryptThreadWait;
		}
		set
		{
			Server.MaxDecryptThreadWait = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxreadqueuelength
	{
		get
		{
			return Server.MaxReadQueueLength;
		}
		set
		{
			Server.MaxReadQueueLength = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxwritequeuelength
	{
		get
		{
			return Server.MaxWriteQueueLength;
		}
		set
		{
			Server.MaxWriteQueueLength = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxdecryptqueuelength
	{
		get
		{
			return Server.MaxDecryptQueueLength;
		}
		set
		{
			Server.MaxDecryptQueueLength = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxreadqueuebytes
	{
		get
		{
			return Server.MaxReadQueueBytes;
		}
		set
		{
			Server.MaxReadQueueBytes = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxwritequeuebytes
	{
		get
		{
			return Server.MaxWriteQueueBytes;
		}
		set
		{
			Server.MaxWriteQueueBytes = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxdecryptqueuebytes
	{
		get
		{
			return Server.MaxDecryptQueueBytes;
		}
		set
		{
			Server.MaxDecryptQueueBytes = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int player_state_cache_size
	{
		get
		{
			return SingletonComponent<ServerMgr>.Instance?.playerStateManager.CacheSize ?? 0;
		}
		set
		{
			SingletonComponent<ServerMgr>.Instance.playerStateManager.CacheSize = value;
		}
	}

	[ServerVar]
	public static int maxpacketspersecond
	{
		get
		{
			return (int)Server.MaxPacketsPerSecond;
		}
		set
		{
			Server.MaxPacketsPerSecond = (ulong)Mathf.Clamp(value, 1, 1000000);
		}
	}

	public static string rootFolder => "server/" + identity;

	public static string filesStorageFolder
	{
		get
		{
			if (!string.IsNullOrEmpty(filefolderoverride))
			{
				return filefolderoverride;
			}
			return rootFolder;
		}
	}

	public static string backupFolder => "backup/0/" + identity;

	public static string backupFolder1 => "backup/1/" + identity;

	public static string backupFolder2 => "backup/2/" + identity;

	public static string backupFolder3 => "backup/3/" + identity;

	[ServerVar]
	public static bool compression
	{
		get
		{
			if (Net.sv == null)
			{
				return false;
			}
			return Net.sv.compressionEnabled;
		}
		set
		{
			Net.sv.compressionEnabled = value;
		}
	}

	[ServerVar]
	public static bool netlog
	{
		get
		{
			if (Net.sv == null)
			{
				return false;
			}
			return Net.sv.logging;
		}
		set
		{
			Net.sv.logging = value;
		}
	}

	public static bool UsePlayerTasks => UsePlayerUpdateJobs >= 2;

	[ReplicatedVar(Name = "era", Help = "none,primitive,medieval,frontier,rust")]
	public static string era
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			Era val = Era;
			return ((object)(Era)(ref val)/*cast due to .constrained prefix*/).ToString();
		}
		set
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Unknown result type (might be due to invalid IL or missing references)
			if (string.IsNullOrEmpty(value) && (int)Era != 0)
			{
				Era = (Era)0;
				OnEraChanged();
				return;
			}
			Era val = Era;
			switch (value.ToLower())
			{
			case "unknown":
			case "none":
				Era = (Era)0;
				break;
			case "primitive":
				Era = (Era)10;
				break;
			case "siege":
			case "medieval":
				Era = (Era)20;
				break;
			case "frontier":
				Era = (Era)30;
				break;
			case "modern":
			case "rust":
				Era = (Era)1000;
				break;
			}
			if (val != Era)
			{
				OnEraChanged();
			}
		}
	}

	public static Era Era { get; private set; }

	private static void ApplyGamemode()
	{
		GameModeManifest gameModeManifest = GameModeManifest.Get();
		if ((Object)(object)gameModeManifest == (Object)null)
		{
			Debug.LogError((object)"No GameModeManifest found");
			return;
		}
		foreach (GameObjectRef gameModePrefab in gameModeManifest.gameModePrefabs)
		{
			object obj;
			if (gameModePrefab == null)
			{
				obj = null;
			}
			else
			{
				GameObject obj2 = gameModePrefab.Get();
				obj = ((obj2 != null) ? obj2.GetComponent<BaseGameMode>() : null);
			}
			BaseGameMode baseGameMode = (BaseGameMode)obj;
			if (baseGameMode.shortname == gamemode)
			{
				baseGameMode.ApplyConVars();
				return;
			}
		}
		Debug.LogWarning((object)("Couldn't find gamemode: " + gamemode));
	}

	public static float GetTaxRateForWorkbenchUnlock(int workbenchLevel)
	{
		float num = 0f;
		switch (workbenchLevel)
		{
		case 0:
			num = workbenchTaxRate1;
			break;
		case 1:
			num = workbenchTaxRate2;
			break;
		case 2:
			num = workbenchTaxRate3;
			break;
		}
		return Mathf.Clamp(num, 0f, 100f);
	}

	public static float TickDelta()
	{
		return 1f / (float)tickrate;
	}

	public static float TickTime(uint tick)
	{
		return (float)((double)TickDelta() * (double)tick);
	}

	[ServerVar(Help = "Show holstered items on player bodies")]
	public static void setshowholstereditems(Arg arg)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		showHolsteredItems = arg.GetBool(0, showHolsteredItems);
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.inventory.UpdatedVisibleHolsteredItems();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.inventory.UpdatedVisibleHolsteredItems();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar]
	public static void player_state_cache_count(Arg args)
	{
		args.ReplyWith((object)SingletonComponent<ServerMgr>.Instance.playerStateManager.CacheCount);
	}

	[ServerVar]
	public static void player_state_cache_evictions(Arg args)
	{
		args.ReplyWith((object)SingletonComponent<ServerMgr>.Instance.playerStateManager.CacheEvictions);
	}

	[ServerVar]
	public static string printreadqueue(Arg arg)
	{
		return "Server read queue: " + ((BaseNetwork)Net.sv).ReadQueueLength + " items / " + NumberExtensions.FormatBytes<int>(((BaseNetwork)Net.sv).ReadQueueBytes, false);
	}

	[ServerVar]
	public static string printwritequeue(Arg arg)
	{
		return "Server write queue: " + ((BaseNetwork)Net.sv).WriteQueueLength + " items / " + NumberExtensions.FormatBytes<int>(((BaseNetwork)Net.sv).WriteQueueBytes, false);
	}

	[ServerVar]
	public static string printdecryptqueue(Arg arg)
	{
		return "Server decrypt queue: " + ((BaseNetwork)Net.sv).DecryptQueueLength + " items / " + NumberExtensions.FormatBytes<int>(((BaseNetwork)Net.sv).DecryptQueueBytes, false);
	}

	[ServerVar]
	public static string packetlog(Arg arg)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (!packetlog_enabled)
		{
			return "Packet log is not enabled.";
		}
		List<Tuple<Type, ulong>> list = new List<Tuple<Type, ulong>>();
		foreach (KeyValuePair<Type, TimeAverageValue> item2 in SingletonComponent<ServerMgr>.Instance.packetHistory.dict)
		{
			list.Add(new Tuple<Type, ulong>(item2.Key, item2.Value.Calculate()));
		}
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("type");
			val.AddColumn("calls");
			foreach (Tuple<Type, ulong> item3 in list.OrderByDescending((Tuple<Type, ulong> entry) => entry.Item2))
			{
				if (item3.Item2 == 0L)
				{
					break;
				}
				Type item = item3.Item1;
				string text = ((object)(Type)(ref item)/*cast due to .constrained prefix*/).ToString();
				string text2 = item3.Item2.ToString();
				val.AddRow(new string[2] { text, text2 });
			}
			return flag ? val.ToJson(true) : ((object)val).ToString();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static string rpclog(Arg arg)
	{
		if (!rpclog_enabled)
		{
			return "RPC log is not enabled.";
		}
		List<Tuple<uint, ulong>> list = new List<Tuple<uint, ulong>>();
		foreach (KeyValuePair<uint, TimeAverageValue> item in SingletonComponent<ServerMgr>.Instance.rpcHistory.dict)
		{
			list.Add(new Tuple<uint, ulong>(item.Key, item.Value.Calculate()));
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("id");
			val.AddColumn("name");
			val.AddColumn("calls");
			foreach (Tuple<uint, ulong> item2 in list.OrderByDescending((Tuple<uint, ulong> entry) => entry.Item2))
			{
				if (item2.Item2 == 0L)
				{
					break;
				}
				string text = item2.Item1.ToString();
				string text2 = StringPool.Get(item2.Item1);
				string text3 = item2.Item2.ToString();
				val.AddRow(new string[3] { text, text2, text3 });
			}
			return ((object)val).ToString();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Starts a server")]
	public static void start(Arg arg)
	{
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			arg.ReplyWith("There is already a server running!");
			return;
		}
		string strLevelName = arg.GetString(0, level);
		if (!LevelManager.IsValid(strLevelName))
		{
			arg.ReplyWith("Level '" + strLevelName + "' isn't valid!");
			return;
		}
		if (Object.op_Implicit((Object)(object)Object.FindObjectOfType<ServerMgr>()))
		{
			arg.ReplyWith("There is already a server running!");
			return;
		}
		Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/shared.prefab"));
		Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/server.prefab"));
		((MonoBehaviour)Global.Runner).StartCoroutine(LoadImpl());
		IEnumerator LoadImpl()
		{
			yield return LevelManager.LoadLevelAsync(strLevelName);
		}
	}

	[ServerVar(Help = "Stops a server")]
	public static void stop(Arg arg)
	{
		if (!((BaseNetwork)Net.sv).IsConnected())
		{
			arg.ReplyWith("There isn't a server running!");
		}
		else
		{
			Net.sv.Stop(arg.GetString(0, "Stopping Server"));
		}
	}

	[ServerVar(Help = "Backup server folder")]
	public static void backup()
	{
		DirectoryEx.Backup(backupFolder, backupFolder1, backupFolder2, backupFolder3);
		DirectoryEx.CopyAll(rootFolder, backupFolder);
	}

	public static string GetServerFolder(string folder)
	{
		string text = rootFolder + "/" + folder;
		if (Directory.Exists(text))
		{
			return text;
		}
		Directory.CreateDirectory(text);
		return text;
	}

	[ServerVar(Help = "Writes config files")]
	public static void writecfg(Arg arg)
	{
		string contents = ConsoleSystem.SaveToConfigString(true);
		File.WriteAllText(GetServerFolder("cfg") + "/serverauto.cfg", contents);
		ServerUsers.Save();
		arg.ReplyWith("Config Saved");
	}

	[ServerVar]
	public static void fps(Arg arg)
	{
		arg.ReplyWith(Performance.report.frameRate + " FPS");
	}

	[ServerVar(Help = "Force save the current game")]
	public static void save(Arg arg)
	{
		Stopwatch stopwatch = Stopwatch.StartNew();
		foreach (BaseEntity save in BaseEntity.saveList)
		{
			save.InvalidateNetworkCache();
		}
		Debug.Log((object)("Invalidate Network Cache took " + stopwatch.Elapsed.TotalSeconds.ToString("0.00") + " seconds"));
		SaveRestore.Save(AndWait: true);
	}

	[ServerVar]
	public static string readcfg(Arg arg)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		string serverFolder = GetServerFolder("cfg");
		Option server;
		if (File.Exists(serverFolder + "/serverauto.cfg"))
		{
			string text = File.ReadAllText(serverFolder + "/serverauto.cfg");
			server = Option.Server;
			ConsoleSystem.RunFile(((Option)(ref server)).Quiet(), text);
		}
		if (File.Exists(serverFolder + "/server.cfg"))
		{
			string text2 = File.ReadAllText(serverFolder + "/server.cfg");
			server = Option.Server;
			ConsoleSystem.RunFile(((Option)(ref server)).Quiet(), text2);
		}
		return "Server Config Loaded";
	}

	[ServerVar]
	public static string netprotocol(Arg arg)
	{
		if (Net.sv == null)
		{
			return string.Empty;
		}
		return Net.sv.ProtocolId;
	}

	[ServerUserVar]
	public static void cheatreport(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			string text = arg.GetUInt64(0, 0uL).ToString();
			string @string = arg.GetString(1, "");
			Debug.LogWarning((object)(((object)basePlayer)?.ToString() + " reported " + text + ": " + StringEx.ToPrintable(@string, 140)));
			EACServer.SendPlayerBehaviorReport(basePlayer, (PlayerReportsCategory)1, text, @string);
		}
	}

	[ServerVar(Help = "Get info on player corpses on the server")]
	public static void corpseinfo(Arg arg)
	{
		PlayerCorpse[] array = BaseNetworkable.serverEntities.OfType<PlayerCorpse>().ToArray();
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		PlayerCorpse[] array2 = array;
		foreach (PlayerCorpse playerCorpse in array2)
		{
			if (playerCorpse.isClient)
			{
				continue;
			}
			num++;
			if (playerCorpse.CorpseIsRagdoll)
			{
				num2++;
				if (playerCorpse.CorpseRagdollScript.IsKinematic)
				{
					num3++;
				}
				else if (playerCorpse.CorpseRagdollScript.IsFullySleeping())
				{
					num4++;
				}
			}
		}
		int num5 = num2 - num3 - num4;
		float num6 = ((num2 > 0) ? ((float)num5 / (float)num2) : 0f);
		string text = $"Found {num} player corpses in the world, " + $"of which {num2} are using server-side ragdolls. " + $"{num5} of those are active ({num6:0%}), {num4} are sleeping, and {num3} are kinematic.";
		arg.ReplyWith(text);
	}

	[ServerAllVar(Help = "Get the player combat log")]
	public static string combatlog(Arg arg)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1) && arg.IsAdmin)
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if ((Object)(object)basePlayer == (Object)null || basePlayer.net == null)
		{
			return "invalid player";
		}
		CombatLog combat = basePlayer.stats.combat;
		int count = combatlogsize;
		bool json = arg.HasArg("--json", false);
		bool isAdmin = arg.IsAdmin;
		ulong requestingUser = arg.Connection?.userid ?? 0;
		return combat.Get(count, default(NetworkableId), json, isAdmin, requestingUser);
	}

	[ServerAllVar(Help = "Get the player combat log, only showing outgoing damage")]
	public static string combatlog_outgoing(Arg arg)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1) && arg.IsAdmin)
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if ((Object)(object)basePlayer == (Object)null)
		{
			return "invalid player";
		}
		return basePlayer.stats.combat.Get(combatlogsize, basePlayer.net.ID, arg.HasArg("--json", false), arg.IsAdmin, arg.Connection?.userid ?? 0);
	}

	[ServerVar(Help = "Print the current player position.")]
	public static string printpos(Arg arg)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1))
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Vector3 position = ((Component)basePlayer).transform.position;
			return ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
		}
		return "invalid player";
	}

	[ServerVar(Help = "Print the current player center position.")]
	public static string printposcenter(Arg arg)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1))
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Vector3 center = basePlayer.GetCenter(ducked: false);
			return ((object)(Vector3)(ref center)/*cast due to .constrained prefix*/).ToString();
		}
		return "invalid player";
	}

	[ServerVar(Help = "Print the current player rotation.")]
	public static string printrot(Arg arg)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1))
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Quaternion rotation = ((Component)basePlayer).transform.rotation;
			Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
			return ((object)(Vector3)(ref eulerAngles)/*cast due to .constrained prefix*/).ToString();
		}
		return "invalid player";
	}

	[ServerVar(Help = "Print the current player eyes.")]
	public static string printeyes(Arg arg)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1))
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Quaternion rotation = basePlayer.eyes.rotation;
			Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
			return ((object)(Vector3)(ref eulerAngles)/*cast due to .constrained prefix*/).ToString();
		}
		return "invalid player";
	}

	[ServerVar(ServerAdmin = true, Help = "This sends a snapshot of all the entities in the client's pvs. This is mostly redundant, but we request this when the client starts recording a demo.. so they get all the information.")]
	public static void snapshot(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Debug.Log((object)("Sending full snapshot to " + (object)basePlayer));
			basePlayer.SendNetworkUpdateImmediate();
			basePlayer.SendGlobalSnapshot();
			basePlayer.SendFullSnapshot();
			basePlayer.SendEntityUpdate();
			TreeManager.SendSnapshot(basePlayer);
			ServerMgr.SendReplicatedVars(basePlayer.net.connection);
		}
	}

	[ServerVar(Help = "Send network update for all players")]
	public static void sendnetworkupdate(Arg arg)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.SendNetworkUpdate();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static void GetPlayerListPosTable(TextTable table)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		table.ResizeColumns(4);
		table.AddColumn("SteamID");
		table.AddColumn("DisplayName");
		table.AddColumn("POS");
		table.AddColumn("ROT");
		table.ResizeRows(BasePlayer.activePlayerList.Count);
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				table.AddValue(current.userID.Get());
				table.AddValue(current.displayName);
				table.AddValue(((Component)current).transform.position);
				table.AddValue(current.eyes.BodyForward());
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Prints the position of all players on the server")]
	public static void playerlistpos(Arg arg)
	{
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			GetPlayerListPosTable(val);
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Prints all the vending machines on the server")]
	public static void listvendingmachines(Arg arg)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumns(new string[3] { "EntityId", "Position", "Name" });
			foreach (VendingMachine item in BaseNetworkable.serverEntities.OfType<VendingMachine>())
			{
				string[] obj = new string[3]
				{
					((object)(NetworkableId)(ref item.net.ID)/*cast due to .constrained prefix*/).ToString(),
					null,
					null
				};
				Vector3 position = ((Component)item).transform.position;
				obj[1] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
				obj[2] = StringExtensions.QuoteSafe(item.shopName);
				val.AddRow(obj);
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Prints all the Tool Cupboards on the server")]
	public static void listtoolcupboards(Arg arg)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumns(new string[3] { "EntityId", "Position", "Authed" });
			foreach (BuildingPrivlidge item in BaseNetworkable.serverEntities.OfType<BuildingPrivlidge>())
			{
				string[] obj = new string[3]
				{
					((object)(NetworkableId)(ref item.net.ID)/*cast due to .constrained prefix*/).ToString(),
					null,
					null
				};
				Vector3 position = ((Component)item).transform.position;
				obj[1] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
				obj[2] = item.authorizedPlayers.Count.ToString();
				val.AddRow(obj);
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void BroadcastPlayVideo(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		if (string.IsNullOrWhiteSpace(@string))
		{
			arg.ReplyWith("Missing video URL");
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Command("client.playvideo", @string);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Sent video to {BasePlayer.activePlayerList.Count} players");
	}

	[ServerVar(Help = "Rescans the serveremoji folder, note that clients will need to reconnect to get the latest emoji")]
	public static void ResetServerEmoji()
	{
		RustEmojiLibrary.ResetServerEmoji();
	}

	[ServerVar]
	public static string BotCount()
	{
		return BasePlayer.bots.Count.ToString();
	}

	[ServerVar(Help = "Prints the current wipe id of the sav")]
	public static void printwipeid(Arg arg)
	{
		if (string.IsNullOrEmpty(SaveRestore.WipeId))
		{
			arg.ReplyWith("ERROR: wipe ID is null or empty!");
		}
		else
		{
			arg.ReplyWith(SaveRestore.WipeId);
		}
	}

	[ServerVar(Help = "Clears the loot spawn cache used to restrict loot into each era")]
	public static void clear_loot_spawn_cache(Arg arg)
	{
		LootContainer[] source = (from x in GameManager.server.preProcessed.prefabList.Values
			select x.GetComponent<LootContainer>() into x
			where (Object)(object)x != (Object)null
			select x).ToArray();
		LootSpawn[] array = (from x in source.Select((LootContainer x) => x.lootDefinition).Concat(from x in source.SelectMany((LootContainer x) => x.LootSpawnSlots)
				select x.definition)
			where (Object)(object)x != (Object)null
			select x).ToArray();
		LootSpawn[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].ClearCache();
		}
		arg.ReplyWith($"Cleared {array.Length} loot spawn caches");
	}

	[ServerVar]
	public static void clear_trees_radius(Arg arg)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		float @float = arg.GetFloat(0, 0f);
		Vector3 position = (((Object)(object)basePlayer != (Object)null) ? ((Component)basePlayer).transform.position : Vector3.zero);
		if (arg.HasArgs(2))
		{
			position = arg.GetVector3(1, default(Vector3));
		}
		int num = 0;
		if ((Object)(object)basePlayer != (Object)null)
		{
			List<TreeEntity> list = Pool.Get<List<TreeEntity>>();
			Vis.Entities(position, @float, list, 1073741824, (QueryTriggerInteraction)2);
			foreach (TreeEntity item in list)
			{
				item.Kill();
				num++;
			}
		}
		arg.ReplyWith($"Deleted {num} server tree entities within {@float}m");
	}

	[ServerVar]
	public static void clear_bushes_radius(Arg arg)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		float @float = arg.GetFloat(0, 0f);
		Vector3 position = (((Object)(object)basePlayer != (Object)null) ? ((Component)basePlayer).transform.position : Vector3.zero);
		if (arg.HasArgs(2))
		{
			position = arg.GetVector3(1, default(Vector3));
		}
		int num = 0;
		if ((Object)(object)basePlayer != (Object)null)
		{
			PooledList<BushEntity> val = Pool.Get<PooledList<BushEntity>>();
			try
			{
				Vis.Entities(position, @float, (List<BushEntity>)(object)val, 67108864, (QueryTriggerInteraction)2);
				foreach (BushEntity item in (List<BushEntity>)(object)val)
				{
					item.Kill();
					num++;
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		arg.ReplyWith($"Deleted {num} server bush entities within {@float}m");
	}

	[ServerVar(Help = "Deletes items on the server that are not allowed in the era")]
	public static void enforce_era_restrictions(Arg arg)
	{
		int num = 0;
		int num2 = 0;
		Dictionary<string, int> dictionary = new Dictionary<string, int>();
		foreach (Item allItem in ItemManager.GetAllItems())
		{
			num++;
			if (!allItem.info.IsAllowed((EraRestriction)0))
			{
				if (!dictionary.ContainsKey(allItem.info.shortname))
				{
					dictionary.Add(allItem.info.shortname, allItem.amount);
				}
				else
				{
					dictionary[allItem.info.shortname] += allItem.amount;
				}
				allItem.Remove();
				num2++;
			}
		}
		ItemManager.DoRemoves();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Iterated '{num}' items and removed '{num2}' restricted items");
		foreach (KeyValuePair<string, int> item in dictionary)
		{
			stringBuilder.AppendLine($"{item.Key}: {item.Value}");
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void fillChickenCoop(Arg arg)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		PooledList<ChickenCoop> val = Pool.Get<PooledList<ChickenCoop>>();
		try
		{
			Vis.Entities(((Component)basePlayer).transform.position, 5f, (List<ChickenCoop>)(object)val, 256, (QueryTriggerInteraction)2);
			foreach (ChickenCoop item in (List<ChickenCoop>)(object)val)
			{
				if (item.isServer)
				{
					item.DebugFillCoop();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Unlock all static respawn points")]
	public static void unlockrespawns(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayer(0);
		if ((Object)(object)basePlayer == (Object)null)
		{
			if (arg.HasArgs(1))
			{
				arg.ReplyWith("Can't find player");
				return;
			}
			basePlayer = arg.Player();
		}
		foreach (SleepingBag sleepingBag in SleepingBag.sleepingBags)
		{
			if (sleepingBag is StaticRespawnArea staticRespawnArea && !staticRespawnArea.IsAuthed(basePlayer.userID))
			{
				staticRespawnArea.Authorize(basePlayer.userID);
			}
		}
	}

	[ServerVar(Help = "Clear all static respawn points")]
	public static void resetrespawns(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayer(0);
		if ((Object)(object)basePlayer == (Object)null)
		{
			if (arg.HasArgs(1))
			{
				arg.ReplyWith("Can't find player");
				return;
			}
			basePlayer = arg.Player();
		}
		foreach (SleepingBag sleepingBag in SleepingBag.sleepingBags)
		{
			if (sleepingBag is StaticRespawnArea staticRespawnArea && staticRespawnArea.IsAuthed(basePlayer.userID))
			{
				staticRespawnArea.Deauthorize(basePlayer.userID);
			}
		}
	}

	public static void GetPlayerReportsListTable(TextTable table)
	{
		table.ResizeColumns(4);
		table.AddColumn("NumReports");
		table.AddColumn("UserID");
		table.AddColumn("DisplayName");
		table.AddColumn("IsConnected");
		foreach (BasePlayer item in BasePlayer.allPlayerList.OrderByDescending((BasePlayer x) => x.State.numberOfTimesReported))
		{
			if (item.State.numberOfTimesReported >= 1)
			{
				table.AddValue(item.State.numberOfTimesReported);
				table.AddValue((ulong)item.userID);
				table.AddValue(item.displayName);
				table.AddValue(item.IsConnected);
			}
		}
	}

	[ServerVar(Help = "List the amount of reports players on the server have received")]
	public static void listplayerreportcounts(Arg arg)
	{
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			GetPlayerReportsListTable(val);
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Clear the player reports list")]
	public static void clearplayerreportcounts(Arg arg)
	{
		foreach (BasePlayer allPlayer in BasePlayer.allPlayerList)
		{
			allPlayer.State.numberOfTimesReported = 0;
		}
		arg.ReplyWith("Cleared report counts");
	}

	private static void OnEraChanged()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is LootContainer lootContainer)
				{
					lootContainer.PopulateLoot();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		SingletonComponent<SpawnHandler>.Instance?.EnforceLimits();
	}

	private static string AutoCorrectTags(string value)
	{
		List<string> inputValues = (from s in value.Split(',', StringSplitOptions.RemoveEmptyEntries)
			select s.Trim().ToLowerInvariant()).ToList();
		List<string> outputValues = new List<string>();
		Add(new string[3] { "monthly", "biweekly", "weekly" });
		Add(new string[3] { "vanilla", "hardcore", "softcore" });
		Add(new string[1] { "roleplay" });
		Add(new string[1] { "creative" });
		Add(new string[1] { "minigame" });
		Add(new string[1] { "training" });
		Add(new string[1] { "battlefield" });
		Add(new string[1] { "broyale" });
		Add(new string[1] { "builds" });
		Add(new string[7] { "NA", "SA", "EU", "WA", "EA", "OC", "AF" });
		Add(new string[1] { "tut" });
		Add(new string[1] { "premium" });
		if (!pve)
		{
			Add(new string[1] { "pve" });
		}
		return string.Join(',', outputValues);
		void Add(string[] options)
		{
			if (outputValues.Count < 4)
			{
				foreach (string text in options)
				{
					if (inputValues.Contains<string>(text, StringComparer.InvariantCultureIgnoreCase))
					{
						outputValues.Add(text);
						break;
					}
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using UnityEngine;

[Factory("spawn")]
public class Spawn : ConsoleSystem
{
	[ServerVar]
	public static float min_rate = 0.5f;

	[ServerVar]
	public static float max_rate = 1f;

	[ServerVar]
	public static float min_density = 0.5f;

	[ServerVar]
	public static float max_density = 1f;

	[ServerVar]
	public static float player_base = 100f;

	[ServerVar]
	public static float player_scale = 2f;

	[ServerVar]
	public static bool respawn_populations = true;

	[ServerVar]
	public static bool respawn_groups = true;

	[ServerVar]
	public static bool respawn_individuals = true;

	[ServerVar]
	public static float tick_populations = 60f;

	[ServerVar]
	public static float tick_individuals = 300f;

	[ServerVar(Help = "When scaling loot respawn rates by population, this will be considered the 'max' population, preventing loot speeding up if player counts are above this")]
	public static int population_cap_rate = 300;

	[ServerVar(Help = "If set the loot spawn system will consider this the player count, not the actual player count. Useful for testing")]
	public static int loot_population_test = 0;

	[ServerVar]
	public static void fill_populations(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.FillPopulations();
		}
	}

	[ServerVar]
	public static void delete_populations(Arg args)
	{
		if (!args.HasArgs(1))
		{
			args.ReplyWith("Usage: delete_populations <population_name> ...");
			return;
		}
		string[] args2 = args.Args;
		foreach (string name in args2)
		{
			SingletonComponent<SpawnHandler>.Instance?.DeletePopulation(name);
		}
	}

	[ServerVar]
	public static void delete_all_populations(Arg args)
	{
		SingletonComponent<SpawnHandler>.Instance?.DeleteAllPopulations();
	}

	[ServerVar(Help = "<iterations> - Simulates a number of iterations on the closest loot container and sums up the items spawned")]
	public static void simulate_loot(Arg args)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = args.Player();
		if ((Object)(object)player == (Object)null)
		{
			args.ReplyWith("Must be called from player");
			return;
		}
		int num = Mathf.Clamp(args.GetInt(0, 100), 1, 10000);
		List<LootContainer> list = new List<LootContainer>();
		Vis.Entities(((Component)player).transform.position, 5f, list, -1, (QueryTriggerInteraction)1);
		LootContainer lootContainer = list.OrderBy((LootContainer x) => Vector3.Distance(((Component)player).transform.position, ((Component)x).transform.position)).FirstOrDefault();
		if ((Object)(object)lootContainer == (Object)null)
		{
			args.ReplyWith("No loot container found");
			return;
		}
		Dictionary<string, int> dictionary = new Dictionary<string, int>();
		for (int i = 0; i < num; i++)
		{
			lootContainer.inventory.Clear();
			ItemManager.DoRemoves();
			lootContainer.PopulateLoot();
			foreach (Item item in lootContainer.inventory.itemList)
			{
				if (item != null)
				{
					dictionary.TryGetValue(item.info.shortname, out var value);
					dictionary[item.info.shortname] = value + item.amount;
				}
			}
		}
		int totalWidth = dictionary.Max((KeyValuePair<string, int> x) => x.Key.Length);
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Simulated loot from {num} {lootContainer.ShortPrefabName}:");
		foreach (KeyValuePair<string, int> item2 in dictionary.OrderByDescending((KeyValuePair<string, int> x) => x.Value))
		{
			stringBuilder.AppendLine($"{item2.Key.PadRight(totalWidth)} : {item2.Value}");
		}
		args.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void fill_groups(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.FillGroups();
		}
	}

	[ServerVar]
	public static void fill_individuals(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.FillIndividuals();
		}
	}

	[ServerVar]
	public static void report(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			bool @bool = args.GetBool(0, false);
			string @string = args.GetString(1, (string)null);
			args.ReplyWith(SingletonComponent<SpawnHandler>.Instance.GetReport(@bool, @string));
		}
		else
		{
			args.ReplyWith("No spawn handler found.");
		}
	}

	[ServerVar]
	public static void dump_map(Arg args)
	{
		string @string = args.GetString(0, "");
		int @int = args.GetInt(1, 100);
		SingletonComponent<SpawnHandler>.Instance.GenerateDebugMaps(@string, @int, out var spawned, out var attempts);
		args.ReplyWith($"Would spawn {spawned} prefabs, ran {attempts} attempts");
	}

	[ServerVar]
	public static void scalars(Arg args)
	{
		bool flag = args.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("Type");
			val.AddColumn("Value");
			val.AddRow(new string[2]
			{
				"Player Fraction",
				SpawnHandler.PlayerFraction().ToString()
			});
			val.AddRow(new string[2]
			{
				"Player Excess",
				SpawnHandler.PlayerExcess().ToString()
			});
			val.AddRow(new string[2]
			{
				"Population Rate",
				SpawnHandler.PlayerLerp(min_rate, max_rate).ToString()
			});
			val.AddRow(new string[2]
			{
				"Population Density",
				SpawnHandler.PlayerLerp(min_density, max_density).ToString()
			});
			val.AddRow(new string[2]
			{
				"Group Rate",
				SpawnHandler.PlayerScale(player_scale).ToString()
			});
			args.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void cargoshipevent(Arg args)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/content/vehicles/boats/cargoship/cargoshiptest.prefab");
		if ((Object)(object)baseEntity != (Object)null)
		{
			((Component)baseEntity).SendMessage("TriggeredEventSpawn", (SendMessageOptions)1);
			baseEntity.Spawn();
			args.ReplyWith("Cargo ship event has been started");
		}
		else
		{
			args.ReplyWith("Couldn't find cargo ship prefab - maybe it has been renamed?");
		}
	}

	[ServerVar]
	public static void ch47event(Arg args)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		if (!CH47LandingZone.HasAnyLandingZones)
		{
			args.ReplyWith("Couldn't find any landing zones for CH47. Not starting the event");
			return;
		}
		int @int = args.GetInt(0, 300);
		if (CH47ReinforcementListener.TryCall("assets/Prefabs/NPC/CH47/ch47scientists.entity.prefab", ((Component)basePlayer).transform.position, @int))
		{
			args.ReplyWith($"CH47 event has been started at a distance of {@int}m");
		}
		else
		{
			args.ReplyWith("Couldn't start CH47 event");
		}
	}

	[ServerVar]
	public static void cargoshipdockingtest(Arg args)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (CargoShip.TotalAvailableHarborDockingPaths == 0)
		{
			args.ReplyWith("No valid harbor dock points");
			return;
		}
		int @int = args.GetInt(0, 0);
		@int = Mathf.Clamp(@int, 0, CargoShip.TotalAvailableHarborDockingPaths);
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/content/vehicles/boats/cargoship/cargoshiptest.prefab");
		if ((Object)(object)baseEntity != (Object)null)
		{
			((Component)baseEntity).SendMessage("TriggeredEventSpawnDockingTest", (object)@int, (SendMessageOptions)1);
			baseEntity.Spawn();
			args.ReplyWith("Cargo ship event has been started");
		}
		else
		{
			args.ReplyWith("Couldn't find cargo ship prefab - maybe it has been renamed?");
		}
	}

	[ServerVar]
	public static void svShieldDummy(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		Vector3 vector2 = arg.GetVector3(1, default(Vector3));
		bool @bool = arg.GetBool(2, false);
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", vector, Quaternion.Euler(vector2)) as BasePlayer;
		basePlayer.Spawn();
		if (Inventory.LoadLoadout("Shields", out var so))
		{
			so.LoadItemsOnTo(basePlayer);
			if (!@bool)
			{
				Inventory.EquipItemInSlot(basePlayer, 0);
			}
			else
			{
				Inventory.EquipItemInSlot(basePlayer, -1);
			}
		}
	}
}


[Factory("SSS")]
public class SSS : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static bool enabled = true;

	[ClientVar(Saved = true)]
	public static int quality = 0;

	[ClientVar(Saved = true)]
	public static bool halfres = true;

	[ClientVar(Saved = true)]
	public static float scale = 1f;
}


using System.Linq;
using UnityEngine;

[Factory("stability")]
public class Stability : ConsoleSystem
{
	[ServerVar]
	public static int verbose = 0;

	[ServerVar]
	public static int strikes = 10;

	[ServerVar]
	public static float collapse = 0.05f;

	[ServerVar]
	public static float accuracy = 0.001f;

	[ServerVar]
	public static float stabilityqueue = 9f;

	[ServerVar]
	public static float surroundingsqueue = 3f;

	public static bool support_highest_stability = false;

	[ServerVar]
	public static bool log_stability_death = false;

	[ServerVar]
	public static bool log_ground_missing_death = false;

	[ServerVar]
	public static bool log_stability_updates = false;

	[ServerVar]
	public static void refresh_stability(Arg args)
	{
		StabilityEntity[] array = BaseNetworkable.serverEntities.OfType<StabilityEntity>().ToArray();
		Debug.Log((object)("Refreshing stability on " + array.Length + " entities..."));
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateStability();
		}
	}
}


public class Steam
{
	[ReplicatedVar(Saved = true, ShowInAdminUI = true)]
	public static bool server_allow_steam_nicknames { get; set; } = true;
}


public class Store
{
}


using UnityEngine;

[Factory("supply")]
public class Supply : ConsoleSystem
{
	private const string path = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";

	[ServerVar]
	public static void drop(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Debug.Log((object)"Supply Drop Inbound");
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab");
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).GetComponent<CargoPlane>().InitDropPosition(((Component)basePlayer).transform.position + new Vector3(0f, 10f, 0f));
				baseEntity.Spawn();
			}
		}
	}

	[ServerVar]
	public static void call(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)arg.Player()))
		{
			Debug.Log((object)"Supply Drop Inbound");
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab");
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.Spawn();
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using UnityEngine;

[Factory("system")]
public static class SystemCommands
{
	public static bool appliedManualCpuAffinity;

	[ServerVar]
	[ClientVar]
	public static void cpu_affinity(Arg arg)
	{
		ulong num = 0uL;
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'cpu_affinity {core,core1-core2,etc}'");
			return;
		}
		string[] array = arg.GetString(0, "").Split(',');
		HashSet<int> hashSet = new HashSet<int>();
		string[] array2 = array;
		foreach (string text in array2)
		{
			if (int.TryParse(text, out var result))
			{
				hashSet.Add(result);
			}
			else
			{
				if (!text.Contains('-'))
				{
					continue;
				}
				string[] array3 = text.Split('-');
				if (array3.Length != 2)
				{
					arg.ReplyWith("Failed to parse section " + text + ", format should be '0-15'");
					continue;
				}
				if (!int.TryParse(array3[0], out var result2) || !int.TryParse(array3[1], out var result3))
				{
					arg.ReplyWith("Core range in section " + text + " are not valid numbers, format should be '0-15'");
					continue;
				}
				if (result2 > result3)
				{
					arg.ReplyWith("Core range in section " + text + " are not ordered from least to greatest, format should be '0-15'");
					continue;
				}
				if (result3 - result2 > 64)
				{
					arg.ReplyWith("Core range in section " + text + " are too big of a range, must be <64");
					return;
				}
				for (int j = result2; j <= result3; j++)
				{
					hashSet.Add(j);
				}
			}
		}
		if (hashSet.Any((int x) => x < 0 || x > 63))
		{
			arg.ReplyWith("Cores provided out of range! Must be in between 0 and 63");
			return;
		}
		for (int k = 0; k < 64; k++)
		{
			if (hashSet.Contains(k))
			{
				num |= (ulong)(1L << k);
			}
		}
		if (num == 0L)
		{
			arg.ReplyWith("No cores provided (bitmask empty)! Format is 'cpu_affinity {core,core1-core2,etc}'");
		}
		else if (SetCpuAffinity(num))
		{
			appliedManualCpuAffinity = true;
			arg.ReplyWith("Successfully changed CPU affinity");
		}
	}

	public static bool SetCpuAffinity(ulong affinityMask)
	{
		try
		{
			Process.GetCurrentProcess().ProcessorAffinity = (IntPtr)(long)affinityMask;
			return true;
		}
		catch (Exception arg)
		{
			Debug.LogWarning((object)$"Unable to set CPU affinity: {arg}");
			return false;
		}
	}

	[ClientVar]
	[ServerVar]
	public static void cpu_priority(Arg arg)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Invalid comparison between Unknown and I4
		if ((int)Application.platform == 1)
		{
			arg.ReplyWith("OSX is not a supported platform");
			return;
		}
		string @string = arg.GetString(0, "");
		ProcessPriorityClass priorityClass;
		switch (@string.Replace("-", "").Replace("_", ""))
		{
		case "belownormal":
			priorityClass = ProcessPriorityClass.BelowNormal;
			break;
		case "normal":
			priorityClass = ProcessPriorityClass.Normal;
			break;
		case "abovenormal":
			priorityClass = ProcessPriorityClass.AboveNormal;
			break;
		case "high":
			priorityClass = ProcessPriorityClass.High;
			break;
		default:
			arg.ReplyWith("Unknown priority '" + @string + "', possible values: below_normal, normal, above_normal, high");
			return;
		}
		try
		{
			Process.GetCurrentProcess().PriorityClass = priorityClass;
		}
		catch (Exception arg2)
		{
			Debug.LogWarning((object)$"Unable to set cpu priority: {arg2}");
			return;
		}
		arg.ReplyWith("Successfully changed cpu priority to " + priorityClass);
	}
}


[Factory("terrain")]
public class Terrain : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static float quality = 100f;
}


[Factory("texture")]
public class Texture : ConsoleSystem
{
}


using UnityEngine;

[Factory("time")]
public class Time : ConsoleSystem
{
	public const int SERVER_DEFAULT_TICKS = 16;

	public const int CLIENT_DEFAULT_TICKS = 32;

	public const string CLIENT_DEFAULT_TICKS_STR = "32";

	[ServerVar]
	[Help("Pause time while loading")]
	public static bool pausewhileloading = true;

	private static float _missiontimerscale = 1f;

	private static int _cl_steps = 32;

	private static int _cl_maxstepsperframe = 2;

	[ServerVar(Help = "Desired physics ticks per second on the server")]
	public static int sv_steps
	{
		get
		{
			return Mathf.RoundToInt(1f / Time.fixedDeltaTime);
		}
		set
		{
			value = Mathf.Clamp(value, 16, 64);
			int num = sv_maxstepsperframe;
			Time.fixedDeltaTime = 1f / (float)value;
			sv_maxstepsperframe = num;
		}
	}

	[ServerVar(Help = "The maximum amount physics ticks per frame on the server. If things are taking too long, time slows down")]
	public static int sv_maxstepsperframe
	{
		get
		{
			return Mathf.RoundToInt(Time.maximumDeltaTime / Time.fixedDeltaTime);
		}
		set
		{
			value = Mathf.Clamp(value, 2, 10);
			Time.maximumDeltaTime = (float)value * Time.fixedDeltaTime;
		}
	}

	[Help("The time scale")]
	[ServerVar]
	public static float timescale
	{
		get
		{
			return Time.timeScale;
		}
		set
		{
			Time.timeScale = value;
		}
	}

	[Help("Time scale which only affects mission timers")]
	[ReplicatedVar]
	public static float missiontimerscale
	{
		get
		{
			return _missiontimerscale;
		}
		set
		{
			_missiontimerscale = ((value < 0f) ? 0f : value);
		}
	}

	[ReplicatedVar(Help = "Desired physics ticks per second on clients", Default = "32")]
	public static int cl_steps
	{
		get
		{
			return _cl_steps;
		}
		set
		{
			value = Mathf.Clamp(value, 32, 64);
			_cl_steps = value;
			cl_maxstepsperframe = _cl_maxstepsperframe;
		}
	}

	[ReplicatedVar(Help = "The maximum amount physics ticks per frame on clients. If things are taking too long, time slows down", Default = "2")]
	public static int cl_maxstepsperframe
	{
		get
		{
			return _cl_maxstepsperframe;
		}
		set
		{
			value = Mathf.Clamp(value, 2, 10);
			_cl_maxstepsperframe = value;
		}
	}
}


[Factory("tree")]
public class Tree : ConsoleSystem
{
	[ServerVar]
	public static bool global_broadcast;

	[ServerVar]
	public static bool simplified_collider;
}


using System;
using Facepunch;
using UnityEngine;

[Factory("vehicle")]
public class vehicle : ConsoleSystem
{
	[ServerVar]
	[Help("how long until boat corpses despawn (excluding tugboat - use tugboat_corpse_seconds)")]
	public static float boat_corpse_seconds = 300f;

	[ServerVar]
	public static bool disable_wheels_when_sleeping = true;

	[ServerVar]
	public static float world_boundary_force_start_distance = 100f;

	[ServerVar]
	public static float deepseaportal_boundary_force_start_distance = 5f;

	[ServerVar]
	public static float world_boundary_force_offset = 25f;

	[ServerVar(Help = "If true, trains always explode when destroyed, and hitting a barrier always destroys the train immediately. Default: false")]
	public static bool cinematictrains = false;

	[ServerVar(Help = "Determines whether trains stop automatically when there's no-one on them. Default: false")]
	public static bool trainskeeprunning = false;

	[ServerVar(Help = "Determines whether modular cars turn into wrecks when destroyed, or just immediately gib. Default: true")]
	public static bool carwrecks = true;

	[ServerVar(Help = "Determines whether vehicles drop storage items when destroyed. Default: true")]
	public static bool vehiclesdroploot = true;

	[ServerUserVar]
	public static void swapseats(Arg arg)
	{
		int seat = -1;
		TryMovePlayerToSeat(arg.Player(), seat);
	}

	[ServerUserVar]
	public static void swaptoseat(Arg arg)
	{
		int @int = arg.GetInt(0, -1);
		TryMovePlayerToSeat(arg.Player(), @int);
	}

	public static void TryMovePlayerToSeat(BasePlayer ply, int seat)
	{
		if ((Object)(object)ply == (Object)null || ply.SwapSeatCooldown())
		{
			return;
		}
		BaseMountable mounted = ply.GetMounted();
		if (!((Object)(object)mounted == (Object)null))
		{
			BaseVehicle baseVehicle = ((Component)mounted).GetComponent<BaseVehicle>();
			if ((Object)(object)baseVehicle == (Object)null)
			{
				baseVehicle = mounted.VehicleParent();
			}
			if (!((Object)(object)baseVehicle == (Object)null))
			{
				baseVehicle.SwapSeats(ply, seat);
			}
		}
	}

	[ServerVar]
	public static void fixcars(Arg arg)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Null player.");
			return;
		}
		if (!basePlayer.IsAdmin)
		{
			arg.ReplyWith("Must be an admin to use fixcars.");
			return;
		}
		int @int = arg.GetInt(0, 2);
		@int = Mathf.Clamp(@int, 1, 3);
		BaseVehicle[] array = BaseEntity.Util.FindAll<BaseVehicle>();
		int num = 0;
		BaseVehicle[] array2 = array;
		foreach (BaseVehicle baseVehicle in array2)
		{
			if (baseVehicle.isServer && Vector3.Distance(((Component)baseVehicle).transform.position, ((Component)basePlayer).transform.position) <= 10f && baseVehicle.AdminFixUp(@int))
			{
				num++;
			}
		}
		MLRS[] array3 = BaseEntity.Util.FindAll<MLRS>();
		foreach (MLRS mLRS in array3)
		{
			if (mLRS.isServer && Vector3.Distance(((Component)mLRS).transform.position, ((Component)basePlayer).transform.position) <= 10f && mLRS.AdminFixUp())
			{
				num++;
			}
		}
		DiverPropulsionVehicle[] array4 = BaseEntity.Util.FindAll<DiverPropulsionVehicle>();
		foreach (DiverPropulsionVehicle diverPropulsionVehicle in array4)
		{
			if (diverPropulsionVehicle.isServer && Vector3.Distance(((Component)diverPropulsionVehicle).transform.position, ((Component)basePlayer).transform.position) <= 10f && diverPropulsionVehicle.AdminFixUp())
			{
				num++;
			}
		}
		HotAirBalloon[] array5 = BaseEntity.Util.FindAll<HotAirBalloon>();
		foreach (HotAirBalloon hotAirBalloon in array5)
		{
			if (hotAirBalloon.isServer && Vector3.Distance(((Component)hotAirBalloon).transform.position, ((Component)basePlayer).transform.position) <= 10f && hotAirBalloon.AdminFixUp())
			{
				num++;
			}
		}
		SmallEngine[] array6 = BaseEntity.Util.FindAll<SmallEngine>();
		foreach (SmallEngine smallEngine in array6)
		{
			if (smallEngine.isServer && Vector3.Distance(((Component)smallEngine).transform.position, ((Component)basePlayer).transform.position) <= 10f && smallEngine.AdminFixUp())
			{
				num++;
			}
		}
		arg.ReplyWith($"Fixed up {num} vehicles/engines.");
	}

	[ServerVar]
	public static void autohover(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Null player.");
			return;
		}
		if (!basePlayer.IsAdmin)
		{
			arg.ReplyWith("Must be an admin to use autohover.");
			return;
		}
		BaseHelicopter baseHelicopter = basePlayer.GetMountedVehicle() as BaseHelicopter;
		if ((Object)(object)baseHelicopter != (Object)null)
		{
			bool flag = baseHelicopter.ToggleAutoHover(basePlayer);
			arg.ReplyWith($"Toggled auto-hover to {flag}.");
		}
		else
		{
			arg.ReplyWith("Must be mounted in a helicopter first.");
		}
	}

	[ServerVar]
	public static void stop_all_trains(Arg arg)
	{
		TrainEngine[] array = Object.FindObjectsOfType<TrainEngine>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].StopEngine();
		}
		arg.ReplyWith("All trains stopped.");
	}

	[ServerVar]
	public static void killcars(Arg args)
	{
		ModularCar[] array = BaseEntity.Util.FindAll<ModularCar>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
	}

	[ServerVar]
	public static void killpushbikes(Arg args)
	{
		Bike[] array = BaseEntity.Util.FindAll<Bike>();
		foreach (Bike bike in array)
		{
			if (bike.poweredBy == Bike.PoweredBy.Human)
			{
				bike.Kill();
			}
		}
	}

	[ServerVar]
	public static void killmotorbikes(Arg args)
	{
		Bike[] array = BaseEntity.Util.FindAll<Bike>();
		foreach (Bike bike in array)
		{
			if (bike.poweredBy == Bike.PoweredBy.Fuel)
			{
				bike.Kill();
			}
		}
	}

	[ServerVar]
	public static void killminis(Arg args)
	{
		PlayerHelicopter[] array = BaseEntity.Util.FindAll<PlayerHelicopter>();
		foreach (PlayerHelicopter playerHelicopter in array)
		{
			if (((Object)playerHelicopter).name.ToLower().Contains("minicopter"))
			{
				playerHelicopter.Kill();
			}
		}
	}

	[ServerVar]
	public static void killscraphelis(Arg args)
	{
		ScrapTransportHelicopter[] array = BaseEntity.Util.FindAll<ScrapTransportHelicopter>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
	}

	[ServerVar]
	public static void killtrains(Arg args)
	{
		TrainCar[] array = BaseEntity.Util.FindAll<TrainCar>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
	}

	[ServerVar]
	public static void killboats(Arg args)
	{
		BaseBoat[] array = BaseEntity.Util.FindAll<BaseBoat>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
	}

	[ServerVar]
	public static void killdrones(Arg args)
	{
		Drone[] array = BaseEntity.Util.FindAll<Drone>();
		foreach (Drone drone in array)
		{
			if (!(drone is DeliveryDrone))
			{
				drone.Kill();
			}
		}
	}

	[ServerVar(Help = "Print out boat drift status for all boats")]
	public static void boatdriftinfo(Arg args)
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("id");
			val.AddColumn("name");
			val.AddColumn("position");
			val.AddColumn("status");
			val.AddColumn("drift");
			BaseBoat[] array = BaseEntity.Util.FindAll<BaseBoat>();
			BaseBoat[] array2 = array;
			foreach (BaseBoat baseBoat in array2)
			{
				if (baseBoat.IsValid())
				{
					string text = (baseBoat.IsAlive() ? "alive" : "dead");
					string driftStatus = baseBoat.GetDriftStatus();
					string[] obj = new string[5]
					{
						((object)(NetworkableId)(ref baseBoat.net.ID)/*cast due to .constrained prefix*/).ToString(),
						baseBoat.ShortPrefabName,
						null,
						null,
						null
					};
					Vector3 position = ((Component)baseBoat).transform.position;
					obj[2] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
					obj[3] = text;
					obj[4] = driftStatus;
					val.AddRow(obj);
				}
			}
			if (array.Length == 0)
			{
				args.ReplyWith("No boats in world");
			}
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


[Factory("vis")]
public class Vis : ConsoleSystem
{
	[Help("Turns on debug display of lerp")]
	[ClientVar]
	public static bool lerp;

	[Help("Turns on debug display of damages")]
	[ServerVar]
	public static bool damage;

	[ClientVar]
	[Help("Turns on debug display of attacks")]
	[ServerVar]
	public static bool attack;

	[ServerVar]
	[Help("Turns on debug display of protection")]
	[ClientVar]
	public static bool protection;

	[ServerVar]
	[Help("Turns on debug display of weakspots")]
	public static bool weakspots;

	[ServerVar]
	[Help("Show trigger entries")]
	public static bool triggers;

	[ServerVar]
	[Help("Turns on debug display of hitboxes")]
	public static bool hitboxes;

	[ServerVar]
	[Help("Turns on debug display of line of sight checks")]
	public static bool lineofsight;

	[ServerVar]
	[Help("Turns on debug display of senses, which are received by Ai")]
	public static bool sense;
}


using UnityEngine;

[Factory("voice")]
public class Voice : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static bool loopback = false;

	private static float _voiceRangeBoostAmount = 50f;

	[ReplicatedVar]
	public static float voiceRangeBoostAmount
	{
		get
		{
			return _voiceRangeBoostAmount;
		}
		set
		{
			_voiceRangeBoostAmount = Mathf.Clamp(value, 0f, 200f);
		}
	}

	[ServerVar(Help = "Enabled/disables voice range boost for a player eg. ToggleVoiceRangeBoost sam 1")]
	public static void ToggleVoiceRangeBoost(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if ((Object)(object)player == (Object)null)
		{
			arg.ReplyWith("Invalid player: " + arg.GetString(0, ""));
			return;
		}
		bool @bool = arg.GetBool(1, false);
		player.SetPlayerFlag(BasePlayer.PlayerFlags.VoiceRangeBoost, @bool);
		arg.ReplyWith($"Set {player.displayName} volume boost to {@bool}");
	}
}


[Factory("water")]
public class Water : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static int quality = 1;

	public static int MaxQuality = 2;

	public static int MinQuality = 0;

	[ClientVar(Saved = true)]
	public static int reflections = 1;

	public static int MaxReflections = 2;

	public static int MinReflections = 0;

	[ClientVar(ClientAdmin = true, Default = "0")]
	public static bool scaled_time = false;
}


using System;
using System.Globalization;
using System.Text;
using Facepunch;
using UnityEngine;

[Factory("weather")]
public class Weather : ConsoleSystem
{
	[ServerVar]
	public static float wetness_rain = 0.4f;

	[ServerVar]
	public static float wetness_snow = 0.2f;

	[ReplicatedVar(Default = "-1")]
	public static float ocean_time = -1f;

	[ReplicatedVar(Default = "1")]
	public static float clear_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 1f;
			}
			return SingletonComponent<Climate>.Instance.Weather.ClearChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.ClearChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float dust_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.DustChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.DustChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float fog_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.FogChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.FogChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float overcast_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.OvercastChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.OvercastChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float storm_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.StormChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.StormChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float rain_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.RainChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.RainChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float rain
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Rain;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Rain = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float wind
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Wind;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Wind = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float thunder
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Thunder;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Thunder = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float rainbow
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Rainbow;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Rainbow = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float fog
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Fogginess;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Fogginess = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_rayleigh
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.RayleighMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.RayleighMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_mie
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.MieMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.MieMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_brightness
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Brightness;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Brightness = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_contrast
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Contrast;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Contrast = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_directionality
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Directionality;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Directionality = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_size
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Size;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Size = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_opacity
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Opacity;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Opacity = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_coverage
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Coverage;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Coverage = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_sharpness
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Sharpness;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Sharpness = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_coloring
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Coloring;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Coloring = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_attenuation
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Attenuation;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Attenuation = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_saturation
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Saturation;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Saturation = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_scattering
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Scattering;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Scattering = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_brightness
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Brightness;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Brightness = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float ocean_scale
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.OceanScale;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.OceanScale = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float ambient_light_multiplier
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AmbientLightMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AmbientLightMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float directional_light_multiplier
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.DirectionalLightMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.DirectionalLightMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float reflection_multiplier
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.ReflectionMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.ReflectionMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float sun_mesh_brightness_multiplier
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.SunMeshBrightnessMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.SunMeshBrightnessMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float moon_mesh_brightness_multiplier
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.MoonMeshBrightnessMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.MoonMeshBrightnessMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float fog_multiplier
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.FogMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.FogMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float biome_fog_distance_curve
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.BiomeFogDistanceCurve;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.BiomeFogDistanceCurve = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float biome_fog_ambient_saturation_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.BiomeFogAmbientSaturationMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.BiomeFogAmbientSaturationMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_fog_height_falloff
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AtmosphereFogHeightFalloff;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AtmosphereFogHeightFalloff = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float vclouds_sun_color_scale
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.VolumeCloudsSunColorScale;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.VolumeCloudsSunColorScale = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float vclouds_moon_color_scale
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.VolumeCloudsMoonColorScale;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.VolumeCloudsMoonColorScale = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arid_fog_ambient_intensity_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.AmbientIntensityMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.AmbientIntensityMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arid_fog_light_boost_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.LightBoostMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.LightBoostMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arid_fog_ramp_start
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.FogRampStartDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.FogRampStartDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arid_fog_ramp_end
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.FogRampEndDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.FogRampEndDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float temperate_fog_ambient_intensity_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.AmbientIntensityMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.AmbientIntensityMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float temperate_fog_light_boost_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.LightBoostMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.LightBoostMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float temperate_fog_ramp_start
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.FogRampStartDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.FogRampStartDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float temperate_fog_ramp_end
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.FogRampEndDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.FogRampEndDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float tundra_fog_ambient_intensity_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.AmbientIntensityMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.AmbientIntensityMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float tundra_fog_light_boost_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.LightBoostMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.LightBoostMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float tundra_fog_ramp_start
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.FogRampStartDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.FogRampStartDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float tundra_fog_ramp_end
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.FogRampEndDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.FogRampEndDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arctic_fog_ambient_intensity_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.AmbientIntensityMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.AmbientIntensityMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arctic_fog_light_boost_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.LightBoostMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.LightBoostMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arctic_fog_ramp_start
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.FogRampStartDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.FogRampStartDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arctic_fog_ramp_end
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.FogRampEndDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.FogRampEndDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float jungle_fog_ambient_intensity_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.AmbientIntensityMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.AmbientIntensityMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float jungle_fog_light_boost_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.LightBoostMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.LightBoostMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float jungle_fog_ramp_start
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.FogRampStartDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.FogRampStartDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float jungle_fog_ramp_end
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.FogRampEndDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.FogRampEndDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static int cloud_config
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.OverrideCloudConfig;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.OverrideCloudConfig = value;
				if (value < 0)
				{
					SingletonComponent<Climate>.Instance.WeatherOverrides.VolumeCloudsConfigs = null;
				}
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_fog_ramp_start_distance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AtmosphereFogRampStartDistance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AtmosphereFogRampStartDistance = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_fog_ramp_end_distance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AtmosphereFogRampEndDistance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AtmosphereFogRampEndDistance = value;
			}
		}
	}

	[ClientVar]
	[ServerVar]
	public static void load(Arg args)
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			return;
		}
		string name = args.GetString(0, "");
		if (string.IsNullOrEmpty(name))
		{
			args.ReplyWith("Weather preset name invalid.");
			return;
		}
		WeatherPreset weatherPreset = Array.Find(SingletonComponent<Climate>.Instance.WeatherPresets, (WeatherPreset x) => StringEx.Contains(((Object)x).name, name, CompareOptions.IgnoreCase));
		if ((Object)(object)weatherPreset == (Object)null)
		{
			args.ReplyWith("Weather preset not found: " + name);
			return;
		}
		SingletonComponent<Climate>.Instance.WeatherOverrides.Set(weatherPreset);
		SingletonComponent<Climate>.Instance.WeatherOverrides.SetVolumeCloudsConfigs(weatherPreset);
		if (args.IsServerside)
		{
			ServerMgr.SendReplicatedVars("weather.");
		}
	}

	public static WeatherPreset GetWeatherPreset(string withName)
	{
		return Array.Find(SingletonComponent<Climate>.Instance.WeatherPresets, (WeatherPreset x) => StringEx.Contains(((Object)x).name, withName, CompareOptions.IgnoreCase));
	}

	[ClientVar]
	public static void debug_cloud_position(Arg args)
	{
	}

	[ServerVar]
	[ClientVar]
	public static void load_cloud_config(Arg args)
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			return;
		}
		string name = args.GetString(0, "");
		if (string.IsNullOrEmpty(name))
		{
			return;
		}
		VolumeCloudsConfig volumeCloudsConfig = Array.Find(SingletonComponent<Climate>.Instance.AllCloudConfigs, (VolumeCloudsConfig x) => StringEx.Contains(((Object)x).name, name, CompareOptions.IgnoreCase));
		if ((Object)(object)volumeCloudsConfig == (Object)null)
		{
			args.ReplyWith("Cloud config not found: " + name);
			return;
		}
		WeatherPreset weatherOverrides = SingletonComponent<Climate>.Instance.WeatherOverrides;
		weatherOverrides.VolumeCloudsConfigs = new VolumeCloudsConfig[1] { volumeCloudsConfig };
		int overrideCloudConfig = Array.IndexOf(SingletonComponent<Climate>.Instance.AllCloudConfigs, volumeCloudsConfig);
		weatherOverrides.OverrideCloudConfig = overrideCloudConfig;
		if (args.IsServerside)
		{
			ServerMgr.SendReplicatedVars("weather.");
		}
	}

	[ClientVar]
	[ServerVar]
	public static void list_cloud_configs(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			VolumeCloudsConfig[] allCloudConfigs = SingletonComponent<Climate>.Instance.AllCloudConfigs;
			StringBuilder stringBuilder = new StringBuilder();
			VolumeCloudsConfig[] array = allCloudConfigs;
			foreach (VolumeCloudsConfig volumeCloudsConfig in array)
			{
				stringBuilder.AppendLine(((Object)volumeCloudsConfig).name);
			}
			args.ReplyWith(stringBuilder.ToString());
		}
	}

	[ServerVar]
	[ClientVar]
	public static void reset_cloud_config(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			WeatherPreset weatherOverrides = SingletonComponent<Climate>.Instance.WeatherOverrides;
			weatherOverrides.VolumeCloudsConfigs = null;
			weatherOverrides.OverrideCloudConfig = -1;
			if (args.IsServerside)
			{
				ServerMgr.SendReplicatedVars("weather.");
			}
		}
	}

	[ServerVar]
	[ClientVar]
	public static void reset(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			SingletonComponent<Climate>.Instance.WeatherOverrides.Reset();
			SingletonComponent<Climate>.Instance.WeatherOverrides.VolumeCloudsConfigs = null;
			if (args.IsServerside)
			{
				ServerMgr.SendReplicatedVars("weather.");
			}
		}
	}

	[ServerVar]
	[ClientVar]
	public static void report(Arg args)
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			return;
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn(((Object)SingletonComponent<Climate>.Instance.WeatherStatePrevious).name);
			val.AddColumn("|");
			val.AddColumn(((Object)SingletonComponent<Climate>.Instance.WeatherStateTarget).name);
			val.AddColumn("|");
			val.AddColumn(((Object)SingletonComponent<Climate>.Instance.WeatherStateNext).name);
			int num = Mathf.RoundToInt(SingletonComponent<Climate>.Instance.WeatherStateBlend * 100f);
			if (num < 100)
			{
				val.AddRow(new string[5]
				{
					"fading out (" + (100 - num) + "%)",
					"|",
					"fading in (" + num + "%)",
					"|",
					"up next"
				});
			}
			else
			{
				val.AddRow(new string[5] { "previous", "|", "current", "|", "up next" });
			}
			args.ReplyWith(((object)val).ToString() + Environment.NewLine + ((object)SingletonComponent<Climate>.Instance.WeatherState).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Facepunch;

[Factory("workshop")]
public class Workshop : ConsoleSystem
{
	[ServerVar]
	public static void print_approved_skins(Arg arg)
	{
		if (!PlatformService.Instance.IsValid || PlatformService.Instance.ItemDefinitions == null)
		{
			return;
		}
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("name");
			val.AddColumn("itemshortname");
			val.AddColumn("workshopid");
			val.AddColumn("workshopdownload");
			foreach (IPlayerItemDefinition itemDefinition in PlatformService.Instance.ItemDefinitions)
			{
				string name = itemDefinition.Name;
				string itemShortName = itemDefinition.ItemShortName;
				string text = itemDefinition.WorkshopId.ToString();
				string text2 = itemDefinition.WorkshopDownload.ToString();
				val.AddRow(new string[4] { name, itemShortName, text, text2 });
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.IO;
using Facepunch;
using UnityEngine;

[Factory("world")]
public class World : ConsoleSystem
{
	[ServerVar]
	[ClientVar]
	public static bool cache = true;

	[ClientVar]
	public static bool streaming = true;

	[ServerVar]
	public static string configString = string.Empty;

	[ServerVar]
	public static string configFile = string.Empty;

	[ServerVar]
	[ClientVar]
	public static void monuments(Arg arg)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			return;
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("type");
			val.AddColumn("name");
			val.AddColumn("prefab");
			val.AddColumn("pos");
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				string[] obj = new string[4]
				{
					monument.Type.ToString(),
					monument.displayPhrase.translated,
					((Object)monument).name,
					null
				};
				Vector3 position = ((Component)monument).transform.position;
				obj[3] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
				val.AddRow(obj);
			}
			arg.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Clientside = true, Help = "Renders a high resolution PNG of the current map")]
	public static void rendermap(Arg arg)
	{
		float @float = arg.GetFloat(0, 1f);
		int imageWidth;
		int imageHeight;
		Color background;
		byte[] array = MapImageRenderer.Render(out imageWidth, out imageHeight, out background, @float, lossy: false);
		if (array == null)
		{
			arg.ReplyWith("Failed to render the map (is a map loaded now?)");
			return;
		}
		string fullPath = Path.GetFullPath(Path.Combine(Environment.CurrentDirectory, $"map_{World.Size}_{World.Seed}.png"));
		File.WriteAllBytes(fullPath, array);
		arg.ReplyWith("Saved map render to: " + fullPath);
	}

	[ServerVar(Clientside = true, Help = "Renders a PNG of the current map's tunnel network")]
	public static void rendertunnels(Arg arg)
	{
		RenderMapLayerToFile(arg, "tunnels", MapLayer.TrainTunnels);
	}

	[ServerVar(Clientside = true, Help = "Renders a PNG of the current map's underwater labs, for a specific floor")]
	public static void renderlabs(Arg arg)
	{
		int underwaterLabFloorCount = MapLayerRenderer.GetOrCreate().GetUnderwaterLabFloorCount();
		int @int = arg.GetInt(0, 0);
		if (@int < 0 || @int >= underwaterLabFloorCount)
		{
			arg.ReplyWith($"Floor number must be between 0 and {underwaterLabFloorCount}");
		}
		else
		{
			RenderMapLayerToFile(arg, $"labs_{@int}", (MapLayer)(1 + @int));
		}
	}

	private static void RenderMapLayerToFile(Arg arg, string name, MapLayer layer)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Expected O, but got Unknown
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			MapLayerRenderer orCreate = MapLayerRenderer.GetOrCreate();
			orCreate.Render(layer);
			string fullPath = Path.GetFullPath(Path.Combine(Environment.CurrentDirectory, $"{name}_{World.Size}_{World.Seed}.png"));
			RenderTexture targetTexture = orCreate.renderCamera.targetTexture;
			Texture2D val = new Texture2D(((Texture)targetTexture).width, ((Texture)targetTexture).height);
			RenderTexture active = RenderTexture.active;
			try
			{
				RenderTexture.active = targetTexture;
				val.ReadPixels(new Rect(0f, 0f, (float)((Texture)targetTexture).width, (float)((Texture)targetTexture).height), 0, 0);
				val.Apply();
				File.WriteAllBytes(fullPath, ImageConversion.EncodeToPNG(val));
			}
			finally
			{
				RenderTexture.active = active;
				Object.DestroyImmediate((Object)(object)val);
			}
			arg.ReplyWith("Saved " + name + " render to: " + fullPath);
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)ex);
			arg.ReplyWith("Failed to render " + name);
		}
	}
}


using UnityEngine;

[Factory("xmas")]
public class XMas : ConsoleSystem
{
	private const string path = "assets/prefabs/misc/xmas/xmasrefill.prefab";

	[ServerVar]
	public static bool enabled = false;

	[ServerVar]
	public static float spawnRange = 40f;

	[ServerVar]
	public static int spawnAttempts = 5;

	[ServerVar]
	public static int giftsPerPlayer = 2;

	[ServerVar]
	public static void refill(Arg arg)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/misc/xmas/xmasrefill.prefab");
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			baseEntity.Spawn();
		}
	}
}


using ConVar.Misc;
using UnityEngine;

public class NoBuildZoneMaterialController : SingletonComponent<NoBuildZoneMaterialController>
{
	[SerializeField]
	private Material noBuildZoneMaterial;

	private static readonly int DistanceWarningStrength = Shader.PropertyToID("_DistanceWarningStrength");

	private static readonly int DistanceWarningStrengthNight = Shader.PropertyToID("_DistanceWarningStrengthNight");

	private static readonly int DistanceWarningMinHeight = Shader.PropertyToID("_DistanceWarningMinHeight");

	[ClientVar(ClientAdmin = true, Help = "[0.0-1.0]")]
	public static void SetStrengthDay(Arg arg)
	{
		float @float = SingletonComponent<NoBuildZoneMaterialController>.Instance.noBuildZoneMaterial.GetFloat(DistanceWarningStrength);
		float float2 = arg.GetFloat(0, @float);
		SingletonComponent<NoBuildZoneMaterialController>.Instance.noBuildZoneMaterial.SetFloat(DistanceWarningStrength, float2);
	}

	[ClientVar(ClientAdmin = true, Help = "[0.0-1.0]")]
	public static void SetStrengthNight(Arg arg)
	{
		float @float = SingletonComponent<NoBuildZoneMaterialController>.Instance.noBuildZoneMaterial.GetFloat(DistanceWarningStrengthNight);
		float float2 = arg.GetFloat(0, @float);
		SingletonComponent<NoBuildZoneMaterialController>.Instance.noBuildZoneMaterial.SetFloat(DistanceWarningStrengthNight, float2);
	}

	[ClientVar(ClientAdmin = true, Help = "[0.0-10]")]
	public static void SetHeight(Arg arg)
	{
		float @float = SingletonComponent<NoBuildZoneMaterialController>.Instance.noBuildZoneMaterial.GetFloat(DistanceWarningMinHeight);
		float float2 = arg.GetFloat(0, @float);
		SingletonComponent<NoBuildZoneMaterialController>.Instance.noBuildZoneMaterial.SetFloat(DistanceWarningMinHeight, float2);
	}
}


public static class PlayerMenuAnimation
{
	public enum Layers
	{
		Movement
	}

	public static class Groups
	{
	}
}


public enum Layers
{
	Movement
}


public static class Groups
{
}


public static class Numlock
{
	public static bool IsOn => true;

	public static void TurnOn()
	{
	}
}


using System;
using UnityEngine;

public class GC : MonoBehaviour, IClientComponent
{
	public static int gcLowerBounds = 64;

	public static int gcDefaultValue = 256;

	public static int gcEditorDefaultValue = 4096;

	public static bool Enabled => true;

	public static void Collect()
	{
		GC.Collect();
	}

	public static int GetSafeGCValue(int val)
	{
		return Mathf.Clamp(val, gcLowerBounds, Mathf.Min(4096, SystemInfo.systemMemorySize / 8));
	}

	public static long GetTotalMemory()
	{
		return GC.GetTotalMemory(forceFullCollection: false) / 1048576;
	}

	public static int CollectionCount()
	{
		return GC.CollectionCount(0);
	}
}


public enum DamageType
{
	Generic,
	Hunger,
	Thirst,
	Cold,
	Drowned,
	Heat,
	Bleeding,
	Poison,
	Suicide,
	Bullet,
	Slash,
	Blunt,
	Fall,
	Radiation,
	Bite,
	Stab,
	Explosion,
	RadiationExposure,
	ColdExposure,
	Decay,
	ElectricShock,
	Arrow,
	AntiVehicle,
	Collision,
	Fun_Water,
	BeeSting,
	Paintball,
	Cannon,
	LAST
}


using System.Collections.Generic;
using Rust;

public class DamageTypeList
{
	public float[] types = new float[28];

	public void Set(DamageType index, float amount)
	{
		types[(int)index] = amount;
	}

	public float Get(DamageType index)
	{
		return types[(int)index];
	}

	public void Add(DamageType index, float amount)
	{
		Set(index, Get(index) + amount);
	}

	public void Scale(DamageType index, float amount)
	{
		Set(index, Get(index) * amount);
	}

	public bool Has(DamageType index)
	{
		return Get(index) > 0f;
	}

	public float Total()
	{
		float num = 0f;
		for (int i = 0; i < types.Length; i++)
		{
			float num2 = types[i];
			if (!float.IsNaN(num2) && !float.IsInfinity(num2))
			{
				num += num2;
			}
		}
		return num;
	}

	public void Clear()
	{
		for (int i = 0; i < types.Length; i++)
		{
			types[i] = 0f;
		}
	}

	public void Add(List<DamageTypeEntry> entries)
	{
		foreach (DamageTypeEntry entry in entries)
		{
			Add(entry.type, entry.amount);
		}
	}

	public void ScaleAll(float amount)
	{
		for (int i = 0; i < types.Length; i++)
		{
			Scale((DamageType)i, amount);
		}
	}

	public DamageType GetMajorityDamageType()
	{
		int result = 0;
		float num = 0f;
		for (int i = 0; i < types.Length; i++)
		{
			float num2 = types[i];
			if (!float.IsNaN(num2) && !float.IsInfinity(num2) && !(num2 < num))
			{
				result = i;
				num = num2;
			}
		}
		return (DamageType)result;
	}

	public bool Contains(DamageType damage)
	{
		if (damage < DamageType.Generic || (int)damage >= types.Length)
		{
			return false;
		}
		float num = types[(int)damage];
		if (!float.IsNaN(num) && !float.IsInfinity(num))
		{
			return num > 0f;
		}
		return false;
	}

	public bool IsMeleeType()
	{
		return GetMajorityDamageType().IsMeleeType();
	}

	public bool IsBleedCausing()
	{
		return GetMajorityDamageType().IsBleedCausing();
	}

	public bool IsConsideredAnAttack()
	{
		return GetMajorityDamageType().IsConsideredAnAttack();
	}

	public DamageTypeList Clone()
	{
		DamageTypeList damageTypeList = new DamageTypeList();
		for (int i = 0; i < types.Length; i++)
		{
			damageTypeList.types[i] = types[i];
		}
		return damageTypeList;
	}
}


using System;
using Rust;

[Serializable]
public class DamageTypeEntry
{
	public DamageType type;

	public float amount;
}


using Rust;

public static class DamageTypeEx
{
	public static bool IsMeleeType(this DamageType damageType)
	{
		if (damageType != DamageType.Blunt && damageType != DamageType.Slash)
		{
			return damageType == DamageType.Stab;
		}
		return true;
	}

	public static bool IsBleedCausing(this DamageType damageType)
	{
		if (damageType != DamageType.Bite && damageType != DamageType.Slash && damageType != DamageType.Stab && damageType != DamageType.Bullet)
		{
			return damageType == DamageType.Arrow;
		}
		return true;
	}

	public static bool IsConsideredAnAttack(this DamageType damageType)
	{
		if (damageType != DamageType.Decay)
		{
			return damageType != DamageType.Collision;
		}
		return false;
	}

	public static bool InterruptsRestraintMinigame(this DamageType damageType)
	{
		if (damageType != DamageType.Fall && damageType != DamageType.Blunt && damageType != DamageType.Slash && damageType != DamageType.Stab && damageType != DamageType.Bullet && damageType != DamageType.Explosion)
		{
			return damageType == DamageType.Arrow;
		}
		return true;
	}
}


using ConVar;
using UnityEngine;

internal static class GameInfo
{
	internal static bool IsOfficialServer
	{
		get
		{
			if (Application.isEditor)
			{
				return true;
			}
			return Server.official;
		}
	}

	internal static bool HasAchievements => IsOfficialServer;
}


public static class Defines
{
	public static class Connection
	{
		public const byte mode_steam = 228;
	}

	public static class Tags
	{
		public const string NotPlayerUsable = "Not Player Usable";
	}

	public static uint appID = 252490u;

	public const string resourceFolder = "assets/bundled";
}


public static class Connection
{
	public const byte mode_steam = 228;
}


public static class Tags
{
	public const string NotPlayerUsable = "Not Player Usable";
}


using UnityEngine.SceneManagement;

public static class Generic
{
	private static Scene _batchingScene;

	public static Scene BatchingScene
	{
		get
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!((Scene)(ref _batchingScene)).IsValid())
			{
				_batchingScene = SceneManager.CreateScene("Batching");
			}
			return _batchingScene;
		}
	}
}


using UnityEngine.SceneManagement;

public static class Server
{
	public const float UseDistance = 3f;

	private static Scene _entityScene;

	public static Scene EntityScene
	{
		get
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!((Scene)(ref _entityScene)).IsValid())
			{
				_entityScene = SceneManager.CreateScene("Server Entities");
			}
			return _entityScene;
		}
	}
}


using Facepunch;
using ProtoBuf.Nexus;

public interface INexusRequestHandler : IPooled
{
	Response Response { get; }

	void Execute();
}


using System;
using Facepunch;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public abstract class BaseNexusRequestHandler<T> : INexusRequestHandler, IPooled where T : class
{
	private bool _fireAndForget;

	protected NexusZoneDetails FromZone { get; private set; }

	protected Uuid RequestId { get; private set; }

	protected T Request { get; private set; }

	public Response Response { get; private set; }

	public void Initialize(NexusZoneDetails fromZone, Uuid id, bool fireAndForget, T request)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		FromZone = fromZone;
		RequestId = id;
		Request = request;
		_fireAndForget = fireAndForget;
	}

	public void EnterPool()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		FromZone = null;
		RequestId = Uuid.Empty;
		Request = null;
		Response = null;
		_fireAndForget = false;
		Reset();
	}

	public void LeavePool()
	{
	}

	public void Execute()
	{
		try
		{
			Handle();
			if (Response == null)
			{
				SendSuccess();
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			if (Response != null)
			{
				Debug.LogError((object)"Nexus RPC handler threw an exception but already sent a response!");
			}
			else
			{
				SendError(ex.Message);
			}
		}
	}

	protected abstract void Handle();

	protected virtual void Reset()
	{
	}

	protected void SendSuccess()
	{
		SendResult(success: true);
	}

	protected void SendSuccess(Response response)
	{
		SendResult(success: true, response);
	}

	protected void SendResult(bool success)
	{
		SendResult(success, NewResponse());
	}

	protected void SendResult(bool success, Response response)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (_fireAndForget)
		{
			response.Dispose();
			return;
		}
		if (Response != null)
		{
			response.Dispose();
			throw new InvalidOperationException("Already sent a response for this nexus RPC invocation!");
		}
		response.id = RequestId;
		response.status = Pool.Get<Status>();
		response.status.success = success;
		Response = response;
	}

	protected void SendError(string message)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (!_fireAndForget)
		{
			if (Response != null)
			{
				throw new InvalidOperationException("Already sent a response for this nexus RPC invocation!");
			}
			Response val = Pool.Get<Response>();
			val.id = RequestId;
			val.status = Pool.Get<Status>();
			val.status.success = false;
			val.status.errorMessage = message;
			Response = val;
		}
	}

	protected static Response NewResponse()
	{
		return Pool.Get<Response>();
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class ClanChatBatchHandler : BaseNexusRequestHandler<ClanChatBatchRequest>
{
	protected override void Handle()
	{
		if (!(ClanManager.ServerInstance.Backend is NexusClanBackend nexusClanBackend))
		{
			Debug.LogError((object)"Received a clan chat batch but this server isn't using the nexus clan backend!");
		}
		else
		{
			nexusClanBackend.HandleClanChatBatch(base.Request);
		}
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;

public class DestroyBagHandler : BaseNexusRequestHandler<SleepingBagDestroyRequest>
{
	protected override void Handle()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		SleepingBag.DestroyBag(base.Request.userId, base.Request.sleepingBagId);
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class FerryRetireHandler : BaseNexusRequestHandler<FerryRetireRequest>
{
	protected override void Handle()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NexusFerry nexusFerry = NexusFerry.Get(base.Request.entityId, base.Request.timestamp);
		if ((Object)(object)nexusFerry != (Object)null)
		{
			nexusFerry.Retire();
		}
		SendSuccess();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class FerryStatusHandler : BaseNexusRequestHandler<FerryStatusRequest>
{
	protected override void Handle()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		FerryStatusResponse val = Pool.Get<FerryStatusResponse>();
		val.statuses = Pool.Get<List<FerryStatus>>();
		Enumerator<NexusFerry> enumerator = NexusFerry.All.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				NexusFerry current = enumerator.Current;
				if (!((Object)(object)current == (Object)null))
				{
					FerryStatus status = current.GetStatus();
					val.statuses.Add(status);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Response val2 = Pool.Get<Response>();
		val2.ferryStatus = val;
		SendSuccess(val2);
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class FerryUpdateScheduleHandler : BaseNexusRequestHandler<FerryUpdateScheduleRequest>
{
	protected override void Handle()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NexusFerry nexusFerry = NexusFerry.Get(base.Request.entityId, base.Request.timestamp);
		if ((Object)(object)nexusFerry != (Object)null)
		{
			nexusFerry.UpdateSchedule(base.Request.schedule);
		}
		SendSuccess();
	}
}


using ConVar;
using Facepunch;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;

public class PingHandler : BaseNexusRequestHandler<PingRequest>
{
	protected override void Handle()
	{
		Response val = BaseNexusRequestHandler<PingRequest>.NewResponse();
		val.ping = Pool.Get<PingResponse>();
		val.ping.players = BasePlayer.activePlayerList.Count;
		val.ping.maxPlayers = Server.maxplayers;
		val.ping.queuedPlayers = SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued;
		SendSuccess(val);
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;

public class PlayerManifestHandler : BaseNexusRequestHandler<PlayerManifestRequest>
{
	protected override void Handle()
	{
		NexusServer.AddZonePlayerManifest(base.FromZone.Key, base.Request.userIds);
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class RespawnAtBagHandler : BaseNexusRequestHandler<SleepingBagRespawnRequest>
{
	protected override void Handle()
	{
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = BasePlayer.FindByID(base.Request.userId) ?? BasePlayer.FindSleeping(base.Request.userId);
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsConnected)
			{
				basePlayer.Kick("You're apparently respawning from a another zone - contact developers!");
			}
			basePlayer.Kill();
		}
		BasePlayer basePlayer2 = SingletonComponent<ServerMgr>.Instance.SpawnNewPlayer(null);
		basePlayer2.userID = base.Request.userId;
		basePlayer2.UserIDString = base.Request.userId.ToString();
		basePlayer2.displayName = basePlayer2.UserIDString;
		basePlayer2.SetPlayerFlag(BasePlayer.PlayerFlags.LoadingAfterTransfer, b: true);
		if (!SleepingBag.TrySpawnPlayer(basePlayer2, base.Request.sleepingBagId, out var errorMessage))
		{
			basePlayer2.Kill();
			SendError(errorMessage);
		}
		if (basePlayer2.isMounted)
		{
			basePlayer2.DisableTransferProtection();
		}
		else if (!basePlayer2.isMounted)
		{
			basePlayer2.SetPlayerFlag(BasePlayer.PlayerFlags.LoadingAfterTransfer, b: false);
		}
		basePlayer2.LoadSecondaryData(base.Request.secondaryData);
		basePlayer2.LoadClanInfo();
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;

public class SpawnOptionsHandler : BaseNexusRequestHandler<SpawnOptionsRequest>
{
	protected override void Handle()
	{
		Response val = BaseNexusRequestHandler<SpawnOptionsRequest>.NewResponse();
		val.spawnOptions = Pool.Get<SpawnOptionsResponse>();
		val.spawnOptions.spawnOptions = Pool.Get<List<SpawnOptions>>();
		BasePlayer.GetRespawnOptionsForPlayer(val.spawnOptions.spawnOptions, base.Request.userId);
		SendSuccess(val);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust;
using Rust.Nexus.Handlers;
using UnityEngine;

public class TransferHandler : BaseNexusRequestHandler<TransferRequest>
{
	private static readonly Dictionary<ulong, ulong> UidMapping = new Dictionary<ulong, ulong>();

	private static readonly Dictionary<NetworkableId, Entity> UidToEntity = new Dictionary<NetworkableId, Entity>();

	private static readonly Dictionary<BaseEntity, Entity> EntityToSpawn = new Dictionary<BaseEntity, Entity>();

	private static readonly Dictionary<ulong, BasePlayer> SpawnedPlayers = new Dictionary<ulong, BasePlayer>();

	private static readonly List<string> PlayerIds = new List<string>();

	private static readonly List<NetworkableId> EntitiesToProtect = new List<NetworkableId>();

	private static readonly Dictionary<ulong, RelationshipManager.PlayerTeam> TeamMapping = new Dictionary<ulong, RelationshipManager.PlayerTeam>();

	protected override void Handle()
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		UidMapping.Clear();
		base.Request.InspectUids((UidInspector<ulong>)UpdateWithNewUid);
		UidToEntity.Clear();
		PlayerIds.Clear();
		EntitiesToProtect.Clear();
		foreach (Entity entity in base.Request.entities)
		{
			UidToEntity.Add(entity.baseNetworkable.uid, entity);
			if (entity.basePlayer != null)
			{
				ulong userid = entity.basePlayer.userid;
				PlayerIds.Add(userid.ToString("G"));
				BasePlayer basePlayer = BasePlayer.FindByID(userid) ?? BasePlayer.FindSleeping(userid);
				if ((Object)(object)basePlayer != (Object)null)
				{
					if (basePlayer.IsConnected)
					{
						basePlayer.Kick("Player transfer is overwriting you - contact developers!");
					}
					basePlayer.Kill();
				}
				entity.basePlayer.currentTeam = 0uL;
				RelationshipManager.ServerInstance.FindPlayersTeam(userid)?.RemovePlayer(userid);
				if ((entity.basePlayer.playerFlags & 0x10) == 0)
				{
					BasePlayer basePlayer2 = entity.basePlayer;
					basePlayer2.playerFlags |= 0x2000000;
				}
				if (entity.basePlayer.loadingTimeout <= 0f || entity.basePlayer.loadingTimeout > Nexus.loadingTimeout)
				{
					entity.basePlayer.loadingTimeout = Nexus.loadingTimeout;
				}
			}
			if (entity.baseCombat != null && entity.baseNetworkable != null)
			{
				EntitiesToProtect.Add(entity.baseNetworkable.uid);
			}
		}
		RepositionEntitiesFromTransfer();
		SpawnedPlayers.Clear();
		SpawnEntities(SpawnedPlayers);
		foreach (NetworkableId item in EntitiesToProtect)
		{
			if (BaseNetworkable.serverEntities.Find(item) is BaseEntity baseEntity)
			{
				baseEntity.EnableTransferProtection();
			}
		}
		TeamMapping.Clear();
		foreach (PlayerSecondaryData secondaryDatum in base.Request.secondaryData)
		{
			if (!SpawnedPlayers.TryGetValue(secondaryDatum.userId, out var value))
			{
				Debug.LogError((object)$"Got secondary data for {secondaryDatum.userId} but they were not spawned in the transfer");
				continue;
			}
			value.LoadSecondaryData(secondaryDatum);
			if (secondaryDatum.isTeamLeader && secondaryDatum.teamId != 0L && !TeamMapping.ContainsKey(secondaryDatum.teamId))
			{
				RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.CreateTeam();
				playerTeam.teamLeader = value.userID;
				playerTeam.AddPlayer(value);
				TeamMapping.Add(secondaryDatum.teamId, playerTeam);
			}
		}
		foreach (PlayerSecondaryData secondaryDatum2 in base.Request.secondaryData)
		{
			if (SpawnedPlayers.TryGetValue(secondaryDatum2.userId, out var value2) && secondaryDatum2.teamId != 0L && !secondaryDatum2.isTeamLeader)
			{
				if (TeamMapping.TryGetValue(secondaryDatum2.teamId, out var value3))
				{
					value3.AddPlayer(value2);
					continue;
				}
				RelationshipManager.PlayerTeam playerTeam2 = RelationshipManager.ServerInstance.CreateTeam();
				playerTeam2.teamLeader = value2.userID;
				playerTeam2.AddPlayer(value2);
				TeamMapping.Add(secondaryDatum2.teamId, playerTeam2);
			}
		}
		if (PlayerIds.Count > 0)
		{
			CompleteTransfers();
		}
		static void UpdateWithNewUid(UidType type, ref ulong prevUid)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			if ((int)type == 3)
			{
				prevUid = 0uL;
			}
			else if (prevUid != 0L)
			{
				if (!UidMapping.TryGetValue(prevUid, out var value4))
				{
					value4 = Net.sv.TakeUID();
					UidMapping.Add(prevUid, value4);
				}
				prevUid = value4;
			}
		}
	}

	private static async void CompleteTransfers()
	{
		try
		{
			await NexusServer.ZoneClient.CompleteTransfers((IEnumerable<string>)PlayerIds);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private void RepositionEntitiesFromTransfer()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		Entity obj = base.Request.entities[0];
		Vector3 pos = obj.baseEntity.pos;
		Quaternion val = Quaternion.Euler(obj.baseEntity.rot);
		(Vector3 Position, Quaternion Rotation, bool PreserveY) tuple = ZoneController.Instance.ChooseTransferDestination(base.FromZone.Key, base.Request.method, base.Request.from, base.Request.to, pos, val);
		var (val2, val3, _) = tuple;
		if (tuple.PreserveY)
		{
			val2.y = pos.y;
		}
		Vector3 val4 = val2 - pos;
		Quaternion val5 = Quaternion.Inverse(val) * val3;
		foreach (Entity entity in base.Request.entities)
		{
			if (entity.baseEntity == null)
			{
				continue;
			}
			if (entity.parent != null && ((NetworkableId)(ref entity.parent.uid)).IsValid)
			{
				if (!UidToEntity.TryGetValue(entity.parent.uid, out var _))
				{
					Debug.LogError((object)$"Transferred entity (ID={entity.baseNetworkable.uid}) has a parent set but it wasn't found in the transfer! The parent is required to correctly restore this entity's position!");
				}
				if (((Vector3)(ref entity.baseEntity.pos)).magnitude > 100f)
				{
					Debug.LogError((object)$"Transferred entity (ID={entity.baseNetworkable.uid}) has a valid parent (ID={entity.parent.uid}) but its position ({entity.baseEntity.pos}) doesn't seem to be in local space! This will probably not work properly!");
				}
			}
			else
			{
				BaseEntity baseEntity = entity.baseEntity;
				baseEntity.pos += val4;
				BaseEntity baseEntity2 = entity.baseEntity;
				Quaternion val6 = Quaternion.Euler(entity.baseEntity.rot) * val5;
				baseEntity2.rot = ((Quaternion)(ref val6)).eulerAngles;
			}
		}
	}

	private void SpawnEntities(Dictionary<ulong, BasePlayer> players)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		Application.isLoadingSave = true;
		try
		{
			EntityToSpawn.Clear();
			foreach (Entity entity in base.Request.entities)
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(StringPool.Get(entity.baseNetworkable.prefabID), entity.baseEntity.pos, Quaternion.Euler(entity.baseEntity.rot));
				if ((Object)(object)baseEntity != (Object)null)
				{
					baseEntity.InitLoad(entity.baseNetworkable.uid);
					baseEntity.PreServerLoad();
					EntityToSpawn.Add(baseEntity, entity);
				}
			}
			foreach (KeyValuePair<BaseEntity, Entity> item in EntityToSpawn)
			{
				BaseEntity key = item.Key;
				if (!((Object)(object)key == (Object)null))
				{
					key.Spawn();
					key.Load(new BaseNetworkable.LoadInfo
					{
						fromDisk = true,
						fromTransfer = true,
						msg = item.Value
					});
				}
			}
			foreach (KeyValuePair<BaseEntity, Entity> item2 in EntityToSpawn)
			{
				BaseEntity key2 = item2.Key;
				if (!((Object)(object)key2 == (Object)null))
				{
					key2.UpdateNetworkGroup();
					key2.PostServerLoad();
					if (key2 is BasePlayer basePlayer)
					{
						players[basePlayer.userID] = basePlayer;
					}
				}
			}
		}
		finally
		{
			Application.isLoadingSave = false;
		}
	}
}


using System;
using System.Diagnostics;
using Rust.Assertions;
using UnityEngine;

public static class Assert
{
	public class SafetyException : Exception
	{
		public SafetyException(string message)
			: base(message)
		{
		}
	}

	public class NullEntityException : SafetyException
	{
		public NullEntityException()
			: base("Entity reference is null.")
		{
		}
	}

	public class InvalidEntityException : SafetyException
	{
		public InvalidEntityException()
			: base("Entity is invalid.")
		{
		}
	}

	public class WrongSideException : SafetyException
	{
		public WrongSideException(string side)
			: base("Entity is not a " + side + "-side entity.")
		{
		}
	}

	public class NullResourceRefException : SafetyException
	{
		public NullResourceRefException()
			: base("ResourceRef is null.")
		{
		}
	}

	public class InvalidResourceRefException : SafetyException
	{
		public InvalidResourceRefException()
			: base("ResourceRef is invalid.")
		{
		}
	}

	public static void That(bool condition, string message = "Assertion failed")
	{
		if (!condition)
		{
			Debug.LogError((object)message);
		}
	}

	[Conditional("SERVER")]
	public static void ThatOnServer(bool condition, string message = "Server assertion failed")
	{
		if (!condition)
		{
			Debug.LogError((object)message);
		}
	}

	[Conditional("CLIENT")]
	public static void ThatOnClient(bool condition, string message = "Client assertion failed")
	{
		if (!condition)
		{
			Debug.LogError((object)message);
		}
	}

	public static void NotNull(object obj, string message = "Value must not be null")
	{
		That(obj != null, message);
	}

	public static void Equal(object actual, object expected, string message = "Values are not equal")
	{
		That(AreEqual(actual, expected), message);
	}

	public static void NotEqual(object actual, object notExpected, string message = "Values should not be equal")
	{
		That(!AreEqual(actual, notExpected), message);
	}

	public static void InRange<T>(T value, T min, T max, string message = "Values not in range") where T : IComparable<T>
	{
		That(value.CompareTo(min) >= 0 && value.CompareTo(max) <= 0, message);
	}

	private static bool AreEqual(object a, object b)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected O, but got Unknown
		//IL_0021: Expected O, but got Unknown
		if (a is Object || b is Object)
		{
			return (Object)a == (Object)b;
		}
		return object.Equals(a, b);
	}

	public static void EntityValid(BaseEntity entity)
	{
		if (!Object.op_Implicit((Object)(object)entity))
		{
			throw new NullEntityException();
		}
		if (!entity.IsValid())
		{
			throw new InvalidEntityException();
		}
	}

	public static void EntityIsServer(BaseEntity entity)
	{
		EntityValid(entity);
		if (!entity.isServer)
		{
			throw new WrongSideException("server");
		}
	}

	public static void EntityIsClient(BaseEntity entity)
	{
		EntityValid(entity);
		if (entity.isServer)
		{
			throw new WrongSideException("client");
		}
	}

	public static void RefValid<T>(ResourceRef<T> gRef) where T : Object
	{
		if (gRef == null)
		{
			throw new NullResourceRefException();
		}
		if (!gRef.isValid)
		{
			throw new InvalidResourceRefException();
		}
	}
}


using System;

public class SafetyException : Exception
{
	public SafetyException(string message)
		: base(message)
	{
	}
}


public class NullEntityException : SafetyException
{
	public NullEntityException()
		: base("Entity reference is null.")
	{
	}
}


public class InvalidEntityException : SafetyException
{
	public InvalidEntityException()
		: base("Entity is invalid.")
	{
	}
}


public class WrongSideException : SafetyException
{
	public WrongSideException(string side)
		: base("Entity is not a " + side + "-side entity.")
	{
	}
}


public class NullResourceRefException : SafetyException
{
	public NullResourceRefException()
		: base("ResourceRef is null.")
	{
	}
}


public class InvalidResourceRefException : SafetyException
{
	public InvalidResourceRefException()
		: base("ResourceRef is invalid.")
	{
	}
}


using System;
using UnityEngine;

public static class Check
{
	public static bool EntityValid(BaseEntity entity)
	{
		if (Object.op_Implicit((Object)(object)entity))
		{
			return entity.IsValid();
		}
		return false;
	}

	public static bool EntityIsServer(BaseEntity entity)
	{
		if (EntityValid(entity))
		{
			return entity.isServer;
		}
		return false;
	}

	public static bool EntityIsClient(BaseEntity entity)
	{
		if (EntityValid(entity))
		{
			return entity.isClient;
		}
		return false;
	}

	public static bool EntitySamePrefabs(BaseEntity entity1, BaseEntity entity2)
	{
		return entity1.prefabID == entity2.prefabID;
	}

	public static bool FlagChanged(Enum flag, BaseEntity.Flags old, BaseEntity.Flags next)
	{
		if (next.HasFlag(flag))
		{
			return !old.HasFlag(flag);
		}
		return false;
	}

	public static bool RefValid<T>(ResourceRef<T> gRef) where T : Object
	{
		return gRef?.isValid ?? false;
	}

	public static bool InBuildingPrivilegeArea(BasePlayer ply, bool useCache = true, float cacheDuration = 1f)
	{
		if (!((Object)(object)ply.GetBuildingPrivilege(useCache, cacheDuration) != (Object)null))
		{
			return ply.HasPrivilegeFromOther(useCache);
		}
		return true;
	}

	public static bool HasTCBuildingPrivilege(BasePlayer ply, bool useCache = true, float cacheDuration = 1f)
	{
		return ply.IsBuildingAuthed(useCache, cacheDuration);
	}

	public static bool HasOtherBuildingPrivilege(BasePlayer ply, bool useCache = true)
	{
		return ply.HasPrivilegeFromOther(useCache);
	}

	public static bool HasBuildingPrivilege(BasePlayer ply, bool useCache = true, float cacheDuration = 1f)
	{
		if (!ply.IsBuildingAuthed(useCache, cacheDuration))
		{
			return ply.HasPrivilegeFromOther(useCache);
		}
		return true;
	}

	public static bool IsAuthorisedToBuild(BasePlayer ply, bool useCache = true, float cacheDuration = 1f)
	{
		if (!InBuildingPrivilegeArea(ply, useCache))
		{
			return false;
		}
		return ply.CanBuild(useCache, cacheDuration);
	}

	public static bool IsValidAttackTarget(BasePlayer ply)
	{
		if ((Object)(object)ply == (Object)null)
		{
			return false;
		}
		if (!ply.IsAlive())
		{
			return false;
		}
		if (ply.InSafeZone())
		{
			return false;
		}
		if (ply.IsInTutorial)
		{
			return false;
		}
		if (ply.IsSleeping())
		{
			return false;
		}
		if (ply.isInvisible)
		{
			return false;
		}
		if (ply.IsNpc || ply.IsBot || ply is HumanNPC)
		{
			return false;
		}
		return true;
	}

	public static bool SimplyOnTerrainAt(Vector3 point)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		float height = TerrainMeta.HeightMap.GetHeight(point);
		float oceanLevel = WaterSystem.OceanLevel;
		return height > oceanLevel;
	}

	public static bool IsValidWeapon(Item item, bool checkCanUseTurret)
	{
		ItemDefinition info = item.info;
		if (item.isBroken)
		{
			return false;
		}
		ItemModEntity component = ((Component)info).GetComponent<ItemModEntity>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		HeldEntity component2 = component.entityPrefab.Get().GetComponent<HeldEntity>();
		if ((Object)(object)component2 == (Object)null)
		{
			return false;
		}
		if (checkCanUseTurret && !component2.IsUsableByTurret)
		{
			return false;
		}
		return true;
	}
}


using Rust.Safety;
using UnityEngine;

public static class CheckExtensions
{
	public static bool IsValidAttackTarget(this BasePlayer ply)
	{
		return Check.IsValidAttackTarget(ply);
	}

	public static bool IsInsideDeepSea(this BaseNetworkable entity)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return DeepSeaManager.IsInsideDeepSea(((Component)entity).transform.position);
	}
}


using Rust.Rendering.IndirectInstancing;
using UnityEngine;

[DefaultExecutionOrder(-1250)]
public class IndirectInstancingCamera : SingletonComponent<IndirectInstancingCamera>
{
	public Shader[] supportedShaders;
}


public ref struct DebugStats
{
	public int calls_submitted;

	public int commands_submitted;

	public uint instances_submitted;

	public int num_transparent_calls;

	public int num_graphics_calls_multi_draw;

	public int num_graphics_calls_mesh_draw;

	public long cull_result_bits_0;

	public long cull_result_bits_1;

	public const int cull_result_bits = 128;

	public bool IsSet(int bit)
	{
		return (((bit < 64) ? cull_result_bits_0 : cull_result_bits_1) & (1L << bit)) != 0;
	}
}


public abstract class InstancedLODComponent : LODComponent
{
}


using System.Runtime.InteropServices;
using UnityEngine;

public struct PerInstanceData
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Property
	{
		public static readonly int _ObjectToWorld = Shader.PropertyToID("_ObjectToWorld");

		public static readonly int _TextureIndex = Shader.PropertyToID("_TextureIndex");

		public static readonly int _Color = Shader.PropertyToID("_Color");

		public static readonly int _DetailColor = Shader.PropertyToID("_DetailColor");

		public static readonly int _DetailAlbedoMap_ST = Shader.PropertyToID("_DetailAlbedoMap_ST");

		public static readonly int _EmissionColor = Shader.PropertyToID("_EmissionColor");

		public static readonly int _MainTex_ST = Shader.PropertyToID("_MainTex_ST");
	}

	public Matrix4x4 _ObjectToWorld;

	public int _TextureIndex;

	public Color _Color;

	public Color _DetailColor;

	public Vector4 _DetailAlbedoMap_ST;

	public Color _EmissionColor;

	public Vector4 _MainTex_ST;

	public float MinDistance;

	public float MaxDistance;
}


using System.Runtime.InteropServices;
using UnityEngine;

[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct Property
{
	public static readonly int _ObjectToWorld = Shader.PropertyToID("_ObjectToWorld");

	public static readonly int _TextureIndex = Shader.PropertyToID("_TextureIndex");

	public static readonly int _Color = Shader.PropertyToID("_Color");

	public static readonly int _DetailColor = Shader.PropertyToID("_DetailColor");

	public static readonly int _DetailAlbedoMap_ST = Shader.PropertyToID("_DetailAlbedoMap_ST");

	public static readonly int _EmissionColor = Shader.PropertyToID("_EmissionColor");

	public static readonly int _MainTex_ST = Shader.PropertyToID("_MainTex_ST");
}


using System;
using Rust.Rendering.IndirectInstancing;
using UnityEngine;

internal struct Frustum
{
	public Plane left;

	public Plane right;

	public Plane down;

	public Plane up;

	public Plane near;

	public Plane far;

	[ThreadStatic]
	private static Plane[] reusable_plane_array;

	public Frustum(Camera camera)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		GeometryUtility.CalculateFrustumPlanes(camera, reusable_plane_array);
		left = reusable_plane_array[0];
		right = reusable_plane_array[1];
		down = reusable_plane_array[2];
		up = reusable_plane_array[3];
		near = reusable_plane_array[4];
		far = reusable_plane_array[5];
	}

	static Frustum()
	{
		reusable_plane_array = (Plane[])(object)new Plane[6];
	}

	public static implicit operator Frustum(Camera camera)
	{
		return new Frustum(camera);
	}
}


public interface IMotionToggle
{
	void MotionStart();

	void OnBeforeMaterialChange();

	void OnAfterMaterialChange();
}


using System.Collections.Generic;
using Facepunch;
using Rust.Rendering.IndirectInstancing;
using UnityEngine;

public static class MotionToggleEx
{
	public static void BroadcastMotionStartSlow(this GameObject go)
	{
		List<IMotionToggle> list = Pool.Get<List<IMotionToggle>>();
		go.GetComponentsInChildren<IMotionToggle>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].MotionStart();
		}
		Pool.FreeUnmanaged<IMotionToggle>(ref list);
	}

	public static void BroadcastBeforeMaterialChange(this GameObject go)
	{
		List<IMotionToggle> list = Pool.Get<List<IMotionToggle>>();
		go.GetComponentsInChildren<IMotionToggle>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnBeforeMaterialChange();
		}
		Pool.FreeUnmanaged<IMotionToggle>(ref list);
	}

	public static void BroadcastAfterMaterialChange(this GameObject go)
	{
		List<IMotionToggle> list = Pool.Get<List<IMotionToggle>>();
		go.GetComponentsInChildren<IMotionToggle>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnAfterMaterialChange();
		}
		Pool.FreeUnmanaged<IMotionToggle>(ref list);
	}
}


using Rust.Rendering.IndirectInstancing;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Assertions;

internal struct TerrainRef
{
	public ReadOnly<short> data;

	public ReadOnly<byte> alpha;

	public Vector3 pos;

	public Vector3 size;

	public Vector3 one_over_size;

	public int res;

	public int alpha_res;

	public static TerrainRef FromCurrent()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsNotNull<TerrainHeightMap>(TerrainMeta.HeightMap, "Cannot create TerrainRef because there is no terrain!");
		TerrainRef result = default(TerrainRef);
		result.data = TerrainMeta.HeightMap.src.AsReadOnly();
		result.alpha = TerrainMeta.AlphaMap.src.AsReadOnly();
		result.pos = TerrainMeta.Position;
		result.size = TerrainMeta.Size;
		result.one_over_size = TerrainMeta.OneOverSize;
		result.res = TerrainMeta.HeightMap.res;
		result.alpha_res = TerrainMeta.AlphaMap.res;
		return result;
	}
}


using Rust.Water5;
using Unity.Mathematics;
using UnityEngine;

public struct OceanDisplacementShort3
{
	private const float precision = 20f;

	private const float float2short = 32766f;

	private const float short2float = 3.051944E-05f;

	public short x;

	public short y;

	public short z;

	public static implicit operator Vector3(OceanDisplacementShort3 v)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = default(Vector3);
		result.x = 3.051944E-05f * (float)v.x * 20f;
		result.y = 3.051944E-05f * (float)v.y * 20f;
		result.z = 3.051944E-05f * (float)v.z * 20f;
		return result;
	}

	public static implicit operator OceanDisplacementShort3(Vector3 v)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		OceanDisplacementShort3 result = default(OceanDisplacementShort3);
		result.x = (short)(v.x / 20f * 32766f + 0.5f);
		result.y = (short)(v.y / 20f * 32766f + 0.5f);
		result.z = (short)(v.z / 20f * 32766f + 0.5f);
		return result;
	}

	public static implicit operator OceanDisplacementShort3(float3 v)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		OceanDisplacementShort3 result = default(OceanDisplacementShort3);
		result.x = (short)(v.x / 20f * 32766f + 0.5f);
		result.y = (short)(v.y / 20f * 32766f + 0.5f);
		result.z = (short)(v.z / 20f * 32766f + 0.5f);
		return result;
	}

	public static implicit operator float3(OceanDisplacementShort3 v)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		float3 result = default(float3);
		result.x = 3.051944E-05f * (float)v.x * 20f;
		result.y = 3.051944E-05f * (float)v.y * 20f;
		result.z = 3.051944E-05f * (float)v.z * 20f;
		return result;
	}
}


using System;
using System.Runtime.CompilerServices;
using Rust.Water5;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

internal struct NativeOceanDisplacementShort3 : IDisposable
{
	public readonly struct ReadOnly
	{
		private readonly ReadOnly<OceanDisplacementShort3> oceanDisplacementShort3S;

		private readonly int spectrumCount;

		private readonly int frameCount;

		public OceanDisplacementShort3 this[int x, int y, int z]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				return oceanDisplacementShort3S[z * spectrumCount * frameCount + y * spectrumCount + x];
			}
		}

		public ReadOnly(ReadOnly<OceanDisplacementShort3> oceanDisplacementShort3s, int spectrumCount, int frameCount)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			oceanDisplacementShort3S = oceanDisplacementShort3s;
			this.spectrumCount = spectrumCount;
			this.frameCount = frameCount;
		}
	}

	[NativeDisableParallelForRestriction]
	private NativeArray<OceanDisplacementShort3> _arr;

	private int spectrumCount;

	private int frameCount;

	public OceanDisplacementShort3 this[int x, int y, int z]
	{
		get
		{
			return _arr[z * spectrumCount * frameCount + y * spectrumCount + x];
		}
		set
		{
			_arr[z * spectrumCount * frameCount + y * spectrumCount + x] = value;
		}
	}

	public int Length => _arr.Length;

	public static NativeOceanDisplacementShort3 Create(int x, int y, int z)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		NativeOceanDisplacementShort3 result = default(NativeOceanDisplacementShort3);
		result._arr = new NativeArray<OceanDisplacementShort3>(x * y * z, (Allocator)4, (NativeArrayOptions)0);
		result.spectrumCount = x;
		result.frameCount = y;
		return result;
	}

	public static NativeOceanDisplacementShort3 Create(OceanDisplacementShort3[,,] simData)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		NativeOceanDisplacementShort3 result = default(NativeOceanDisplacementShort3);
		result._arr = new NativeArray<OceanDisplacementShort3>(simData.Length, (Allocator)4, (NativeArrayOptions)1);
		result.spectrumCount = simData.GetLength(0);
		result.frameCount = simData.GetLength(1);
		for (int i = 0; i < result.spectrumCount; i++)
		{
			for (int j = 0; j < result.frameCount; j++)
			{
				for (int k = 0; k < simData.GetLength(2); k++)
				{
					result._arr[i * result.spectrumCount + j * result.frameCount + k] = simData[i, j, k];
				}
			}
		}
		return result;
	}

	public unsafe OceanDisplacementShort3* GetUnsafePtr()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (!_arr.IsCreated)
		{
			return null;
		}
		return (OceanDisplacementShort3*)NativeArrayUnsafeUtility.GetUnsafePtr<OceanDisplacementShort3>(_arr);
	}

	public ReadOnly<OceanDisplacementShort3> GetNativeRawReadOnly()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return _arr.AsReadOnly();
	}

	public NativeArray<OceanDisplacementShort3> GetNativeRaw()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _arr;
	}

	public void Dispose()
	{
		_arr.Dispose();
	}

	public ReadOnly AsReadOnly()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return new ReadOnly(_arr.AsReadOnly(), spectrumCount, frameCount);
	}
}


using System.Runtime.CompilerServices;
using Unity.Collections;

public readonly struct ReadOnly
{
	private readonly ReadOnly<OceanDisplacementShort3> oceanDisplacementShort3S;

	private readonly int spectrumCount;

	private readonly int frameCount;

	public OceanDisplacementShort3 this[int x, int y, int z]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return oceanDisplacementShort3S[z * spectrumCount * frameCount + y * spectrumCount + x];
		}
	}

	public ReadOnly(ReadOnly<OceanDisplacementShort3> oceanDisplacementShort3s, int spectrumCount, int frameCount)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		oceanDisplacementShort3S = oceanDisplacementShort3s;
		this.spectrumCount = spectrumCount;
		this.frameCount = frameCount;
	}
}


using System;
using System.Runtime.CompilerServices;
using OceanSimulationJobs;
using Rust.Water5;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Assertions;

public class OceanSimulation : IDisposable
{
	public const int octaveCount = 3;

	public const int simulationSize = 256;

	public const int physicsSimulationSize = 256;

	public const int physicsFrameRate = 4;

	public const int physicsLooptime = 18;

	public const int physicsFrameCount = 72;

	public const float phsyicsDeltaTime = 0.25f;

	public const float oneOverPhysicsSimulationSize = 0.00390625f;

	public const int physicsFrameSize = 65536;

	public const int physicsSpectrumOffset = 4718592;

	private OceanSettings oceanSettings;

	private float[] spectrumRanges;

	private float distanceAttenuationFactor;

	private float depthAttenuationFactor;

	private static float oneOverOctave0Scale;

	private static float[] beaufortValues;

	private int spectrum0;

	private int spectrum1;

	private float spectrumBlend;

	private int frame0;

	private int frame1;

	private float frameBlend;

	private float currentTime;

	private float prevUpdateComputeTime;

	private float deltaTime;

	private NativeOceanDisplacementShort3 nativeSimData;

	private GetHeightBatchedJob _cachedBatchJob;

	private GetHeightsJobIndirect _heightsJobIndirect;

	private NativeArray<float3> _batchPositionQueryArr;

	public int Spectrum0 => spectrum0;

	public int Spectrum1 => spectrum1;

	public float SpectrumBlend => spectrumBlend;

	public int Frame0 => frame0;

	public int Frame1 => frame1;

	public float FrameBlend => frameBlend;

	public OceanSimulation(OceanSettings oceanSettings)
	{
		this.oceanSettings = oceanSettings;
		oneOverOctave0Scale = 1f / oceanSettings.octaveScales[0];
		beaufortValues = new float[oceanSettings.spectrumSettings.Length];
		for (int i = 0; i < oceanSettings.spectrumSettings.Length; i++)
		{
			beaufortValues[i] = oceanSettings.spectrumSettings[i].beaufort;
		}
		nativeSimData = oceanSettings.LoadNativeSimData();
		spectrumRanges = oceanSettings.spectrumRanges;
		depthAttenuationFactor = oceanSettings.depthAttenuationFactor;
		distanceAttenuationFactor = oceanSettings.distanceAttenuationFactor;
		_cachedBatchJob = new GetHeightBatchedJob
		{
			SimData = nativeSimData.AsReadOnly()
		};
		_heightsJobIndirect = new GetHeightsJobIndirect
		{
			SimData = nativeSimData
		};
	}

	public void Update(float time, float dt, float beaufort)
	{
		currentTime = time % 18f;
		deltaTime = dt;
		FindFrames(currentTime, out frame0, out frame1, out frameBlend);
		FindSpectra(beaufort, out spectrum0, out spectrum1, out spectrumBlend);
	}

	private static void FindSpectra(float beaufort, out int spectrum0, out int spectrum1, out float spectrumT)
	{
		beaufort = Mathf.Clamp(beaufort, 0f, 10f);
		spectrum0 = (spectrum1 = 0);
		spectrumT = 0f;
		for (int i = 1; i < beaufortValues.Length; i++)
		{
			float num = beaufortValues[i - 1];
			float num2 = beaufortValues[i];
			if (beaufort >= num && beaufort <= num2)
			{
				spectrum0 = i - 1;
				spectrum1 = i;
				spectrumT = math.remap(num, num2, 0f, 1f, beaufort);
				break;
			}
		}
	}

	public static void FindFrames(float time, out int frame0, out int frame1, out float frameBlend)
	{
		frame0 = (int)math.floor(time * 4f);
		frame1 = (int)math.floor(time * 4f);
		frame1 = (frame1 + 1) % 72;
		frameBlend = math.remap((float)frame0 * 0.25f, (float)(frame0 + 1) * 0.25f, 0f, 1f, time);
	}

	public JobHandle TraceBatch(NativeList<int> indices, NativeArray<Ray> rays, NativeArray<float> maxDists, NativeArray<bool> hitResults, NativeArray<Vector3> hitPositions, JobHandle inputDeps)
	{
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Lerp(spectrumRanges[spectrum0], spectrumRanges[spectrum1], spectrumBlend);
		if (num <= 0.1f)
		{
			SmallDisplacementPlaneTraceJob smallDisplacementPlaneTraceJob = default(SmallDisplacementPlaneTraceJob);
			smallDisplacementPlaneTraceJob.SeaPlane = new Plane(Vector3.up, -0f);
			smallDisplacementPlaneTraceJob.Indices = indices;
			smallDisplacementPlaneTraceJob.Rays = rays;
			smallDisplacementPlaneTraceJob.MaxDists = maxDists.AsReadOnly();
			smallDisplacementPlaneTraceJob.HitResults = hitResults;
			smallDisplacementPlaneTraceJob.HitPositions = hitPositions;
			inputDeps = IJobParallelForDeferExtensions.Schedule<SmallDisplacementPlaneTraceJob, int>(smallDisplacementPlaneTraceJob, indices, 256, inputDeps);
			return inputDeps;
		}
		OceanTraceJob oceanTraceJob = default(OceanTraceJob);
		oceanTraceJob.MaxDisplacement = num;
		oceanTraceJob.Indices = indices;
		oceanTraceJob.Rays = rays;
		oceanTraceJob.MaxDists = maxDists.AsReadOnly();
		oceanTraceJob.HitResults = hitResults;
		oceanTraceJob.HitPositions = hitPositions;
		oceanTraceJob.OneOverOctave0Scale = oneOverOctave0Scale;
		oceanTraceJob.SimData = nativeSimData;
		oceanTraceJob.Spectrum0 = spectrum0;
		oceanTraceJob.Spectrum1 = spectrum1;
		oceanTraceJob.Frame0 = frame0;
		oceanTraceJob.Frame1 = frame1;
		oceanTraceJob.spectrumBlend = spectrumBlend;
		oceanTraceJob.frameBlend = frameBlend;
		oceanTraceJob.HeightMapQueryStructure = TerrainMeta.HeightMap.GetQueryStructure();
		oceanTraceJob.ShoreVectorQueryStructure = TerrainMeta.Texturing.GetShoreVectorQueryStructure();
		oceanTraceJob.distanceAttenuationFactor = distanceAttenuationFactor;
		oceanTraceJob.depthAttenuationFactor = depthAttenuationFactor;
		inputDeps = IJobParallelForDeferExtensions.Schedule<OceanTraceJob, int>(oceanTraceJob, indices, 256, inputDeps);
		return inputDeps;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Trace(Ray ray, float maxDist, out Vector3 result)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Lerp(spectrumRanges[spectrum0], spectrumRanges[spectrum1], spectrumBlend);
		if (num <= 0.1f)
		{
			Plane val = default(Plane);
			((Plane)(ref val))..ctor(Vector3.up, -0f);
			float num2 = default(float);
			if (((Plane)(ref val)).Raycast(ray, ref num2) && num2 < maxDist)
			{
				result = ((Ray)(ref ray)).GetPoint(num2);
				return true;
			}
			result = Vector3.zero;
			return false;
		}
		float num3 = 0f - num;
		Vector3 point = ((Ray)(ref ray)).GetPoint(maxDist);
		if (((Ray)(ref ray)).origin.y > num && point.y > num)
		{
			result = Vector3.zero;
			return false;
		}
		if (((Ray)(ref ray)).origin.y < num3 && point.y < num3)
		{
			result = Vector3.zero;
			return false;
		}
		Vector3 val2 = ((Ray)(ref ray)).origin;
		Vector3 direction = ((Ray)(ref ray)).direction;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 2f / (math.abs(direction.y) + 1f);
		result = val2;
		if (direction.y <= -0.99f)
		{
			result.y = GetHeight(val2);
			return math.lengthsq(float3.op_Implicit(result - val2)) < maxDist * maxDist;
		}
		if (val2.y >= num + 0f)
		{
			num5 = (num4 = (0f - (val2.y - num - 0f)) / direction.y);
			val2 += num4 * direction;
			if (num5 >= maxDist)
			{
				result = Vector3.zero;
				return false;
			}
		}
		int num7 = 0;
		while (true)
		{
			float height = GetHeight(val2);
			num4 = num6 * Mathf.Abs(val2.y - height - 0f);
			val2 += num4 * direction;
			num5 += num4;
			if (num7 >= 16 || num4 < 0.1f)
			{
				break;
			}
			if (num5 >= maxDist)
			{
				return false;
			}
			num7++;
		}
		if (num4 < 0.1f && num5 >= 0f)
		{
			result = val2;
			return true;
		}
		if (direction.y < 0f)
		{
			num4 = (0f - (val2.y + num - 0f)) / direction.y;
			Vector3 val3 = val2;
			Vector3 val4 = val2 + num4 * ((Ray)(ref ray)).direction;
			for (int i = 0; i < 16; i++)
			{
				val2 = (val3 + val4) * 0.5f;
				float height2 = GetHeight(val2);
				if (val2.y - height2 - 0f > 0f)
				{
					val3 = val2;
				}
				else
				{
					val4 = val2;
				}
				if (math.abs(val2.y - height2) < 0.1f)
				{
					val2.y = height2;
					break;
				}
			}
			result = val2;
			return true;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float MinLevel()
	{
		return 0f - Mathf.Lerp(spectrumRanges[spectrum0], spectrumRanges[spectrum1], spectrumBlend);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float MaxLevel()
	{
		return Mathf.Lerp(spectrumRanges[spectrum0], spectrumRanges[spectrum1], spectrumBlend);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float GetHeight(Vector3[,,] simData, Vector3 position, float time, float beaufort, float distAttenFactor, float depthAttenFactor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Position.x;
		float z = TerrainMeta.Position.z;
		float x2 = TerrainMeta.OneOverSize.x;
		float z2 = TerrainMeta.OneOverSize.z;
		float num = (position.x - x) * x2;
		float num2 = (position.z - z) * z2;
		Vector2 uv = default(Vector2);
		((Vector2)(ref uv))..ctor(num, num2);
		float num3 = (((Object)(object)TerrainTexturing.Instance != (Object)null) ? TerrainTexturing.Instance.GetCoarseDistanceToShore(position) : 0f);
		float num4 = (((Object)(object)TerrainMeta.HeightMap != (Object)null) ? TerrainMeta.HeightMap.GetHeightFast(uv) : 0f);
		float num5 = Mathf.Clamp01(num3 / distAttenFactor);
		float num6 = Mathf.Clamp01(Mathf.Abs(num4) / depthAttenFactor);
		Vector3 zero = Vector3.zero;
		zero = GetDisplacement(simData, position, time, beaufort);
		zero = GetDisplacement(simData, position - zero, time, beaufort);
		zero = GetDisplacement(simData, position - zero, time, beaufort);
		return GetDisplacement(simData, position - zero, time, beaufort).y * num5 * num6;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector3 GetDisplacement(Vector3[,,] simData, Vector3 position, float time, float beaufort)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		FindFrames(time, out var num, out var num2, out var num3);
		FindSpectra(beaufort, out var num4, out var num5, out var spectrumT);
		return GetDisplacement(simData, position, num, num2, num3, num4, num5, spectrumT);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector3 GetDisplacement(Vector3[,,] simData, Vector3 position, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		float normX = position.x * oneOverOctave0Scale;
		float normZ = position.z * oneOverOctave0Scale;
		return GetDisplacement(simData, normX, normZ, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector3 GetDisplacement(Vector3[,,] simData, float normX, float normZ, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		normX -= Mathf.Floor(normX);
		normZ -= Mathf.Floor(normZ);
		float num = normX * 256f - 0.5f;
		float num2 = normZ * 256f - 0.5f;
		int num3 = Mathf.FloorToInt(num);
		int num4 = Mathf.FloorToInt(num2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		int x = num3;
		int y = num4;
		int x2 = num3 + 1;
		int y2 = num4 + 1;
		Vector3 displacement = GetDisplacement(simData, x, y, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
		Vector3 displacement2 = GetDisplacement(simData, x2, y, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
		Vector3 displacement3 = GetDisplacement(simData, x, y2, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
		Vector3 displacement4 = GetDisplacement(simData, x2, y2, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
		Vector3 val = Vector3.LerpUnclamped(displacement, displacement2, num5);
		Vector3 val2 = Vector3.LerpUnclamped(displacement3, displacement4, num5);
		return Vector3.LerpUnclamped(val, val2, num6);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector3 GetDisplacement(Vector3[,,] simData, int x, int y, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		int num = x * 256 + y;
		Vector3 val = Vector3.LerpUnclamped(simData[spectrum0, frame0, num], simData[spectrum1, frame0, num], spectrumBlend);
		Vector3 val2 = Vector3.LerpUnclamped(simData[spectrum0, frame1, num], simData[spectrum1, frame1, num], spectrumBlend);
		return Vector3.LerpUnclamped(val, val2, frameBlend);
	}

	public void Dispose()
	{
		if (_batchPositionQueryArr.IsCreated)
		{
			_batchPositionQueryArr.Dispose();
		}
		nativeSimData.Dispose();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void GetHeightBatch(Vector2[] positions, float[] heights, float[] shore, float[] terrainHeight)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(positions.Length == heights.Length);
		PopulateBatchNative(positions);
		_cachedBatchJob.OneOverOctave0Scale = oneOverOctave0Scale;
		_cachedBatchJob.Frame0 = frame0;
		_cachedBatchJob.Frame1 = frame1;
		_cachedBatchJob.Spectrum0 = spectrum0;
		_cachedBatchJob.Spectrum1 = spectrum1;
		_cachedBatchJob.spectrumBlend = spectrumBlend;
		_cachedBatchJob.frameBlend = frameBlend;
		_cachedBatchJob.Positions = _batchPositionQueryArr;
		_cachedBatchJob.Count = positions.Length;
		ref GetHeightBatchedJob cachedBatchJob = ref _cachedBatchJob;
		int num = positions.Length;
		int batchSize = GamePhysics.GetBatchSize(positions.Length);
		JobHandle val = default(JobHandle);
		val = IJobParallelForExtensions.ScheduleByRef<GetHeightBatchedJob>(ref cachedBatchJob, num, batchSize, val);
		((JobHandle)(ref val)).Complete();
		for (int i = 0; i < heights.Length; i++)
		{
			heights[i] = _batchPositionQueryArr[i].x * GetHeightAttenuation(shore[i], terrainHeight[i]);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void GetHeightBatch(ReadOnlySpan<Vector2> positions, Span<float> heights, ReadOnlySpan<float> shore, ReadOnlySpan<float> terrainHeight)
	{
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(positions.Length == heights.Length);
		PopulateBatchNative(positions);
		_cachedBatchJob.OneOverOctave0Scale = oneOverOctave0Scale;
		_cachedBatchJob.Frame0 = frame0;
		_cachedBatchJob.Frame1 = frame1;
		_cachedBatchJob.Spectrum0 = spectrum0;
		_cachedBatchJob.Spectrum1 = spectrum1;
		_cachedBatchJob.spectrumBlend = spectrumBlend;
		_cachedBatchJob.frameBlend = frameBlend;
		_cachedBatchJob.Positions = _batchPositionQueryArr;
		_cachedBatchJob.Count = positions.Length;
		ref GetHeightBatchedJob cachedBatchJob = ref _cachedBatchJob;
		int length = positions.Length;
		int batchSize = GamePhysics.GetBatchSize(positions.Length);
		JobHandle val = default(JobHandle);
		val = IJobParallelForExtensions.ScheduleByRef<GetHeightBatchedJob>(ref cachedBatchJob, length, batchSize, val);
		((JobHandle)(ref val)).Complete();
		for (int i = 0; i < heights.Length; i++)
		{
			heights[i] = _batchPositionQueryArr[i].x * GetHeightAttenuation(shore[i], terrainHeight[i]);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void GetHeightBatch(NativeArray<float3> positions, Span<float> heights, ReadOnlySpan<float> shore, ReadOnlySpan<float> terrainHeight)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(positions.Length == heights.Length);
		_cachedBatchJob.OneOverOctave0Scale = oneOverOctave0Scale;
		_cachedBatchJob.Frame0 = frame0;
		_cachedBatchJob.Frame1 = frame1;
		_cachedBatchJob.Spectrum0 = spectrum0;
		_cachedBatchJob.Spectrum1 = spectrum1;
		_cachedBatchJob.spectrumBlend = spectrumBlend;
		_cachedBatchJob.frameBlend = frameBlend;
		_cachedBatchJob.Positions = positions;
		_cachedBatchJob.Count = positions.Length;
		ref GetHeightBatchedJob cachedBatchJob = ref _cachedBatchJob;
		int length = positions.Length;
		int batchSize = GamePhysics.GetBatchSize(positions.Length);
		JobHandle val = default(JobHandle);
		val = IJobParallelForExtensions.ScheduleByRef<GetHeightBatchedJob>(ref cachedBatchJob, length, batchSize, val);
		((JobHandle)(ref val)).Complete();
		for (int i = 0; i < heights.Length; i++)
		{
			heights[i] = positions[i].x * GetHeightAttenuation(shore[i], terrainHeight[i]);
		}
	}

	public void GetHeightsIndirect(ReadOnly<Vector3> pos, ReadOnly<float> shore, ReadOnly<float> terrainHeight, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		_heightsJobIndirect.Heights = results;
		_heightsJobIndirect.Pos = pos;
		_heightsJobIndirect.ShoreDists = shore;
		_heightsJobIndirect.TerrainHeights = terrainHeight;
		_heightsJobIndirect.Indices = indices;
		_heightsJobIndirect.OneOverOctave0Scale = oneOverOctave0Scale;
		_heightsJobIndirect.Frame0 = frame0;
		_heightsJobIndirect.Frame1 = frame1;
		_heightsJobIndirect.Spectrum0 = spectrum0;
		_heightsJobIndirect.Spectrum1 = spectrum1;
		_heightsJobIndirect.SpectrumBlend = spectrumBlend;
		_heightsJobIndirect.FrameBlend = frameBlend;
		_heightsJobIndirect.DistanceAttenuationFactor = distanceAttenuationFactor;
		_heightsJobIndirect.DepthAttenuationFactor = depthAttenuationFactor;
		IJobExtensions.RunByRef<GetHeightsJobIndirect>(ref _heightsJobIndirect);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float GetHeight(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		float heightAttenuation = GetHeightAttenuation(position);
		_cachedBatchJob.OneOverOctave0Scale = oneOverOctave0Scale;
		_cachedBatchJob.Frame0 = frame0;
		_cachedBatchJob.Frame1 = frame1;
		_cachedBatchJob.Spectrum0 = spectrum0;
		_cachedBatchJob.Spectrum1 = spectrum1;
		_cachedBatchJob.spectrumBlend = spectrumBlend;
		_cachedBatchJob.frameBlend = frameBlend;
		PopulateBatchNative(position);
		_cachedBatchJob.Positions = _batchPositionQueryArr;
		_cachedBatchJob.Count = 1;
		IJobExtensions.RunByRef<GetHeightBatchedJob>(ref _cachedBatchJob);
		return _cachedBatchJob.Positions[0].x * heightAttenuation;
	}

	private void PopulateBatchNative(Vector3 position)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (!_batchPositionQueryArr.IsCreated || _batchPositionQueryArr.Length < 1)
		{
			if (_batchPositionQueryArr.IsCreated)
			{
				_batchPositionQueryArr.Dispose();
			}
			_batchPositionQueryArr = new NativeArray<float3>(1, (Allocator)4, (NativeArrayOptions)1);
		}
		_batchPositionQueryArr[0] = float3.op_Implicit(position);
	}

	private void PopulateBatchNative(Vector2[] positions)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (!_batchPositionQueryArr.IsCreated || _batchPositionQueryArr.Length < positions.Length)
		{
			if (_batchPositionQueryArr.IsCreated)
			{
				_batchPositionQueryArr.Dispose();
			}
			_batchPositionQueryArr = new NativeArray<float3>(positions.Length, (Allocator)4, (NativeArrayOptions)1);
		}
		for (int i = 0; i < positions.Length; i++)
		{
			_batchPositionQueryArr[i] = float3.op_Implicit(Vector3Ex.XZ3D(positions[i]));
		}
	}

	private void PopulateBatchNative(ReadOnlySpan<Vector2> positions)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!_batchPositionQueryArr.IsCreated || _batchPositionQueryArr.Length < positions.Length)
		{
			if (_batchPositionQueryArr.IsCreated)
			{
				_batchPositionQueryArr.Dispose();
			}
			_batchPositionQueryArr = new NativeArray<float3>(positions.Length, (Allocator)4, (NativeArrayOptions)1);
		}
		for (int i = 0; i < positions.Length; i++)
		{
			_batchPositionQueryArr[i] = float3.op_Implicit(Vector3Ex.XZ3D(positions[i]));
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float GetHeightAttenuation(float shore, float terrainHeight)
	{
		float num = Mathf.Clamp01(shore / distanceAttenuationFactor);
		float num2 = Mathf.Clamp01(Mathf.Abs(terrainHeight) / depthAttenuationFactor);
		return num * num2;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float GetHeightAttenuation(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Position.x;
		float z = TerrainMeta.Position.z;
		float x2 = TerrainMeta.OneOverSize.x;
		float z2 = TerrainMeta.OneOverSize.z;
		float num = (position.x - x) * x2;
		float num2 = (position.z - z) * z2;
		Vector2 uv = default(Vector2);
		((Vector2)(ref uv))..ctor(num, num2);
		float num3 = (((Object)(object)TerrainTexturing.Instance != (Object)null) ? TerrainTexturing.Instance.GetCoarseDistanceToShore(position) : 0f);
		float num4 = (((Object)(object)TerrainMeta.HeightMap != (Object)null) ? TerrainMeta.HeightMap.GetHeightFast(uv) : 0f);
		float num5 = Mathf.Clamp01(num3 / distanceAttenuationFactor);
		float num6 = Mathf.Clamp01(Mathf.Abs(num4) / depthAttenuationFactor);
		return num5 * num6;
	}
}


using Rust.Water5;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile]
internal struct GetHeightBatchedJob : IJob, IJobParallelFor
{
	[NativeDisableParallelForRestriction]
	public NativeArray<float3> Positions;

	public int Count;

	public float OneOverOctave0Scale;

	public NativeOceanDisplacementShort3.ReadOnly SimData;

	public int Spectrum0;

	public int Spectrum1;

	public int Frame0;

	public int Frame1;

	public float spectrumBlend;

	public float frameBlend;

	public void Execute()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Count; i++)
		{
			ref NativeArray<float3> positions = ref Positions;
			int num = i;
			float3 val = Positions[i];
			positions[num] = float3.op_Implicit(GetHeightRaw(((float3)(ref val)).xyz));
		}
	}

	public void Execute(int index)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		ref NativeArray<float3> positions = ref Positions;
		float3 val = Positions[index];
		positions[index] = float3.op_Implicit(GetHeightRaw(((float3)(ref val)).xyz));
	}

	private float GetHeightRaw(float3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		float3 zero = float3.zero;
		zero = float3.op_Implicit(GetDisplacement(position));
		zero = float3.op_Implicit(GetDisplacement(position - zero));
		zero = float3.op_Implicit(GetDisplacement(position - zero));
		return GetDisplacement(position - zero).y;
	}

	private Vector3 GetDisplacement(float3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float normX = position.x * OneOverOctave0Scale;
		float normZ = position.z * OneOverOctave0Scale;
		return float3.op_Implicit(GetDisplacement(normX, normZ));
	}

	private float3 GetDisplacement(float normX, float normZ)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		normX -= math.floor(normX);
		normZ -= math.floor(normZ);
		float num = normX * 256f - 0.5f;
		float num2 = normZ * 256f - 0.5f;
		int num3 = (int)math.floor(num);
		int num4 = (int)math.floor(num2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		int num7 = num3 % 256;
		int num8 = num4 % 256;
		int x = (num7 + 256) % 256;
		int z = (num8 + 256) % 256;
		int x2 = (num7 + 1 + 256) % 256;
		int z2 = (num8 + 1 + 256) % 256;
		float3 displacementFromSimData = GetDisplacementFromSimData(x, z);
		float3 displacementFromSimData2 = GetDisplacementFromSimData(x2, z);
		float3 displacementFromSimData3 = GetDisplacementFromSimData(x, z2);
		float3 displacementFromSimData4 = GetDisplacementFromSimData(x2, z2);
		float3 val = math.lerp(displacementFromSimData, displacementFromSimData2, num5);
		float3 val2 = math.lerp(displacementFromSimData3, displacementFromSimData4, num5);
		return math.lerp(val, val2, num6);
	}

	private float3 GetDisplacementFromSimData(int x, int z)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		int z2 = x * 256 + z;
		float3 val = math.lerp((float3)SimData[Spectrum0, Frame0, z2], (float3)SimData[Spectrum1, Frame0, z2], spectrumBlend);
		float3 val2 = math.lerp((float3)SimData[Spectrum0, Frame1, z2], (float3)SimData[Spectrum1, Frame1, z2], spectrumBlend);
		return math.lerp(val, val2, frameBlend);
	}
}


using Rust.Water5;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile]
internal struct GetHeightsJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<float> ShoreDists;

	[ReadOnly]
	public ReadOnly<float> TerrainHeights;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public float OneOverOctave0Scale;

	[ReadOnly]
	public NativeOceanDisplacementShort3 SimData;

	[ReadOnly]
	public int Spectrum0;

	[ReadOnly]
	public int Spectrum1;

	[ReadOnly]
	public int Frame0;

	[ReadOnly]
	public int Frame1;

	[ReadOnly]
	public float SpectrumBlend;

	[ReadOnly]
	public float FrameBlend;

	[ReadOnly]
	public float DistanceAttenuationFactor;

	[ReadOnly]
	public float DepthAttenuationFactor;

	public void Execute()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			float heightRaw = GetHeightRaw(float3.op_Implicit(Pos[num]));
			Heights[num] = heightRaw * GetHeightAttenuation(ShoreDists[num], TerrainHeights[num]);
		}
	}

	private float GetHeightRaw(float3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		float3 zero = float3.zero;
		zero = float3.op_Implicit(GetDisplacement(position));
		zero = float3.op_Implicit(GetDisplacement(position - zero));
		zero = float3.op_Implicit(GetDisplacement(position - zero));
		return GetDisplacement(position - zero).y;
	}

	private Vector3 GetDisplacement(float3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float normX = position.x * OneOverOctave0Scale;
		float normZ = position.z * OneOverOctave0Scale;
		return float3.op_Implicit(GetDisplacement(normX, normZ));
	}

	private float3 GetDisplacement(float normX, float normZ)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		normX -= math.floor(normX);
		normZ -= math.floor(normZ);
		float num = normX * 256f - 0.5f;
		float num2 = normZ * 256f - 0.5f;
		int num3 = (int)math.floor(num);
		int num4 = (int)math.floor(num2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		int num7 = num3 % 256;
		int num8 = num4 % 256;
		int x = (num7 + 256) % 256;
		int z = (num8 + 256) % 256;
		int x2 = (num7 + 1 + 256) % 256;
		int z2 = (num8 + 1 + 256) % 256;
		float3 displacementFromSimData = GetDisplacementFromSimData(x, z);
		float3 displacementFromSimData2 = GetDisplacementFromSimData(x2, z);
		float3 displacementFromSimData3 = GetDisplacementFromSimData(x, z2);
		float3 displacementFromSimData4 = GetDisplacementFromSimData(x2, z2);
		float3 val = math.lerp(displacementFromSimData, displacementFromSimData2, num5);
		float3 val2 = math.lerp(displacementFromSimData3, displacementFromSimData4, num5);
		return math.lerp(val, val2, num6);
	}

	private float3 GetDisplacementFromSimData(int x, int z)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		int z2 = x * 256 + z;
		float3 val = math.lerp((float3)SimData[Spectrum0, Frame0, z2], (float3)SimData[Spectrum1, Frame0, z2], SpectrumBlend);
		float3 val2 = math.lerp((float3)SimData[Spectrum0, Frame1, z2], (float3)SimData[Spectrum1, Frame1, z2], SpectrumBlend);
		return math.lerp(val, val2, FrameBlend);
	}

	public float GetHeightAttenuation(float shore, float terrainHeight)
	{
		float num = Mathf.Clamp01(shore / DistanceAttenuationFactor);
		float num2 = Mathf.Clamp01(Mathf.Abs(terrainHeight) / DepthAttenuationFactor);
		return num * num2;
	}
}


using System;

[Serializable]
public struct SpectrumParameters
{
	public float scale;

	public float angle;

	public float spreadBlend;

	public float swell;

	public float alpha;

	public float peakOmega;

	public float gamma;

	public float shortWavesFade;
}


using System;
using UnityEngine;

[Serializable]
public struct SpectrumSettings
{
	[Range(0f, 1f)]
	public float scale;

	public float windSpeed;

	public float fetch;

	[Range(0f, 1f)]
	public float spreadBlend;

	[Range(0f, 1f)]
	public float swell;

	public float peakEnhancement;

	public float shortWavesFade;
}


using System;
using UnityEngine;

[Serializable]
public struct MaterialSettings
{
	public Color color;

	public Color specColor;

	public float smoothness;

	public Color waterColor;

	public Color waterExtinction;

	public float scatteringCoefficient;

	public Color subSurfaceColor;

	public float subSurfaceFalloff;

	public float subSurfaceBase;

	public float subSurfaceSun;

	public float subSurfaceAmount;

	public float foamAmount;

	public float foamScale;

	public Color foamColor;

	public Color baseFoamColor;
}


using Rust.Water5;
using UnityEngine;

[CreateAssetMenu(fileName = "New Spectrum Settings", menuName = "Water5/Spectrum Settings")]
public class OceanSpectrumSettings : ScriptableObject
{
	public OceanSettings oceanSettings;

	[Header("Deep Wave Settings")]
	public float g;

	public float beaufort;

	public float depth;

	public SpectrumSettings local;

	public SpectrumSettings swell;

	[Header("Material Settings")]
	public MaterialSettings mainlandMaterial;

	public MaterialSettings deepSeaMaterial;

	[Button("Update Spectrum")]
	public void UpdateSpectrum()
	{
		WaterSystem.Instance?.Refresh();
	}

	public MaterialSettings GetMaterial(bool inDeepSea)
	{
		if (!inDeepSea)
		{
			return mainlandMaterial;
		}
		return deepSeaMaterial;
	}
}


using System;
using Rust.Modular;
using UnityEngine;

[Serializable]
public class ConditionalObject
{
	public enum AdjacentCondition
	{
		SameInFront,
		SameBehind,
		DifferentInFront,
		DifferentBehind,
		BothDifferent,
		BothSame
	}

	public enum AdjacentMatchType
	{
		GroupOrExact,
		ExactOnly,
		GroupNotExact
	}

	public GameObject gameObject;

	public GameObject ownerGameObject;

	public ConditionalSocketSettings[] socketSettings;

	public bool restrictOnHealth;

	public float healthRestrictionMin;

	public float healthRestrictionMax;

	public bool restrictOnAdjacent;

	public AdjacentCondition adjacentRestriction;

	public AdjacentMatchType adjacentMatch;

	public bool restrictOnLockable;

	public bool lockableRestriction;

	public bool? IsActive { get; private set; }

	public ConditionalObject(GameObject conditionalGO, GameObject ownerGO, int socketsTaken)
	{
		gameObject = conditionalGO;
		ownerGameObject = ownerGO;
		socketSettings = new ConditionalSocketSettings[socketsTaken];
	}

	public void SetActive(bool active)
	{
		if (!IsActive.HasValue || active != IsActive.Value)
		{
			gameObject.SetActive(active);
			IsActive = active;
		}
	}

	public void RefreshActive()
	{
		if (IsActive.HasValue)
		{
			gameObject.SetActive(IsActive.Value);
		}
	}
}


public enum AdjacentCondition
{
	SameInFront,
	SameBehind,
	DifferentInFront,
	DifferentBehind,
	BothDifferent,
	BothSame
}


public enum AdjacentMatchType
{
	GroupOrExact,
	ExactOnly,
	GroupNotExact
}


using System;
using Rust.Modular;

[Serializable]
public class ConditionalSocketSettings
{
	public enum LocationCondition
	{
		Middle,
		Front,
		Back,
		NotMiddle,
		NotFront,
		NotBack
	}

	public bool restrictOnLocation;

	public LocationCondition locationRestriction;

	public bool restrictOnWheel;

	public ModularVehicleSocket.SocketWheelType wheelRestriction;

	public bool HasSocketRestrictions
	{
		get
		{
			if (!restrictOnLocation)
			{
				return restrictOnWheel;
			}
			return true;
		}
	}
}


public enum LocationCondition
{
	Middle,
	Front,
	Back,
	NotMiddle,
	NotFront,
	NotBack
}


using UnityEngine;
using UnityEngine.Events;

public class EnableDisableEvent : MonoBehaviour
{
	[SerializeField]
	private UnityEvent enableEvent;

	[SerializeField]
	private UnityEvent disableEvent;

	protected void OnEnable()
	{
		if (enableEvent != null)
		{
			enableEvent.Invoke();
		}
	}

	protected void OnDisable()
	{
		if (disableEvent != null)
		{
			disableEvent.Invoke();
		}
	}
}


using Rust.Modular;

public static class EngineItemTypeEx
{
	public static bool BoostsAcceleration(this EngineStorage.EngineItemTypes engineItemType)
	{
		if (engineItemType != EngineStorage.EngineItemTypes.SparkPlug)
		{
			return engineItemType == EngineStorage.EngineItemTypes.Piston;
		}
		return true;
	}

	public static bool BoostsTopSpeed(this EngineStorage.EngineItemTypes engineItemType)
	{
		if (engineItemType != EngineStorage.EngineItemTypes.Carburetor && engineItemType != 0)
		{
			return engineItemType == EngineStorage.EngineItemTypes.Piston;
		}
		return true;
	}

	public static bool BoostsFuelEconomy(this EngineStorage.EngineItemTypes engineItemType)
	{
		if (engineItemType != EngineStorage.EngineItemTypes.Carburetor)
		{
			return engineItemType == EngineStorage.EngineItemTypes.Valve;
		}
		return true;
	}
}


using System;
using System.Linq;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust.Modular;
using UnityEngine;

public class EngineStorage : StorageContainer
{
	public enum EngineItemTypes
	{
		Crankshaft,
		Carburetor,
		SparkPlug,
		Piston,
		Valve
	}

	[Header("Engine Storage")]
	public Sprite engineIcon;

	public float internalDamageMultiplier = 0.5f;

	public EngineItemTypes[] slotTypes;

	[SerializeField]
	public VehicleModuleEngineItems allEngineItems;

	[ReadOnly]
	[SerializeField]
	public int accelerationBoostSlots;

	[SerializeField]
	[ReadOnly]
	public int topSpeedBoostSlots;

	[ReadOnly]
	[SerializeField]
	public int fuelEconomyBoostSlots;

	public bool isUsable { get; set; }

	public float accelerationBoostPercent { get; set; }

	public float topSpeedBoostPercent { get; set; }

	public float fuelEconomyBoostPercent { get; set; }

	public VehicleModuleEngine GetEngineModule()
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			return ((Component)baseEntity).GetComponent<VehicleModuleEngine>();
		}
		return null;
	}

	public float GetAveragedLoadoutPercent()
	{
		return (accelerationBoostPercent + topSpeedBoostPercent + fuelEconomyBoostPercent) / 3f;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.engineStorage != null)
		{
			isUsable = info.msg.engineStorage.isUsable;
			accelerationBoostPercent = info.msg.engineStorage.accelerationBoost;
			topSpeedBoostPercent = info.msg.engineStorage.topSpeedBoost;
			fuelEconomyBoostPercent = info.msg.engineStorage.fuelEconomyBoost;
		}
		GetEngineModule()?.RefreshPerformanceStats(this);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		VehicleModuleEngine engineModule = GetEngineModule();
		if ((Object)(object)engineModule != (Object)null)
		{
			return engineModule.CanBeLooted(player);
		}
		return false;
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return GetValidSlot(item);
	}

	public int GetValidSlot(Item item)
	{
		ItemModEngineItem component = ((Component)item.info).GetComponent<ItemModEngineItem>();
		if ((Object)(object)component == (Object)null)
		{
			return -1;
		}
		EngineItemTypes engineItemType = component.engineItemType;
		for (int i = 0; i < inventorySlots; i++)
		{
			if (engineItemType == slotTypes[i] && !base.inventory.SlotTaken(item, i))
			{
				return i;
			}
		}
		return -1;
	}

	public override void OnInventoryFirstCreated(ItemContainer container)
	{
		RefreshLoadoutData();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		RefreshLoadoutData();
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (!base.ItemFilter(item, targetSlot))
		{
			return false;
		}
		if (targetSlot < 0 || targetSlot >= slotTypes.Length)
		{
			return false;
		}
		ItemModEngineItem component = ((Component)item.info).GetComponent<ItemModEngineItem>();
		if ((Object)(object)component != (Object)null && component.engineItemType == slotTypes[targetSlot])
		{
			return true;
		}
		return false;
	}

	public void RefreshLoadoutData()
	{
		if (Interface.CallHook("OnEngineLoadoutRefresh", (object)this) == null)
		{
			isUsable = base.inventory.IsFull() && base.inventory.itemList.All((Item item) => !item.isBroken);
			accelerationBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsAcceleration) / (float)accelerationBoostSlots;
			topSpeedBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsTopSpeed) / (float)topSpeedBoostSlots;
			fuelEconomyBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsFuelEconomy) / (float)fuelEconomyBoostSlots;
			SendNetworkUpdate();
			GetEngineModule()?.RefreshPerformanceStats(this);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.engineStorage = Pool.Get<EngineStorage>();
		info.msg.engineStorage.isUsable = isUsable;
		info.msg.engineStorage.accelerationBoost = accelerationBoostPercent;
		info.msg.engineStorage.topSpeedBoost = topSpeedBoostPercent;
		info.msg.engineStorage.fuelEconomyBoost = fuelEconomyBoostPercent;
	}

	public void OnModuleDamaged(float damageTaken)
	{
		if (damageTaken <= 0f)
		{
			return;
		}
		damageTaken *= internalDamageMultiplier;
		float[] array = new float[base.inventory.capacity];
		float num = 0f;
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = Random.value;
			num += array[i];
		}
		float num2 = damageTaken / num;
		for (int j = 0; j < array.Length; j++)
		{
			Item slot = base.inventory.GetSlot(j);
			if (slot != null)
			{
				slot.condition -= array[j] * num2;
			}
		}
		RefreshLoadoutData();
	}

	public void AdminAddParts(int tier)
	{
		if (base.inventory == null)
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": Null inventory on " + ((Object)this).name));
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				slot.RemoveFromContainer();
				slot.Remove();
			}
		}
		for (int j = 0; j < base.inventory.capacity; j++)
		{
			if (base.inventory.GetSlot(j) == null && allEngineItems.TryGetItem(tier, slotTypes[j], out var output))
			{
				ItemDefinition component = ((Component)output).GetComponent<ItemDefinition>();
				Item item = ItemManager.Create(component, 1, 0uL);
				if (item != null)
				{
					item.condition = component.condition.max;
					item.MoveToContainer(base.inventory, j, allowStack: false);
				}
				else
				{
					Debug.LogError((object)(((object)this).GetType().Name + ": Failed to create engine storage item."));
				}
			}
		}
	}

	public float GetContainerItemsValueFor(Func<EngineItemTypes, bool> boostConditional)
	{
		float num = 0f;
		foreach (Item item in base.inventory.itemList)
		{
			ItemModEngineItem component = ((Component)item.info).GetComponent<ItemModEngineItem>();
			if ((Object)(object)component != (Object)null && boostConditional(component.engineItemType) && !item.isBroken)
			{
				num += (float)item.amount * GetTierValue(component.tier);
			}
		}
		return num;
	}

	public float GetTierValue(int tier)
	{
		switch (tier)
		{
		case 1:
			return 0.6f;
		case 2:
			return 0.8f;
		case 3:
			return 1f;
		default:
			Debug.LogError((object)(((object)this).GetType().Name + ": Unrecognised item tier: " + tier));
			return 0f;
		}
	}
}


public enum EngineItemTypes
{
	Crankshaft,
	Carburetor,
	SparkPlug,
	Piston,
	Valve
}


using UnityEngine;

public class ModularCarAudio : GroundVehicleAudio
{
	public bool showDebug;

	[SerializeField]
	[Header("Skid")]
	private SoundDefinition skidSoundLoop;

	[SerializeField]
	private SoundDefinition skidSoundDirtLoop;

	[SerializeField]
	private SoundDefinition skidSoundSnowLoop;

	[SerializeField]
	private float skidMinSlip = 10f;

	[SerializeField]
	private float skidMaxSlip = 25f;

	[SerializeField]
	[Header("Movement & Suspension")]
	private SoundDefinition movementStartOneshot;

	[SerializeField]
	private SoundDefinition movementStopOneshot;

	[SerializeField]
	private float movementStartStopMinTimeBetweenSounds = 0.25f;

	[SerializeField]
	private SoundDefinition movementRattleLoop;

	[SerializeField]
	private float movementRattleMaxSpeed = 10f;

	[SerializeField]
	private float movementRattleMaxAngSpeed = 10f;

	[SerializeField]
	private float movementRattleIdleGain = 0.3f;

	[SerializeField]
	private SoundDefinition suspensionLurchSound;

	[SerializeField]
	private float suspensionLurchMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionLurchMinTimeBetweenSounds = 0.25f;

	[Header("Wheels")]
	[SerializeField]
	private SoundDefinition tyreRollingSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingWaterSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingGrassSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingSnowSoundDef;

	[SerializeField]
	private AnimationCurve tyreRollGainCurve;
}


using System;
using Facepunch;
using Rust;
using Rust.Modular;
using UnityEngine;

public class ModularVehicleInventory : IDisposable
{
	private ItemContainer moduleContainer;

	private ItemContainer chassisContainer;

	private readonly BaseModularVehicle vehicle;

	public ItemContainer ModuleContainer => moduleContainer;

	public ItemContainer ChassisContainer => chassisContainer;

	public ItemContainerId UID => moduleContainer.uid;

	private int TotalSockets => vehicle.TotalSockets;

	public ModularVehicleInventory(BaseModularVehicle vehicle, ItemDefinition chassisItemDef, bool giveUID)
	{
		this.vehicle = vehicle;
		moduleContainer = CreateModuleInventory(vehicle, giveUID);
		chassisContainer = CreateChassisInventory(vehicle, giveUID);
		vehicle.AssociatedItemInstance = ItemManager.Create(chassisItemDef, 1, 0uL);
		if (!Application.isLoadingSave)
		{
			vehicle.AssociatedItemInstance.MoveToContainer(chassisContainer, 0, allowStack: false);
		}
	}

	public void Dispose()
	{
		foreach (Item item in moduleContainer.itemList)
		{
			item.OnDirty -= OnModuleItemChanged;
		}
		Pool.Free<ItemContainer>(ref moduleContainer);
		Pool.Free<ItemContainer>(ref chassisContainer);
	}

	public void GiveUIDs()
	{
		moduleContainer.GiveUID();
		chassisContainer.GiveUID();
	}

	public bool SocketIsFree(int socketIndex, Item moduleItem = null)
	{
		Item item = null;
		int num = socketIndex;
		while (item == null && num >= 0)
		{
			item = moduleContainer.GetSlot(num);
			if (item != null)
			{
				if (item == moduleItem)
				{
					return true;
				}
				ItemModVehicleModule component = ((Component)item.info).GetComponent<ItemModVehicleModule>();
				return num + component.socketsTaken - 1 < socketIndex;
			}
			num--;
		}
		return true;
	}

	public bool SocketIsTaken(int socketIndex)
	{
		return !SocketIsFree(socketIndex);
	}

	public bool TryAddModuleItem(Item moduleItem, int socketIndex)
	{
		if (moduleItem == null)
		{
			Debug.LogError((object)(GetType().Name + ": Can't add null item."));
			return false;
		}
		return moduleItem.MoveToContainer(moduleContainer, socketIndex, allowStack: false);
	}

	public bool RemoveAndDestroy(Item itemToRemove)
	{
		bool result = moduleContainer.Remove(itemToRemove);
		itemToRemove.Remove();
		return result;
	}

	public int TryGetFreeSocket(int socketsTaken)
	{
		return TryGetFreeSocket(null, socketsTaken);
	}

	public int TryGetFreeSocket(Item moduleItem, int socketsTaken)
	{
		for (int i = 0; i <= TotalSockets - socketsTaken; i++)
		{
			if (SocketsAreFree(i, socketsTaken, moduleItem))
			{
				return i;
			}
		}
		return -1;
	}

	public bool SocketsAreFree(int firstIndex, int socketsTaken, Item moduleItem = null)
	{
		if (firstIndex < 0 || firstIndex + socketsTaken > TotalSockets)
		{
			return false;
		}
		for (int i = firstIndex; i < firstIndex + socketsTaken; i++)
		{
			if (!SocketIsFree(i, moduleItem))
			{
				return false;
			}
		}
		return true;
	}

	public bool TrySyncModuleInventory(BaseVehicleModule moduleEntity, int firstSocketIndex)
	{
		if (firstSocketIndex < 0)
		{
			Debug.LogError((object)$"{GetType().Name}: Invalid socket index ({firstSocketIndex}) for new module entity.", (Object)(object)((Component)vehicle).gameObject);
			return false;
		}
		Item slot = moduleContainer.GetSlot(firstSocketIndex);
		int numSocketsTaken = moduleEntity.GetNumSocketsTaken();
		if (!SocketsAreFree(firstSocketIndex, numSocketsTaken) && (slot == null || moduleEntity.AssociatedItemInstance != slot))
		{
			Debug.LogError((object)$"{GetType().Name}: Sockets are not free for new module entity. First: {firstSocketIndex} Taken: {numSocketsTaken}", (Object)(object)((Component)vehicle).gameObject);
			return false;
		}
		if (slot == null)
		{
			Item item = ItemManager.Create(moduleEntity.AssociatedItemDef, 1, 0uL);
			item.condition = moduleEntity.health;
			moduleEntity.AssociatedItemInstance = item;
			bool num = TryAddModuleItem(item, firstSocketIndex);
			if (num)
			{
				vehicle.SetUpModule(moduleEntity, item);
				return num;
			}
			item.Remove();
			return num;
		}
		return true;
	}

	private bool SocketIsUsed(Item item, int slotIndex)
	{
		return !SocketIsFree(slotIndex, item);
	}

	private ItemContainer CreateModuleInventory(BaseModularVehicle vehicle, bool giveUID)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.entityOwner = vehicle;
		itemContainer.allowedContents = ItemContainer.ContentsType.Generic;
		itemContainer.maxStackSize = 1;
		itemContainer.ServerInitialize(null, TotalSockets);
		if (giveUID)
		{
			itemContainer.GiveUID();
		}
		itemContainer.onItemAddedRemoved = OnSocketInventoryAddRemove;
		itemContainer.canAcceptItem = ItemFilter;
		itemContainer.slotIsReserved = SocketIsUsed;
		return itemContainer;
	}

	private ItemContainer CreateChassisInventory(BaseModularVehicle vehicle, bool giveUID)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.entityOwner = vehicle;
		itemContainer.allowedContents = ItemContainer.ContentsType.Generic;
		itemContainer.maxStackSize = 1;
		itemContainer.ServerInitialize(null, 1);
		if (giveUID)
		{
			itemContainer.GiveUID();
		}
		return itemContainer;
	}

	private void OnSocketInventoryAddRemove(Item moduleItem, bool added)
	{
		if (added)
		{
			ModuleItemAdded(moduleItem, moduleItem.position);
		}
		else
		{
			ModuleItemRemoved(moduleItem);
		}
	}

	private void ModuleItemAdded(Item moduleItem, int socketIndex)
	{
		ItemModVehicleModule component = ((Component)moduleItem.info).GetComponent<ItemModVehicleModule>();
		if (!Application.isLoadingSave && (Object)(object)vehicle.GetModuleForItem(moduleItem) == (Object)null)
		{
			vehicle.CreatePhysicalModuleEntity(moduleItem, component, socketIndex);
		}
		moduleItem.OnDirty += OnModuleItemChanged;
	}

	private void ModuleItemRemoved(Item moduleItem)
	{
		if (moduleItem == null)
		{
			Debug.LogError((object)"Null module item removed.", (Object)(object)((Component)vehicle).gameObject);
			return;
		}
		moduleItem.OnDirty -= OnModuleItemChanged;
		BaseVehicleModule moduleForItem = vehicle.GetModuleForItem(moduleItem);
		if ((Object)(object)moduleForItem != (Object)null)
		{
			if (!moduleForItem.IsFullySpawned())
			{
				Debug.LogError((object)"Module entity being removed before it's fully spawned. This could cause errors.", (Object)(object)((Component)vehicle).gameObject);
			}
			moduleForItem.Kill();
		}
		else
		{
			Debug.Log((object)"Couldn't find entity for this item.");
		}
	}

	private void OnModuleItemChanged(Item moduleItem)
	{
		BaseVehicleModule moduleForItem = vehicle.GetModuleForItem(moduleItem);
		if ((Object)(object)moduleForItem != (Object)null)
		{
			moduleForItem.SetHealth(moduleItem.condition);
			if (moduleForItem.FirstSocketIndex != moduleItem.position)
			{
				ModuleItemRemoved(moduleItem);
				ModuleItemAdded(moduleItem, moduleItem.position);
			}
		}
	}

	private bool ItemFilter(Item item, int targetSlot)
	{
		string failureReason;
		return vehicle.ModuleCanBeAdded(item, targetSlot, out failureReason);
	}
}


using System;
using Rust.Modular;
using UnityEngine;

[Serializable]
public class ModularVehicleSocket
{
	public enum SocketWheelType
	{
		NoWheel,
		ForwardWheel,
		BackWheel
	}

	public enum SocketLocationType
	{
		Middle,
		Front,
		Back
	}

	[SerializeField]
	private Transform socketTransform;

	[SerializeField]
	private SocketWheelType wheelType;

	[SerializeField]
	private SocketLocationType locationType;

	public Vector3 WorldPosition => socketTransform.position;

	public Quaternion WorldRotation => socketTransform.rotation;

	public SocketWheelType WheelType => wheelType;

	public SocketLocationType LocationType => locationType;

	public bool ShouldBeActive(ConditionalSocketSettings modelSettings)
	{
		bool flag = true;
		if (modelSettings.restrictOnLocation)
		{
			ConditionalSocketSettings.LocationCondition locationRestriction = modelSettings.locationRestriction;
			switch (LocationType)
			{
			case SocketLocationType.Back:
				flag = locationRestriction == ConditionalSocketSettings.LocationCondition.Back || locationRestriction == ConditionalSocketSettings.LocationCondition.NotFront || locationRestriction == ConditionalSocketSettings.LocationCondition.NotMiddle;
				break;
			case SocketLocationType.Front:
				flag = locationRestriction == ConditionalSocketSettings.LocationCondition.Front || locationRestriction == ConditionalSocketSettings.LocationCondition.NotBack || locationRestriction == ConditionalSocketSettings.LocationCondition.NotMiddle;
				break;
			case SocketLocationType.Middle:
				flag = locationRestriction == ConditionalSocketSettings.LocationCondition.Middle || locationRestriction == ConditionalSocketSettings.LocationCondition.NotFront || locationRestriction == ConditionalSocketSettings.LocationCondition.NotBack;
				break;
			}
		}
		if (flag && modelSettings.restrictOnWheel)
		{
			flag = WheelType == modelSettings.wheelRestriction;
		}
		return flag;
	}
}


public enum SocketWheelType
{
	NoWheel,
	ForwardWheel,
	BackWheel
}


public enum SocketLocationType
{
	Middle,
	Front,
	Back
}


using System.Collections.Generic;
using Facepunch;
using Rust.Modular;
using UnityEngine;

[CreateAssetMenu(fileName = "Vehicle Module Engine Items", menuName = "Scriptable Object/Vehicles/Module Engine Items")]
public class VehicleModuleEngineItems : ScriptableObject
{
	[SerializeField]
	private ItemModEngineItem[] engineItems;

	public bool TryGetItem(int tier, EngineStorage.EngineItemTypes type, out ItemModEngineItem output)
	{
		List<ItemModEngineItem> list = Pool.Get<List<ItemModEngineItem>>();
		bool result = false;
		output = null;
		ItemModEngineItem[] array = engineItems;
		foreach (ItemModEngineItem itemModEngineItem in array)
		{
			if (itemModEngineItem.tier == tier && itemModEngineItem.engineItemType == type)
			{
				list.Add(itemModEngineItem);
			}
		}
		if (list.Count > 0)
		{
			output = ListEx.GetRandom<ItemModEngineItem>(list);
			result = true;
		}
		Pool.FreeUnmanaged<ItemModEngineItem>(ref list);
		return result;
	}
}


using System;
using Rust.Modular;
using UnityEngine;

[Serializable]
public class VehicleModuleSlidingComponent
{
	[Serializable]
	public class SlidingPart
	{
		public Transform transform;

		public Vector3 openPosition;

		public Vector3 closedPosition;
	}

	public string interactionColliderName = "MyCollider";

	public BaseEntity.Flags flag_SliderOpen = BaseEntity.Flags.Reserved3;

	public float moveTime = 1f;

	public SlidingPart[] slidingParts;

	public SoundDefinition openSoundDef;

	public SoundDefinition closeSoundDef;

	private float positionPercent;

	public bool WantsOpenPos(BaseEntity parentEntity)
	{
		return parentEntity.HasFlag(flag_SliderOpen);
	}

	public void Use(BaseVehicleModule parentModule)
	{
		parentModule.SetFlag(flag_SliderOpen, !WantsOpenPos(parentModule));
	}

	public void ServerUpdateTick(BaseVehicleModule parentModule)
	{
		CheckPosition(parentModule, Time.fixedDeltaTime);
	}

	private void CheckPosition(BaseEntity parentEntity, float dt)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		bool flag = WantsOpenPos(parentEntity);
		if ((flag && positionPercent == 1f) || (!flag && positionPercent == 0f))
		{
			return;
		}
		float num = (flag ? (dt / moveTime) : (0f - dt / moveTime));
		positionPercent = Mathf.Clamp01(positionPercent + num);
		SlidingPart[] array = slidingParts;
		foreach (SlidingPart slidingPart in array)
		{
			if (!((Object)(object)slidingPart.transform == (Object)null))
			{
				slidingPart.transform.localPosition = Vector3.Lerp(slidingPart.closedPosition, slidingPart.openPosition, positionPercent);
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class SlidingPart
{
	public Transform transform;

	public Vector3 openPosition;

	public Vector3 closedPosition;
}


using Rust.Modular;
using UnityEngine;

public class ItemModEngineItem : ItemMod
{
	public EngineStorage.EngineItemTypes engineItemType;

	[Range(1f, 3f)]
	public int tier = 1;
}


using UnityEngine;

public class ItemModVehicleChassis : ItemMod, VehicleModuleInformationPanel.IVehicleModuleInfo
{
	public GameObjectRef entityPrefab;

	[Range(1f, 6f)]
	public int socketsTaken = 1;

	public int SocketsTaken => socketsTaken;
}


using UnityEngine;

public class ItemModVehicleModule : ItemMod, VehicleModuleInformationPanel.IVehicleModuleInfo
{
	public GameObjectRef entityPrefab;

	[Range(1f, 2f)]
	public int socketsTaken = 1;

	public int SocketsTaken => socketsTaken;

	public BaseVehicleModule CreateModuleEntity(BaseEntity parent, Vector3 position, Quaternion rotation)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (!entityPrefab.isValid)
		{
			Debug.LogError((object)"Invalid entity prefab for module");
			return null;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityPrefab.resourcePath, position, rotation);
		BaseVehicleModule result = null;
		if ((Object)(object)baseEntity != (Object)null)
		{
			if ((Object)(object)parent != (Object)null)
			{
				baseEntity.SetParent(parent, worldPositionStays: true);
				baseEntity.canTriggerParent = false;
			}
			baseEntity.Spawn();
			result = ((Component)baseEntity).GetComponent<BaseVehicleModule>();
		}
		return result;
	}
}


public enum Notes
{
	A,
	B,
	C,
	D,
	E,
	F,
	G
}


using System.Collections.Generic;
using Rust.Interpolation;

public interface IGenericLerpTarget<T> where T : ISnapshot<T>, new()
{
	float GetInterpolationDelay(ILerpInfo.LerpType lerpType);

	float GetInterpolationSmoothing();

	void SetFrom(T snapshot);

	T GetCurrentState();

	void DebugInterpolationState(Interpolator<T>.Segment segment, List<T> entries);
}


using System;
using Rust.Interpolation;
using UnityEngine;

public class GenericLerp<T> : IDisposable where T : ISnapshot<T>, new()
{
	private readonly Interpolator<T> interpolator;

	private IGenericLerpTarget<T> target;

	private static T snapshotPrototype = new T();

	private static float timeOffset = 0f;

	private float timeOffset0 = float.MaxValue;

	private float timeOffset1 = float.MaxValue;

	private float timeOffset2 = float.MaxValue;

	private float timeOffset3 = float.MaxValue;

	private int timeOffsetCount;

	private int TimeOffsetInterval => PositionLerp.TimeOffsetInterval;

	private float LerpTime => PositionLerp.LerpTime;

	public GenericLerp(IGenericLerpTarget<T> target, int listCount)
	{
		this.target = target;
		interpolator = new Interpolator<T>(listCount);
	}

	public void Tick()
	{
		if (target != null)
		{
			float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Generic);
			float interpolationSmoothing = target.GetInterpolationSmoothing();
			Interpolator<T>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, 0f, interpolationSmoothing, ref snapshotPrototype);
			target.SetFrom(segment.tick);
		}
	}

	public void Snapshot(T snapshot)
	{
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Generic);
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		float num = interpolationDelay + interpolationSmoothing + 1f;
		float lerpTime = LerpTime;
		timeOffset0 = Mathf.Min(timeOffset0, lerpTime - snapshot.Time);
		timeOffsetCount++;
		if (timeOffsetCount >= TimeOffsetInterval / 4)
		{
			timeOffset3 = timeOffset2;
			timeOffset2 = timeOffset1;
			timeOffset1 = timeOffset0;
			timeOffset0 = float.MaxValue;
			timeOffsetCount = 0;
		}
		timeOffset = Mathx.Min(timeOffset0, timeOffset1, timeOffset2, timeOffset3);
		lerpTime = (snapshot.Time += timeOffset);
		interpolator.Add(snapshot);
		interpolator.Cull(lerpTime - num);
	}

	public void SnapTo(T snapshot)
	{
		interpolator.Clear();
		Snapshot(snapshot);
		target.SetFrom(snapshot);
	}

	public void SnapToNow(T snapshot)
	{
		snapshot.Time = LerpTime;
		interpolator.last = snapshot;
		Wipe();
	}

	public void SnapToEnd()
	{
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Generic);
		Interpolator<T>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, 0f, 0f, ref snapshotPrototype);
		target.SetFrom(segment.tick);
		Wipe();
	}

	public void Dispose()
	{
		target = null;
		interpolator.Clear();
		timeOffset0 = float.MaxValue;
		timeOffset1 = float.MaxValue;
		timeOffset2 = float.MaxValue;
		timeOffset3 = float.MaxValue;
		timeOffsetCount = 0;
	}

	private void Wipe()
	{
		interpolator.Clear();
		timeOffsetCount = 0;
		timeOffset0 = float.MaxValue;
		timeOffset1 = float.MaxValue;
		timeOffset2 = float.MaxValue;
		timeOffset3 = float.MaxValue;
	}
}


public interface ISnapshot<T>
{
	float Time { get; set; }

	void MatchValuesTo(T entry);

	void Lerp(T prev, T next, float delta);

	T GetNew();
}


using System.Collections.Generic;
using Rust.Interpolation;
using UnityEngine;

public class Interpolator<T> where T : ISnapshot<T>, new()
{
	public struct Segment
	{
		public T tick;

		public T prev;

		public T next;
	}

	public List<T> list;

	public T last;

	public Interpolator(int listCount)
	{
		list = new List<T>(listCount);
	}

	public void Add(T tick)
	{
		last = tick;
		list.Add(tick);
	}

	public void Cull(float beforeTime)
	{
		for (int i = 0; i < list.Count; i++)
		{
			if (list[i].Time < beforeTime)
			{
				list.RemoveAt(i);
				i--;
			}
		}
	}

	public void Clear()
	{
		list.Clear();
	}

	public Segment Query(float time, float interpolation, float extrapolation, float smoothing, ref T t)
	{
		Segment result = default(Segment);
		if (list.Count == 0)
		{
			result.prev = last;
			result.next = last;
			result.tick = last;
			return result;
		}
		float num = time - interpolation - smoothing * 0.5f;
		float num2 = Mathf.Min(time - interpolation, last.Time);
		float num3 = num2 - smoothing;
		T prev = list[0];
		T val = last;
		T prev2 = list[0];
		T val2 = last;
		foreach (T item in list)
		{
			if (item.Time < num3)
			{
				prev = item;
			}
			else if (val.Time >= item.Time)
			{
				val = item;
			}
			if (item.Time < num2)
			{
				prev2 = item;
			}
			else if (val2.Time >= item.Time)
			{
				val2 = item;
			}
		}
		T @new = t.GetNew();
		if (val.Time - prev.Time <= Mathf.Epsilon)
		{
			@new.Time = num3;
			@new.MatchValuesTo(val);
		}
		else
		{
			@new.Time = num3;
			@new.Lerp(prev, val, (num3 - prev.Time) / (val.Time - prev.Time));
		}
		result.prev = @new;
		T new2 = t.GetNew();
		if (val2.Time - prev2.Time <= Mathf.Epsilon)
		{
			new2.Time = num2;
			new2.MatchValuesTo(val2);
		}
		else
		{
			new2.Time = num2;
			new2.Lerp(prev2, val2, (num2 - prev2.Time) / (val2.Time - prev2.Time));
		}
		result.next = new2;
		if (new2.Time - @new.Time <= Mathf.Epsilon)
		{
			result.prev = new2;
			result.tick = new2;
			return result;
		}
		if (num - new2.Time > extrapolation)
		{
			result.prev = new2;
			result.tick = new2;
			return result;
		}
		T new3 = t.GetNew();
		new3.Time = num;
		new3.Lerp(@new, new2, Mathf.Min(num - @new.Time, new2.Time + extrapolation - @new.Time) / (new2.Time - @new.Time));
		result.tick = new3;
		return result;
	}
}


public struct Segment
{
	public T tick;

	public T prev;

	public T next;
}


using Rust.Interpolation;
using UnityEngine;

public struct TransformSnapshot : ISnapshot<TransformSnapshot>
{
	public Vector3 pos;

	public Quaternion rot;

	public float Time { get; set; }

	public TransformSnapshot(float time, Vector3 pos, Quaternion rot)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Time = time;
		this.pos = pos;
		this.rot = rot;
	}

	public void MatchValuesTo(TransformSnapshot entry)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		pos = entry.pos;
		rot = entry.rot;
	}

	public void Lerp(TransformSnapshot prev, TransformSnapshot next, float delta)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		pos = Vector3.LerpUnclamped(prev.pos, next.pos, delta);
		rot = Quaternion.SlerpUnclamped(prev.rot, next.rot, delta);
	}

	public TransformSnapshot GetNew()
	{
		return default(TransformSnapshot);
	}
}


using Rust.Interpolation;
using UnityEngine;

public struct FloatSnapshot : ISnapshot<FloatSnapshot>
{
	public float value;

	public float Time { get; set; }

	public FloatSnapshot(float time, float value)
	{
		Time = time;
		this.value = value;
	}

	public void MatchValuesTo(FloatSnapshot entry)
	{
		value = entry.value;
	}

	public void Lerp(FloatSnapshot prev, FloatSnapshot next, float delta)
	{
		value = Mathf.Lerp(prev.value, next.value, delta);
	}

	public FloatSnapshot GetNew()
	{
		return default(FloatSnapshot);
	}
}


using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;

public static class AStarPath
{
	private static float Heuristic(IAIPathNode from, IAIPathNode to)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Distance(from.Position, to.Position);
	}

	public static bool FindPath(IAIPathNode start, IAIPathNode goal, out Stack<IAIPathNode> path, out float pathCost)
	{
		path = null;
		pathCost = -1f;
		bool result = false;
		if (start == goal)
		{
			return false;
		}
		AStarNodeList aStarNodeList = new AStarNodeList();
		HashSet<IAIPathNode> hashSet = new HashSet<IAIPathNode>();
		AStarNode item = new AStarNode(0f, Heuristic(start, goal), null, start);
		aStarNodeList.Add(item);
		while (aStarNodeList.Count > 0)
		{
			AStarNode aStarNode = aStarNodeList[0];
			aStarNodeList.RemoveAt(0);
			hashSet.Add(aStarNode.Node);
			if (aStarNode.Satisfies(goal))
			{
				path = new Stack<IAIPathNode>();
				pathCost = 0f;
				while (aStarNode.Parent != null)
				{
					pathCost += aStarNode.F;
					path.Push(aStarNode.Node);
					aStarNode = aStarNode.Parent;
				}
				if (aStarNode != null)
				{
					path.Push(aStarNode.Node);
				}
				result = true;
				break;
			}
			foreach (IAIPathNode item2 in aStarNode.Node.Linked)
			{
				if (!hashSet.Contains(item2))
				{
					float num = aStarNode.G + Heuristic(aStarNode.Node, item2);
					AStarNode aStarNodeOf = aStarNodeList.GetAStarNodeOf(item2);
					if (aStarNodeOf == null)
					{
						aStarNodeOf = new AStarNode(num, Heuristic(item2, goal), aStarNode, item2);
						aStarNodeList.Add(aStarNodeOf);
						aStarNodeList.AStarNodeSort();
					}
					else if (num < aStarNodeOf.G)
					{
						aStarNodeOf.Update(num, aStarNodeOf.H, aStarNode, item2);
						aStarNodeList.AStarNodeSort();
					}
				}
			}
		}
		return result;
	}
}


using Rust.Ai;

public class AStarNode
{
	public AStarNode Parent;

	public float G;

	public float H;

	public IAIPathNode Node;

	public float F => G + H;

	public AStarNode(float g, float h, AStarNode parent, IAIPathNode node)
	{
		G = g;
		H = h;
		Parent = parent;
		Node = node;
	}

	public void Update(float g, float h, AStarNode parent, IAIPathNode node)
	{
		G = g;
		H = h;
		Parent = parent;
		Node = node;
	}

	public bool Satisfies(IAIPathNode node)
	{
		return Node == node;
	}

	public static bool operator <(AStarNode lhs, AStarNode rhs)
	{
		return lhs.F < rhs.F;
	}

	public static bool operator >(AStarNode lhs, AStarNode rhs)
	{
		return lhs.F > rhs.F;
	}
}


using System.Collections.Generic;
using Rust.Ai;

public class AStarNodeList : List<AStarNode>
{
	private class AStarNodeComparer : IComparer<AStarNode>
	{
		int IComparer<AStarNode>.Compare(AStarNode lhs, AStarNode rhs)
		{
			if (lhs < rhs)
			{
				return -1;
			}
			if (lhs > rhs)
			{
				return 1;
			}
			return 0;
		}
	}

	private readonly AStarNodeComparer comparer = new AStarNodeComparer();

	public bool Contains(IAIPathNode n)
	{
		for (int i = 0; i < base.Count; i++)
		{
			AStarNode aStarNode = base[i];
			if (aStarNode != null && aStarNode.Node.Equals(n))
			{
				return true;
			}
		}
		return false;
	}

	public AStarNode GetAStarNodeOf(IAIPathNode n)
	{
		for (int i = 0; i < base.Count; i++)
		{
			AStarNode aStarNode = base[i];
			if (aStarNode != null && aStarNode.Node.Equals(n))
			{
				return aStarNode;
			}
		}
		return null;
	}

	public void AStarNodeSort()
	{
		Sort(comparer);
	}
}


using System.Collections.Generic;

private class AStarNodeComparer : IComparer<AStarNode>
{
	int IComparer<AStarNode>.Compare(AStarNode lhs, AStarNode rhs)
	{
		if (lhs < rhs)
		{
			return -1;
		}
		if (lhs > rhs)
		{
			return 1;
		}
		return 0;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using Rust.Ai;
using UnityEngine;

public class SimpleAIMemory
{
	public struct SeenInfo
	{
		public BaseEntity Entity;

		public Vector3 Position;

		public float Timestamp;

		public float Danger;
	}

	public static HashSet<BasePlayer> PlayerIgnoreList = new HashSet<BasePlayer>();

	[NonSerialized]
	public List<SeenInfo> All = new List<SeenInfo>();

	[NonSerialized]
	public List<BaseEntity> Players = new List<BaseEntity>();

	[NonSerialized]
	public HashSet<BaseEntity> LOS = new HashSet<BaseEntity>();

	[NonSerialized]
	public List<BaseEntity> Targets = new List<BaseEntity>();

	[NonSerialized]
	public List<BaseEntity> Threats = new List<BaseEntity>();

	[NonSerialized]
	public List<BaseEntity> Friendlies = new List<BaseEntity>();

	public void SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnNpcTargetSense", (object)owner, (object)ent, (object)brainSenses) != null)
		{
			return;
		}
		IAISenses iAISenses = owner as IAISenses;
		BasePlayer basePlayer = ent as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null && PlayerIgnoreList.Contains(basePlayer))
		{
			return;
		}
		bool flag = false;
		if (iAISenses != null && iAISenses.IsThreat(ent))
		{
			flag = true;
			if (brainSenses != null)
			{
				brainSenses.LastThreatTimestamp = Time.realtimeSinceStartup;
			}
		}
		for (int i = 0; i < All.Count; i++)
		{
			if ((Object)(object)All[i].Entity == (Object)(object)ent)
			{
				SeenInfo value = All[i];
				value.Position = ((Component)ent).transform.position;
				value.Timestamp = Mathf.Max(Time.realtimeSinceStartup, value.Timestamp);
				All[i] = value;
				return;
			}
		}
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (AI.ignoreplayers && !basePlayer.IsNpc)
			{
				return;
			}
			Players.Add(ent);
		}
		if (iAISenses != null)
		{
			if (iAISenses.IsTarget(ent))
			{
				Targets.Add(ent);
			}
			if (iAISenses.IsFriendly(ent))
			{
				Friendlies.Add(ent);
			}
			if (flag)
			{
				Threats.Add(ent);
			}
		}
		All.Add(new SeenInfo
		{
			Entity = ent,
			Position = ((Component)ent).transform.position,
			Timestamp = Time.realtimeSinceStartup
		});
	}

	public void SetLOS(BaseEntity ent, bool flag)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			if (flag)
			{
				LOS.Add(ent);
			}
			else
			{
				LOS.Remove(ent);
			}
		}
	}

	public bool IsLOS(BaseEntity ent)
	{
		return LOS.Contains(ent);
	}

	public bool IsPlayerKnown(BasePlayer player)
	{
		return Players.Contains(player);
	}

	public void Forget(float secondsOld)
	{
		for (int i = 0; i < All.Count; i++)
		{
			if (!(Time.realtimeSinceStartup - All[i].Timestamp >= secondsOld))
			{
				continue;
			}
			BaseEntity entity = All[i].Entity;
			if ((Object)(object)entity != (Object)null)
			{
				if (entity is BasePlayer)
				{
					Players.Remove(entity);
				}
				Targets.Remove(entity);
				Threats.Remove(entity);
				Friendlies.Remove(entity);
				LOS.Remove(entity);
			}
			All.RemoveAt(i);
			i--;
		}
	}

	public static void AddIgnorePlayer(BasePlayer player)
	{
		if (!PlayerIgnoreList.Contains(player))
		{
			PlayerIgnoreList.Add(player);
		}
	}

	public static void RemoveIgnorePlayer(BasePlayer player)
	{
		PlayerIgnoreList.Remove(player);
	}

	public static void ClearIgnoredPlayers()
	{
		PlayerIgnoreList.Clear();
	}

	public static string GetIgnoredPlayers()
	{
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[2] { "Name", "Steam ID" });
			foreach (BasePlayer playerIgnore in PlayerIgnoreList)
			{
				val.AddRow(new string[2]
				{
					playerIgnore.displayName,
					playerIgnore.userID.ToString()
				});
			}
			return ((object)val).ToString();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using UnityEngine;

public struct SeenInfo
{
	public BaseEntity Entity;

	public Vector3 Position;

	public float Timestamp;

	public float Danger;
}


using System.Collections;
using Rust.Ai;
using UnityEngine;

public class CoverPoint
{
	public enum CoverType
	{
		Full,
		Partial,
		None
	}

	public CoverType NormalCoverType;

	public bool IsDynamic;

	public Transform SourceTransform;

	private Vector3 _staticPosition;

	private Vector3 _staticNormal;

	public CoverPointVolume Volume { get; private set; }

	public Vector3 Position
	{
		get
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (IsDynamic && (Object)(object)SourceTransform != (Object)null)
			{
				return SourceTransform.position;
			}
			return _staticPosition;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_staticPosition = value;
		}
	}

	public Vector3 Normal
	{
		get
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (IsDynamic && (Object)(object)SourceTransform != (Object)null)
			{
				return SourceTransform.forward;
			}
			return _staticNormal;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_staticNormal = value;
		}
	}

	public BaseEntity ReservedFor { get; set; }

	public bool IsReserved => (Object)(object)ReservedFor != (Object)null;

	public bool IsCompromised { get; set; }

	public float Score { get; set; }

	public bool IsValidFor(BaseEntity entity)
	{
		if (!IsCompromised)
		{
			if (!((Object)(object)ReservedFor == (Object)null))
			{
				return (Object)(object)ReservedFor == (Object)(object)entity;
			}
			return true;
		}
		return false;
	}

	public CoverPoint(CoverPointVolume volume, float score)
	{
		Volume = volume;
		Score = score;
	}

	public void CoverIsCompromised(float cooldown)
	{
		if (!IsCompromised && (Object)(object)Volume != (Object)null)
		{
			((MonoBehaviour)Volume).StartCoroutine(StartCooldown(cooldown));
		}
	}

	private IEnumerator StartCooldown(float cooldown)
	{
		IsCompromised = true;
		yield return CoroutineEx.waitForSeconds(cooldown);
		IsCompromised = false;
	}

	public bool ProvidesCoverFromPoint(Vector3 point, float arcThreshold)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Position - point;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return Vector3.Dot(Normal, normalized) < arcThreshold;
	}
}


public enum CoverType
{
	Full,
	Partial,
	None
}


using UnityEngine;

[RequireComponent(typeof(Collider))]
public class CoverPointBlockerVolume : MonoBehaviour
{
}


using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class CoverPointVolume : MonoBehaviour, IServerComponent
{
	internal enum CoverType
	{
		None,
		Partial,
		Full
	}

	public float DefaultCoverPointScore = 1f;

	public float CoverPointRayLength = 1f;

	public LayerMask CoverLayerMask;

	public Transform BlockerGroup;

	public Transform ManualCoverPointGroup;

	[ServerVar(Help = "cover_point_sample_step_size defines the size of the steps we do horizontally for the cover point volume's cover point generation (smaller steps gives more accurate cover points, but at a higher processing cost). (default: 6.0)")]
	public static float cover_point_sample_step_size = 6f;

	[ServerVar(Help = "cover_point_sample_step_height defines the height of the steps we do vertically for the cover point volume's cover point generation (smaller steps gives more accurate cover points, but at a higher processing cost). (default: 2.0)")]
	public static float cover_point_sample_step_height = 2f;

	public readonly List<CoverPoint> CoverPoints = new List<CoverPoint>();

	private readonly List<CoverPointBlockerVolume> _coverPointBlockers = new List<CoverPointBlockerVolume>();

	private float _dynNavMeshBuildCompletionTime = -1f;

	private int _genAttempts;

	private Bounds bounds = new Bounds(Vector3.zero, Vector3.zero);

	public bool repeat => true;

	public float? ExecuteUpdate(float deltaTime, float nextInterval)
	{
		if (CoverPoints.Count == 0)
		{
			if (_dynNavMeshBuildCompletionTime < 0f)
			{
				if ((Object)(object)SingletonComponent<DynamicNavMesh>.Instance == (Object)null || !((Behaviour)SingletonComponent<DynamicNavMesh>.Instance).enabled || !SingletonComponent<DynamicNavMesh>.Instance.IsBuilding)
				{
					_dynNavMeshBuildCompletionTime = Time.realtimeSinceStartup;
				}
			}
			else if (_genAttempts < 4 && Time.realtimeSinceStartup - _dynNavMeshBuildCompletionTime > 0.25f)
			{
				GenerateCoverPoints(null);
				if (CoverPoints.Count != 0)
				{
					return null;
				}
				_dynNavMeshBuildCompletionTime = Time.realtimeSinceStartup;
				_genAttempts++;
				if (_genAttempts >= 4)
				{
					Object.Destroy((Object)(object)((Component)this).gameObject);
					return null;
				}
			}
		}
		return 1f + Random.value * 2f;
	}

	[ContextMenu("Clear Cover Points")]
	private void ClearCoverPoints()
	{
		CoverPoints.Clear();
		_coverPointBlockers.Clear();
	}

	public Bounds GetBounds()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 center = ((Bounds)(ref bounds)).center;
		if (Mathf.Approximately(((Vector3)(ref center)).sqrMagnitude, 0f))
		{
			bounds = new Bounds(((Component)this).transform.position, ((Component)this).transform.localScale);
		}
		return bounds;
	}

	[ContextMenu("Pre-Generate Cover Points")]
	public void PreGenerateCoverPoints()
	{
		GenerateCoverPoints(null);
	}

	[ContextMenu("Convert to Manual Cover Points")]
	public void ConvertToManualCoverPoints()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		foreach (CoverPoint coverPoint in CoverPoints)
		{
			ManualCoverPoint manualCoverPoint = new GameObject("MCP").AddComponent<ManualCoverPoint>();
			((Component)manualCoverPoint).transform.localPosition = Vector3.zero;
			((Component)manualCoverPoint).transform.position = coverPoint.Position;
			manualCoverPoint.Normal = coverPoint.Normal;
			manualCoverPoint.NormalCoverType = coverPoint.NormalCoverType;
			manualCoverPoint.Volume = this;
		}
	}

	public void GenerateCoverPoints(Transform coverPointGroup)
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		_ = Time.realtimeSinceStartup;
		ClearCoverPoints();
		if ((Object)(object)ManualCoverPointGroup == (Object)null)
		{
			ManualCoverPointGroup = coverPointGroup;
		}
		if ((Object)(object)ManualCoverPointGroup == (Object)null)
		{
			ManualCoverPointGroup = ((Component)this).transform;
		}
		if (ManualCoverPointGroup.childCount > 0)
		{
			ManualCoverPoint[] componentsInChildren = ((Component)ManualCoverPointGroup).GetComponentsInChildren<ManualCoverPoint>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				CoverPoint item = componentsInChildren[i].ToCoverPoint(this);
				CoverPoints.Add(item);
			}
		}
		if (_coverPointBlockers.Count == 0 && (Object)(object)BlockerGroup != (Object)null)
		{
			CoverPointBlockerVolume[] componentsInChildren2 = ((Component)BlockerGroup).GetComponentsInChildren<CoverPointBlockerVolume>();
			if (componentsInChildren2 != null && componentsInChildren2.Length != 0)
			{
				_coverPointBlockers.AddRange(componentsInChildren2);
			}
		}
		NavMeshHit val = default(NavMeshHit);
		if (CoverPoints.Count != 0 || !NavMesh.SamplePosition(((Component)this).transform.position, ref val, ((Component)this).transform.localScale.y * cover_point_sample_step_height, -1))
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		Vector3 val2 = ((Component)this).transform.lossyScale * 0.5f;
		NavMeshHit info = default(NavMeshHit);
		for (float num = position.x - val2.x + 1f; num < position.x + val2.x - 1f; num += cover_point_sample_step_size)
		{
			for (float num2 = position.z - val2.z + 1f; num2 < position.z + val2.z - 1f; num2 += cover_point_sample_step_size)
			{
				for (float num3 = position.y - val2.y; num3 < position.y + val2.y; num3 += cover_point_sample_step_height)
				{
					if (!NavMesh.FindClosestEdge(new Vector3(num, num3, num2), ref info, ((NavMeshHit)(ref val)).mask))
					{
						continue;
					}
					((NavMeshHit)(ref info)).position = new Vector3(((NavMeshHit)(ref info)).position.x, ((NavMeshHit)(ref info)).position.y + 0.5f, ((NavMeshHit)(ref info)).position.z);
					bool flag = true;
					foreach (CoverPoint coverPoint2 in CoverPoints)
					{
						Vector3 val3 = coverPoint2.Position - ((NavMeshHit)(ref info)).position;
						if (((Vector3)(ref val3)).sqrMagnitude < cover_point_sample_step_size * cover_point_sample_step_size)
						{
							flag = false;
							break;
						}
					}
					if (flag)
					{
						CoverPoint coverPoint = CalculateCoverPoint(info);
						if (coverPoint != null)
						{
							CoverPoints.Add(coverPoint);
						}
					}
				}
			}
		}
	}

	private CoverPoint CalculateCoverPoint(NavMeshHit info)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit rayHit;
		CoverType coverType = ProvidesCoverInDir(new Ray(((NavMeshHit)(ref info)).position, -((NavMeshHit)(ref info)).normal), CoverPointRayLength, out rayHit);
		if (coverType == CoverType.None)
		{
			return null;
		}
		CoverPoint coverPoint = new CoverPoint(this, DefaultCoverPointScore)
		{
			Position = ((NavMeshHit)(ref info)).position,
			Normal = -((NavMeshHit)(ref info)).normal
		};
		switch (coverType)
		{
		case CoverType.Full:
			coverPoint.NormalCoverType = CoverPoint.CoverType.Full;
			break;
		case CoverType.Partial:
			coverPoint.NormalCoverType = CoverPoint.CoverType.Partial;
			break;
		}
		return coverPoint;
	}

	internal CoverType ProvidesCoverInDir(Ray ray, float maxDistance, out RaycastHit rayHit)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		rayHit = default(RaycastHit);
		if (Vector3Ex.IsNaNOrInfinity(((Ray)(ref ray)).origin))
		{
			return CoverType.None;
		}
		if (Vector3Ex.IsNaNOrInfinity(((Ray)(ref ray)).direction))
		{
			return CoverType.None;
		}
		if (((Ray)(ref ray)).direction == Vector3.zero)
		{
			return CoverType.None;
		}
		((Ray)(ref ray)).origin = ((Ray)(ref ray)).origin + PlayerEyes.EyeOffset;
		if (Physics.Raycast(((Ray)(ref ray)).origin, ((Ray)(ref ray)).direction, ref rayHit, maxDistance, LayerMask.op_Implicit(CoverLayerMask)))
		{
			return CoverType.Full;
		}
		((Ray)(ref ray)).origin = ((Ray)(ref ray)).origin + PlayerEyes.DuckOffset;
		if (Physics.Raycast(((Ray)(ref ray)).origin, ((Ray)(ref ray)).direction, ref rayHit, maxDistance, LayerMask.op_Implicit(CoverLayerMask)))
		{
			return CoverType.Partial;
		}
		return CoverType.None;
	}

	public bool Contains(Vector3 point)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Bounds val = default(Bounds);
		((Bounds)(ref val))..ctor(((Component)this).transform.position, ((Component)this).transform.localScale);
		return ((Bounds)(ref val)).Contains(point);
	}
}


internal enum CoverType
{
	None,
	Partial,
	Full
}


using Rust.Ai;
using UnityEngine;

public class ManualCoverPoint : FacepunchBehaviour
{
	public bool IsDynamic;

	public float Score = 2f;

	public CoverPointVolume Volume;

	public Vector3 Normal;

	public CoverPoint.CoverType NormalCoverType;

	public Vector3 Position => ((Component)this).transform.position;

	public float DirectionMagnitude
	{
		get
		{
			if ((Object)(object)Volume != (Object)null)
			{
				return Volume.CoverPointRayLength;
			}
			return 1f;
		}
	}

	private void Awake()
	{
		if ((Object)(object)((Component)this).transform.parent != (Object)null)
		{
			Volume = ((Component)((Component)this).transform.parent).GetComponent<CoverPointVolume>();
		}
	}

	public CoverPoint ToCoverPoint(CoverPointVolume volume)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Volume = volume;
		if (IsDynamic)
		{
			CoverPoint obj = new CoverPoint(Volume, Score)
			{
				IsDynamic = true,
				SourceTransform = ((Component)this).transform,
				NormalCoverType = NormalCoverType
			};
			Transform transform = ((Component)this).transform;
			obj.Position = ((transform != null) ? transform.position : Vector3.zero);
			return obj;
		}
		Vector3 val = ((Component)this).transform.rotation * Normal;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return new CoverPoint(Volume, Score)
		{
			IsDynamic = false,
			Position = ((Component)this).transform.position,
			Normal = normalized,
			NormalCoverType = NormalCoverType
		};
	}
}


using System;
using Rust;
using Rust.Ai;
using UnityEngine;

[DefaultExecutionOrder(-102)]
public class AiManagedAgent : FacepunchBehaviour, IServerComponent
{
	[Tooltip("TODO: Replace with actual agent type id on the NavMeshAgent when we upgrade to 5.6.1 or above.")]
	public int AgentTypeIndex;

	[NonSerialized]
	[ReadOnly]
	public Vector2i NavmeshGridCoord;

	private bool isRegistered;

	private void OnEnable()
	{
		isRegistered = false;
		if ((Object)(object)SingletonComponent<AiManager>.Instance == (Object)null || !((Behaviour)SingletonComponent<AiManager>.Instance).enabled || AiManager.nav_disable)
		{
			((Behaviour)this).enabled = false;
		}
	}

	private void DelayedRegistration()
	{
		if (!isRegistered)
		{
			isRegistered = true;
		}
	}

	private void OnDisable()
	{
		if (!Application.isQuitting && !((Object)(object)SingletonComponent<AiManager>.Instance == (Object)null) && ((Behaviour)SingletonComponent<AiManager>.Instance).enabled)
		{
			_ = isRegistered;
		}
	}
}


using System;
using Rust;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

[DefaultExecutionOrder(-103)]
public class AiManager : SingletonComponent<AiManager>, IServerComponent
{
	[SerializeField]
	[Header("Cover System")]
	public bool UseCover = true;

	public float CoverPointVolumeCellSize = 20f;

	public float CoverPointVolumeCellHeight = 8f;

	public float CoverPointRayLength = 1f;

	public CoverPointVolume cpvPrefab;

	[SerializeField]
	public LayerMask DynamicCoverPointVolumeLayerMask;

	private WorldSpaceGrid<CoverPointVolume> coverPointVolumeGrid;

	[ServerVar(Help = "If true we'll wait for the navmesh to generate before completely starting the server. This might cause your server to hitch and lag as it generates in the background.")]
	public static bool nav_wait = true;

	[ServerVar(Help = "If set to true the navmesh won't generate.. which means Ai that uses the navmesh won't be able to move")]
	public static bool nav_disable = false;

	[ServerVar(Help = "If set to true, npcs will attempt to place themselves on the navmesh if not on a navmesh when set destination is called.")]
	public static bool setdestination_navmesh_failsafe = false;

	[ServerVar(Help = "If ai_dormant is true, any npc outside the range of players will render itself dormant and take up less resources, but wildlife won't simulate as well.")]
	public static bool ai_dormant = true;

	[ServerVar(Help = "If an agent is beyond this distance to a player, it's flagged for becoming dormant.")]
	public static float ai_to_player_distance_wakeup_range = 160f;

	[ServerVar(Help = "nav_obstacles_carve_state defines which obstacles can carve the terrain. 0 - No carving, 1 - Only player construction carves, 2 - All obstacles carve.")]
	public static int nav_obstacles_carve_state = 2;

	[ServerVar(Help = "ai_dormant_max_wakeup_per_tick defines the maximum number of dormant agents we will wake up in a single tick. (default: 30)")]
	public static int ai_dormant_max_wakeup_per_tick = 30;

	[ServerVar(Help = "ai_htn_player_tick_budget defines the maximum amount of milliseconds ticking htn player agents are allowed to consume. (default: 4 ms)")]
	public static float ai_htn_player_tick_budget = 4f;

	[ServerVar(Help = "ai_htn_player_junkpile_tick_budget defines the maximum amount of milliseconds ticking htn player junkpile agents are allowed to consume. (default: 4 ms)")]
	public static float ai_htn_player_junkpile_tick_budget = 4f;

	[ServerVar(Help = "ai_htn_animal_tick_budget defines the maximum amount of milliseconds ticking htn animal agents are allowed to consume. (default: 4 ms)")]
	public static float ai_htn_animal_tick_budget = 4f;

	[ServerVar(Help = "If ai_htn_use_agency_tick is true, the ai manager's agency system will tick htn agents at the ms budgets defined in ai_htn_player_tick_budget and ai_htn_animal_tick_budget. If it's false, each agent registers with the invoke system individually, with no frame-budget restrictions. (default: true)")]
	public static bool ai_htn_use_agency_tick = true;

	private readonly BasePlayer[] playerVicinityQuery = new BasePlayer[1];

	private readonly Func<BasePlayer, bool> filter = InterestedInPlayersOnly;

	[ServerVar(Help = "The maximum amount of nodes processed each frame in the asynchronous pathfinding process. Increasing this value will cause the paths to be processed faster, but can cause some hiccups in frame rate. Default value is 100, a good range for tuning is between 50 and 500.")]
	public static int pathfindingIterationsPerFrame
	{
		get
		{
			return NavMesh.pathfindingIterationsPerFrame;
		}
		set
		{
			NavMesh.pathfindingIterationsPerFrame = value;
		}
	}

	public bool repeat => true;

	internal void OnEnableAgency()
	{
	}

	internal void OnDisableAgency()
	{
	}

	internal void UpdateAgency()
	{
	}

	internal void OnEnableCover()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (coverPointVolumeGrid == null)
		{
			Vector3 size = TerrainMeta.Size;
			coverPointVolumeGrid = new WorldSpaceGrid<CoverPointVolume>(size.x, CoverPointVolumeCellSize, (RoundingMode)0);
		}
	}

	internal void OnDisableCover()
	{
		if (coverPointVolumeGrid != null && coverPointVolumeGrid.Cells != null)
		{
			for (int i = 0; i < coverPointVolumeGrid.Cells.Length; i++)
			{
				Object.Destroy((Object)(object)coverPointVolumeGrid.Cells[i]);
			}
		}
	}

	public static CoverPointVolume CreateNewCoverVolume(Vector3 point, Transform coverPointGroup)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<AiManager>.Instance != (Object)null && ((Behaviour)SingletonComponent<AiManager>.Instance).enabled && SingletonComponent<AiManager>.Instance.UseCover)
		{
			CoverPointVolume coverPointVolume = SingletonComponent<AiManager>.Instance.GetCoverVolumeContaining(point);
			if ((Object)(object)coverPointVolume == (Object)null)
			{
				Vector2i val = SingletonComponent<AiManager>.Instance.coverPointVolumeGrid.WorldToGridCoords(point);
				coverPointVolume = ((!((Object)(object)SingletonComponent<AiManager>.Instance.cpvPrefab != (Object)null)) ? new GameObject("CoverPointVolume").AddComponent<CoverPointVolume>() : Object.Instantiate<CoverPointVolume>(SingletonComponent<AiManager>.Instance.cpvPrefab));
				((Component)coverPointVolume).transform.localPosition = default(Vector3);
				((Component)coverPointVolume).transform.position = SingletonComponent<AiManager>.Instance.coverPointVolumeGrid.GridToWorldCoords(val) + Vector3.up * point.y;
				((Component)coverPointVolume).transform.localScale = new Vector3(SingletonComponent<AiManager>.Instance.CoverPointVolumeCellSize, SingletonComponent<AiManager>.Instance.CoverPointVolumeCellHeight, SingletonComponent<AiManager>.Instance.CoverPointVolumeCellSize);
				coverPointVolume.CoverLayerMask = SingletonComponent<AiManager>.Instance.DynamicCoverPointVolumeLayerMask;
				coverPointVolume.CoverPointRayLength = SingletonComponent<AiManager>.Instance.CoverPointRayLength;
				SingletonComponent<AiManager>.Instance.coverPointVolumeGrid[val] = coverPointVolume;
				coverPointVolume.GenerateCoverPoints(coverPointGroup);
			}
			return coverPointVolume;
		}
		return null;
	}

	public CoverPointVolume GetCoverVolumeContaining(Vector3 point)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (coverPointVolumeGrid == null)
		{
			return null;
		}
		Vector2i val = coverPointVolumeGrid.WorldToGridCoords(point);
		return coverPointVolumeGrid[val];
	}

	public void Initialize()
	{
		OnEnableAgency();
		if (UseCover)
		{
			OnEnableCover();
		}
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			OnDisableAgency();
			if (UseCover)
			{
				OnDisableCover();
			}
		}
	}

	public float? ExecuteUpdate(float deltaTime, float nextInterval)
	{
		if (nav_disable)
		{
			return nextInterval;
		}
		UpdateAgency();
		return Random.value + 1f;
	}

	private static bool InterestedInPlayersOnly(BaseEntity entity)
	{
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return false;
		}
		if (basePlayer.IsSleeping() || !basePlayer.IsConnected)
		{
			return false;
		}
		return true;
	}
}


using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;

public class Memory
{
	public struct SeenInfo
	{
		public BaseEntity Entity;

		public Vector3 Position;

		public float Timestamp;

		public float Danger;
	}

	public struct ExtendedInfo
	{
		public BaseEntity Entity;

		public Vector3 Direction;

		public float Dot;

		public float DistanceSqr;

		public byte LineOfSight;

		public float LastHurtUsTime;
	}

	public List<BaseEntity> Visible = new List<BaseEntity>();

	public List<SeenInfo> All = new List<SeenInfo>();

	public List<ExtendedInfo> AllExtended = new List<ExtendedInfo>();

	public SeenInfo Update(BaseEntity entity, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, out ExtendedInfo extendedInfo)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return Update(entity, entity.ServerPosition, score, direction, dot, distanceSqr, lineOfSight, updateLastHurtUsTime, lastHurtUsTime, out extendedInfo);
	}

	public SeenInfo Update(BaseEntity entity, Vector3 position, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, out ExtendedInfo extendedInfo)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		extendedInfo = default(ExtendedInfo);
		bool flag = false;
		for (int i = 0; i < AllExtended.Count; i++)
		{
			if ((Object)(object)AllExtended[i].Entity == (Object)(object)entity)
			{
				ExtendedInfo extendedInfo2 = AllExtended[i];
				extendedInfo2.Direction = direction;
				extendedInfo2.Dot = dot;
				extendedInfo2.DistanceSqr = distanceSqr;
				extendedInfo2.LineOfSight = lineOfSight;
				if (updateLastHurtUsTime)
				{
					extendedInfo2.LastHurtUsTime = lastHurtUsTime;
				}
				AllExtended[i] = extendedInfo2;
				extendedInfo = extendedInfo2;
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			if (updateLastHurtUsTime)
			{
				ExtendedInfo extendedInfo3 = default(ExtendedInfo);
				extendedInfo3.Entity = entity;
				extendedInfo3.Direction = direction;
				extendedInfo3.Dot = dot;
				extendedInfo3.DistanceSqr = distanceSqr;
				extendedInfo3.LineOfSight = lineOfSight;
				extendedInfo3.LastHurtUsTime = lastHurtUsTime;
				ExtendedInfo extendedInfo4 = extendedInfo3;
				AllExtended.Add(extendedInfo4);
				extendedInfo = extendedInfo4;
			}
			else
			{
				ExtendedInfo extendedInfo3 = default(ExtendedInfo);
				extendedInfo3.Entity = entity;
				extendedInfo3.Direction = direction;
				extendedInfo3.Dot = dot;
				extendedInfo3.DistanceSqr = distanceSqr;
				extendedInfo3.LineOfSight = lineOfSight;
				ExtendedInfo extendedInfo5 = extendedInfo3;
				AllExtended.Add(extendedInfo5);
				extendedInfo = extendedInfo5;
			}
		}
		return Update(entity, position, score);
	}

	public SeenInfo Update(BaseEntity ent, float danger = 0f)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return Update(ent, ent.ServerPosition, danger);
	}

	public SeenInfo Update(BaseEntity ent, Vector3 position, float danger = 0f)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < All.Count; i++)
		{
			if ((Object)(object)All[i].Entity == (Object)(object)ent)
			{
				SeenInfo seenInfo = All[i];
				seenInfo.Position = position;
				seenInfo.Timestamp = Time.realtimeSinceStartup;
				seenInfo.Danger += danger;
				All[i] = seenInfo;
				return seenInfo;
			}
		}
		SeenInfo seenInfo2 = default(SeenInfo);
		seenInfo2.Entity = ent;
		seenInfo2.Position = position;
		seenInfo2.Timestamp = Time.realtimeSinceStartup;
		seenInfo2.Danger = danger;
		SeenInfo seenInfo3 = seenInfo2;
		All.Add(seenInfo3);
		Visible.Add(ent);
		return seenInfo3;
	}

	public void AddDanger(Vector3 position, float amount)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < All.Count; i++)
		{
			if (Mathf.Approximately(All[i].Position.x, position.x) && Mathf.Approximately(All[i].Position.y, position.y) && Mathf.Approximately(All[i].Position.z, position.z))
			{
				SeenInfo value = All[i];
				value.Danger = amount;
				All[i] = value;
				return;
			}
		}
		All.Add(new SeenInfo
		{
			Position = position,
			Timestamp = Time.realtimeSinceStartup,
			Danger = amount
		});
	}

	public SeenInfo GetInfo(BaseEntity entity)
	{
		foreach (SeenInfo item in All)
		{
			if ((Object)(object)item.Entity == (Object)(object)entity)
			{
				return item;
			}
		}
		return default(SeenInfo);
	}

	public SeenInfo GetInfo(Vector3 position)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		foreach (SeenInfo item in All)
		{
			Vector3 val = item.Position - position;
			if (((Vector3)(ref val)).sqrMagnitude < 1f)
			{
				return item;
			}
		}
		return default(SeenInfo);
	}

	public ExtendedInfo GetExtendedInfo(BaseEntity entity)
	{
		foreach (ExtendedInfo item in AllExtended)
		{
			if ((Object)(object)item.Entity == (Object)(object)entity)
			{
				return item;
			}
		}
		return default(ExtendedInfo);
	}

	internal void Forget(float maxSecondsOld)
	{
		for (int i = 0; i < All.Count; i++)
		{
			float num = Time.realtimeSinceStartup - All[i].Timestamp;
			if (num > maxSecondsOld)
			{
				if ((Object)(object)All[i].Entity != (Object)null)
				{
					Visible.Remove(All[i].Entity);
					for (int j = 0; j < AllExtended.Count; j++)
					{
						if ((Object)(object)AllExtended[j].Entity == (Object)(object)All[i].Entity)
						{
							AllExtended.RemoveAt(j);
							break;
						}
					}
				}
				All.RemoveAt(i);
				i--;
			}
			else
			{
				if (!(num > 0f))
				{
					continue;
				}
				float num2 = num / maxSecondsOld;
				if (All[i].Danger > 0f)
				{
					SeenInfo value = All[i];
					value.Danger -= num2;
					All[i] = value;
				}
				if (!(num >= 1f))
				{
					continue;
				}
				for (int k = 0; k < AllExtended.Count; k++)
				{
					if ((Object)(object)AllExtended[k].Entity == (Object)(object)All[i].Entity)
					{
						ExtendedInfo value2 = AllExtended[k];
						value2.LineOfSight = 0;
						AllExtended[k] = value2;
						break;
					}
				}
			}
		}
		for (int l = 0; l < Visible.Count; l++)
		{
			if ((Object)(object)Visible[l] == (Object)null)
			{
				Visible.RemoveAt(l);
				l--;
			}
		}
		for (int m = 0; m < AllExtended.Count; m++)
		{
			if ((Object)(object)AllExtended[m].Entity == (Object)null)
			{
				AllExtended.RemoveAt(m);
				m--;
			}
		}
	}
}


using UnityEngine;

public struct SeenInfo
{
	public BaseEntity Entity;

	public Vector3 Position;

	public float Timestamp;

	public float Danger;
}


using UnityEngine;

public struct ExtendedInfo
{
	public BaseEntity Entity;

	public Vector3 Direction;

	public float Dot;

	public float DistanceSqr;

	public byte LineOfSight;

	public float LastHurtUsTime;
}


using UnityEngine;

public class NavmeshPrefabInstantiator : MonoBehaviour
{
	public GameObjectRef NavmeshPrefab;

	private void Start()
	{
		if (NavmeshPrefab != null)
		{
			NavmeshPrefab.Instantiate(((Component)this).transform).SetActive(true);
			Object.Destroy((Object)(object)this);
		}
	}
}


using ConVar;
using Rust.Ai;
using UnityEngine;

public class ScientistSpawner : SpawnGroup
{
	[Header("Scientist Spawner")]
	public bool Mobile = true;

	public bool NeverMove;

	public bool SpawnHostile;

	public bool OnlyAggroMarkedTargets = true;

	public bool IsPeacekeeper = true;

	public bool IsBandit;

	public bool IsMilitaryTunnelLab;

	public WaypointSet Waypoints;

	public Transform[] LookAtInterestPointsStationary;

	public Vector2 RadioEffectRepeatRange = new Vector2(10f, 15f);

	public Model Model;

	[SerializeField]
	private AiLocationManager _mgr;

	private float _nextForcedRespawn = float.PositiveInfinity;

	private bool _lastSpawnCallHadAliveMembers;

	private bool _lastSpawnCallHadMaxAliveMembers;

	protected override void Spawn(int numToSpawn)
	{
		if (!AI.npc_enable)
		{
			return;
		}
		if (base.currentPopulation == maxPopulation)
		{
			_lastSpawnCallHadMaxAliveMembers = true;
			_lastSpawnCallHadAliveMembers = true;
			return;
		}
		if (_lastSpawnCallHadMaxAliveMembers)
		{
			_nextForcedRespawn = Time.time + 2200f;
		}
		if (Time.time < _nextForcedRespawn)
		{
			if (base.currentPopulation == 0 && _lastSpawnCallHadAliveMembers)
			{
				_lastSpawnCallHadMaxAliveMembers = false;
				_lastSpawnCallHadAliveMembers = false;
				return;
			}
			if (base.currentPopulation > 0)
			{
				_lastSpawnCallHadMaxAliveMembers = false;
				_lastSpawnCallHadAliveMembers = base.currentPopulation > 0;
				return;
			}
		}
		_lastSpawnCallHadMaxAliveMembers = false;
		_lastSpawnCallHadAliveMembers = base.currentPopulation > 0;
		base.Spawn(numToSpawn);
	}

	protected override void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
	{
	}

	protected override void OnDrawGizmos()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		base.OnDrawGizmos();
		if (LookAtInterestPointsStationary == null || LookAtInterestPointsStationary.Length == 0)
		{
			return;
		}
		Gizmos.color = Color.magenta - new Color(0f, 0f, 0f, 0.5f);
		Transform[] lookAtInterestPointsStationary = LookAtInterestPointsStationary;
		foreach (Transform val in lookAtInterestPointsStationary)
		{
			if ((Object)(object)val != (Object)null)
			{
				Gizmos.DrawSphere(val.position, 0.1f);
				Gizmos.DrawLine(((Component)this).transform.position, val.position);
			}
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class AiLocationManager : FacepunchBehaviour, IServerComponent
{
	public static List<AiLocationManager> Managers = new List<AiLocationManager>();

	[SerializeField]
	public AiLocationSpawner MainSpawner;

	[SerializeField]
	public AiLocationSpawner.SquadSpawnerLocation LocationWhenMainSpawnerIsNull = AiLocationSpawner.SquadSpawnerLocation.None;

	public Transform CoverPointGroup;

	public Transform PatrolPointGroup;

	public CoverPointVolume DynamicCoverPointVolume;

	public bool SnapCoverPointsToGround;

	private List<PathInterestNode> patrolPoints;

	public AiLocationSpawner.SquadSpawnerLocation LocationType
	{
		get
		{
			if ((Object)(object)MainSpawner != (Object)null)
			{
				return MainSpawner.Location;
			}
			return LocationWhenMainSpawnerIsNull;
		}
	}

	private void Awake()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Managers.Add(this);
		if (!SnapCoverPointsToGround)
		{
			return;
		}
		AICoverPoint[] componentsInChildren = ((Component)CoverPointGroup).GetComponentsInChildren<AICoverPoint>();
		NavMeshHit val = default(NavMeshHit);
		foreach (AICoverPoint aICoverPoint in componentsInChildren)
		{
			if (NavMesh.SamplePosition(((Component)aICoverPoint).transform.position, ref val, 4f, -1))
			{
				((Component)aICoverPoint).transform.position = ((NavMeshHit)(ref val)).position;
			}
		}
	}

	private void OnDestroy()
	{
		Managers.Remove(this);
	}

	public PathInterestNode GetFirstPatrolPointInRange(Vector3 from, float minRange = 10f, float maxRange = 100f)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)PatrolPointGroup == (Object)null)
		{
			return null;
		}
		if (patrolPoints == null)
		{
			patrolPoints = new List<PathInterestNode>(((Component)PatrolPointGroup).GetComponentsInChildren<PathInterestNode>());
		}
		if (patrolPoints.Count == 0)
		{
			return null;
		}
		float num = minRange * minRange;
		float num2 = maxRange * maxRange;
		foreach (PathInterestNode patrolPoint in patrolPoints)
		{
			Vector3 val = ((Component)patrolPoint).transform.position - from;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			if (sqrMagnitude >= num && sqrMagnitude <= num2)
			{
				return patrolPoint;
			}
		}
		return null;
	}

	public PathInterestNode GetRandomPatrolPointInRange(Vector3 from, float minRange = 10f, float maxRange = 100f, PathInterestNode currentPatrolPoint = null)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)PatrolPointGroup == (Object)null)
		{
			return null;
		}
		if (patrolPoints == null)
		{
			patrolPoints = new List<PathInterestNode>(((Component)PatrolPointGroup).GetComponentsInChildren<PathInterestNode>());
		}
		if (patrolPoints.Count == 0)
		{
			return null;
		}
		float num = minRange * minRange;
		float num2 = maxRange * maxRange;
		for (int i = 0; i < 20; i++)
		{
			PathInterestNode pathInterestNode = patrolPoints[Random.Range(0, patrolPoints.Count)];
			if (Time.time < pathInterestNode.NextVisitTime)
			{
				if ((Object)(object)pathInterestNode == (Object)(object)currentPatrolPoint)
				{
					return null;
				}
				continue;
			}
			Vector3 val = ((Component)pathInterestNode).transform.position - from;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			if (sqrMagnitude >= num && sqrMagnitude <= num2)
			{
				pathInterestNode.NextVisitTime = Time.time + AI.npc_patrol_point_cooldown;
				return pathInterestNode;
			}
		}
		return null;
	}
}


using ConVar;
using Rust.Ai;
using UnityEngine;

public class AiLocationSpawner : SpawnGroup
{
	public enum SquadSpawnerLocation
	{
		MilitaryTunnels,
		JunkpileA,
		JunkpileG,
		CH47,
		None,
		Compound,
		BanditTown,
		CargoShip
	}

	public SquadSpawnerLocation Location;

	public AiLocationManager Manager;

	public JunkPile Junkpile;

	public bool IsMainSpawner = true;

	public float chance = 1f;

	private int defaultMaxPopulation;

	private int defaultNumToSpawnPerTickMax;

	private int defaultNumToSpawnPerTickMin;

	public override void SpawnInitial()
	{
		if (IsMainSpawner)
		{
			if (Location == SquadSpawnerLocation.MilitaryTunnels)
			{
				maxPopulation = AI.npc_max_population_military_tunnels;
				numToSpawnPerTickMax = AI.npc_spawn_per_tick_max_military_tunnels;
				numToSpawnPerTickMin = AI.npc_spawn_per_tick_min_military_tunnels;
				respawnDelayMax = AI.npc_respawn_delay_max_military_tunnels;
				respawnDelayMin = AI.npc_respawn_delay_min_military_tunnels;
			}
			else
			{
				defaultMaxPopulation = maxPopulation;
				defaultNumToSpawnPerTickMax = numToSpawnPerTickMax;
				defaultNumToSpawnPerTickMin = numToSpawnPerTickMin;
			}
		}
		else
		{
			defaultMaxPopulation = maxPopulation;
			defaultNumToSpawnPerTickMax = numToSpawnPerTickMax;
			defaultNumToSpawnPerTickMin = numToSpawnPerTickMin;
		}
		base.SpawnInitial();
	}

	protected override void Spawn(int numToSpawn)
	{
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.npc_enable)
		{
			maxPopulation = 0;
			numToSpawnPerTickMax = 0;
			numToSpawnPerTickMin = 0;
			return;
		}
		if (numToSpawn == 0)
		{
			if (IsMainSpawner)
			{
				if (Location == SquadSpawnerLocation.MilitaryTunnels)
				{
					maxPopulation = AI.npc_max_population_military_tunnels;
					numToSpawnPerTickMax = AI.npc_spawn_per_tick_max_military_tunnels;
					numToSpawnPerTickMin = AI.npc_spawn_per_tick_min_military_tunnels;
					numToSpawn = Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1);
				}
				else
				{
					maxPopulation = defaultMaxPopulation;
					numToSpawnPerTickMax = defaultNumToSpawnPerTickMax;
					numToSpawnPerTickMin = defaultNumToSpawnPerTickMin;
					numToSpawn = Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1);
				}
			}
			else
			{
				maxPopulation = defaultMaxPopulation;
				numToSpawnPerTickMax = defaultNumToSpawnPerTickMax;
				numToSpawnPerTickMin = defaultNumToSpawnPerTickMin;
				numToSpawn = Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1);
			}
		}
		float npc_junkpilespawn_chance = chance;
		switch (Location)
		{
		case SquadSpawnerLocation.JunkpileA:
			npc_junkpilespawn_chance = AI.npc_junkpilespawn_chance;
			break;
		case SquadSpawnerLocation.JunkpileG:
			npc_junkpilespawn_chance = AI.npc_junkpilespawn_chance;
			break;
		}
		if (numToSpawn == 0 || Random.value > npc_junkpilespawn_chance)
		{
			return;
		}
		numToSpawn = Mathf.Min(numToSpawn, maxPopulation - base.currentPopulation);
		for (int i = 0; i < numToSpawn; i++)
		{
			GameObjectRef prefab = GetPrefab();
			Vector3 pos;
			Quaternion rot;
			BaseSpawnPoint spawnPoint = GetSpawnPoint(prefab, out pos, out rot);
			if (Object.op_Implicit((Object)(object)spawnPoint))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(prefab.resourcePath, pos, rot);
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					baseEntity.Spawn();
					SpawnPointInstance spawnPointInstance = ((Component)baseEntity).gameObject.AddComponent<SpawnPointInstance>();
					spawnPointInstance.parentSpawnPointUser = this;
					spawnPointInstance.parentSpawnPoint = spawnPoint;
					spawnPointInstance.Entity = baseEntity;
					spawnPointInstance.Notify();
				}
			}
		}
	}

	protected override BaseSpawnPoint GetSpawnPoint(GameObjectRef prefabRef, out Vector3 pos, out Quaternion rot)
	{
		return base.GetSpawnPoint(prefabRef, out pos, out rot);
	}
}


public enum SquadSpawnerLocation
{
	MilitaryTunnels,
	JunkpileA,
	JunkpileG,
	CH47,
	None,
	Compound,
	BanditTown,
	CargoShip
}


using System;
using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;

public class WaypointSet : MonoBehaviour, IServerComponent
{
	public enum NavModes
	{
		Loop,
		PingPong
	}

	[Serializable]
	public struct Waypoint
	{
		public Transform Transform;

		public float WaitTime;

		public Transform[] LookatPoints;

		[NonSerialized]
		public bool IsOccupied;
	}

	[SerializeField]
	private List<Waypoint> _points = new List<Waypoint>();

	[SerializeField]
	private NavModes navMode;

	public List<Waypoint> Points
	{
		get
		{
			return _points;
		}
		set
		{
			_points = value;
		}
	}

	public NavModes NavMode => navMode;

	private void OnDrawGizmos()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Points.Count; i++)
		{
			Transform transform = Points[i].Transform;
			if ((Object)(object)transform != (Object)null)
			{
				if (Points[i].IsOccupied)
				{
					Gizmos.color = Color.red;
				}
				else
				{
					Gizmos.color = Color.cyan;
				}
				Gizmos.DrawSphere(transform.position, 0.25f);
				Gizmos.color = Color.cyan;
				if (i + 1 < Points.Count)
				{
					Gizmos.DrawLine(transform.position, Points[i + 1].Transform.position);
				}
				else if (NavMode == NavModes.Loop)
				{
					Gizmos.DrawLine(transform.position, Points[0].Transform.position);
				}
				Gizmos.color = Color.magenta - new Color(0f, 0f, 0f, 0.5f);
				Transform[] lookatPoints = Points[i].LookatPoints;
				foreach (Transform val in lookatPoints)
				{
					Gizmos.DrawSphere(val.position, 0.1f);
					Gizmos.DrawLine(transform.position, val.position);
				}
			}
		}
	}
}


public enum NavModes
{
	Loop,
	PingPong
}


using System;
using UnityEngine;

[Serializable]
public struct Waypoint
{
	public Transform Transform;

	public float WaitTime;

	public Transform[] LookatPoints;

	[NonSerialized]
	public bool IsOccupied;
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using Rust.Ai.HTN.ScientistJunkpile;
using UnityEngine;

public class ScientistJunkpileSpawner : MonoBehaviour, IServerComponent, ISpawnGroup
{
	public enum JunkpileType
	{
		A,
		B,
		C,
		D,
		E,
		F,
		G
	}

	public GameObjectRef ScientistPrefab;

	[NonSerialized]
	public List<BaseCombatEntity> Spawned = new List<BaseCombatEntity>();

	[NonSerialized]
	public BaseSpawnPoint[] SpawnPoints;

	public int MaxPopulation = 1;

	public bool InitialSpawn;

	public float MinRespawnTimeMinutes = 120f;

	public float MaxRespawnTimeMinutes = 120f;

	public float MovementRadius = -1f;

	public bool ReducedLongRangeAccuracy;

	public JunkpileType SpawnType;

	[Range(0f, 1f)]
	public float SpawnBaseChance = 1f;

	private float nextRespawnTime;

	private bool pendingRespawn;

	public int currentPopulation => Spawned.Count;

	private void Awake()
	{
		SpawnPoints = ((Component)this).GetComponentsInChildren<BaseSpawnPoint>();
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Add((ISpawnGroup)this);
		}
	}

	protected void OnDestroy()
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Remove((ISpawnGroup)this);
		}
		else if (AI.logIssues)
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": SpawnHandler instance not found."));
		}
	}

	public void Fill()
	{
		DoRespawn();
	}

	public void Clear()
	{
		if (Spawned == null)
		{
			return;
		}
		foreach (BaseCombatEntity item in Spawned)
		{
			if (!((Object)(object)item == (Object)null) && !((Object)(object)((Component)item).gameObject == (Object)null) && !((Object)(object)((Component)item).transform == (Object)null))
			{
				BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					baseEntity.Kill();
				}
			}
		}
		Spawned.Clear();
	}

	public void SpawnInitial()
	{
		nextRespawnTime = Time.time + Random.Range(3f, 4f);
		pendingRespawn = true;
	}

	public void SpawnRepeating()
	{
		CheckIfRespawnNeeded();
	}

	public void CheckIfRespawnNeeded()
	{
		if (!pendingRespawn)
		{
			if (Spawned == null || Spawned.Count == 0 || IsAllSpawnedDead())
			{
				ScheduleRespawn();
			}
		}
		else if ((Spawned == null || Spawned.Count == 0 || IsAllSpawnedDead()) && Time.time >= nextRespawnTime)
		{
			DoRespawn();
		}
	}

	private bool IsAllSpawnedDead()
	{
		int num = 0;
		while (num < Spawned.Count)
		{
			BaseCombatEntity baseCombatEntity = Spawned[num];
			if ((Object)(object)baseCombatEntity == (Object)null || (Object)(object)((Component)baseCombatEntity).transform == (Object)null || baseCombatEntity.IsDestroyed || baseCombatEntity.IsDead())
			{
				Spawned.RemoveAt(num);
				num--;
				num++;
				continue;
			}
			return false;
		}
		return true;
	}

	public void ScheduleRespawn()
	{
		nextRespawnTime = Time.time + Random.Range(MinRespawnTimeMinutes, MaxRespawnTimeMinutes) * 60f;
		pendingRespawn = true;
	}

	public void DoRespawn()
	{
		if (!Application.isLoading && !Application.isLoadingSave)
		{
			SpawnScientist();
		}
		pendingRespawn = false;
	}

	public void SpawnScientist()
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.npc_enable || Spawned == null || Spawned.Count >= MaxPopulation)
		{
			return;
		}
		float num = SpawnBaseChance;
		switch (SpawnType)
		{
		case JunkpileType.A:
			num = AI.npc_junkpilespawn_chance;
			break;
		case JunkpileType.G:
			num = AI.npc_junkpilespawn_chance;
			break;
		}
		if (Random.value > num)
		{
			return;
		}
		int num2 = MaxPopulation - Spawned.Count;
		for (int i = 0; i < num2; i++)
		{
			if (!((Object)(object)GetSpawnPoint(out var pos, out var rot) == (Object)null))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(ScientistPrefab.resourcePath, pos, rot, startActive: false);
				if (!((Object)(object)baseEntity != (Object)null))
				{
					break;
				}
				baseEntity.enableSaving = false;
				((Component)baseEntity).gameObject.AwakeFromInstantiate();
				baseEntity.Spawn();
				Spawned.Add((BaseCombatEntity)baseEntity);
			}
		}
	}

	private BaseSpawnPoint GetSpawnPoint(out Vector3 pos, out Quaternion rot)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		BaseSpawnPoint baseSpawnPoint = null;
		pos = Vector3.zero;
		rot = Quaternion.identity;
		int num = Random.Range(0, SpawnPoints.Length);
		for (int i = 0; i < SpawnPoints.Length; i++)
		{
			baseSpawnPoint = SpawnPoints[(num + i) % SpawnPoints.Length];
			if (Object.op_Implicit((Object)(object)baseSpawnPoint) && ((Component)baseSpawnPoint).gameObject.activeSelf)
			{
				break;
			}
		}
		if (Object.op_Implicit((Object)(object)baseSpawnPoint))
		{
			baseSpawnPoint.GetLocation(out pos, out rot);
		}
		return baseSpawnPoint;
	}
}


public enum JunkpileType
{
	A,
	B,
	C,
	D,
	E,
	F,
	G
}


using System;
using FIMSpace.FLook;
using FIMSpace.FSpine;
using FIMSpace.FTail;
using Network;
using Rust.Ai.Gen2;
using UnityEngine;

public class NPCAnimController : EntityComponent<BaseEntity>, IClientComponent
{
	public enum AnimatorType
	{
		NoStrafe,
		Strafe
	}

	[SerializeField]
	private string animationsPrefix = "wolf_";

	[SerializeField]
	private string[] animationBlacklist = new string[4] { "prowl", "walk", "trot", "run" };

	[ClientVar(ClientAdmin = true)]
	public static float lookInterpSpeed = 3f;

	[ClientVar(ClientAdmin = true)]
	public static float spineInterpSpeed = 3f;

	[SerializeField]
	private AnimatorType animatorType;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private FSpineAnimator spineAnimator;

	[SerializeField]
	private FLookAnimator lookAnimator;

	[SerializeField]
	private TailAnimator2 tailAnimator;

	[SerializeField]
	private float maxPitchToConformToSlope = 30f;

	[SerializeField]
	private bool onlyConformPitchToSlope = true;

	[SerializeField]
	private float posInterpSpeed = 10f;

	[SerializeField]
	private float rotInterpSpeed = 2f;

	[SerializeField]
	private float snapVerticalOffset;

	[SerializeField]
	public bool enableLookAtDuringLocomotion = true;

	[SerializeField]
	public bool enableLookAtDuringProwl = true;

	[SerializeField]
	private AnimationClip[] animationsWithLookAt;

	[SerializeField]
	private AnimationClip[] animationsWithSpineDeform;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("NPCAnimController.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}
}


public enum AnimatorType
{
	NoStrafe,
	Strafe
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Rust.Ai.Gen2;
using UnityEngine;

public class NpcBarkComponent : EntityComponent<BaseEntity>
{
	public NPCVoicelinesDatabase VoicelinesDatabase;

	private const float maxConversationDistance = 50f;

	private SenseComponent _senseComponent;

	private NpcZoneComponent _npcZoneComponent;

	private double? _lastTickTime;

	private float timeBeforeConversationResponse;

	private NPCVoiceline? conversationResponse;

	private SenseComponent SenseComponent => _senseComponent ?? (_senseComponent = ((Component)base.baseEntity).GetComponent<SenseComponent>());

	private NpcZoneComponent NpcZoneComponent => _npcZoneComponent ?? (_npcZoneComponent = ((Component)base.baseEntity).GetComponent<NpcZoneComponent>());

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("NpcBarkComponent.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool PlayVoicelineFromCategory(ENPCVoicelineCategory category, BaseEntity targetAlly = null)
	{
		TimeWarning val = TimeWarning.New("NpcBarkComponent.PlayVoicelineFromCategory", 0);
		try
		{
			if (!AI.npcBarksEnabled)
			{
				return false;
			}
			if (!VoicelinesDatabase.GetVoicelinesByCategory(category, out var voicelinesInCategory) || voicelinesInCategory.Count == 0)
			{
				return false;
			}
			PooledList<int> val2 = Pool.Get<PooledList<int>>();
			try
			{
				for (int i = 0; i < voicelinesInCategory.Count; i++)
				{
					((List<int>)(object)val2).Add(i);
				}
				ListEx.Shuffle<int>((List<int>)(object)val2, (uint)Environment.TickCount);
				NPCVoiceline? nPCVoiceline = null;
				int num = 0;
				foreach (int item in (List<int>)(object)val2)
				{
					NPCVoiceline nPCVoiceline2 = voicelinesInCategory[item];
					if (nPCVoiceline2.importance == ENpcVoicelineImportance.Conversation)
					{
						num++;
					}
					else if (!nPCVoiceline.HasValue && SingletonComponent<NpcBarkManager>.Instance.CanPlay(base.baseEntity, nPCVoiceline2))
					{
						nPCVoiceline = nPCVoiceline2;
					}
				}
				if (!nPCVoiceline.HasValue)
				{
					return false;
				}
				if (num == 0 && !nPCVoiceline.Value.allowOkResponse)
				{
					return PlayVoiceline(nPCVoiceline.Value);
				}
				NPCVoiceline? nPCVoiceline3 = null;
				if (num > 0)
				{
					ListEx.Shuffle<int>((List<int>)(object)val2, (uint)Environment.TickCount);
					foreach (int item2 in (List<int>)(object)val2)
					{
						NPCVoiceline nPCVoiceline4 = voicelinesInCategory[item2];
						if (nPCVoiceline4.importance == ENpcVoicelineImportance.Conversation && SingletonComponent<NpcBarkManager>.Instance.CanPlay(base.baseEntity, nPCVoiceline4))
						{
							nPCVoiceline3 = nPCVoiceline4;
							break;
						}
					}
				}
				if (!nPCVoiceline3.HasValue)
				{
					if (!VoicelinesDatabase.GetVoicelinesByCategory(ENPCVoicelineCategory.Ok, out voicelinesInCategory))
					{
						return false;
					}
					((List<int>)(object)val2).Clear();
					for (int j = 0; j < voicelinesInCategory.Count; j++)
					{
						((List<int>)(object)val2).Add(j);
					}
					ListEx.Shuffle<int>((List<int>)(object)val2, (uint)Environment.TickCount);
					foreach (int item3 in (List<int>)(object)val2)
					{
						NPCVoiceline nPCVoiceline5 = voicelinesInCategory[item3];
						if (SingletonComponent<NpcBarkManager>.Instance.CanPlay(base.baseEntity, nPCVoiceline5))
						{
							nPCVoiceline3 = nPCVoiceline5;
							break;
						}
					}
				}
				if (!nPCVoiceline3.HasValue)
				{
					return false;
				}
				return PlayConversation(nPCVoiceline.Value, nPCVoiceline3.Value, targetAlly);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool PlayConversation(NPCVoiceline starter, NPCVoiceline response, BaseEntity targetAlly = null)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.npcBarksEnabled)
		{
			return false;
		}
		if ((Object)(object)targetAlly == (Object)null && !NpcPushHelper.FindBestPartner(((Component)base.baseEntity).transform.position, SenseComponent, NpcZoneComponent, out targetAlly, 50f))
		{
			return false;
		}
		if ((Object)(object)targetAlly == (Object)null)
		{
			Debug.LogError((object)$"NpcBarkComponent.PlayConversation - {base.baseEntity} found invalid ally for conversation response: {starter.text} > {response.text}");
			return false;
		}
		NpcBarkComponent npcBarkComponent = default(NpcBarkComponent);
		if (!((Component)targetAlly).TryGetComponent<NpcBarkComponent>(ref npcBarkComponent))
		{
			Debug.LogError((object)$"NpcBarkComponent.PlayConversation - {base.baseEntity}'s ally {targetAlly} has no NpcBarkComponent to play conversation response after playing starter: {starter.text} > {response.text}");
			return false;
		}
		if (starter.duration == 0f)
		{
			Debug.LogError((object)$"NpcBarkComponent.PlayConversation - {base.baseEntity} is trying to say something with a duration of 0: {starter.text}");
			return false;
		}
		if (!starter.otherNpcShouldSpeakFirst)
		{
			if (!PlayVoiceline(starter))
			{
				return false;
			}
			npcBarkComponent.PlayConversationResponse(response, starter.duration + 0.25f);
			return true;
		}
		if (!npcBarkComponent.PlayVoiceline(starter))
		{
			return false;
		}
		PlayConversationResponse(response, starter.duration + 0.25f);
		return true;
	}

	private bool PlayVoiceline(NPCVoiceline voiceline, bool setCooldown = true)
	{
		if (!SingletonComponent<NpcBarkManager>.Instance.CanPlay(base.baseEntity, voiceline))
		{
			return false;
		}
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayBark"), voiceline.index);
		if (setCooldown)
		{
			SingletonComponent<NpcBarkManager>.Instance.OnPlay(base.baseEntity, voiceline);
		}
		return true;
	}

	private void PlayConversationResponse(NPCVoiceline voiceline, float delay)
	{
		conversationResponse = voiceline;
		timeBeforeConversationResponse = delay;
	}

	public void Tick()
	{
		TimeWarning val = TimeWarning.New("NpcBarkComponent.Tick", 0);
		try
		{
			if (!AI.npcBarksEnabled)
			{
				return;
			}
			float num = (float)(Time.timeAsDouble - LastTickTime);
			LastTickTime = Time.timeAsDouble;
			if (conversationResponse.HasValue)
			{
				timeBeforeConversationResponse -= num;
				if (!(timeBeforeConversationResponse > 0f))
				{
					PlayVoiceline(conversationResponse.Value, setCooldown: false);
					timeBeforeConversationResponse = 0f;
					conversationResponse = null;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Network;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class TigerFSM : FSMComponent
{
	public State_PlayRandomAnimation randomIdle = new State_PlayRandomAnimation();

	public State_Roam roam = new State_Roam();

	public State_CircleDynamic approach = new State_CircleDynamic();

	public State_FastSneak fastSneak = new State_FastSneak();

	public State_Roar roar = new State_Roar();

	public State_Growl growlFire = new State_Growl();

	public State_MoveToTarget charge = new State_MoveToTarget();

	public State_Observe observe = new State_Observe();

	public State_DeadlyAttack attack = new State_DeadlyAttack();

	public State_Circle comboCircle = new State_Circle();

	public State_HurtWithAdditive hurt = new State_HurtWithAdditive();

	public State_FleeToHide flee = new State_FleeToHide();

	public State_Flee permaFlee = new State_Flee();

	public State_Dead dead = new State_Dead();

	public State_ApproachFood approachFood = new State_ApproachFood();

	public State_EatFood eatFood = new State_EatFood();

	public State_PlayAnimLoop sleep = new State_PlayAnimLoop();

	public State_AttackUnreachableWarped attackUnreachable = new State_AttackUnreachableWarped();

	public State_DragCorpse dragCorpse = new State_DragCorpse();

	private Trans_Triggerable_HitInfo HurtTrans;

	private Trans_Triggerable_HitInfo StaggerTrans;

	private Trans_Triggerable_HitInfo DeathTrans;

	[ServerVar(Help = "The range at which the tiger will charge instead of fleeing if aimed at")]
	public static float chargeRange = 20f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TigerFSM.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Expected O, but got Unknown
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Expected O, but got Unknown
		if (base.baseEntity.isServer)
		{
			State_Nothing state_Nothing = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			new State_MoveToTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Walk,
				decelerationOverride = 6f,
				Name = "Step forward"
			};
			State_MoveToLastReachablePointNearTarget state_MoveToLastReachablePointNearTarget = new State_MoveToLastReachablePointNearTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Jog,
				succeedWhenDestinationIsReached = true,
				Name = "Go to last destination slow"
			};
			State_MoveToLastReachablePointNearTarget state_MoveToLastReachablePointNearTarget2 = new State_MoveToLastReachablePointNearTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Sprint,
				succeedWhenDestinationIsReached = true,
				Name = "Go to last destination"
			};
			DeathTrans = new Trans_Triggerable_HitInfo();
			HurtTrans = new Trans_Triggerable_HitInfo();
			StaggerTrans = new Trans_Triggerable_HitInfo();
			Trans_Triggerable FireMeleeTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<SenseComponent>().onFireMelee.AddListener((UnityAction)delegate
			{
				FireMeleeTrans.Trigger();
			});
			Trans_Triggerable EncounterEndTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<NPCEncounterTimer>().onShouldGiveUp.AddListener((UnityAction)delegate
			{
				EncounterEndTrans.Trigger();
			});
			State_Nothing obj = new State_Nothing
			{
				Name = "Root"
			};
			State_Nothing state_Nothing2 = new State_Nothing
			{
				Name = "Alive"
			};
			State_Nothing state_Nothing3 = new State_Nothing
			{
				Name = "OnNavmesh"
			};
			State_Nothing state_Nothing4 = new State_Nothing
			{
				Name = "Food"
			};
			State_Nothing state_Nothing5 = new State_Nothing
			{
				Name = "Roaming"
			};
			State_Nothing state_Nothing6 = new State_Nothing
			{
				Name = "Has target"
			};
			State_Nothing state_Nothing7 = new State_Nothing
			{
				Name = "Ready to strike"
			};
			State_Nothing state_Nothing8 = new State_Nothing
			{
				Name = "Not hurt"
			};
			State_Nothing state_Nothing9 = new State_Nothing
			{
				Name = "Random post idle wait"
			};
			Trans_And transition = new Trans_And
			{
				~new Trans_BlackboardCounterGte
				{
					Key = "AlreadyGrowled",
					MinValue = 2
				},
				new Trans_Cooldown
				{
					cooldown = 6f
				},
				new Trans_TargetIsNearFire
				{
					onlySeeFireWhenClose = true
				}
			};
			Trans_Or trans_Or = HurtTrans | new Trans_IsWatchedByTarget
			{
				requireAiming = true,
				minTime = 3f
			};
			Trans_Or trans_Or2 = HurtTrans | new Trans_IsWatchedByTarget
			{
				requireAiming = true,
				minTime = 0.5f
			};
			_ = obj + (state_Nothing2.AddTickTransition(dead, DeathTrans) + state_Nothing.AddTickTransition(roam, new Trans_IsNavmeshReady()) + (state_Nothing3.AddTickTransition(state_Nothing, ~new Trans_IsNavmeshReady()) + (state_Nothing8.AddTickTransition(hurt, StaggerTrans) + (state_Nothing5.AddTickTransition(approach, new Trans_HasTarget()).AddTickTransition(approachFood, new Trans_SeesFood()) + roam.AddEndTransition(sleep, new Trans_RandomChance
			{
				Chance = 0.25f
			}).AddFailureTransition(dead).AddEndTransition(randomIdle) + sleep.AddEndTransition(roam) + randomIdle.AddEndTransition(state_Nothing9) + state_Nothing9.AddTickTransition(roam, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 0.0,
				MaxDuration = 3.0
			})) + (state_Nothing6.AddTickTransition(roam, new Trans_HasTarget
			{
				Inverted = true
			}).AddTickTransition(permaFlee, EncounterEndTrans).AddTickTransition(permaFlee, new Trans_TargetIsInSafeZone())
				.AddTickTransition(permaFlee, new Trans_IsInWater_Slow() | new Trans_IsTargetInWater()) + (state_Nothing7.AddTickTransition(growlFire, transition).AddTickTransition(approachFood, new Trans_SeesFood() & ~new Trans_HasBlackboardBool
			{
				Key = "TriedToApproachUnreachableFood"
			}).AddTickTransition(charge, new Trans_TargetInRange
			{
				Range = 10f
			})
				.AddTickTransition(charge, new Trans_TargetInRange
				{
					Range = chargeRange
				} & trans_Or)
				.AddTickTransition(flee, ~new Trans_TargetInRange
				{
					Range = chargeRange
				} & trans_Or2) + approach.AddTickTransition(observe, new Trans_And
			{
				~new Trans_HasBlackboardBool
				{
					Key = "AlreadyGrowled"
				},
				new Trans_IsWatchedByTarget
				{
					requireAiming = false
				},
				~new Trans_TargetInRange
				{
					Range = 15f
				}
			}).AddTickTransition(fastSneak, ~new Trans_IsInTargetViewCone
			{
				angle = 70f
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget) + fastSneak.AddTickTransition(approach, new Trans_IsInTargetViewCone
			{
				angle = 60f
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget) + observe.AddTickTransition(approach, new Trans_IsWatchedByTarget
			{
				wantsWatched = false,
				requireAiming = false
			}).AddTickTransition(charge, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 8.0,
				MaxDuration = 12.0
			} & new Trans_TargetInRange
			{
				Range = chargeRange
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget)) + charge.AddTickTransition(attack, new Trans_TargetInRange
			{
				Range = attack.range
			}).AddTickTransition(approach, new Trans_ElapsedTime
			{
				Duration = 5.0
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget2) + attack.AddEndTransition(comboCircle, new Trans_IsTargetDown()).AddEndTransition(flee) + comboCircle.AddTickTransition(charge, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 0.75,
				MaxDuration = 1.5
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget2).AddEndTransition(charge) + growlFire.AddTickTransition(attack, new Trans_TargetInRange
			{
				Range = 2f
			}).AddEndTransition(approach) + state_MoveToLastReachablePointNearTarget.AddTickBranchingTrans(permaFlee, trans_Or2, state_MoveToLastReachablePointNearTarget2, new Trans_TargetInRange
			{
				Range = chargeRange
			}).AddTickTransition(permaFlee, FireMeleeTrans).AddTickTransition(approach, new Trans_CanReachTarget_Slow())
				.AddFailureTransition(permaFlee)
				.AddEndTransition(attackUnreachable) + state_MoveToLastReachablePointNearTarget2.AddTickTransition(permaFlee, FireMeleeTrans).AddTickTransition(charge, new Trans_CanReachTarget_Slow()).AddFailureTransition(permaFlee)
				.AddEndTransition(attackUnreachable) + flee.AddFailureTransition(dead).AddEndTransition(approach)) + (state_Nothing4.AddTickTransition(growlFire, transition).AddTickTransition(flee, trans_Or2) + approachFood.AddTickTransition(roam, ~new Trans_SeesFood()).AddTickTransition(charge, new Trans_TargetInRange
			{
				Range = 10f
			}).AddFailureTransition(roam)
				.AddEndTransition(eatFood) + eatFood.AddTickTransition(roam, ~new Trans_SeesFood()).AddTickTransition(dragCorpse, new Trans_TargetInRange
			{
				Range = 20f
			}).AddFailureTransition(roam)
				.AddEndTransition(roam) + dragCorpse.AddTickTransition(attack, new Trans_TargetInRange
			{
				Range = 3f
			}).AddTickTransition(permaFlee, new Trans_ElapsedTime
			{
				Duration = 1.0
			} & new Trans_TargetInRange
			{
				Range = 12f
			}).AddTickTransition(eatFood, ~new Trans_TargetInRange
			{
				Range = 30f
			})
				.AddFailureTransition(permaFlee)
				.AddEndTransition(permaFlee)) + permaFlee.AddFailureTransition(dead).AddEndTransition(roam)) + hurt.AddEndTransition(flee)) + attackUnreachable.AddFailureTransition(permaFlee).AddEndTransition(permaFlee, new Trans_HasBlackboardBool
			{
				Key = "HitDuringCharge"
			}).AddEndTransition(flee)) + dead;
			SetState(state_Nothing);
			SetFsmActive(newActive: true);
		}
	}

	public override void Hurt(HitInfo hitInfo)
	{
		if (!((Component)this).GetComponent<SenseComponent>().CanTarget(hitInfo.Initiator))
		{
			return;
		}
		((Component)this).GetComponent<RootMotionPlayer>().PlayServerAdditive(hurt.WeakHitAdditive);
		if (base.CurrentState == roar || base.CurrentState == charge || base.CurrentState == attack || base.CurrentState == attackUnreachable)
		{
			((Component)this).GetComponent<BlackboardComponent>().Add("HitDuringCharge");
		}
		HurtTrans.Trigger(hitInfo);
		if (hurt.ShouldStagger(base.baseEntity, hitInfo))
		{
			StaggerTrans.Trigger(hitInfo);
			if (base.CurrentState != hurt && base.CurrentState != dead)
			{
				ForceTickOnTheNextUpdate();
			}
		}
	}

	public override bool OnDied(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
		return false;
	}
}


using System;
using Network;
using Rust.Ai.Gen2;
using UnityEngine;

public class TigerSneakTelegraphGrowl : EntityComponent<BaseEntity>
{
	[SerializeField]
	private SoundDefinition growlSound;

	[ServerVar(Help = "Minimum angle for the tiger to growl when stalking a player")]
	public static float minAngle = 60f;

	[ServerVar(Help = "Time between growls when stalking a player")]
	public static float minTimeBetweenGrowls = 5f;

	private static readonly float[] growlDistances = new float[3] { 50f, 30f, 20f };

	private SenseComponent _senses;

	private double? lastGrowlTime;

	private BasePlayer targetPlayer;

	private int numGrowlsForCurrentPlayer;

	private SenseComponent Senses => _senses ?? (_senses = ((Component)this).GetComponent<SenseComponent>());

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TigerSneakTelegraphGrowl.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		if (base.baseEntity.isServer)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)Tick, 0f, 0.5f);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.baseEntity.isServer)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)Tick);
			UpdateTarget(null);
		}
	}

	private void Tick()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		Senses.FindTarget(out var target);
		UpdateTarget(target);
		if (!((Object)(object)targetPlayer == (Object)null) && (!lastGrowlTime.HasValue || !((double)Time.time - lastGrowlTime.Value < (double)minTimeBetweenGrowls)) && Senses.GetVisibilityStatus(target, out var status) && numGrowlsForCurrentPlayer < growlDistances.Length)
		{
			float num = growlDistances[numGrowlsForCurrentPlayer];
			if (!(Vector3.Distance(((Component)target).transform.position, ((Component)this).transform.position) > num) && !(status.timeNotWatched <= 0f) && !Trans_IsInTargetViewCone.IsInTargetViewCone(Senses, minAngle))
			{
				base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayTigerSneakTelegraphGrowl"));
				lastGrowlTime = Time.timeAsDouble;
				numGrowlsForCurrentPlayer++;
			}
		}
	}

	private void UpdateTarget(BaseEntity newTarget)
	{
		BasePlayer basePlayer = targetPlayer;
		targetPlayer = newTarget as BasePlayer;
		if ((Object)(object)basePlayer != (Object)(object)targetPlayer)
		{
			if (basePlayer.IsValid())
			{
				basePlayer.ClientRPC(RpcTarget.Player("CL_AddPredatorHuntingPlayer", basePlayer), arg1: false);
			}
			if (targetPlayer.IsValid())
			{
				targetPlayer.ClientRPC(RpcTarget.Player("CL_AddPredatorHuntingPlayer", targetPlayer), arg1: true);
			}
			lastGrowlTime = null;
			numGrowlsForCurrentPlayer = 0;
		}
	}
}


using Rust.Ai.Gen2;

public class Crocodile : BaseNPC2
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 1f;

	public override string Categorize()
	{
		return "Crocodile";
	}
}


using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class CrocodileFSM : FSMComponent
{
	public State_PlayRandomAnimation randomIdle = new State_PlayRandomAnimation();

	public State_Roam roam = new State_Roam();

	public State_CircleDynamic approach = new State_CircleDynamic();

	public State_CrocCharge charge = new State_CrocCharge();

	public State_CrocIntimidate intimidate = new State_CrocIntimidate();

	public State_CrocTurn intimidateTurn = new State_CrocTurn();

	public State_AttackWithTracking staticAttack = new State_AttackWithTracking();

	public State_AttackWithTracking bellyFlop = new State_AttackWithTracking();

	public State_AttackWithTracking intimidateSnap = new State_AttackWithTracking();

	public State_AttackWithTracking swimAttack = new State_AttackWithTracking();

	public State_GoBackToWater flee = new State_GoBackToWater();

	public State_HurtWithAdditive hurt = new State_HurtWithAdditive();

	public State_Dead dead = new State_Dead();

	public State_ApproachFood approachFood = new State_ApproachFood();

	public State_BringFoodBackToWater bringFoodBackToWater = new State_BringFoodBackToWater();

	public State_TryAmbushUnderwater diveRoam = new State_TryAmbushUnderwater();

	private Trans_Triggerable_HitInfo HurtTrans;

	private Trans_Triggerable_HitInfo DeathTrans;

	public override void InitShared()
	{
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Expected O, but got Unknown
		if (base.baseEntity.isServer)
		{
			State_Nothing state_Nothing = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			State_MoveToBreakFoundation state_MoveToBreakFoundation = new State_MoveToBreakFoundation
			{
				Name = "MoveToFoundation",
				speed = LimitedTurnNavAgent.Speeds.Run,
				accelerationOverride = charge.accelerationOverride,
				decelerationOverride = charge.decelerationOverride,
				stopAtDestination = true,
				succeedWhenDestinationIsReached = true
			};
			State_CrocBreakFoundation state_CrocBreakFoundation = new State_CrocBreakFoundation
			{
				Name = "BreakFoundation",
				Animation = bellyFlop.Animation,
				DamageType = bellyFlop.DamageType,
				damageDelay = bellyFlop.damageDelay,
				damage = bellyFlop.damage,
				radius = 3f,
				trackingDuration = bellyFlop.trackingDuration,
				trackingSpeed = 360f,
				forceScale = bellyFlop.forceScale,
				doesStrafeDodge = false
			};
			DeathTrans = new Trans_Triggerable_HitInfo();
			HurtTrans = new Trans_Triggerable_HitInfo();
			Trans_Triggerable EncounterEndTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<NPCEncounterTimer>().onShouldGiveUp.AddListener((UnityAction)delegate
			{
				EncounterEndTrans.Trigger();
			});
			Trans_IsSwimming trans_IsSwimming = new Trans_IsSwimming();
			FSMTransitionBase fSMTransitionBase = ~new Trans_IsSwimming();
			FSMTransitionBase dstState2Trans = ~(new Trans_TargetInRange
			{
				Range = 30f
			} | trans_IsSwimming | new Trans_IsTargetInWater());
			Trans_CrocHasStraightPathToTarget trans_CrocHasStraightPathToTarget = new Trans_CrocHasStraightPathToTarget();
			State_Nothing obj = new State_Nothing
			{
				Name = "Root"
			};
			State_Nothing state_Nothing2 = new State_Nothing
			{
				Name = "Alive"
			};
			State_Nothing state_Nothing3 = new State_Nothing
			{
				Name = "Reachable"
			};
			State_Nothing state_Nothing4 = new State_Nothing
			{
				Name = "OnNavmesh"
			};
			new State_Nothing().Name = "Food";
			State_Nothing state_Nothing5 = new State_Nothing
			{
				Name = "Roaming"
			};
			State_Nothing state_Nothing6 = new State_Nothing
			{
				Name = "Has target"
			};
			State_Nothing state_Nothing7 = new State_Nothing
			{
				Name = "Random post idle wait"
			};
			_ = obj + (state_Nothing2.AddTickTransition(dead, DeathTrans) + state_Nothing.AddTickTransition(roam, new Trans_IsNavmeshReady()) + state_Nothing4.AddTickTransition(state_Nothing, ~new Trans_IsNavmeshReady()) + (state_Nothing5.AddTickBranchingTrans(charge, new Trans_HasTarget(), flee, dstState2Trans).AddTickTransition(approachFood, new Trans_SeesFood()) + roam.AddFailureTransition(dead).AddEndTransition(randomIdle, fSMTransitionBase).AddEndTransition(state_Nothing7) + randomIdle.AddEndTransition(state_Nothing7) + state_Nothing7.AddTickTransition(roam, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 7.0,
				MaxDuration = 14.0
			})) + (state_Nothing6.AddTickTransition(roam, ~new Trans_HasTarget()).AddTickTransition(flee, EncounterEndTrans).AddTickTransition(flee, new Trans_TargetIsInSafeZone())
				.AddTickTransition(flee, new Trans_IsTargetProtectedByMount()) + (state_Nothing3.AddTickTransition(flee, new Trans_Cooldown
			{
				cooldown = 30f
			} & new Trans_IsTargetTooFarFromWater()) + charge.AddTickTransition(flee, fSMTransitionBase & new Trans_ElapsedTime
			{
				Duration = 15.0
			} & ~new Trans_TargetInRange
			{
				Range = 15f
			}).AddTickTransition(bellyFlop, fSMTransitionBase & new Trans_Cooldown
			{
				cooldown = 6f
			} & new Trans_TargetInFront
			{
				Angle = 45f
			} & new Trans_TargetInRange
			{
				Range = 5f,
				TimeToPredict = 0.46f
			} & trans_CrocHasStraightPathToTarget).AddTickTransition(intimidateTurn, fSMTransitionBase & new Trans_Cooldown
			{
				cooldown = 5f
			} & ~new Trans_TargetInFront
			{
				Angle = 80f
			} & new Trans_TargetInRange
			{
				Range = 5f
			} & trans_CrocHasStraightPathToTarget)
				.AddTickTransition(staticAttack, fSMTransitionBase & new Trans_TargetInRange
				{
					Range = 2f,
					TimeToPredict = 0.5f
				} & trans_CrocHasStraightPathToTarget)
				.AddTickTransition(swimAttack, trans_IsSwimming & new Trans_TargetInRange
				{
					Range = 5.65f,
					TimeToPredict = 0.85f
				} & trans_CrocHasStraightPathToTarget)
				.AddFailureTransition(state_MoveToBreakFoundation) + intimidate.AddTickTransition(charge, HurtTrans).AddTickTransition(charge, new Trans_ElapsedTime
			{
				Duration = 0.25
			} & new Trans_TargetInRange
			{
				Range = 4f
			}).AddTickTransition(charge, new Trans_ElapsedTime
			{
				Duration = 1.5
			} & new Trans_TargetInRange
			{
				Range = 6f
			})
				.AddTickBranchingTrans(charge, ~new Trans_TargetInFront
				{
					Angle = 70f
				}, intimidateTurn, new Trans_Cooldown
				{
					cooldown = 5f
				})
				.AddEndTransition(charge)) + state_MoveToBreakFoundation.AddTickTransition(charge, new Trans_CanReachTarget_Slow()).AddFailureTransition(flee).AddEndTransition(state_CrocBreakFoundation)) + approachFood.AddTickBranchingTrans(charge, HurtTrans, flee, dstState2Trans).AddTickTransition(charge, new Trans_TargetInRange
			{
				Range = 8f
			}).AddTickTransition(roam, ~new Trans_SeesFood())
				.AddFailureTransition(roam)
				.AddEndTransition(bringFoodBackToWater) + bringFoodBackToWater.AddTickBranchingTrans(charge, HurtTrans, flee, dstState2Trans).AddTickTransition(charge, new Trans_TargetInRange
			{
				Range = 8f
			}).AddFailureTransition(roam)
				.AddEndTransition(roam) + bellyFlop.AddEndTransition(intimidateTurn, fSMTransitionBase & ~new Trans_TargetInFront
			{
				Angle = 30f
			}).AddEndTransition(intimidateSnap, fSMTransitionBase).AddEndTransition(charge) + state_CrocBreakFoundation.AddEndTransition(charge) + swimAttack.AddEndTransition(charge) + staticAttack.AddEndTransition(intimidateSnap) + intimidateSnap.AddEndTransition(intimidate) + intimidateTurn.AddEndTransition(intimidateSnap, new Trans_TargetInRange
			{
				Range = 6f
			}).AddEndTransition(charge) + flee.AddTickTransition(intimidate, fSMTransitionBase & new Trans_ElapsedTime
			{
				Duration = 3.0
			} & new Trans_TargetInRange
			{
				Range = 8f
			}).AddTickTransition(diveRoam, trans_IsSwimming).AddFailureTransition(dead)
				.AddEndTransition(diveRoam) + diveRoam.AddTickTransition(charge, ~new Trans_IsTargetProtectedByMount() & (new Trans_IsTargetInWater() | (new Trans_TargetInRange
			{
				Range = 8f
			} & new Trans_IsTargetOnNavmesh_Slow()))).AddTickTransition(roam, ~new Trans_TargetInRange
			{
				Range = 50f
			}).AddFailureTransition(dead) + dead);
			SetState(state_Nothing);
			SetFsmActive(newActive: true);
		}
	}

	public override void Hurt(HitInfo hitInfo)
	{
		if (((Component)this).GetComponent<SenseComponent>().CanTarget(hitInfo.Initiator))
		{
			((Component)this).GetComponent<RootMotionPlayer>().PlayServerAdditive(hurt.WeakHitAdditive);
			HurtTrans.Trigger(hitInfo);
			if (base.CurrentState == approach || base.CurrentState == approachFood || base.CurrentState == bringFoodBackToWater || base.CurrentState == intimidate)
			{
				ForceTickOnTheNextUpdate();
			}
		}
	}

	public override bool OnDied(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
		return false;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_LandOrSwimAttack : State_Attack
{
	public RootMotionData swimAttack;

	protected override RootMotionData GetAnimation()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (WaterLevel.GetWaterDepth(((Component)Owner).transform.position, waves: false, volumes: false) > 0f)
		{
			return swimAttack;
		}
		return Animation;
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_CrocIntimidate : FSMStateBase
{
	private float remainingDuration;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		if (Owner is BaseCombatEntity baseCombatEntity)
		{
			remainingDuration = Mathx.RemapValClamped(baseCombatEntity.healthFraction, 1f, 0.3f, 5f, 0f);
			if (remainingDuration == 0f)
			{
				return EFSMStateStatus.Success;
			}
			return result;
		}
		return EFSMStateStatus.Failure;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (remainingDuration > 0f)
		{
			remainingDuration -= deltaTime;
			if (remainingDuration <= 0f)
			{
				return EFSMStateStatus.Success;
			}
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CrocTurn : State_PlayAnimationRM
{
	[SerializeField]
	public RootMotionData turn90L;

	[SerializeField]
	public RootMotionData turn90R;

	[SerializeField]
	public RootMotionData turn180;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 val = targetPosition - ((Component)Owner).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		float num = Vector3.SignedAngle(((Component)Owner).transform.forward, normalized, Vector3.up);
		if (Mathf.Abs(num) > 130f)
		{
			Animation = turn180;
		}
		else if (num > 0f)
		{
			Animation = turn90R;
		}
		else
		{
			Animation = turn90L;
		}
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CrocCharge : State_MoveToTarget
{
	private const float maxChargeDuration = 6f;

	private float remainingChargeDuration;

	private Action _reallowChargingAction;

	private Action _surpriseAction;

	private Action _resetSurpriseAction;

	private double nextSurpriseTime;

	private Action ReallowChargingAction => ResetStamina;

	private Action SurpriseAction => Surprise;

	private Action ResetSurpriseAction => ResetSurprise;

	public override EFSMStateStatus OnStateEnter()
	{
		ResetStamina();
		ResetSurprise();
		return base.OnStateEnter();
	}

	private void ResetStamina()
	{
		remainingChargeDuration = 6f;
	}

	private void ResetSurprise()
	{
		float num = Random.Range(3f, 6f);
		((FacepunchBehaviour)Owner).Invoke(SurpriseAction, num);
		((FacepunchBehaviour)Owner).Invoke(ResetSurpriseAction, num + Random.Range(3f, 6f));
	}

	private void Surprise()
	{
		nextSurpriseTime = Time.timeAsDouble + (double)Random.Range(3f, 6f);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		if (Owner is BaseCombatEntity baseCombatEntity)
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return EFSMStateStatus.Success;
			}
			base.Agent.acceleration.Value = accelerationOverride;
			float num = Mathx.RemapValClamped(baseCombatEntity.healthFraction, 1f, 0.3f, 0f, 1f);
			bool flag = false;
			BasePlayer player;
			if (base.Agent.IsSwimming)
			{
				flag = true;
				base.Agent.acceleration.Value = 2.5f;
				num = 1f;
			}
			else if (baseCombatEntity.lastAttackedTime > 0f && Time.time < baseCombatEntity.lastAttackedTime + 0.5f)
			{
				flag = true;
				num = 1f;
			}
			else if (Time.timeAsDouble > nextSurpriseTime && Time.timeAsDouble < nextSurpriseTime + 0.5)
			{
				num = 1f;
			}
			else if (base.Agent.RemainingDistance < 4f)
			{
				flag = true;
				num = 1f;
			}
			else if (target.ToNonNpcPlayer(out player) && player.modelState.sprinting)
			{
				Vector3 estimatedVelocity = player.estimatedVelocity;
				if (Vector3.Dot(((Vector3)(ref estimatedVelocity)).normalized, ((Component)Owner).transform.forward) > 0.5f)
				{
					base.Agent.acceleration.Value = 2f;
					num = 1f;
				}
			}
			if (!flag && num >= 1f)
			{
				float num2 = remainingChargeDuration;
				remainingChargeDuration -= deltaTime;
				if (num2 > 0f && remainingChargeDuration <= 0f)
				{
					((FacepunchBehaviour)Owner).Invoke(ReallowChargingAction, 6f);
				}
			}
			if (!flag && remainingChargeDuration <= 0f)
			{
				num = Mathf.Min(num, 0.3f);
			}
			base.Agent.SetSpeedRatio(num, speed, LimitedTurnNavAgent.Speeds.FullSprint);
			if (base.Senses.GetVisibilityStatus(target, out var status) && status.isInWaterCached)
			{
				base.Agent.desiredSwimDepth.Value = Mathf.Max(base.Agent.desiredSwimDepth.DefaultValue, status.lastWaterInfo.Value.currentDepth + 1f);
			}
		}
		return base.OnStateUpdate(deltaTime);
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		destination = default(Vector3);
		if (!base.Senses.FindTarget(out var target))
		{
			return false;
		}
		if (target.IsNonNpcPlayer() && base.Agent.canSwim && base.Senses.GetVisibilityStatus(target, out var status) && status.isInWaterCached)
		{
			destination = Vector3Ex.WithY(((Component)target).transform.position, status.lastWaterInfo.Value.terrainHeight);
			return true;
		}
		return base.GetMoveDestination(out destination);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_GoBackToWater : State_MoveToTarget
{
	private Vector3 nearestWaterPoint;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if (base.Agent.IsSwimming)
		{
			return EFSMStateStatus.Success;
		}
		TimeWarning val = TimeWarning.New("State_GoBackToWater GetCoarseVectorToShore and GetHeight", 0);
		try
		{
			(Vector3 shoreDir, float shoreDist) coarseVectorToShore = TerrainTexturing.Instance.GetCoarseVectorToShore(((Component)Owner).transform.position);
			Vector3 item = coarseVectorToShore.shoreDir;
			float item2 = coarseVectorToShore.shoreDist;
			Vector3 val2 = item * item2;
			Vector3 val3 = ((Component)Owner).transform.position + ((Vector3)(ref val2)).normalized * (((Vector3)(ref val2)).magnitude + 10f);
			val3.y = TerrainMeta.HeightMap.GetHeight(val3);
			PooledList<Vector3> val4 = Pool.Get<PooledList<Vector3>>();
			try
			{
				Eqs.SamplePositionsInDonutShape(val3, (List<Vector3>)(object)val4);
				ListEx.Shuffle<Vector3>((List<Vector3>)(object)val4, (uint)Environment.TickCount);
				nearestWaterPoint = val3;
				foreach (Vector3 item3 in (List<Vector3>)(object)val4)
				{
					if (base.Agent.SamplePosition(item3, out var sample, 10f) && base.Agent.IsInWater(sample))
					{
						nearestWaterPoint = sample;
						break;
					}
				}
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		destination = nearestWaterPoint;
		return true;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_BringFoodBackToWater : State_GoBackToWater
{
	private BaseCorpse corpse;

	private Action _updateCorpsePositionAction;

	private Action UpdateCorpsePositionAction => OnStateFixedUpdate;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (!(food is BaseCorpse baseCorpse))
		{
			return EFSMStateStatus.Failure;
		}
		if (!SingletonComponent<NpcFoodManager>.Instance.Remove(baseCorpse))
		{
			return EFSMStateStatus.Failure;
		}
		((Component)Owner).transform.forward = Vector3Ex.NormalizeXZ(((Component)baseCorpse).transform.position - ((Component)Owner).transform.position);
		corpse = baseCorpse;
		corpse.SetFlag(BaseEntity.Flags.Reserved3, b: true);
		((FacepunchBehaviour)Owner).InvokeRepeatingFixedTime(UpdateCorpsePositionAction);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!corpse.IsValid() || corpse.IsDead())
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}

	private void OnStateFixedUpdate()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (corpse.IsValid() && !corpse.IsDead())
		{
			Rigidbody component = ((Component)corpse).GetComponent<Rigidbody>();
			if (component != null)
			{
				component.MovePosition(((Component)Owner).transform.position + ((Component)Owner).transform.forward * 1.6f + ((Component)Owner).transform.up * 0.6f);
				component.velocity = Vector3.zero;
				component.angularVelocity = Vector3.zero;
			}
		}
	}

	public override void OnStateExit()
	{
		base.OnStateExit();
		if (corpse.IsValid())
		{
			corpse.SetFlag(BaseEntity.Flags.Reserved3, b: false);
		}
		((FacepunchBehaviour)Owner).CancelInvokeFixedTime(UpdateCorpsePositionAction);
		corpse = null;
	}
}


using System;
using ConVar;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_AttackWithTracking : State_PlayAnimationRM
{
	public DamageType DamageType = DamageType.Bite;

	public float damageDelay = 0.5f;

	public float damage = 30f;

	public float forceScale = 1f;

	public float trackingSpeed = 90f;

	public float trackingDuration = 9999f;

	public float radius = 4f;

	public bool doesStrafeDodge;

	private Action _doDamageAction;

	private static readonly Vector3 force = new Vector3(15f, 3f, 15f);

	private double startTime;

	private Action DoDamageAction => _doDamageAction ?? (_doDamageAction = DoDamage);

	public override EFSMStateStatus OnStateEnter()
	{
		FaceTarget = false;
		startTime = Time.timeAsDouble;
		((FacepunchBehaviour)Owner).Invoke(DoDamageAction, damageDelay + AI.defaultInterpolationDelay);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (trackingDuration > 0f && trackingSpeed > 0f && Time.timeAsDouble - startTime < (double)(trackingDuration + AI.defaultInterpolationDelay) && base.Senses.FindTarget(out var target))
		{
			base.AnimPlayer.Track(((Component)target).transform.position, trackingSpeed, null);
		}
		return base.OnStateUpdate(deltaTime);
	}

	protected virtual void DoDamage()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BaseCombatEntity baseCombatEntity))
		{
			return;
		}
		if (baseCombatEntity.ToNonNpcPlayer(out var player) && doesStrafeDodge)
		{
			Vector3 estimatedVelocity = player.estimatedVelocity;
			if (Mathf.Abs(Vector3.Dot(((Vector3)(ref estimatedVelocity)).normalized, ((Component)Owner).transform.right)) > 0.7f)
			{
				return;
			}
		}
		if (base.Senses.GetVisibilityStatus(target, out var status) && status.timeNotVisible < 1f && Vector3.Distance(((Component)Owner).transform.position, ((Component)baseCombatEntity).transform.position) < radius)
		{
			baseCombatEntity.OnAttacked(damage, DamageType, Owner, ignoreShield: false);
			if (forceScale > 0f && (Object)(object)player != (Object)null)
			{
				Vector3 val = ((Vector3.Dot(((Component)Owner).transform.right, Vector3Ex.NormalizeXZ(((Component)player).transform.position - ((Component)Owner).transform.position)) > 0f) ? ((Component)Owner).transform.right : (-((Component)Owner).transform.right));
				player.DoPush((((Component)Owner).transform.forward * force.z + val * force.x + Vector3.up * force.y) * forceScale);
			}
		}
	}

	public override void OnStateExit()
	{
		((FacepunchBehaviour)Owner).CancelInvoke(DoDamageAction);
		base.OnStateExit();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_MoveToBreakFoundation : State_CrocCharge
{
	private const float maxHorizontalDist = 10f;

	private Vector3 attackLocation;

	private bool FindReachableLocation(out Vector3 location)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		location = default(Vector3);
		if (!base.Senses.FindTarget(out var target) || !target.ToNonNpcPlayer(out var player))
		{
			return false;
		}
		Vector3 position = ((Component)target).transform.position;
		if (Vector3.Distance(((Component)Owner).transform.position, position) > 50f)
		{
			return false;
		}
		if (((Object)(object)State_CrocBreakFoundation.FindNearestTwigFoundationOnTargetBuilding(base.Agent, player, null)).Is<BuildingBlock>(out BuildingBlock castedUnityObject) && base.Agent.SamplePosition(castedUnityObject.ClosestPoint(((Component)Owner).transform.position), out var sample, 10f))
		{
			location = sample;
			return true;
		}
		if (base.Agent.SamplePosition(position, out var sample2, 3f))
		{
			location = sample2;
			return true;
		}
		return false;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !target.ToNonNpcPlayer(out var _))
		{
			return EFSMStateStatus.Failure;
		}
		if (!FindReachableLocation(out attackLocation))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 val = attackLocation + ((Bounds)(ref Owner.bounds)).extents.y * Vector3.up;
		Vector3 val2 = target.CenterPoint() - val;
		if (GamePhysics.Trace(new Ray(val, val2), 0f, out var _, ((Vector3)(ref val2)).magnitude, 1503731969, (QueryTriggerInteraction)0))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		destination = attackLocation;
		return true;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CrocBreakFoundation : State_AttackWithTracking
{
	public const float attackRange = 3f;

	private static bool FindBuildingBlockNearby(LimitedTurnNavAgent agent, Vector3 position, out BuildingBlock buildingBlock)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (agent.SampleGroundPositionWithPhysics(position, out var hitInfo, 2f, BasePlayer.GetRadius(), 2097152) && hitInfo.GetEntity() is BuildingBlock buildingBlock2)
		{
			buildingBlock = buildingBlock2;
			return true;
		}
		PooledList<BuildingBlock> val = Pool.Get<PooledList<BuildingBlock>>();
		try
		{
			Vis.Entities(position, 4f, (List<BuildingBlock>)(object)val, 2097152, (QueryTriggerInteraction)2);
			if (((List<BuildingBlock>)(object)val).Count > 0)
			{
				buildingBlock = ((List<BuildingBlock>)(object)val)[0];
				return true;
			}
			buildingBlock = null;
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static BuildingBlock FindNearestTwigFoundationOnTargetBuilding(LimitedTurnNavAgent agent, BasePlayer targetPlayer, float? maxDistance = null)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (!FindBuildingBlockNearby(agent, ((Component)targetPlayer).transform.position, out var buildingBlock))
		{
			return null;
		}
		BuildingManager.Building building = BuildingManager.server.GetBuilding(buildingBlock.buildingID);
		BuildingBlock result = null;
		float num = float.MaxValue;
		Enumerator<BuildingBlock> enumerator = building.buildingBlocks.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BuildingBlock current = enumerator.Current;
				if (current.grade == BuildingGrade.Enum.Twigs && (Object)(object)current.parentEntity.Get(serverside: true) == (Object)null && (current.ShortPrefabName == "foundation" || current.ShortPrefabName == "foundation.triangle"))
				{
					float num2 = current.Distance(((Component)agent).transform.position);
					if ((!maxDistance.HasValue || !(num2 > maxDistance.Value)) && num2 < num)
					{
						result = current;
						num = num2;
					}
				}
			}
			return result;
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	protected override void DoDamage()
	{
		if (base.Senses.FindTarget(out var target) && target.ToNonNpcPlayer(out var player))
		{
			BuildingBlock buildingBlock = FindNearestTwigFoundationOnTargetBuilding(base.Agent, player, null);
			if ((Object)(object)buildingBlock == (Object)null)
			{
				base.DoDamage();
			}
			else
			{
				buildingBlock.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_TryAmbushUnderwater : FSMStateBase
{
	[SerializeField]
	private Vector2 distanceRange = new Vector2(10f, 20f);

	[SerializeField]
	private float maxDistFromDivingPoint = 50f;

	private const float desiredDepth = 3f;

	private Vector3 divePosition;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		base.Agent.desiredSwimDepth.Value = 3f;
		divePosition = ((Component)Owner).transform.position;
		return FindNewUnderwaterWaitingPosition();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Agent.IsFollowingPath)
		{
			return FindNewUnderwaterWaitingPosition();
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.Agent.desiredSwimDepth.Reset();
		base.OnStateExit();
	}

	private EFSMStateStatus FindNewUnderwaterWaitingPosition()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			float radius = Random.Range(distanceRange.x, distanceRange.y);
			Eqs.SamplePositionsInDonutShape(base.Agent.NavPosition, (List<Vector3>)(object)val, radius);
			if (Vector3.Distance(divePosition, ((Component)Owner).transform.position) > maxDistFromDivingPoint)
			{
				Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
				try
				{
					Vector3 val2 = divePosition - ((Component)Owner).transform.position;
					Vector3 normalized = ((Vector3)(ref val2)).normalized;
					foreach (Vector3 item2 in (List<Vector3>)(object)val)
					{
						val2 = item2 - ((Component)Owner).transform.position;
						float item = Vector3.Dot(normalized, ((Vector3)(ref val2)).normalized);
						((List<(Vector3, float)>)(object)pooledScoreList).Add((item2, item));
					}
					pooledScoreList.SortByScoreDesc(Owner);
					pooledScoreList.Reorder((List<Vector3>)(object)val);
				}
				finally
				{
					((IDisposable)(object)pooledScoreList)?.Dispose();
				}
			}
			else
			{
				ListEx.Shuffle<Vector3>((List<Vector3>)(object)val, (uint)Environment.TickCount);
			}
			foreach (Vector3 item3 in (List<Vector3>)(object)val)
			{
				if (base.Agent.SamplePosition(item3, out var sample, 10f) && base.Agent.IsInWater(sample) && base.Agent.SetDestination(sample))
				{
					base.Agent.SetSpeed((!base.Agent.IsSwimming) ? LimitedTurnNavAgent.Speeds.Run : LimitedTurnNavAgent.Speeds.Sneak);
					return EFSMStateStatus.None;
				}
			}
			return EFSMStateStatus.Failure;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_TooFarFromWater : FSMTransitionBase
{
	public float maxDistance = 20f;

	protected override bool EvaluateInternal()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TooFarFromWater", 0);
		try
		{
			return TerrainTexturing.Instance.GetCoarseDistanceToShore(((Component)Owner).transform.position) < 0f - maxDistance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsTargetTooFarFromWater : FSMTransitionBase
{
	public float maxDistance = 30f;

	protected override bool EvaluateInternal()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsTargetTooFarFromWater", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			return TerrainTexturing.Instance.GetCoarseDistanceToShore(targetPosition) < 0f - maxDistance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
internal class Trans_CrocHasStraightPathToTarget : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_CrocHasStraightPathToTarget", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			Vector3 targetPosition = ((Component)target).transform.position;
			if (target.IsNonNpcPlayer() && base.Agent.canSwim && base.Senses.GetVisibilityStatus(target, out var status) && status.isInWaterCached)
			{
				targetPosition = Vector3Ex.WithY(((Component)target).transform.position, status.lastWaterInfo.Value.terrainHeight);
			}
			NavMeshHit hitInfo;
			return !base.Agent.Raycast(targetPosition, out hitInfo);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsTargetProtectedByMount : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsTargetProtectedByMount", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target) || !target.ToNonNpcPlayer(out var player))
			{
				return false;
			}
			BaseMountable castedUnityObject;
			return ((Object)(object)player.GetMounted()).Is<BaseMountable>(out castedUnityObject) && castedUnityObject.ProtectsFromAnimals;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

public class CoverComponent : MonoBehaviour, IServerComponent
{
	[Polymorphic]
	[SerializeReference]
	public CoverGroup coverGroup;

	private void OnEnable()
	{
		if (coverGroup != null)
		{
			coverGroup.GenerateCovers(((Component)this).gameObject);
		}
		SingletonComponent<NpcCoverManager>.Instance.Add(this);
	}

	private void OnDisable()
	{
		if ((Object)(object)SingletonComponent<NpcCoverManager>.Instance != (Object)null)
		{
			SingletonComponent<NpcCoverManager>.Instance.Remove(this);
		}
	}

	public bool GetCovers(List<Cover> covers, Vector3 from)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return coverGroup.GetCovers(((Component)this).transform, covers, from);
	}

	[Button("Bake")]
	public void Bake()
	{
		if (coverGroup != null)
		{
			coverGroup.GenerateCovers(((Component)this).gameObject);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public struct Cover : IEquatable<Cover>
{
	[Flags]
	public enum Peeks
	{
		None = 0,
		Left = 1,
		Right = 2,
		Up = 4,
		Sides = 3,
		All = 7
	}

	public Vector3 position;

	public float yaw;

	public Peeks peeks;

	public const float sidePeekLength = 1f;

	private const int ShotTestLayer = 1486954497;

	public bool NeedDucking => peeks.HasFlag(Peeks.Up);

	public Cover(Vector3 position, float yaw, Peeks peeks)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		this.position = position;
		this.yaw = yaw;
		this.peeks = peeks;
	}

	public bool ProtectsFrom(Vector3 threatLocation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = threatLocation - position;
		return Mathf.Abs(Mathf.DeltaAngle(Mathf.Atan2(val.x, val.z) * 57.29578f, yaw)) <= 50f;
	}

	public Peeks GetAnyPeek()
	{
		if (peeks.HasFlag(Peeks.Left))
		{
			return Peeks.Left;
		}
		if (peeks.HasFlag(Peeks.Right))
		{
			return Peeks.Right;
		}
		if (peeks.HasFlag(Peeks.Up))
		{
			return Peeks.Up;
		}
		return Peeks.None;
	}

	public Peeks GetFirstUnoccludedPeek(Vector3 target, BaseEntity entity = null)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (peeks.HasFlag(Peeks.Left) && !IsPeekOccluded(Peeks.Left, target, entity))
		{
			return Peeks.Left;
		}
		if (peeks.HasFlag(Peeks.Right) && !IsPeekOccluded(Peeks.Right, target, entity))
		{
			return Peeks.Right;
		}
		if (peeks.HasFlag(Peeks.Up) && !IsPeekOccluded(Peeks.Up, target, entity))
		{
			return Peeks.Up;
		}
		return Peeks.None;
	}

	public bool IsPeekOccluded(Peeks peek, Vector3 target, BaseEntity entity = null)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Cover.IsPeekOccluded", 0);
		try
		{
			Vector3 peekLocation = GetPeekLocation(peek);
			Vector3 val2 = target - peekLocation;
			float magnitude = ((Vector3)(ref val2)).magnitude;
			Vector3 val3 = val2 / magnitude;
			RaycastHit hitInfo;
			return GamePhysics.Trace(new Ray(peekLocation, val3), 0f, out hitInfo, magnitude, 1486954497, (QueryTriggerInteraction)1);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Vector3 GetPeekLocation(Peeks peek)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = GetForward();
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(forward.z, 0f, 0f - forward.x);
		Vector3 val2 = position + PlayerEyes.EyeOffset;
		if (peek.HasFlag(Peeks.Right))
		{
			val2 += val * 1f;
		}
		if (peek.HasFlag(Peeks.Left))
		{
			val2 -= val * 1f;
		}
		return val2;
	}

	public Vector3 GetPeekGroundLocation(Peeks peek)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return GetPeekLocation(peek) - PlayerEyes.EyeOffset;
	}

	public Vector3 GetForward()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(Mathf.Sin(yaw * (MathF.PI / 180f)), 0f, Mathf.Cos(yaw * (MathF.PI / 180f)));
	}

	public bool Equals(Cover other)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return position == other.position;
	}

	public override bool Equals(object obj)
	{
		if (obj is Cover other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).GetHashCode();
	}

	public static bool operator ==(Cover left, Cover right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(Cover left, Cover right)
	{
		return !(left == right);
	}
}


using System;

[Flags]
public enum Peeks
{
	None = 0,
	Left = 1,
	Right = 2,
	Up = 4,
	Sides = 3,
	All = 7
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class CoverGroup : IPooled, IDisposable
{
	[SerializeField]
	protected bool isTall;

	protected List<Cover> covers = new List<Cover>();

	public bool HasCovers => covers.Count > 0;

	public virtual bool IsSlow => false;

	public virtual void GenerateCovers(GameObject gameObject)
	{
	}

	public virtual bool GetCovers(Transform transform, List<Cover> covers, Vector3 from)
	{
		return false;
	}

	public virtual void EnterPool()
	{
		covers.Clear();
	}

	public virtual void LeavePool()
	{
	}

	public void Dispose()
	{
		CoverGroup coverGroup = this;
		Pool.Free<CoverGroup>(ref coverGroup);
	}
}


using System;
using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class LineCoverGroup : CoverGroup
{
	[SerializeField]
	private float length = 5f;

	[SerializeField]
	private float thickness = 0.5f;

	[SerializeField]
	private bool rotate90;

	public static Vector3 GetCircleInscribedInCorner(Vector3 corner, Vector3 dir1, Vector3 dir2, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		dir1 = Vector3Ex.NormalizeXZ(dir1);
		dir2 = Vector3Ex.NormalizeXZ(dir2);
		float num = Vector3.Angle(dir1, dir2);
		float num2 = radius / Mathf.Sin(num * 0.5f * (MathF.PI / 180f));
		Vector3 val = dir1 + dir2;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return corner + normalized * num2;
	}

	public static (Cover, Cover) GetLineCovers(Vector3 a, Vector3 b, Vector3 from)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		bool flag = Vector3.Cross(b - a, from - a).y < 0f;
		Vector3 circleInscribedInCorner = GetCircleInscribedInCorner(a, a - from, b - a, 0.5f);
		Quaternion val = Quaternion.LookRotation(from - a);
		float y = ((Quaternion)(ref val)).eulerAngles.y;
		Cover item = new Cover(circleInscribedInCorner, y, flag ? Cover.Peeks.Left : Cover.Peeks.Right);
		Vector3 circleInscribedInCorner2 = GetCircleInscribedInCorner(b, b - from, a - b, 0.5f);
		val = Quaternion.LookRotation(from - b);
		float y2 = ((Quaternion)(ref val)).eulerAngles.y;
		Cover item2 = new Cover(circleInscribedInCorner2, y2, (!flag) ? Cover.Peeks.Left : Cover.Peeks.Right);
		return (item, item2);
	}

	public override bool GetCovers(Transform transform, List<Cover> covers, Vector3 threatLocation)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = (rotate90 ? transform.right : transform.forward);
		Vector3 val2 = Vector3Ex.NormalizeXZ(threatLocation - transform.position);
		Vector3 val3 = Vector3.Project(val2, val);
		val = ((Vector3)(ref val3)).normalized;
		Vector3 val4 = default(Vector3);
		((Vector3)(ref val4))..ctor(val.z, 0f, 0f - val.x);
		if (Vector3.Dot(val, val2) < 0.5f)
		{
			return false;
		}
		Vector3 val5 = -val * thickness;
		float num = length - 1f + 0.25f;
		if (num < 0f)
		{
			return false;
		}
		if (num <= 0.5f)
		{
			num = length;
		}
		Vector3 a = transform.position + val5 + val4 * num * 0.5f;
		Vector3 b = transform.position + val5 - val4 * num * 0.5f;
		(Cover, Cover) lineCovers = GetLineCovers(a, b, threatLocation);
		covers.Add(lineCovers.Item1);
		covers.Add(lineCovers.Item2);
		return true;
	}
}


using System;
using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class PillarCoverGroup : CoverGroup
{
	[SerializeField]
	private float radius = 1f;

	[SerializeField]
	private float radiusOffset;

	private Vector3 position;

	private Quaternion rotation;

	public override void GenerateCovers(GameObject gameObject)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		position = gameObject.transform.position;
		rotation = gameObject.transform.rotation;
		BaseEntity component = gameObject.GetComponent<BaseEntity>();
		MeshRenderer componentInChildren = gameObject.GetComponentInChildren<MeshRenderer>();
		if ((Object)(object)component != (Object)null)
		{
			Bounds bounds = component.bounds;
			radius = Mathf.Max(((Bounds)(ref bounds)).extents.x, ((Bounds)(ref bounds)).extents.z) - radiusOffset;
			isTall = ((Bounds)(ref bounds)).size.y >= 1.8f;
		}
		else if ((Object)(object)componentInChildren != (Object)null)
		{
			Bounds localBounds = ((Renderer)componentInChildren).localBounds;
			Vector3 extents = ((Bounds)(ref localBounds)).extents;
			radius = ((Vector3)(ref extents)).magnitude * ((Component)componentInChildren).transform.lossyScale.x - radiusOffset;
			localBounds = ((Renderer)componentInChildren).localBounds;
			isTall = ((Bounds)(ref localBounds)).size.y * ((Component)componentInChildren).transform.lossyScale.y >= 1.8f;
		}
	}

	public override bool GetCovers(Transform transform, List<Cover> covers, Vector3 from)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = from - position;
		Cover.Peeks peeks = (isTall ? Cover.Peeks.Sides : Cover.Peeks.Up);
		if (rotation == Quaternion.identity)
		{
			float yaw = Mathf.Atan2(val.x, val.z) * 57.29578f;
			Vector3 val2 = position + -Vector3Ex.NormalizeXZ(val) * (radius + 0.5f);
			covers.Add(new Cover(val2, yaw, peeks));
		}
		else
		{
			Vector3 val3 = rotation * Vector3.forward;
			Vector3 val4 = rotation * Vector3.right;
			Vector3 val5 = default(Vector3);
			((Vector3)(ref val5))..ctor(Vector3.Dot(val, val4), 0f, Vector3.Dot(val, val3));
			float yaw2 = Mathf.Atan2(val.x, val.z) * 57.29578f;
			Vector3 val6 = -((Vector3)(ref val5)).normalized * (radius + 0.5f);
			Vector3 val7 = position + val4 * val6.x + val3 * val6.z;
			covers.Add(new Cover(val7, yaw2, peeks));
		}
		return true;
	}
}


using System;
using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class BoxCoverGroup : CoverGroup
{
	[SerializeField]
	private Vector3 size = new Vector3(5f, 1.5f, 1f);

	private OBB obb;

	private static readonly (int x, int z)[] boxCorners = new(int, int)[4]
	{
		(1, 1),
		(1, -1),
		(-1, -1),
		(-1, 1)
	};

	public override void GenerateCovers(GameObject gameObject)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		covers.Clear();
		BaseEntity component = gameObject.GetComponent<BaseEntity>();
		MeshRenderer componentInChildren = gameObject.GetComponentInChildren<MeshRenderer>();
		if ((Object)(object)component != (Object)null)
		{
			Bounds bounds = component.bounds;
			obb = new OBB(gameObject.transform.position + ((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).size, gameObject.transform.rotation);
		}
		else if ((Object)(object)componentInChildren != (Object)null)
		{
			Vector3 position = gameObject.transform.position;
			Bounds localBounds = ((Renderer)componentInChildren).localBounds;
			Vector3 val = position + ((Bounds)(ref localBounds)).center * ((Component)componentInChildren).transform.lossyScale.x;
			localBounds = ((Renderer)componentInChildren).localBounds;
			obb = new OBB(val, ((Bounds)(ref localBounds)).size * ((Component)componentInChildren).transform.lossyScale.x, gameObject.transform.rotation);
		}
		else
		{
			obb = new OBB(gameObject.transform.position + size.y * 0.5f * Vector3.up, size, gameObject.transform.rotation);
		}
		isTall = obb.extents.y * 2f >= 1.8f;
		for (int i = 0; i < boxCorners.Length; i++)
		{
			(int, int) tuple = boxCorners[i];
			(int, int) tuple2 = boxCorners[(i + 1) % boxCorners.Length];
			Vector3 point = ((OBB)(ref obb)).GetPoint((float)tuple.Item1, -1f, (float)tuple.Item2);
			Vector3 point2 = ((OBB)(ref obb)).GetPoint((float)tuple2.Item1, -1f, (float)tuple2.Item2);
			Vector3 val2 = point2 - point;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			point += normalized * 0.875f;
			point2 -= normalized * 0.875f;
			int num = Mathf.FloorToInt(Vector3.Distance(point, point2) / 1f);
			for (int j = 0; j < num; j++)
			{
				Cover.Peeks peeks = Cover.Peeks.None;
				if (!isTall)
				{
					peeks |= Cover.Peeks.Up;
				}
				else
				{
					if (j == 0)
					{
						peeks |= Cover.Peeks.Right;
					}
					if (j == num - 1)
					{
						peeks |= Cover.Peeks.Left;
					}
				}
				if (peeks != 0)
				{
					Vector3 val3 = Vector3.Lerp(point, point2, (float)(j / (num - 1)));
					Vector3 val4 = val3;
					val2 = Vector3.Cross(normalized, Vector3.up);
					val3 = val4 + ((Vector3)(ref val2)).normalized * 0.5f;
					Cover item = new Cover(val3, Mathf.Atan2(point2.x - point.x, point2.z - point.z) * 57.29578f + 90f, peeks);
					covers.Add(item);
				}
			}
		}
	}

	public override bool GetCovers(Transform transform, List<Cover> covers, Vector3 from)
	{
		covers.AddRange(base.covers);
		return base.covers.Count > 0;
	}
}


using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

public class NavGeneratedCoverGroup : CoverGroup
{
	[SerializeField]
	public List<Cover> cachedCovers = new List<Cover>();

	public override bool IsSlow => true;

	public override bool GetCovers(Transform transform, List<Cover> covers, Vector3 from)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (cachedCovers.Count == 0)
		{
			return false;
		}
		foreach (Cover cachedCover in cachedCovers)
		{
			Cover item = cachedCover;
			item.position = transform.TransformPoint(cachedCover.position);
			float yaw = cachedCover.yaw;
			Quaternion rotation = transform.rotation;
			item.yaw = yaw + ((Quaternion)(ref rotation)).eulerAngles.y;
			covers.Add(item);
		}
		return true;
	}
}


public class NPCHumanoidFootstepComponent : BaseFootstepEffect
{
	public NPCHumanoidAnimController AnimComp;
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public class NpcGrenade : BaseEntity
{
	public GameObjectRef explosionEffect;

	public GameObjectRef fireballPrefab;

	public float speed = 10f;

	[NonSerialized]
	public NpcGrenadePositionHint grenadeHint;

	private double spawnTime;

	public override void ServerInit()
	{
		base.ServerInit();
		spawnTime = Time.realtimeSinceStartupAsDouble;
	}

	private void Update()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && !base.IsDestroyed)
		{
			Vector3 val = ((Component)grenadeHint).transform.position + 1.8f * Vector3.up;
			Vector3 position = grenadeHint.landingPoint.position;
			Vector3 val2 = Vector3Ex.WithY((val + position) * 0.5f, Mathf.Max(val.y, position.y) + grenadeHint.apexHeight);
			float num = Vector3Ex.MagnitudeXZ(position - val) / speed;
			float num2 = (float)(Time.realtimeSinceStartupAsDouble - spawnTime) / num;
			num2 = Mathf.Clamp01(num2);
			((Component)this).transform.position = Vector3.Lerp(Vector3.Lerp(val, val2, num2), Vector3.Lerp(val2, position, num2), num2);
			if (num2 >= 1f)
			{
				FlameExplode();
				Kill();
			}
		}
	}

	public void FlameExplode(int numToCreate = 5)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + Vector3.up * 0.3f;
		Effect.server.Run(explosionEffect.resourcePath, val, Vector3.up, null, broadcast: true);
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.enabled = false;
		}
		SpawnFireball(val);
		for (int i = 0; i < numToCreate; i++)
		{
			Vector3 val2 = Quaternion.Euler(0f, (float)i / (float)numToCreate * 360f, 0f) * Vector3.forward * 1.8f * Random.Range(0.8f, 1.2f);
			Vector3 spawnPos = val + val2;
			if (GamePhysics.Trace(new Ray(val, val2), 0f, out var hitInfo, ((Vector3)(ref val2)).magnitude, 1237003025, (QueryTriggerInteraction)0))
			{
				spawnPos = ((RaycastHit)(ref hitInfo)).point - ((Vector3)(ref val2)).normalized * 0.5f;
			}
			SpawnFireball(spawnPos);
		}
	}

	private void SpawnFireball(Vector3 spawnPos)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, spawnPos);
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			float num = Random.Range(0f, 360f);
			Quaternion val = Quaternion.Euler(0f, num, 0f);
			((Component)baseEntity).transform.SetPositionAndRotation(spawnPos, val);
			baseEntity.creatorEntity = (((Object)(object)creatorEntity == (Object)null) ? baseEntity : creatorEntity);
			baseEntity.Spawn();
		}
	}

	public static bool SimulatePositionAtTime(Vector3 startPos, Vector3 endPos, float speed, float elapsedTime, out Vector3 pos, float gravity = -9.81f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = endPos - startPos;
		Vector2 val2 = default(Vector2);
		((Vector2)(ref val2))..ctor(val.x, val.z);
		float magnitude = ((Vector2)(ref val2)).magnitude;
		float num;
		Vector3 val3;
		if (magnitude < 0.001f)
		{
			num = 0.25f;
			val3 = Vector3.zero;
		}
		else
		{
			Vector3 val4 = new Vector3(val.x, 0f, val.z);
			val3 = ((Vector3)(ref val4)).normalized;
			num = Mathf.Max(0.0001f, magnitude / speed);
		}
		float num2 = Mathf.Min(elapsedTime, num);
		pos = startPos;
		pos += val3 * (speed * num2);
		float num3 = (endPos.y - startPos.y - 0.5f * gravity * num * num) / num;
		pos.y = startPos.y + num3 * num2 + 0.5f * gravity * num2 * num2;
		return elapsedTime >= num;
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public class NpcGrenadePositionHint : NpcPositionHint
{
	public Transform landingPoint;

	public float apexHeight = 1f;
}


using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

public class NpcLevelScript : TriggerBase, IServerComponent
{
	public List<NpcLevelTrigger> linkedTriggers = new List<NpcLevelTrigger>();

	public List<NpcPositionHint> positionHints = new List<NpcPositionHint>();

	public void OnDrawGizmosSelected()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_031e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0336: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		BoxCollider val = default(BoxCollider);
		foreach (NpcLevelTrigger linkedTrigger in linkedTriggers)
		{
			if (((Behaviour)linkedTrigger).isActiveAndEnabled && ((Component)linkedTrigger).TryGetComponent<BoxCollider>(ref val))
			{
				Gizmos.color = Color.cyan;
				Matrix4x4 matrix = Gizmos.matrix;
				Gizmos.matrix = Matrix4x4.TRS(((Component)val).transform.position, ((Component)val).transform.rotation, ((Component)val).transform.lossyScale);
				Gizmos.DrawWireCube(val.center, val.size);
				Gizmos.matrix = matrix;
			}
		}
		Collider val3 = default(Collider);
		foreach (NpcPositionHint positionHint in positionHints)
		{
			if ((Object)(object)positionHint == (Object)null || !((Behaviour)positionHint).isActiveAndEnabled || positionHint is NpcGrenadePositionHint)
			{
				continue;
			}
			Vector3? val2 = null;
			float num = float.PositiveInfinity;
			foreach (NpcLevelTrigger linkedTrigger2 in linkedTriggers)
			{
				if (!((Object)(object)linkedTrigger2 == (Object)null) && ((Behaviour)linkedTrigger2).isActiveAndEnabled && ((Component)linkedTrigger2).TryGetComponent<Collider>(ref val3))
				{
					Vector3 val4 = val3.ClosestPoint(((Component)positionHint).transform.position);
					Vector3 val5 = val4 - ((Component)positionHint).transform.position;
					float sqrMagnitude = ((Vector3)(ref val5)).sqrMagnitude;
					if (sqrMagnitude < num)
					{
						num = sqrMagnitude;
						val2 = val4;
					}
				}
			}
			Gizmos.color = Color.cyan;
			Gizmos.DrawWireSphere(((Component)positionHint).transform.position, 0.2f);
			Gizmos.DrawLine(((Component)positionHint).transform.position, ((Component)positionHint).transform.position + 1.8f * Vector3.up);
			if (val2.HasValue)
			{
				Gizmos.DrawLine(((Component)positionHint).transform.position + 1.8f * Vector3.up, val2.Value);
			}
		}
		foreach (NpcPositionHint positionHint2 in positionHints)
		{
			if ((Object)(object)positionHint2 == (Object)null || !((Behaviour)positionHint2).isActiveAndEnabled || !(positionHint2 is NpcGrenadePositionHint npcGrenadePositionHint))
			{
				continue;
			}
			Gizmos.color = Color.red;
			Gizmos.DrawWireSphere(((Component)positionHint2).transform.position, 0.2f);
			Gizmos.DrawLine(((Component)positionHint2).transform.position, ((Component)positionHint2).transform.position + 1.8f * Vector3.up);
			if (!((Object)(object)npcGrenadePositionHint.landingPoint == (Object)null))
			{
				Vector3 val6 = ((Component)npcGrenadePositionHint).transform.position + 1.8f * Vector3.up;
				Vector3 position = npcGrenadePositionHint.landingPoint.position;
				Vector3 val7 = Vector3Ex.WithY((val6 + position) * 0.5f, Mathf.Max(val6.y, position.y) + npcGrenadePositionHint.apexHeight);
				int num2 = 20;
				Vector3 val8 = val6;
				for (int i = 1; i <= num2; i++)
				{
					float num3 = (float)i / (float)num2;
					Vector3 val9 = Vector3.Lerp(Vector3.Lerp(val6, val7, num3), Vector3.Lerp(val7, position, num3), num3);
					Gizmos.DrawLine(val8, val9);
					val8 = val9;
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_ScriptedNade : FSMStateBase
{
	public GameObjectRef deployedGrenadePrefab;

	public const string thrownGrenadeKey = "ThrownScriptedNadeRecently";

	private const float explosionRadius = 6f;

	private const float cooldown = 60f;

	private static NavMeshPath _path;

	private NpcBarkComponent _barkComponent;

	private NpcGrenadePositionHint currentHint;

	private static NavMeshPath Path
	{
		get
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Expected O, but got Unknown
			object obj = _path;
			if (obj == null)
			{
				NavMeshPath val = new NavMeshPath();
				_path = val;
				obj = (object)val;
			}
			return (NavMeshPath)obj;
		}
	}

	private NpcBarkComponent BarkComponent => _barkComponent ?? (_barkComponent = ((Component)Owner).GetComponent<NpcBarkComponent>());

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		currentHint = null;
		if (!base.Senses.FindTargetLKP(out var lkp, applyHeightOffset: false, predict: true))
		{
			return EFSMStateStatus.Failure;
		}
		NpcZone npcZone = NpcZone.GetForPoint(Owner, lkp);
		NpcZoneComponent npcZoneComponent = default(NpcZoneComponent);
		if (((Component)Owner).TryGetComponent<NpcZoneComponent>(ref npcZoneComponent) && (Object)(object)npcZoneComponent.zone != (Object)null)
		{
			if ((Object)(object)npcZone == (Object)null)
			{
				npcZone = npcZoneComponent.zone;
			}
			else if ((Object)(object)npcZoneComponent.zone != (Object)(object)npcZone)
			{
				return EFSMStateStatus.Failure;
			}
		}
		if ((Object)(object)npcZone == (Object)null)
		{
			return EFSMStateStatus.Failure;
		}
		PooledList<NpcLevelScript> val = Pool.Get<PooledList<NpcLevelScript>>();
		try
		{
			((Component)npcZone).GetComponentsInChildren<NpcLevelScript>((List<NpcLevelScript>)(object)val);
			if (((List<NpcLevelScript>)(object)val).Count == 0)
			{
				return EFSMStateStatus.Failure;
			}
			PooledList<NpcGrenadePositionHint> val2 = Pool.Get<PooledList<NpcGrenadePositionHint>>();
			try
			{
				BoxCollider val3 = default(BoxCollider);
				foreach (NpcLevelScript item in (List<NpcLevelScript>)(object)val)
				{
					bool flag = false;
					foreach (NpcLevelTrigger linkedTrigger in item.linkedTriggers)
					{
						if (((Behaviour)linkedTrigger).isActiveAndEnabled && ((Component)linkedTrigger).TryGetComponent<BoxCollider>(ref val3) && !(Vector3.Distance(((Collider)val3).ClosestPoint(lkp), lkp) > 2f))
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						continue;
					}
					foreach (NpcPositionHint positionHint in item.positionHints)
					{
						if (((Behaviour)positionHint).isActiveAndEnabled && positionHint is NpcGrenadePositionHint npcGrenadePositionHint && !(Vector3.Distance(((Component)npcGrenadePositionHint.landingPoint).transform.position, lkp) > 6f))
						{
							((List<NpcGrenadePositionHint>)(object)val2).Add(npcGrenadePositionHint);
						}
					}
				}
				if (((List<NpcGrenadePositionHint>)(object)val2).Count == 0)
				{
					return EFSMStateStatus.Failure;
				}
				((List<NpcGrenadePositionHint>)(object)val2).Sort((Comparison<NpcGrenadePositionHint>)delegate(NpcGrenadePositionHint a, NpcGrenadePositionHint b)
				{
					//IL_0006: Unknown result type (might be due to invalid IL or missing references)
					//IL_000c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0011: Unknown result type (might be due to invalid IL or missing references)
					//IL_0016: Unknown result type (might be due to invalid IL or missing references)
					//IL_0027: Unknown result type (might be due to invalid IL or missing references)
					//IL_002d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0032: Unknown result type (might be due to invalid IL or missing references)
					//IL_0037: Unknown result type (might be due to invalid IL or missing references)
					Vector3 val4 = ((Component)a).transform.position - lkp;
					float sqrMagnitude = ((Vector3)(ref val4)).sqrMagnitude;
					val4 = ((Component)b).transform.position - lkp;
					return sqrMagnitude.CompareTo(((Vector3)(ref val4)).sqrMagnitude);
				});
				float num = float.PositiveInfinity;
				NpcGrenadePositionHint npcGrenadePositionHint2 = null;
				foreach (NpcGrenadePositionHint item2 in (List<NpcGrenadePositionHint>)(object)val2)
				{
					if (base.Agent.CalculatePathCustom(((Component)item2).transform.position, Path))
					{
						float pathLength = Path.GetPathLength();
						if (pathLength < num)
						{
							num = pathLength;
							npcGrenadePositionHint2 = item2;
						}
					}
				}
				if ((Object)(object)npcGrenadePositionHint2 == (Object)null)
				{
					return EFSMStateStatus.Failure;
				}
				if (!base.Agent.SetDestination(((Component)npcGrenadePositionHint2).transform.position))
				{
					return EFSMStateStatus.Failure;
				}
				base.Agent.SetSpeed(LimitedTurnNavAgent.Speeds.Run);
				currentHint = npcGrenadePositionHint2;
				return EFSMStateStatus.None;
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (base.Agent.IsFollowingPath)
		{
			return EFSMStateStatus.None;
		}
		NpcGrenade npcGrenade = GameManager.server.CreateEntity(deployedGrenadePrefab.resourcePath, base.Senses.EyePosition, ((Component)Owner).transform.rotation) as NpcGrenade;
		if ((Object)(object)npcGrenade == (Object)null)
		{
			return EFSMStateStatus.Failure;
		}
		npcGrenade.SetCreatorEntity(Owner);
		npcGrenade.grenadeHint = currentHint;
		npcGrenade.Spawn();
		base.Blackboard.Add("ThrownScriptedNadeRecently", 60f);
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetPerceivedAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<BlackboardComponent>().Add("ThrownScriptedNadeRecently", 60f);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		NpcPushHelper.CoordinatePush(Owner);
		return EFSMStateStatus.Success;
	}
}


using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

public class NpcLevelTrigger : TriggerBase, IServerComponent
{
	private HashSet<BasePlayer> playersInside = new HashSet<BasePlayer>();

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (!baseEntity.IsNonNpcPlayer())
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (ent.ToNonNpcPlayer(out var player))
		{
			playersInside.Add(player);
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (ent.ToNonNpcPlayer(out var player))
		{
			playersInside.Remove(player);
		}
	}

	private void OnDrawGizmosSelected()
	{
		NpcLevelScript npcLevelScript = default(NpcLevelScript);
		if (!((Object)(object)((Component)this).transform.parent == (Object)null) && ((Component)((Component)this).transform.parent).TryGetComponent<NpcLevelScript>(ref npcLevelScript))
		{
			npcLevelScript.OnDrawGizmosSelected();
		}
	}

	private void OnValidate()
	{
		NpcLevelScript npcLevelScript = default(NpcLevelScript);
		if (!((Object)(object)((Component)this).transform.parent == (Object)null) && ((Component)((Component)this).transform.parent).TryGetComponent<NpcLevelScript>(ref npcLevelScript) && !npcLevelScript.linkedTriggers.Contains(this))
		{
			npcLevelScript.linkedTriggers.Add(this);
		}
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public class NpcPositionHint : MonoBehaviour, IServerComponent
{
	private void OnDrawGizmosSelected()
	{
		NpcLevelScript npcLevelScript = default(NpcLevelScript);
		if (!((Object)(object)((Component)this).transform.parent == (Object)null) && ((Component)((Component)this).transform.parent).TryGetComponent<NpcLevelScript>(ref npcLevelScript))
		{
			npcLevelScript.OnDrawGizmosSelected();
		}
	}

	private void OnValidate()
	{
		NpcLevelScript npcLevelScript = default(NpcLevelScript);
		if (!((Object)(object)((Component)this).transform.parent == (Object)null) && ((Component)((Component)this).transform.parent).TryGetComponent<NpcLevelScript>(ref npcLevelScript) && !npcLevelScript.positionHints.Contains(this))
		{
			npcLevelScript.positionHints.Add(this);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(WeaponlessShootingComponent), typeof(SenseComponent))]
public class NpcShootingComponent : EntityComponent<BaseEntity>
{
	[SerializeField]
	[Header("Weapon Stats")]
	private GameObjectRef weaponEntityPrefab;

	[SerializeField]
	private float bulletDamage = 20f;

	[SerializeField]
	private float minTimeBetweenAccurateShots = 0.5f;

	[SerializeField]
	private float maxTimeBetweenAccurateShots = 4f;

	[SerializeField]
	private bool fireInBursts = true;

	[SerializeField]
	private Vector3 offset = new Vector3(0.25f, 1.4f, 0.71f);

	[SerializeField]
	private int magazineSizeOverride;

	[SerializeField]
	private float reloadTimeOverride;

	private BaseProjectile _weaponTemplate;

	private const float spreadWhenAccurate = 0.1f;

	private WeaponlessShootingComponent _weapon;

	private SenseComponent _senses;

	private LimitedTurnNavAgent _agent;

	private int currentAmmo;

	private float remainingReloadTime;

	private float remainingTimeBeforeNextShot;

	private float remainingNormTimeBeforeAccurateShot;

	private int? remainingShotsInCurrentBurst;

	public BaseProjectile WeaponTemplate => _weaponTemplate ?? (_weaponTemplate = weaponEntityPrefab.Get().GetComponent<BaseProjectile>());

	private WeaponlessShootingComponent Weapon => _weapon ?? (_weapon = ((Component)this).GetComponent<WeaponlessShootingComponent>());

	private SenseComponent Senses => _senses ?? (_senses = ((Component)this).GetComponent<SenseComponent>());

	private LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)this).GetComponent<LimitedTurnNavAgent>());

	private Vector3 EyePosition => Senses.EyePosition;

	private float minTimeBetweenShots => WeaponTemplate.repeatDelay;

	private float reloadTime
	{
		get
		{
			if (!(reloadTimeOverride > 0f))
			{
				return WeaponTemplate.reloadTime;
			}
			return reloadTimeOverride;
		}
	}

	private int magazineSize
	{
		get
		{
			if (magazineSizeOverride <= 0)
			{
				return WeaponTemplate.primaryMagazine.definition.builtInSize;
			}
			return magazineSizeOverride;
		}
	}

	private float maxEffectiveRange => WeaponTemplate.effectiveRange;

	public bool IsReloading => remainingReloadTime > 0f;

	public bool AllowShooting { get; set; } = true;

	public bool AllowBeingAccurate { get; set; } = true;

	public bool OnlyShootIfTargetIsVisible { get; set; } = true;

	public override void InitShared()
	{
		Reset();
		currentAmmo = magazineSize;
	}

	private void Reset()
	{
		remainingReloadTime = 0f;
		remainingTimeBeforeNextShot = 0f;
		remainingNormTimeBeforeAccurateShot = 1f;
		remainingShotsInCurrentBurst = null;
	}

	private void OnDisable()
	{
		Reset();
	}

	private void Update()
	{
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		if (((Object)(object)base.baseEntity).Is<BaseCombatEntity>(out BaseCombatEntity castedUnityObject) && castedUnityObject.IsDead())
		{
			return;
		}
		Senses.FindTarget(out var target);
		if ((Object)(object)target != (Object)null && Senses.GetVisibilityStatus(target, out var status) && !status.IsAware && status.timeNotVisible > 6f && (float)currentAmmo < (float)magazineSize * 0.5f && TryReload())
		{
			return;
		}
		if (remainingReloadTime > 0f)
		{
			remainingReloadTime -= Time.deltaTime;
			if (remainingReloadTime <= 0f)
			{
				remainingReloadTime = 0f;
				currentAmmo = magazineSize;
			}
			return;
		}
		remainingTimeBeforeNextShot -= Time.deltaTime;
		if ((Object)(object)target == (Object)null)
		{
			Reset();
			return;
		}
		remainingNormTimeBeforeAccurateShot -= Time.deltaTime / GetDesiredTimeBetweenAccurateShotsFor(target);
		if (AllowShooting && remainingTimeBeforeNextShot <= 0f && !Agent.IsSprinting && Senses.FindLKP(target, out var lkp) && Vector3.Angle(((Component)base.baseEntity).transform.forward, Vector3Ex.WithY(lkp - ((Component)base.baseEntity).transform.position, 0f)) < 5f)
		{
			remainingTimeBeforeNextShot += Shoot(target);
			if (remainingTimeBeforeNextShot < 0f)
			{
				remainingTimeBeforeNextShot = 0f;
			}
		}
	}

	private float GetDesiredTimeBetweenAccurateShotsFor(BaseEntity target)
	{
		if (!Senses.GetVisibilityStatus(target, out var status))
		{
			return maxTimeBetweenAccurateShots;
		}
		return Mathx.RemapValClamped(status.Accuracy, 1f, 0f, minTimeBetweenAccurateShots, maxTimeBetweenAccurateShots);
	}

	public bool CanShootFromAt(Vector3 potentialLocation, Vector3 targetLocation, string debugCategory = "shoot trace")
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return !Senses.IsLineOccluded(potentialLocation, targetLocation, 1218519297, debugCategory);
	}

	private float Shoot(BaseEntity target)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcShootingComponent.Shoot", 0);
		try
		{
			if (!Senses.GetVisibilityStatus(target, out var status))
			{
				return 0f;
			}
			if (!Senses.FindLKP(target, out var lkp))
			{
				return 0f;
			}
			Vector3 entityPointToShootAt = GetEntityPointToShootAt(target, lkp);
			Vector3 val2 = entityPointToShootAt;
			bool flag = true;
			if (status.IsVisible && status.IsAware)
			{
				float num = 0.1f;
				float num2 = 0.1f;
				flag = !AllowBeingAccurate || remainingNormTimeBeforeAccurateShot > 0f;
				if (flag)
				{
					Vector3 extents = ((Bounds)(ref target.bounds)).extents;
					num += extents.x;
					num2 += extents.y;
				}
				else
				{
					remainingNormTimeBeforeAccurateShot = 1f;
				}
				val2 += CalculateSpreadOffset(entityPointToShootAt, num, num2);
			}
			else
			{
				if (OnlyShootIfTargetIsVisible || !(status.timeNotVisible < 5f))
				{
					return 0f;
				}
				val2 += CalculateSpreadOffset(entityPointToShootAt);
			}
			Vector3 muzzleEstimatedPositionOnServer = GetMuzzleEstimatedPositionOnServer(lkp);
			if (!flag && !CanShootFromAt(muzzleEstimatedPositionOnServer, val2) && !Senses.FindLKP(target, out val2, applyHeightOffset: true, predict: false, ignoreCrouch: false))
			{
				return 1f;
			}
			Weapon.Shoot(muzzleEstimatedPositionOnServer, val2, bulletDamage);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_Attack"));
			if (status.IsAware && status.IsVisible)
			{
				SingletonComponent<NpcNoiseManager>.Instance.OnNpcWeaponShot(base.baseEntity, target, val2);
			}
			currentAmmo--;
			if (currentAmmo <= 0 && TryReload())
			{
				return 0f;
			}
			if (fireInBursts)
			{
				float distanceRatio = Mathx.RemapValClamped(Vector3.Distance(EyePosition, entityPointToShootAt), 0f, maxEffectiveRange, 0f, 1f);
				if (!remainingShotsInCurrentBurst.HasValue)
				{
					UpdateBurstFire(distanceRatio);
				}
				remainingShotsInCurrentBurst--;
				if (remainingShotsInCurrentBurst <= 0)
				{
					return UpdateBurstFire(distanceRatio);
				}
			}
			return minTimeBetweenShots;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool TryReload()
	{
		if (IsReloading || currentAmmo >= magazineSize)
		{
			return false;
		}
		Reset();
		remainingReloadTime = reloadTime;
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_Reload"));
		return true;
	}

	private Vector3 CalculateSpreadOffset(Vector3 targetPos, float spreadX = 0.1f, float spreadY = 0.1f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = targetPos - EyePosition;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Vector3.up;
		if (Mathf.Abs(Vector3.Dot(normalized, Vector3.up)) > 0.99f)
		{
			val2 = Vector3.right;
		}
		val = Vector3.Cross(normalized, val2);
		Vector3 normalized2 = ((Vector3)(ref val)).normalized;
		val = Vector3.Cross(normalized2, normalized);
		Vector3 normalized3 = ((Vector3)(ref val)).normalized;
		float num = Random.Range(0f, MathF.PI * 2f);
		return normalized2 * Mathf.Cos(num) * spreadX + normalized3 * Mathf.Sin(num) * spreadY;
	}

	private float UpdateBurstFire(float distanceRatio)
	{
		int num = Mathf.Min(10, currentAmmo);
		if (distanceRatio < 0.4f)
		{
			remainingShotsInCurrentBurst = Random.Range(1, num);
			return Random.Range(0.3f, 0.4f);
		}
		if (distanceRatio < 0.75f)
		{
			remainingShotsInCurrentBurst = Random.Range(1, num);
			return Random.Range(0.5f, 1.2f);
		}
		remainingShotsInCurrentBurst = 1;
		return Random.Range(0.5f, 1.5f);
	}

	public static Vector3 GetEntityPointToShootAt(BaseEntity entity, Vector3 entityGroundPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return entityGroundPos + ((Bounds)(ref entity.bounds)).extents.y * Vector3.up;
	}

	public Vector3 GetMuzzleEstimatedPositionOnServer(Vector3 targetGroundPos, bool noZ = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.LookRotation(targetGroundPos - ((Component)base.baseEntity).transform.position);
		if (noZ)
		{
			return ((Component)base.baseEntity).transform.TransformPoint(Vector3Ex.WithZ(offset, 0f));
		}
		Quaternion val2 = Quaternion.Inverse(((Component)base.baseEntity).transform.rotation) * val;
		return ((Component)base.baseEntity).transform.TransformPoint(val2 * Vector3Ex.WithXY(offset, 0f, 0f) + Vector3Ex.WithZ(offset, 0f));
	}
}


using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

public class NpcSleepingComponent : EntityComponent<BaseEntity>, IAISleepable, IServerComponent
{
	public List<Component> componentsToSleep = new List<Component>();

	private bool sleeping;

	private AIInformationZone infoZone;

	public override void InitShared()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		infoZone = AIInformationZone.GetForPoint(((Component)this).transform.position, fallBackToNearest: false);
		if ((Object)(object)infoZone != (Object)null)
		{
			infoZone.RegisterSleepableEntity(this);
		}
	}

	public override void DestroyShared()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)infoZone == (Object)null)
		{
			infoZone = AIInformationZone.GetForPoint(((Component)this).transform.position);
		}
		if ((Object)(object)infoZone != (Object)null)
		{
			infoZone.UnregisterSleepableEntity(this);
		}
		base.DestroyShared();
	}

	bool IAISleepable.AllowedToSleep()
	{
		return true;
	}

	void IAISleepable.SleepAI()
	{
		SetSleeping(newSleeping: true);
	}

	void IAISleepable.WakeAI()
	{
		SetSleeping(newSleeping: false);
	}

	private void SetSleeping(bool newSleeping)
	{
		if (sleeping == newSleeping)
		{
			return;
		}
		sleeping = newSleeping;
		foreach (Component item in componentsToSleep)
		{
			if ((Object)(object)item == (Object)null)
			{
				continue;
			}
			if (item is FSMComponent fSMComponent)
			{
				fSMComponent.SetFsmActive(!newSleeping);
				continue;
			}
			MonoBehaviour val = (MonoBehaviour)(object)((item is MonoBehaviour) ? item : null);
			if (val != null)
			{
				((Behaviour)val).enabled = !newSleeping;
			}
		}
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public class NpcZoneComponent : EntityComponent<BaseEntity>, IServerComponent
{
	private bool hasAbandonnedZone;

	public NpcZone zone { get; private set; }

	public override void InitShared()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (base.baseEntity.isServer)
		{
			zone = NpcZone.GetForPoint(base.baseEntity, base.baseEntity.CenterPoint());
			base.InitShared();
		}
	}

	public void AbandonZone()
	{
		hasAbandonnedZone = true;
	}

	public bool IsPointInsideZone(Vector3 point)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)zone == (Object)null)
		{
			return true;
		}
		if (hasAbandonnedZone)
		{
			return true;
		}
		return zone.IsPointInside(base.baseEntity, point);
	}

	public bool IsInSameZone(BaseEntity other)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)zone == (Object)null || (Object)(object)other == (Object)null)
		{
			return false;
		}
		NpcZoneComponent npcZoneComponent = default(NpcZoneComponent);
		if (((Component)other).TryGetComponent<NpcZoneComponent>(ref npcZoneComponent))
		{
			return (Object)(object)zone == (Object)(object)npcZoneComponent.zone;
		}
		NpcZone forPoint = NpcZone.GetForPoint(other, other.CenterPoint());
		return (Object)(object)zone == (Object)(object)forPoint;
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public class RustNavmeshModifierVolume : MonoBehaviour, IServerComponent
{
	public static SparseGrid<RustNavmeshModifierVolume> AllModifierVolumes = new SparseGrid<RustNavmeshModifierVolume>();

	private void Awake()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		AllModifierVolumes.Add(((Component)this).transform.position, this);
	}

	private void OnDestroy()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		AllModifierVolumes.Remove(((Component)this).transform.position, this);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(BlackboardComponent), typeof(NpcBarkManager))]
[SoftRequireComponent(typeof(NpcZoneComponent), typeof(NPCEncounterTimer), typeof(NpcShootingComponent))]
[SoftRequireComponent(typeof(LimitedTurnNavAgent), typeof(RootMotionPlayer), typeof(SenseComponent))]
public class Scientist2FSM : FSMComponent
{
	public State_PatrolIdle idle = new State_PatrolIdle();

	public State_Patrol patrol = new State_Patrol();

	public State_Search search = new State_Search();

	public State_ScientistRush chase = new State_ScientistRush();

	public State_ScientistDead dead = new State_ScientistDead();

	public State_DogFight dogFight = new State_DogFight();

	public State_MoveToCoverHiddenFromTarget goHide = new State_MoveToCoverHiddenFromTarget();

	public State_MoveToPointWithLosOnTarget popOut = new State_MoveToPointWithLosOnTarget();

	public State_StayInCover stayInCover = new State_StayInCover();

	public State_ScientistSurprised surprised = new State_ScientistSurprised();

	public State_Flank flank = new State_Flank();

	public State_ThrowGrenade throwGrenade = new State_ThrowGrenade();

	public State_ScriptedNade throwScriptedGrenade = new State_ScriptedNade();

	private Trans_Triggerable<HitInfo> HurtTrans;

	private Trans_Triggerable<HitInfo> DeathTrans;

	[NonSerialized]
	public Trans_Triggerable<(BaseEntity, Vector3)> RushPositionTrans;

	[NonSerialized]
	public Trans_Triggerable SearchTrans;

	private NpcBarkComponent _barkComponent;

	private NpcBarkComponent BarkComponent => _barkComponent ?? (_barkComponent = ((Component)base.baseEntity).GetComponent<NpcBarkComponent>());

	public override void InitShared()
	{
		if (base.baseEntity.isServer)
		{
			State_Nothing state_Nothing = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			HurtTrans = new Trans_Triggerable<HitInfo>();
			DeathTrans = new Trans_Triggerable<HitInfo>();
			RushPositionTrans = new Trans_Triggerable<(BaseEntity, Vector3)>();
			SearchTrans = new Trans_Triggerable();
			State_Nothing obj = new State_Nothing
			{
				Name = "Root"
			};
			State_Nothing state_Nothing2 = new State_Nothing
			{
				Name = "Alive"
			};
			State_Nothing state_Nothing3 = new State_Nothing
			{
				Name = "OnNavmesh"
			};
			State_Nothing state_Nothing4 = new State_Nothing
			{
				Name = "No target"
			};
			State_Nothing state_Nothing5 = new State_Nothing
			{
				Name = "Has target"
			};
			State_Nothing state_Nothing6 = new State_Nothing
			{
				Name = "Searching"
			};
			State_Nothing state_Nothing7 = new State_Nothing
			{
				Name = "Ready to assist rush"
			};
			State_Nothing state_Nothing8 = new State_Nothing
			{
				Name = "Looking for grenade opportunities"
			};
			State_Search state_Search = search.Clone() as State_Search;
			state_Search.Name = "SearchPastLKP";
			state_Search.predict = true;
			state_Search.loop = false;
			FSMTransitionBase fSMTransitionBase = ~new Trans_IsReloading();
			Trans_IsReloading trans_IsReloading = new Trans_IsReloading();
			Trans_CanSeeTarget trans_CanSeeTarget = new Trans_CanSeeTarget();
			FSMTransitionBase fSMTransitionBase2 = ~new Trans_CanSeeTarget();
			Trans_And trans_And = new Trans_TargetLkpInRange
			{
				Range = 50f
			} & new Trans_IsTargetLkpInOurZone();
			Trans_Or trans_Or = ~new Trans_TargetLkpInRange
			{
				Range = 50f
			} | ~new Trans_IsTargetLkpInOurZone();
			Trans_And trans_And2 = new Trans_Cooldown
			{
				cooldown = 5f
			} & new Trans_TargetSurprised();
			Trans_And transition = new Trans_Cooldown
			{
				cooldown = 5f
			} & trans_And;
			Trans_And transition2 = new Trans_Cooldown
			{
				cooldown = 5f
			} & fSMTransitionBase2 & (new Trans_TargetIsLowHealth() | (new Trans_TargetIsUndergeared() & trans_And));
			Trans_And transition3 = ~new Trans_HasBlackboardBool
			{
				Key = "ThrownGrenadeRecently"
			} & fSMTransitionBase & new Trans_TargetLost
			{
				minLostDuration = 2f
			} & new Trans_TargetCamping() & ~new Trans_TargetLkpInRange
			{
				Range = 6f
			} & new Trans_TargetLkpInRange
			{
				Range = 50f
			} & new Trans_CanThrowGrenade();
			_ = obj + (state_Nothing2.AddTickTransition(dead, DeathTrans) + state_Nothing.AddTickTransition(patrol, new Trans_IsNavmeshReady()) + (state_Nothing3 + (state_Nothing4.AddTickTransition(surprised, new Trans_HasTarget() & trans_And2).AddTickTransition(dogFight, new Trans_HasTarget() & trans_CanSeeTarget & trans_And).AddTickTransition(goHide, new Trans_HasTarget()) + patrol.AddFailureTransition(dead).AddEndTransition(idle) + idle.AddTickTransition(patrol, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 1.0,
				MaxDuration = 10.0
			})) + (state_Nothing5.AddTickTransition(patrol, ~new Trans_HasTarget()) + (state_Nothing7.AddTickTransition(chase, fSMTransitionBase & RushPositionTrans) + (state_Nothing8.AddTickTransition(throwGrenade, transition3).AddTickTransition(search, SearchTrans & trans_And) + dogFight.AddTickTransition(goHide, trans_Or | (trans_IsReloading & new Trans_Bark
			{
				category = ENPCVoicelineCategory.Reload
			})).AddTickTransition(chase, transition2).AddTickTransition(goHide, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 1.0,
				MaxDuration = 4.0
			})
				.AddFailureTransition(goHide) + goHide.AddTickBranchingTrans(dogFight, trans_CanSeeTarget & fSMTransitionBase & new Trans_TargetInRange
			{
				Range = 3f
			}, surprised, trans_And2).AddTickTransition(chase, transition2).AddFailureTransition(dogFight)
				.AddEndTransition(popOut, new Trans_RandomChance
				{
					Chance = 0.5f
				} & fSMTransitionBase & trans_And)
				.AddEndTransition(stayInCover) + stayInCover.AddTickTransition(goHide, trans_IsReloading & (trans_CanSeeTarget | HurtTrans | (new Trans_IsTargetRunning() & new Trans_TargetInRange
			{
				Range = 20f
			}))).AddTickBranchingTrans(dogFight, fSMTransitionBase & (trans_CanSeeTarget | HurtTrans), surprised, trans_And2).AddTickTransition(popOut, trans_And & fSMTransitionBase & new Trans_ElapsedTimeRandomized
			{
				MinDuration = 5.0,
				MaxDuration = 10.0
			}) + popOut.AddTickBranchingTrans(dogFight, trans_CanSeeTarget, surprised, trans_And2).AddEndTransition(chase, new Trans_RandomChance
			{
				Chance = 0.1f
			} & new Trans_TargetLost() & trans_And).AddEndTransition(flank, transition)
				.AddEndTransition(goHide) + flank.AddTickBranchingTrans(dogFight, trans_CanSeeTarget, surprised, trans_And2).AddFailureTransition(goHide).AddEndTransition(state_Search)) + surprised.AddEndTransition(dogFight, trans_CanSeeTarget & trans_And).AddEndTransition(goHide) + (state_Nothing6.AddTickBranchingTrans(dogFight, trans_CanSeeTarget, surprised, trans_And2).AddTickBranchingTrans(goHide, new Trans_Cooldown
			{
				cooldown = 5f
			} & fSMTransitionBase2 & new Trans_HeardNoise(), chase, trans_And).AddFailureTransition(goHide) + state_Search.AddEndTransition(search, new Trans_Bark
			{
				category = ENPCVoicelineCategory.Search
			}) + search)) + throwGrenade.AddFailureTransition(goHide).AddEndTransition(chase) + throwScriptedGrenade.AddFailureTransition(goHide).AddEndTransition(chase) + chase.AddTickBranchingTrans(dogFight, trans_CanSeeTarget, surprised, trans_And2).AddFailureTransition(goHide).AddEndTransition(state_Search)))) + dead;
			SetState(state_Nothing);
			SetFsmActive(newActive: true);
		}
	}

	public override void Hurt(HitInfo hitInfo)
	{
		HurtTrans.Trigger(hitInfo);
	}

	public override bool OnDied(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
		return false;
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public class Trans_Bark : FSMTransitionBase
{
	public ENPCVoicelineCategory category;

	private NpcBarkComponent _barkComponent;

	private NpcBarkComponent BarkComponent => _barkComponent ?? (_barkComponent = ((Component)Owner).GetComponent<NpcBarkComponent>());

	protected override bool EvaluateInternal()
	{
		return true;
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		BarkComponent.PlayVoicelineFromCategory(category);
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_CanSeeTarget : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_CanSeeTarget", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			if (!base.Senses.GetVisibilityStatus(target, out var status))
			{
				return false;
			}
			return status.IsVisible && status.IsAware;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public class Trans_TargetIsLowHealth : FSMTransitionBase
{
	public float maxHealthFraction = 0.5f;

	public bool requireDamagedByUs = true;

	public float maxTimeSinceDamagedByUs = 5f;

	private WeaponlessShootingComponent _weaponlessShooting;

	private WeaponlessShootingComponent WeaponlessShooting => _weaponlessShooting ?? (_weaponlessShooting = ((Component)Owner).GetComponent<WeaponlessShootingComponent>());

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetIsLowHealth", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			if (!((Object)(object)target).Is<BaseCombatEntity>(out BaseCombatEntity castedUnityObject))
			{
				return false;
			}
			if (requireDamagedByUs)
			{
				return castedUnityObject.healthFraction <= maxHealthFraction && WeaponlessShooting.LastDamagedEntity.IsValid() && (Object)(object)WeaponlessShooting.LastDamagedEntity == (Object)(object)target && WeaponlessShooting.LastDamagedTime.HasValue && Time.timeAsDouble <= WeaponlessShooting.LastDamagedTime + (double)maxTimeSinceDamagedByUs;
			}
			return castedUnityObject.healthFraction <= maxHealthFraction;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public class Trans_TargetLkpInRange : FSMTransitionBase
{
	public float Range = 10f;

	public bool Predict;

	protected override bool EvaluateInternal()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TargetLkpInRange", 0);
		try
		{
			if (!base.Senses.FindTargetLKP(out var lkp, applyHeightOffset: false, Predict))
			{
				return false;
			}
			return Vector3.Distance(((Component)Owner).transform.position, lkp) <= Range;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_TargetLost : FSMTransitionBase
{
	public float minLostDuration = 10f;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetLost", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			if (!base.Senses.GetVisibilityStatus(target, out var status) || status.IsVisible)
			{
				return false;
			}
			return status.timeNotVisible >= minLostDuration;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_IsTargetRunning : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsTargetRunning", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			if (!target.ToNonNpcPlayer(out var player))
			{
				return false;
			}
			return player.IsRunning();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_TargetSurprised : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetSurprised", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return true;
			}
			if (!base.Senses.GetVisibilityStatus(target, out var status))
			{
				return true;
			}
			return status.TryConsumeSurprise();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_TargetCamping : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetCamping", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return true;
			}
			if (!base.Senses.GetVisibilityStatus(target, out var status))
			{
				return true;
			}
			return status.IsCamping;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public class Trans_IsReloading : FSMTransitionBase
{
	private NpcShootingComponent _shooting;

	private NpcShootingComponent Shooting => _shooting ?? (_shooting = ((Component)Owner).GetComponent<NpcShootingComponent>());

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsReloading", 0);
		try
		{
			return Shooting.IsReloading;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public class Trans_IsTargetLkpInOurZone : FSMTransitionBase
{
	private NpcZoneComponent _npcZoneComponent;

	private NpcBarkComponent _barkComponent;

	private NpcZoneComponent NpcZoneComponent => _npcZoneComponent ?? (_npcZoneComponent = ((Component)Owner).GetComponent<NpcZoneComponent>());

	private NpcBarkComponent BarkComponent => _barkComponent ?? (_barkComponent = ((Component)Owner).GetComponent<NpcBarkComponent>());

	protected override bool EvaluateInternal()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsTargetLkpInOurZone", 0);
		try
		{
			if (!base.Senses.FindTargetLKP(out var lkp))
			{
				return false;
			}
			if (NpcZoneComponent.IsPointInsideZone(lkp))
			{
				return true;
			}
			BarkComponent.PlayVoicelineFromCategory(ENPCVoicelineCategory.Hold);
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public class Trans_IsMuzzleClear_Slow : FSMSlowTransitionBase
{
	private NpcShootingComponent _shootingComponent;

	private NpcShootingComponent ShootingComponent => _shootingComponent ?? (_shootingComponent = ((Component)Owner).GetComponent<NpcShootingComponent>());

	protected override bool EvaluateAtInterval()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsMuzzleClear_Slow", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			if (!base.Senses.FindLKP(target, out var lkp))
			{
				return false;
			}
			Vector3 muzzleEstimatedPositionOnServer = ShootingComponent.GetMuzzleEstimatedPositionOnServer(lkp);
			Vector3 entityPointToShootAt = NpcShootingComponent.GetEntityPointToShootAt(target, lkp);
			return ShootingComponent.CanShootFromAt(muzzleEstimatedPositionOnServer, entityPointToShootAt, "muzzle clear");
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

public class Trans_TargetIsUndergeared : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetIsUndergeared", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			if (!target.ToNonNpcPlayer(out var player))
			{
				return false;
			}
			foreach (Item item in player.inventory.containerBelt.itemList)
			{
				if (IsItemHighLevelWeapon(item))
				{
					return false;
				}
			}
			foreach (Item item2 in player.inventory.containerMain.itemList)
			{
				if (IsItemHighLevelWeapon(item2))
				{
					return false;
				}
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool IsItemHighLevelWeapon(Item item)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		ItemMod[] itemMods = item.info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			if (((Object)(object)itemMods[i]).Is<ItemModEntity>(out ItemModEntity castedUnityObject) && ((Object)(object)castedUnityObject.entityPrefab.GetEntity()).Is<BaseProjectile>(out BaseProjectile castedUnityObject2) && (((Enum)castedUnityObject2.primaryMagazine.definition.ammoTypes).HasFlag((Enum)(object)(AmmoTypes)1) || ((Enum)castedUnityObject2.primaryMagazine.definition.ammoTypes).HasFlag((Enum)(object)(AmmoTypes)4) || ((Enum)castedUnityObject2.primaryMagazine.definition.ammoTypes).HasFlag((Enum)(object)(AmmoTypes)2) || ((Enum)castedUnityObject2.primaryMagazine.definition.ammoTypes).HasFlag((Enum)(object)(AmmoTypes)32) || ((Enum)castedUnityObject2.primaryMagazine.definition.ammoTypes).HasFlag((Enum)(object)(AmmoTypes)4096)))
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_Patrol : FSMStateBase
{
	[SerializeField]
	private Vector2 distanceRange = new Vector2(4f, 6f);

	[SerializeField]
	private float homeRadius = 10f;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds speed;

	private NPCHumanoidAnimController _clientAnim;

	private NpcShootingComponent _shooting;

	private NpcZoneComponent _npcZoneComponent;

	private Vector3? spawnPositionNS;

	private Vector3? desiredEndDirection;

	private static NavMeshPath _path;

	private NPCHumanoidAnimController ClientAnim => _clientAnim ?? (_clientAnim = ((Component)Owner).GetComponentInChildren<NPCHumanoidAnimController>());

	private NpcShootingComponent Shooting => _shooting ?? (_shooting = ((Component)Owner).GetComponent<NpcShootingComponent>());

	private NpcZoneComponent NpcZoneComponent => _npcZoneComponent ?? (_npcZoneComponent = ((Component)Owner).GetComponent<NpcZoneComponent>());

	private static NavMeshPath Path
	{
		get
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Expected O, but got Unknown
			object obj = _path;
			if (obj == null)
			{
				NavMeshPath val = new NavMeshPath();
				_path = val;
				obj = (object)val;
			}
			return (NavMeshPath)obj;
		}
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Reset();
		if (!spawnPositionNS.HasValue)
		{
			spawnPositionNS = Owner.ServerNavMeshPos;
		}
		if (!TrySetPatrolDestination())
		{
			return EFSMStateStatus.Failure;
		}
		ClientAnim.IsRelaxed = true;
		ClientAnim.IsAiming = false;
		Shooting.AllowShooting = false;
		return base.OnStateEnter();
	}

	private bool TrySetPatrolDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		Vector3 serverNavMeshPos = Owner.ServerNavMeshPos;
		bool flag = Vector3.Distance(spawnPositionNS.Value, serverNavMeshPos) > homeRadius;
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			float radius = Random.Range(distanceRange.x, distanceRange.y);
			Eqs.SamplePositionsInDonutShape(serverNavMeshPos, (List<Vector3>)(object)val, radius);
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				Vector3 val2 = spawnPositionNS.Value - serverNavMeshPos;
				Vector3 normalized = ((Vector3)(ref val2)).normalized;
				foreach (Vector3 item2 in (List<Vector3>)(object)val)
				{
					float num = 0f;
					if (flag)
					{
						float num2 = num;
						val2 = item2 - serverNavMeshPos;
						num = num2 + Mathx.RemapValClamped(Vector3.Dot(normalized, ((Vector3)(ref val2)).normalized), -1f, 1f, 0f, 1f);
					}
					else
					{
						num += Random.value;
					}
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item2, num));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				Matrix4x4 navMeshToWorldSpace = Owner.NavMeshToWorldSpace;
				foreach (var item3 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item = item3.Item1;
					if (!base.Agent.SamplePosition(item, out var sample, 3.5f))
					{
						continue;
					}
					Vector3 val3 = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyPoint(sample);
					if (!NpcZoneComponent.IsPointInsideZone(val3) || base.Agent.IsInWater(val3) || !base.Agent.CalculatePathCustom(sample, Path))
					{
						continue;
					}
					if ((int)Path.status != 0)
					{
						Vector3 val4 = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyPoint(Path.GetDestination());
						if (!NpcZoneComponent.IsPointInsideZone(val4) || base.Agent.IsInWater(val4))
						{
							continue;
						}
					}
					base.Agent.SetPath(Path);
					base.Agent.SetSpeed(speed);
					if (base.Agent.lastValidPath.Count >= 2)
					{
						List<Vector3> lastValidPath = base.Agent.lastValidPath;
						Vector3 val5 = lastValidPath[lastValidPath.Count - 1];
						List<Vector3> lastValidPath2 = base.Agent.lastValidPath;
						Vector3 val6 = Vector3Ex.NormalizeXZ(val5 - lastValidPath2[lastValidPath2.Count - 2]) * 3f;
						Vector3 direction = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyVector(val6);
						List<Vector3> lastValidPath3 = base.Agent.lastValidPath;
						Vector3 val7 = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyPoint(lastValidPath3[lastValidPath3.Count - 1]);
						if (base.Senses.Trace(val7 + base.Senses.EyeOffset, direction, out var hitInfo, 1218519041, "patrol"))
						{
							desiredEndDirection = Vector3Ex.WithY(((RaycastHit)(ref hitInfo)).normal, 0f);
						}
					}
					return true;
				}
				return false;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Agent.IsFollowingPath)
		{
			return EFSMStateStatus.Success;
		}
		if (desiredEndDirection.HasValue && !base.Agent.overrideDirection.HasValue && base.Agent.RemainingDistance < 2.5f)
		{
			base.Agent.overrideDirection = desiredEndDirection.Value;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		ClientAnim.IsRelaxed = false;
		ClientAnim.IsAiming = true;
		Shooting.AllowShooting = true;
		desiredEndDirection = null;
		base.Agent.overrideDirection = null;
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	private void Reset()
	{
		base.Senses.ClearTarget();
		base.Blackboard.Clear();
		if (Owner is BaseCombatEntity { healthFraction: <1f, SecondsSinceAttacked: >120f } baseCombatEntity)
		{
			baseCombatEntity.SetHealth(Owner.MaxHealth());
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PatrolIdle : FSMStateBase
{
	private NPCHumanoidAnimController _clientAnim;

	private NpcShootingComponent _shooting;

	private NPCHumanoidAnimController ClientAnim => _clientAnim ?? (_clientAnim = ((Component)Owner).GetComponentInChildren<NPCHumanoidAnimController>());

	private NpcShootingComponent Shooting => _shooting ?? (_shooting = ((Component)Owner).GetComponent<NpcShootingComponent>());

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		ClientAnim.IsRelaxed = true;
		ClientAnim.IsAiming = false;
		Shooting.AllowShooting = false;
		base.Agent.overrideDirection = ((Component)Owner).transform.forward;
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		ClientAnim.IsRelaxed = false;
		ClientAnim.IsAiming = true;
		Shooting.AllowShooting = true;
		base.Agent.overrideDirection = null;
		base.OnStateExit();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_ScientistDead : State_Dead
{
	public GameObjectRef DeathEffect;

	private NpcBarkComponent _barkComponent;

	private NpcBarkComponent BarkComponent => _barkComponent ?? (_barkComponent = ((Component)Owner).GetComponent<NpcBarkComponent>());

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (DeathEffect != null)
		{
			Effect.server.Run(DeathEffect.resourcePath, ((Component)Owner).transform.position, Vector3.up);
		}
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_Flank : FSMStateBase
{
	public LimitedTurnNavAgent.Speeds speed;

	private NPCHumanoidAnimController _clientAnim;

	private NpcBarkComponent _barkComponent;

	private NavMeshPath _pathToLkp;

	private NavMeshPath _pathToFlank;

	private NavMeshPath _pathFromFlankToEnemy;

	private bool isOnSecondPath;

	private const int MaxCorners = 128;

	private static Vector3[] bufferA = (Vector3[])(object)new Vector3[128];

	private static Vector3[] bufferB = (Vector3[])(object)new Vector3[128];

	private NPCHumanoidAnimController ClientAnim => _clientAnim ?? (_clientAnim = ((Component)Owner).GetComponentInChildren<NPCHumanoidAnimController>());

	private NpcBarkComponent BarkComponent => _barkComponent ?? (_barkComponent = ((Component)Owner).GetComponent<NpcBarkComponent>());

	private NavMeshPath PathToLkp
	{
		get
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Expected O, but got Unknown
			//IL_0017: Expected O, but got Unknown
			NavMeshPath obj = _pathToLkp;
			if (obj == null)
			{
				NavMeshPath val = new NavMeshPath();
				NavMeshPath val2 = val;
				_pathToLkp = val;
				obj = val2;
			}
			return obj;
		}
	}

	private NavMeshPath PathToFlank
	{
		get
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Expected O, but got Unknown
			//IL_0017: Expected O, but got Unknown
			NavMeshPath obj = _pathToFlank;
			if (obj == null)
			{
				NavMeshPath val = new NavMeshPath();
				NavMeshPath val2 = val;
				_pathToFlank = val;
				obj = val2;
			}
			return obj;
		}
	}

	private NavMeshPath PathFromFlankToEnemy
	{
		get
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Expected O, but got Unknown
			//IL_0017: Expected O, but got Unknown
			NavMeshPath obj = _pathFromFlankToEnemy;
			if (obj == null)
			{
				NavMeshPath val = new NavMeshPath();
				NavMeshPath val2 = val;
				_pathFromFlankToEnemy = val;
				obj = val2;
			}
			return obj;
		}
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetLKP(out var lkp, applyHeightOffset: false, predict: true))
		{
			return EFSMStateStatus.Failure;
		}
		Matrix4x4 worldToNavMeshSpace = Owner.WorldToNavMeshSpace;
		Vector3 position = ((Matrix4x4)(ref worldToNavMeshSpace)).MultiplyPoint(lkp);
		if (!base.Agent.SamplePosition(position, out var sample, 3.5f))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Agent.CalculatePathCustom(sample, PathToLkp) && (int)PathToLkp.status != 0)
		{
			return EFSMStateStatus.Failure;
		}
		if (!NPCFlankSpot.Find(base.Agent, sample, PathToLkp, PathToFlank, PathFromFlankToEnemy))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Agent.SetPath(PathToFlank))
		{
			return EFSMStateStatus.Failure;
		}
		if (speed == LimitedTurnNavAgent.Speeds.Sneak)
		{
			ClientAnim.IsCrouching = true;
		}
		base.Agent.SetSpeed(speed);
		isOnSecondPath = false;
		BarkComponent.PlayVoicelineFromCategory(ENPCVoicelineCategory.Flank);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Agent.IsFollowingPath)
		{
			if (isOnSecondPath)
			{
				return EFSMStateStatus.Success;
			}
			isOnSecondPath = true;
			if (!base.Senses.FindTarget(out var _))
			{
				return EFSMStateStatus.Failure;
			}
			if (!base.Agent.SetPath(PathFromFlankToEnemy))
			{
				return EFSMStateStatus.Failure;
			}
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		ClientAnim.IsCrouching = false;
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	public static float ComputePathsInitialSimilarity(NavMeshPath pathA, NavMeshPath pathB)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ComputePathDistance", 0);
		try
		{
			int cornersNonAlloc = pathA.GetCornersNonAlloc(bufferA);
			int cornersNonAlloc2 = pathB.GetCornersNonAlloc(bufferB);
			int num = Mathf.Min(cornersNonAlloc, cornersNonAlloc2);
			float num2 = 0f;
			for (int i = 0; i + 1 < num && !(bufferA[i] != bufferB[i]) && !(bufferA[i + 1] != bufferB[i + 1]); i++)
			{
				num2 += Vector3.Distance(bufferA[i], bufferA[i + 1]);
			}
			return num2 / Mathf.Min(GetPathLength(bufferA, cornersNonAlloc), GetPathLength(bufferB, cornersNonAlloc2));
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetPathLength(Vector3[] buffer, int count)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		if (count < 2)
		{
			return num;
		}
		for (int i = 0; i < count - 1; i++)
		{
			num += Vector3.Distance(buffer[i], buffer[i + 1]);
		}
		return num;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_ScientistRush : State_MoveToTarget, IParametrized<(BaseEntity, Vector3)>
{
	public bool useSuppressiveFire;

	private NpcZoneComponent _npcZoneComponent;

	private NpcShootingComponent _shooting;

	private (BaseEntity, Vector3)? assistRequest;

	private NpcZoneComponent NpcZoneComponent => _npcZoneComponent ?? (_npcZoneComponent = ((Component)Owner).GetComponent<NpcZoneComponent>());

	private NpcShootingComponent Shooting => _shooting ?? (_shooting = ((Component)Owner).GetComponent<NpcShootingComponent>());

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		destination = default(Vector3);
		if (!base.Senses.FindTargetLKP(out var lkp, applyHeightOffset: false, predict: true))
		{
			return false;
		}
		Matrix4x4 worldToNavMeshSpace = Owner.WorldToNavMeshSpace;
		Vector3 position = ((Matrix4x4)(ref worldToNavMeshSpace)).MultiplyPoint(lkp);
		if (!base.Agent.SamplePosition(position, out var sample, 3.5f) && !base.Agent.SamplePosition(position, out sample, 20f))
		{
			return false;
		}
		destination = sample;
		return true;
	}

	void IParametrized<(BaseEntity, Vector3)>.SetParameter((BaseEntity, Vector3) parameter)
	{
		assistRequest = parameter;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Shooting.OnlyShootIfTargetIsVisible = !useSuppressiveFire;
		if (assistRequest.HasValue)
		{
			BaseEntity item = assistRequest.Value.Item1;
			Vector3 item2 = assistRequest.Value.Item2;
			base.Senses.SimulateSighting(item, item2);
			base.Senses.TrySetTarget(item);
		}
		else
		{
			NpcPushHelper.CoordinatePush(Owner);
		}
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (useSuppressiveFire && base.Senses.FindTargetLKP(out var lkp, applyHeightOffset: true, predict: true))
		{
			if (!base.Senses.IsLineOccluded(base.Senses.EyePosition, lkp, 1218519041))
			{
				LimitedTurnNavAgent agent = base.Agent;
				Vector3 val = lkp - base.Senses.EyePosition;
				agent.overrideDirection = ((Vector3)(ref val)).normalized;
				Shooting.OnlyShootIfTargetIsVisible = true;
			}
			else
			{
				base.Agent.overrideDirection = null;
				Shooting.OnlyShootIfTargetIsVisible = false;
			}
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (!NpcZoneComponent.IsPointInsideZone(((Component)Owner).transform.position))
		{
			NpcZoneComponent.AbandonZone();
		}
		Shooting.OnlyShootIfTargetIsVisible = true;
		base.Agent.overrideDirection = null;
		assistRequest = null;
		base.OnStateExit();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Search : FSMStateBase
{
	[SerializeField]
	private float searchRadius = 10f;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds speed;

	[SerializeField]
	private int numCloseSearchesBeforeExpanding = 2;

	public bool predict;

	public bool loop = true;

	private NPCHumanoidAnimController _clientAnim;

	private NpcBarkComponent _barkComponent;

	private Vector3 searchOriginNS;

	private int numIterations;

	private NPCHumanoidAnimController ClientAnim => _clientAnim ?? (_clientAnim = ((Component)Owner).GetComponentInChildren<NPCHumanoidAnimController>());

	private NpcBarkComponent BarkComponent => _barkComponent ?? (_barkComponent = ((Component)Owner).GetComponent<NpcBarkComponent>());

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Senses.FindLKP(target, out var lkp, applyHeightOffset: false, predict: true))
		{
			return EFSMStateStatus.Failure;
		}
		Matrix4x4 worldToNavMeshSpace = Owner.WorldToNavMeshSpace;
		Vector3 position = ((Matrix4x4)(ref worldToNavMeshSpace)).MultiplyPoint(lkp);
		if (!base.Agent.SamplePosition(position, out var sample, 3.5f) && !base.Agent.SamplePosition(position, out sample, 20f))
		{
			return EFSMStateStatus.Failure;
		}
		searchOriginNS = sample;
		if (!TrySetSearchDestination())
		{
			return EFSMStateStatus.Failure;
		}
		if (predict)
		{
			BarkComponent.PlayVoicelineFromCategory(ENPCVoicelineCategory.Lost);
		}
		if (!predict)
		{
			PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				base.Senses.GetPerceivedAllies((List<BaseEntity>)(object)val);
				Scientist2FSM scientist2FSM = default(Scientist2FSM);
				SenseComponent senseComponent = default(SenseComponent);
				foreach (BaseEntity item in (List<BaseEntity>)(object)val)
				{
					if (((Component)item).TryGetComponent<Scientist2FSM>(ref scientist2FSM) && ((Component)item).TryGetComponent<SenseComponent>(ref senseComponent) && senseComponent.FindTarget(out var target2) && !((Object)(object)target2 != (Object)(object)target))
					{
						scientist2FSM.SearchTrans.Trigger();
					}
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		return base.OnStateEnter();
	}

	private bool TrySetSearchDestination()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			if (numIterations < numCloseSearchesBeforeExpanding)
			{
				Eqs.SamplePositionsInMultiDonutShape(searchOriginNS, (List<Vector3>)(object)val, searchRadius, searchRadius * 0.5f, 2);
			}
			else
			{
				Eqs.SamplePositionsInDonutShape(Owner.ServerNavMeshPos, (List<Vector3>)(object)val, searchRadius);
			}
			if (!base.Senses.FindTargetLKP(out var lkp, applyHeightOffset: false, predict: true))
			{
				return false;
			}
			if (!base.Senses.FindTargetLKP(out var lkp2, applyHeightOffset: false, predict: true))
			{
				return false;
			}
			Matrix4x4 worldToNavMeshSpace = Owner.WorldToNavMeshSpace;
			Vector3 val2 = ((Matrix4x4)(ref worldToNavMeshSpace)).MultiplyPoint(lkp);
			((Matrix4x4)(ref worldToNavMeshSpace)).MultiplyPoint(lkp2);
			Vector3 val3 = ((Matrix4x4)(ref worldToNavMeshSpace)).MultiplyVector(((Component)Owner).transform.forward);
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				PooledList<ScientistNPC2> val4 = Pool.Get<PooledList<ScientistNPC2>>();
				try
				{
					BaseEntity.Query.Server.GetBrainsInSphere(((Component)Owner).transform.position, searchRadius * 3f, (List<ScientistNPC2>)(object)val4);
					LimitedTurnNavAgent limitedTurnNavAgent = default(LimitedTurnNavAgent);
					foreach (Vector3 item2 in (List<Vector3>)(object)val)
					{
						float num = 0f;
						if (predict)
						{
							num += Mathx.RemapValClamped(Vector3.Dot(val3, Vector3Ex.NormalizeXZ(item2 - val2)), -1f, 1f, 0f, 1f) * 3f;
							num += Mathx.RemapValClamped(Vector3.Distance(item2, val2), 0f, searchRadius, 0f, 1f);
						}
						else
						{
							foreach (ScientistNPC2 item3 in (List<ScientistNPC2>)(object)val4)
							{
								if (!((Object)(object)item3 == (Object)(object)Owner))
								{
									num = ((!((Component)item3).TryGetComponent<LimitedTurnNavAgent>(ref limitedTurnNavAgent) || !limitedTurnNavAgent.IsFollowingPath || !limitedTurnNavAgent.lastValidDestination.HasValue) ? (num + Vector3.Distance(item3.ServerNavMeshPos, item2)) : (num + Vector3.Distance(limitedTurnNavAgent.lastValidDestination.Value, item2)));
								}
							}
							num += Random.value * 0.01f;
						}
						((List<(Vector3, float)>)(object)pooledScoreList).Add((item2, num));
					}
					pooledScoreList.SortByScoreDesc(Owner);
					Matrix4x4 navMeshToWorldSpace = Owner.NavMeshToWorldSpace;
					foreach (var item4 in (List<(Vector3, float)>)(object)pooledScoreList)
					{
						Vector3 item = item4.Item1;
						if (base.Agent.SamplePosition(item, out var sample, 3.5f))
						{
							Vector3 position = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyPoint(sample);
							if (!base.Agent.IsInWater(position) && !(Vector3.Distance(sample, Owner.ServerNavMeshPos) < 2f) && base.Agent.SetDestination(sample))
							{
								numIterations++;
								ClientAnim.IsCrouching = speed == LimitedTurnNavAgent.Speeds.Sneak;
								base.Agent.SetSpeed(speed);
								return true;
							}
						}
					}
					return false;
				}
				finally
				{
					((IDisposable)val4)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (base.Agent.lastValidDestination.HasValue)
		{
			Vector3 val = base.Agent.lastValidDestination.Value - Owner.ServerNavMeshPos;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			Matrix4x4 navMeshToWorldSpace = Owner.NavMeshToWorldSpace;
			base.Agent.overrideDirection = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyVector(normalized);
		}
		if (!base.Agent.IsFollowingPath)
		{
			if (!loop)
			{
				return EFSMStateStatus.Success;
			}
			if (!TrySetSearchDestination())
			{
				return EFSMStateStatus.Failure;
			}
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		numIterations = 0;
		base.Agent.ResetPath();
		base.Agent.overrideDirection = null;
		ClientAnim.IsCrouching = false;
		base.OnStateExit();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_DogFight : FSMStateBase
{
	private bool shouldGoRightNext;

	public override EFSMStateStatus OnStateEnter()
	{
		if (CalculatePathDestination() == EFSMStateStatus.Failure)
		{
			return EFSMStateStatus.Failure;
		}
		base.Agent.shouldStopAtDestination = false;
		shouldGoRightNext = Random.value > 0.5f;
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (base.Agent.IsFollowingPath)
		{
			return base.OnStateUpdate(deltaTime);
		}
		if (CalculatePathDestination() == EFSMStateStatus.Failure)
		{
			return EFSMStateStatus.Failure;
		}
		return EFSMStateStatus.None;
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	private EFSMStateStatus CalculatePathDestination()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 position = ((Component)Owner).transform.position;
		Vector3 val = targetPosition - position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 normalized2;
		if (!shouldGoRightNext)
		{
			val = Vector3.Cross(Vector3.up, normalized);
			normalized2 = ((Vector3)(ref val)).normalized;
		}
		else
		{
			val = Vector3.Cross(normalized, Vector3.up);
			normalized2 = ((Vector3)(ref val)).normalized;
		}
		Vector3 val2 = normalized2;
		shouldGoRightNext = !shouldGoRightNext;
		Vector3 val3 = Quaternion.AngleAxis(Random.Range(-50f, 50f), Vector3.up) * val2;
		float radius;
		if (Random.value > 0.95f && Vector3.Distance(targetPosition, position) > 8f)
		{
			radius = Random.Range(3f, 4f);
			base.Agent.SetSpeed(LimitedTurnNavAgent.Speeds.Sprint);
		}
		else
		{
			radius = Random.Range(1f, 2f);
			base.Agent.SetSpeed(LimitedTurnNavAgent.Speeds.Walk);
		}
		PooledList<Vector3> val4 = Pool.Get<PooledList<Vector3>>();
		try
		{
			Eqs.SamplePositionsInDonutShape(position, (List<Vector3>)(object)val4, radius);
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				foreach (Vector3 item3 in (List<Vector3>)(object)val4)
				{
					val = item3 - position;
					float item = Mathx.RemapValClamped(Vector3.Dot(val3, ((Vector3)(ref val)).normalized), -1f, 1f, 0f, 1f);
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item3, item));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				Matrix4x4 worldToNavMeshSpace = Owner.WorldToNavMeshSpace;
				Matrix4x4 navMeshToWorldSpace = Owner.NavMeshToWorldSpace;
				foreach (var item4 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item2 = item4.Item1;
					Vector3 position2 = ((Matrix4x4)(ref worldToNavMeshSpace)).MultiplyPoint(item2);
					if (base.Agent.SamplePosition(position2, out var sample, 3.5f))
					{
						Vector3 position3 = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyPoint(sample);
						if (!base.Agent.IsInWater(position3) && base.Agent.SetDestination(sample))
						{
							return EFSMStateStatus.None;
						}
					}
				}
				return EFSMStateStatus.Failure;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val4)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_MoveToCoverHiddenFromTarget : FSMStateBase
{
	public float searchRadius = 8f;

	public float walkDurationBeforeSprint = 1f;

	public LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.Walk;

	private static NavMeshPath _path;

	private NpcShootingComponent _shooting;

	private NpcZoneComponent _npcZoneComponent;

	private double? remainingWalkBeforeSprintTime;

	private Vector3? lastChosenHidingSpotNS;

	private AIInformationZone _infoZone;

	private AICoverPoint heldCover;

	private static NavMeshPath Path
	{
		get
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Expected O, but got Unknown
			object obj = _path;
			if (obj == null)
			{
				NavMeshPath val = new NavMeshPath();
				_path = val;
				obj = (object)val;
			}
			return (NavMeshPath)obj;
		}
	}

	private NpcShootingComponent Shooting => _shooting ?? (_shooting = ((Component)Owner).GetComponent<NpcShootingComponent>());

	private NpcZoneComponent NpcZoneComponent => _npcZoneComponent ?? (_npcZoneComponent = ((Component)Owner).GetComponent<NpcZoneComponent>());

	private AIInformationZone InfoZone => _infoZone ?? (_infoZone = AIInformationZone.GetForPoint(((Component)Owner).transform.position));

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetLKP(out var lkp, applyHeightOffset: true))
		{
			return EFSMStateStatus.Failure;
		}
		Matrix4x4 worldToNavMeshSpace = Owner.WorldToNavMeshSpace;
		Vector3 val = ((Matrix4x4)(ref worldToNavMeshSpace)).MultiplyPoint(lkp);
		Vector3 serverNavMeshPos = Owner.ServerNavMeshPos;
		PooledList<Vector3> val2 = Pool.Get<PooledList<Vector3>>();
		try
		{
			Eqs.SamplePositionsInMultiDonutShape(serverNavMeshPos, (List<Vector3>)(object)val2, searchRadius * 0.5f, searchRadius, 2);
			float num = Vector3.Distance(val, serverNavMeshPos);
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				NavMeshAgent val3 = default(NavMeshAgent);
				NavMeshHit val4 = default(NavMeshHit);
				foreach (Vector3 item2 in (List<Vector3>)(object)val2)
				{
					float num2 = 0f;
					if (num < 20f)
					{
						num2 += Mathx.RemapValClamped(Vector3.Distance(item2, val), 0f, searchRadius, 0f, 1f);
					}
					else if (num > 50f)
					{
						num2 += Mathx.RemapValClamped(Vector3.Distance(item2, val), 0f, searchRadius, 0f, 1f);
					}
					else if (lastChosenHidingSpotNS.HasValue)
					{
						num2 += Mathx.RemapValClamped(Vector3.Distance(item2, lastChosenHidingSpotNS.Value), 0f, searchRadius, 0f, 1f);
					}
					if (((Component)Owner).TryGetComponent<NavMeshAgent>(ref val3) && val3.FindClosestEdge(ref val4) && Vector3.Distance(((NavMeshHit)(ref val4)).position, Owner.ServerNavMeshPos) < 1.5f)
					{
						num2 += 2f;
					}
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item2, num2));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				Matrix4x4 navMeshToWorldSpace = Owner.NavMeshToWorldSpace;
				foreach (var item3 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item = item3.Item1;
					if (!base.Agent.SamplePosition(item, out var sample, 3.5f))
					{
						continue;
					}
					Vector3 val5 = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyPoint(sample);
					if (NpcZoneComponent.IsPointInsideZone(val5) && !base.Agent.IsInWater(val5) && !base.Senses.CanBeSeenAtFrom(val5 + 1.1f * Vector3.up, lkp, "navigation") && base.Agent.CalculatePathCustom(sample, Path) && (int)Path.status == 0)
					{
						float pathLength = Path.GetPathLength();
						if (!(pathLength < 0.5f) && !(pathLength > searchRadius * 3f) && base.Agent.SetDestination(sample))
						{
							base.Agent.SetSpeed(speed);
							remainingWalkBeforeSprintTime = walkDurationBeforeSprint;
							lastChosenHidingSpotNS = sample;
							return base.OnStateEnter();
						}
					}
				}
				if ((Object)(object)InfoZone == (Object)null)
				{
					return EFSMStateStatus.Failure;
				}
				AICoverPoint bestCoverPoint = InfoZone.GetBestCoverPoint(((Component)Owner).transform.position, lkp, 0f, searchRadius, Owner);
				if ((Object)(object)bestCoverPoint != (Object)null && NpcZoneComponent.IsPointInsideZone(((Component)bestCoverPoint).transform.position))
				{
					Vector3 newDestination = ((Matrix4x4)(ref worldToNavMeshSpace)).MultiplyPoint(((Component)bestCoverPoint).transform.position);
					if (base.Agent.SetDestination(newDestination))
					{
						heldCover = bestCoverPoint;
						heldCover.SetUsedBy(Owner);
						base.Agent.SetSpeed(speed);
						remainingWalkBeforeSprintTime = walkDurationBeforeSprint;
						return base.OnStateEnter();
					}
				}
				return EFSMStateStatus.Failure;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Agent.IsFollowingPath)
		{
			return EFSMStateStatus.Success;
		}
		if (remainingWalkBeforeSprintTime.HasValue)
		{
			remainingWalkBeforeSprintTime -= deltaTime;
			if (remainingWalkBeforeSprintTime <= 0.0)
			{
				base.Agent.SetSpeed(LimitedTurnNavAgent.Speeds.Sprint);
				remainingWalkBeforeSprintTime = null;
			}
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		if ((Object)(object)heldCover != (Object)null)
		{
			heldCover.ClearIfUsedBy(Owner);
			heldCover = null;
		}
		remainingWalkBeforeSprintTime = null;
		base.Agent.ResetPath();
		base.OnStateExit();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_MoveToPointWithLosOnTarget : FSMStateBase
{
	public float searchRadius = 8f;

	private static NavMeshPath _path;

	private NpcZoneComponent _npcZoneComponent;

	private NpcShootingComponent _shooting;

	private Vector3? lastChosenPeekNS;

	private static NavMeshPath Path
	{
		get
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Expected O, but got Unknown
			object obj = _path;
			if (obj == null)
			{
				NavMeshPath val = new NavMeshPath();
				_path = val;
				obj = (object)val;
			}
			return (NavMeshPath)obj;
		}
	}

	private NpcZoneComponent NpcZoneComponent => _npcZoneComponent ?? (_npcZoneComponent = ((Component)Owner).GetComponent<NpcZoneComponent>());

	private NpcShootingComponent Shooting => _shooting ?? (_shooting = ((Component)Owner).GetComponent<NpcShootingComponent>());

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Senses.FindLKP(target, out var lkp, applyHeightOffset: true))
		{
			return EFSMStateStatus.Failure;
		}
		SenseComponent.VisibilityStatus status;
		bool flag = NpcZoneComponent.IsPointInsideZone(lkp) || (base.Senses.GetVisibilityStatus(target, out status) && status.timeNotVisible < 30f);
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			Vector3 serverNavMeshPos = Owner.ServerNavMeshPos;
			if (flag)
			{
				Eqs.SamplePositionsInMultiDonutShape(serverNavMeshPos, (List<Vector3>)(object)val, searchRadius * 0.5f, searchRadius, 2);
			}
			else
			{
				Eqs.SamplePositionsInMultiDonutShape(serverNavMeshPos, (List<Vector3>)(object)val, searchRadius, searchRadius, 1, 4);
			}
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				foreach (Vector3 item2 in (List<Vector3>)(object)val)
				{
					float num = 0f;
					if (lastChosenPeekNS.HasValue)
					{
						num += Mathx.RemapValClamped(Vector3.Distance(item2, lastChosenPeekNS.Value), 0f, searchRadius, 0f, 1f);
					}
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item2, num));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				_ = Owner.WorldToNavMeshSpace;
				Matrix4x4 navMeshToWorldSpace = Owner.NavMeshToWorldSpace;
				foreach (var item3 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item = item3.Item1;
					if (base.Agent.SamplePosition(item, out var sample, 3.5f))
					{
						Vector3 val2 = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyPoint(sample);
						if (NpcZoneComponent.IsPointInsideZone(val2) && (!lastChosenPeekNS.HasValue || !(Vector3.Distance(sample, lastChosenPeekNS.Value) < 2f)) && !base.Agent.IsInWater(val2) && Shooting.CanShootFromAt(val2 + base.Senses.EyeOffset, lkp, "navigation") && base.Agent.CalculatePathCustom(sample, Path) && (int)Path.status == 0 && !(Path.GetPathLength() > searchRadius * 3f) && base.Agent.SetDestination(sample))
						{
							base.Agent.SetSpeed(LimitedTurnNavAgent.Speeds.Walk);
							lastChosenPeekNS = sample;
							return base.OnStateEnter();
						}
					}
				}
				return EFSMStateStatus.Failure;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Agent.IsFollowingPath)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_StayInCover : FSMStateBase
{
	private NPCHumanoidAnimController _clientAnim;

	private NavMeshPath _pathToLkp;

	private NPCHumanoidAnimController ClientAnim => _clientAnim ?? (_clientAnim = ((Component)Owner).GetComponentInChildren<NPCHumanoidAnimController>());

	private NavMeshPath PathToLkp
	{
		get
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Expected O, but got Unknown
			//IL_0017: Expected O, but got Unknown
			NavMeshPath obj = _pathToLkp;
			if (obj == null)
			{
				NavMeshPath val = new NavMeshPath();
				NavMeshPath val2 = val;
				_pathToLkp = val;
				obj = val2;
			}
			return obj;
		}
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 position = ((Component)Owner).transform.position;
		if (base.Senses.FindLKP(target, out var lkp, applyHeightOffset: true) && (base.Senses.CanBeSeenAtFrom(position + 1.1f * Vector3.up, lkp, "navigation") || base.Senses.CanBeSeenAtFrom(position + 0.1f * Vector3.up, lkp, "navigation")))
		{
			return EFSMStateStatus.Failure;
		}
		ClientAnim.IsCrouching = true;
		Matrix4x4 navMeshToWorldSpace = Owner.NavMeshToWorldSpace;
		Vector3 val3;
		if (base.Senses.FindLKP(target, out var lkp2) && Vector3.Distance(lkp2, position) < 40f && Mathf.Abs(lkp2.y - position.y) < 10f)
		{
			Matrix4x4 worldToNavMeshSpace = Owner.WorldToNavMeshSpace;
			Vector3 position2 = ((Matrix4x4)(ref worldToNavMeshSpace)).MultiplyPoint(lkp2);
			if (base.Agent.SamplePosition(position2, out var sample, 3.5f) && base.Agent.CalculatePathCustom(sample, PathToLkp))
			{
				PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
				try
				{
					PathToLkp.GetCornersNonAllocAsList((List<Vector3>)(object)val);
					if (((List<Vector3>)(object)val).Count >= 2)
					{
						Vector3 val2 = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyPoint(((List<Vector3>)(object)val)[1]);
						LimitedTurnNavAgent agent = base.Agent;
						val3 = val2 - position;
						agent.overrideDirection = ((Vector3)(ref val3)).normalized;
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
		}
		if (!base.Agent.overrideDirection.HasValue && base.Agent.lastValidPath.Count >= 2)
		{
			List<Vector3> lastValidPath = base.Agent.lastValidPath;
			Vector3 val4 = lastValidPath[lastValidPath.Count - 1];
			List<Vector3> lastValidPath2 = base.Agent.lastValidPath;
			val3 = val4 - lastValidPath2[lastValidPath2.Count - 2];
			Vector3 normalized = ((Vector3)(ref val3)).normalized;
			Vector3 value = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyVector(normalized);
			base.Agent.overrideDirection = value;
			val3 = lkp - base.Senses.EyePosition;
			Vector3 normalized2 = ((Vector3)(ref val3)).normalized;
			if (Vector3.Dot(base.Agent.overrideDirection.Value, normalized2) < 0f)
			{
				base.Agent.overrideDirection = normalized2;
			}
		}
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		ClientAnim.IsCrouching = false;
		base.Agent.overrideDirection = null;
		base.OnStateExit();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_ScientistSurprised : FSMStateBase
{
	public float angularSpeedOverride;

	public float timeBeforeTurning;

	public float minTimeBeforeShooting = 0.6f;

	public float shootingDuration = 0.4f;

	public float maxDuration = 1f;

	public ENPCVoicelineCategory voicelineCategory = ENPCVoicelineCategory.Surprise;

	private NpcShootingComponent _shooting;

	private NpcBarkComponent _barkComponent;

	private float elapsedTime;

	private float elapsedTimeShooting;

	private Quaternion startRotation;

	private LockState.LockHandle pauseHandle;

	private bool wasSurprisedFromBehind;

	private NpcShootingComponent Shooting => _shooting ?? (_shooting = ((Component)Owner).GetComponent<NpcShootingComponent>());

	private NpcBarkComponent BarkComponent => _barkComponent ?? (_barkComponent = ((Component)Owner).GetComponent<NpcBarkComponent>());

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetLKP(out var lkp))
		{
			return EFSMStateStatus.Failure;
		}
		startRotation = ((Component)Owner).transform.rotation;
		base.Agent.overrideDirection = Vector3Ex.NormalizeXZ(startRotation * Vector3.forward);
		pauseHandle = base.Agent.Pause();
		Shooting.AllowShooting = false;
		Shooting.AllowBeingAccurate = false;
		BarkComponent.PlayVoicelineFromCategory(voicelineCategory);
		elapsedTime = 0f;
		elapsedTimeShooting = 0f;
		if (angularSpeedOverride > 0f)
		{
			base.Agent.overrideAngularSpeed = angularSpeedOverride;
		}
		wasSurprisedFromBehind = Vector3.Angle(((Component)Owner).transform.forward, Vector3Ex.WithY(lkp - ((Component)Owner).transform.position, 0f)) > 60f;
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetLKP(out var lkp, applyHeightOffset: true, predict: false, ignoreCrouch: false))
		{
			return EFSMStateStatus.Failure;
		}
		EFSMStateStatus result = base.OnStateUpdate(deltaTime);
		elapsedTime += deltaTime;
		if (!wasSurprisedFromBehind || !(elapsedTime < timeBeforeTurning))
		{
			Vector3 val = lkp - base.Senses.EyePosition;
			base.Agent.overrideDirection = val;
			Matrix4x4 worldToNavMeshSpace = Owner.WorldToNavMeshSpace;
			Vector3 val2 = ((Matrix4x4)(ref worldToNavMeshSpace)).MultiplyVector(val);
			base.Agent.Move(-Vector3Ex.NormalizeXZ(val2) * deltaTime * 1.7f);
		}
		if (elapsedTime >= minTimeBeforeShooting && Vector3.Angle(((Component)Owner).transform.forward, Vector3Ex.WithY(lkp - ((Component)Owner).transform.position, 0f)) <= 5f)
		{
			Shooting.AllowShooting = true;
		}
		if (Shooting.AllowShooting)
		{
			elapsedTimeShooting += deltaTime;
			if (elapsedTimeShooting >= shootingDuration)
			{
				return EFSMStateStatus.Success;
			}
		}
		if (elapsedTime > maxDuration)
		{
			return EFSMStateStatus.Success;
		}
		return result;
	}

	public override void OnStateExit()
	{
		base.Agent.overrideAngularSpeed = null;
		base.Agent.overrideDirection = null;
		base.Agent.Unpause(ref pauseHandle);
		Shooting.AllowShooting = true;
		Shooting.AllowBeingAccurate = true;
		base.OnStateExit();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_CanThrowGrenade : FSMSlowTransitionBase
{
	private Vector3? lastThrowVelocity;

	protected override bool EvaluateAtInterval()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		lastThrowVelocity = null;
		if (!State_ThrowGrenade.FindPotentialLandingPoint(base.Senses, out var landingPoint, out var throwVelocity))
		{
			return false;
		}
		if (!State_ThrowGrenade.ValidateLandingPoint(Owner, base.Senses.EyePosition, landingPoint, throwVelocity, out var _))
		{
			return false;
		}
		lastThrowVelocity = throwVelocity;
		return true;
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (lastThrowVelocity.HasValue && to is IParametrized<Vector3> parametrized)
		{
			parametrized.SetParameter(lastThrowVelocity.Value);
		}
		lastThrowVelocity = null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_ThrowGrenade : FSMStateBase, IParametrized<Vector3>
{
	public GameObjectRef deployedGrenadePrefab;

	public float cooldown = 60f;

	public const float grenadeRadius = 0.2f;

	public const float explosionRadius = 6f;

	public const string thrownGrenadeKey = "ThrownGrenadeRecently";

	private const float duration = 1f;

	private const float overshoot = 0.01f;

	private NpcShootingComponent _shooting;

	private NpcBarkComponent _barkComponent;

	private float remainingDuration;

	private Vector3? throwVelocity;

	private NpcShootingComponent Shooting => _shooting ?? (_shooting = ((Component)Owner).GetComponent<NpcShootingComponent>());

	private NpcBarkComponent BarkComponent => _barkComponent ?? (_barkComponent = ((Component)Owner).GetComponent<NpcBarkComponent>());

	public static bool FindPotentialLandingPoint(SenseComponent Senses, out Vector3 landingPoint, out Vector3 throwVelocity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		landingPoint = Vector3.zero;
		throwVelocity = Vector3.zero;
		if (!Senses.FindTargetLKP(out var lkp))
		{
			return false;
		}
		Vector3 eyePosition = Senses.EyePosition;
		Vector3 val = Vector3Ex.NormalizeXZ(lkp - eyePosition);
		landingPoint = lkp + val * 1f;
		Vector3 val2 = Vector3.Cross(Vector3.up, val);
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		Vector3 val3 = val + Quaternion.AngleAxis(10f, normalized) * Vector3.up;
		float num = ThrownWeapon.GetThrowVelocity(eyePosition, landingPoint, val3);
		if (float.IsNaN(num))
		{
			val3 = val + Quaternion.AngleAxis(20f, normalized) * Vector3.up;
			num = ThrownWeapon.GetThrowVelocity(eyePosition, landingPoint, val3);
			if (float.IsNaN(num))
			{
				return false;
			}
		}
		throwVelocity = val3 * num;
		return true;
	}

	public static bool ValidateLandingPoint(BaseEntity querier, Vector3 origin, Vector3 destination, Vector3 initialVelocity, out RaycastHit hitInfo, int maxSegments = 5)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		hitInfo = default(RaycastHit);
		Vector3 val = Vector3Ex.WithY(initialVelocity, 0f);
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (magnitude < 0.001f)
		{
			return false;
		}
		val = Vector3Ex.WithY(destination - origin, 0f);
		float num = ((Vector3)(ref val)).magnitude / magnitude + 0.01f;
		Vector3 val2 = origin;
		Vector3 val3 = initialVelocity;
		float num2 = Mathf.Abs(Physics.gravity.y);
		float num3 = num / (float)maxSegments;
		int num4 = Mathf.CeilToInt(num / num3);
		num3 = num / (float)num4;
		float num5 = 0f;
		Vector3 val4 = default(Vector3);
		for (int i = 0; i < num4; i++)
		{
			if (!(num5 < num))
			{
				break;
			}
			float num6 = Mathf.Min(num3, num - num5);
			((Vector3)(ref val4))..ctor(0f, 0f - num2, 0f);
			Vector3 val5 = val2 + val3 * num6 + 0.5f * val4 * num6 * num6;
			Vector3 val6 = val3 + val4 * num6;
			Vector3 val7 = val5 - val2;
			float magnitude2 = ((Vector3)(ref val7)).magnitude;
			if (magnitude2 > 0.001f && GamePhysics.Trace(new Ray(val2, ((Vector3)(ref val7)).normalized), 0.2f, out hitInfo, magnitude2, 1218519297, (QueryTriggerInteraction)0, querier))
			{
				if (Vector3.Distance(((RaycastHit)(ref hitInfo)).point, origin) <= 6f)
				{
					return false;
				}
				if (Vector3.Distance(((RaycastHit)(ref hitInfo)).point, destination) > 6f)
				{
					return false;
				}
				return true;
			}
			val2 = val5;
			val3 = val6;
			num5 += num6;
		}
		return false;
	}

	void IParametrized<Vector3>.SetParameter(Vector3 parameter)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		throwVelocity = parameter;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(deployedGrenadePrefab.resourcePath, base.Senses.EyePosition, Quaternion.LookRotation(throwVelocity.Value));
		if ((Object)(object)baseEntity == (Object)null)
		{
			return EFSMStateStatus.Failure;
		}
		baseEntity.SetCreatorEntity(Owner);
		baseEntity.SetVelocity(throwVelocity.Value);
		baseEntity.Spawn();
		remainingDuration = 1f;
		Shooting.AllowShooting = false;
		base.Blackboard.Add("ThrownGrenadeRecently", cooldown);
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetPerceivedAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<BlackboardComponent>().Add("ThrownGrenadeRecently", cooldown);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		remainingDuration -= deltaTime;
		if (remainingDuration <= 0f)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		Shooting.AllowShooting = true;
		throwVelocity = null;
		base.OnStateExit();
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

public static class NpcPushHelper
{
	public static void CoordinatePush(BaseEntity coordinator, float maxDistance = 50f)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		SenseComponent senseComponent = default(SenseComponent);
		NpcZoneComponent npcZoneComponent = default(NpcZoneComponent);
		Scientist2FSM scientist2FSM = default(Scientist2FSM);
		if (((Component)coordinator).TryGetComponent<SenseComponent>(ref senseComponent) && ((Component)coordinator).TryGetComponent<NpcZoneComponent>(ref npcZoneComponent) && senseComponent.FindTarget(out var target) && senseComponent.FindLKP(target, out var lkp) && FindBestPartner(((Component)coordinator).transform.position, senseComponent, npcZoneComponent, out var bestPartner, maxDistance) && ((Component)bestPartner).TryGetComponent<Scientist2FSM>(ref scientist2FSM))
		{
			scientist2FSM.RushPositionTrans.Trigger((target, lkp));
			NpcBarkComponent npcBarkComponent = default(NpcBarkComponent);
			if (AI.npcBarksEnabled && ((Component)coordinator).TryGetComponent<NpcBarkComponent>(ref npcBarkComponent))
			{
				npcBarkComponent.PlayVoicelineFromCategory(ENPCVoicelineCategory.Push, bestPartner);
			}
		}
	}

	public static bool FindBestPartner(Vector3 worldPosition, SenseComponent SenseComponent, NpcZoneComponent NpcZoneComponent, out BaseEntity bestPartner, float maxDistance)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcPushHelper.FindBestPartner", 0);
		try
		{
			bestPartner = null;
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SenseComponent.GetPerceivedAllies((List<BaseEntity>)(object)val2);
				float num = float.MaxValue;
				BaseEntity baseEntity = null;
				float num2 = float.MaxValue;
				BaseEntity baseEntity2 = null;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					float num3 = DistanceWithExaggeratedY(worldPosition, ((Component)item).transform.position);
					if (!(num3 > maxDistance))
					{
						if (num3 < num2)
						{
							num2 = num3;
							baseEntity2 = item;
						}
						if (NpcZoneComponent.IsInSameZone(item) && num3 < num)
						{
							num = num3;
							baseEntity = item;
						}
					}
				}
				if ((Object)(object)baseEntity2 == (Object)null && (Object)(object)baseEntity == (Object)null)
				{
					return false;
				}
				bestPartner = baseEntity ?? baseEntity2;
				return true;
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static float DistanceWithExaggeratedY(Vector3 a, Vector3 b, float yDistMultiplier = 6f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector2.Distance(new Vector2(a.x, a.z), new Vector2(b.x, b.z));
		float num2 = Mathf.Abs(a.y - b.y);
		return num + num2 * yDistMultiplier;
	}
}


using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(BlackboardComponent), typeof(NpcBarkManager))]
[SoftRequireComponent(typeof(LimitedTurnNavAgent), typeof(RootMotionPlayer), typeof(SenseComponent))]
[SoftRequireComponent(typeof(NpcZoneComponent), typeof(NPCEncounterTimer), typeof(NpcShootingComponent))]
public class Scientist2FSM_Heavy : FSMComponent
{
	public State_PatrolIdle idle = new State_PatrolIdle();

	public State_Patrol patrol = new State_Patrol();

	public State_Search search = new State_Search();

	public State_ScientistRush chase = new State_ScientistRush();

	public State_MoveToPointWithLosOnTarget popOut = new State_MoveToPointWithLosOnTarget();

	public State_Dead dead = new State_Dead();

	public State_ScientistSurprised surprised = new State_ScientistSurprised();

	private Trans_Triggerable<HitInfo> HurtTrans;

	private Trans_Triggerable<HitInfo> DeathTrans;

	public Trans_Triggerable<Vector3> RushPositionTrans;

	private NpcBarkComponent _barkComponent;

	private bool spokeDistractedByHeavyVoiceline;

	public GameObjectRef explosionPrefab;

	public GameObjectRef bulletEffect;

	public SoundDefinition backpackHitSound;

	public float bulletSpeed = 35f;

	public float backPackHealth = 110f;

	private NpcBarkComponent BarkComponent => _barkComponent ?? (_barkComponent = ((Component)base.baseEntity).GetComponent<NpcBarkComponent>());

	public override void InitShared()
	{
		if (base.baseEntity.isServer)
		{
			State_Nothing state_Nothing = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			HurtTrans = new Trans_Triggerable<HitInfo>();
			DeathTrans = new Trans_Triggerable<HitInfo>();
			RushPositionTrans = new Trans_Triggerable<Vector3>();
			State_Nothing obj = new State_Nothing
			{
				Name = "Root"
			};
			State_Nothing state_Nothing2 = new State_Nothing
			{
				Name = "Alive"
			};
			State_Nothing state_Nothing3 = new State_Nothing
			{
				Name = "OnNavmesh"
			};
			State_Nothing state_Nothing4 = new State_Nothing
			{
				Name = "Roaming"
			};
			State_Nothing state_Nothing5 = new State_Nothing
			{
				Name = "Has target"
			};
			State_Nothing state_Nothing6 = new State_Nothing
			{
				Name = "Searching"
			};
			State_Nothing state_Nothing7 = new State_Nothing
			{
				Name = "Shoot while still"
			};
			State_Search state_Search = search.Clone() as State_Search;
			state_Search.Name = "SearchPastLKP";
			state_Search.predict = true;
			Trans_CanSeeTarget trans_CanSeeTarget = new Trans_CanSeeTarget();
			FSMTransitionBase fSMTransitionBase = ~new Trans_CanSeeTarget();
			Trans_And dstState2Trans = new Trans_Cooldown
			{
				cooldown = 5f
			} & new Trans_TargetSurprised();
			_ = obj + (state_Nothing2.AddTickTransition(dead, DeathTrans) + state_Nothing.AddTickTransition(patrol, new Trans_IsNavmeshReady()) + (state_Nothing3 + (state_Nothing4.AddTickBranchingTrans(chase, new Trans_HasTarget(), surprised, dstState2Trans) + patrol.AddFailureTransition(dead).AddEndTransition(idle) + idle.AddTickTransition(patrol, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 1.0,
				MaxDuration = 10.0
			})) + (state_Nothing5.AddTickTransition(patrol, ~new Trans_HasTarget()) + surprised.AddEndTransition(chase) + chase.AddTickTransition(state_Nothing7, trans_CanSeeTarget & new Trans_TargetLkpInRange
			{
				Range = 8f
			} & new Trans_IsMuzzleClear_Slow()).AddEndTransition(popOut, ~new Trans_TargetLkpInRange
			{
				Range = 3f,
				Predict = true
			}).AddEndTransition(state_Search) + popOut.AddEndTransition(state_Nothing7, trans_CanSeeTarget).AddEndTransition(state_Search) + state_Nothing7.AddTickTransition(chase, fSMTransitionBase | ~new Trans_TargetLkpInRange
			{
				Range = 10f
			} | ~new Trans_IsMuzzleClear_Slow()) + (state_Nothing6.AddTickTransition(chase, RushPositionTrans).AddTickBranchingTrans(chase, trans_CanSeeTarget, surprised, dstState2Trans).AddTickTransition(chase, new Trans_Cooldown
			{
				cooldown = 5f
			} & fSMTransitionBase & new Trans_HeardNoise())
				.AddFailureTransition(patrol)
				.AddEndTransition(search, new Trans_Bark
				{
					category = ENPCVoicelineCategory.Search
				}) + state_Search + search)))) + dead;
			SetState(state_Nothing);
			SetFsmActive(newActive: true);
		}
	}

	public override void Hurt(HitInfo hitInfo)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		HurtTrans.Trigger(hitInfo);
		if (hitInfo.HitBone == StringPool.Get("backpack_col"))
		{
			backPackHealth -= hitInfo.damageTypes.Total();
			hitInfo.damageTypes.Clear();
			if (explosionPrefab != null && backPackHealth <= 0f)
			{
				hitInfo.damageTypes.Add(DamageType.Explosion, 99999f);
				GameManager.server.CreateEntity(explosionPrefab.resourcePath, hitInfo.HitPositionWorld, Quaternion.LookRotation(hitInfo.HitNormalWorld)).Spawn();
			}
		}
		else if (!spokeDistractedByHeavyVoiceline && (hitInfo.damageTypes.Has(DamageType.Bullet) || hitInfo.damageTypes.Has(DamageType.Arrow)) && BarkComponent.PlayVoicelineFromCategory(ENPCVoicelineCategory.DistractedByHeavy))
		{
			spokeDistractedByHeavyVoiceline = true;
		}
	}

	public override bool OnDied(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
		return false;
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(NpcZoneComponent), typeof(NPCEncounterTimer), typeof(NpcShootingComponent))]
[SoftRequireComponent(typeof(LimitedTurnNavAgent), typeof(RootMotionPlayer), typeof(SenseComponent))]
[SoftRequireComponent(typeof(BlackboardComponent), typeof(NpcBarkManager))]
public class Scientist2FSM_Shotgun : FSMComponent
{
	public State_PatrolIdle idle = new State_PatrolIdle();

	public State_Patrol patrol = new State_Patrol();

	public State_Search search = new State_Search();

	public State_ScientistRush chase = new State_ScientistRush();

	public State_Dead dead = new State_Dead();

	public State_DogFight dogFight = new State_DogFight();

	public State_MoveToCoverHiddenFromTarget goHide = new State_MoveToCoverHiddenFromTarget();

	public State_StayInCover stayInCover = new State_StayInCover();

	public State_ScientistSurprised surprised = new State_ScientistSurprised();

	public State_Flank flank = new State_Flank();

	private Trans_Triggerable<HitInfo> HurtTrans;

	private Trans_Triggerable<HitInfo> DeathTrans;

	public Trans_Triggerable<Vector3> RushPositionTrans;

	private NpcBarkComponent _barkComponent;

	private NpcBarkComponent BarkComponent => _barkComponent ?? (_barkComponent = ((Component)base.baseEntity).GetComponent<NpcBarkComponent>());

	public override void InitShared()
	{
		if (base.baseEntity.isServer)
		{
			State_Nothing state_Nothing = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			State_Nothing state_Nothing2 = new State_Nothing
			{
				Name = "ReadyToChase"
			};
			HurtTrans = new Trans_Triggerable<HitInfo>();
			DeathTrans = new Trans_Triggerable<HitInfo>();
			RushPositionTrans = new Trans_Triggerable<Vector3>();
			State_Nothing obj = new State_Nothing
			{
				Name = "Root"
			};
			State_Nothing state_Nothing3 = new State_Nothing
			{
				Name = "Alive"
			};
			State_Nothing state_Nothing4 = new State_Nothing
			{
				Name = "OnNavmesh"
			};
			State_Nothing state_Nothing5 = new State_Nothing
			{
				Name = "Roaming"
			};
			State_Nothing state_Nothing6 = new State_Nothing
			{
				Name = "Has target"
			};
			State_Nothing state_Nothing7 = new State_Nothing
			{
				Name = "Searching"
			};
			State_Nothing state_Nothing8 = new State_Nothing
			{
				Name = "See target switch"
			};
			State_Search state_Search = search.Clone() as State_Search;
			state_Search.Name = "SearchPastLKP";
			state_Search.predict = true;
			FSMTransitionBase fSMTransitionBase = ~new Trans_IsReloading();
			Trans_IsReloading trans_IsReloading = new Trans_IsReloading();
			Trans_CanSeeTarget trans_CanSeeTarget = new Trans_CanSeeTarget();
			FSMTransitionBase fSMTransitionBase2 = ~new Trans_CanSeeTarget();
			float num = 7f;
			Trans_And dstState2Trans = new Trans_Cooldown
			{
				cooldown = 5f
			} & new Trans_TargetLkpInRange
			{
				Range = num + 1f
			} & new Trans_TargetSurprised();
			Trans_And trans_And = new Trans_Cooldown
			{
				cooldown = 5f
			} & new Trans_IsTargetLkpInOurZone();
			Trans_And transition = new Trans_Cooldown
			{
				cooldown = 5f
			} & ~new Trans_CanSeeTarget() & (new Trans_TargetIsLowHealth() | new Trans_TargetIsUndergeared());
			_ = obj + (state_Nothing3.AddTickTransition(dead, DeathTrans) + state_Nothing.AddTickTransition(patrol, new Trans_IsNavmeshReady()) + (state_Nothing4 + (state_Nothing5.AddTickBranchingTrans(goHide, new Trans_HasTarget(), surprised, dstState2Trans) + patrol.AddFailureTransition(dead).AddEndTransition(idle) + idle.AddTickTransition(patrol, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 1.0,
				MaxDuration = 10.0
			})) + (state_Nothing6.AddTickTransition(patrol, ~new Trans_HasTarget()) + (state_Nothing2.AddTickTransition(chase, fSMTransitionBase & RushPositionTrans) + state_Nothing8.AddTickTransition(goHide, trans_IsReloading | ~new Trans_TargetLkpInRange
			{
				Range = 30f
			}).AddTickTransition(chase, new Trans_TargetLkpInRange
			{
				Range = 20f
			}).AddTickTransition(dogFight, new Trans_TargetLkpInRange
			{
				Range = num
			}) + dogFight.AddTickTransition(goHide, ~new Trans_TargetLkpInRange
			{
				Range = 50f
			} | (trans_IsReloading & new Trans_Bark
			{
				category = ENPCVoicelineCategory.Reload
			})).AddTickTransition(chase, transition).AddTickTransition(chase, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 1.0,
				MaxDuration = 4.0
			} & fSMTransitionBase)
				.AddFailureTransition(goHide) + goHide.AddTickBranchingTrans(dogFight, fSMTransitionBase & trans_CanSeeTarget & new Trans_TargetInRange
			{
				Range = 3f
			}, surprised, dstState2Trans).AddTickTransition(chase, transition).AddFailureTransition(chase)
				.AddEndTransition(stayInCover, ~new Trans_TargetLkpInRange
				{
					Range = 50f
				} | trans_IsReloading | new Trans_RandomChance
				{
					Chance = 0.5f
				})
				.AddEndTransition(flank, trans_And) + stayInCover.AddTickBranchingTrans(chase, trans_CanSeeTarget | HurtTrans | (new Trans_IsTargetRunning() & new Trans_TargetInRange
			{
				Range = 20f
			}), goHide, trans_IsReloading).AddTickBranchingTrans(chase, new Trans_TargetLkpInRange
			{
				Range = 50f
			} & fSMTransitionBase & new Trans_ElapsedTimeRandomized
			{
				MinDuration = 5.0,
				MaxDuration = 10.0
			}, flank, trans_And).AddTickBranchingTrans(state_Nothing8, trans_CanSeeTarget, surprised, dstState2Trans) + flank.AddTickBranchingTrans(state_Nothing8, trans_CanSeeTarget, surprised, dstState2Trans).AddFailureTransition(chase).AddEndTransition(state_Search) + (state_Nothing7.AddTickBranchingTrans(state_Nothing8, trans_CanSeeTarget, surprised, dstState2Trans).AddTickTransition(flank, new Trans_Cooldown
			{
				cooldown = 5f
			} & fSMTransitionBase2 & new Trans_HeardNoise()).AddFailureTransition(goHide)
				.AddEndTransition(search, new Trans_Bark
				{
					category = ENPCVoicelineCategory.Search
				}) + state_Search + search) + surprised.AddEndTransition(state_Nothing8)) + chase.AddTickBranchingTrans(dogFight, new Trans_CanSeeTarget() & new Trans_TargetLkpInRange
			{
				Range = num
			}, surprised, dstState2Trans).AddFailureTransition(goHide).AddEndTransition(state_Search)))) + dead;
			SetState(state_Nothing);
			SetFsmActive(newActive: true);
		}
	}

	public override void Hurt(HitInfo hitInfo)
	{
		HurtTrans.Trigger(hitInfo);
	}

	public override bool OnDied(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
		return false;
	}
}


using Prefabs.Misc;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(Scientist2FSM))]
public class ScientistNPC2 : BaseNPC2
{
	public bool canBeHeadshot = true;

	public override bool IsAnimal => false;

	public override Vector3 ServerNavMeshPos
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			Vector3 serverWorldPosition = ServerWorldPosition;
			Matrix4x4 worldToNavMeshSpace = WorldToNavMeshSpace;
			return ((Matrix4x4)(ref worldToNavMeshSpace)).MultiplyPoint(serverWorldPosition);
		}
		set
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0004: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			Matrix4x4 navMeshToWorldSpace = NavMeshToWorldSpace;
			ServerWorldPosition = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyPoint(value);
		}
	}

	public override Matrix4x4 WorldToNavMeshSpace
	{
		get
		{
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			GhostShip ghostShip = GetParentEntity() as GhostShip;
			if (Object.op_Implicit((Object)(object)ghostShip))
			{
				return ghostShip.WorldToNavMeshSpace;
			}
			return base.WorldToNavMeshSpace;
		}
	}

	public override Matrix4x4 NavMeshToWorldSpace
	{
		get
		{
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			GhostShip ghostShip = GetParentEntity() as GhostShip;
			if (Object.op_Implicit((Object)(object)ghostShip))
			{
				return ghostShip.NavMeshToWorldSpace;
			}
			return base.NavMeshToWorldSpace;
		}
	}

	public override string Categorize()
	{
		return "Scientist2";
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
	}

	public override void ScaleDamage(HitInfo info)
	{
		base.ScaleDamage(info);
		if (canBeHeadshot && Object.op_Implicit((Object)(object)info.damageProperties))
		{
			info.damageProperties.ScaleDamage(info);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

public class ClawMarkSpawner : EntityComponent<BaseEntity>, IServerComponent
{
	public GameObjectRef clawDecal;

	public float radius = 130f;

	public float height = 1.8f;

	public float minTreeRadius = 1.4f;

	[Range(0f, 1f)]
	public float ratioOfTreesMarked = 0.5f;

	private static bool showClawMarks;

	private List<ClawMark> clawMarks = new List<ClawMark>();

	[ServerVar]
	public static void ShowClawMarks(Arg arg)
	{
		bool @bool = arg.GetBool(0, !showClawMarks);
		if (@bool == showClawMarks)
		{
			arg.ReplyWith("Claw marks are already " + (showClawMarks ? "visible" : "hidden") + ".");
			return;
		}
		showClawMarks = @bool;
		BaseNPC2[] array;
		if (showClawMarks)
		{
			array = BaseEntity.Util.FindAll<BaseNPC2>();
			for (int i = 0; i < array.Length; i++)
			{
				ClawMarkSpawner component = ((Component)array[i]).GetComponent<ClawMarkSpawner>();
				if ((Object)(object)component != (Object)null)
				{
					component.SpawnClawMarks();
				}
			}
			arg.ReplyWith("Claw marks are now visible.");
			return;
		}
		array = BaseEntity.Util.FindAll<BaseNPC2>();
		for (int i = 0; i < array.Length; i++)
		{
			ClawMarkSpawner component2 = ((Component)array[i]).GetComponent<ClawMarkSpawner>();
			if ((Object)(object)component2 != (Object)null)
			{
				component2.ClearClawMarks();
			}
		}
		arg.ReplyWith("Claw marks are now hidden.");
	}

	public override void InitShared()
	{
		UpdateBaseEntity();
		if (showClawMarks)
		{
			SpawnClawMarks();
		}
	}

	public override void DestroyShared()
	{
		ClearClawMarks();
	}

	private void SpawnClawMarks()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		if (!base.baseEntity.isServer)
		{
			return;
		}
		if (AI.logIssues && clawMarks.Count > 0)
		{
			Debug.LogWarning((object)$"Claw marks already spawned for {base.baseEntity}.");
			return;
		}
		PooledList<TreeEntity> val = Pool.Get<PooledList<TreeEntity>>();
		try
		{
			BaseEntity.Query.Server.GetInSphere(((Component)base.baseEntity).transform.position, radius, (List<TreeEntity>)(object)val);
			clawMarks.Capacity = ((List<TreeEntity>)(object)val).Count;
			RaycastHit val3 = default(RaycastHit);
			foreach (TreeEntity item in (List<TreeEntity>)(object)val)
			{
				if (Random.value > ratioOfTreesMarked || (Object)(object)item.serverCollider == (Object)null)
				{
					continue;
				}
				float num = Mathf.Min(((Bounds)(ref item.bounds)).extents.x, ((Bounds)(ref item.bounds)).extents.z);
				if (num < minTreeRadius)
				{
					continue;
				}
				Vector3 val2 = ((Component)item).transform.position + Vector3.up * height;
				Vector3 forward = ((Component)item).transform.forward;
				if (!item.serverCollider.Raycast(new Ray(val2 - forward * num, forward), ref val3, num))
				{
					continue;
				}
				ClawMark clawMark = GameManager.server.CreateEntity(clawDecal.resourcePath, ((RaycastHit)(ref val3)).point, Quaternion.LookRotation(-((RaycastHit)(ref val3)).normal)) as ClawMark;
				if ((Object)(object)clawMark == (Object)null)
				{
					if (AI.logIssues)
					{
						Debug.LogWarning((object)$"Failed to create claw mark for {base.baseEntity}.");
					}
				}
				else
				{
					clawMarks.Add(clawMark);
					clawMark.SetParent(item, worldPositionStays: true);
					clawMark.Spawn();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ClearClawMarks()
	{
		if (!base.baseEntity.isServer)
		{
			return;
		}
		foreach (ClawMark clawMark in clawMarks)
		{
			clawMark.Kill();
		}
		clawMarks.Clear();
	}
}


using Rust.Ai.Gen2;

[SoftRequireComponent(typeof(TigerFSM))]
public class Panther : BaseNPC2
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 0.5f;

	public override string Categorize()
	{
		return "Panther";
	}
}


using Rust.Ai.Gen2;

[SoftRequireComponent(typeof(TigerFSM))]
public class Tiger : BaseNPC2
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 0.5f;

	public override string Categorize()
	{
		return "Tiger";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_HurtWithAdditive : State_Hurt
{
	public AnimationClip WeakHitAdditive;
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_Roar : State_PlayAnimation
{
	public const string AlreadyRoared = "AlreadyRoared";

	public override EFSMStateStatus OnStateEnter()
	{
		if (!base.Senses.FindTarget(out var _))
		{
			return EFSMStateStatus.Failure;
		}
		base.Blackboard.Add("AlreadyRoared");
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_DeadlyAttack : State_Attack
{
	public float range = 4f;

	public SoundDefinition impactSound;

	private static readonly Vector3 force = new Vector3(15f, 3f, 15f);

	protected override void DoDamage()
	{
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BaseCombatEntity baseCombatEntity))
		{
			return;
		}
		float amount = Damage;
		if (target.IsNonNpcPlayer())
		{
			float num = baseCombatEntity.baseProtection.Get(DamageType);
			float num2 = (1f - num) * 1.2f;
			float num3 = Damage * num2;
			if (num == 0f && baseCombatEntity.health >= 30f && num3 > baseCombatEntity.health)
			{
				amount = (baseCombatEntity.health - 1f) * (1f / num2);
			}
		}
		baseCombatEntity.OnAttacked(amount, DamageType, Owner, ignoreShield: false);
		Owner.ClientRPC(RpcTarget.NetworkGroup("RPC_PlayNPCAttackImpactSound"));
		if (baseCombatEntity.ToNonNpcPlayer(out var player))
		{
			Vector3 val = ((Vector3.Dot(((Component)Owner).transform.right, Vector3Ex.NormalizeXZ(((Component)player).transform.position - ((Component)Owner).transform.position)) > 0f) ? ((Component)Owner).transform.right : (-((Component)Owner).transform.right));
			player.DoPush(((Component)Owner).transform.forward * force.z + val * force.x + Vector3.up * force.y);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_FleeToHide : State_Flee
{
	public const string HitDuringChargeKey = "HitDuringCharge";

	private bool clockWise;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		base.Blackboard.Remove("HitDuringCharge");
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		Vector3 val = Vector3Ex.NormalizeXZ(targetPosition - ((Component)Owner).transform.position);
		clockWise = Vector3.Dot(((Component)Owner).transform.right, val) > 0f;
		return base.OnStateEnter();
	}

	protected override EFSMStateStatus MoveAwayFromTarget()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		Vector3 val = ((Component)Owner).transform.position - targetPosition;
		float magnitude = ((Vector3)(ref val)).magnitude;
		Vector3 val2 = ((Component)Owner).transform.forward;
		float num = 15f;
		if (magnitude > 6f)
		{
			val2 = Vector3Ex.NormalizeXZ(((Component)Owner).transform.position - targetPosition);
			num = 55f;
		}
		val2 = Quaternion.AngleAxis(num * (clockWise ? 1f : (-1f)), Vector3.up) * val2;
		PooledList<Vector3> val3 = Pool.Get<PooledList<Vector3>>();
		try
		{
			Eqs.SamplePositionsInDonutShape(base.Agent.NavPosition, (List<Vector3>)(object)val3, distance);
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				foreach (Vector3 item3 in (List<Vector3>)(object)val3)
				{
					Vector3 val4 = val2;
					Vector3 val5 = item3 - ((Component)Owner).transform.position;
					float item = Vector3.Dot(val4, ((Vector3)(ref val5)).normalized);
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item3, item));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				foreach (var item4 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item2 = item4.Item1;
					if (base.Agent.SamplePosition(item2, out var sample, 10f) && (base.Agent.canSwim || !base.Agent.IsInWater(sample)) && base.Agent.SetDestination(sample))
					{
						return EFSMStateStatus.None;
					}
				}
				return EFSMStateStatus.Failure;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val3)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Observe : State_MoveToTarget
{
	private double startTime;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus eFSMStateStatus = base.OnStateEnter();
		if (eFSMStateStatus == EFSMStateStatus.Failure)
		{
			return eFSMStateStatus;
		}
		succeedWhenDestinationIsReached = false;
		stopAtDestination = false;
		base.Agent.deceleration.Value = 0.1f;
		base.Agent.SetSpeed(0f);
		startTime = Time.timeAsDouble;
		base.Agent.currentDeviation = 2f;
		return eFSMStateStatus;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (Time.timeAsDouble - startTime > 6.0)
		{
			base.Agent.SetSpeed(0.2f);
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_AttackUnreachableWarped : FSMStateBase
{
	private enum Phase
	{
		PreJump,
		Jump,
		Attack,
		JumpBack,
		PostJumpBack
	}

	public float jumpOnStart = 1.03f;

	public float jumpOnEnd = 1.63f;

	public float jumpOffStart = 2.9f;

	public float jumpOffEnd = 3.47f;

	public float totalDuration = 3.6f;

	private const float groundCheckDistance = 2f;

	private const float damage = 35f;

	private const float meleeAttackRange = 1.7f;

	private const DamageType damageType = DamageType.Bite;

	public RootMotionData animClip;

	private float elapsedTime;

	private LockState.LockHandle targetLock;

	private LockState.LockHandle movementLock;

	private Phase phase;

	private RootMotionPlayer.Warp[] warps = new RootMotionPlayer.Warp[2];

	private RootMotionPlayer.PlayServerState animState;

	private Vector3 destination;

	private bool didHit;

	public static bool SampleGroundPositionUnderTarget(LimitedTurnNavAgent agent, BasePlayer targetAsPlayer, out Vector3 projectedLocation)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (targetAsPlayer.IsOnGround() && !targetAsPlayer.OnLadder())
		{
			projectedLocation = ((Component)targetAsPlayer).transform.position;
			return true;
		}
		float radius = BasePlayer.GetRadius();
		RaycastHit hitInfo;
		bool result = agent.SampleGroundPositionWithPhysics(((Component)targetAsPlayer).transform.position, out hitInfo, 2f, radius * 0.5f);
		projectedLocation = ((RaycastHit)(ref hitInfo)).point;
		return result;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer targetAsPlayer))
		{
			return EFSMStateStatus.Failure;
		}
		destination = ((Component)target).transform.position;
		if (!SampleGroundPositionUnderTarget(base.Agent, targetAsPlayer, out destination))
		{
			return EFSMStateStatus.Failure;
		}
		if (!State_MoveToLastReachablePointNearTarget.CanJumpFromPosToPos(Owner, ((Component)Owner).transform.position, destination))
		{
			return EFSMStateStatus.Failure;
		}
		movementLock = base.Agent.Pause();
		didHit = false;
		elapsedTime = 0f;
		targetLock = base.Senses.LockCurrentTarget();
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = false;
		animState = RootMotionPlayer.PlayServerState.TakeFromPool(animClip, ((Component)Owner).transform);
		animState.warps = warps;
		animState.constrainToNavmesh = false;
		base.AnimPlayer.PlayServer(animState);
		SetPhase(Phase.PreJump);
		return base.OnStateEnter();
	}

	private EFSMStateStatus SetPhase(Phase newPhase)
	{
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_032a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		phase = newPhase;
		if (phase == Phase.Jump)
		{
			if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer targetAsPlayer))
			{
				return EFSMStateStatus.Failure;
			}
			if (SampleGroundPositionUnderTarget(base.Agent, targetAsPlayer, out var projectedLocation))
			{
				destination = projectedLocation;
			}
			Vector3 position = ((Component)Owner).transform.position;
			animState.initialRotation = Quaternion.LookRotation(Vector3Ex.WithY(destination - ((Component)Owner).transform.position, 0f));
			((Component)Owner).transform.rotation = animState.initialRotation;
			float num = animClip.zMotionCurve.Evaluate(jumpOnEnd) - animClip.zMotionCurve.Evaluate(jumpOnStart);
			float num2 = animClip.yMotionCurve.Evaluate(jumpOnEnd) - animClip.yMotionCurve.Evaluate(jumpOnStart);
			RootMotionPlayer.Warp warp = new RootMotionPlayer.Warp(jumpOnStart, jumpOnEnd, Vector3.one);
			warp.translationScale.z = Vector3.Distance(Vector3Ex.WithY(destination, 0f), Vector3Ex.WithY(position, 0f)) / num;
			warp.translationScale.y = (destination.y - position.y) / num2;
			warps[0] = warp;
			float num3 = animClip.zMotionCurve.Evaluate(jumpOffStart) - animClip.zMotionCurve.Evaluate(jumpOffEnd);
			float num4 = animClip.yMotionCurve.Evaluate(jumpOffStart) - animClip.yMotionCurve.Evaluate(jumpOffEnd);
			RootMotionPlayer.Warp warp2 = new RootMotionPlayer.Warp(jumpOffStart, jumpOffEnd, Vector3.one);
			warp2.translationScale.z = Vector3.Distance(Vector3Ex.WithY(destination, 0f), Vector3Ex.WithY(position, 0f)) / num3;
			warp2.translationScale.y = (destination.y - position.y) / num4;
			warps[1] = warp2;
			base.Agent.IsJumping = true;
		}
		else if (phase == Phase.Attack)
		{
			if (base.Senses.FindTarget(out var target2))
			{
				if (target2 is BaseCombatEntity baseCombatEntity && Vector3.Distance(((Component)Owner).transform.position, ((Component)baseCombatEntity).transform.position) <= 1.7f)
				{
					didHit = true;
					baseCombatEntity.OnAttacked(35f, DamageType.Bite, Owner, ignoreShield: false);
				}
				if (target2 is BasePlayer basePlayer && Vector3.Distance(((Component)Owner).transform.position, ((Component)basePlayer).transform.position) <= 1f)
				{
					basePlayer.DoPush(((Component)Owner).transform.forward * 10f + Vector3.up * 3f);
				}
			}
		}
		else if (phase == Phase.PostJumpBack)
		{
			base.Agent.IsJumping = false;
		}
		return EFSMStateStatus.None;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		elapsedTime += deltaTime;
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		if (phase == Phase.PreJump)
		{
			Quaternion val = Quaternion.LookRotation(Vector3Ex.WithY(targetPosition - ((Component)Owner).transform.position, 0f));
			animState.initialRotation = Quaternion.RotateTowards(animState.initialRotation, val, Time.deltaTime * 60f);
			((Component)Owner).transform.rotation = animState.initialRotation;
			if (elapsedTime >= jumpOnStart && SetPhase(Phase.Jump) == EFSMStateStatus.Failure)
			{
				return EFSMStateStatus.Failure;
			}
		}
		if (phase == Phase.Jump && elapsedTime >= jumpOnEnd)
		{
			SetPhase(Phase.Attack);
		}
		if (phase == Phase.Attack && elapsedTime > jumpOffStart)
		{
			SetPhase(Phase.JumpBack);
		}
		if (phase == Phase.JumpBack && elapsedTime >= jumpOffEnd)
		{
			SetPhase(Phase.PostJumpBack);
		}
		if (elapsedTime >= animClip.inPlaceAnimation.length - 0.25f)
		{
			if (!didHit)
			{
				return EFSMStateStatus.Failure;
			}
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = true;
		base.Senses.UnlockTarget(ref targetLock);
		base.Agent.Unpause(ref movementLock);
		if (phase != Phase.PostJumpBack)
		{
			base.Agent.IsJumping = false;
		}
		base.OnStateExit();
	}
}


private enum Phase
{
	PreJump,
	Jump,
	Attack,
	JumpBack,
	PostJumpBack
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_DragCorpse : FSMStateBase
{
	[SerializeField]
	protected RootMotionData Animation;

	private const int numLoops = 6;

	private int currentLoop;

	private BaseCorpse corpse;

	private RootMotionPlayer.PlayServerState animState;

	private Action _updateCorpsePositionAction;

	private Action UpdateCorpsePositionAction => OnStateFixedUpdate;

	public override EFSMStateStatus OnStateEnter()
	{
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (!(food is BaseCorpse food2))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Senses.FindTarget(out var _))
		{
			return EFSMStateStatus.Failure;
		}
		if (!SingletonComponent<NpcFoodManager>.Instance.Remove(food2))
		{
			return EFSMStateStatus.Failure;
		}
		corpse = food2;
		corpse.SetFlag(BaseEntity.Flags.Reserved3, b: true);
		((FacepunchBehaviour)Owner).InvokeRepeatingFixedTime(UpdateCorpsePositionAction);
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (!corpse.IsValid() || corpse.IsDead())
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		if (animState != null)
		{
			Quaternion val = Quaternion.LookRotation(Vector3Ex.WithY(targetPosition - ((Component)Owner).transform.position, 0f));
			animState.initialRotation = Quaternion.RotateTowards(animState.initialRotation, val, Time.deltaTime * 60f);
			((Component)Owner).transform.rotation = animState.initialRotation;
		}
		if (!animState.isPlaying)
		{
			currentLoop++;
			if (currentLoop >= 6)
			{
				return EFSMStateStatus.Success;
			}
			base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
			animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		}
		return base.OnStateUpdate(deltaTime);
	}

	private void OnStateFixedUpdate()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (corpse.IsValid() && !corpse.IsDead())
		{
			Rigidbody component = ((Component)corpse).GetComponent<Rigidbody>();
			if (component != null)
			{
				component.MovePosition(((Component)Owner).transform.position + ((Component)Owner).transform.forward * 1.6f + ((Component)Owner).transform.up * 0.6f);
				component.velocity = Vector3.zero;
				component.angularVelocity = Vector3.zero;
			}
		}
	}

	public override void OnStateExit()
	{
		base.OnStateExit();
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
		currentLoop = 0;
		if (corpse.IsValid())
		{
			SingletonComponent<NpcFoodManager>.Instance.Add(corpse);
			corpse.SetFlag(BaseEntity.Flags.Reserved3, b: false);
		}
		corpse = null;
		((FacepunchBehaviour)Owner).CancelInvokeFixedTime(UpdateCorpsePositionAction);
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_FastSneak : State_CircleDynamic
{
	public override EFSMStateStatus OnStateEnter()
	{
		base.Agent.deceleration.Value = 10f;
		return base.OnStateEnter();
	}

	protected override void SetSpeed(BaseEntity target, float distToTarget, float normalizedDist)
	{
		if (!target.ToNonNpcPlayer(out var player))
		{
			base.SetSpeed(target, distToTarget, normalizedDist);
		}
		else if (distToTarget > 50f)
		{
			base.Agent.SetSpeed(8.25f);
		}
		else if (player.modelState.sprinting && distToTarget < 20f)
		{
			base.Agent.SetSpeed(6.875f);
		}
		else if (player.modelState.sprinting)
		{
			base.Agent.SetSpeed(8.25f);
		}
		else if (player.modelState.ducked || player.estimatedSpeed < 0.1f)
		{
			base.Agent.SetSpeed(1.7f);
		}
		else
		{
			base.Agent.SetSpeed(3.5f);
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_IsTargetDown : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		if (!base.Senses.FindTarget(out var target))
		{
			return false;
		}
		if (!target.ToNonNpcPlayer(out var player))
		{
			return false;
		}
		return player.IsWounded();
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_IsWatchedByTarget : FSMTransitionBase
{
	public float minTime = 1.5f;

	public bool requireAiming = true;

	public bool wantsWatched = true;

	protected override bool EvaluateInternal()
	{
		if (!base.Senses.FindTarget(out var target))
		{
			return false;
		}
		if (!base.Senses.GetVisibilityStatus(target, out var status))
		{
			return false;
		}
		return ((!wantsWatched) ? (requireAiming ? status.timeNotAimedAt : status.timeNotWatched) : (requireAiming ? status.timeAimedAt : status.timeWatched)) > minTime;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_IsInTargetViewCone : FSMTransitionBase
{
	public float angle = 90f;

	protected override bool EvaluateInternal()
	{
		return IsInTargetViewCone(base.Senses, angle);
	}

	public static bool IsInTargetViewCone(SenseComponent senses, float testAngle)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (!senses.FindTarget(out var target))
		{
			return false;
		}
		Vector3 val = ((Component)senses.GetBaseEntity()).transform.position - ((Component)target).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = (target.ToNonNpcPlayer(out var player) ? player.eyes.BodyForward() : ((Component)target).transform.forward);
		return Vector3.Dot(((Vector3)(ref val)).normalized, normalized) > Mathf.Cos(testAngle * (MathF.PI / 180f));
	}

	public override string ToString()
	{
		if (!Inverted)
		{
			return $"We are in target view cone of {angle} degrees";
		}
		return $"We are not in target view cone of {angle} degrees";
	}
}


using Rust.Ai.Gen2;

[SoftRequireComponent(typeof(Wolf2FSM))]
public class Wolf2 : BaseNPC2
{
	public override string Categorize()
	{
		return "Wolf";
	}
}


public static class NPCRangeConstants
{
	public const float MeleeRange = 2f;

	public const float CloseRange = 10f;

	public const float MediumRange = 16f;

	public const float LongRange = 50f;
}


public static class FireConstants
{
	public const float fireCirclingRadius = 16f;

	public const string HitByFire = "HitByFire";
}


using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class Wolf2FSM : FSMComponent
{
	public State_PlayRandomAnimation randomIdle = new State_PlayRandomAnimation();

	public State_Roam roam = new State_Roam();

	public State_Howl howl = new State_Howl();

	public State_CircleDynamic approach = new State_CircleDynamic();

	public State_Bark bark = new State_Bark();

	public State_Growl growlFire = new State_Growl();

	public State_ApproachFire approachFire = new State_ApproachFire();

	public State_FleeFire fleeFire = new State_FleeFire();

	public State_MoveToTarget charge = new State_MoveToTarget();

	public State_Attack attack = new State_Attack();

	public State_PlayAnimationRM leapAway = new State_PlayAnimationRM();

	public State_Circle reacCircle = new State_Circle();

	public State_CircleDynamic fastApproach = new State_CircleDynamic();

	public State_WolfHurt hurt = new State_WolfHurt();

	public State_Intimidated intimidated = new State_Intimidated();

	public State_Flee flee = new State_Flee();

	public State_Flee fleeForHowl = new State_Flee();

	public State_Dead dead = new State_Dead();

	public State_ApproachFood approachFood = new State_ApproachFood();

	public State_EatFood eatFood = new State_EatFood();

	public State_PlayAnimationRM growlFood = new State_PlayAnimationRM();

	public State_PlayAnimLoop sleep = new State_PlayAnimLoop();

	public State_AttackUnreachable attackUnreachable = new State_AttackUnreachable();

	private Trans_Triggerable_HitInfo HurtTrans;

	private Trans_Triggerable_HitInfo DeathTrans;

	private Trans_Triggerable<BaseEntity> AllyGotHurtNearby;

	private Trans_Triggerable<BaseEntity> HowlTrans;

	private Trans_Triggerable<BaseEntity> BarkTrans;

	public override void InitShared()
	{
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Expected O, but got Unknown
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Expected O, but got Unknown
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Expected O, but got Unknown
		if (base.baseEntity.isServer)
		{
			State_Nothing state_Nothing = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			State_Circle state_Circle = new State_Circle
			{
				radius = 2f,
				speed = LimitedTurnNavAgent.Speeds.Sprint,
				Name = "Combo circle"
			};
			State_MoveToTarget state_MoveToTarget = new State_MoveToTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Walk,
				decelerationOverride = 6f,
				Name = "Step forward"
			};
			State_MoveToLastReachablePointNearTarget state_MoveToLastReachablePointNearTarget = new State_MoveToLastReachablePointNearTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Sprint,
				succeedWhenDestinationIsReached = true,
				Name = "Go to last destination"
			};
			FSMStateBase fSMStateBase = leapAway.Clone();
			fSMStateBase.Name = "Leap away unreachable";
			State_Flee state_Flee = new State_Flee
			{
				distance = 8f,
				desiredDistance = 16f,
				Name = "Flee fire after attack"
			};
			FSMStateBase fSMStateBase2 = state_Circle.Clone();
			fSMStateBase2.Name = "Circle short fire";
			FSMStateBase fSMStateBase3 = charge.Clone();
			fSMStateBase3.Name = "Charge fire";
			FSMStateBase fSMStateBase4 = attack.Clone();
			fSMStateBase4.Name = "Attack fire";
			DeathTrans = new Trans_Triggerable_HitInfo();
			HurtTrans = new Trans_Triggerable_HitInfo();
			Trans_Triggerable PathFailedTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>().onPathFailed.AddListener((UnityAction)delegate
			{
				PathFailedTrans.Trigger();
			});
			Trans_Triggerable FireMeleeTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<SenseComponent>().onFireMelee.AddListener((UnityAction)delegate
			{
				FireMeleeTrans.Trigger();
			});
			Trans_Triggerable EncounterEndTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<NPCEncounterTimer>().onShouldGiveUp.AddListener((UnityAction)delegate
			{
				EncounterEndTrans.Trigger();
			});
			BarkTrans = new Trans_Triggerable<BaseEntity>();
			AllyGotHurtNearby = new Trans_Triggerable<BaseEntity>();
			HowlTrans = new Trans_Triggerable<BaseEntity>();
			State_Nothing state_Nothing2 = new State_Nothing();
			state_Nothing2.Name = "Root";
			State_Nothing state_Nothing3 = new State_Nothing
			{
				Name = "Alive"
			};
			State_Nothing state_Nothing4 = new State_Nothing
			{
				Name = "OnNavmesh"
			};
			State_Nothing state_Nothing5 = new State_Nothing
			{
				Name = "Food"
			};
			State_Nothing state_Nothing6 = new State_Nothing
			{
				Name = "Roaming"
			};
			State_Nothing state_Nothing7 = new State_Nothing
			{
				Name = "Has target"
			};
			State_Nothing state_Nothing8 = new State_Nothing
			{
				Name = "Not hurt"
			};
			State_Nothing state_Nothing9 = new State_Nothing
			{
				Name = "No fire"
			};
			State_Nothing state_Nothing10 = new State_Nothing
			{
				Name = "Reachable"
			};
			State_Nothing state_Nothing11 = new State_Nothing
			{
				Name = "Unreachable"
			};
			State_Nothing state_Nothing12 = new State_Nothing
			{
				Name = "Fire"
			};
			State_Nothing state_Nothing13 = new State_Nothing
			{
				Name = "Fire melee reac"
			};
			State_Nothing state_Nothing14 = new State_Nothing
			{
				Name = "Ready to help"
			};
			State_Nothing state_Nothing15 = new State_Nothing
			{
				Name = "Fire entry"
			};
			State_Nothing state_Nothing16 = new State_Nothing
			{
				Name = "Combat entry"
			};
			State_Nothing state_Nothing17 = new State_Nothing
			{
				Name = "Random post idle wait"
			};
			state_Nothing2.AddChildren(state_Nothing3.AddTickTransition(dead, DeathTrans).AddChildren(state_Nothing.AddTickTransition(roam, new Trans_IsNavmeshReady()), state_Nothing4.AddTickTransition(state_Nothing, new Trans_IsNavmeshReady
			{
				Inverted = true
			}).AddChildren(state_Nothing8.AddTickTransition(hurt, HurtTrans).AddChildren(state_Nothing6.AddTickTransition(dead, PathFailedTrans).AddTickTransition(approach, HowlTrans).AddTickTransition(state_Nothing16, new Trans_HasTarget())
				.AddTickTransition(approachFood, new Trans_SeesFood())
				.AddChildren(roam.AddEndTransition(sleep, new Trans_RandomChance
				{
					Chance = 0.25f
				}).AddEndTransition(randomIdle), sleep.AddEndTransition(roam), randomIdle.AddEndTransition(state_Nothing17), state_Nothing17.AddTickTransition(roam, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 0.0,
					MaxDuration = 3.0
				})), state_Nothing7.AddTickTransition(roam, new Trans_HasTarget
			{
				Inverted = true
			}).AddTickTransition(flee, EncounterEndTrans).AddTickTransition(flee, new Trans_TargetIsInSafeZone())
				.AddChildren(state_Nothing10.AddTickTransition(flee, new Trans_IsInWater_Slow() | new Trans_IsTargetInWater()).AddTickTransition(state_MoveToLastReachablePointNearTarget, PathFailedTrans).AddChildren(state_Nothing9.AddTickTransition(state_Nothing15, new Trans_TargetIsNearFire
				{
					onlySeeFireWhenClose = true
				}).AddChildren(state_Nothing16.AddTickTransition(howl, new Trans_HasBlackboardBool
				{
					Key = "WolfNearbyAlreadyHowled",
					Inverted = true
				}).AddTickTransition(approach, new Trans_AlwaysValid()), state_Nothing14.AddTickTransition(flee, new Trans_And
				{
					AllyGotHurtNearby,
					new Trans_TargetIsNearFire()
				}).AddTickTransition(fastApproach, AllyGotHurtNearby).AddTickTransition(charge, BarkTrans)
					.AddChildren(howl.AddTickTransition(approach, new Trans_TargetInRange
					{
						Range = 12f
					}).AddEndTransition(approach), approach.AddTickBranchingTrans(charge, new Trans_TargetInRange
					{
						Range = 12f
					}, bark, new Trans_HasBlackboardBool
					{
						Key = "WolfNearbyAlreadyBarked",
						Inverted = true
					}).AddTickTransition(approachFood, new Trans_And
					{
						new Trans_SeesFood(),
						new Trans_HasBlackboardBool
						{
							Key = "TriedToApproachUnreachableFood",
							Inverted = true
						}
					})), bark.AddTickTransition(charge, new Trans_TargetInRange
				{
					Range = 2f
				}).AddEndTransition(charge), charge.AddTickTransition(fastApproach, AllyGotHurtNearby).AddTickTransition(attack, new Trans_TargetInRange
				{
					Range = 2f
				}).AddTickTransition(approach, new Trans_ElapsedTime
				{
					Duration = 5.0
				})
					.AddFailureTransition(state_MoveToLastReachablePointNearTarget), attack.AddEndTransition(leapAway, new Trans_TargetInFront
				{
					Angle = 120f,
					Inverted = true
				}).AddEndTransition(state_Circle), leapAway.AddEndTransition(state_Circle), state_Circle.AddTickTransition(charge, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 0.75,
					MaxDuration = 1.5
				}).AddEndTransition(charge), reacCircle.AddTickTransition(reacCircle, AllyGotHurtNearby).AddTickTransition(charge, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 2.0,
					MaxDuration = 4.0
				}).AddEndTransition(charge), fastApproach.AddTickTransition(reacCircle, new Trans_TargetInRange
				{
					Range = reacCircle.radius + 5f
				}).AddTickTransition(charge, BarkTrans), fleeForHowl.AddEndTransition(howl)), state_Nothing12.AddTickTransition(flee, PathFailedTrans).AddTickTransition(flee, AllyGotHurtNearby).AddChildren(state_Nothing15.AddTickTransition(intimidated, new Trans_TargetInRange
				{
					Range = 12f
				}).AddTickTransition(growlFire, new Trans_HasBlackboardBool
				{
					Key = "AlreadyGrowled",
					Inverted = true
				}).AddTickTransition(approachFire, new Trans_AlwaysValid()), state_Nothing13.AddTickBranchingTrans(intimidated, FireMeleeTrans, growlFire, new Trans_RandomChance
				{
					Chance = 0.75f
				}).AddChildren(approachFire.AddTickTransition(fSMStateBase2, new Trans_TargetInRange
				{
					Range = 5f
				}).AddTickTransition(fastApproach, new Trans_TargetIsNearFire
				{
					Inverted = true
				}).AddTickTransition(fastApproach, new Trans_TargetInRange
				{
					Range = 21f,
					Inverted = true
				}), state_MoveToTarget.AddTickTransition(fSMStateBase2, new Trans_TargetInRange
				{
					Range = 5f
				}).AddTickTransition(approachFire, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 1.0,
					MaxDuration = 3.0
				})), growlFire.AddTickTransition(intimidated, FireMeleeTrans).AddTickTransition(fSMStateBase2, new Trans_TargetInRange
				{
					Range = 5f
				}).AddEndTransition(approachFire), fSMStateBase2.AddTickTransition(fSMStateBase3, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 0.5,
					MaxDuration = 1.25
				}).AddEndTransition(fSMStateBase3), fSMStateBase3.AddTickTransition(fSMStateBase4, new Trans_TargetInRange
				{
					Range = 2f
				}), fSMStateBase4.AddEndTransition(state_Flee), intimidated.AddEndTransition(fleeFire), fleeFire.AddEndTransition(state_MoveToTarget), state_Flee.AddEndTransition(state_MoveToTarget))), state_Nothing11.AddChildren(state_MoveToLastReachablePointNearTarget.AddFailureTransition(flee).AddTickTransition(flee, FireMeleeTrans).AddTickTransition(charge, new Trans_CanReachTarget_Slow())
					.AddEndTransition(charge, new Trans_CanReachTarget_Slow())
					.AddEndTransition(attackUnreachable)
					.AddEndTransition(flee), fSMStateBase.AddEndTransition(state_MoveToLastReachablePointNearTarget)), flee.AddTickTransition(dead, PathFailedTrans).AddEndTransition(fastApproach, new Trans_TargetInRange
				{
					Range = flee.desiredDistance
				}).AddEndTransition(roam)), state_Nothing5.AddTickTransition(state_Nothing15, new Trans_TargetIsNearFire
			{
				onlySeeFireWhenClose = true
			}).AddTickTransition(approach, HowlTrans).AddTickTransition(fastApproach, AllyGotHurtNearby)
				.AddTickTransition(charge, BarkTrans)
				.AddTickTransition(roam, new Trans_SeesFood
				{
					Inverted = true
				})
				.AddChildren(approachFood.AddTickTransition(growlFood, new Trans_TargetInRange
				{
					Range = 12f
				}).AddFailureTransition(roam).AddEndTransition(eatFood), eatFood.AddTickTransition(growlFood, new Trans_TargetInRange
				{
					Range = 12f
				}).AddFailureTransition(roam).AddEndTransition(roam), growlFood.AddTickTransition(bark, new Trans_TargetInRange
				{
					Range = 5f
				}).AddEndTransition(bark, new Trans_TargetInRange
				{
					Range = 12f
				}).AddEndTransition(approachFood))), hurt.AddEndTransition(flee, new Trans_IsHealthBelowPercentage()).AddEndTransition(flee, new Trans_HasBlackboardBool
			{
				Key = "HitByFire"
			}).AddEndTransition(flee, new Trans_TargetIsNearFire())
				.AddEndTransition(flee, new Trans_TargetInRange
				{
					Range = 50f,
					Inverted = true
				})
				.AddEndTransition(fleeForHowl, new Trans_InitialAlliesNotFighting())
				.AddEndTransition(charge, new Trans_And
				{
					new Trans_RandomChance
					{
						Chance = 0.5f
					},
					new Trans_TargetInRange
					{
						Range = 12f
					}
				})
				.AddEndTransition(reacCircle, new Trans_TargetInRange
				{
					Range = reacCircle.radius + 5f
				})
				.AddEndTransition(fastApproach)), attackUnreachable.AddFailureTransition(flee).AddEndTransition(flee, new Trans_TargetIsNearFire()).AddEndTransition(fSMStateBase)), dead);
			SetState(state_Nothing);
			SetFsmActive(newActive: true);
		}
	}

	public override void Hurt(HitInfo hitInfo)
	{
		if (((Component)this).GetComponent<SenseComponent>().CanTarget(hitInfo.Initiator) && (hitInfo.Initiator.IsNonNpcPlayer() || !(Random.value > 0.5f)))
		{
			HurtTrans.Trigger(hitInfo);
			if (base.CurrentState != hurt && base.CurrentState != dead)
			{
				ForceTickOnTheNextUpdate();
			}
		}
	}

	public void Intimidate(BaseEntity target)
	{
		AllyGotHurtNearby.Trigger(target);
	}

	public void Howl(BaseEntity target)
	{
		HowlTrans.Trigger(target);
	}

	public void Bark(BaseEntity target)
	{
		BarkTrans.Trigger(target);
	}

	public override bool OnDied(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
		return false;
	}
}


using Facepunch;
using Rust.Ai.Gen2;

public class Trans_Triggerable_HitInfo : Trans_Triggerable
{
	private HitInfo HitInfo;

	public virtual void Trigger(HitInfo hitInfo)
	{
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
		HitInfo = Pool.Get<HitInfo>();
		HitInfo.CopyFrom(hitInfo);
		Trigger();
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		if (base.Triggered && to is IParametrized<HitInfo> parametrized)
		{
			parametrized.SetParameter(HitInfo);
		}
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
[SoftRequireComponent(typeof(LimitedTurnNavAgent), typeof(SenseComponent), typeof(BlackboardComponent))]
public class State_ApproachFood : State_MoveToTarget
{
	public const string TriedToApproachUnreachableFood = "TriedToApproachUnreachableFood";

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (food.WaterFactor() > 0f || !base.Agent.CanReach(((Component)food).transform.position))
		{
			base.Blackboard.Add("TriedToApproachUnreachableFood");
			SingletonComponent<NpcFoodManager>.Instance.Remove(food);
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			destination = Vector3.zero;
			return false;
		}
		destination = ((Component)food).transform.position;
		return true;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
[SoftRequireComponent(typeof(RootMotionPlayer))]
public class State_EatFood : FSMStateBase
{
	[SerializeField]
	protected AnimationClip Animation;

	private const float damageToCorpsesPerLoop = 2.5f;

	private const float timeToForgetSightingWhileEating = 5f;

	private RootMotionPlayer.PlayServerState animState;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 val = ((Component)food).transform.position - ((Component)Owner).transform.position;
		val.y = 0f;
		((Component)Owner).transform.rotation = Quaternion.LookRotation(val);
		base.Senses.timeToForgetSightings.Value = 5f;
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (!animState.isPlaying)
		{
			if (food is BaseCorpse baseCorpse)
			{
				baseCorpse.Hurt(2.5f);
				if (baseCorpse.IsDead())
				{
					base.Senses.ClearTarget();
					return EFSMStateStatus.Success;
				}
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
			}
			else if (food is DroppedItem droppedItem)
			{
				droppedItem.item.amount = Mathf.FloorToInt((float)droppedItem.item.amount * 0.5f);
				if (droppedItem.item.amount <= 0)
				{
					droppedItem.DestroyItem();
					droppedItem.Kill();
					base.Senses.ClearTarget();
					return EFSMStateStatus.Success;
				}
				droppedItem.item.MarkDirty();
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
			}
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Senses.timeToForgetSightings.Reset();
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Flee : FSMStateBase
{
	[SerializeField]
	public float desiredDistance = 50f;

	[SerializeField]
	public float distance = 20f;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.Sprint;

	[SerializeField]
	private int maxAttempts = 3;

	private int attempts;

	protected float startDistance;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.Blackboard.Remove("HitByFire");
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		attempts = 0;
		base.Agent.SetSpeed(speed);
		base.Agent.shouldStopAtDestination = false;
		startDistance = Vector3.Distance(((Component)Owner).transform.position, targetPosition);
		return MoveAwayFromTarget();
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (base.Agent.IsFollowingPath)
		{
			return base.OnStateUpdate(deltaTime);
		}
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		if (Vector3.Distance(targetPosition, ((Component)Owner).transform.position) > desiredDistance + startDistance)
		{
			return EFSMStateStatus.Success;
		}
		attempts++;
		if (attempts >= maxAttempts)
		{
			return EFSMStateStatus.Success;
		}
		return MoveAwayFromTarget();
	}

	protected virtual EFSMStateStatus MoveAwayFromTarget()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			Eqs.SamplePositionsInDonutShape(base.Agent.NavPosition, (List<Vector3>)(object)val, distance);
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				Vector3 val2 = Vector3Ex.NormalizeXZ(((Component)Owner).transform.position - targetPosition);
				foreach (Vector3 item3 in (List<Vector3>)(object)val)
				{
					Vector3 val3 = item3 - ((Component)Owner).transform.position;
					float item = Vector3.Dot(val2, ((Vector3)(ref val3)).normalized);
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item3, item));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				foreach (var item4 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item2 = item4.Item1;
					if (base.Agent.SamplePosition(item2, out var sample, 10f) && (base.Agent.canSwim || !base.Agent.IsInWater(sample)) && base.Agent.SetDestination(sample))
					{
						return EFSMStateStatus.None;
					}
				}
				return EFSMStateStatus.Failure;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_FleeFire : State_Flee
{
	private int numExecutions;

	private int maxExecutionsBeforeMinDist = 2;

	private float minDistance = 8f;

	private float maxDistance = 20f;

	private double timeOfLastExecution;

	public override EFSMStateStatus OnStateEnter()
	{
		if (Time.timeAsDouble - timeOfLastExecution > 30.0)
		{
			numExecutions = 0;
		}
		timeOfLastExecution = Time.timeAsDouble;
		distance = 7f;
		desiredDistance = Mathx.RemapValClamped((float)numExecutions, 0f, (float)maxExecutionsBeforeMinDist, maxDistance, minDistance);
		numExecutions++;
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (base.Senses.FindTargetPosition(out var targetPosition) && Time.timeAsDouble - timeOfLastExecution > 1.0 && Vector3.Distance(((Component)Owner).transform.position, targetPosition) > desiredDistance)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Roam : FSMStateBase
{
	[SerializeField]
	private Vector2 distanceRange = new Vector2(10f, 20f);

	[SerializeField]
	private float homeRadius = 50f;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds minSpeed;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds maxSpeed = LimitedTurnNavAgent.Speeds.Sprint;

	[SerializeField]
	protected bool favourWater;

	private Vector3? spawnPosition;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Reset();
		if (!spawnPosition.HasValue)
		{
			spawnPosition = ((Component)Owner).transform.position;
		}
		if (!TrySetRoamDestination())
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	private bool TrySetRoamDestination()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			float num = Random.Range(distanceRange.x, distanceRange.y);
			Eqs.SamplePositionsInDonutShape(base.Agent.NavPosition, (List<Vector3>)(object)val, num);
			bool flag = Vector3.Distance(spawnPosition.Value, ((Component)Owner).transform.position) > homeRadius;
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				Vector3 val2 = spawnPosition.Value - ((Component)Owner).transform.position;
				Vector3 normalized = ((Vector3)(ref val2)).normalized;
				foreach (Vector3 item2 in (List<Vector3>)(object)val)
				{
					float num2 = 0f;
					if (flag)
					{
						float num3 = num2;
						val2 = item2 - ((Component)Owner).transform.position;
						num2 = num3 + Mathx.RemapValClamped(Vector3.Dot(normalized, ((Vector3)(ref val2)).normalized), -1f, 1f, 0f, 1f);
						if (base.Agent.IsPositionOnFavoredTerrain(item2))
						{
							num2 += 0.25f;
						}
					}
					else
					{
						num2 += Random.value;
						if (base.Agent.IsPositionOnFavoredTerrain(item2))
						{
							num2 += 10f;
						}
					}
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item2, num2));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				foreach (var item3 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item = item3.Item1;
					if (base.Agent.SamplePosition(item, out var sample, 10f) && (base.Agent.canSwim || !base.Agent.IsInWater(sample)) && base.Agent.SetDestination(sample))
					{
						float ratio = Mathf.InverseLerp(0f, distanceRange.y, num);
						base.Agent.SetSpeedRatio(ratio, minSpeed, maxSpeed);
						return true;
					}
				}
				return false;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Agent.IsFollowingPath)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	private void Reset()
	{
		base.Senses.ClearTarget();
		base.Blackboard.Clear();
		if (Owner is BaseCombatEntity { healthFraction: <1f, SecondsSinceAttacked: >120f } baseCombatEntity)
		{
			baseCombatEntity.SetHealth(Owner.MaxHealth());
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Oxide.Core;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Dead : FSMStateBase, IParametrized<HitInfo>
{
	[SerializeField]
	private string deathStatName;

	[SerializeField]
	private GameObjectRef CorpsePrefab;

	[SerializeField]
	private RootMotionData staticDeathAnim;

	[SerializeField]
	private RootMotionData forwardMotionDeathAnim;

	[SerializeField]
	private float ragdollWhenAnimRemainingTimeIsBelow = 0.5f;

	[SerializeField]
	private LootContainer.LootSpawnSlot[] LootSpawnSlots;

	private HitInfo HitInfo;

	private RootMotionPlayer.PlayServerState animState;

	private Action _startRagdollAction;

	private Action StartRagdollAction => StartRagdoll;

	public void SetParameter(HitInfo parameter)
	{
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
		if (parameter == null)
		{
			Debug.LogWarning((object)"No parameter set for death state");
		}
		HitInfo = Pool.Get<HitInfo>();
		HitInfo.CopyFrom(parameter);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		if (HitInfo != null && (Object)(object)HitInfo.InitiatorPlayer != (Object)null && !HitInfo.InitiatorPlayer.IsNpc)
		{
			BasePlayer initiatorPlayer = HitInfo.InitiatorPlayer;
			if (((Object)(object)Owner).Is<BaseNPC2>(out BaseNPC2 castedUnityObject) && castedUnityObject.IsAnimal)
			{
				initiatorPlayer.GiveAchievement("KILL_ANIMAL");
			}
			if (!string.IsNullOrEmpty(deathStatName))
			{
				initiatorPlayer.stats.Add(deathStatName, 1, (Stats)5);
				initiatorPlayer.stats.Save();
			}
			if (Owner is BaseCombatEntity killed)
			{
				initiatorPlayer.LifeStoryKill(killed);
			}
		}
		if (!CorpsePrefab.isValid)
		{
			Owner.Kill();
			return base.OnStateEnter();
		}
		if (forwardMotionDeathAnim != null && base.Agent.IsSpeedGTE(LimitedTurnNavAgent.Speeds.Run))
		{
			animState = base.AnimPlayer.PlayServerAndTakeFromPool(forwardMotionDeathAnim);
			float num = Mathf.Max(0f, forwardMotionDeathAnim.inPlaceAnimation.length - ragdollWhenAnimRemainingTimeIsBelow);
			((FacepunchBehaviour)Owner).Invoke(StartRagdollAction, num + AI.defaultInterpolationDelay);
		}
		else if (staticDeathAnim != null && HitInfo != null && Vector3.Dot(HitInfo.attackNormal, ((Component)Owner).transform.forward) < 0f)
		{
			animState = base.AnimPlayer.PlayServerAndTakeFromPool(staticDeathAnim);
			float num2 = Mathf.Max(0f, staticDeathAnim.inPlaceAnimation.length - ragdollWhenAnimRemainingTimeIsBelow);
			((FacepunchBehaviour)Owner).Invoke(StartRagdollAction, num2 + AI.defaultInterpolationDelay);
		}
		else
		{
			StartRagdoll();
		}
		return base.OnStateEnter();
	}

	private void StartRagdoll()
	{
		BaseCorpse baseCorpse = Owner.DropCorpse(CorpsePrefab.resourcePath);
		if (((Object)(object)baseCorpse).Is<LootableCorpse>(out LootableCorpse castedUnityObject))
		{
			castedUnityObject.TakeFrom(Owner, CreateInventory());
			PrefabInformation prefabInformation = PrefabAttribute.server.Find<PrefabInformation>(Owner.prefabID);
			if (prefabInformation != null && prefabInformation.title.IsValid())
			{
				castedUnityObject.playerName = prefabInformation.title.translated;
			}
			else
			{
				castedUnityObject.playerName = ((object)Owner).GetType().Name;
			}
			castedUnityObject.Spawn();
			baseCorpse.TakeChildren(Owner);
			if (Interface.CallHook("OnCorpsePopulate", (object)Owner, (object)castedUnityObject) == null && LootSpawnSlots.Length != 0)
			{
				LootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
				for (int i = 0; i < lootSpawnSlots.Length; i++)
				{
					LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
					for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
					{
						if (Random.Range(0f, 1f) <= lootSpawnSlot.probability)
						{
							lootSpawnSlot.definition.SpawnIntoContainer(castedUnityObject.containers[0]);
						}
					}
				}
			}
		}
		else if ((Object)(object)baseCorpse != (Object)null)
		{
			baseCorpse.Spawn();
			baseCorpse.TakeChildren(Owner);
		}
		((FacepunchBehaviour)Owner).Invoke((Action)Owner.KillMessage, 0.5f);
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
		Pool.Free<HitInfo>(ref HitInfo);
		base.OnStateExit();
	}

	private ItemContainer CreateInventory()
	{
		ItemContainer itemContainer = new ItemContainer
		{
			entityOwner = Owner
		};
		itemContainer.ServerInitialize(null, 24);
		if (!((ItemContainerId)(ref itemContainer.uid)).IsValid)
		{
			itemContainer.GiveUID();
		}
		return itemContainer;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Howl : State_PlayAnimation
{
	public const string WolfNearbyAlreadyHowled = "WolfNearbyAlreadyHowled";

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var targetEntity))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Agent.CanReach(((Component)targetEntity).transform.position, updateLastValidPath: true))
		{
			base.Agent.ResetPath();
			return EFSMStateStatus.Failure;
		}
		base.Blackboard.Add("WolfNearbyAlreadyHowled");
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetInitialAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<BlackboardComponent>().Add("WolfNearbyAlreadyHowled");
				Wolf2FSM otherWolf = ((Component)item).GetComponent<Wolf2FSM>();
				((FacepunchBehaviour)Owner).Invoke((Action)delegate
				{
					otherWolf.Howl(targetEntity);
				}, 1f);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_Growl : State_PlayAnimationRM
{
	public const string AlreadyGrowled = "AlreadyGrowled";

	public override EFSMStateStatus OnStateEnter()
	{
		base.Blackboard.Increment("AlreadyGrowled");
		return base.OnStateEnter();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Bark : State_PlayAnimation
{
	public const string WolfNearbyAlreadyBarked = "WolfNearbyAlreadyBarked";

	public override EFSMStateStatus OnStateEnter()
	{
		if (!base.Senses.FindTarget(out var targetEntity))
		{
			return EFSMStateStatus.Failure;
		}
		base.Blackboard.Add("WolfNearbyAlreadyBarked");
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetInitialAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<BlackboardComponent>().Add("WolfNearbyAlreadyBarked");
				Wolf2FSM otherWolf = ((Component)item).GetComponent<Wolf2FSM>();
				((FacepunchBehaviour)Owner).Invoke((Action)delegate
				{
					otherWolf.Bark(targetEntity);
				}, Mathf.Max(0f, Animation.length + Random.Range(-0.5f, 0.5f)));
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Intimidated : State_PlayAnimationRM
{
	private static readonly float facingAwayDotThreshold = Mathf.Cos(MathF.PI / 2f);

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		FaceTarget = true;
		if (base.Senses.FindTargetPosition(out var targetPosition))
		{
			Vector3 forward = ((Component)Owner).transform.forward;
			Vector3 val = ((Component)Owner).transform.position - targetPosition;
			if (Vector3.Dot(forward, ((Vector3)(ref val)).normalized) > facingAwayDotThreshold)
			{
				return EFSMStateStatus.Success;
			}
		}
		return base.OnStateEnter();
	}
}


using System;
using Facepunch;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Hurt : State_PlayAnimationRM, IParametrized<HitInfo>
{
	[SerializeField]
	private RootMotionData StrongHitL;

	[SerializeField]
	private RootMotionData StrongHitR;

	[SerializeField]
	private RootMotionData WeakHit;

	[SerializeField]
	private float StaggerRatio = 0.5f;

	private HitInfo HitInfo;

	public void SetParameter(HitInfo parameter)
	{
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
		if (parameter == null)
		{
			Debug.LogWarning((object)"No parameter set for hurt state");
		}
		HitInfo = Pool.Get<HitInfo>();
		HitInfo.CopyFrom(parameter);
	}

	public bool ShouldStagger(BaseEntity owner, HitInfo hitInfo)
	{
		float num = owner.Health() + hitInfo.damageTypes.Total();
		float num2 = owner.MaxHealth() * StaggerRatio;
		if (num > num2)
		{
			return owner.Health() < num2;
		}
		return false;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (HitInfo == null)
		{
			Debug.LogWarning((object)"No hitinfo set for hurt state");
			return base.OnStateEnter();
		}
		if (HitInfo.damageTypes.Has(DamageType.Heat))
		{
			base.Blackboard.Add("HitByFire");
		}
		if (WeakHit == null || ShouldStagger(Owner, HitInfo))
		{
			bool flag = Vector3.Dot(HitInfo.attackNormal, ((Component)Owner).transform.right) > 0f;
			Animation = (flag ? StrongHitL : StrongHitR);
		}
		else
		{
			Animation = WeakHit;
		}
		if (HitInfo.Initiator is BaseCombatEntity baseCombatEntity)
		{
			bool flag2 = true;
			if (base.Senses.FindTarget(out var target))
			{
				bool num = Owner.Distance((BaseEntity)baseCombatEntity) < 16f;
				bool flag3 = !target.IsNonNpcPlayer() && baseCombatEntity.IsNonNpcPlayer();
				flag2 = num || flag3;
			}
			if (flag2)
			{
				base.Senses.TrySetTarget(baseCombatEntity);
			}
		}
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		Pool.Free<HitInfo>(ref HitInfo);
		base.OnStateExit();
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_WolfHurt : State_Hurt
{
	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		if (!base.Senses.FindTarget(out var target))
		{
			if (AI.logIssues)
			{
				Debug.LogWarning((object)"Got attacked but couldn't find a target");
			}
			return result;
		}
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetInitialAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<Wolf2FSM>().Intimidate(target);
			}
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using ConVar;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Assertions;

[Serializable]
public class State_Attack : State_PlayAnimationRM
{
	[SerializeField]
	public float Damage = 30f;

	[SerializeField]
	public float Delay = 0.5f;

	[SerializeField]
	public DamageType DamageType = DamageType.Bite;

	private Action _doDamageAction;

	protected Action DoDamageAction => _doDamageAction ?? (_doDamageAction = DoDamage);

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(Delay < Animation.inPlaceAnimation.length);
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		if (!FaceTarget)
		{
			Vector3 val = Vector3Ex.NormalizeXZ(((Component)Owner).transform.position - targetPosition);
			Vector3 val2 = Vector3.Cross(Vector3.up, val);
			targetPosition += ((Random.value > 0.5f) ? 1f : (-1f)) * val2;
			Vector3 val3 = Vector3Ex.NormalizeXZ(targetPosition - ((Component)Owner).transform.position);
			((Component)Owner).transform.rotation = Quaternion.LookRotation(val3);
		}
		((FacepunchBehaviour)Owner).Invoke(DoDamageAction, Delay + AI.defaultInterpolationDelay);
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		((FacepunchBehaviour)Owner).CancelInvoke(DoDamageAction);
		base.OnStateExit();
	}

	protected virtual void DoDamage()
	{
		if (base.Senses.FindTarget(out var target) && target is BaseCombatEntity baseCombatEntity)
		{
			baseCombatEntity.OnAttacked(Damage, DamageType, Owner, ignoreShield: false);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_Circle : FSMStateBase, IParametrized<BaseEntity>
{
	[SerializeField]
	public float radius = 16f;

	[SerializeField]
	public LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.Sprint;

	private bool clockWise = true;

	private float radiusOffset;

	public void SetParameter(BaseEntity target)
	{
		base.Senses.TrySetTarget(target);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		base.Agent.SetSpeed(speed);
		radiusOffset = Random.Range(-1f, 1f);
		clockWise = Random.value > 0.5f;
		base.Agent.shouldStopAtDestination = false;
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	protected virtual bool GetCircleOrigin(out Vector3 origin)
	{
		return base.Senses.FindTargetPosition(out origin);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		if (!GetCircleOrigin(out var origin))
		{
			return EFSMStateStatus.Failure;
		}
		float num = radius + radiusOffset;
		Quaternion val = Quaternion.LookRotation(((Component)Owner).transform.position - origin);
		float num2 = (((Quaternion)(ref val)).eulerAngles.y + 5f * (float)(clockWise ? 1 : (-1))) * (MathF.PI / 180f);
		Vector3 val2 = origin + new Vector3(Mathf.Sin(num2), 0f, Mathf.Cos(num2)) * num;
		val2.y = Mathf.Lerp(origin.y, ((Component)Owner).transform.position.y, Mathf.InverseLerp(0f, Vector3.Distance(origin, ((Component)Owner).transform.position), num));
		NavMeshHit val3 = default(NavMeshHit);
		if (NavMesh.Raycast(((Component)Owner).transform.position, val2, ref val3, -1))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Agent.SetDestination(val2))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_ApproachFire : State_CircleDynamic
{
	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		base.Agent.deceleration.Value = 6f;
		distanceSpeedRange.x = 16f;
		return result;
	}

	public override void OnStateExit()
	{
		base.Agent.deceleration.Reset();
		base.OnStateExit();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CircleDynamic : FSMStateBase, IParametrized<BaseEntity>
{
	[SerializeField]
	private LimitedTurnNavAgent.Speeds minSpeed;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds maxSpeed = LimitedTurnNavAgent.Speeds.Sprint;

	[SerializeField]
	protected Vector2 distanceSpeedRange = new Vector2(10f, 50f);

	[SerializeField]
	private Vector2 angleRange = Vector2.op_Implicit(new Vector3(20f, 80f));

	[SerializeField]
	private Vector2 angleDurationRange = new Vector2(1f, 3f);

	[SerializeField]
	private Vector2 burstDurationRange = new Vector2(1f, 3f);

	[SerializeField]
	private Vector2 burstCooldownRange = new Vector2(1f, 10f);

	private Action _updateBurstAction;

	private Action _endBurstAction;

	private Action _updateAngleAction;

	private bool clockWise = true;

	private int burstSpeedIndexOffset;

	private float randomAngle;

	private Action UpdateBurstAction => UpdateBurst;

	private Action EndBurstAction => EndBurst;

	private Action UpdateAngleAction => UpdateAngle;

	public void SetParameter(BaseEntity target)
	{
		base.Senses.TrySetTarget(target);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		clockWise = Random.value > 0.5f;
		EndBurst();
		UpdateAngle();
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		((FacepunchBehaviour)Owner).CancelInvoke(UpdateBurstAction);
		((FacepunchBehaviour)Owner).CancelInvoke(EndBurstAction);
		((FacepunchBehaviour)Owner).CancelInvoke(UpdateAngleAction);
		base.OnStateExit();
	}

	private void UpdateAngle()
	{
		randomAngle = Random.Range(angleRange.x, angleRange.y) * (float)(clockWise ? 1 : (-1));
		((FacepunchBehaviour)Owner).Invoke(UpdateAngleAction, Random.Range(angleDurationRange.x, angleDurationRange.y));
	}

	private void UpdateBurst()
	{
		burstSpeedIndexOffset = 2;
		clockWise = Random.value > 0.5f;
		float num = Random.Range(burstDurationRange.x, burstDurationRange.y);
		((FacepunchBehaviour)Owner).Invoke(EndBurstAction, num);
	}

	private void EndBurst()
	{
		burstSpeedIndexOffset = 0;
		float num = Random.Range(burstCooldownRange.x, burstCooldownRange.y);
		((FacepunchBehaviour)Owner).Invoke(UpdateBurstAction, num);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 position = ((Component)target).transform.position;
		float num = Vector3.Distance(((Component)Owner).transform.position, position);
		float normalizedDist = Mathf.InverseLerp(distanceSpeedRange.x, distanceSpeedRange.y, num);
		SetSpeed(target, num, normalizedDist);
		float currentDeviation = Mathx.RemapValClamped(num, distanceSpeedRange.x, distanceSpeedRange.y, randomAngle, 0f);
		base.Agent.currentDeviation = currentDeviation;
		Vector3 newDestination = position;
		if (!base.Agent.SetDestination(newDestination))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}

	protected virtual void SetSpeed(BaseEntity target, float distToTarget, float normalizedDist)
	{
		base.Agent.SetSpeedRatio(normalizedDist, minSpeed, maxSpeed, burstSpeedIndexOffset);
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public class State_MoveToLastReachablePointNearTarget : State_MoveToTarget
{
	private const float maxHorizontalDist = 7f;

	private const float maxVerticalDist = 2.7f;

	private const float traceVerticalOffset = 1f;

	private Vector3 reachableDestination;

	private LockState.LockHandle targetLock;

	public static bool CanJumpFromPosToPos(BaseEntity owner, Vector3 ownerLocation, Vector3 targetPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (Mathf.Abs(targetPos.y - ownerLocation.y) > 2.7f)
		{
			return false;
		}
		if (Vector3.Distance(ownerLocation, targetPos) > 7f)
		{
			return false;
		}
		if (!owner.CanSee(ownerLocation + 1f * Vector3.up, targetPos + 1f * Vector3.up))
		{
			return false;
		}
		return true;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		if (!FindReachableLocation(out reachableDestination))
		{
			return EFSMStateStatus.Failure;
		}
		targetLock = base.Senses.LockCurrentTarget();
		base.Agent.deceleration.Value = 6f;
		return base.OnStateEnter();
	}

	private bool FindReachableLocation(out Vector3 location)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		location = default(Vector3);
		if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer basePlayer))
		{
			return false;
		}
		if (basePlayer.isMounted)
		{
			return false;
		}
		Vector3 position = ((Component)target).transform.position;
		if (Vector3.Distance(((Component)Owner).transform.position, position) > 50f)
		{
			return false;
		}
		Vector3? val = null;
		if (base.Agent.lastValidDestination.HasValue && Vector3.Distance(base.Agent.lastValidDestination.Value, position) <= 7f && base.Agent.SamplePosition(base.Agent.lastValidDestination.Value, out var sample, 7f) && CanJumpFromPosToPos(Owner, sample, position))
		{
			val = sample;
		}
		if (!val.HasValue && base.Agent.SamplePosition(position, out var sample2, 7f) && CanJumpFromPosToPos(Owner, sample2, position))
		{
			val = sample2;
		}
		if (!val.HasValue)
		{
			return false;
		}
		location = val.Value;
		return true;
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		destination = reachableDestination;
		return true;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (Trans_TargetIsNearFire.Test(Owner, base.Senses))
		{
			float ratio = Mathx.RemapValClamped(Vector3.Distance(((Component)Owner).transform.position, reachableDestination), 4f, 16f, 0f, 1f);
			base.Agent.SetSpeedRatio(ratio, LimitedTurnNavAgent.Speeds.Sneak, LimitedTurnNavAgent.Speeds.Jog);
		}
		else
		{
			base.Agent.SetSpeed(speed);
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.OnStateExit();
		base.Senses.UnlockTarget(ref targetLock);
		base.Agent.deceleration.Reset();
	}
}


using System;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_AttackUnreachable : FSMStateBase
{
	private enum Phase
	{
		PreJump,
		Jump,
		Attack,
		JumpBack,
		PostJumpBack
	}

	public float preJumpEnd = 0.29f;

	public float jumpEnd = 0.395f;

	public float attackEnd = 0.67f;

	public float jumpBackEnd = 0.765f;

	public float postJumpBackEnd = 0.95f;

	private const float groundCheckDistance = 2f;

	private const float damage = 35f;

	private const float meleeAttackRange = 1.7f;

	private const DamageType damageType = DamageType.Bite;

	public RootMotionData animClip;

	private Vector3 startLocation;

	private Quaternion startRotation;

	private Vector3 destination;

	private float elapsedTime;

	private LockState.LockHandle targetLock;

	private LockState.LockHandle movementLock;

	private Phase phase;

	private float previousOffsetZ;

	private RootMotionPlayer.PlayServerState animState;

	public static bool SampleGroundPositionUnderTarget(LimitedTurnNavAgent agent, BasePlayer targetAsPlayer, out Vector3 projectedLocation)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		float radius = BasePlayer.GetRadius();
		RaycastHit hitInfo;
		bool result = agent.SampleGroundPositionWithPhysics(((Component)targetAsPlayer).transform.position, out hitInfo, 2f, radius);
		projectedLocation = ((RaycastHit)(ref hitInfo)).point;
		return result;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer basePlayer))
		{
			return EFSMStateStatus.Failure;
		}
		destination = ((Component)target).transform.position;
		if (!basePlayer.IsOnGround() && !SampleGroundPositionUnderTarget(base.Agent, basePlayer, out destination))
		{
			return EFSMStateStatus.Failure;
		}
		if (!State_MoveToLastReachablePointNearTarget.CanJumpFromPosToPos(Owner, ((Component)Owner).transform.position, destination))
		{
			return EFSMStateStatus.Failure;
		}
		movementLock = base.Agent.Pause();
		elapsedTime = 0f;
		targetLock = base.Senses.LockCurrentTarget();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(animClip.inPlaceAnimation);
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = false;
		SetPhase(Phase.PreJump);
		return base.OnStateEnter();
	}

	private void SetPhase(Phase newPhase)
	{
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		phase = newPhase;
		previousOffsetZ = animClip.zMotionCurve.Evaluate(elapsedTime);
		if (phase == Phase.Jump)
		{
			if (base.Senses.FindTarget(out var target) && target is BasePlayer targetAsPlayer)
			{
				SampleGroundPositionUnderTarget(base.Agent, targetAsPlayer, out destination);
			}
			startLocation = ((Component)Owner).transform.position;
			((Component)Owner).transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(destination - ((Component)Owner).transform.position, 0f));
			base.Agent.IsJumping = true;
		}
		else if (phase == Phase.Attack)
		{
			startRotation = ((Component)Owner).transform.rotation;
			if (base.Senses.FindTarget(out var target2))
			{
				if (target2 is BaseCombatEntity baseCombatEntity && Vector3.Distance(((Component)Owner).transform.position, ((Component)baseCombatEntity).transform.position) <= 1.7f)
				{
					baseCombatEntity.OnAttacked(35f, DamageType.Bite, Owner, ignoreShield: false);
				}
				if (target2 is BasePlayer basePlayer && Vector3.Distance(((Component)Owner).transform.position, ((Component)basePlayer).transform.position) <= 1f)
				{
					basePlayer.DoPush(((Component)Owner).transform.forward * 10f + Vector3.up * 3f);
				}
			}
		}
		else if (phase == Phase.PostJumpBack)
		{
			base.Agent.IsJumping = false;
		}
	}

	private Vector3 ThreePointLerp(Vector3 a, Vector3 b, Vector3 c, float t)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Lerp(Vector3.Lerp(a, b, t), Vector3.Lerp(b, c, t), t);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		elapsedTime += deltaTime;
		float num = elapsedTime / Mathf.Max(animClip.inPlaceAnimation.length, 0.001f);
		if (phase == Phase.PreJump)
		{
			Quaternion val = Quaternion.LookRotation(Vector3Ex.WithY(destination - ((Component)Owner).transform.position, 0f));
			((Component)Owner).transform.rotation = Quaternion.Slerp(((Component)Owner).transform.rotation, val, 2f * deltaTime);
			float num2 = animClip.zMotionCurve.Evaluate(elapsedTime);
			Vector3 val2 = ((Component)Owner).transform.forward * (num2 - previousOffsetZ);
			previousOffsetZ = num2;
			Transform transform = ((Component)Owner).transform;
			transform.position += val2;
			if (num >= preJumpEnd)
			{
				SetPhase(Phase.Jump);
			}
		}
		if (phase == Phase.Jump)
		{
			Vector3 b = (startLocation + destination) * 0.5f;
			b.y = Mathf.Max(startLocation.y, destination.y);
			float t = Mathx.RemapValClamped(num, preJumpEnd, jumpEnd, 0f, 1f);
			Vector3 position = ThreePointLerp(startLocation, b, destination, t);
			((Component)Owner).transform.position = position;
			if (num >= jumpEnd)
			{
				SetPhase(Phase.Attack);
			}
		}
		if (phase == Phase.Attack)
		{
			((Component)Owner).transform.rotation = startRotation * Quaternion.AngleAxis(animClip.yRotationCurve.Evaluate(elapsedTime), Vector3.up);
			if (num > attackEnd)
			{
				SetPhase(Phase.JumpBack);
			}
		}
		if (phase == Phase.JumpBack)
		{
			Vector3 b2 = (startLocation + destination) * 0.5f;
			b2.y = Mathf.Max(startLocation.y, destination.y);
			float t2 = Mathx.RemapValClamped(num, attackEnd, jumpBackEnd, 0f, 1f);
			Vector3 position2 = ThreePointLerp(destination, b2, startLocation, t2);
			((Component)Owner).transform.position = position2;
			((Component)Owner).transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(startLocation - destination, 0f));
			if (num >= jumpBackEnd)
			{
				SetPhase(Phase.PostJumpBack);
			}
		}
		if (phase == Phase.PostJumpBack)
		{
			float num3 = animClip.zMotionCurve.Evaluate(elapsedTime);
			Vector3 val3 = ((Component)Owner).transform.forward * (num3 - previousOffsetZ);
			previousOffsetZ = num3;
			Transform transform2 = ((Component)Owner).transform;
			transform2.position -= val3;
		}
		if (num >= postJumpBackEnd)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = true;
		base.Senses.UnlockTarget(ref targetLock);
		base.Agent.Unpause(ref movementLock);
		if (phase != Phase.PostJumpBack)
		{
			base.Agent.IsJumping = false;
		}
		base.OnStateExit();
	}
}


private enum Phase
{
	PreJump,
	Jump,
	Attack,
	JumpBack,
	PostJumpBack
}


public class AIArena2 : FacepunchBehaviour, IClientComponent
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BlackboardComponent : EntityComponent<BaseEntity>, IServerComponent
{
	private const float factDuration = 30f;

	private Dictionary<string, int> addedFacts = new Dictionary<string, int>();

	private Dictionary<string, float> factExpirationTimes = new Dictionary<string, float>();

	public override void InitShared()
	{
		base.InitShared();
		((MonoBehaviour)this).InvokeRepeating("CleanExpiredFacts", Random.value, 1f);
	}

	public void Add(string value, float duration = 30f)
	{
		if (addedFacts.TryAdd(value, 1))
		{
			factExpirationTimes[value] = Time.time + duration;
		}
	}

	public void Increment(string value, float duration = 30f)
	{
		if (!addedFacts.TryGetValue(value, out var value2))
		{
			value2 = 0;
		}
		value2++;
		addedFacts[value] = value2;
		factExpirationTimes[value] = Time.time + duration;
	}

	public void Remove(string value)
	{
		if (addedFacts.Remove(value))
		{
			factExpirationTimes.Remove(value);
		}
	}

	public void Clear()
	{
		addedFacts.Clear();
		factExpirationTimes.Clear();
	}

	public bool Has(string value)
	{
		return addedFacts.ContainsKey(value);
	}

	public bool Count(string value, out int count)
	{
		return addedFacts.TryGetValue(value, out count);
	}

	public void CleanExpiredFacts()
	{
		TimeWarning val = TimeWarning.New("BlackboardComponent.CleanExpiredFacts", 0);
		try
		{
			float time = Time.time;
			PooledList<string> val2 = Pool.Get<PooledList<string>>();
			try
			{
				foreach (var (text2, _) in addedFacts)
				{
					if (factExpirationTimes[text2] < time)
					{
						((List<string>)(object)val2).Add(text2);
					}
				}
				foreach (string item in (List<string>)(object)val2)
				{
					Remove(item);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;

[Flags]
public enum EFSMStateStatus
{
	None = 0,
	Success = 1,
	Failure = 2
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(LimitedTurnNavAgent), typeof(RootMotionPlayer), typeof(SenseComponent))]
[SoftRequireComponent(typeof(BlackboardComponent), typeof(NPCEncounterTimer))]
public class FSMComponent : EntityComponent<BaseEntity>
{
	public class TickFSMWorkQueue : PersistentObjectWorkQueue<FSMComponent>
	{
		protected override void RunJob(FSMComponent component)
		{
			if (((PersistentObjectWorkQueue<FSMComponent>)this).ShouldAdd(component) && component.isRunning)
			{
				component.Senses.Tick();
				NPCEncounterTimer nPCEncounterTimer = default(NPCEncounterTimer);
				if (((Component)component).TryGetComponent<NPCEncounterTimer>(ref nPCEncounterTimer))
				{
					nPCEncounterTimer.Tick();
				}
				component.Tick();
				NpcBarkComponent npcBarkComponent = default(NpcBarkComponent);
				if (((Component)component).TryGetComponent<NpcBarkComponent>(ref npcBarkComponent))
				{
					npcBarkComponent.Tick();
				}
			}
		}

		protected override bool ShouldAdd(FSMComponent component)
		{
			if (base.ShouldAdd(component))
			{
				return component.baseEntity.IsValid();
			}
			return false;
		}
	}

	private bool isRunning;

	private SenseComponent _senses;

	public const float minRefreshIntervalSeconds = 0f;

	public const float maxRefreshIntervalSeconds = 0.5f;

	private double? _lastTickTime;

	private double nextRefreshTime;

	private const int maxStateChangesPerTick = 3;

	private List<FSMStateBase> sameFrameStateChangesHistory = new List<FSMStateBase>();

	private FSMStateBase pendingStateChange;

	public static TickFSMWorkQueue workQueue = new TickFSMWorkQueue();

	public const float frameBudgetMs = 1f;

	public FSMStateBase CurrentState { get; private set; }

	private SenseComponent Senses => _senses ?? (_senses = ((Component)base.baseEntity).GetComponent<SenseComponent>());

	private float RefreshInterval
	{
		get
		{
			if (!Senses.ShouldRefreshFast)
			{
				return 0.5f;
			}
			return 0f;
		}
	}

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	public void SetFsmActive(bool newActive)
	{
		if (newActive != isRunning)
		{
			isRunning = newActive;
			if (isRunning)
			{
				_lastTickTime = null;
				((PersistentObjectWorkQueue<FSMComponent>)workQueue).Add(this);
			}
			else
			{
				((PersistentObjectWorkQueue<FSMComponent>)workQueue).Remove(this);
			}
		}
	}

	public override void DestroyShared()
	{
		if (base.baseEntity.isServer)
		{
			SetFsmActive(newActive: false);
			base.DestroyShared();
		}
	}

	public static void ShowDebugInfoAroundLocation(BasePlayer player, float radius = 100f)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (!player.IsValid())
		{
			return;
		}
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			BaseEntity.Query.Server.GetBrainsInSphere(((Component)player).transform.position, radius, (List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				FSMComponent component = ((Component)item).GetComponent<FSMComponent>();
				if (!((Object)(object)component == (Object)null) && component.CurrentState != null && component.isRunning)
				{
					player.ClientRPC(RpcTarget.Player("CL_ShowStateDebugInfo", player), ((Component)component.baseEntity).transform.position, component.CurrentState.Name);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected void ForceTickOnTheNextUpdate()
	{
		nextRefreshTime = 0.0;
	}

	public void Tick()
	{
		TimeWarning val = TimeWarning.New("FSMComponent.Tick", 0);
		try
		{
			if (Time.timeAsDouble < nextRefreshTime)
			{
				return;
			}
			nextRefreshTime = Time.timeAsDouble + (double)RefreshInterval;
			float deltaTime = (float)(Time.timeAsDouble - LastTickTime);
			LastTickTime = Time.timeAsDouble;
			sameFrameStateChangesHistory.Clear();
			if (pendingStateChange != null)
			{
				SetState(pendingStateChange);
			}
			else
			{
				if (CurrentState == null)
				{
					return;
				}
				TimeWarning val2 = TimeWarning.New("NormalTransitions", 0);
				try
				{
					PooledList<FSMStateBase> val3 = Pool.Get<PooledList<FSMStateBase>>();
					try
					{
						CurrentState.FindAncestry((List<FSMStateBase>)(object)val3);
						foreach (FSMStateBase item in (List<FSMStateBase>)(object)val3)
						{
							foreach (var (fSMTransitionBase, fSMStateBase) in item.transitions)
							{
								fSMTransitionBase.Init(base.baseEntity);
								if (fSMTransitionBase.Evaluate())
								{
									fSMStateBase.Owner = base.baseEntity;
									fSMTransitionBase.OnTransitionTaken(CurrentState, fSMStateBase);
									SetState(fSMStateBase);
									return;
								}
							}
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				EFSMStateStatus currentStateStatus = EFSMStateStatus.None;
				TimeWarning val4 = TimeWarning.New("StateTick", 0);
				try
				{
					TimeWarning val5 = TimeWarning.New(CurrentState.Name, 0);
					try
					{
						currentStateStatus = CurrentState.OnStateUpdate(deltaTime);
					}
					finally
					{
						((IDisposable)val5)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val4)?.Dispose();
				}
				EvaluateEndTransitions(currentStateStatus);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void EvaluateEndTransitions(EFSMStateStatus currentStateStatus)
	{
		TimeWarning val = TimeWarning.New("EndTransitions", 0);
		try
		{
			if (currentStateStatus == EFSMStateStatus.None)
			{
				return;
			}
			PooledList<FSMStateBase> val2 = Pool.Get<PooledList<FSMStateBase>>();
			try
			{
				CurrentState.FindAncestry((List<FSMStateBase>)(object)val2);
				foreach (FSMStateBase item in (List<FSMStateBase>)(object)val2)
				{
					foreach (var (fSMTransitionBase, fSMStateBase, eFSMStateStatus) in item.endTransitions)
					{
						if (eFSMStateStatus == (EFSMStateStatus.Success | EFSMStateStatus.Failure) || eFSMStateStatus == currentStateStatus)
						{
							bool flag = true;
							if (fSMTransitionBase != null)
							{
								fSMTransitionBase.Init(base.baseEntity);
								flag = fSMTransitionBase.Evaluate();
							}
							if (flag)
							{
								fSMStateBase.Owner = base.baseEntity;
								fSMTransitionBase?.OnTransitionTaken(CurrentState, fSMStateBase);
								SetState(fSMStateBase);
								ForceTickOnTheNextUpdate();
								return;
							}
						}
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void SetState(FSMStateBase newState)
	{
		TimeWarning val = TimeWarning.New("SetState", 0);
		try
		{
			newState.Owner = base.baseEntity;
			pendingStateChange = null;
			sameFrameStateChangesHistory.Add(newState);
			if (sameFrameStateChangesHistory.Count > 3)
			{
				if (!AI.logIssues)
				{
					return;
				}
				StringBuilder stringBuilder = Pool.Get<StringBuilder>();
				stringBuilder.AppendFormat("[FSM] Possible endless recursion detected from {0} to {1} on {2}\n", CurrentState?.Name, newState.Name, base.baseEntity);
				foreach (FSMStateBase item in sameFrameStateChangesHistory)
				{
					stringBuilder.AppendFormat("{0} -> ", item.Name);
				}
				Debug.LogWarning((object)stringBuilder);
				pendingStateChange = newState;
				Pool.FreeUnmanaged(ref stringBuilder);
				return;
			}
			if (CurrentState != null)
			{
				TimeWarning val2 = TimeWarning.New("Transitions OnStateExit", 0);
				try
				{
					PooledList<FSMStateBase> val3 = Pool.Get<PooledList<FSMStateBase>>();
					try
					{
						CurrentState.FindAncestry((List<FSMStateBase>)(object)val3);
						foreach (FSMStateBase item2 in (List<FSMStateBase>)(object)val3)
						{
							foreach (var endTransition in item2.endTransitions)
							{
								endTransition.transition?.OnStateExit();
							}
							foreach (var transition in item2.transitions)
							{
								transition.transition.OnStateExit();
							}
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				TimeWarning val4 = TimeWarning.New("OnStateExit", 0);
				try
				{
					TimeWarning val5 = TimeWarning.New(CurrentState.Name, 0);
					try
					{
						CurrentState.OnStateExit();
					}
					finally
					{
						((IDisposable)val5)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val4)?.Dispose();
				}
			}
			CurrentState = newState;
			TimeWarning val6 = TimeWarning.New("Transitions OnStateEnter", 0);
			try
			{
				PooledList<FSMStateBase> val7 = Pool.Get<PooledList<FSMStateBase>>();
				try
				{
					CurrentState.FindAncestry((List<FSMStateBase>)(object)val7);
					foreach (FSMStateBase item3 in (List<FSMStateBase>)(object)val7)
					{
						foreach (var endTransition2 in item3.endTransitions)
						{
							endTransition2.transition?.OnStateEnter();
						}
						foreach (var transition2 in item3.transitions)
						{
							transition2.transition.OnStateEnter();
						}
					}
				}
				finally
				{
					((IDisposable)val7)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val6)?.Dispose();
			}
			TimeWarning val8 = TimeWarning.New("OnStateEnter", 0);
			try
			{
				TimeWarning val9 = TimeWarning.New(CurrentState.Name, 0);
				try
				{
					EFSMStateStatus currentStateStatus = CurrentState.OnStateEnter();
					EvaluateEndTransitions(currentStateStatus);
				}
				finally
				{
					((IDisposable)val9)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val8)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using UnityEngine;

public class TickFSMWorkQueue : PersistentObjectWorkQueue<FSMComponent>
{
	protected override void RunJob(FSMComponent component)
	{
		if (((PersistentObjectWorkQueue<FSMComponent>)this).ShouldAdd(component) && component.isRunning)
		{
			component.Senses.Tick();
			NPCEncounterTimer nPCEncounterTimer = default(NPCEncounterTimer);
			if (((Component)component).TryGetComponent<NPCEncounterTimer>(ref nPCEncounterTimer))
			{
				nPCEncounterTimer.Tick();
			}
			component.Tick();
			NpcBarkComponent npcBarkComponent = default(NpcBarkComponent);
			if (((Component)component).TryGetComponent<NpcBarkComponent>(ref npcBarkComponent))
			{
				npcBarkComponent.Tick();
			}
		}
	}

	protected override bool ShouldAdd(FSMComponent component)
	{
		if (base.ShouldAdd(component))
		{
			return component.baseEntity.IsValid();
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

public abstract class FSMStateBase
{
	[NonSerialized]
	public BaseEntity Owner;

	[SerializeField]
	private string _Name;

	[NonSerialized]
	public FSMStateBase parent;

	public List<(FSMTransitionBase transition, FSMStateBase dstState)> transitions = new List<(FSMTransitionBase, FSMStateBase)>();

	public List<(FSMTransitionBase transition, FSMStateBase dstState, EFSMStateStatus status)> endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();

	private SenseComponent _senses;

	private LimitedTurnNavAgent _agent;

	private RootMotionPlayer _animPlayer;

	private BlackboardComponent _blackboard;

	public string Name
	{
		get
		{
			if (string.IsNullOrEmpty(_Name))
			{
				_Name = GetType().Name.Replace("State_", "");
			}
			return _Name;
		}
		set
		{
			_Name = value;
		}
	}

	protected SenseComponent Senses => _senses ?? (_senses = ((Component)Owner).GetComponent<SenseComponent>());

	protected LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)Owner).GetComponent<LimitedTurnNavAgent>());

	protected RootMotionPlayer AnimPlayer => _animPlayer ?? (_animPlayer = ((Component)Owner).GetComponent<RootMotionPlayer>());

	protected BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	public virtual EFSMStateStatus OnStateEnter()
	{
		return EFSMStateStatus.None;
	}

	public virtual EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		return EFSMStateStatus.None;
	}

	public virtual void OnStateExit()
	{
	}

	protected T GetRootFSM<T>() where T : FSMComponent
	{
		return ((Component)Owner).GetComponent<T>();
	}

	public virtual FSMStateBase Clone()
	{
		FSMStateBase obj = (FSMStateBase)MemberwiseClone();
		obj.transitions = new List<(FSMTransitionBase, FSMStateBase)>();
		obj.endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();
		return obj;
	}

	public void FindAncestry(List<FSMStateBase> ancestry)
	{
		TimeWarning val = TimeWarning.New("FindAncestry", 0);
		try
		{
			FindAncestryRecursive(ancestry);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void FindAncestryRecursive(List<FSMStateBase> ancestry)
	{
		parent?.FindAncestryRecursive(ancestry);
		ancestry.Add(this);
	}

	public FSMStateBase AddEndTransition(FSMStateBase dstState, FSMTransitionBase transition = null)
	{
		if (endTransitions == null)
		{
			endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();
		}
		endTransitions.Add((transition, dstState, EFSMStateStatus.Success | EFSMStateStatus.Failure));
		return this;
	}

	public FSMStateBase AddFailureTransition(FSMStateBase dstState, FSMTransitionBase transition = null)
	{
		if (endTransitions == null)
		{
			endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();
		}
		endTransitions.Add((transition, dstState, EFSMStateStatus.Failure));
		return this;
	}

	public FSMStateBase AddTickTransition(FSMStateBase dstState, FSMTransitionBase transition)
	{
		if (transitions == null)
		{
			transitions = new List<(FSMTransitionBase, FSMStateBase)>();
		}
		transitions.Add((transition, dstState));
		return this;
	}

	public FSMStateBase AddTickBranchingTrans(FSMStateBase dstState1, FSMTransitionBase sharedTransition, FSMStateBase dstState2, FSMTransitionBase dstState2Trans)
	{
		if (transitions == null)
		{
			transitions = new List<(FSMTransitionBase, FSMStateBase)>();
		}
		transitions.Add((new Trans_And { sharedTransition, dstState2Trans }, dstState2));
		transitions.Add((sharedTransition, dstState1));
		return this;
	}

	public FSMStateBase AddChild(FSMStateBase child)
	{
		child.parent = this;
		return child;
	}

	public FSMStateBase AddChildren(FSMStateBase child1, FSMStateBase child2 = null, FSMStateBase child3 = null, FSMStateBase child4 = null, FSMStateBase child5 = null, FSMStateBase child6 = null, FSMStateBase child7 = null, FSMStateBase child8 = null, FSMStateBase child9 = null, FSMStateBase child10 = null)
	{
		AddChild(child1);
		if (child2 != null)
		{
			AddChild(child2);
		}
		if (child3 != null)
		{
			AddChild(child3);
		}
		if (child4 != null)
		{
			AddChild(child4);
		}
		if (child5 != null)
		{
			AddChild(child5);
		}
		if (child6 != null)
		{
			AddChild(child6);
		}
		if (child7 != null)
		{
			AddChild(child7);
		}
		if (child8 != null)
		{
			AddChild(child8);
		}
		if (child9 != null)
		{
			AddChild(child9);
		}
		if (child10 != null)
		{
			AddChild(child10);
		}
		return this;
	}

	public static FSMStateBase operator +(FSMStateBase parent, FSMStateBase child)
	{
		parent.AddChild(child);
		return parent;
	}
}


public interface IParametrized<T>
{
	void SetParameter(T parameter);
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_Nothing : FSMStateBase
{
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_MoveToTarget : FSMStateBase, IParametrized<BaseEntity>
{
	[SerializeField]
	public LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.FullSprint;

	[SerializeField]
	public bool succeedWhenDestinationIsReached = true;

	[SerializeField]
	public bool stopAtDestination = true;

	[SerializeField]
	public float accelerationOverride;

	[SerializeField]
	public float decelerationOverride;

	public void SetParameter(BaseEntity target)
	{
		base.Senses.TrySetTarget(target);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		base.Agent.ResetPath();
		base.Agent.desiredSwimDepth.Reset();
		base.Agent.shouldStopAtDestination = stopAtDestination;
		base.Agent.SetSpeed(speed);
		if (accelerationOverride > 0f)
		{
			base.Agent.acceleration.Value = accelerationOverride;
		}
		if (decelerationOverride > 0f)
		{
			base.Agent.deceleration.Value = decelerationOverride;
		}
		if (!GetMoveDestination(out var destination) || !base.Agent.SetDestination(destination))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Agent.IsFollowingPath && succeedWhenDestinationIsReached)
		{
			return EFSMStateStatus.Success;
		}
		if (!GetMoveDestination(out var destination) || !base.Agent.SetDestination(destination))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	protected virtual bool GetMoveDestination(out Vector3 destination)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			destination = Vector3.zero;
			return false;
		}
		destination = targetPosition;
		return true;
	}
}


using ConVar;
using Rust.Ai.Gen2;
using UnityEngine;

public abstract class State_PlayAnimationBase : FSMStateBase
{
	[SerializeField]
	public bool FaceTarget;

	protected RootMotionPlayer.PlayServerState animState;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (FaceTarget && base.Senses.FindTargetPosition(out var targetPosition))
		{
			Vector3 val = targetPosition - ((Component)Owner).transform.position;
			val.y = 0f;
			if (((Vector3)(ref val)).magnitude > 0.001f)
			{
				((Component)Owner).transform.rotation = Quaternion.LookRotation(val);
			}
		}
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (animState == null)
		{
			if (AI.logIssues)
			{
				Debug.LogError((object)$"[FSM] Animation state is null in state update {base.Name} from {Owner}");
			}
			return EFSMStateStatus.Failure;
		}
		if (!animState.isPlaying)
		{
			return EFSMStateStatus.Success;
		}
		return EFSMStateStatus.None;
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimation : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip Animation;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		return result;
	}

	protected virtual AnimationClip GetAnimation()
	{
		return Animation;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimationRM : State_PlayAnimationBase
{
	[SerializeField]
	public RootMotionData Animation;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(GetAnimation());
		return result;
	}

	protected virtual RootMotionData GetAnimation()
	{
		return Animation;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayRandomAnimation : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip[] animations;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(animations.GetRandom());
		return result;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimLoop : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip Start;

	[SerializeField]
	public AnimationClip Loop;

	[SerializeField]
	public AnimationClip Stop;

	[SerializeField]
	public float MinDuration = 7f;

	[SerializeField]
	public float MaxDuration = 14f;

	private float duration;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		duration = Random.Range(MinDuration, MaxDuration);
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Start);
		return result;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (duration > 0f)
		{
			duration -= deltaTime;
			if (duration <= 0f)
			{
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Stop);
			}
			else if (!animState.isPlaying)
			{
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Loop);
			}
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using System.Linq;
using Rust.Ai.Gen2;
using UnityEngine;

public abstract class FSMTransitionBase
{
	[SerializeField]
	public bool Inverted;

	[NonSerialized]
	public BaseEntity Owner;

	private SenseComponent _senses;

	private LimitedTurnNavAgent _agent;

	protected SenseComponent Senses => _senses ?? (_senses = ((Component)Owner).GetComponent<SenseComponent>());

	protected LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)Owner).GetComponent<LimitedTurnNavAgent>());

	public virtual void Init(BaseEntity owner)
	{
		Owner = owner;
	}

	public virtual void OnStateEnter()
	{
	}

	public virtual void OnStateExit()
	{
	}

	public virtual void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
	}

	public bool Evaluate()
	{
		if (!Inverted)
		{
			return EvaluateInternal();
		}
		return !EvaluateInternal();
	}

	protected virtual bool EvaluateInternal()
	{
		return false;
	}

	public virtual string GetName()
	{
		return (Inverted ? "!" : "") + GetGenericTypeName(GetType());
	}

	protected static string GetGenericTypeName(Type type)
	{
		if (type.IsGenericType)
		{
			string name = type.Name;
			return (name[..name.IndexOf('`')] + "<" + string.Join(", ", type.GetGenericArguments().Select(GetGenericTypeName)) + ">").Replace("Trans_", "");
		}
		return type.Name.Replace("Trans_", "");
	}

	public virtual FSMTransitionBase Clone()
	{
		return (FSMTransitionBase)MemberwiseClone();
	}

	public static Trans_And operator &(FSMTransitionBase lhs, FSMTransitionBase rhs)
	{
		return new Trans_And { lhs, rhs };
	}

	public static Trans_Or operator |(FSMTransitionBase lhs, FSMTransitionBase rhs)
	{
		return new Trans_Or { lhs, rhs };
	}

	public static FSMTransitionBase operator ~(FSMTransitionBase instance)
	{
		instance.Inverted = !instance.Inverted;
		return instance;
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_AlwaysValid : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		return true;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public abstract class Trans_Composite : FSMTransitionBase, IEnumerable<FSMTransitionBase>, IEnumerable
{
	[SerializeField]
	protected List<FSMTransitionBase> transitions = new List<FSMTransitionBase>();

	public IEnumerator<FSMTransitionBase> GetEnumerator()
	{
		return transitions.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public void Add(FSMTransitionBase transition)
	{
		transitions.Add(transition);
	}

	public Trans_Composite()
	{
	}

	public override void Init(BaseEntity owner)
	{
		base.Init(owner);
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.Init(owner);
		}
	}

	public Trans_Composite(List<FSMTransitionBase> transitions)
	{
		this.transitions = transitions;
	}

	public override void OnStateEnter()
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnStateEnter();
		}
	}

	public override void OnStateExit()
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnStateExit();
		}
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnTransitionTaken(from, to);
		}
	}

	protected virtual string GetNameSeparator()
	{
		return " ";
	}

	public override string GetName()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("(");
		for (int i = 0; i < transitions.Count; i++)
		{
			stringBuilder.Append(transitions[i].GetName());
			if (i < transitions.Count - 1)
			{
				stringBuilder.Append(" ");
				stringBuilder.Append(GetNameSeparator());
				stringBuilder.Append(" ");
			}
		}
		stringBuilder.Append(" )");
		return stringBuilder.ToString();
	}

	public override FSMTransitionBase Clone()
	{
		Trans_Composite obj = base.Clone() as Trans_Composite;
		obj.transitions = new List<FSMTransitionBase>();
		return obj;
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_And : Trans_Composite
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_And", 0);
		try
		{
			foreach (FSMTransitionBase transition in transitions)
			{
				if (!transition.Evaluate())
				{
					return false;
				}
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override string GetNameSeparator()
	{
		return "&&";
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_Or : Trans_Composite
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Or", 0);
		try
		{
			foreach (FSMTransitionBase transition in transitions)
			{
				if (transition.Evaluate())
				{
					return true;
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override string GetNameSeparator()
	{
		return "||";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public class Trans_Lambda : FSMTransitionBase
{
	private Func<BaseEntity, bool> EvaluateFunc;

	public Trans_Lambda(Func<BaseEntity, bool> evaluateFunc)
	{
		EvaluateFunc = evaluateFunc;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Lambda", 0);
		try
		{
			if ((Object)(object)Owner == (Object)null)
			{
				return false;
			}
			return EvaluateFunc(Owner);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_RandomChance : FSMTransitionBase
{
	[SerializeField]
	public float Chance = 0.5f;

	private bool Triggered;

	public override void OnStateEnter()
	{
		Triggered = Random.value <= Chance;
	}

	public override void OnStateExit()
	{
		Triggered = false;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_RandomChance", 0);
		try
		{
			return Triggered;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_Cooldown : FSMTransitionBase
{
	[SerializeField]
	public float cooldown = 20f;

	private double? lastTakenTime;

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		base.OnTransitionTaken(from, to);
		lastTakenTime = Time.timeAsDouble;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Cooldown", 0);
		try
		{
			return !lastTakenTime.HasValue || Time.timeAsDouble - lastTakenTime.Value >= (double)cooldown;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {cooldown}s";
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_Triggerable : FSMTransitionBase
{
	protected bool Triggered { get; private set; }

	public void Trigger()
	{
		Triggered = true;
	}

	public override void OnStateEnter()
	{
		Triggered = false;
	}

	public override void OnStateExit()
	{
		Triggered = false;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Triggerable", 0);
		try
		{
			return Triggered;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using Rust.Ai.Gen2;

public class Trans_Triggerable<T> : Trans_Triggerable
{
	private T Parameter;

	public void Trigger(T parameter)
	{
		Parameter = parameter;
		Trigger();
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		if (base.Triggered && to is IParametrized<T> parametrized)
		{
			parametrized.SetParameter(Parameter);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_ElapsedTime : FSMTransitionBase
{
	[SerializeField]
	public double Duration = 6.0;

	private double startTime;

	public override void OnStateEnter()
	{
		startTime = Time.timeAsDouble;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_ElapsedTime", 0);
		try
		{
			return Time.timeAsDouble >= startTime + Duration;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {Duration}s";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_ElapsedTimeRandomized : Trans_ElapsedTime
{
	[SerializeField]
	public double MinDuration = 2.0;

	[SerializeField]
	public double MaxDuration = 6.0;

	public override void OnStateEnter()
	{
		Duration = MinDuration + (double)Random.value * (MaxDuration - MinDuration);
		base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_TargetInRange : FSMTransitionBase
{
	[SerializeField]
	public float Range = 4f;

	[SerializeField]
	public float TimeToPredict;

	protected override bool EvaluateInternal()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TargetInRange", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			Vector3 val2 = ((Component)target).transform.position;
			if (TimeToPredict > 0f && target.ToNonNpcPlayer(out var player))
			{
				Vector3 inferedVelocity = player.inferedVelocity;
				inferedVelocity = Vector3.ProjectOnPlane(inferedVelocity, ((Component)Owner).transform.right);
				val2 += inferedVelocity * TimeToPredict;
			}
			return Vector3.Distance(val2, ((Component)Owner).transform.position) <= Range;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return string.Format("{0} {1}{2}m", base.GetName(), Inverted ? ">=" : "<", Range);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_TargetInFront : FSMTransitionBase
{
	[SerializeField]
	public float Angle = 90f;

	protected override bool EvaluateInternal()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TargetInFront", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			Vector3 val2 = targetPosition - ((Component)Owner).transform.position;
			return Vector3.Angle(((Component)Owner).transform.forward, val2) < Angle;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return string.Format("{0} {1}{2}", base.GetName(), Inverted ? ">=" : "<", Angle);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_TargetIsNearFire : FSMTransitionBase
{
	public bool onlySeeFireWhenClose;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetIsNearFire", 0);
		try
		{
			return Test(Owner, base.Senses, onlySeeFireWhenClose);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool Test(BaseEntity owner, SenseComponent senses, bool onlySeeFireWhenClose = false)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Test", 0);
		try
		{
			if (!senses.FindTarget(out var target))
			{
				return false;
			}
			if (target.ToNonNpcPlayer(out var player) && SingletonComponent<NpcNoiseManager>.Instance.HasPlayerSpokenNear(owner, player))
			{
				return true;
			}
			if (!senses.FindFire(out var fire))
			{
				return false;
			}
			bool flag = Vector3.Distance(((Component)target).transform.position, ((Component)fire).transform.position) < 16f;
			bool flag2 = Vector3.Distance(((Component)owner).transform.position, ((Component)target).transform.position) < 18f;
			if (onlySeeFireWhenClose)
			{
				return flag && flag2;
			}
			return flag;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_HasTarget : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasTarget", 0);
		try
		{
			BaseEntity target;
			return base.Senses.FindTarget(out target);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public abstract class FSMSlowTransitionBase : FSMTransitionBase
{
	private bool cachedEvalResult;

	private double? lastEvalTime;

	private double cacheLifeTime = 1.0;

	protected sealed override bool EvaluateInternal()
	{
		double timeAsDouble = Time.timeAsDouble;
		if (!lastEvalTime.HasValue || timeAsDouble - lastEvalTime.Value > cacheLifeTime)
		{
			cachedEvalResult = EvaluateAtInterval();
			lastEvalTime = timeAsDouble;
		}
		return cachedEvalResult;
	}

	protected abstract bool EvaluateAtInterval();
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_CanReachTarget_Slow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_CanReachTarget_Slow", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			return base.Agent.CanReach(targetPosition);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsTargetOnNavmesh_Slow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsTargetOnNavmesh_Slow", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			Vector3 sample;
			return base.Agent.SamplePosition(targetPosition, out sample, 2f);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_IsHealthBelowPercentage : FSMTransitionBase
{
	[SerializeField]
	public float percentage = 0.25f;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsHealthBelowPercentage", 0);
		try
		{
			return Owner is BaseCombatEntity baseCombatEntity && baseCombatEntity.healthFraction < percentage;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} <{percentage * 100f}%";
	}
}


using System;
using ConVar;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_IsNavmeshReady : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsNavmeshReady", 0);
		try
		{
			return AI.move && base.Agent.IsNavmeshReady;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_InitialAlliesNotFighting : FSMTransitionBase
{
	[SerializeField]
	public float MinAllyHealthFraction = 0.3f;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_InitialAlliesNotFighting", 0);
		try
		{
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				base.Senses.GetInitialAllies((List<BaseEntity>)(object)val2);
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (!((Component)item).GetComponent<SenseComponent>().FindTarget(out var _) && (!(item is BaseCombatEntity baseCombatEntity) || !(baseCombatEntity.healthFraction < MinAllyHealthFraction)))
					{
						return true;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_HasBlackboardBool : FSMTransitionBase
{
	[SerializeField]
	public string Key;

	private BlackboardComponent _blackboard;

	private BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasBlackboardBool", 0);
		try
		{
			return Blackboard.Has(Key);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return base.GetName() + " " + Key;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_BlackboardCounterGte : FSMTransitionBase
{
	[SerializeField]
	public string Key;

	[SerializeField]
	public int MinValue;

	private BlackboardComponent _blackboard;

	private BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasBlackboardBool", 0);
		try
		{
			if (!Blackboard.Count(Key, out var count))
			{
				return false;
			}
			return count >= MinValue;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {Key} >= {MinValue}";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_HeardNoise : FSMTransitionBase
{
	private NpcNoiseEvent? noise;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HeardNoise", 0);
		try
		{
			noise = null;
			if (base.Senses.FindMostRelevantNoise(out var mostRelevantNoise))
			{
				noise = mostRelevantNoise;
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		base.OnTransitionTaken(from, to);
		if (noise.HasValue && to is IParametrized<Vector3> parametrized)
		{
			base.Senses.TrySetTarget(noise.Value.Initiator);
			parametrized.SetParameter(noise.Value.GuessedInitiatorPosition);
			base.Senses.ForgetAllNoises();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_SeesFood : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_SeesFood", 0);
		try
		{
			BaseEntity food;
			return base.Senses.FindFood(out food);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_IsTargetInWater : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsTargetInWater", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			if (!target.ToNonNpcPlayer(out var _))
			{
				return false;
			}
			if (!base.Senses.GetVisibilityStatus(target, out var status))
			{
				return false;
			}
			return status.isInWaterCached;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_IsSwimming : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsSwimming", 0);
		try
		{
			return base.Agent.canSwim && base.Agent.IsSwimming;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_IsInWater_Slow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsInWater_Slow", 0);
		try
		{
			if (base.Agent.canSwim)
			{
				return base.Agent.IsSwimming;
			}
			return WaterLevel.GetWaterDepth(((Component)Owner).transform.position, waves: false, volumes: false) >= 0.3f;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_TargetIsInSafeZone : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetIsInSafeZone", 0);
		try
		{
			BaseEntity target;
			return base.Senses.FindTarget(out target) && target.InSafeZone();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

public class NpcBarkManager : SingletonComponent<NpcBarkManager>, IServerComponent
{
	public NPCVoicelinesDatabase voicelinesDatabase;

	private const float minTimeBetweenStarterVoicelines = 5f;

	private const float minTimeBetweenExactSameVoiceline = 300f;

	private const float minTimeBetweenStartersOfSameCategory = 60f;

	private SparseGrid<(int, double)> voicelineHistory = new SparseGrid<(int, double)>();

	public bool CanPlay(BaseEntity source, NPCVoiceline voiceline)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcBarkManager.CanPlay", 0);
		try
		{
			if ((Object)(object)source == (Object)null || voiceline.category == ENPCVoicelineCategory.None)
			{
				if (AI.logIssues)
				{
					Debug.LogError((object)$"NpcBarkManager: CanPlay called with null source or invalid voiceline. index: {voiceline.index}");
				}
				return false;
			}
			double timeAsDouble = Time.timeAsDouble;
			PooledList<(int, double)> val2 = Pool.Get<PooledList<(int, double)>>();
			try
			{
				voicelineHistory.GetNeighboors(((Component)source).transform.position, (List<(int, double)>)(object)val2);
				foreach (var (num, num2) in (List<(int, double)>)(object)val2)
				{
					if (!voicelinesDatabase.FindVoiceline(num, out var voiceline2))
					{
						if (AI.logIssues)
						{
							Debug.LogError((object)$"NpcBarkManager: CanPlay - voiceline {num} present in history not found in db.");
						}
						continue;
					}
					float num3 = (float)(timeAsDouble - num2);
					if (voiceline.importance != ENpcVoicelineImportance.Conversation && num3 < 5f)
					{
						return false;
					}
					if (voiceline2.category == voiceline.category && voiceline.importance == ENpcVoicelineImportance.Flavour && num3 < 60f)
					{
						return false;
					}
					if (voiceline2.index != voiceline.index || !(num3 < 300f))
					{
						continue;
					}
					return false;
				}
				return true;
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnPlay(BaseEntity source, NPCVoiceline voiceline)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcBarkManager.OnPlay", 0);
		try
		{
			double timeAsDouble = Time.timeAsDouble;
			voicelineHistory.Add(((Component)source).transform.position, (voiceline.index, timeAsDouble));
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using Spatial;
using UnityEngine;
using UnityEngine.AI;

public class NpcCoverManager : SingletonComponent<NpcCoverManager>, IServerComponent
{
	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private Grid<CoverComponent> coverGrid = new Grid<CoverComponent>(32, 8096f);

	private Dictionary<Cover, BaseEntity> coverToEntity = new Dictionary<Cover, BaseEntity>();

	private Dictionary<BaseEntity, Cover> entityToCover = new Dictionary<BaseEntity, Cover>();

	public void Add(CoverComponent cover)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		coverGrid.Add(cover, ((Component)cover).transform.position.x, ((Component)cover).transform.position.z);
	}

	public void Remove(CoverComponent cover)
	{
		coverGrid.Remove(cover);
	}

	public void GetCoversAround(BaseEntity entity, Vector3 origin, Vector3 threatPosition, float range, List<Cover> covers)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcCoverManager.GetCoverAround", 0);
		try
		{
			if (coverGrid == null)
			{
				return;
			}
			PooledList<CoverComponent> val2 = Pool.Get<PooledList<CoverComponent>>();
			try
			{
				coverGrid.Query(origin.x, origin.z, range, (List<CoverComponent>)(object)val2);
				foreach (CoverComponent item in (List<CoverComponent>)(object)val2)
				{
					item.GetCovers(covers, threatPosition);
				}
				PooledList<BaseEntity> val3 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					BaseEntity.Query.Server.GetInSphere(origin, range, (List<BaseEntity>)(object)val3);
					foreach (BaseEntity item2 in (List<BaseEntity>)(object)val3)
					{
						if (!(item2 is TreeEntity) && !(item2 is OreResourceEntity) && !(item2 is LootContainer))
						{
							continue;
						}
						Bounds bounds = ((Component)item2).GetComponentInChildren<Collider>().bounds;
						float num = Mathf.Max(((Bounds)(ref bounds)).extents.x, ((Bounds)(ref bounds)).extents.z);
						if (!(num > 1.5f) && !(num < 0.5f))
						{
							using PillarCoverGroup pillarCoverGroup = Pool.Get<PillarCoverGroup>();
							pillarCoverGroup.GenerateCovers(((Component)item2).gameObject);
							pillarCoverGroup.GetCovers(((Component)item2).transform, covers, threatPosition);
						}
					}
					for (int num2 = covers.Count - 1; num2 >= 0; num2--)
					{
						if (coverToEntity.TryGetValue(covers[num2], out var value) && (Object)(object)value != (Object)(object)entity)
						{
							covers.RemoveAt(num2);
						}
						else if (Vector3.Distance(covers[num2].position, origin) > range)
						{
							covers.RemoveAt(num2);
						}
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Cover? FindBestCover(LimitedTurnNavAgent agent, Vector3 threatPosition, float radius, float preferedEngagementDistance, ref NavMeshPath path, bool requireLoS, float? targetRadius = null)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FindBestCover", 0);
		try
		{
			PooledList<Cover> val2 = Pool.Get<PooledList<Cover>>();
			try
			{
				BaseEntity baseEntity = agent.GetBaseEntity();
				GetCoversAround(baseEntity, ((Component)agent).transform.position, threatPosition, radius, (List<Cover>)(object)val2);
				PooledList<(Cover, float)> val3 = Pool.Get<PooledList<(Cover, float)>>();
				try
				{
					foreach (Cover item2 in (List<Cover>)(object)val2)
					{
						if (item2.ProtectsFrom(threatPosition))
						{
							float num = 0f - Mathf.Abs(Vector3.Distance(item2.position, threatPosition) - preferedEngagementDistance);
							float item = (0f - Vector3.Distance(((Component)agent).transform.position, item2.position)) * 4f + num;
							((List<(Cover, float)>)(object)val3).Add((item2, item));
						}
					}
					((List<(Cover, float)>)(object)val3).Sort((Comparison<(Cover, float)>)(((Cover cover, float score) a, (Cover cover, float score) b) => b.score.CompareTo(a.score)));
					((List<Cover>)(object)val2).Clear();
					foreach (var item3 in (List<(Cover, float)>)(object)val3)
					{
						((List<Cover>)(object)val2).Add(item3.Item1);
					}
					return GetFirstUsableCover(agent, threatPosition, (List<Cover>)(object)val2, radius * 4f, ref path, requireLoS, targetRadius);
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static Cover? GetFirstUsableCover(LimitedTurnNavAgent agent, Vector3 threatPosition, List<Cover> covers, float maxPathLength, ref NavMeshPath navPath, bool requireLoS, float? targetRadius)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetFirstUsableCover", 0);
		try
		{
			BaseEntity baseEntity = agent.GetBaseEntity();
			foreach (Cover cover in covers)
			{
				if ((!requireLoS || cover.GetFirstUnoccludedPeek(threatPosition, baseEntity) != 0) && agent.CalculatePathCustom(cover.position, navPath) && (int)navPath.status == 0 && !(navPath.GetPathLength() > maxPathLength) && (!targetRadius.HasValue || !DoesPathIntersectTarget(navPath, threatPosition, targetRadius.Value)))
				{
					return cover;
				}
			}
			return null;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static bool DoesPathIntersectTarget(NavMeshPath path, Vector3 targetPosition, float targetRadius)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < path.corners.Length - 1; i++)
		{
			Vector3 start = path.corners[i];
			Vector3 end = path.corners[i + 1];
			if (SegmentSphereIntersection(start, end, targetPosition, targetRadius))
			{
				return true;
			}
		}
		return false;
	}

	private static bool SegmentSphereIntersection(Vector3 start, Vector3 end, Vector3 center, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = end - start;
		Vector3 val2 = start - center;
		if (((Vector3)(ref val)).sqrMagnitude == 0f)
		{
			return false;
		}
		float num = Vector3.Dot(val, val);
		float num2 = 2f * Vector3.Dot(val2, val);
		float num3 = Vector3.Dot(val2, val2) - radius * radius;
		float num4 = num2 * num2 - 4f * num * num3;
		if (Mathf.Abs(num4) < Mathf.Epsilon)
		{
			num4 = 0f;
		}
		if (num4 < 0f)
		{
			return false;
		}
		num4 = Mathf.Sqrt(num4);
		float num5 = (0f - num2 - num4) / (2f * num);
		float num6 = (0f - num2 + num4) / (2f * num);
		if (((Vector3)(ref val2)).sqrMagnitude <= radius * radius)
		{
			Vector3 val3 = end - center;
			return ((Vector3)(ref val3)).sqrMagnitude <= radius * radius;
		}
		if (!(num5 >= 0f) || !(num5 <= 1f))
		{
			if (num6 >= 0f)
			{
				return num6 <= 1f;
			}
			return false;
		}
		return true;
	}

	public void Reserve(Cover cover, BaseEntity entity)
	{
		if (TryGetCover(entity, out var cover2))
		{
			Release(cover2);
		}
		coverToEntity[cover] = entity;
		entityToCover[entity] = cover;
	}

	public void Release(Cover cover)
	{
		entityToCover.Remove(coverToEntity[cover]);
		coverToEntity.Remove(cover);
	}

	public bool TryGetCover(BaseEntity entity, out Cover cover)
	{
		if (entityToCover.TryGetValue(entity, out cover))
		{
			return true;
		}
		return false;
	}

	public void Tick()
	{
		TimeWarning val = TimeWarning.New("NpcCoverManager.Tick", 0);
		try
		{
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				foreach (KeyValuePair<BaseEntity, Cover> item in entityToCover)
				{
					BaseEntity key = item.Key;
					if (!key.IsValid() || (key is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead()))
					{
						((List<BaseEntity>)(object)val2).Add(item.Key);
					}
				}
				foreach (BaseEntity item2 in (List<BaseEntity>)(object)val2)
				{
					Release(entityToCover[item2]);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public enum NpcNoiseIntensity
{
	None,
	Low,
	Medium,
	High
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public readonly struct NpcNoiseEvent : IEquatable<NpcNoiseEvent>
{
	public readonly int Id;

	public readonly BaseEntity Initiator;

	public readonly Vector3 NoisePosition;

	public readonly Vector3 GuessedInitiatorPosition;

	public readonly NpcNoiseIntensity Intensity;

	public readonly double EventTime;

	public NpcNoiseEvent(int id, BaseEntity initiator, Vector3 position, Vector3 initiatorPosition, NpcNoiseIntensity intensity, double eventTime)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Id = id;
		Initiator = initiator;
		NoisePosition = position;
		GuessedInitiatorPosition = initiatorPosition;
		Intensity = intensity;
		EventTime = eventTime;
	}

	public bool Equals(NpcNoiseEvent other)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (Id == other.Id)
		{
			double eventTime = EventTime;
			if (eventTime.Equals(other.EventTime) && (Object)(object)Initiator == (Object)(object)other.Initiator && Intensity == other.Intensity)
			{
				Vector3 val = NoisePosition;
				if (((Vector3)(ref val)).Equals(other.NoisePosition))
				{
					val = GuessedInitiatorPosition;
					return ((Vector3)(ref val)).Equals(other.GuessedInitiatorPosition);
				}
			}
		}
		return false;
	}

	public override int GetHashCode()
	{
		return Id;
	}

	public override bool Equals(object obj)
	{
		if (obj is NpcNoiseEvent other)
		{
			return Equals(other);
		}
		return false;
	}

	public static bool operator ==(NpcNoiseEvent left, NpcNoiseEvent right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(NpcNoiseEvent left, NpcNoiseEvent right)
	{
		return !left.Equals(right);
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using Spatial;
using UnityEngine;

public class NpcNoiseManager : SingletonComponent<NpcNoiseManager>, IServerComponent
{
	private const float voiceChatEventMaxAge = 1f;

	private const float noiseMaxAge = 10f;

	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private ConcurrentDictionary<BasePlayer, double> recentVoiceChatEvents = new ConcurrentDictionary<BasePlayer, double>();

	private Grid<NpcNoiseEvent> noiseGrid = new Grid<NpcNoiseEvent>(32, 8096f);

	private Queue<NpcNoiseEvent> noises = new Queue<NpcNoiseEvent>();

	private double nextTickTime;

	private int nextNoiseId = 1;

	public void AddNoise(BaseEntity initiator, Vector3 position, NpcNoiseIntensity intensity, bool guessInitiatorPosition = false)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		if (!((FacepunchBehaviour)this).IsInvoking((Action)RemoveOldNoises))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)RemoveOldNoises, 0f, 0f);
		}
		NpcNoiseEvent npcNoiseEvent = new NpcNoiseEvent(nextNoiseId++, initiator, position, guessInitiatorPosition ? ((Component)initiator).transform.position : position, intensity, Time.timeAsDouble);
		noiseGrid.Add(npcNoiseEvent, npcNoiseEvent.NoisePosition.x, npcNoiseEvent.NoisePosition.z);
		noises.Enqueue(npcNoiseEvent);
	}

	private void RemoveOldNoises()
	{
		TimeWarning val = TimeWarning.New("RemoveOldNoises", 0);
		try
		{
			while (noises.Count > 0)
			{
				NpcNoiseEvent npcNoiseEvent = noises.Peek();
				if (Time.timeAsDouble - npcNoiseEvent.EventTime <= 10.0)
				{
					break;
				}
				noises.Dequeue();
				noiseGrid.Remove(npcNoiseEvent);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetNoisesAround(Vector3 position, float range, List<NpcNoiseEvent> results)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (noiseGrid != null)
		{
			noiseGrid.Query(position.x, position.z, range, results);
		}
	}

	public void OnServerProjectileHit(BaseEntity entity, ServerProjectile projectile, RaycastHit hit)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		AddNoise(entity, ((Component)projectile).transform.position, NpcNoiseIntensity.High);
	}

	public void OnProjectileHit(BaseEntity entity, HitInfo hit)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcNoiseManager.OnProjectileHit", 0);
		try
		{
			if (((Object)(object)hit.Weapon).Is<BaseProjectile>(out BaseProjectile _) || ((Object)(object)hit.Weapon).Is<BaseMelee>(out BaseMelee _))
			{
				if (((Object)(object)hit.Weapon).Is<BaseProjectile>(out BaseProjectile castedUnityObject3) && !((Object)(object)hit.Weapon).Is<BowWeapon>(out BowWeapon _))
				{
					AddNoise(entity, hit.HitPositionWorld, castedUnityObject3.IsSilenced() ? NpcNoiseIntensity.Medium : NpcNoiseIntensity.High, guessInitiatorPosition: true);
				}
				else
				{
					AddNoise(entity, hit.HitPositionWorld, NpcNoiseIntensity.Low);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnWeaponShot(BasePlayer player, BaseProjectile weapon)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcNoiseManager.OnWeaponShot", 0);
		try
		{
			NpcNoiseIntensity intensity = NpcNoiseIntensity.High;
			if (((Object)(object)weapon).Is<BowWeapon>(out BowWeapon _))
			{
				intensity = NpcNoiseIntensity.Low;
			}
			else if ((Object)(object)weapon != (Object)null && weapon.IsSilenced())
			{
				intensity = NpcNoiseIntensity.Medium;
			}
			AddNoise(player, ((Component)player).transform.position, intensity);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnNpcWeaponShot(BaseEntity npc, BaseEntity target, Vector3 impactLocation)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcNoiseManager.OnNpcWeaponShot", 0);
		try
		{
			AddNoise(target, impactLocation, NpcNoiseIntensity.High, guessInitiatorPosition: true);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnWeaponThrown(BasePlayer player, BaseMelee weapon, bool canAiHearIt)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (canAiHearIt)
		{
			AddNoise(player, ((Component)player).transform.position, NpcNoiseIntensity.Low);
		}
	}

	public void OnExplosion(BaseEntity creatorEntity, TimedExplosive explosive)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (creatorEntity.IsValid())
		{
			AddNoise(creatorEntity, ((Component)explosive).transform.position, NpcNoiseIntensity.High, guessInitiatorPosition: true);
		}
	}

	public void OnVoiceChat(BasePlayer player)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		recentVoiceChatEvents[player] = Time.timeAsDouble;
		AddNoise(player, ((Component)player).transform.position, NpcNoiseIntensity.Low);
	}

	public void OnMeleeHit(BaseMelee weapon, HitInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = weapon.GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			AddNoise(ownerPlayer, ((Component)ownerPlayer).transform.position, NpcNoiseIntensity.Low);
		}
	}

	public bool HasPlayerSpokenNear(BaseEntity querier, BasePlayer targetPlayer, float maxDistance = 16f)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcNoiseManager.HasPlayerSpokenNear", 0);
		try
		{
			double value;
			return recentVoiceChatEvents.TryGetValue(targetPlayer, out value) && Vector3.Distance(((Component)querier).transform.position, ((Component)targetPlayer).transform.position) <= maxDistance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Tick()
	{
		if (Time.timeAsDouble < nextTickTime)
		{
			return;
		}
		nextTickTime = Time.timeAsDouble + (double)Random.Range(4f, 6f);
		TimeWarning val = TimeWarning.New("NpcNoiseManager.RemoveStaleEntries", 0);
		try
		{
			PooledList<BasePlayer> val2 = Pool.Get<PooledList<BasePlayer>>();
			try
			{
				double value;
				foreach (KeyValuePair<BasePlayer, double> recentVoiceChatEvent in recentVoiceChatEvents)
				{
					recentVoiceChatEvent.Deconstruct(out var key, out value);
					BasePlayer basePlayer = key;
					double num = value;
					if (!basePlayer.IsValid() || Time.timeAsDouble - num > 1.0)
					{
						((List<BasePlayer>)(object)val2).Add(basePlayer);
					}
				}
				foreach (BasePlayer item in (List<BasePlayer>)(object)val2)
				{
					recentVoiceChatEvents.Remove(item, out value);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

public class NpcZone : MonoBehaviour, IServerComponent
{
	private static List<NpcZone> zones = new List<NpcZone>();

	public Bounds bounds = new Bounds(Vector3.zero, new Vector3(10f, 3.5f, 10f));

	public bool drawBounds = true;

	private void Awake()
	{
		zones.Add(this);
	}

	private void OnDestroy()
	{
		zones.Remove(this);
	}

	public bool IsPointInside(BaseEntity querier, Vector3 point)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcZone.IsPointInside", 0);
		try
		{
			OBB val2 = new OBB(((Component)this).transform.position, ((Component)this).transform.lossyScale, ((Component)this).transform.rotation, bounds);
			return ((OBB)(ref val2)).Contains(point);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static NpcZone GetForPoint(BaseEntity querier, Vector3 point, bool fallBackToNearest = false)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NpcZone.GetForPoint", 0);
		try
		{
			if (zones == null || zones.Count == 0)
			{
				return null;
			}
			foreach (NpcZone zone in zones)
			{
				if (!((Object)(object)zone == (Object)null) && zone.IsPointInside(querier, point))
				{
					return zone;
				}
			}
			if (!fallBackToNearest)
			{
				return null;
			}
			float num = float.PositiveInfinity;
			NpcZone result = zones[0];
			foreach (NpcZone zone2 in zones)
			{
				if (!((Object)(object)zone2 == (Object)null) && !((Object)(object)((Component)zone2).transform == (Object)null))
				{
					float num2 = Vector3.Distance(((Component)zone2).transform.position, point);
					if (num2 < num)
					{
						num = num2;
						result = zone2;
					}
				}
			}
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


