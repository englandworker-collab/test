using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using ProtoBuf;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Events;

[SoftRequireComponent(typeof(NavMeshAgent))]
public class LimitedTurnNavAgent : EntityComponent<BaseEntity>
{
	public enum Speeds
	{
		Sneak,
		Walk,
		Jog,
		Run,
		Sprint,
		FullSprint
	}

	public enum SteeringMode
	{
		FaceTarget,
		LimitedTurnRate
	}

	[SerializeField]
	private NavMeshAgent agent;

	[SerializeField]
	private SteeringMode steeringMode = SteeringMode.LimitedTurnRate;

	[SerializeField]
	[Header("Speed")]
	private float sneakSpeed = 0.6f;

	[SerializeField]
	private float walkSpeed = 0.89f;

	[SerializeField]
	private float jogSpeed = 2.45f;

	[SerializeField]
	private float runSpeed = 4.4f;

	[SerializeField]
	private float sprintSpeed = 6f;

	[SerializeField]
	private float fullSprintSpeed = 9f;

	[SerializeField]
	public bool canSwim;

	[SerializeField]
	private float swimSpeed = 0.6f;

	[SerializeField]
	private float swimSprintSpeed = 0.89f;

	public ResettableFloat desiredSwimDepth = new ResettableFloat(0.7f);

	public ResettableFloat acceleration = new ResettableFloat(10f);

	public ResettableFloat deceleration = new ResettableFloat(2f);

	[SerializeField]
	private float maxTurnRadius = 2f;

	[SerializeField]
	private bool canOpenDoors;

	[SerializeField]
	private Enum preferedTopology = (Enum)537002081;

	[SerializeField]
	private Enum preferedBiome = (Enum)15;

	public const BaseEntity.Flags FLAG_IS_SWIMMING = BaseEntity.Flags.Reserved1;

	public const BaseEntity.Flags FLAG_IS_JUMPING = BaseEntity.Flags.Reserved2;

	private const float emergencyDeceleration = 10f;

	private static NavMeshPath path;

	[NonSerialized]
	public UnityEvent onPathFailed = new UnityEvent();

	private LockState movementLock = new LockState();

	private bool isNavMeshReady;

	private int? lastFrameCall;

	[NonSerialized]
	public float currentDeviation;

	[NonSerialized]
	public bool shouldStopAtDestination = true;

	[NonSerialized]
	public float? overrideAngularSpeed;

	private float cachedPathLength;

	private Vector3? previousLocalPosition;

	private float curSpeed;

	private float desiredSpeed;

	private static ListHashSet<LimitedTurnNavAgent> steeringComponents = new ListHashSet<LimitedTurnNavAgent>();

	private Vector3? _overrideDirection;

	public bool IsSwimming
	{
		get
		{
			return base.baseEntity.flags.HasFlag(BaseEntity.Flags.Reserved1);
		}
		private set
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Reserved1, value);
		}
	}

	public bool IsJumping
	{
		get
		{
			return base.baseEntity.flags.HasFlag(BaseEntity.Flags.Reserved2);
		}
		set
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Reserved2, value);
		}
	}

	public Vector3 NavPosition => agent.nextPosition;

	public bool IsSprinting => curSpeed >= sprintSpeed;

	public bool isPaused => movementLock.IsLocked;

	public bool IsNavmeshReady => isNavMeshReady;

	public Vector3? lastValidDestination
	{
		get
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			if (lastValidPath.Count <= 0)
			{
				return null;
			}
			List<Vector3> list = lastValidPath;
			return list[list.Count - 1];
		}
	}

	public List<Vector3> lastValidPath { get; private set; } = new List<Vector3>();

	private float AngularSpeed
	{
		get
		{
			if (!overrideAngularSpeed.HasValue)
			{
				return agent.angularSpeed;
			}
			return overrideAngularSpeed.Value;
		}
	}

	public float RemainingDistance => agent.remainingDistance;

	public bool IsFollowingPath
	{
		get
		{
			if (agent.hasPath)
			{
				return agent.remainingDistance > (shouldStopAtDestination ? 0.05f : maxTurnRadius);
			}
			return false;
		}
	}

	public Vector3? overrideDirection
	{
		get
		{
			return _overrideDirection;
		}
		set
		{
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			Vector3? val = value;
			Vector3? val2 = _overrideDirection;
			if (val.HasValue != val2.HasValue || (val.HasValue && !(val.GetValueOrDefault() == val2.GetValueOrDefault())))
			{
				_overrideDirection = value;
				if (base.baseEntity.isServer)
				{
					base.baseEntity.SendNetworkUpdate();
				}
			}
		}
	}

	public LockState.LockHandle Pause()
	{
		if (!movementLock.IsLocked)
		{
			OnPaused();
		}
		return movementLock.AddLock();
	}

	public bool Unpause(ref LockState.LockHandle handle)
	{
		bool result = movementLock.RemoveLock(ref handle);
		if (!movementLock.IsLocked)
		{
			OnUnpaused();
		}
		return result;
	}

	public void Move(Vector3 offset)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:Move", 0);
		try
		{
			agent.Move(offset);
			lastFrameCall = Time.frameCount;
			if (canSwim)
			{
				Vector3 nextPosition = agent.nextPosition;
				WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(nextPosition, waves: false, volumes: false);
				IsSwimming = waterInfo.currentDepth > desiredSwimDepth.Value;
				if (IsSwimming)
				{
					nextPosition.y = ((Component)base.baseEntity).transform.position.y;
					nextPosition.y = Mathf.MoveTowards(nextPosition.y, waterInfo.surfaceLevel - desiredSwimDepth.Value, 1f * Time.deltaTime);
					nextPosition.y = Mathf.Max(nextPosition.y, waterInfo.terrainHeight);
					base.baseEntity.ServerNavMeshPos = nextPosition;
				}
				else
				{
					base.baseEntity.ServerNavMeshPos = agent.nextPosition;
				}
			}
			else
			{
				IsSwimming = false;
				base.baseEntity.ServerNavMeshPos = agent.nextPosition;
			}
			if (!canOpenDoors)
			{
				return;
			}
			PooledList<NPCDoorTriggerBox> val2 = Pool.Get<PooledList<NPCDoorTriggerBox>>();
			try
			{
				NPCDoorTriggerBox.AllDoors.GetNeighboors(((Component)base.baseEntity).transform.position, (List<NPCDoorTriggerBox>)(object)val2);
				foreach (NPCDoorTriggerBox item in (List<NPCDoorTriggerBox>)(object)val2)
				{
					item.TryOpenDoorFor(base.baseEntity);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ResetPath()
	{
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:ResetPath", 0);
		try
		{
			shouldStopAtDestination = true;
			acceleration.Reset();
			deceleration.Reset();
			currentDeviation = 0f;
			SetSpeed(0f);
			if (agent.hasPath)
			{
				agent.ResetPath();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool CanReach(Vector3 location, bool updateLastValidPath = false)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Invalid comparison between Unknown and I4
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:CanReach", 0);
		try
		{
			if (!IsPositionOnNavmesh(location, out var sample))
			{
				DebugShowFailedPath(location);
				return false;
			}
			if (!CalculatePathCustom(sample, path))
			{
				return false;
			}
			bool num = (int)path.status == 0;
			if (!num)
			{
				DebugShowFailedPath(sample, path);
			}
			else if (updateLastValidPath)
			{
				path.GetCornersNonAllocAsList(lastValidPath);
			}
			return num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool SetDestination(Vector3 newDestination, bool allowPartialPaths = false)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:SetDestination", 0);
		try
		{
			if (shouldStopAtDestination && agent.hasPath && Vector3.Distance(agent.destination, newDestination) < 1f)
			{
				return true;
			}
			if (!CalculatePathCustom(newDestination, path))
			{
				return false;
			}
			if (!allowPartialPaths && (int)path.status != 0)
			{
				return false;
			}
			SetPath(path);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void InitShared()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Expected O, but got Unknown
		base.InitShared();
		if (path == null)
		{
			path = new NavMeshPath();
		}
	}

	private void OnPaused()
	{
		if (((Behaviour)agent).enabled && agent.isOnNavMesh)
		{
			ResetPath();
		}
	}

	private void OnUnpaused()
	{
	}

	public bool SetPath(NavMeshPath newPath)
	{
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:SetPath", 0);
		try
		{
			if (agent.path == newPath)
			{
				return true;
			}
			if (!agent.SetPath(newPath))
			{
				return false;
			}
			cachedPathLength = newPath.GetPathLength();
			newPath.GetCornersNonAllocAsList(lastValidPath);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void DebugShowFailedPath(Vector3? destination, NavMeshPath failedPath = null)
	{
	}

	private float GetSpeedForGait(Speeds gait)
	{
		return gait switch
		{
			Speeds.Sneak => sneakSpeed, 
			Speeds.Walk => walkSpeed, 
			Speeds.Jog => jogSpeed, 
			Speeds.Run => runSpeed, 
			Speeds.Sprint => sprintSpeed, 
			Speeds.FullSprint => fullSprintSpeed, 
			_ => walkSpeed, 
		};
	}

	public void SetSpeed(Speeds gait)
	{
		SetSpeed(GetSpeedForGait(gait));
	}

	public bool IsSpeedGTE(Speeds minGait)
	{
		return curSpeed >= GetSpeedForGait(minGait) - 0.01f;
	}

	public void SetSpeed(float speed)
	{
		desiredSpeed = speed;
	}

	public void SetSpeedRatio(float ratio, Speeds minSpeed = Speeds.Sneak, Speeds maxSpeed = Speeds.Sprint, int offset = 0)
	{
		int num = Mathf.FloorToInt(Mathf.Lerp((float)minSpeed, (float)maxSpeed, ratio));
		num = Mathf.Clamp(num + offset, (int)minSpeed, (int)maxSpeed);
		SetSpeed((Speeds)num);
	}

	private void OnEnable()
	{
		steeringComponents.TryAdd(this);
	}

	private void OnDisable()
	{
		steeringComponents.Remove(this);
	}

	public static void TickSteering()
	{
		for (int num = steeringComponents.Count - 1; num >= 0; num--)
		{
			LimitedTurnNavAgent limitedTurnNavAgent = steeringComponents[num];
			if (limitedTurnNavAgent.IsUnityNull() || !limitedTurnNavAgent.baseEntity.IsValid())
			{
				steeringComponents.RemoveAt(num);
			}
			else
			{
				limitedTurnNavAgent.Tick();
			}
		}
	}

	private void Tick()
	{
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_032a: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:Tick", 0);
		try
		{
			try
			{
				if (!AI.move)
				{
					return;
				}
				if (!isNavMeshReady)
				{
					isNavMeshReady = (Object)(object)agent != (Object)null && ((Behaviour)agent).enabled;
					if (isNavMeshReady && !agent.isOnNavMesh)
					{
						if (base.baseEntity.ServerNavMeshPos != base.baseEntity.ServerWorldPosition)
						{
							Vector3 serverWorldPosition = base.baseEntity.ServerWorldPosition;
							isNavMeshReady = agent.Warp(base.baseEntity.ServerNavMeshPos);
							base.baseEntity.ServerWorldPosition = serverWorldPosition;
						}
						else
						{
							isNavMeshReady = false;
						}
					}
					if (!isNavMeshReady)
					{
						return;
					}
					agent.updateRotation = false;
					agent.updatePosition = false;
					agent.updateUpAxis = false;
					agent.isStopped = true;
				}
				if (movementLock.IsLocked)
				{
					if (previousLocalPosition.HasValue)
					{
						Vector3 val2 = ((Component)base.baseEntity).transform.localPosition - previousLocalPosition.Value;
						curSpeed = ((Vector3)(ref val2)).magnitude / Time.deltaTime;
					}
				}
				else if (IsSwimming && curSpeed > swimSprintSpeed)
				{
					if (AI.logIssues)
					{
						Debug.LogError((object)$"Speed is too high: {curSpeed}/{swimSprintSpeed}");
					}
					curSpeed = swimSpeed;
				}
				else if (!IsSwimming && curSpeed > fullSprintSpeed)
				{
					if (AI.logIssues)
					{
						Debug.LogError((object)$"Speed is too high: {curSpeed}/{fullSprintSpeed}");
					}
					curSpeed = fullSprintSpeed;
				}
				if (!movementLock.IsLocked)
				{
					if (steeringMode == SteeringMode.LimitedTurnRate && (!shouldStopAtDestination || IsFollowingPath))
					{
						SteerTowardsWaypoint();
					}
					else if (steeringMode == SteeringMode.FaceTarget && IsFollowingPath)
					{
						curSpeed = desiredSpeed;
						agent.isStopped = true;
						Vector3 val3 = agent.steeringTarget - agent.nextPosition;
						Vector3 normalized = ((Vector3)(ref val3)).normalized;
						Vector3 val4 = normalized * (curSpeed * Time.deltaTime);
						val4 = Vector3.ClampMagnitude(val4, ((Vector3)(ref val3)).magnitude);
						Move(val4);
						if (!overrideDirection.HasValue)
						{
							SenseComponent senseComponent = default(SenseComponent);
							if (!IsSprinting && ((Component)base.baseEntity).TryGetComponent<SenseComponent>(ref senseComponent) && senseComponent.FindTargetLKP(out var lkp, applyHeightOffset: true, predict: false, ignoreCrouch: false))
							{
								Vector3 val5 = Vector3Ex.NormalizeXZ(lkp - ((Component)this).transform.position);
								if (((Vector3)(ref val5)).magnitude > 0.001f)
								{
									SetRotation(Quaternion.LookRotation(val5));
								}
							}
							else if (((Vector3)(ref val4)).magnitude > 0.001f)
							{
								Matrix4x4 navMeshToWorldSpace = base.baseEntity.NavMeshToWorldSpace;
								normalized = ((Matrix4x4)(ref navMeshToWorldSpace)).MultiplyVector(normalized);
								Vector3 val6 = Vector3Ex.XZ3D(normalized);
								if (((Vector3)(ref val6)).magnitude > 0.001f)
								{
									SetRotation(Quaternion.LookRotation(val6));
								}
							}
						}
					}
					else
					{
						curSpeed = Mathf.Max(desiredSpeed, curSpeed - 10f * Time.deltaTime);
						ResetPath();
					}
				}
				SenseComponent senseComponent2 = default(SenseComponent);
				Vector3 lkp2;
				if (overrideDirection.HasValue)
				{
					SetDirection(overrideDirection.Value);
				}
				else if (steeringMode == SteeringMode.FaceTarget && !IsSprinting && ((Component)base.baseEntity).TryGetComponent<SenseComponent>(ref senseComponent2) && senseComponent2.FindTargetLKP(out lkp2, applyHeightOffset: true))
				{
					Vector3 direction = Vector3Ex.NormalizeXZ(lkp2 - ((Component)this).transform.position);
					SetDirection(direction);
				}
			}
			finally
			{
				previousLocalPosition = ((Component)base.baseEntity).transform.localPosition;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SetDirection(Vector3 direction)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.XZ3D(direction);
		if (((Vector3)(ref val)).magnitude > 0.001f)
		{
			SetRotation(Quaternion.LookRotation(val));
		}
	}

	private void SetRotation(Quaternion rotation)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.rotation = Quaternion.RotateTowards(((Component)this).transform.rotation, rotation, AngularSpeed * Time.deltaTime);
	}

	private static float GetBrakingDistance(float speed, float brakingDeceleration)
	{
		float num = speed / Mathf.Max(brakingDeceleration, 0.001f);
		return 0.5f * brakingDeceleration * num * num;
	}

	private float AdjustSpeedForSwimming(float speed)
	{
		if (!IsSwimming || speed <= 0f)
		{
			return speed;
		}
		if (!(speed < sprintSpeed))
		{
			return swimSprintSpeed;
		}
		return swimSpeed;
	}

	private void SteerTowardsWaypoint()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SteerTowardsWaypoint", 0);
		try
		{
			Transform transform = ((Component)base.baseEntity).transform;
			Vector3 val2 = agent.steeringTarget - transform.position;
			Vector3 val3 = ((Vector3)(ref val2)).normalized;
			if (Mathf.Abs(cachedPathLength - Vector3.Distance(transform.position, agent.destination)) < 5f)
			{
				val3 = Quaternion.AngleAxis(currentDeviation, Vector3.up) * val3;
			}
			float num = AdjustSpeedForSwimming(desiredSpeed);
			if (shouldStopAtDestination && agent.remainingDistance - maxTurnRadius < GetBrakingDistance(curSpeed, deceleration.Value))
			{
				curSpeed = Mathf.Max(1f, curSpeed - deceleration.Value * Time.deltaTime);
			}
			else if (curSpeed > num)
			{
				float num2 = (curSpeed - num) / deceleration.Value;
				float num3 = ((curSpeed > walkSpeed && num2 > 1f) ? 10f : deceleration.Value);
				curSpeed = Mathf.Max(num, curSpeed - num3 * Time.deltaTime);
			}
			else if (curSpeed < num)
			{
				curSpeed = Mathf.Min(num, curSpeed + acceleration.Value * Time.deltaTime);
			}
			agent.isStopped = true;
			if (!(((Vector3)(ref val3)).magnitude < 0.01f))
			{
				float num4 = (shouldStopAtDestination ? Mathx.RemapValClamped(agent.remainingDistance, maxTurnRadius * 2f, 0f, maxTurnRadius, 0.001f) : maxTurnRadius);
				float num5 = curSpeed / num4;
				Vector3 val4 = Vector3.RotateTowards(transform.forward, val3, num5 * Time.deltaTime, 0f);
				Vector3 offset = val4 * (curSpeed * Time.deltaTime);
				transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(val4, 0f));
				Move(offset);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionOnNavmesh(Vector3 position, out Vector3 sample)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return SamplePosition(position, out sample, 0.5f);
	}

	public bool SampleGroundPositionWithPhysics(Vector3 position, out RaycastHit hitInfo, float maxDistance = 2f, float radius = 0f, int layerMask = 1503731969)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SampleGroundPositionWithPhysics", 0);
		try
		{
			Vector3 val2 = position + Vector3.up * radius * 1.5f;
			float maxDistance2 = maxDistance + radius * 1.5f;
			if (!GamePhysics.TraceRealm(GamePhysics.Realm.Server, new Ray(val2, Vector3.down), radius, out hitInfo, maxDistance2, layerMask, (QueryTriggerInteraction)1))
			{
				((RaycastHit)(ref hitInfo)).point = position;
				return false;
			}
			if (radius > 0f && ((RaycastHit)(ref hitInfo)).distance <= 0f)
			{
				((RaycastHit)(ref hitInfo)).point = position;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionOnFavoredTerrain(Vector3 position)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionOnFavoredTerrain", 0);
		try
		{
			return IsPositionAtTopologyRequirement(position, preferedTopology) && IsPositionABiomeRequirement(position, preferedBiome);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionAtTopologyRequirement(Vector3 position, Enum topologyRequirement)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionAtTopologyRequirement", 0);
		try
		{
			if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
			{
				return false;
			}
			Enum val2 = (Enum)TerrainMeta.TopologyMap.GetTopology(position);
			if ((topologyRequirement & val2) == 0)
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionABiomeRequirement(Vector3 position, Enum biomeRequirement)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionABiomeRequirement", 0);
		try
		{
			if ((int)biomeRequirement == 0)
			{
				return true;
			}
			if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
			{
				return false;
			}
			Enum val2 = (Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(position);
			if ((biomeRequirement & val2) == 0)
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsInWater(Vector3 position)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsInWater", 0);
		try
		{
			if ((Object)(object)base.baseEntity.GetParentEntity() != (Object)null)
			{
				return false;
			}
			if (WaterLevel.GetWaterDepth(position, waves: false, volumes: false) >= 0.3f)
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool SamplePosition(Vector3 position, out Vector3 sample, float maxDistance)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SamplePosition", 0);
		try
		{
			sample = position;
			NavMeshHit val2 = default(NavMeshHit);
			if (!NavMesh.SamplePosition(position, ref val2, maxDistance, agent.areaMask))
			{
				return false;
			}
			sample = ((NavMeshHit)(ref val2)).position;
			return ((NavMeshHit)(ref val2)).hit;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool Raycast(Vector3 startPosition, Vector3 targetPosition, out NavMeshHit hitInfo)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:RaycastAgent", 0);
		try
		{
			return NavMesh.Raycast(startPosition, targetPosition, ref hitInfo, agent.areaMask);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool Raycast(Vector3 targetPosition, out NavMeshHit hitInfo)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:Raycast", 0);
		try
		{
			return agent.Raycast(targetPosition, ref hitInfo);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool CalculatePathCustom(Vector3 startPosition, Vector3 destination, NavMeshPath path)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:CalculatePathCustom", 0);
		try
		{
			return NavMesh.CalculatePath(startPosition, destination, agent.areaMask, path);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool CalculatePathCustom(Vector3 destination, NavMeshPath path)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:CalculatePathCustomAgent", 0);
		try
		{
			return agent.CalculatePath(destination, path);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void SaveComponent(BaseNetworkable.SaveInfo info)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		base.SaveComponent(info);
		if (base.baseEntity.isServer && !info.forDisk)
		{
			info.msg.npcMovementState = Pool.Get<NPCMovementState>();
			info.msg.npcMovementState.overrideDirection = (overrideDirection.HasValue ? overrideDirection.Value : Vector3.zero);
		}
	}
}


public enum Speeds
{
	Sneak,
	Walk,
	Jog,
	Run,
	Sprint,
	FullSprint
}


public enum SteeringMode
{
	FaceTarget,
	LimitedTurnRate
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public static class NavMeshPathEx
{
	private static Vector3[] cornersBuffer = (Vector3[])(object)new Vector3[128];

	public static void GetCornersNonAllocAsList(this NavMeshPath path, List<Vector3> corners)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetCornersNonAllocAsList", 0);
		try
		{
			corners.Clear();
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc >= 1)
			{
				for (int i = 0; i < cornersNonAlloc; i++)
				{
					corners.Add(cornersBuffer[i]);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetPathLength(this NavMeshPath path)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetPathLength", 0);
		try
		{
			float num = 0f;
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc < 2)
			{
				return num;
			}
			for (int i = 0; i < cornersNonAlloc - 1; i++)
			{
				num += Vector3.Distance(cornersBuffer[i], cornersBuffer[i + 1]);
			}
			return num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetOrigin(this NavMeshPath path)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetOrigin", 0);
		try
		{
			if (path.GetCornersNonAlloc(cornersBuffer) < 1)
			{
				return Vector3.zero;
			}
			return cornersBuffer[0];
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetDestination(this NavMeshPath path)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetDestination", 0);
		try
		{
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc < 1)
			{
				return Vector3.zero;
			}
			return cornersBuffer[cornersNonAlloc - 1];
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using ConVar;
using Rust;
using UnityEngine;

public class BaseNPC2 : BaseCombatEntity
{
	[SerializeField]
	private float mass = 45f;

	public override bool IsNpc => true;

	public virtual bool IsAnimal => true;

	public override float RealisticMass => mass;

	public string displayName
	{
		get
		{
			PrefabInformation prefabInformation = null;
			if (base.isServer)
			{
				prefabInformation = PrefabAttribute.server.Find<PrefabInformation>(prefabID);
			}
			if (prefabInformation == null)
			{
				if (AI.logIssues)
				{
					Debug.LogError((object)("PrefabInformation not found for " + Categorize() + ")"));
				}
				return "NPC";
			}
			return prefabInformation.title.english;
		}
	}

	public override float AntiHackVelocity()
	{
		return 10f;
	}

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			startHealth *= AI.npcHealthMultiplier;
			startHealth = Mathf.Max(1f, startHealth);
			Query.Server.AddBrain(this);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer && Object.op_Implicit((Object)(object)info.InitiatorPlayer) && !info.damageTypes.IsMeleeType())
		{
			info.InitiatorPlayer.LifeStoryShotHit(info.Weapon);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer && !Application.isQuitting)
		{
			Query.Server.RemoveBrain(this);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

[SoftRequireComponent(typeof(SenseComponent))]
public class NPCEncounterTimer : EntityComponent<BaseEntity>, IServerComponent
{
	public float giveUpDurationSeconds = 120f;

	[NonSerialized]
	public UnityEvent onShouldGiveUp = new UnityEvent();

	private const float fireTimeMultiplier = 4f;

	private const float mountedTimeMultiplier = 12f;

	private float? encounterRemainingTimeSeconds;

	private double? _lastTickTime;

	private SenseComponent _senseComponent;

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	private SenseComponent Senses => _senseComponent ?? (_senseComponent = ((Component)base.baseEntity).GetComponent<SenseComponent>());

	public void Tick()
	{
		float num = (float)(Time.timeAsDouble - LastTickTime);
		LastTickTime = Time.timeAsDouble;
		BaseEntity target;
		bool flag = Senses.FindTarget(out target);
		if (encounterRemainingTimeSeconds.HasValue && !flag)
		{
			encounterRemainingTimeSeconds = null;
		}
		else if (!encounterRemainingTimeSeconds.HasValue && flag)
		{
			StartTimer();
		}
		else
		{
			if (!encounterRemainingTimeSeconds.HasValue)
			{
				return;
			}
			if (base.baseEntity is BaseCombatEntity { SecondsSinceAttacked: <5f })
			{
				StartTimer();
				PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					Senses.GetInitialAllies((List<BaseEntity>)(object)val);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val)
					{
						((Component)item).GetComponent<NPCEncounterTimer>().StartTimer();
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			float num2 = 1f;
			if (target.ToNonNpcPlayer(out var player) && player.isMounted)
			{
				num2 = 12f;
			}
			else if (Trans_TargetIsNearFire.Test(base.baseEntity, Senses))
			{
				num2 = 4f;
			}
			encounterRemainingTimeSeconds -= num * num2;
			if (!(encounterRemainingTimeSeconds <= 0f))
			{
				return;
			}
			GiveUp();
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				Senses.GetInitialAllies((List<BaseEntity>)(object)val2);
				foreach (BaseEntity item2 in (List<BaseEntity>)(object)val2)
				{
					((Component)item2).GetComponent<NPCEncounterTimer>().GiveUp();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
	}

	private void StartTimer()
	{
		encounterRemainingTimeSeconds = giveUpDurationSeconds;
	}

	private void GiveUp()
	{
		if (encounterRemainingTimeSeconds.HasValue)
		{
			encounterRemainingTimeSeconds = null;
			onShouldGiveUp.Invoke();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/AI/NPC team", fileName = "NPCTeam_new", order = 0)]
public class NPCTeam : BaseScriptableObject
{
}


public enum ENPCVoicelineCategory
{
	None,
	Surprise,
	Push,
	Flank,
	Hold,
	Lost,
	Search,
	Reload,
	Ok,
	DistractedByHeavy,
	SurprisedHeavy
}


public enum ENpcVoicelineImportance : byte
{
	Flavour = 0,
	Important = 1,
	Conversation = 3
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public struct NPCVoiceline
{
	public ENPCVoicelineCategory category;

	public string text;

	public AudioClip audioClip;

	public ENpcVoicelineImportance importance;

	public bool otherNpcShouldSpeakFirst;

	public bool allowOkResponse;

	public int index;

	public float duration;
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust.Ai.Gen2;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/AI/NPC voiceline db", fileName = "NPCVoicelineDB", order = 0)]
public class NPCVoicelinesDatabase : BaseScriptableObject
{
	public List<NPCVoiceline> voicelines = new List<NPCVoiceline>();

	private Dictionary<ENPCVoicelineCategory, List<NPCVoiceline>> categoryToVoiceline;

	public bool FindVoiceline(int index, out NPCVoiceline voiceline)
	{
		TimeWarning val = TimeWarning.New("NPCVoicelinesDatabase.FindVoiceline", 0);
		try
		{
			if (index < 0 || index >= voicelines.Count)
			{
				voiceline = default(NPCVoiceline);
				if (AI.logIssues)
				{
					Debug.LogWarning((object)$"NPCVoicelinesDatabase.FindAudioClip - index out of range: {index} / {voicelines.Count}");
				}
				return false;
			}
			voiceline = voicelines[index];
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetVoicelinesByCategory(ENPCVoicelineCategory category, out List<NPCVoiceline> voicelinesInCategory)
	{
		TimeWarning val = TimeWarning.New("NPCVoicelinesDatabase.GetVoicelinesByCategory", 0);
		try
		{
			if (categoryToVoiceline == null)
			{
				categoryToVoiceline = new Dictionary<ENPCVoicelineCategory, List<NPCVoiceline>>();
				foreach (NPCVoiceline voiceline in voicelines)
				{
					if (!categoryToVoiceline.TryGetValue(voiceline.category, out var value))
					{
						value = new List<NPCVoiceline>();
						categoryToVoiceline[voiceline.category] = value;
					}
					value.Add(voiceline);
				}
			}
			return categoryToVoiceline.TryGetValue(category, out voicelinesInCategory);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

[RequireComponent(typeof(LimitedTurnNavAgent))]
public class NavPathTester : MonoBehaviour
{
	[SerializeField]
	private Transform target;
}


using UnityEngine;
using UnityEngine.AI;

public static class NPCOverwatchSpot
{
	public static (Vector3 loc, Vector3 dir)? Find(Vector3[] corners)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		if (corners.Length < 3)
		{
			return null;
		}
		NavMeshHit val8 = default(NavMeshHit);
		RaycastHit val10 = default(RaycastHit);
		RaycastHit val11 = default(RaycastHit);
		for (int num = corners.Length - 1; num >= 2; num--)
		{
			Vector3 val = corners[num];
			Vector3 val2 = corners[num - 1];
			Vector3 val3 = corners[num - 2];
			Vector3 val4 = Vector3Ex.NormalizeXZ(val - val2);
			Vector3 val5 = Vector3Ex.NormalizeXZ(val3 - val2);
			Vector3 val6 = -Vector3Ex.NormalizeXZ(val4 + val5) * 0.01f;
			val += val6;
			val2 += val6;
			Vector3 val7 = Vector3Ex.NormalizeXZ(val2 - val) * 100f;
			if (NavMesh.Raycast(val, val + val7, ref val8, -1) && ((NavMeshHit)(ref val8)).distance >= 7f)
			{
				Vector3 val9 = corners[^1];
				Vector3 position = ((NavMeshHit)(ref val8)).position;
				if (Physics.Linecast(val9 + 1.7f * Vector3.up, position + 1.7f * Vector3.up, ref val10, 1218652417) && Physics.Linecast(val9 + 0.2f * Vector3.up, position + 0.2f * Vector3.up, ref val11, 1218652417))
				{
					Vector3 position2 = ((NavMeshHit)(ref val8)).position;
					Vector3 val12 = val - ((NavMeshHit)(ref val8)).position;
					return (position2, ((Vector3)(ref val12)).normalized);
				}
			}
		}
		return null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

public static class NPCFlankSpot
{
	private static readonly List<Quaternion> sampleRotations = new List<Quaternion>
	{
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.Euler(0f, -90f, 0f),
		Quaternion.Euler(0f, 45f, 0f),
		Quaternion.Euler(0f, -45f, 0f)
	};

	public static bool Find(LimitedTurnNavAgent agent, Vector3 enemyPositionNs, NavMeshPath directPath, NavMeshPath pathToFlank, NavMeshPath pathFromFlankToEnemy, float flankWidth = 15f, float sampleRadius = 3.5f, float minAngle = 30f, float minSimilarity = 0.25f)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isPlaying || !Application.isEditor)
		{
			agent.GetBaseEntity();
		}
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			directPath.GetCornersNonAllocAsList((List<Vector3>)(object)val);
			if (((List<Vector3>)(object)val).Count < 2)
			{
				return false;
			}
			Vector3 val2 = Vector3Ex.NormalizeXZ(enemyPositionNs - agent.NavPosition) * flankWidth;
			for (int i = 0; i < sampleRotations.Count; i++)
			{
				Vector3 position = enemyPositionNs + sampleRotations[i] * val2;
				if (!agent.SamplePosition(position, out var sample, sampleRadius) || !agent.CalculatePathCustom(sample, enemyPositionNs, pathFromFlankToEnemy) || (int)pathFromFlankToEnemy.status != 0)
				{
					continue;
				}
				PooledList<Vector3> val3 = Pool.Get<PooledList<Vector3>>();
				try
				{
					pathFromFlankToEnemy.GetCornersNonAllocAsList((List<Vector3>)(object)val3);
					if (((List<Vector3>)(object)val3).Count < 2)
					{
						continue;
					}
					if (Vector3.Angle(Vector3Ex.NormalizeXZ(((List<Vector3>)(object)val)[((List<Vector3>)(object)val).Count - 1] - ((List<Vector3>)(object)val)[((List<Vector3>)(object)val).Count - 2]), Vector3Ex.NormalizeXZ(((List<Vector3>)(object)val3)[((List<Vector3>)(object)val3).Count - 1] - ((List<Vector3>)(object)val3)[((List<Vector3>)(object)val3).Count - 2])) < minAngle || !agent.CalculatePathCustom(sample, pathToFlank) || (int)pathToFlank.status != 0 || State_Flank.ComputePathsInitialSimilarity(directPath, pathToFlank) > minSimilarity)
					{
						continue;
					}
					Vector3? val4 = null;
					PooledList<Vector3> val5 = Pool.Get<PooledList<Vector3>>();
					try
					{
						pathToFlank.GetCornersNonAllocAsList((List<Vector3>)(object)val5);
						if (((List<Vector3>)(object)val5).Count < 2)
						{
							continue;
						}
						for (int j = 0; j < ((List<Vector3>)(object)val5).Count - 1; j++)
						{
							for (int num = ((List<Vector3>)(object)val3).Count - 1; num >= 1; num--)
							{
								if (Vector3.Distance(((List<Vector3>)(object)val5)[j], ((List<Vector3>)(object)val3)[num]) < 2f && !agent.Raycast(((List<Vector3>)(object)val5)[j], ((List<Vector3>)(object)val3)[num], out var _))
								{
									val4 = ((List<Vector3>)(object)val5)[j];
									break;
								}
							}
							if (val4.HasValue)
							{
								break;
							}
						}
						if (val4.HasValue)
						{
							sample = val4.Value;
							if (!agent.CalculatePathCustom(sample, enemyPositionNs, pathFromFlankToEnemy) || (int)pathFromFlankToEnemy.status != 0)
							{
								return false;
							}
							pathFromFlankToEnemy.GetCornersNonAllocAsList((List<Vector3>)(object)val3);
							if (((List<Vector3>)(object)val3).Count < 2)
							{
								return false;
							}
							if (Vector3.Angle(Vector3Ex.NormalizeXZ(((List<Vector3>)(object)val)[((List<Vector3>)(object)val).Count - 1] - ((List<Vector3>)(object)val)[((List<Vector3>)(object)val).Count - 2]), Vector3Ex.NormalizeXZ(((List<Vector3>)(object)val3)[((List<Vector3>)(object)val3).Count - 1] - ((List<Vector3>)(object)val3)[((List<Vector3>)(object)val3).Count - 2])) < minAngle)
							{
								return false;
							}
							if (!agent.CalculatePathCustom(sample, pathToFlank) || (int)pathToFlank.status != 0)
							{
								return false;
							}
						}
						return true;
					}
					finally
					{
						((IDisposable)val5)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(LimitedTurnNavAgent))]
public class RootMotionPlayer : EntityComponent<BaseEntity>, IServerComponent
{
	public struct Warp
	{
		public float startTime;

		public float endTime;

		public Vector3 translationScale;

		public float rotationScale;

		public Warp(float startTime, float endTime, Vector3 translationScale, float rotationScale = 1f)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			this.startTime = startTime;
			this.endTime = endTime;
			this.translationScale = translationScale;
			this.rotationScale = rotationScale;
		}
	}

	public class PlayServerState : IPooled
	{
		public AnimationClip animClip;

		public RootMotionData rmData;

		public float elapsedTime;

		public Vector3 initialLocation;

		public Quaternion initialRotation;

		public Action ServerTickAction;

		public Warp[] warps;

		public bool constrainToNavmesh;

		public Vector3 lastUnscaledOffset;

		public float lastUnscaledRotation;

		public bool isPlaying;

		public void Reset()
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			isPlaying = false;
			rmData = null;
			animClip = null;
			initialRotation = Quaternion.identity;
			warps = null;
			constrainToNavmesh = true;
			elapsedTime = 0f;
			ServerTickAction = null;
			lastUnscaledOffset = Vector3.zero;
			lastUnscaledRotation = 0f;
		}

		void IPooled.EnterPool()
		{
			Reset();
		}

		void IPooled.LeavePool()
		{
			Reset();
		}

		public static PlayServerState TakeFromPool(RootMotionData data, Transform transform)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			PlayServerState playServerState = Pool.Get<PlayServerState>();
			playServerState.rmData = data;
			playServerState.initialLocation = transform.position;
			playServerState.initialRotation = transform.rotation;
			return playServerState;
		}

		public static PlayServerState TakeFromPool(AnimationClip data, Transform transform)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			PlayServerState playServerState = Pool.Get<PlayServerState>();
			playServerState.animClip = data;
			playServerState.initialLocation = transform.position;
			playServerState.initialRotation = transform.rotation;
			return playServerState;
		}

		public int GetAnimHash()
		{
			if (rmData != null)
			{
				if ((Object)(object)rmData.inPlaceAnimation == (Object)null)
				{
					Debug.LogError((object)("RootMotionPlayer.PlayServer: rmData.inPlaceAnimation is null for " + ((Object)rmData).name));
				}
				return Animator.StringToHash(((Object)rmData.inPlaceAnimation).name);
			}
			if ((Object)(object)animClip == (Object)null)
			{
				Debug.LogError((object)"RootMotionPlayer.PlayServer: animClip is null");
			}
			return Animator.StringToHash(((Object)animClip).name);
		}

		public float GetAnimLength()
		{
			if (!(rmData != null))
			{
				return animClip.length;
			}
			return rmData.inPlaceAnimation.length;
		}

		public bool Step(float deltaTime, ref Vector3 location, ref Quaternion rotation, float rootBoneLocalZOffset = 0f)
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_018a: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			//IL_0195: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0209: Unknown result type (might be due to invalid IL or missing references)
			//IL_020e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0213: Unknown result type (might be due to invalid IL or missing references)
			//IL_0218: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0162: Unknown result type (might be due to invalid IL or missing references)
			if (elapsedTime >= GetAnimLength())
			{
				return false;
			}
			if (rmData == null)
			{
				elapsedTime += deltaTime;
				return elapsedTime < GetAnimLength() - 0.25f;
			}
			Vector3 zero = Vector3.zero;
			zero.x = rmData.xMotionCurve.Evaluate(elapsedTime);
			zero.y = (constrainToNavmesh ? 0f : rmData.yMotionCurve.Evaluate(elapsedTime));
			zero.z = rmData.zMotionCurve.Evaluate(elapsedTime);
			float num = rmData.yRotationCurve.Evaluate(elapsedTime);
			Vector3 val = zero - lastUnscaledOffset;
			float num2 = num - lastUnscaledRotation;
			lastUnscaledOffset = zero;
			lastUnscaledRotation = num;
			if (warps != null)
			{
				Warp[] array = warps;
				for (int i = 0; i < array.Length; i++)
				{
					Warp warp = array[i];
					if (warp.startTime <= elapsedTime && elapsedTime <= warp.endTime)
					{
						val.x *= warp.translationScale.x;
						val.y *= warp.translationScale.y;
						val.z *= warp.translationScale.z;
						num2 *= warp.rotationScale;
					}
				}
			}
			Vector3 val2 = initialRotation * val;
			location -= rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
			location += val2;
			rotation *= Quaternion.Euler(0f, num2, 0f);
			location += rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
			elapsedTime += deltaTime;
			return elapsedTime < GetAnimLength() - 0.25f;
		}

		public Quaternion Track(Vector3 ownerPos, Vector3 targetPos, Quaternion rotation, float trackingSpeed, float deltaTime)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Vector3Ex.NormalizeXZ(targetPos - ownerPos);
			initialRotation = Quaternion.RotateTowards(initialRotation, Quaternion.LookRotation(val, Vector3.up), trackingSpeed * deltaTime);
			rotation *= Quaternion.Inverse(rotation) * initialRotation;
			return rotation;
		}
	}

	[SerializeField]
	private float rootBoneLocalZOffset;

	private LimitedTurnNavAgent _agent;

	private PlayServerState currentPlayState;

	private Action _playServerTickAction;

	private LockState.LockHandle lockHandle;

	private LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>());

	private Action PlayServerTickAction => PlayServerTick;

	public PlayServerState PlayServerAndTakeFromPool(RootMotionData data)
	{
		PlayServerState playServerState = PlayServerState.TakeFromPool(data, ((Component)base.baseEntity).transform);
		PlayServer(playServerState);
		return playServerState;
	}

	public PlayServerState PlayServerAndTakeFromPool(AnimationClip data)
	{
		PlayServerState playServerState = PlayServerState.TakeFromPool(data, ((Component)base.baseEntity).transform);
		PlayServer(playServerState);
		return playServerState;
	}

	public void PlayServer(PlayServerState state)
	{
		if (AI.logIssues && state.rmData == null && (Object)(object)state.animClip == (Object)null)
		{
			Debug.LogError((object)"RootMotionPlayer.PlayServer: state.rmData and state.animClip are both null");
			return;
		}
		if (currentPlayState != null)
		{
			StopServer(currentPlayState);
		}
		currentPlayState = state;
		currentPlayState.isPlaying = true;
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayMontageDelayed"), currentPlayState.GetAnimHash());
		lockHandle = Agent.Pause();
		((FacepunchBehaviour)base.baseEntity).InvokeRepeating(PlayServerTickAction, 0f, 0f);
	}

	public void PlayServerAdditive(AnimationClip animClip)
	{
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayAdditiveMontage"), Animator.StringToHash(((Object)animClip).name));
	}

	private void PlayServerTick()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("RootMotionPlayer:PlayServerTick", 0);
		try
		{
			Vector3 location = ((Component)base.baseEntity).transform.position;
			Quaternion rotation = ((Component)base.baseEntity).transform.rotation;
			bool num = !currentPlayState.Step(Time.deltaTime, ref location, ref rotation, rootBoneLocalZOffset);
			if (currentPlayState.rmData != null)
			{
				if (currentPlayState.constrainToNavmesh)
				{
					Agent.Move(location - ((Component)base.baseEntity).transform.position);
				}
				else
				{
					((Component)base.baseEntity).transform.position = location;
				}
				((Component)base.baseEntity).transform.rotation = rotation;
			}
			if (num)
			{
				StopServer(currentPlayState, interrupt: false);
				currentPlayState = null;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Track(Vector3 targetPos, float trackingSpeed = 45f, float? timeStep = null)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (currentPlayState != null && !(currentPlayState.rmData == null))
		{
			if (!timeStep.HasValue)
			{
				timeStep = Time.deltaTime;
			}
			((Component)base.baseEntity).transform.rotation = currentPlayState.Track(((Component)this).transform.position, targetPos, ((Component)base.baseEntity).transform.rotation, trackingSpeed, timeStep.Value);
		}
	}

	private void StopServer(PlayServerState state, bool interrupt = true)
	{
		if (state != null && state.isPlaying)
		{
			state.isPlaying = false;
			if (state == currentPlayState)
			{
				((FacepunchBehaviour)base.baseEntity).CancelInvoke(PlayServerTickAction);
				Agent.Unpause(ref lockHandle);
				currentPlayState = null;
			}
			if (interrupt)
			{
				base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_StopMontage"));
			}
		}
	}

	public void StopServerAndReturnToPool(ref PlayServerState state, bool interrupt = true)
	{
		if (state != null)
		{
			StopServer(state, interrupt);
			Pool.Free<PlayServerState>(ref state);
		}
	}
}


using UnityEngine;

public struct Warp
{
	public float startTime;

	public float endTime;

	public Vector3 translationScale;

	public float rotationScale;

	public Warp(float startTime, float endTime, Vector3 translationScale, float rotationScale = 1f)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		this.startTime = startTime;
		this.endTime = endTime;
		this.translationScale = translationScale;
		this.rotationScale = rotationScale;
	}
}


using System;
using Facepunch;
using UnityEngine;

public class PlayServerState : IPooled
{
	public AnimationClip animClip;

	public RootMotionData rmData;

	public float elapsedTime;

	public Vector3 initialLocation;

	public Quaternion initialRotation;

	public Action ServerTickAction;

	public Warp[] warps;

	public bool constrainToNavmesh;

	public Vector3 lastUnscaledOffset;

	public float lastUnscaledRotation;

	public bool isPlaying;

	public void Reset()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		isPlaying = false;
		rmData = null;
		animClip = null;
		initialRotation = Quaternion.identity;
		warps = null;
		constrainToNavmesh = true;
		elapsedTime = 0f;
		ServerTickAction = null;
		lastUnscaledOffset = Vector3.zero;
		lastUnscaledRotation = 0f;
	}

	void IPooled.EnterPool()
	{
		Reset();
	}

	void IPooled.LeavePool()
	{
		Reset();
	}

	public static PlayServerState TakeFromPool(RootMotionData data, Transform transform)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		PlayServerState playServerState = Pool.Get<PlayServerState>();
		playServerState.rmData = data;
		playServerState.initialLocation = transform.position;
		playServerState.initialRotation = transform.rotation;
		return playServerState;
	}

	public static PlayServerState TakeFromPool(AnimationClip data, Transform transform)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		PlayServerState playServerState = Pool.Get<PlayServerState>();
		playServerState.animClip = data;
		playServerState.initialLocation = transform.position;
		playServerState.initialRotation = transform.rotation;
		return playServerState;
	}

	public int GetAnimHash()
	{
		if (rmData != null)
		{
			if ((Object)(object)rmData.inPlaceAnimation == (Object)null)
			{
				Debug.LogError((object)("RootMotionPlayer.PlayServer: rmData.inPlaceAnimation is null for " + ((Object)rmData).name));
			}
			return Animator.StringToHash(((Object)rmData.inPlaceAnimation).name);
		}
		if ((Object)(object)animClip == (Object)null)
		{
			Debug.LogError((object)"RootMotionPlayer.PlayServer: animClip is null");
		}
		return Animator.StringToHash(((Object)animClip).name);
	}

	public float GetAnimLength()
	{
		if (!(rmData != null))
		{
			return animClip.length;
		}
		return rmData.inPlaceAnimation.length;
	}

	public bool Step(float deltaTime, ref Vector3 location, ref Quaternion rotation, float rootBoneLocalZOffset = 0f)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		if (elapsedTime >= GetAnimLength())
		{
			return false;
		}
		if (rmData == null)
		{
			elapsedTime += deltaTime;
			return elapsedTime < GetAnimLength() - 0.25f;
		}
		Vector3 zero = Vector3.zero;
		zero.x = rmData.xMotionCurve.Evaluate(elapsedTime);
		zero.y = (constrainToNavmesh ? 0f : rmData.yMotionCurve.Evaluate(elapsedTime));
		zero.z = rmData.zMotionCurve.Evaluate(elapsedTime);
		float num = rmData.yRotationCurve.Evaluate(elapsedTime);
		Vector3 val = zero - lastUnscaledOffset;
		float num2 = num - lastUnscaledRotation;
		lastUnscaledOffset = zero;
		lastUnscaledRotation = num;
		if (warps != null)
		{
			Warp[] array = warps;
			for (int i = 0; i < array.Length; i++)
			{
				Warp warp = array[i];
				if (warp.startTime <= elapsedTime && elapsedTime <= warp.endTime)
				{
					val.x *= warp.translationScale.x;
					val.y *= warp.translationScale.y;
					val.z *= warp.translationScale.z;
					num2 *= warp.rotationScale;
				}
			}
		}
		Vector3 val2 = initialRotation * val;
		location -= rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
		location += val2;
		rotation *= Quaternion.Euler(0f, num2, 0f);
		location += rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
		elapsedTime += deltaTime;
		return elapsedTime < GetAnimLength() - 0.25f;
	}

	public Quaternion Track(Vector3 ownerPos, Vector3 targetPos, Quaternion rotation, float trackingSpeed, float deltaTime)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.NormalizeXZ(targetPos - ownerPos);
		initialRotation = Quaternion.RotateTowards(initialRotation, Quaternion.LookRotation(val, Vector3.up), trackingSpeed * deltaTime);
		rotation *= Quaternion.Inverse(rotation) * initialRotation;
		return rotation;
	}
}


using UnityEngine;

public class RootMotionTester : MonoBehaviour
{
	public RootMotionData anim;

	public Transform target;

	public float timeStep = 0.1f;

	public float trackingSpeed = 90f;

	public float trackingDuration = 1f;

	public float rotArrowLength = 0.2f;

	public float targetVelocityYaw = 45f;

	public float targetVelocityMagnitude = 5f;

	public int trackingStepIndex;

	public float parentFrontOffset;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust.Ai;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class SenseComponent : EntityComponent<BaseEntity>
{
	[Serializable]
	public struct Cone
	{
		public float halfAngle;

		public float range;

		public Cone(float halfAngle = 80f, float range = 10f)
		{
			this.halfAngle = halfAngle;
			this.range = range;
		}
	}

	public class VisibilityStatus : IPooled
	{
		private const float maxPredictionTime = 1f;

		private bool isFirstAware;

		private BaseEntity baseEntity;

		private BaseEntity targetEntity;

		public Vector3 lastKnownPosition;

		public Vector3 predictedPosition;

		private const float maxClarity = 2f;

		private const float waterCheckInterval = 1f;

		private double? lastTimeInWaterUpdated;

		private double? lastTimeSurprised;

		public float clarity { get; private set; }

		public bool IsAware => clarity >= 1f;

		public float Accuracy
		{
			get
			{
				if (!IsAware)
				{
					return 0f;
				}
				return Mathx.RemapValClamped(clarity, 1f, 2f, 0f, 1f);
			}
		}

		public float timeVisible { get; private set; }

		public float timeNotVisible { get; private set; }

		public bool IsVisible => timeVisible > 0f;

		public float timeAwareAndVisible { get; private set; }

		public float timeNotAwareAndVisible { get; private set; }

		public float timeWatched { get; private set; }

		public float timeNotWatched { get; private set; }

		public float timeAimedAt { get; private set; }

		public float timeNotAimedAt { get; private set; }

		public WaterLevel.WaterInfo? lastWaterInfo { get; private set; }

		public bool isInWaterCached
		{
			get
			{
				//IL_0093: Unknown result type (might be due to invalid IL or missing references)
				//IL_009d: Unknown result type (might be due to invalid IL or missing references)
				//IL_008c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
				if (!targetEntity.ToNonNpcPlayer(out var player))
				{
					return false;
				}
				if (!lastWaterInfo.HasValue || !lastTimeInWaterUpdated.HasValue || Time.timeAsDouble - lastTimeInWaterUpdated > 1.0)
				{
					BaseMountable castedUnityObject;
					Vector3 val = (((Object)(object)player.GetMounted()).Is<BaseMountable>(out castedUnityObject) ? (Vector3.down * 0.5f) : Vector3.zero);
					lastWaterInfo = WaterLevel.GetWaterInfo(((Component)targetEntity).transform.position + val, waves: false, volumes: false);
					lastTimeInWaterUpdated = Time.timeAsDouble;
				}
				return lastWaterInfo.Value.currentDepth >= 0.3f;
			}
		}

		public bool IsCamping { get; private set; }

		public bool TryConsumeSurprise()
		{
			if (!lastTimeSurprised.HasValue)
			{
				return false;
			}
			lastTimeSurprised = null;
			return true;
		}

		private void Reset()
		{
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			isFirstAware = true;
			targetEntity = null;
			baseEntity = null;
			timeAwareAndVisible = 0f;
			timeNotAwareAndVisible = 100f;
			timeWatched = 0f;
			timeNotWatched = 100f;
			timeAimedAt = 0f;
			timeNotAimedAt = 100f;
			timeVisible = 0f;
			timeNotVisible = 100f;
			lastKnownPosition = Vector3.zero;
			predictedPosition = Vector3.zero;
			lastWaterInfo = null;
			lastTimeInWaterUpdated = null;
			lastTimeSurprised = null;
			IsCamping = false;
			clarity = 0f;
		}

		public void EnterPool()
		{
			Reset();
		}

		public void LeavePool()
		{
			Reset();
		}

		public static VisibilityStatus GetFromPool(BaseEntity baseEntity, BaseEntity targetEntity, bool isVisible, float deltaTime, float clarityGainSpeed, Vector3? lastKnownPositionOverride = null, float? minClarity = null)
		{
			VisibilityStatus visibilityStatus = Pool.Get<VisibilityStatus>();
			visibilityStatus.baseEntity = baseEntity;
			visibilityStatus.targetEntity = targetEntity;
			visibilityStatus.UpdateVisibility(isVisible, deltaTime, clarityGainSpeed, lastKnownPositionOverride, minClarity);
			return visibilityStatus;
		}

		private bool CheckValid()
		{
			if (!baseEntity.IsValid() || !targetEntity.IsValid())
			{
				if (AI.logIssues)
				{
					Debug.LogError((object)$"SenseComponent:UpdateVisibility NRE: {baseEntity} {targetEntity}");
				}
				return false;
			}
			return true;
		}

		public void UpdateVisibility(bool newVisibility, float deltaTime, float clarityGainSpeed, Vector3? lastKnownPositionOverride = null, float? minClarity = null)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0124: Unknown result type (might be due to invalid IL or missing references)
			//IL_019e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0236: Unknown result type (might be due to invalid IL or missing references)
			//IL_023b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0248: Unknown result type (might be due to invalid IL or missing references)
			//IL_024d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0285: Unknown result type (might be due to invalid IL or missing references)
			//IL_028a: Unknown result type (might be due to invalid IL or missing references)
			//IL_028c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0291: Unknown result type (might be due to invalid IL or missing references)
			//IL_0293: Unknown result type (might be due to invalid IL or missing references)
			//IL_0297: Unknown result type (might be due to invalid IL or missing references)
			//IL_0265: Unknown result type (might be due to invalid IL or missing references)
			//IL_026a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0273: Unknown result type (might be due to invalid IL or missing references)
			//IL_0278: Unknown result type (might be due to invalid IL or missing references)
			if (!CheckValid())
			{
				return;
			}
			bool isAware = IsAware;
			Vector3 val = lastKnownPosition;
			if (minClarity.HasValue)
			{
				clarity = Mathf.Max(clarity, minClarity.Value);
			}
			else if (clarityGainSpeed > 0f)
			{
				clarity += clarityGainSpeed * (deltaTime / 1f);
			}
			else
			{
				clarity -= deltaTime / 3f;
			}
			clarity = Mathf.Clamp(clarity, 0f, 2f);
			bool flag = clarity >= 1f;
			if (lastKnownPositionOverride.HasValue)
			{
				lastKnownPosition = lastKnownPositionOverride.Value;
				predictedPosition = lastKnownPositionOverride.Value;
			}
			else if (newVisibility && flag)
			{
				lastKnownPosition = ((Component)targetEntity).transform.position;
				predictedPosition = ((Component)targetEntity).transform.position;
			}
			if (timeNotAwareAndVisible < 1f)
			{
				predictedPosition = ((Component)targetEntity).transform.position;
			}
			if (isFirstAware || (!isAware && flag && ShouldBeSurprised(val)))
			{
				lastTimeSurprised = Time.timeAsDouble;
			}
			if (lastTimeSurprised.HasValue && Time.timeAsDouble - lastTimeSurprised.Value > 3.0)
			{
				lastTimeSurprised = null;
			}
			if (!isFirstAware && !isAware && flag && timeNotVisible >= 2f && timeNotVisible < 15f)
			{
				float num = Vector3.Distance(val, lastKnownPosition);
				IsCamping = num < 6f;
			}
			if (newVisibility)
			{
				timeNotVisible = 0f;
				timeVisible += deltaTime;
			}
			else
			{
				timeVisible = 0f;
				timeNotVisible += deltaTime;
				timeAwareAndVisible = 0f;
				timeNotAwareAndVisible += deltaTime;
			}
			if (flag)
			{
				if (newVisibility)
				{
					timeNotAwareAndVisible = 0f;
					timeAwareAndVisible += deltaTime;
				}
				Vector3 val2 = ((Component)targetEntity).transform.forward;
				Vector3 position = ((Component)targetEntity).transform.position;
				if (targetEntity.ToNonNpcPlayer(out var player))
				{
					val2 = player.eyes.HeadForward();
					position = player.eyes.position;
				}
				Vector3 val3 = ((Component)baseEntity).transform.position - position;
				float num2 = Mathf.Acos(Vector3.Dot(val2, ((Vector3)(ref val3)).normalized)) * 57.29578f * 2f;
				bool num3 = num2 < AI.watchedAngle;
				if (num3)
				{
					timeNotWatched = 0f;
					timeWatched += deltaTime;
				}
				else
				{
					timeWatched = 0f;
					timeNotWatched += deltaTime;
				}
				if (num3 && (Object)(object)player != (Object)null && player.modelState.aiming && num2 < AI.aimedAtAngle && !(player.GetHeldEntity() is BaseMelee { canScareAiWhenAimed: false }))
				{
					timeNotAimedAt = 0f;
					timeAimedAt += deltaTime;
				}
				else
				{
					timeAimedAt = 0f;
					timeNotAimedAt += deltaTime;
				}
				isFirstAware = false;
			}
			else
			{
				timeWatched = 0f;
				timeNotWatched += deltaTime;
				timeAimedAt = 0f;
				timeNotAimedAt += deltaTime;
			}
		}

		private bool ShouldBeSurprised(Vector3 previousLastKnownPosition)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			if (timeNotAwareAndVisible <= 4f)
			{
				return false;
			}
			if (Vector3.Angle(((Component)baseEntity).transform.forward, lastKnownPosition - ((Component)baseEntity).transform.position) > 45f)
			{
				return true;
			}
			if (Vector3.Distance(previousLastKnownPosition, lastKnownPosition) > 20f)
			{
				return true;
			}
			return false;
		}
	}

	[SerializeField]
	private Vector3 LongRangeVisionRectangle = new Vector3(6f, 30f, 60f);

	[SerializeField]
	private Cone ShortRangeVisionCone = new Cone(100f, 30f);

	[SerializeField]
	private float touchDistance = 6f;

	[SerializeField]
	private float noiseRangeMultiplier = 1f;

	[SerializeField]
	private float hearingRange = 50f;

	[SerializeField]
	private NPCTeam team;

	public ResettableFloat timeToForgetSightings = new ResettableFloat(30f);

	private const float timeToForgetNoises = 5f;

	private static HashSet<BaseEntity> entitiesUpdatedThisFrame = new HashSet<BaseEntity>();

	[ServerVar]
	public static float minRefreshIntervalSeconds = 0.2f;

	[ServerVar]
	public static float maxRefreshIntervalSeconds = 1f;

	private double? _lastTickTime;

	private double nextRefreshTime;

	private double spawnTime;

	private Dictionary<BaseEntity, double> _alliesWeAreAwareOf = new Dictionary<BaseEntity, double>(3);

	private Dictionary<BaseEntity, VisibilityStatus> entitiesWeAreAwareOf = new Dictionary<BaseEntity, VisibilityStatus>(8);

	public static readonly Dictionary<NpcNoiseIntensity, float> noiseRadii = new Dictionary<NpcNoiseIntensity, float>
	{
		{
			NpcNoiseIntensity.None,
			0f
		},
		{
			NpcNoiseIntensity.Low,
			10f
		},
		{
			NpcNoiseIntensity.Medium,
			20f
		},
		{
			NpcNoiseIntensity.High,
			50f
		}
	};

	private HashSet<NpcNoiseEvent> noises = new HashSet<NpcNoiseEvent>();

	[SerializeField]
	private float foodDetectionRange = 30f;

	private BaseEntity _nearestFood;

	[SerializeField]
	private float fireDetectionRange = 20f;

	[NonSerialized]
	public UnityEvent onFireMelee = new UnityEvent();

	private BaseEntity _nearestFire;

	private double? lastMeleeTime;

	[SerializeField]
	private float TargetingCooldown = 5f;

	[SerializeField]
	private float SwitchTargetToFocusAggressorCooldown = 5f;

	private LockState lockState = new LockState();

	private double? lastTargetTime;

	private double? lastTimeSwitchedTargetToFocusAggressor;

	private BaseEntity _target;

	private Vector3 _targetLkp;

	private bool _targetIsVisible;

	private NPCHumanoidAnimController _clientAnimController;

	private LimitedTurnNavAgent _agent;

	public float RefreshInterval
	{
		get
		{
			if (!ShouldRefreshFast)
			{
				return maxRefreshIntervalSeconds;
			}
			return minRefreshIntervalSeconds;
		}
	}

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	public bool HasPlayerInVicinity { get; private set; }

	public bool ShouldRefreshFast
	{
		get
		{
			if (!HasPlayerInVicinity)
			{
				if ((Object)(object)Target != (Object)null)
				{
					return Target.IsNonNpcPlayer();
				}
				return false;
			}
			return true;
		}
	}

	private bool IsInCombat => base.baseEntity.HasFlag(BaseEntity.Flags.Reserved3);

	private bool ChangedTargetRecently
	{
		get
		{
			if ((Object)(object)Target != (Object)null && lastTargetTime.HasValue)
			{
				return Time.timeAsDouble - lastTargetTime.Value < (double)TargetingCooldown;
			}
			return false;
		}
	}

	private bool SwitchedTargetToFocusAggressorRecently
	{
		get
		{
			if ((Object)(object)Target != (Object)null && lastTimeSwitchedTargetToFocusAggressor.HasValue)
			{
				return Time.timeAsDouble - lastTimeSwitchedTargetToFocusAggressor.Value < (double)SwitchTargetToFocusAggressorCooldown;
			}
			return false;
		}
	}

	public BaseEntity Target
	{
		get
		{
			return _target;
		}
		private set
		{
			if (!((Object)(object)_target == (Object)(object)value))
			{
				_target = value;
				if (base.baseEntity.isServer)
				{
					base.baseEntity.SendNetworkUpdate();
				}
			}
		}
	}

	public Vector3 TargetLKP
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return _targetLkp;
		}
		private set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			if (!(_targetLkp == value))
			{
				_targetLkp = value;
				if (base.baseEntity.isServer)
				{
					base.baseEntity.SendNetworkUpdate();
				}
			}
		}
	}

	public bool TargetIsVisible
	{
		get
		{
			return _targetIsVisible;
		}
		private set
		{
			if (value != _targetIsVisible)
			{
				_targetIsVisible = value;
				if (base.baseEntity.isServer)
				{
					base.baseEntity.SendNetworkUpdate();
				}
			}
		}
	}

	private NPCHumanoidAnimController ClientAnimController => _clientAnimController ?? (_clientAnimController = ((Component)base.baseEntity).GetComponentInChildren<NPCHumanoidAnimController>());

	public Vector3 EyePosition
	{
		get
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("SenseComponent:ClientEyePosition", 0);
			try
			{
				if ((Object)(object)ClientAnimController == (Object)null)
				{
					return base.baseEntity.CenterPoint();
				}
				Vector3 val2 = PlayerEyes.EyeOffset;
				if (ClientAnimController.IsCrouching)
				{
					val2 += PlayerEyes.DuckOffset;
				}
				return ((Component)base.baseEntity).transform.position + val2;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	private LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>());

	public Vector3 EyeOffset => EyePosition - ((Component)base.baseEntity).transform.position;

	public void GetPerceivedAllies(List<BaseEntity> allies)
	{
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			foreach (var (baseEntity2, _) in _alliesWeAreAwareOf)
			{
				if (!baseEntity2.IsValid() || (((Object)(object)baseEntity2).Is<BaseCombatEntity>(out BaseCombatEntity castedUnityObject) && castedUnityObject.IsDead()))
				{
					((List<BaseEntity>)(object)val).Add(baseEntity2);
				}
				else
				{
					allies.Add(baseEntity2);
				}
			}
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				_alliesWeAreAwareOf.Remove(item);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetInitialAllies(List<BaseEntity> allies)
	{
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			foreach (var (baseEntity2, num2) in _alliesWeAreAwareOf)
			{
				if (!baseEntity2.IsValid() || (((Object)(object)baseEntity2).Is<BaseCombatEntity>(out BaseCombatEntity castedUnityObject) && castedUnityObject.IsDead()))
				{
					((List<BaseEntity>)(object)val).Add(baseEntity2);
				}
				else if (!(num2 - spawnTime > (double)(maxRefreshIntervalSeconds * 2f)))
				{
					allies.Add(baseEntity2);
				}
			}
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				_alliesWeAreAwareOf.Remove(item);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetEntityLineOfSightTestPoint(BaseEntity entity, bool ignoreCrouch = true)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return GetEntityLineOfSightTestPoint(entity, ((Component)entity).transform.position, ignoreCrouch);
	}

	public static Vector3 GetEntityLineOfSightTestPoint(BaseEntity entity, Vector3 entityPosition, bool ignoreCrouch = true)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (entity.ToNonNpcPlayer(out var player))
		{
			if (ignoreCrouch)
			{
				return entityPosition + PlayerEyes.EyeOffset.y * Vector3.up;
			}
			return entityPosition + (player.eyes.position - ((Component)player).transform.position);
		}
		return entityPosition + ((Bounds)(ref entity.bounds)).size.y * Vector3.up;
	}

	public bool FindTargetLKP(out Vector3 lkp, bool applyHeightOffset = false, bool predict = false, bool ignoreCrouch = true)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!FindTarget(out var target))
		{
			lkp = Vector3.zero;
			return false;
		}
		return FindLKP(target, out lkp, applyHeightOffset, predict, ignoreCrouch);
	}

	public bool FindLKP(BaseEntity entity, out Vector3 lkp, bool applyHeightOffset = false, bool predict = false, bool ignoreCrouch = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (!GetVisibilityStatus(entity, out var status))
		{
			lkp = Vector3.zero;
			return false;
		}
		if (status.IsVisible && status.IsAware)
		{
			lkp = ((Component)entity).transform.position;
		}
		else
		{
			lkp = (predict ? status.predictedPosition : status.lastKnownPosition);
		}
		if (applyHeightOffset)
		{
			lkp = GetEntityLineOfSightTestPoint(entity, lkp, ignoreCrouch);
		}
		return true;
	}

	public bool GetVisibilityStatus(BaseEntity entity, out VisibilityStatus status)
	{
		status = null;
		if (!CanTarget(entity))
		{
			return false;
		}
		if (!entitiesWeAreAwareOf.TryGetValue(entity, out status))
		{
			return false;
		}
		return true;
	}

	public bool Forget(BaseEntity entity)
	{
		if (!entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			return false;
		}
		entitiesWeAreAwareOf.Remove(entity);
		Pool.Free<VisibilityStatus>(ref value);
		return true;
	}

	public bool IsVisible(BaseEntity entity)
	{
		if (!GetVisibilityStatus(entity, out var status))
		{
			return false;
		}
		return status.IsVisible;
	}

	public void GetSeenEntities(List<BaseEntity> perceivedEntities)
	{
		TimeWarning val = TimeWarning.New("SenseComponent:GetSeenEntities", 0);
		try
		{
			foreach (BaseEntity key in entitiesWeAreAwareOf.Keys)
			{
				if (IsVisible(key))
				{
					perceivedEntities.Add(key);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetOncePerceivedEntities(List<BaseEntity> perceivedEntities)
	{
		foreach (BaseEntity key in entitiesWeAreAwareOf.Keys)
		{
			if (GetVisibilityStatus(key, out var _))
			{
				perceivedEntities.Add(key);
			}
		}
	}

	public bool Trace(Vector3 source, Vector3 direction, out RaycastHit hitInfo, int layerMask, string debugCategory = "sight")
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trace", 0);
		try
		{
			return GamePhysics.Trace(new Ray(source, direction), 0f, out hitInfo, ((Vector3)(ref direction)).magnitude, layerMask, (QueryTriggerInteraction)0);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsLineOccluded(Vector3 a, Vector3 b, int layerMask, string debugCategory = "sight")
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsLineOccluded", 0);
		try
		{
			RaycastHit hitInfo;
			return Trace(a, b - a, out hitInfo, layerMask, debugCategory);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool CanSeeFromAt(Vector3 potentialLocation, Vector3 targetLocation, string debugCategory = "sight")
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(Vector3Ex.NormalizeXZ(targetLocation - potentialLocation), Vector3.up) * 0.5f * 2f;
		if (IsLineOccluded(potentialLocation, targetLocation + val, 1218519041, debugCategory))
		{
			return !IsLineOccluded(potentialLocation, targetLocation - val, 1218519041, debugCategory);
		}
		return true;
	}

	public bool CanBeSeenAtFrom(Vector3 potentialLocation, Vector3 targetLocation, string debugCategory = "sight")
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(Vector3Ex.NormalizeXZ(targetLocation - potentialLocation), Vector3.up) * 0.5f * 2f;
		if (IsLineOccluded(targetLocation, potentialLocation + val, 1218519041, debugCategory))
		{
			return !IsLineOccluded(targetLocation, potentialLocation - val, 1218519041, debugCategory);
		}
		return true;
	}

	public override void InitShared()
	{
		base.InitShared();
		spawnTime = Time.timeAsDouble;
	}

	public override void Hurt(HitInfo hitInfo)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:Hurt", 0);
		try
		{
			BaseEntity initiator = hitInfo.Initiator;
			if (CanTarget(initiator))
			{
				Vector3 entityPositionGuess = ((Component)initiator).transform.position + Quaternion.AngleAxis(Random.Range(0f, 360f), Vector3.up) * Vector3.forward * 5f;
				SimulateSighting(initiator, entityPositionGuess);
				if ((Object)(object)Target == (Object)null)
				{
					TrySetTarget(initiator, bypassCooldown: false);
				}
				else if ((Object)(object)Target != (Object)(object)initiator && !SwitchedTargetToFocusAggressorRecently && Vector3.Distance(((Component)base.baseEntity).transform.position, ((Component)initiator).transform.position) < 50f && TrySetTarget(initiator))
				{
					lastTimeSwitchedTargetToFocusAggressor = Time.timeAsDouble;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void SimulateSighting(BaseEntity entity, Vector3 entityPositionGuess)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			if (!value.IsVisible || !value.IsAware)
			{
				value.UpdateVisibility(newVisibility: false, 0.01f, 0f, entityPositionGuess, 1f);
			}
		}
		else
		{
			VisibilityStatus fromPool = VisibilityStatus.GetFromPool(base.baseEntity, entity, isVisible: false, 0.01f, 0f, entityPositionGuess, 1f);
			entitiesWeAreAwareOf.Add(entity, fromPool);
		}
	}

	public void Tick()
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:Tick", 0);
		try
		{
			double timeAsDouble = Time.timeAsDouble;
			if (timeAsDouble < nextRefreshTime)
			{
				return;
			}
			float deltaTime = (float)(timeAsDouble - LastTickTime);
			LastTickTime = timeAsDouble;
			HasPlayerInVicinity = false;
			entitiesUpdatedThisFrame.Clear();
			TimeWarning val2 = TimeWarning.New("SenseComponent:Tick:ProcessEntities", 0);
			try
			{
				PooledList<BaseEntity> val3 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					GetModifiedSenses(null, out var _, out var _, out var _, out var modLongVisionRectangle);
					BaseEntity.Query.Server.GetPlayersAndBrainsInSphere(((Component)base.baseEntity).transform.position, modLongVisionRectangle.z, (List<BaseEntity>)(object)val3, BaseEntity.Query.DistanceCheckType.None);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val3)
					{
						if (!((Object)(object)item == (Object)(object)base.baseEntity))
						{
							if (item.IsNonNpcPlayer())
							{
								HasPlayerInVicinity = true;
							}
							if (InSameTeam(item) && !_alliesWeAreAwareOf.ContainsKey(item))
							{
								_alliesWeAreAwareOf.Add(item, timeAsDouble);
							}
							if (CanTarget(item))
							{
								UpdateEntityVisibility(item, deltaTime);
							}
						}
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			TimeWarning val4 = TimeWarning.New("SenseComponent:Tick:RemoveEntities", 0);
			try
			{
				PooledList<BaseEntity> val5 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					foreach (var (baseEntity2, visibilityStatus2) in entitiesWeAreAwareOf)
					{
						if (!CanTarget(baseEntity2))
						{
							((List<BaseEntity>)(object)val5).Add(baseEntity2);
						}
						else if (!visibilityStatus2.IsVisible && visibilityStatus2.timeNotVisible > timeToForgetSightings.Value)
						{
							((List<BaseEntity>)(object)val5).Add(baseEntity2);
						}
						else if (!entitiesUpdatedThisFrame.Contains(baseEntity2))
						{
							if (IsInCombat)
							{
								UpdateEntityVisibility(baseEntity2, deltaTime);
							}
							else if (visibilityStatus2.IsVisible)
							{
								entitiesWeAreAwareOf[baseEntity2].UpdateVisibility(newVisibility: false, deltaTime, 0f, null, null);
							}
						}
					}
					entitiesUpdatedThisFrame.Clear();
					foreach (BaseEntity item2 in (List<BaseEntity>)(object)val5)
					{
						if (Target.IsValid() && (Object)(object)Target == (Object)(object)item2)
						{
							ClearTarget(forget: false);
						}
						Forget(item2);
					}
				}
				finally
				{
					((IDisposable)val5)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
			TickHearing(deltaTime);
			TickFoodDetection(deltaTime);
			TickFireDetection(deltaTime);
			TickTargeting(deltaTime);
			nextRefreshTime = Time.timeAsDouble + (double)RefreshInterval;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void GetModifiedSenses(BaseEntity entity, out float modTouchDistance, out float modHalfAngle, out float modShortVisionRange, out Vector3 modLongVisionRectangle)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		modTouchDistance = touchDistance;
		modHalfAngle = ShortRangeVisionCone.halfAngle;
		modShortVisionRange = ShortRangeVisionCone.range;
		modLongVisionRectangle = LongRangeVisionRectangle;
		if (!((Object)(object)entity != (Object)null) || !entity.ToNonNpcPlayer(out var player))
		{
			return;
		}
		if (((Object)(object)player.GetMountedVehicle()).Is<BaseVehicle>(out BaseVehicle castedUnityObject))
		{
			switch (castedUnityObject.npcVisibilityCategory)
			{
			case BaseVehicle.NpcVisibilityCategory.QuiteObious:
				modTouchDistance = touchDistance * 6f;
				modShortVisionRange = LongRangeVisionRectangle.z;
				return;
			case BaseVehicle.NpcVisibilityCategory.VeryObvious:
				modTouchDistance = LongRangeVisionRectangle.z;
				modShortVisionRange = LongRangeVisionRectangle.z;
				return;
			case BaseVehicle.NpcVisibilityCategory.LikeNormalPlayer:
				return;
			}
			if (AI.logIssues)
			{
				Debug.LogError((object)$"SenseComponent:GetModifiedSenses: Unknown npcVisibilityCategory {castedUnityObject.npcVisibilityCategory} for vehicle {castedUnityObject}");
			}
		}
		else if (player.IsDucked())
		{
			modTouchDistance = ((Bounds)(ref base.baseEntity.bounds)).extents.z * 1.5f;
			modHalfAngle = ShortRangeVisionCone.halfAngle * 0.85f;
			modShortVisionRange = ShortRangeVisionCone.range * 0.5f;
			modLongVisionRectangle = Vector3.Scale(LongRangeVisionRectangle, new Vector3(3f, 0.5f, 0.5f));
		}
		else if (player.IsRunning())
		{
			modTouchDistance = touchDistance * 3f;
			modShortVisionRange = ShortRangeVisionCone.range * 1.3f;
			modLongVisionRectangle = LongRangeVisionRectangle * 1.15f;
		}
	}

	private bool IsInAnyRange(BaseEntity entity, out float clarity)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsInAnyRange", 0);
		try
		{
			Matrix4x4 eyeTransform = GetEyeTransform();
			Vector3 position = ((Matrix4x4)(ref eyeTransform)).GetPosition();
			eyeTransform = GetEyeTransform();
			Vector3 val2 = ((Matrix4x4)(ref eyeTransform)).rotation * Vector3.forward;
			Vector3 val3 = GetEntityLineOfSightTestPoint(entity, ignoreCrouch: false) - position;
			float magnitude = ((Vector3)(ref val3)).magnitude;
			GetModifiedSenses(entity, out var modTouchDistance, out var modHalfAngle, out var modShortVisionRange, out var modLongVisionRectangle);
			clarity = 0f;
			float num = Vector3.Angle(val2, ((Vector3)(ref val3)).normalized);
			if (magnitude < 1.2f)
			{
				clarity = 999f;
			}
			else if (num < modHalfAngle)
			{
				if (magnitude < modShortVisionRange)
				{
					float num2 = Mathx.RemapValClamped(num, modHalfAngle, 0f, 0f, 1f);
					float num3 = Mathx.RemapValClamped(magnitude, modShortVisionRange, touchDistance, 0f, 1f);
					clarity = (num2 + num3) * 0.5f;
				}
				else
				{
					clarity = Mathx.RemapValClamped(magnitude, modLongVisionRectangle.z, modShortVisionRange, 0f, 0.5f);
				}
			}
			else if (magnitude < modTouchDistance)
			{
				clarity = 1f;
				if (entity.ToNonNpcPlayer(out var player))
				{
					if (player.IsRunning())
					{
						clarity = 2f;
					}
					else if (player.IsDucked())
					{
						clarity = 0.5f;
					}
				}
			}
			if (magnitude < modTouchDistance)
			{
				return true;
			}
			if (num < modHalfAngle)
			{
				if (magnitude < modShortVisionRange)
				{
					return true;
				}
				if ((IsInCombat || (TOD_Sky.Instance.IsDay && magnitude < modLongVisionRectangle.z)) && DistToLineYZ(position, val2, ((Component)entity).transform.position) < modLongVisionRectangle.y * 0.5f && DistToLineXZ(position, val2, ((Component)entity).transform.position) < modLongVisionRectangle.x * 0.5f)
				{
					return true;
				}
			}
			clarity = 0f;
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static float DistToLine(Vector3 lineStart, Vector3 lineDir, Vector3 point)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(((Vector3)(ref lineDir)).normalized, point - lineStart);
		return ((Vector3)(ref val)).magnitude;
	}

	private static float DistToLineXZ(Vector3 lineStart, Vector3 lineDir, Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		return DistToLine(Vector3Ex.WithY(lineStart, 0f), Vector3Ex.WithY(lineDir, 0f), Vector3Ex.WithY(point, 0f));
	}

	private static float DistToLineYZ(Vector3 lineStart, Vector3 lineDir, Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		return DistToLine(Vector3Ex.WithX(lineStart, 0f), Vector3Ex.WithX(lineDir, 0f), Vector3Ex.WithX(point, 0f));
	}

	private void UpdateEntityVisibility(BaseEntity entity, float deltaTime)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		float clarity;
		bool flag = IsInAnyRange(entity, out clarity);
		clarity *= 1f / AI.npcReactionTime;
		clarity = Mathf.Max(clarity, 0.001f);
		if (flag && entity.ToNonNpcPlayer(out var player))
		{
			Vector3 entityLineOfSightTestPoint = GetEntityLineOfSightTestPoint(player, ignoreCrouch: false);
			flag = !IsLineOccluded(EyePosition, entityLineOfSightTestPoint, 1218519041);
		}
		if (!flag)
		{
			clarity = 0f;
		}
		if (entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			value.UpdateVisibility(flag, deltaTime, clarity, null, null);
			entitiesUpdatedThisFrame.Add(entity);
		}
		else if (flag)
		{
			VisibilityStatus fromPool = VisibilityStatus.GetFromPool(base.baseEntity, entity, isVisible: true, deltaTime, clarity, null, null);
			entitiesWeAreAwareOf.Add(entity, fromPool);
			entitiesUpdatedThisFrame.Add(entity);
		}
		if ((Object)(object)entity == (Object)(object)Target && entitiesWeAreAwareOf.TryGetValue(entity, out var value2) && FindLKP(entity, out var lkp, applyHeightOffset: true, predict: false, value2.IsAware && value2.IsVisible))
		{
			TargetIsVisible = value2.IsAware && value2.IsVisible;
			TargetLKP = lkp;
		}
	}

	public bool InSameTeam(BaseEntity other)
	{
		if (team != null && ((Object)(object)((Component)other).GetComponent<SenseComponent>()).Is<SenseComponent>(out SenseComponent castedUnityObject) && team == castedUnityObject.team)
		{
			return true;
		}
		return base.baseEntity.InSameNpcTeam(other);
	}

	private void TickHearing(float deltaTime)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickHearing", 0);
		try
		{
			if (noiseRangeMultiplier > 0f)
			{
				PooledList<NpcNoiseEvent> val2 = Pool.Get<PooledList<NpcNoiseEvent>>();
				try
				{
					SingletonComponent<NpcNoiseManager>.Instance.GetNoisesAround(((Component)base.baseEntity).transform.position, hearingRange, (List<NpcNoiseEvent>)(object)val2);
					foreach (NpcNoiseEvent item in (List<NpcNoiseEvent>)(object)val2)
					{
						if (!noises.Contains(item) && !((Object)(object)item.Initiator == (Object)(object)base.baseEntity) && CanTarget(item.Initiator) && !(Time.timeAsDouble - item.EventTime > 5.0))
						{
							if (!noiseRadii.TryGetValue(item.Intensity, out var value))
							{
								Debug.LogError((object)$"Unknown noise intensity: {item.Intensity}");
							}
							else if (!(Vector3.Distance(item.NoisePosition, ((Component)base.baseEntity).transform.position) > Mathf.Min(value * noiseRangeMultiplier, hearingRange)))
							{
								noises.Add(item);
								SimulateSighting(item.Initiator, item.GuessedInitiatorPosition);
							}
						}
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			PooledList<NpcNoiseEvent> val3 = Pool.Get<PooledList<NpcNoiseEvent>>();
			try
			{
				foreach (NpcNoiseEvent noise in noises)
				{
					if (!CanTarget(noise.Initiator) || Time.timeAsDouble - noise.EventTime > 5.0)
					{
						((List<NpcNoiseEvent>)(object)val3).Add(noise);
					}
				}
				foreach (NpcNoiseEvent item2 in (List<NpcNoiseEvent>)(object)val3)
				{
					noises.Remove(item2);
				}
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool FindMostRelevantNoise(out NpcNoiseEvent mostRelevantNoise)
	{
		TimeWarning val = TimeWarning.New("SenseComponent:FindMostRelevantPooledNoise", 0);
		try
		{
			NpcNoiseEvent? npcNoiseEvent = null;
			foreach (NpcNoiseEvent noise in noises)
			{
				if (CanTarget(noise.Initiator) && !(Time.timeAsDouble - noise.EventTime > 5.0) && (!npcNoiseEvent.HasValue || noise.Intensity > npcNoiseEvent.Value.Intensity))
				{
					npcNoiseEvent = noise;
				}
			}
			if (npcNoiseEvent.HasValue)
			{
				mostRelevantNoise = npcNoiseEvent.Value;
				return true;
			}
			mostRelevantNoise = default(NpcNoiseEvent);
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ForgetAllNoises()
	{
		noises.Clear();
	}

	public bool FindFood(out BaseEntity food)
	{
		if (!_nearestFood.IsValid() || _nearestFood.IsDestroyed || !SingletonComponent<NpcFoodManager>.Instance.Contains(_nearestFood))
		{
			food = null;
			return false;
		}
		food = _nearestFood;
		return true;
	}

	private void TickFoodDetection(float deltaTime)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickFoodDetection", 0);
		try
		{
			_nearestFood = null;
			if (foodDetectionRange <= 0f)
			{
				return;
			}
			float num = foodDetectionRange * foodDetectionRange;
			float num2 = float.MaxValue;
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SingletonComponent<NpcFoodManager>.Instance.GetFoodAround(((Component)base.baseEntity).transform.position, foodDetectionRange, (List<BaseEntity>)(object)val2);
				LimitedTurnNavAgent component = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>();
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (!NpcFoodManager.IsFoodImmobile(item) || (item is BaseCorpse baseCorpse && ((Object)(object)((Component)baseCorpse).GetComponent<HeadDispenser>()).Is<HeadDispenser>(out HeadDispenser castedUnityObject) && ((Object)(object)castedUnityObject.SourceEntity.GetEntity()).Is<BaseEntity>(out BaseEntity castedUnityObject2) && castedUnityObject2.InSameNpcTeam(base.baseEntity)))
					{
						continue;
					}
					if (!component.IsPositionOnNavmesh(((Component)item).transform.position, out var sample))
					{
						SingletonComponent<NpcFoodManager>.Instance.Remove(item);
						continue;
					}
					sample = ((Component)item).transform.position - ((Component)base.baseEntity).transform.position;
					float sqrMagnitude = ((Vector3)(ref sample)).sqrMagnitude;
					if (sqrMagnitude < num2 && sqrMagnitude < num)
					{
						_nearestFood = item;
						num2 = sqrMagnitude;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool FindFire(out BaseEntity fire)
	{
		if (!_nearestFire.IsValid() || _nearestFire.IsDestroyed || !NpcFireManager.IsOnFire(_nearestFire))
		{
			_nearestFire = null;
		}
		fire = _nearestFire;
		return (Object)(object)fire != (Object)null;
	}

	private void TickFireDetection(float deltaTime)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickFireDetection", 0);
		try
		{
			if (fireDetectionRange <= 0f)
			{
				return;
			}
			if ((Object)(object)Target != (Object)null && SingletonComponent<NpcFireManager>.Instance.DidMeleeWithFireRecently(base.baseEntity, Target, out var meleeTime) && (!lastMeleeTime.HasValue || meleeTime != lastMeleeTime.Value))
			{
				lastMeleeTime = meleeTime;
				onFireMelee.Invoke();
			}
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SingletonComponent<NpcFireManager>.Instance.GetFiresAround(((Component)base.baseEntity).transform.position, fireDetectionRange, (List<BaseEntity>)(object)val2);
				BaseEntity baseEntity = null;
				float num = fireDetectionRange * fireDetectionRange;
				float num2 = float.MaxValue;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					Vector3 val3 = ((Component)item).transform.position - ((Component)base.baseEntity).transform.position;
					float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
					if (sqrMagnitude < num2 && sqrMagnitude < num)
					{
						baseEntity = item;
						num2 = sqrMagnitude;
					}
				}
				if ((Object)(object)baseEntity != (Object)null)
				{
					_nearestFire = baseEntity;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public LockState.LockHandle LockCurrentTarget()
	{
		return lockState.AddLock();
	}

	public bool UnlockTarget(ref LockState.LockHandle handle)
	{
		return lockState.RemoveLock(ref handle);
	}

	public bool CanTarget(BaseEntity entity)
	{
		if (!entity.IsValid())
		{
			return false;
		}
		if (entity.IsTransferProtected())
		{
			return false;
		}
		if (entity.IsDestroyed)
		{
			return false;
		}
		if (!entity.IsNonNpcPlayer() && !entity.IsNpc)
		{
			return false;
		}
		if (entity.IsNpcPlayer())
		{
			return false;
		}
		if (entity is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead())
		{
			return false;
		}
		if (InSameTeam(entity))
		{
			return false;
		}
		if (entity is BasePlayer item)
		{
			if (AI.ignoreplayers)
			{
				return false;
			}
			if (SimpleAIMemory.PlayerIgnoreList.Contains(item))
			{
				return false;
			}
		}
		object obj = Interface.CallHook("IOnNpcTarget", (object)this, (object)entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public bool FindTarget(out BaseEntity target)
	{
		if (!CanTarget(Target))
		{
			ClearTarget();
			target = null;
			return false;
		}
		target = Target;
		return (Object)(object)target != (Object)null;
	}

	public bool FindTargetPosition(out Vector3 targetPosition)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!FindTarget(out var target))
		{
			targetPosition = Vector3.zero;
			return false;
		}
		targetPosition = ((Component)target).transform.position;
		return true;
	}

	public bool FindTargetStatus(out VisibilityStatus status)
	{
		status = null;
		if (!FindTarget(out var target))
		{
			return false;
		}
		if (!GetVisibilityStatus(target, out status))
		{
			return false;
		}
		return true;
	}

	public bool TrySetTarget(BaseEntity newTarget, bool bypassCooldown = true)
	{
		if (lockState.IsLocked)
		{
			return false;
		}
		if ((Object)(object)newTarget == (Object)null)
		{
			ClearTarget();
			return true;
		}
		if ((Object)(object)newTarget == (Object)(object)Target)
		{
			return true;
		}
		if (!CanTarget(newTarget))
		{
			return false;
		}
		if ((Object)(object)Target != (Object)null && !bypassCooldown && ChangedTargetRecently)
		{
			return false;
		}
		lastTargetTime = Time.timeAsDouble;
		Target = newTarget;
		return true;
	}

	public void ClearTarget(bool forget = true)
	{
		if (Target.IsValid())
		{
			if (forget)
			{
				Forget(Target);
			}
			lastTargetTime = null;
			Target = null;
		}
	}

	private void TickTargeting(float deltaTime)
	{
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickTargeting", 0);
		try
		{
			if ((Object)(object)Target != (Object)null && !CanTarget(Target))
			{
				ClearTarget();
			}
			if (((Object)(object)Target != (Object)null && SwitchedTargetToFocusAggressorRecently) || ((Object)(object)Target != (Object)null && ChangedTargetRecently))
			{
				return;
			}
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				GetOncePerceivedEntities((List<BaseEntity>)(object)val2);
				if (((List<BaseEntity>)(object)val2).Count == 0)
				{
					return;
				}
				BaseEntity baseEntity = null;
				float num = float.NegativeInfinity;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (GetVisibilityStatus(item, out var status) && status.IsAware && FindLKP(item, out var lkp, applyHeightOffset: false, predict: true))
					{
						float num2 = 0f;
						float num3 = base.baseEntity.Distance(lkp);
						if (status.IsVisible && num3 < 3f)
						{
							num2 += 1000f;
						}
						num2 += Mathx.RemapValClamped(status.timeNotVisible, 0f, 10f, 1f, 0f) * 100f;
						num2 += Mathx.RemapValClamped(num3, 0f, 50f, 1f, 0f);
						if (num2 > num)
						{
							num = num2;
							baseEntity = item;
						}
					}
				}
				if ((Object)(object)baseEntity != (Object)null)
				{
					TrySetTarget(baseEntity, bypassCooldown: false);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void SaveComponent(BaseNetworkable.SaveInfo info)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		base.SaveComponent(info);
		if (base.baseEntity.isServer && !info.forDisk)
		{
			info.msg.npcTargetState = Pool.Get<NPCTargetState>();
			info.msg.npcTargetState.targetId = (NetworkableId)(((Object)(object)Target != (Object)null) ? Target.net.ID : default(NetworkableId));
			info.msg.npcTargetState.targetLkp = _targetLkp;
			info.msg.npcTargetState.targetIsVisible = _targetIsVisible;
		}
	}

	private Matrix4x4 GetEyeTransform()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:GetEyeTransform", 0);
		try
		{
			Vector3 eyePosition = EyePosition;
			Quaternion val2 = ((Component)base.baseEntity).transform.rotation;
			if ((Object)(object)Target != (Object)null && !Agent.IsSprinting && !Agent.overrideDirection.HasValue)
			{
				val2 = Quaternion.LookRotation(TargetLKP - eyePosition, Vector3.up);
				val2 = Clamp(((Component)base.baseEntity).transform.rotation, val2, 90f);
			}
			return Matrix4x4.TRS(eyePosition, val2, Vector3.one);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static Quaternion Clamp(Quaternion originalForward, Quaternion targetRotation, float maxAngle)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		float num = Quaternion.Angle(originalForward, targetRotation);
		if (num > maxAngle)
		{
			float num2 = maxAngle / num;
			return Quaternion.Slerp(originalForward, targetRotation, num2);
		}
		return targetRotation;
	}
}


using System;

[Serializable]
public struct Cone
{
	public float halfAngle;

	public float range;

	public Cone(float halfAngle = 80f, float range = 10f)
	{
		this.halfAngle = halfAngle;
		this.range = range;
	}
}


using ConVar;
using Facepunch;
using UnityEngine;

public class VisibilityStatus : IPooled
{
	private const float maxPredictionTime = 1f;

	private bool isFirstAware;

	private BaseEntity baseEntity;

	private BaseEntity targetEntity;

	public Vector3 lastKnownPosition;

	public Vector3 predictedPosition;

	private const float maxClarity = 2f;

	private const float waterCheckInterval = 1f;

	private double? lastTimeInWaterUpdated;

	private double? lastTimeSurprised;

	public float clarity { get; private set; }

	public bool IsAware => clarity >= 1f;

	public float Accuracy
	{
		get
		{
			if (!IsAware)
			{
				return 0f;
			}
			return Mathx.RemapValClamped(clarity, 1f, 2f, 0f, 1f);
		}
	}

	public float timeVisible { get; private set; }

	public float timeNotVisible { get; private set; }

	public bool IsVisible => timeVisible > 0f;

	public float timeAwareAndVisible { get; private set; }

	public float timeNotAwareAndVisible { get; private set; }

	public float timeWatched { get; private set; }

	public float timeNotWatched { get; private set; }

	public float timeAimedAt { get; private set; }

	public float timeNotAimedAt { get; private set; }

	public WaterLevel.WaterInfo? lastWaterInfo { get; private set; }

	public bool isInWaterCached
	{
		get
		{
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			if (!targetEntity.ToNonNpcPlayer(out var player))
			{
				return false;
			}
			if (!lastWaterInfo.HasValue || !lastTimeInWaterUpdated.HasValue || Time.timeAsDouble - lastTimeInWaterUpdated > 1.0)
			{
				BaseMountable castedUnityObject;
				Vector3 val = (((Object)(object)player.GetMounted()).Is<BaseMountable>(out castedUnityObject) ? (Vector3.down * 0.5f) : Vector3.zero);
				lastWaterInfo = WaterLevel.GetWaterInfo(((Component)targetEntity).transform.position + val, waves: false, volumes: false);
				lastTimeInWaterUpdated = Time.timeAsDouble;
			}
			return lastWaterInfo.Value.currentDepth >= 0.3f;
		}
	}

	public bool IsCamping { get; private set; }

	public bool TryConsumeSurprise()
	{
		if (!lastTimeSurprised.HasValue)
		{
			return false;
		}
		lastTimeSurprised = null;
		return true;
	}

	private void Reset()
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		isFirstAware = true;
		targetEntity = null;
		baseEntity = null;
		timeAwareAndVisible = 0f;
		timeNotAwareAndVisible = 100f;
		timeWatched = 0f;
		timeNotWatched = 100f;
		timeAimedAt = 0f;
		timeNotAimedAt = 100f;
		timeVisible = 0f;
		timeNotVisible = 100f;
		lastKnownPosition = Vector3.zero;
		predictedPosition = Vector3.zero;
		lastWaterInfo = null;
		lastTimeInWaterUpdated = null;
		lastTimeSurprised = null;
		IsCamping = false;
		clarity = 0f;
	}

	public void EnterPool()
	{
		Reset();
	}

	public void LeavePool()
	{
		Reset();
	}

	public static VisibilityStatus GetFromPool(BaseEntity baseEntity, BaseEntity targetEntity, bool isVisible, float deltaTime, float clarityGainSpeed, Vector3? lastKnownPositionOverride = null, float? minClarity = null)
	{
		VisibilityStatus visibilityStatus = Pool.Get<VisibilityStatus>();
		visibilityStatus.baseEntity = baseEntity;
		visibilityStatus.targetEntity = targetEntity;
		visibilityStatus.UpdateVisibility(isVisible, deltaTime, clarityGainSpeed, lastKnownPositionOverride, minClarity);
		return visibilityStatus;
	}

	private bool CheckValid()
	{
		if (!baseEntity.IsValid() || !targetEntity.IsValid())
		{
			if (AI.logIssues)
			{
				Debug.LogError((object)$"SenseComponent:UpdateVisibility NRE: {baseEntity} {targetEntity}");
			}
			return false;
		}
		return true;
	}

	public void UpdateVisibility(bool newVisibility, float deltaTime, float clarityGainSpeed, Vector3? lastKnownPositionOverride = null, float? minClarity = null)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckValid())
		{
			return;
		}
		bool isAware = IsAware;
		Vector3 val = lastKnownPosition;
		if (minClarity.HasValue)
		{
			clarity = Mathf.Max(clarity, minClarity.Value);
		}
		else if (clarityGainSpeed > 0f)
		{
			clarity += clarityGainSpeed * (deltaTime / 1f);
		}
		else
		{
			clarity -= deltaTime / 3f;
		}
		clarity = Mathf.Clamp(clarity, 0f, 2f);
		bool flag = clarity >= 1f;
		if (lastKnownPositionOverride.HasValue)
		{
			lastKnownPosition = lastKnownPositionOverride.Value;
			predictedPosition = lastKnownPositionOverride.Value;
		}
		else if (newVisibility && flag)
		{
			lastKnownPosition = ((Component)targetEntity).transform.position;
			predictedPosition = ((Component)targetEntity).transform.position;
		}
		if (timeNotAwareAndVisible < 1f)
		{
			predictedPosition = ((Component)targetEntity).transform.position;
		}
		if (isFirstAware || (!isAware && flag && ShouldBeSurprised(val)))
		{
			lastTimeSurprised = Time.timeAsDouble;
		}
		if (lastTimeSurprised.HasValue && Time.timeAsDouble - lastTimeSurprised.Value > 3.0)
		{
			lastTimeSurprised = null;
		}
		if (!isFirstAware && !isAware && flag && timeNotVisible >= 2f && timeNotVisible < 15f)
		{
			float num = Vector3.Distance(val, lastKnownPosition);
			IsCamping = num < 6f;
		}
		if (newVisibility)
		{
			timeNotVisible = 0f;
			timeVisible += deltaTime;
		}
		else
		{
			timeVisible = 0f;
			timeNotVisible += deltaTime;
			timeAwareAndVisible = 0f;
			timeNotAwareAndVisible += deltaTime;
		}
		if (flag)
		{
			if (newVisibility)
			{
				timeNotAwareAndVisible = 0f;
				timeAwareAndVisible += deltaTime;
			}
			Vector3 val2 = ((Component)targetEntity).transform.forward;
			Vector3 position = ((Component)targetEntity).transform.position;
			if (targetEntity.ToNonNpcPlayer(out var player))
			{
				val2 = player.eyes.HeadForward();
				position = player.eyes.position;
			}
			Vector3 val3 = ((Component)baseEntity).transform.position - position;
			float num2 = Mathf.Acos(Vector3.Dot(val2, ((Vector3)(ref val3)).normalized)) * 57.29578f * 2f;
			bool num3 = num2 < AI.watchedAngle;
			if (num3)
			{
				timeNotWatched = 0f;
				timeWatched += deltaTime;
			}
			else
			{
				timeWatched = 0f;
				timeNotWatched += deltaTime;
			}
			if (num3 && (Object)(object)player != (Object)null && player.modelState.aiming && num2 < AI.aimedAtAngle && !(player.GetHeldEntity() is BaseMelee { canScareAiWhenAimed: false }))
			{
				timeNotAimedAt = 0f;
				timeAimedAt += deltaTime;
			}
			else
			{
				timeAimedAt = 0f;
				timeNotAimedAt += deltaTime;
			}
			isFirstAware = false;
		}
		else
		{
			timeWatched = 0f;
			timeNotWatched += deltaTime;
			timeAimedAt = 0f;
			timeNotAimedAt += deltaTime;
		}
	}

	private bool ShouldBeSurprised(Vector3 previousLastKnownPosition)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (timeNotAwareAndVisible <= 4f)
		{
			return false;
		}
		if (Vector3.Angle(((Component)baseEntity).transform.forward, lastKnownPosition - ((Component)baseEntity).transform.position) > 45f)
		{
			return true;
		}
		if (Vector3.Distance(previousLastKnownPosition, lastKnownPosition) > 20f)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine.Assertions;

public class LockState
{
	public class LockHandle
	{
	}

	private HashSet<LockHandle> locks = new HashSet<LockHandle>();

	public bool IsLocked => locks.Count > 0;

	public LockHandle AddLock()
	{
		LockHandle lockHandle = Pool.Get<LockHandle>();
		locks.Add(lockHandle);
		return lockHandle;
	}

	public bool RemoveLock(ref LockHandle handle)
	{
		if (handle == null)
		{
			return false;
		}
		bool num = locks.Remove(handle);
		Assert.IsTrue(num, "Trying to remove a lock that doesn't exist");
		if (num)
		{
			Pool.FreeUnsafe<LockHandle>(ref handle);
		}
		return num;
	}
}


public class LockHandle
{
}


using UnityEngine;

public static class BaseEntityTargettingExtensions
{
	public static bool InSameNpcTeam(this BaseEntity entity, BaseEntity other)
	{
		if ((Object)(object)entity == (Object)null || (Object)(object)other == (Object)null)
		{
			return false;
		}
		return ((object)entity).GetType() == ((object)other).GetType();
	}

	public static bool IsNonNpcPlayer(this BaseEntity entity)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			return !basePlayer.IsNpc;
		}
		return false;
	}

	public static bool IsNpcPlayer(this BaseEntity entity)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			return basePlayer.IsNpc;
		}
		return false;
	}

	public static bool ToNonNpcPlayer(this BaseEntity entity, out BasePlayer player)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc)
		{
			player = null;
			return false;
		}
		player = basePlayer;
		return true;
	}
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;

public class UI_RustButtonGroup : MonoBehaviour
{
	[Header("Button Group")]
	[SerializeField]
	protected List<RustButton> _buttons = new List<RustButton>();

	[SerializeField]
	protected bool _unpressSiblings;

	[Tooltip("This button will appear 'pressed' at the beginning.")]
	[SerializeField]
	private RustButton _defaultButton;

	[SerializeField]
	private bool _allowToggleOff;

	public List<RustButton> Buttons => _buttons;

	private void Start()
	{
		SetupButtons();
	}

	public void AddListenerToGroup(UnityAction action)
	{
		if (_buttons.Count <= 0)
		{
			Debug.LogError((object)"No Buttons found in group.");
			return;
		}
		foreach (RustButton button in _buttons)
		{
			if (!((Object)(object)button == (Object)null))
			{
				button.OnPressed.AddListener(action);
			}
		}
	}

	public void AddListenerToIndex(int index, UnityAction action)
	{
		if (_buttons.Count <= 0)
		{
			Debug.LogError((object)"No Buttons found in group.");
		}
		else if (_buttons.Count - 1 < index)
		{
			Debug.LogError((object)$"No Buttons found at index {index}.");
		}
		else if ((Object)(object)_buttons[index] == (Object)null)
		{
			Debug.LogError((object)$"Button at index {index} is null.");
		}
		else
		{
			_buttons[index].OnPressed.AddListener(action);
		}
	}

	public void EnableButton(int index)
	{
		if (_buttons.Count <= index)
		{
			Debug.LogError((object)$"Button with index {index} doesn't exist.");
		}
		else
		{
			_buttons[index].SetToggleTrue(true);
		}
	}

	protected virtual void SetupButtons()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Expected O, but got Unknown
		if (_buttons.Count <= 0)
		{
			Debug.LogError((object)"No Buttons found in group.");
			return;
		}
		foreach (RustButton button in _buttons)
		{
			if ((Object)(object)button == (Object)null)
			{
				continue;
			}
			if ((Object)(object)_defaultButton != (Object)null && (Object)(object)button == (Object)(object)_defaultButton)
			{
				button.PreventToggleOff = false;
				button.SetToggleTrue(true);
			}
			if (!_unpressSiblings)
			{
				continue;
			}
			button.OnPressed.AddListener((UnityAction)delegate
			{
				if (!_allowToggleOff)
				{
					button.PreventToggleOff = true;
				}
				UnpressSiblings(button);
			});
		}
	}

	public void UnpressSiblings(RustButton thisButton)
	{
		foreach (RustButton button in _buttons)
		{
			if (!((Object)(object)thisButton == (Object)(object)button) && !((Object)(object)button == (Object)null))
			{
				button.PreventToggleOff = false;
				button.SetToggleFalse(true);
			}
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.Events;

public class ClockSlider : RustSlider
{
	private bool isUpdatingText;

	public override float Value
	{
		get
		{
			return ((RustSlider)this).Value;
		}
		set
		{
			value = Mathf.Clamp(value, base.MinValue, base.MaxValue);
			if (base.Integer)
			{
				value = Mathf.Round(value);
			}
			if (base.ValueInternal != value)
			{
				base.ValueInternal = value;
			}
			string text = FormatText(value);
			if ((Object)(object)base.NumberInput != (Object)null && !base.NumberInput.IsFocused && base.NumberInput.Text != text)
			{
				UpdateTextNoNotify(text);
			}
			base.SliderCanvas.fillAmount = ((RustSlider)this).ValueNormalized;
			if (base.lastCallbackValue != value)
			{
				base.lastCallbackValue = value;
				((UnityEvent<float>)(object)base.OnChanged)?.Invoke(value);
			}
		}
	}

	protected override void Awake()
	{
		((RustSlider)this).Awake();
		if ((Object)(object)base.NumberInput != (Object)null)
		{
			((UnityEvent<string>)(object)base.NumberInput.OnValueChanged).RemoveListener((UnityAction<string>)TextChanged);
			((UnityEvent<string>)(object)base.NumberInput.OnValueChanged).AddListener((UnityAction<string>)TextChanged);
			((UnityEvent<string>)(object)base.NumberInput.OnEndEdit).RemoveListener((UnityAction<string>)OnEndEdit);
			((UnityEvent<string>)(object)base.NumberInput.OnEndEdit).AddListener((UnityAction<string>)OnEndEdit);
		}
	}

	public void OnEndEdit(string text)
	{
		if (isUpdatingText)
		{
			return;
		}
		if (!text.Contains(":"))
		{
			text = ((text.Length == 4) ? text.Insert(2, ":") : ((text.Length == 3) ? text.Insert(1, ":") : ((text.Length != 1) ? "00:00" : ("0" + text + ":00"))));
			UpdateTextNoNotify(text);
		}
		else
		{
			if (text.Length == 3)
			{
				text = text.Insert(3, "00");
			}
			UpdateTextNoNotify(text);
		}
		UpdateValue(text, updateText: true);
	}

	public void TextChanged(string text)
	{
		if (isUpdatingText)
		{
			return;
		}
		int num = -1;
		if (!text.Contains(":"))
		{
			if (text.Length == 2)
			{
				text = text.Insert(2, ":");
				num = 3;
			}
			if (text.Length == 1)
			{
				int.TryParse(text, out var result);
				if (result > 2)
				{
					text = "0" + text + ":";
					num = 3;
				}
			}
			UpdateTextNoNotify(text);
			if (num != -1)
			{
				base.NumberInput.InputField.caretPosition = num;
			}
		}
		UpdateValue(text, updateText: false);
	}

	private void UpdateValue(string text, bool updateText)
	{
		string[] array = text.Split(':');
		if (array.Length != 2 || !int.TryParse(array[0], out var result) || !int.TryParse(array[1], out var result2))
		{
			return;
		}
		result = Mathf.Clamp(result, 0, 23);
		result2 = Mathf.Clamp(result2, 0, 59);
		((RustSlider)this).Value = (float)result + (float)result2 / 60f;
		if (updateText)
		{
			string text2 = FormatText(((RustSlider)this).Value);
			if (base.NumberInput.Text != text2)
			{
				UpdateTextNoNotify(text2);
			}
		}
	}

	private string FormatText(float value)
	{
		int num = Mathf.RoundToInt(value * 60f);
		int num2 = num / 60;
		int num3 = num % 60;
		return $"{num2:D2}:{num3:D2}";
	}

	private void UpdateTextNoNotify(string text)
	{
		isUpdatingText = true;
		base.NumberInput.Text = text;
		isUpdatingText = false;
	}
}


using UnityEngine;

public class MuteListController : UIDialog
{
	public RectTransform ListParent;

	public GameObjectRef UserWidget;

	public SteamFriendsList SearchList;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ReportBug : UIDialog
{
	public GameObject GetInformation;

	public GameObject Finished;

	public RustInput Subject;

	public RustInput Message;

	public RustButton ReportButton;

	public RustButtonGroup Category;

	public RustIcon ProgressIcon;

	public RustText ProgressText;

	public RawImage ScreenshotImage;

	public GameObject ScreenshotRoot;

	public UIBackgroundBlur BlurController;

	public RustButton SubmitButton;

	public GameObject SubmitErrorRoot;

	public RustText CooldownText;

	public RustText ContentMissingText;
}


using Rust.UI;
using UnityEngine;

public class ReportPlayer : UIDialog
{
	public const string BreakServerRulesKey = "break_server_rules";

	public GameObject FindPlayer;

	public GameObject GetInformation;

	public GameObject Finished;

	public GameObject RecentlyReported;

	public Dropdown ReasonDropdown;

	public RustInput Subject;

	public RustInput Message;

	public RustButton ReportButton;

	public SteamUserButton SteamUserButton;

	public RustIcon ProgressIcon;

	public RustText ProgressText;

	public static Option[] ReportReasons = (Option[])(object)new Option[6]
	{
		new Option(new Phrase("report.reason.none", "Select an option"), "none", false, (Icons)61641),
		new Option(new Phrase("report.reason.abuse", "Racism/Sexism/Abusive"), "abusive", false, (Icons)62806),
		new Option(new Phrase("report.reason.cheat", "Cheating"), "cheat", false, (Icons)61531),
		new Option(new Phrase("report.reason.spam", "Spamming"), "spam", false, (Icons)61601),
		new Option(new Phrase("report.reason.name", "Offensive Name"), "name", false, (Icons)63417),
		new Option(new Phrase("report.reason.server_rules", "Breaking Server Rules"), "break_server_rules", false, (Icons)61546)
	};
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class SteamInventoryCrafting : MonoBehaviour
{
	public GameObject Container;

	public ToggleGroup ToggleGroup;

	public Button ConvertToItem;

	public Button DeleteButton;

	public TextMeshProUGUI WoodAmount;

	public TextMeshProUGUI ClothAmount;

	public TextMeshProUGUI MetalAmount;

	public TextMeshProUGUI InfoText;

	public SteamInventoryCrateOpen CraftModal;

	public GameObject CraftingContainer;

	public GameObject CraftingButton;

	public SteamInventoryNewItem NewItemModal;

	public IPlayerItemDefinition ResultItem { get; private set; }

	public Coroutine MarketCoroutine { get; private set; }
}


using Rust.UI;
using TMPro;
using UnityEngine;

public class SteamInventoryCrateOpen : MonoBehaviour
{
	public TextMeshProUGUI Name;

	public TextMeshProUGUI Requirements;

	public TextMeshProUGUI Label;

	public HttpImage IconImage;

	public GameObject ErrorPanel;

	public TextMeshProUGUI ErrorText;

	public GameObject CraftButton;

	public GameObject ProgressPanel;

	public SteamInventoryNewItem NewItemModal;
}


using UnityEngine;

public class SteamInventoryIcon : MonoBehaviour
{
}


using Facepunch.Extend;
using Rust.UI;
using TMPro;
using UnityEngine;

public class SteamInventoryItem : MonoBehaviour
{
	public IPlayerItem Item;

	public HttpImage Image;

	public bool Setup(IPlayerItem item)
	{
		Item = item;
		if (PlayerItemExtensions.GetDefinition(item) == null)
		{
			return false;
		}
		((TMP_Text)((Component)TransformEx.FindChildRecursive(((Component)this).transform, "ItemName")).GetComponent<TextMeshProUGUI>()).text = PlayerItemExtensions.GetDefinition(item).Name;
		return Image.Load(PlayerItemExtensions.GetDefinition(item).IconUrl);
	}
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;

public class SteamInventoryManager : SingletonComponent<SteamInventoryManager>
{
	public GameObject inventoryItemPrefab;

	public GameObject inventoryCanvas;

	public GameObject missingItems;

	public SteamInventoryCrafting CraftControl;

	public List<GameObject> items;

	public GameObject LoadingOverlay;
}


using System.Threading.Tasks;
using Rust.UI;
using UnityEngine;

public class SteamInventoryNewItem : MonoBehaviour
{
	public async Task Open(IPlayerItem item)
	{
		((Component)this).gameObject.SetActive(true);
		((Component)this).GetComponentInChildren<Rust.UI.SteamInventoryItem>().Setup(item);
		while (Object.op_Implicit((Object)(object)this) && ((Component)this).gameObject.activeSelf)
		{
			await Task.Delay(100);
		}
	}
}


using Rust.UI;
using UnityEngine;

public class ServerAdminConvarInfo : MonoBehaviour
{
	public RustText InfoName;

	public RustText InfoValue;

	public RustInput VariableInput;

	public Tooltip TooltipComponent;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminPlayerEntry : MonoBehaviour
{
	public RustText PlayerName;

	public RustText Ping;

	public RustButton Button;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminPlayerId : MonoBehaviour
{
	public RustText PlayerName;

	public RustText PlayerId;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminPlayerInfo : MonoBehaviour
{
	public RustText PlayerName;

	public RustText SteamID;

	public RustText OwnerSteamID;

	public RustText Ping;

	public RustText Address;

	public RustText ConnectedTime;

	public RustText ViolationLevel;

	public RustText Health;

	public RustInput KickReasonInput;

	public RustInput BanReasonInput;

	public RustButton SpectateButton;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminServerInfo : MonoBehaviour
{
	public RustText InfoName;

	public RustText InfoValue;
}


using UnityEngine;

public class ServerAdminUGCEntry : MonoBehaviour
{
}


using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;

public class ServerAdminUGCEntryAudio : ServerAdminUGCEntry
{
	public AudioSource AudioSpeaker;

	public RustText DurationText;

	public RustSlider ProgressSlider;

	public RustIcon PlayIcon;
}


using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;
using UnityEngine.UI;

public class ServerAdminUGCEntryImage : ServerAdminUGCEntry
{
	public RawImage Image;

	public RectTransform Backing;

	public GameObject MultiImageRoot;

	public RustText ImageIndex;

	public Vector2 OriginalImageSize;
}


using Rust.UI.ServerAdmin;
using UnityEngine;

public class ServerAdminUGCEntryPattern : ServerAdminUGCEntry
{
	public GameObjectRef StarPrefab;

	public RectTransform StarRoot;
}


using Rust.UI.ServerAdmin;
using UnityEngine;
using UnityEngine.UI;

public class ServerAdminUGCEntrySculpture : ServerAdminUGCEntry
{
	public Camera Camera;

	public Material MaterialToUse;

	public RawImage Target;
}


using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;

public class ServerAdminUGCEntryStub : MonoBehaviour
{
	public ServerAdminUGCEntryAudio AudioWidget;

	public ServerAdminUGCEntryImage ImageWidget;

	public ServerAdminUGCEntryPattern PatternWidget;

	public ServerAdminUGCEntryVendingMachine VendingWidget;

	public ServerAdminUGCEntrySculpture SculptureWidget;

	public RustText PrefabName;

	public RustButton HistoryButton;

	public ServerAdminPlayerId[] HistoryIds = new ServerAdminPlayerId[0];
}


using Rust.UI;
using Rust.UI.ServerAdmin;

public class ServerAdminUGCEntryVendingMachine : ServerAdminUGCEntry
{
	public RustText NameLabel;
}


using Facepunch;
using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;
using UnityEngine.UI;

public class ServerAdminUI : SingletonComponent<ServerAdminUI>
{
	public GameObjectRef PlayerEntry;

	public RectTransform PlayerInfoParent;

	public RustText PlayerCount;

	public RustInput PlayerNameFilter;

	public GameObjectRef ServerInfoEntry;

	public RectTransform ServerInfoParent;

	public GameObjectRef ConvarInfoEntry;

	public GameObjectRef ConvarInfoLongEntry;

	public RectTransform ConvarInfoParent;

	public ServerAdminPlayerInfo PlayerInfo;

	public RustInput UgcNameFilter;

	public GameObjectRef ImageEntry;

	public GameObjectRef PatternEntry;

	public GameObjectRef SoundEntry;

	public RustButton ShowWantedPostersButton;

	public VirtualScroll UgcVirtualScroll;

	public GameObject ExpandedUgcRoot;

	public RawImage ExpandedImage;

	public RectTransform ExpandedImageBacking;
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(Toggle))]
internal class ForceWeather : MonoBehaviour
{
	private Toggle component;

	public bool Rain;

	public bool Fog;

	public bool Wind;

	public bool Clouds;

	public void OnEnable()
	{
		component = ((Component)this).GetComponent<Toggle>();
	}

	public void Update()
	{
		if (!((Object)(object)SingletonComponent<Climate>.Instance == (Object)null))
		{
			if (Rain)
			{
				SingletonComponent<Climate>.Instance.Overrides.Rain = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Rain, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
			if (Fog)
			{
				SingletonComponent<Climate>.Instance.Overrides.Fog = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Fog, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
			if (Wind)
			{
				SingletonComponent<Climate>.Instance.Overrides.Wind = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Wind, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
			if (Clouds)
			{
				SingletonComponent<Climate>.Instance.Overrides.Clouds = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Clouds, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Development.Attributes;
using Rust.UI.MainMenu;
using UnityEngine;

[ResetStaticFields]
public class UI_MenuManager : SingletonComponent<UI_MenuManager>
{
	[SerializeField]
	private UI_Popup _genericPopupPrefab;

	[SerializeField]
	private Transform _genericPopupParent;

	[Header("Drops")]
	[SerializeField]
	private UI_DropsController _dropsController;

	[SerializeField]
	[Header("Background Image Settings")]
	private CanvasGroup _homeVideoOverlay;

	[SerializeField]
	private float _homeVideoOverlayAlpha = 1f;

	[SerializeField]
	private float _otherPageVideoOverlayAlpha = 0.98f;

	[SerializeField]
	private CanvasGroup _pageBackgroundOverlay;

	[SerializeField]
	private float _pageBackgroundOverlayAlpha = 0.98f;

	public static Action OnOpenStateChanged;

	private static bool _isOpen = true;

	public List<GameObject> HideInMenu = new List<GameObject>();

	public List<GameObject> HideInGame = new List<GameObject>();

	private UI_MenuNavigationGroup _navGroup;

	public Transform GenericPopupParent => _genericPopupParent;

	public static bool IsOpen => _isOpen;
}


using System;
using Rust.UI.MainMenu;
using UnityEngine;

[Serializable]
public class UI_NavigationEntry
{
	public string Path;

	public GameObject Reference;

	[NonSerialized]
	public UI_Page Page;

	public void Hide()
	{
		if (CheckReference() && (Object)(object)Page != (Object)null)
		{
			Page.Close();
		}
	}

	public void Show()
	{
		if (CheckReference() && (Object)(object)Page != (Object)null)
		{
			Page.Open();
		}
	}

	private bool CheckReference()
	{
		if ((Object)(object)Reference == (Object)null)
		{
			Debug.LogError((object)("Navigation Entry '" + Path + "' doesn't have a valid reference."));
			return false;
		}
		return true;
	}
}


using Rust.UI.MainMenu;

public abstract class UI_Page : UI_Window
{
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_RegisterNavigation : MonoBehaviour
{
	public UI_NavigationEntry NavigationEntry;

	public void Setup()
	{
		if (NavigationEntry != null)
		{
			SetupEntry();
		}
	}

	private void SetupEntry()
	{
		UI_Page page = default(UI_Page);
		if (!((Object)(object)NavigationEntry.Reference == (Object)null) && NavigationEntry.Reference.TryGetComponent<UI_Page>(ref page))
		{
			NavigationEntry.Page = page;
		}
	}
}


using UnityEngine;

public class UI_DemoWindowButton : MonoBehaviour
{
}


using UnityEngine;

public class UI_DropsController : FacepunchBehaviour
{
	[SerializeField]
	private GameObject _dropPrefab;

	[SerializeField]
	private Transform _dropsParent;

	[ClientVar(Saved = true)]
	public static bool show_placeholder_drop_data;

	private const int MAX_DROPS = 3;
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UI_Hero_InfoBox : FacepunchBehaviour
{
	[Header("References")]
	[SerializeField]
	protected RustText _title;

	[SerializeField]
	protected RustText _subtitle;

	[SerializeField]
	protected RustText _tag;

	[SerializeField]
	protected CoverImage _coverImage;

	[SerializeField]
	protected RustButton _button;

	[SerializeField]
	protected FlexTransition _hoverFlex;

	[SerializeField]
	protected Image _blackout;

	[Header("Settings")]
	[SerializeField]
	private Phrase _titlePhrase;

	[SerializeField]
	private Phrase _subtitlePhrase;

	[SerializeField]
	protected Texture _image;

	[SerializeField]
	protected bool _internalLink;

	[SerializeField]
	protected string _linkUrl;
}


using Rust.UI;
using UnityEngine;

public class UI_PatchInfo : FacepunchBehaviour
{
	[SerializeField]
	private RustText _title;

	[SerializeField]
	private RustText _description;

	[SerializeField]
	private RustText _date;

	[SerializeField]
	private RustButton _readMoreButton;

	[SerializeField]
	private RustButton _changelogButton;

	[SerializeField]
	private GameObject _devlogTag;
}


using System.Collections.Generic;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_Hero_QuickJoin : UI_Hero_InfoBox
{
	[SerializeField]
	private List<UI_ServerEntry> _quickJoinEntries = new List<UI_ServerEntry>();
}


using Rust.UI;
using UnityEngine;

public class UI_Hero_QuickJoin_Entry : FacepunchBehaviour
{
	[SerializeField]
	private RustText _serverTitle;

	[SerializeField]
	private RustText _lastPlayed;

	[SerializeField]
	private RustButton _button;
}


using System.Collections.Generic;
using Facepunch.Flexbox;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class UI_Hero_Store : UI_Hero_InfoBox
{
	[Header("Hero Store")]
	[SerializeField]
	private VideoPlayer _video;

	[SerializeField]
	private GameObject _titleContainer;

	[SerializeField]
	private FlexTransition _loadingFlex;

	[SerializeField]
	private CanvasGroup _loadingGroup;

	[SerializeField]
	private RawImage _videoImage;

	[SerializeField]
	private List<Image> _progressBars;

	[SerializeField]
	private List<Image> _progressBarHolders;

	[Header("On Hover Animation")]
	[SerializeField]
	private CanvasGroup _menuBlurGroup;

	[SerializeField]
	private GameObject _expandButton;

	[SerializeField]
	private GameObject _viewInStoreButton;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_HomePage : UI_Page
{
	[SerializeField]
	private UI_Hero_QuickJoin _quickJoin;

	[SerializeField]
	private UI_Hero_Store _storeHero;
}


using Rust.UI;
using UnityEngine;

public class UI_NotificationEntry : MonoBehaviour
{
	[Header("Icons")]
	[SerializeField]
	private RustIcon _basicIcon;

	[SerializeField]
	private RustIcon _standardIcon;

	[SerializeField]
	private RustIcon _banIcon;

	[SerializeField]
	private RustIcon _warningIcon;

	[SerializeField]
	[Header("UI Elements")]
	private GameObject _linkIcon;

	[SerializeField]
	private RustButton _linkButton;

	[SerializeField]
	private RustText _notificationText;
}


public enum NotificationType
{
	Basic,
	Standard,
	Warning,
	Ban
}


using System;
using Rust.UI.MainMenu;

[Serializable]
public struct NotificationData
{
	public NotificationType NotificationType;

	public string NotificationText;

	public string NotificationLink;

	public bool IsInternal;

	public Phrase Phrase;

	public bool HasSeen;

	public int? Id;

	public object[] PhraseArguments;

	public bool HasLink => !string.IsNullOrEmpty(NotificationLink);

	public NotificationData(NotificationType type, string text, string link = "", bool isInternal = true, Phrase phrase = null, bool hasSeen = false, int? id = null, params object[] arguments)
	{
		NotificationType = type;
		NotificationText = text;
		NotificationLink = link;
		IsInternal = isInternal;
		Phrase = phrase;
		HasSeen = hasSeen;
		Id = id;
		PhraseArguments = arguments;
	}

	public override bool Equals(object obj)
	{
		if (obj is NotificationData notificationData)
		{
			if (NotificationText == notificationData.NotificationText)
			{
				return NotificationLink == notificationData.NotificationLink;
			}
			return false;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (NotificationText?.GetHashCode() ?? 0) + (NotificationLink?.GetHashCode() ?? 0);
	}
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_Notifications : UI_Window
{
	[Header("Prefab & Container")]
	[SerializeField]
	private GameObject _entryPrefab;

	[SerializeField]
	private RectTransform _contentRoot;

	[SerializeField]
	private GameObject _noNotifications;

	[SerializeField]
	private GameObject _circle;

	[SerializeField]
	private StyleAsset _regularStyle;

	[SerializeField]
	private StyleAsset _seenStyle;
}


using System;
using Rust.UI.MainMenu;

[Serializable]
internal struct ServerBrowserHeader
{
	public string AscendingSortOrder;

	public string DescendingSortOrder;

	public UI_ServerBrowser_Header Header;
}


using System;

[Serializable]
internal class ServerBrowserCategoryData
{
	public string Name;

	public ServerBrowserCategory Button;

	public ServerBrowserListBase List;
}


using System.Collections.Generic;
using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_ServerBrowserPage : UI_Page
{
	[SerializeField]
	private UI_ServerBrowser_RefreshButton _refreshButton;

	[SerializeField]
	private UI_ConnectModal _connectModal;

	[SerializeField]
	private UI_Window _shockbyteWindow;

	[Header("Categories")]
	[SerializeField]
	private List<ServerBrowserCategoryData> _categories;

	[SerializeField]
	[Header("Headers")]
	private List<ServerBrowserHeader> _headers;

	[SerializeField]
	[Header("Filters")]
	private RustButton _showEmptyToggle;

	[SerializeField]
	private RustButton _showFullToggle;

	[SerializeField]
	private RustButton _prioritisePremiumToggle;

	[SerializeField]
	private RustButton _useCacheToggle;

	[SerializeField]
	private RustInput _searchInput;

	[Header("No Results")]
	[SerializeField]
	private UI_ServerBrowser_NoResults_Controller _noResultsController;

	[Header("Other")]
	[SerializeField]
	private FlexTransition _favouritesButtonAnimation;

	[SerializeField]
	private GameObject _loadingSpinner;
}


using Facepunch.Flexbox;
using UnityEngine;

public class UI_ServerBrowser_Header : MonoBehaviour
{
	public enum HeaderState
	{
		None,
		Ascending,
		Descending
	}

	[Header("References")]
	[SerializeField]
	private FlexTransition _ascendingTransition;

	[SerializeField]
	private FlexTransition _descendingTransition;
}


public enum HeaderState
{
	None,
	Ascending,
	Descending
}


using System.Collections.Generic;
using UnityEngine;

public class UI_ServerBrowser_ModifyComponentsOnCategory : MonoBehaviour
{
	[SerializeField]
	private List<GameObject> _disableComponentsWhileActive = new List<GameObject>();

	[SerializeField]
	private List<GameObject> _enableComponentsWhileActive = new List<GameObject>();
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UI_ServerBrowser_NoResults_Controller : MonoBehaviour
{
	[SerializeField]
	private CanvasGroup _noServersFound;

	[SerializeField]
	private RustButton _button;

	[SerializeField]
	private FlexTransition _transition;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UIElements;

public class UI_ServerBrowser_RefreshButton : RustButton
{
	[SerializeField]
	private UI_LoadingRotate loadingRotate;

	[SerializeField]
	private Image refreshOverview;

	[SerializeField]
	private RustText text;

	private Phrase _refreshPhrase = new Phrase("serverbrowser.refresh", "Refresh");

	private Phrase _cancelPhrase = new Phrase("serverbrowser.cancel", "Cancel");

	public void SetRefreshState(bool state)
	{
		if (!((Object)(object)loadingRotate == (Object)null))
		{
			if (state)
			{
				loadingRotate.ContinuouslyRotate(state: true);
				((RustButton)this).SetToggleVisualOn();
				text.SetPhrase(_cancelPhrase, Array.Empty<object>());
			}
			else
			{
				loadingRotate.Reset();
				loadingRotate.ContinuouslyRotate(state: false);
				((RustButton)this).SetToggleVisualOff();
				text.SetPhrase(_refreshPhrase, Array.Empty<object>());
			}
		}
	}
}


using System;
using Rust.UI;
using TMPro;
using UnityEngine;

public class UI_ServerBrowser_TagModifierButton : RustButton
{
	[Header("Tag Modifier Button")]
	[SerializeField]
	private string _serverTag;

	[SerializeField]
	private RustText _countText;

	private string _tag;

	private LTDescr _countTween;

	public string ServerTag => _serverTag;

	public string CompactTag
	{
		get
		{
			if (_tag == null)
			{
				_tag = ServerTagCompressor.ShortenTag(_serverTag);
			}
			return _tag;
		}
	}

	public void SetCount(int count)
	{
		if (!((Object)(object)_countText == (Object)null))
		{
			if (_countTween != null)
			{
				LeanTween.cancel(_countTween.id);
			}
			int.TryParse(((TMP_Text)_countText).text, out var result);
			_countTween = LeanTween.value(((Component)this).gameObject, (float)result, (float)count, 0.2f).setEaseOutQuad().setOnUpdate((Action<float>)delegate(float val)
			{
				int num = Mathf.RoundToInt(val);
				((TMP_Text)_countText).text = num.ToString();
			});
		}
	}
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UI_ServerEntry : MonoBehaviour
{
	[Header("References")]
	[SerializeField]
	private RustButton _button;

	[SerializeField]
	private RustText _serverNameText;

	[SerializeField]
	private RustText _modeText;

	[SerializeField]
	private RustText _playerCurrentText;

	[SerializeField]
	private RustText _playerMaxText;

	[SerializeField]
	private RustText _pingText;

	[SerializeField]
	private RustText _mapTypeText;

	[SerializeField]
	private ServerBrowserTagList _tagController;

	[SerializeField]
	private GameObject _favouritingParticlesPrefab;

	[Header("References - Last Played")]
	[SerializeField]
	private RustText _lastPlayedText;

	[SerializeField]
	private GameObject _lastPlayedObject;

	[SerializeField]
	[Header("References - Friends")]
	private RustText _friendsText;

	[SerializeField]
	private GameObject _friendsObject;

	[SerializeField]
	private Tooltip _friendsTooltip;

	[Header("References - Queue")]
	[SerializeField]
	private RustText _queueText;

	[SerializeField]
	private GameObject _queueObject;

	[SerializeField]
	[Header("References - Favourites")]
	private RustButton _favouritesButton;

	[SerializeField]
	private FlexTransition _favouritesTransition;

	[SerializeField]
	private RectTransform _favouritesSpawnPoint;

	[Header("References - Styles")]
	[SerializeField]
	private StyleAsset _evenStyle;

	[SerializeField]
	private StyleAsset _oddStyle;

	[SerializeField]
	private StyleAsset _favouriteStyle;

	[Header("Other")]
	[SerializeField]
	private bool _joinOnClick;

	public static Phrase LastJoinedPhrase = (Phrase)(object)new TokenisedPhrase("serverentry.lastplayed.ago", "{0} ago");

	public static Phrase FriendsPhrase = (Phrase)(object)new TokenisedPhrase("serverentry.friends", "{0} friends");
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UI_TabBox : MonoBehaviour
{
	[SerializeField]
	private bool _autoClose = true;

	[SerializeField]
	private RustText _filterEnabledText;

	[SerializeField]
	private RustButton _collapseButton;

	[SerializeField]
	private Image _spacerImage;

	public static readonly Phrase FiltersPhrase = new Phrase("tabbox.filters", "{0} filters");

	public static readonly Phrase EnabledPhrase = new Phrase("tabbox.filters.enabled", "enabled");

	public static readonly Phrase DisabledPhrase = new Phrase("tabbox.filters.disabled", "disabled");
}


using System;
using System.Collections.Generic;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_TagController : MonoBehaviour
{
	[Serializable]
	public class TagData
	{
		public string TagName;

		public GameObject TagObject;
	}

	[SerializeField]
	private List<TagData> _tags = new List<TagData>();

	public void ClearTags()
	{
		foreach (TagData tag in _tags)
		{
			if (tag.TagObject.activeInHierarchy)
			{
				tag.TagObject.SetActive(false);
			}
		}
	}

	public void EnableTag(string tagName)
	{
		foreach (TagData tag in _tags)
		{
			if (tag.TagName == tagName && !tag.TagObject.activeInHierarchy)
			{
				tag.TagObject.SetActive(true);
				return;
			}
		}
		Debug.LogError((object)("Tag '" + tagName + "' not found in the list."));
	}
}


using System;
using UnityEngine;

[Serializable]
public class TagData
{
	public string TagName;

	public GameObject TagObject;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SessionPage : UI_Page
{
	public static UI_SessionPage Instance;

	public HttpImage serverLogoImage;

	[SerializeField]
	private RustText _topServerName;

	[SerializeField]
	private GameObject _rustPlusBanner;

	[SerializeField]
	private GameObject _connectToServerButton;

	[SerializeField]
	private GameObject _quitButton;

	[SerializeField]
	private GameObject _quitDemo;

	[SerializeField]
	private GameObject _quitTutorial;

	[SerializeField]
	private RustButton _rustPlusButton;

	[SerializeField]
	private RustButton _tutorialButton;

	[SerializeField]
	private UI_ConnectModal _connectModal;

	[SerializeField]
	private CompanionSetupScreen _setupScreen;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_ConnectModal : UI_Window
{
	[Header("References")]
	[SerializeField]
	private RustText _title;

	[SerializeField]
	private RustText _description;

	[SerializeField]
	private HttpImage _headerImage;

	[SerializeField]
	private GameObject _headerImageLoading;

	[SerializeField]
	private ServerBrowserTagList _tagController;

	[SerializeField]
	private RustText _mapTypeText;

	[SerializeField]
	private RustButton _websiteButton;

	[SerializeField]
	private Tooltip _websiteTooltip;

	[SerializeField]
	private GameObject _descriptionLoading;

	[SerializeField]
	private GameObject _connectToServerButton;

	[SerializeField]
	private GameObject _needsPremiumButton;

	[SerializeField]
	private GameObject _mapButton;

	[SerializeField]
	private UI_ServerMap _map;

	[Header("References - Friends")]
	[SerializeField]
	private RustText _friendsText;

	[SerializeField]
	private GameObject _friendsObject;

	[SerializeField]
	private Tooltip _friendsTooltip;

	[SerializeField]
	[Header("Info Box References")]
	private RustText _playerCount;

	[SerializeField]
	private GameObject _queuedPlayersObject;

	[SerializeField]
	private RustText _queuedPlayersCount;

	[SerializeField]
	private GameObject _lastPlayedObject;

	[SerializeField]
	private RustText _lastPlayedText;

	[SerializeField]
	private GameObject _wipedObject;

	[SerializeField]
	private RustText _wipedText;

	[SerializeField]
	private ScrollRect _scrollRect;

	[SerializeField]
	private RectMask2D _scrollMask;

	public static Phrase lastPlayedPhrase = new Phrase("connection.modal.lastplayed.ago", "{0} ago");

	public static Phrase serverAgePhrase = new Phrase("connection.modal.serverage.old", "{0} old");

	public static Phrase loadingError = new Phrase("connection.modal.error", "Error loading server");
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
public class UI_FoilShaderMouseFollow : MonoBehaviour
{
	[Header("Foil Shader Settings")]
	[SerializeField]
	private RawImage _rawImage;

	[SerializeField]
	private Image _image;

	[SerializeField]
	private float _rotationSpeed = 10f;

	[SerializeField]
	private float _tiltSensitivity = 3f;

	[SerializeField]
	private float _maxTilt = 10f;

	[Header("Global Settings")]
	[SerializeField]
	private bool _useGlobal;

	[SerializeField]
	[Range(0f, 1f)]
	private float _normalisedMaxGlobalDistance;
}


using UnityEngine;

public class UI_HideTutorialCategory : MonoBehaviour
{
	[SerializeField]
	private GameObject _tutorialCategoryButton;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_InteractionToast : UI_Window
{
	[SerializeField]
	[Header("Interaction Modal")]
	private RustText _text;

	[SerializeField]
	private GameObject _informationPanel;

	[SerializeField]
	private RustText _informationTitle;

	[SerializeField]
	private RustText _informationText;

	[SerializeField]
	private RustButton _firstButton;

	[SerializeField]
	private RustButton _secondButton;

	[SerializeField]
	private RustIcon _firstIcon;

	[SerializeField]
	private RustIcon _secondIcon;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_ServerMap : UI_Window
{
	[SerializeField]
	[Header("References")]
	private HttpImage _httpImage;

	[SerializeField]
	private GameObject _loadingObject;

	[SerializeField]
	private RustButton _gridButton;
}


using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.Video;

public class UI_TutorialModal : UI_Window
{
	[SerializeField]
	private RustButton _acceptButton;

	[SerializeField]
	private List<RustButton> _declineButtons;

	[SerializeField]
	private VideoPlayer _videoPlayer;
}


using System;
using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_MenuNavigationGroup : UI_RustButtonGroup
{
	[Serializable]
	private class TabButton
	{
		public RustButton Button;

		public string Path;
	}

	[Header("Navigation Groups (IGNORE BUTTON GROUPS - Just Add Here)")]
	[SerializeField]
	private List<TabButton> _navigationGroups = new List<TabButton>();
}


using System;

[Serializable]
private class TabButton
{
	public RustButton Button;

	public string Path;
}


public static class UI_Utils
{
	private static Phrase _monthSingularPhrase = new Phrase("time.month", "month");

	private static Phrase _monthsPhrase = new Phrase("time.months", "months");

	private static Phrase _weekSingularPhrase = new Phrase("time.week", "week");

	private static Phrase _weeksPhrase = new Phrase("time.weeks", "weeks");

	private static Phrase _daysSingularPhrase = new Phrase("time.day", "day");

	private static Phrase _daysPhrase = new Phrase("time.days", "days");

	private static Phrase _hourSingularPhrase = new Phrase("time.hour", "hour");

	private static Phrase _hoursPhrase = new Phrase("time.hours", "hours");

	private static Phrase _minuteSingularPhrase = new Phrase("time.minute", "minute");

	private static Phrase _minutesPhrase = new Phrase("time.minutes", "minutes");

	private static Phrase _secondSingularPhrase = new Phrase("time.second", "second");

	private static Phrase _secondsPhrase = new Phrase("time.seconds", "seconds");
}


using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class CompanionSetupScreen : UI_Window
{
	public enum ScreenState
	{
		Loading,
		Error,
		NoServer,
		NotSupported,
		NotInstalled,
		Disabled,
		Enabled,
		ShowHelp
	}

	public const string PairedKey = "companionPaired";

	public GameObject pleaseSignInMessage;

	public GameObject loadingMessage;

	public GameObject errorMessage;

	public GameObject notSupportedMessage;

	public GameObject disabledMessage;

	public GameObject enabledMessage;

	public GameObject refreshButton;

	public GameObject enableButton;

	public GameObject disableButton;

	public GameObject pairButton;

	public RustText serverName;

	public FlexTransition removeFooterTransition;
}


public enum ScreenState
{
	Loading,
	Error,
	NoServer,
	NotSupported,
	NotInstalled,
	Disabled,
	Enabled,
	ShowHelp
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class Hero : SingletonComponent<Hero>
{
	public CanvasGroup CanvasGroup;

	public Video VideoPlayer;

	public RustText TitleText;

	public RustText ButtonText;

	public HttpImage TitleImage;

	[Header("Item Store Links")]
	public RustButton ItemStoreButton;

	public RustButton LimitedTabButton;

	public RustButton GeneralTabButton;
}


using Coffee.UIEffects;
using UnityEngine;

[RequireComponent(typeof(RectTransform))]
public class GradientMouseFollow : MonoBehaviour
{
	[SerializeField]
	private UIGradient gradient;
}


using Development.Attributes;

[ResetStaticFields]
public static class SteamInventoryRecipeIndex
{
}


using System;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SteamInventoryCraftingModal : UI_SteamInventoryItemBaseModal
{
	[Serializable]
	public struct MaterialGroup
	{
		public GameObject GameObject;

		public RustText CountText;

		public Image BackgroundImage;
	}

	[SerializeField]
	private MaterialGroup woodGroup;

	[SerializeField]
	private MaterialGroup metalGroup;

	[SerializeField]
	private MaterialGroup clothGroup;

	[SerializeField]
	[Space]
	private GameObject craftOK;

	[SerializeField]
	private GameObject craftKO;

	[SerializeField]
	private UI_SteamInventoryNewItemModal newItemModal;
}


using System;
using UnityEngine;
using UnityEngine.UI;

[Serializable]
public struct MaterialGroup
{
	public GameObject GameObject;

	public RustText CountText;

	public Image BackgroundImage;
}


using System;
using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SteamInventoryItemBaseModal : UI_Window
{
	[Serializable]
	private struct Tag
	{
		public string Name;

		public GameObject GameObject;
	}

	[SerializeField]
	protected GameObject skinViewerGroup;

	[SerializeField]
	protected GameObject staticIconGroup;

	[Space]
	[SerializeField]
	protected HttpImage iconImage;

	[SerializeField]
	protected RustText nameText;

	[SerializeField]
	protected RustText descText;

	[SerializeField]
	protected RustText itemTypeText;

	[SerializeField]
	private UI_BackgroundAspectRatioFitter background;

	[SerializeField]
	[Header("Marketable Tag")]
	private GameObject marketablePriceGroup;

	[SerializeField]
	private GameObject marketableLockedGroup;

	[SerializeField]
	protected RustText daysLeftText;

	[SerializeField]
	protected RustText priceText;

	[SerializeField]
	private List<Tag> tagDefinitions = new List<Tag>();

	[Header("Gallery")]
	[SerializeField]
	private GameObject gallery;

	[SerializeField]
	private RectTransform galleryItemParent;

	[SerializeField]
	private GameObjectRef galleryItemPrefab;

	[SerializeField]
	private ScrollRect galleryScrollRect;

	[SerializeField]
	private CanvasGroup leftArrow;

	[SerializeField]
	private CanvasGroup rightArrow;

	[Header("Skin Viewer")]
	[SerializeField]
	private CoverImage skinViewerImage;

	[SerializeField]
	private GameObject icon3D;

	[SerializeField]
	private GameObject skinFullscreenButton;

	[SerializeField]
	private GameObject loadingOverlay;

	[SerializeField]
	private Color loadingColor;

	[SerializeField]
	private AnimationCurve loadingCompletePunchCurve;
}


using System;
using UnityEngine;

[Serializable]
private struct Tag
{
	public string Name;

	public GameObject GameObject;
}


using Rust.UI.MainMenu;

public class UI_SteamInventoryNewItemModal : UI_Window
{
	public UI_SteamInventoryItem uiItem;

	private IPlayerItem _item;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SteamInventoryPlayerItemModal : UI_SteamInventoryItemBaseModal
{
	[Header("Breakdown")]
	[SerializeField]
	private GameObject breakdownGroup;

	[SerializeField]
	private GameObject notScrappableGroup;

	[SerializeField]
	protected UI_SteamInventoryCraftingModal.MaterialGroup woodGroup;

	[SerializeField]
	protected UI_SteamInventoryCraftingModal.MaterialGroup metalGroup;

	[SerializeField]
	protected UI_SteamInventoryCraftingModal.MaterialGroup clothGroup;

	[Header("Breakdown Controls")]
	[SerializeField]
	private GameObject breakdownButtonGroup;

	[SerializeField]
	private GameObject cantBreakdownButtonGroup;

	[SerializeField]
	private GameObject deleteButtonGroup;

	[SerializeField]
	private RustText cantBreakdownReasonText;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SteamInventory : UI_Page
{
	public static UI_SteamInventory Instance;

	[SerializeField]
	private FlexVirtualScroll virtualScrollFlex;

	[Space]
	[SerializeField]
	private UI_SteamInventoryCrafting crafting;

	[SerializeField]
	private UI_SteamInventoryItem inventoryItemPrefab;

	[SerializeField]
	private RectTransform inventoryItemParent;

	[Space]
	public GameObject loadingOverlay;

	[SerializeField]
	private UI_StoreTakeover takeovers;

	[SerializeField]
	private RustButton refreshButton;

	[SerializeField]
	private RustInput searchBar;

	public static UI_SteamInventoryCrafting Crafting => Instance?.crafting;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SteamInventoryCrafting : MonoBehaviour
{
	[SerializeField]
	private RustText clothAmountText;

	[SerializeField]
	private RustText woodAmountText;

	[SerializeField]
	private RustText metalAmountText;

	[Space]
	[SerializeField]
	private GameObject craftingLoading;

	[SerializeField]
	private CanvasGroup craftingButtonParent;

	[SerializeField]
	private GameObject craftingButtonPrefab;

	[SerializeField]
	public UI_SteamInventoryNewItemModal newItemModal;

	[SerializeField]
	private UI_SteamInventoryCraftingModal craftingModal;

	[SerializeField]
	[Space]
	private UI_SteamInventoryPlayerItemModal bagOpeningModal;

	[SerializeField]
	private UI_SteamInventoryPlayerItemModal playerItemModal;

	[SerializeField]
	private UI_Popup deleteWarningPopup;

	[SerializeField]
	private UI_Popup craftingWarningPopup;
}


using Rust.UI;
using UnityEngine;

public class UI_SteamInventoryItem : MonoBehaviour
{
	public RustButton button;

	[SerializeField]
	private HttpImage image;

	[SerializeField]
	private GameObject takeoverGroup;

	[SerializeField]
	private CoverImage takeoverImage;

	[SerializeField]
	private RustText nameText;

	[SerializeField]
	private RustText subtitleText;

	[SerializeField]
	private GameObject twitchDropTag;

	public IPlayerItem PlayerItem;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class UI_SettingsGestureButton : UI_SettingsGestureDraggable
{
	[SerializeField]
	private StyleAsset unlockedStyle;

	[SerializeField]
	private StyleAsset lockedStyle;

	[Space]
	[SerializeField]
	private GameObject boundLine;

	[SerializeField]
	private GameObject dragIcon;

	[SerializeField]
	private Image gestureIcon;

	[SerializeField]
	private RustText gestureNameText;

	[Space]
	[SerializeField]
	private RectTransform videoPreview;

	[SerializeField]
	private VideoPlayer videoPlayer;

	[SerializeField]
	private RawImage videoRawTexture;

	[SerializeField]
	[Space]
	private GameObject deleteButton;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public abstract class UI_SettingsGestureDraggable : BaseMonoBehaviour
{
	[SerializeField]
	public RustButton button;

	[SerializeField]
	private GameObject draggedPrefab;

	public GestureConfig gestureConfig { get; private set; }

	public UI_SettingsGestureWheel wheel { get; private set; }
}


using Rust.UI;
using UnityEngine;

public class UI_SettingsGesturePack : MonoBehaviour
{
	[SerializeField]
	private RustText headerText;

	[SerializeField]
	public RectTransform contentParent;

	[SerializeField]
	private GameObject storeButton;

	[SerializeField]
	private GameObject lockIcon;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsGestureWheel : MonoBehaviour
{
	[SerializeField]
	private RustText wheelHeaderText;

	[SerializeField]
	private RustButton leftArrowButton;

	[SerializeField]
	private RustButton rightArrowButton;

	[Space]
	[SerializeField]
	private UI_SettingsGestureWidget[] gestureWidgets;

	[SerializeField]
	private RustText gestureTitleText;

	[SerializeField]
	private RustText gestureDescriptionText;

	[SerializeField]
	private Image gestureIcon;

	[Space]
	[SerializeField]
	private RectTransform wheelCenter;

	[SerializeField]
	private float radius = 100f;

	[SerializeField]
	private float initialAngleOffset;

	[Space]
	[SerializeField]
	private UI_SettingsGestureButton gestureButtonPrefab;

	[Space]
	[SerializeField]
	private RectTransform ownedButtonsParent;

	[SerializeField]
	private RectTransform lockedPacksParent;

	[SerializeField]
	private UI_SettingsGesturePack packPrefab;

	[Space]
	[SerializeField]
	public RectTransform dragAndDropCanvas;

	[SerializeField]
	private CanvasGroup assignOverlay;

	[SerializeField]
	private Canvas buttonListCanvas;

	[SerializeField]
	[Space]
	private GameObject hoveredGestureTexts;

	[SerializeField]
	private GameObject emptyWheelTexts;
}


using LeTai.TrueShadow;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsGestureWidget : UI_SettingsGestureDraggable
{
	[SerializeField]
	private StyleAsset boundStyle;

	[SerializeField]
	private StyleAsset emptyStyle;

	[Space]
	[SerializeField]
	private Image gestureIcon;

	[SerializeField]
	private GameObject emptyIcon;

	[SerializeField]
	private GameObject hoverImage;

	[SerializeField]
	private Canvas canvas;

	[SerializeField]
	private TrueShadow shadow;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class PopulateResolutionDropdown : MonoBehaviour
{
	public UI_SettingsTweakDropdown Dropdown;
}


using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsApplyTweakChanges : MonoBehaviour
{
	public Button ApplyButton;

	public RustButton applyButton;

	public FlexTransition flexTransition;

	public UI_SettingsTweakConvar[] Options;
}


using Rust.UI;
using UnityEngine;

public class UI_SettingsFramerateSlider : MonoBehaviour
{
	public RustSlider slider;

	public RustInput rustInput;
}


using Rust.UI;
using UnityEngine;

public class UI_SettingsKeyBindButton : MonoBehaviour
{
	[HideInInspector]
	public string currentBind;

	public RustButton button;

	public StyleAsset boundStyle;

	public StyleAsset notBoundStyle;

	public RustText text;
}


using UnityEngine;

public abstract class UI_SettingsTweakBase : MonoBehaviour
{
	public Phrase tooltip;

	public Sprite tooltipImage;

	public string tooltipVideoURL;

	[Tooltip("For any clickable URL in the tooltip.")]
	public string tooltipExternalURL;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsTweakColour : UI_SettingsTweakConvar
{
	public Image BackgroundImage;

	public RustButton Opener;

	public RectTransform Dropdown;

	public RectTransform DropdownContainer;

	public GameObject DropdownItemPrefab;

	public AccessibilityColourCollection forColourCollection;

	public AccessibilityMaterialCollection forMaterialCollection;

	public int currentValue;
}


using Rust.UI.MainMenu;
using UnityEngine.Events;

public class UI_SettingsTweakConvar : UI_SettingsTweakBase
{
	public string convarName;

	public bool ApplyImmediatelyOnChange = true;

	public UnityEvent onValueChanged = new UnityEvent();
}


using System;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsTweakDropdown : UI_SettingsTweakConvar
{
	[Serializable]
	public class NameValue
	{
		public string value;

		public Color imageColor;

		public Phrase label;

		public string untranslatedLabel;

		public bool rightToLeft;

		public bool useColorInsteadOfText;
	}

	public RustText Current;

	public Image CurrentColor;

	public RustButton Opener;

	public RectTransform Dropdown;

	public RectTransform DropdownContainer;

	public GameObject DropdownItemPrefab;

	public NameValue[] nameValues;

	public bool forceEnglish;

	[HideInInspector]
	public int currentValue;
}


using System;
using UnityEngine;

[Serializable]
public class NameValue
{
	public string value;

	public Color imageColor;

	public Phrase label;

	public string untranslatedLabel;

	public bool rightToLeft;

	public bool useColorInsteadOfText;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsTweakDropdownItem : MonoBehaviour
{
	public Image Image;

	public RustText Text;

	[Space]
	public StyleAsset DefaultStyle;

	public StyleAsset SelectedStyle;

	public RustButton Button;

	public void SetSelected(bool selected)
	{
		((RustControl)Button).Styles = (selected ? SelectedStyle : DefaultStyle);
		((RustControl)Button).ApplyStyles();
	}
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SettingsTweakKeyBind : UI_SettingsTweakBase
{
	[Space]
	public GameObject blockingCanvas;

	public RustButton button;

	public RustText labelText;

	public UI_SettingsKeyBindButton btnA;

	public UI_SettingsKeyBindButton btnB;

	public CanvasGroup resetButton;

	public string bindString;

	public static bool IsBinding { get; private set; }
}


using Rust.UI.MainMenu;

public class UI_SettingsTweakPresetGraphics : UI_SettingsTweakPresetSelect
{
}


using System;
using Rust.UI.MainMenu;

public class UI_SettingsTweakPresetSelect : UI_SettingsTweakDropdown
{
	[Serializable]
	public struct Presets
	{
		public string[] PresetValues;
	}

	public string StreamingAssetsFilename = "";

	public UI_SettingsTweakConvar[] TargetOptions;

	public string[] AdditionalTargetOptions;

	public Presets[] PresetsArray;

	public int CustomIndex;
}


using System;

[Serializable]
public struct Presets
{
	public string[] PresetValues;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine.Events;

public class UI_SettingsTweakSlider : UI_SettingsTweakConvar
{
	public RustSlider rustSliderControl;

	public RustInput rustInput;

	public bool applyOnMouseUp;

	private TimeSince mouseDown;

	public UnityEvent OnMouseUp;

	private float GetSliderValue()
	{
		return rustSliderControl.Value;
	}
}


using Rust.UI;
using Rust.UI.MainMenu;

public class UI_SettingsTweakToggle : UI_SettingsTweakConvar
{
	public RustButton buttonControl;

	public bool inverse;

	public static string lastConVarChanged;

	public static TimeSince timeSinceLastConVarChange;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_Popup_CrosshairImportExport : UI_Popup
{
	[SerializeField]
	private bool isExport;

	[SerializeField]
	private RustInput inputField;

	[SerializeField]
	private RustText placeHolderTextField;

	[SerializeField]
	private RustText copyButtonTextField;

	[SerializeField]
	private Image inputFieldBackgroundImage;

	[SerializeField]
	private Color defaultBackgroundColor;

	[SerializeField]
	private Color failedBackgroundColor;

	public Phrase placeHolderPhrase;

	public Phrase invalidCodePhrase;

	public Phrase copyCodePhrase;

	public Phrase copiedPhrase;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SafeModeWarning : UI_Popup, IClientComponent
{
	[SerializeField]
	[Space]
	private GameObject yesButton;

	[SerializeField]
	private GameObject timer;

	[SerializeField]
	private RustText timerText;

	[SerializeField]
	private float timeToWait = 5f;
}


using System;
using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_Settings : UI_Page
{
	[Serializable]
	private class SettingTab
	{
		public string name;

		public UI_SettingsTabButton tabButton;

		public GameObject content;

		[ReadOnly]
		public List<SettingEntry> settings;

		public RustButton button => tabButton.button;

		public CanvasGroup canvasGroup => tabButton.canvasGroup;
	}

	private class SettingEntry
	{
		[NonSerialized]
		public SettingTab ownerTab;

		public string convarName;

		public string nameToken;

		public UI_SettingsTweakBase tweakUIBase;

		private CanvasGroup _canvasGroup;

		private RustText _labelText;

		private RustButton _button;

		private string searchIndex;

		public GameObject gameObject
		{
			get
			{
				UI_SettingsTweakBase uI_SettingsTweakBase = tweakUIBase;
				if (uI_SettingsTweakBase == null)
				{
					return null;
				}
				return ((Component)uI_SettingsTweakBase).gameObject;
			}
		}

		public CanvasGroup canvasGroup
		{
			get
			{
				if ((Object)(object)_canvasGroup == (Object)null)
				{
					_canvasGroup = gameObject.GetComponent<CanvasGroup>();
				}
				return _canvasGroup;
			}
		}

		public RustText labelText
		{
			get
			{
				if ((Object)(object)_labelText == (Object)null)
				{
					_labelText = gameObject.GetComponentInChildren<RustText>();
				}
				return _labelText;
			}
		}

		public RustButton button
		{
			get
			{
				if ((Object)(object)_button == (Object)null)
				{
					_button = gameObject.GetComponent<RustButton>();
				}
				return _button;
			}
		}

		public SettingEntry(string convarName, UI_SettingsTweakBase tweakUIBase)
		{
			this.convarName = convarName;
			this.tweakUIBase = tweakUIBase;
		}

		public string GetSettingName()
		{
			return Translate.Get(nameToken, (string)null, false);
		}

		public string GetTooltip()
		{
			return Translate.Get(tweakUIBase.tooltip.token, (string)null, false);
		}

		public void BuildSearchIndex()
		{
			searchIndex = string.Join(" ", GetSettingName(), GetTooltip());
		}

		public bool Matches(string query)
		{
			if (string.IsNullOrWhiteSpace(query))
			{
				return false;
			}
			string[] array = query.Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries);
			foreach (string text in array)
			{
				int startIndex = 0;
				while (true)
				{
					int num = searchIndex.IndexOf(text, startIndex, StringComparison.OrdinalIgnoreCase);
					if (num < 0)
					{
						break;
					}
					if (!RustText.IsInsideTag(searchIndex, num))
					{
						return true;
					}
					startIndex = num + text.Length;
				}
			}
			return false;
		}
	}

	[SerializeField]
	private List<SettingTab> tabs;

	[SerializeField]
	private UI_SearchBar searchBar;

	[Space]
	[SerializeField]
	private GameObject gestureGroup;

	[SerializeField]
	private CanvasGroup tooltipGroup;

	[SerializeField]
	private RustText tooltipNameText;

	[SerializeField]
	private RustText tooltipDescText;

	[SerializeField]
	private CanvasGroup tooltipImageGroup;

	[SerializeField]
	private CoverImage tooltipImage;

	[SerializeField]
	private CoverVideo tooltipVideo;

	[SerializeField]
	[Space]
	private ScrollRect scrollRect;

	[SerializeField]
	private CanvasGroup scrollbar;

	[SerializeField]
	private RectMask2D mask;

	[SerializeField]
	private UI_Popup safeModePopupPrefab;

	[SerializeField]
	private UI_SettingsGestureWheel gestureWheel;

	[SerializeField]
	private GameObject previewCrosshair;

	[SerializeField]
	private UI_Popup_CrosshairImportExport crosshairImportPopupPrefab;

	[SerializeField]
	private UI_Popup_CrosshairImportExport crosshairExportPopupPrefab;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
private class SettingTab
{
	public string name;

	public UI_SettingsTabButton tabButton;

	public GameObject content;

	[ReadOnly]
	public List<SettingEntry> settings;

	public RustButton button => tabButton.button;

	public CanvasGroup canvasGroup => tabButton.canvasGroup;
}


using System;
using UnityEngine;

private class SettingEntry
{
	[NonSerialized]
	public SettingTab ownerTab;

	public string convarName;

	public string nameToken;

	public UI_SettingsTweakBase tweakUIBase;

	private CanvasGroup _canvasGroup;

	private RustText _labelText;

	private RustButton _button;

	private string searchIndex;

	public GameObject gameObject
	{
		get
		{
			UI_SettingsTweakBase uI_SettingsTweakBase = tweakUIBase;
			if (uI_SettingsTweakBase == null)
			{
				return null;
			}
			return ((Component)uI_SettingsTweakBase).gameObject;
		}
	}

	public CanvasGroup canvasGroup
	{
		get
		{
			if ((Object)(object)_canvasGroup == (Object)null)
			{
				_canvasGroup = gameObject.GetComponent<CanvasGroup>();
			}
			return _canvasGroup;
		}
	}

	public RustText labelText
	{
		get
		{
			if ((Object)(object)_labelText == (Object)null)
			{
				_labelText = gameObject.GetComponentInChildren<RustText>();
			}
			return _labelText;
		}
	}

	public RustButton button
	{
		get
		{
			if ((Object)(object)_button == (Object)null)
			{
				_button = gameObject.GetComponent<RustButton>();
			}
			return _button;
		}
	}

	public SettingEntry(string convarName, UI_SettingsTweakBase tweakUIBase)
	{
		this.convarName = convarName;
		this.tweakUIBase = tweakUIBase;
	}

	public string GetSettingName()
	{
		return Translate.Get(nameToken, (string)null, false);
	}

	public string GetTooltip()
	{
		return Translate.Get(tweakUIBase.tooltip.token, (string)null, false);
	}

	public void BuildSearchIndex()
	{
		searchIndex = string.Join(" ", GetSettingName(), GetTooltip());
	}

	public bool Matches(string query)
	{
		if (string.IsNullOrWhiteSpace(query))
		{
			return false;
		}
		string[] array = query.Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries);
		foreach (string text in array)
		{
			int startIndex = 0;
			while (true)
			{
				int num = searchIndex.IndexOf(text, startIndex, StringComparison.OrdinalIgnoreCase);
				if (num < 0)
				{
					break;
				}
				if (!RustText.IsInsideTag(searchIndex, num))
				{
					return true;
				}
				startIndex = num + text.Length;
			}
		}
		return false;
	}
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SettingsKeyBindsTab : MonoBehaviour
{
	private UI_SettingsTweakKeyBind[] keybinds;

	public static string keyDefaults;
}


using Rust.UI;
using UnityEngine;

public class UI_SettingsTabButton : MonoBehaviour
{
	public RustButton button;

	public CanvasGroup canvasGroup;

	public GameObject searchResult;

	public RustText searchResultCountText;

	public void SetSearchResult(int matchCount)
	{
		canvasGroup.alpha = ((matchCount != 0) ? 1f : 0.3f);
		searchResult.SetActive(matchCount != 0);
		if (matchCount != 0)
		{
			searchResultCountText.SetText(matchCount.ToString());
		}
	}

	public void CancelSearch()
	{
		canvasGroup.alpha = 1f;
		searchResult.SetActive(false);
	}
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreCart : UI_Window
{
	public static readonly Phrase CartEmptyPhrase = new Phrase("store.cart", "Cart");

	public static readonly Phrase CartPhrase = new Phrase("store.cart.items", "Cart ({0})");

	[SerializeField]
	[Space]
	private StyleAsset emptyStyle;

	[SerializeField]
	private StyleAsset notEmptySyle;

	[SerializeField]
	private RustButton cartButton;

	[SerializeField]
	private Canvas cartButtonCanvas;

	[SerializeField]
	private RustText cartButtonText;

	[SerializeField]
	private RustText itemCountText;

	[SerializeField]
	private RustText totalValueText;

	[SerializeField]
	[Space]
	private RectTransform itemParent;

	[SerializeField]
	private GameObject cartItemPrefab;

	[SerializeField]
	private RustButton checkoutButton;

	[SerializeField]
	private GameObject emptyGroup;

	[SerializeField]
	private GameObject footer;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreCartItem : MonoBehaviour
{
	public RustButton closeButton;

	public StoreSource source;

	private IPlayerItemDefinition _item;
}


public static class IPlayerItemDefinitionExtensions
{
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UI_StoreGeneralSubTabButton : BaseMonoBehaviour
{
	[SerializeField]
	private FlexTransition transition;

	[SerializeField]
	[Space]
	private FlexElement flexElement;

	[SerializeField]
	private FlexElement textParent;

	[SerializeField]
	private RustText text;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreGeneralTabButton : MonoBehaviour
{
	[SerializeField]
	private UI_StoreGeneralTab generalTab;
}


public static class PriceFormatter
{
}


using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreDLCTab : UI_StoreTabBase
{
	[SerializeField]
	private RectMask2D mask;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreFeaturedTab : UI_StoreTabBase
{
	[SerializeField]
	[Space]
	private UI_StoreCountdown countdown;
}


using System;
using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreGeneralTab : UI_StoreTabBase
{
	[Serializable]
	public struct Section
	{
		public string Name;

		public GameObject Group;

		public RectTransform MarkdownTarget;

		public RustButton Button;
	}

	[SerializeField]
	[Space]
	private ScrollRect scrollRect;

	[SerializeField]
	private RectTransform content;

	[SerializeField]
	private FlexElement scrollRectContentFlex;

	[SerializeField]
	[Space]
	private Section[] sections;

	[SerializeField]
	private RectMask2D mask;
}


using System;
using UnityEngine;

[Serializable]
public struct Section
{
	public string Name;

	public GameObject Group;

	public RectTransform MarkdownTarget;

	public RustButton Button;
}


using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreLimitedTab : UI_StoreTabBase
{
	[Space]
	[SerializeField]
	private UI_StoreItemGrid itemGrid;

	[SerializeField]
	private UI_StoreCountdown countdown;

	[SerializeField]
	private Scrollbar scrollbar;

	[SerializeField]
	private ScrollRect scrollRect;
}


using Rust.UI.MainMenu;

public class UI_StoreTabBase : UI_Window
{
	protected UI_Store store;

	private UI_StoreBackground[] storeBackgrounds;
}


using System;
using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_Store : UI_Page
{
	[Serializable]
	private class StoreTab
	{
		public string name;

		public RustButton button;

		public UI_StoreTabBase page;
	}

	private const string JOURNEY_ID_KEY = "journey_id";

	public static UI_Store Instance;

	[SerializeField]
	private List<StoreTab> tabs;

	[SerializeField]
	private SteamDLCItem[] dlcItems;

	[SerializeField]
	private UI_StoreLimitedItemModal weeklySkinModal;

	[SerializeField]
	private UI_StoreCart cart;

	[SerializeField]
	private RectTransform pageOverlayParent;

	[SerializeField]
	private GameObject loadingOverlay;

	[SerializeField]
	private GameObject noConnectionOverlay;

	public UI_StoreTakeover Takeovers;

	public UI_StoreCheckoutResultPage checkoutResultPagePrefab;

	[SerializeField]
	private GameObject newHeaderButtonTag;

	public static int CurrentWeekID;

	private const string CART_KEY = "STORE_CART_ITEMS";

	[SerializeField]
	[Header("Search")]
	private UI_StoreItemGrid searchGrid;

	[SerializeField]
	private RustText searchSubtitleText;

	public static Guid JourneyId
	{
		get
		{
			if (Guid.TryParse(PlayerPrefs.GetString("journey_id", ""), out var result))
			{
				return result;
			}
			Guid result2 = Guid.NewGuid();
			PlayerPrefs.SetString("journey_id", result2.ToString());
			PlayerPrefs.Save();
			return result2;
		}
		private set
		{
			PlayerPrefs.SetString("journey_id", value.ToString());
			PlayerPrefs.Save();
		}
	}

	public void EnsureJourneyId()
	{
		_ = JourneyId;
	}

	public void CreateNewJourneyId()
	{
		PlayerPrefs.DeleteKey("journey_id");
		PlayerPrefs.Save();
		EnsureJourneyId();
	}

	private StoreSource ParseSource(string query)
	{
		StoreSource result = default(StoreSource);
		string[] array = query.Split('&');
		foreach (string text in array)
		{
			if (text.StartsWith("source_area="))
			{
				result.source_area = text.Substring(12);
			}
			else if (text.StartsWith("source="))
			{
				result.source = text.Substring(7);
			}
			else if (text.StartsWith("source_id="))
			{
				result.source_id = text.Substring(10);
			}
		}
		return result;
	}
}


using System;

[Serializable]
private class StoreTab
{
	public string name;

	public RustButton button;

	public UI_StoreTabBase page;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreAddCartButton : ListComponent<UI_StoreAddCartButton>
{
	[SerializeField]
	private StyleAsset notInCartStyle;

	[SerializeField]
	private StyleAsset inCartStyle;

	[SerializeField]
	private RustButton button;

	[SerializeField]
	private RustText priceText;

	[SerializeField]
	private GameObject discountTag;

	[SerializeField]
	private RustText discountText;

	[Space]
	[SerializeField]
	private Animator animator;

	[SerializeField]
	private UI_StoreCartButtonAnimation animationSequence;

	[SerializeField]
	[Space]
	private Rust.UI.SteamInventoryItem autoInitItem;
}


using UnityEngine;
using UnityEngine.UI;

public class UI_StoreBackground : BaseMonoBehaviour
{
	public RectTransform viewport;

	public RectTransform section;

	public Image backgroundImage;

	public float fadeRange = 400f;

	public float fadeSpeed = 5f;
}


using System;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreCarrouselButton : MonoBehaviour
{
	public RustButton button;

	[Space]
	public RustText titleText;

	public RustText subtitleText;

	public CoverImage coverImage;

	public GameObject videoIcon;

	[Space]
	public GameObject gaugeParent;

	public Image gaugeImage;

	public GameObject variantGroup;

	public RustText variantText;

	[Space]
	public GameObject skinViewerGroup;

	public HttpImage httpImage;

	public void UpdateGauge(float fillAmount)
	{
		if (fillAmount != 0f && !gaugeParent.activeInHierarchy)
		{
			gaugeParent.SetActive(true);
		}
		else if (fillAmount == 0f && gaugeParent.activeInHierarchy)
		{
			gaugeParent.SetActive(false);
		}
		gaugeImage.fillAmount = fillAmount;
	}

	public void Init(UI_StoreItemOverlayPage.PageElement element, UI_StoreItemOverlayPage page)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		if (!element.UseSkinViewer)
		{
			if (element.Name != null && !string.IsNullOrEmpty(element.Name.english))
			{
				titleText.SetPhrase(element.Name, Array.Empty<object>());
			}
			else if ((Object)(object)element.Item != (Object)null)
			{
				titleText.SetPhrase(element.Item.displayName, Array.Empty<object>());
			}
		}
		skinViewerGroup.SetActive(element.UseSkinViewer);
		videoIcon.SetActive(element.isVideo);
		Sprite val = (((Object)(object)element.GallerySprite == (Object)null) ? element.FullscreenSprite : element.GallerySprite);
		Sprite val2 = null;
		if ((Object)(object)val != (Object)null && (Object)(object)page.SmallAtlas != (Object)null)
		{
			Rect rect = val.rect;
			if (((Rect)(ref rect)).width > 512f)
			{
				rect = val.rect;
				if (((Rect)(ref rect)).height > 512f)
				{
					val2 = page.SmallAtlas.GetSprite(((Object)val).name);
				}
			}
		}
		coverImage.sprite = (((Object)(object)val2 != (Object)null) ? val2 : val);
		variantGroup.SetActive(element.VariantCount > 0);
		variantText.SetText(element.VariantCount.ToString());
	}

	public void Init(string imageURL)
	{
		if ((Object)(object)httpImage != (Object)null)
		{
			httpImage.Load(imageURL);
		}
	}
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UI_StoreCartButtonAnimation : BaseMonoBehaviour
{
	[SerializeField]
	private CanvasGroup loading;

	[SerializeField]
	private GameObject addToCartGroup;

	[SerializeField]
	[Space]
	private FlexElement inCartGroup;

	[SerializeField]
	private FlexElement inCartTextParent;

	[SerializeField]
	private RustFlexText inCartText;

	[SerializeField]
	private FlexGraphicTransform inCartIcon;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreCheckoutResultButton : MonoBehaviour
{
	public RustButton button;

	[Space]
	[SerializeField]
	private RustText titleText;

	[SerializeField]
	private RustText subtitleText;

	[Space]
	[SerializeField]
	private CoverImage takeoverImage;

	[SerializeField]
	private HttpImage httpImage;

	[SerializeField]
	[Space]
	private GameObject gaugeParent;

	[SerializeField]
	private Image gaugeImage;

	[Space]
	[Header("Animation")]
	[SerializeField]
	private CanvasGroup canvasGroup;
}


using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreCheckoutResultPage : UI_Window
{
	[SerializeField]
	[Space]
	private FlexTransition crossFadeTransition;

	[SerializeField]
	private CoverImage coverBackground;

	[SerializeField]
	private Sprite defaultBackground;

	[SerializeField]
	private RustText itemNameText;

	[SerializeField]
	private RustText itemSubtitleText;

	[SerializeField]
	[Space]
	private UI_StoreCheckoutResultButton carrouselButtonPrefab;

	[SerializeField]
	private RectTransform buttonsParent;

	[SerializeField]
	[Space]
	private GraphicRaycaster footerGraphicRaycaster;

	[SerializeField]
	private CanvasGroup arrowButtons;

	[SerializeField]
	private ScrollRect scrollRect;

	[SerializeField]
	private FlexElement scrollContentFlex;

	[SerializeField]
	private CanvasGroup leftArrow;

	[SerializeField]
	private CanvasGroup rightArrow;

	[SerializeField]
	private bool autoCycleEnabled = true;

	[SerializeField]
	private float autoCycleInterval = 10f;

	[SerializeField]
	private UI_StoreTakeover localTakeovers;

	[SerializeField]
	[Header("Skin Viewer")]
	[Space]
	private CoverImage skinViewerImage;

	[SerializeField]
	private GameObject icon3D;

	[SerializeField]
	private GameObject icon2D;

	[SerializeField]
	private GameObject loadingOverlay;

	[SerializeField]
	protected HttpImage iconImage;

	[SerializeField]
	[Header("Intro Sequence")]
	private CanvasGroup fadeOverlay;

	[SerializeField]
	private CanvasGroup inventoryButton;
}


using Rust.UI;
using UnityEngine;

public class UI_StoreCountdown : MonoBehaviour
{
	[SerializeField]
	private RustText refreshesInText;

	[SerializeField]
	private RustText countdownText;
}


using Rust.UI.MainMenu;

public class UI_StoreFakeItemsTakeover : UI_StoreTakeover
{
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreItemDLC : MonoBehaviour
{
	public int appID;

	public UI_StoreItemOverlayPage overlayPagePrefab;

	public UI_StoreAddCartButton cartButton;

	private IPlayerItemDefinition _item;
}


using System;

[Serializable]
public struct StoreSource
{
	public string source_area;

	public string source;

	public string source_id;
}


using System;
using System.Collections.Generic;
using Facepunch.Flexbox;
using Rust.UI.MainMenu;
using UnityEngine;

[RequireComponent(typeof(FlexGridsElement))]
public class UI_StoreItemGrid : MonoBehaviour
{
	public enum OrderingRule
	{
		TakeoverOrder,
		WhitelistOrder,
		OwnedLast,
		OwnedFirst,
		PriceLowToHigh,
		PriceHighToLow,
		Alphabetical,
		ReverseAlphabetical,
		FeaturedFirst,
		LargestFirst,
		Random,
		FeaturedLast,
		FakeItemsOrder,
		FeaturingOrder
	}

	public enum RuleMatchMode
	{
		All,
		Any
	}

	public enum FilterRule
	{
		TagInclude,
		TagExclude,
		OnlyFeatured,
		ExcludeFeatured,
		NeedTakeOver,
		ItemShortName,
		ExcludeOwned
	}

	[Serializable]
	public class StoreFilterRule
	{
		public bool enabled = true;

		public FilterRule ruleType;

		public List<string> tags = new List<string>();

		public List<string> itemShortNames = new List<string>();
	}

	[Serializable]
	public struct ItemSizeSettings
	{
		public SteamInventoryItem Item;

		public int ItemID;

		[Range(1f, 12f)]
		public int SizeX;

		[Range(1f, 5f)]
		public int SizeY;

		public int GetItemID
		{
			get
			{
				if (!((Object)(object)Item != (Object)null))
				{
					return ItemID;
				}
				return Item.id;
			}
		}
	}

	[SerializeField]
	private FlexGridsElement grid;

	[Tooltip("The source of the items, for analytics")]
	[SerializeField]
	private StoreSource source;

	[Space]
	[SerializeField]
	private UI_StoreItemTile skinItemTilePrefab;

	[SerializeField]
	private UI_StoreItemTile featuredSkinItemTilePrefab;

	[SerializeField]
	private int maxCellCount;

	[SerializeField]
	[Min(0f)]
	public int cellWidth;

	[SerializeField]
	[Min(0f)]
	public int cellHeight;

	public bool fixedGrid;

	public List<Vector2Int> fixedSizes = new List<Vector2Int>();

	[SerializeField]
	private bool autoSizing;

	[SerializeField]
	private Vector2 baseItemSize = new Vector2(1f, 1f);

	[SerializeField]
	private Vector2 featuredItemSize;

	[SerializeField]
	private ItemSizeSettings[] sizeOverrides;

	[SerializeField]
	private List<OrderingRule> orderingRules = new List<OrderingRule>();

	[SerializeField]
	private List<SteamInventoryItem> whiteListedItems = new List<SteamInventoryItem>();

	[SerializeField]
	private UI_StoreFakeItemsTakeover fakeAdditionalItems;

	public bool dynamicContent = true;

	[SerializeField]
	private RuleMatchMode ruleMatchMode = RuleMatchMode.Any;

	[SerializeField]
	private List<StoreFilterRule> rules = new List<StoreFilterRule>();

	public FlexGridsElement Grid => grid;

	private UI_Store store => UI_Store.Instance;
}


public enum OrderingRule
{
	TakeoverOrder,
	WhitelistOrder,
	OwnedLast,
	OwnedFirst,
	PriceLowToHigh,
	PriceHighToLow,
	Alphabetical,
	ReverseAlphabetical,
	FeaturedFirst,
	LargestFirst,
	Random,
	FeaturedLast,
	FakeItemsOrder,
	FeaturingOrder
}


public enum RuleMatchMode
{
	All,
	Any
}


public enum FilterRule
{
	TagInclude,
	TagExclude,
	OnlyFeatured,
	ExcludeFeatured,
	NeedTakeOver,
	ItemShortName,
	ExcludeOwned
}


using System;
using System.Collections.Generic;

[Serializable]
public class StoreFilterRule
{
	public bool enabled = true;

	public FilterRule ruleType;

	public List<string> tags = new List<string>();

	public List<string> itemShortNames = new List<string>();
}


using System;
using UnityEngine;

[Serializable]
public struct ItemSizeSettings
{
	public global::SteamInventoryItem Item;

	public int ItemID;

	[Range(1f, 12f)]
	public int SizeX;

	[Range(1f, 5f)]
	public int SizeY;

	public int GetItemID
	{
		get
		{
			if (!((Object)(object)Item != (Object)null))
			{
				return ItemID;
			}
			return Item.id;
		}
	}
}


using System;
using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.U2D;
using UnityEngine.UI;

public class UI_StoreItemOverlayPage : UI_Window
{
	[Serializable]
	public struct PageElement
	{
		public Phrase Name;

		[ItemSelector]
		public ItemDefinition Item;

		public bool isVideo;

		public string videoURL;

		public Sprite FullscreenSprite;

		public Sprite GallerySprite;

		[Min(0f)]
		public int VariantCount;

		public bool overrideItem;

		public Phrase ItemName;

		public Sprite ItemIcon;

		public bool UseSkinViewer;

		public Phrase GetTitle()
		{
			if (Name != null && !string.IsNullOrEmpty(Name.english))
			{
				return Name;
			}
			if ((Object)(object)Item != (Object)null)
			{
				return Item.displayName;
			}
			return Phrase.op_Implicit(string.Empty);
		}

		public Phrase GetRedirectItemName()
		{
			if ((Object)(object)Item != (Object)null && (Object)(object)Item.isRedirectOf != (Object)null)
			{
				return Item.isRedirectOf.displayName;
			}
			if (overrideItem)
			{
				return ItemName;
			}
			return null;
		}

		public Sprite GetRedirectItemIcon()
		{
			if ((Object)(object)Item != (Object)null && (Object)(object)Item.isRedirectOf != (Object)null)
			{
				return Item.isRedirectOf.iconSprite;
			}
			if (overrideItem)
			{
				return ItemIcon;
			}
			return null;
		}
	}

	[Serializable]
	public struct PageContent
	{
		public PageElement[] Elements;
	}

	[Header("Page Content")]
	[SerializeField]
	[Space]
	private CanvasGroup bodyCanvasGroup;

	[SerializeField]
	private FlexTransition crossFadeTransition;

	[SerializeField]
	private CoverVideo coverVideo;

	[SerializeField]
	private CoverImage coverImage;

	[SerializeField]
	private UI_BackgroundAspectRatioFitter coverBackground;

	[SerializeField]
	private Canvas backButtonCanvas;

	[SerializeField]
	private GameObject textContainerGroup;

	[SerializeField]
	private RustText titleText;

	[SerializeField]
	private GameObject itemGroup;

	[SerializeField]
	private RustText itemNameText;

	[SerializeField]
	private Image itemIconImage;

	[SerializeField]
	private GameObject variantGroup;

	[SerializeField]
	private RustText variantCoutText;

	[Header("Gallery")]
	public SpriteAtlas SmallAtlas;

	[SerializeField]
	private Transform galleryParent;

	[SerializeField]
	private Canvas galleryCanvas;

	[SerializeField]
	private CanvasGroup arrowButtons;

	[SerializeField]
	private ScrollRect scrollRect;

	[SerializeField]
	private CanvasGroup leftArrow;

	[SerializeField]
	private CanvasGroup rightArrow;

	[SerializeField]
	private UI_StoreAddCartButton cartButton;

	[SerializeField]
	private GameObject ownedButton;

	[SerializeField]
	[Space]
	private bool autoCycleEnabled = true;

	[SerializeField]
	private float autoCycleInterval = 10f;

	[SerializeField]
	[Header("Skin Viewer")]
	private UI_SkinViewerControls skinViewerControls;

	[SerializeField]
	private CoverImage skinViewerImage;

	[SerializeField]
	private UI_StoreCarrouselButton carouselButtonPrefab;

	[SerializeField]
	[Space]
	private PageContent pageContent;
}


using System;
using UnityEngine;

[Serializable]
public struct PageElement
{
	public Phrase Name;

	[ItemSelector]
	public ItemDefinition Item;

	public bool isVideo;

	public string videoURL;

	public Sprite FullscreenSprite;

	public Sprite GallerySprite;

	[Min(0f)]
	public int VariantCount;

	public bool overrideItem;

	public Phrase ItemName;

	public Sprite ItemIcon;

	public bool UseSkinViewer;

	public Phrase GetTitle()
	{
		if (Name != null && !string.IsNullOrEmpty(Name.english))
		{
			return Name;
		}
		if ((Object)(object)Item != (Object)null)
		{
			return Item.displayName;
		}
		return Phrase.op_Implicit(string.Empty);
	}

	public Phrase GetRedirectItemName()
	{
		if ((Object)(object)Item != (Object)null && (Object)(object)Item.isRedirectOf != (Object)null)
		{
			return Item.isRedirectOf.displayName;
		}
		if (overrideItem)
		{
			return ItemName;
		}
		return null;
	}

	public Sprite GetRedirectItemIcon()
	{
		if ((Object)(object)Item != (Object)null && (Object)(object)Item.isRedirectOf != (Object)null)
		{
			return Item.isRedirectOf.iconSprite;
		}
		if (overrideItem)
		{
			return ItemIcon;
		}
		return null;
	}
}


using System;

[Serializable]
public struct PageContent
{
	public PageElement[] Elements;
}


using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreItemTile : BaseMonoBehaviour
{
	public RustButton button;

	[SerializeField]
	public CanvasGroup animatedParent;

	[SerializeField]
	private RustText skinNameText;

	[SerializeField]
	private RustText itemTypeText;

	[Space]
	[SerializeField]
	private CanvasGroup imageGroup;

	[SerializeField]
	protected HttpImage httpImage;

	[SerializeField]
	private CoverVideo coverVideo;

	[SerializeField]
	public CoverImage coverImage;

	[Space]
	[Header("Header")]
	[SerializeField]
	private GameObject headerTextGroup;

	[SerializeField]
	private RustText headerText;

	[SerializeField]
	private FlexElement paddedContainer;

	[SerializeField]
	private UI_StoreAddCartButton cartButton;

	[SerializeField]
	[Space]
	private GameObject ownedOverlay;

	[SerializeField]
	private GameObject ownedTag;

	[SerializeField]
	private bool disableCartWhenOwned;

	[SerializeField]
	private bool fadeIconWhenOwned = true;
}


using System.Collections.Generic;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreItemTileWeeklySkin : UI_StoreItemTile
{
	[SerializeField]
	private bool applyIconColor;

	[SerializeField]
	private bool animatedShimmers;

	[SerializeField]
	private Image coloredGradient;

	private static readonly Dictionary<IPlayerItemDefinition, Color> CachedGradientColors = new Dictionary<IPlayerItemDefinition, Color>();

	private static readonly int ShimmerStrength = Shader.PropertyToID("_ShimmerStrength");

	private static readonly int ShimmerSpeed = Shader.PropertyToID("_ShimmerSpeed");

	[SerializeField]
	private float idleShimmerStrength;

	[SerializeField]
	private float idleShimmerSpeed;

	[SerializeField]
	private float hoverShimmerStrength = 0.154f;

	[SerializeField]
	private float hoverShimmerSpeed = 0.03f;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreLimitedItemModal : UI_SteamInventoryPlayerItemModal
{
	[SerializeField]
	private UI_StoreAddCartButton cartButton;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StorePackShowcase : MonoBehaviour
{
	public SteamInventoryItem item;

	public UI_StoreAddCartButton cartButton;

	public GameObject background;
}


using System;
using Facepunch.Models;
using Rust.UI.MainMenu;
using UnityEngine;

[Serializable]
public struct ItemStoreTakeover
{
	public Phrase NameOverride;

	public Phrase SubtitleOverride;

	public Phrase HeaderPhrase;

	public Sprite IconOverride;

	public Sprite IconPortraitOverride;

	public Sprite IconSquareOverride;

	public string ImageURL;

	public string VideoURL;

	public UI_StoreItemOverlayPage PagePrefab;

	public UI_StoreItemTile TilePrefabOverride;

	public SteamInventoryItem Item;

	[Tooltip("Will be used if you don't have an Item definition (DLCs)")]
	public int ItemId;

	public readonly int GetItemID()
	{
		if (!((Object)(object)Item != (Object)null))
		{
			return ItemId;
		}
		return Item.id;
	}

	public ItemStoreTakeover(StoreFeaturing storeFeaturing)
	{
		NameOverride = Phrase.op_Implicit(storeFeaturing.TitleText);
		SubtitleOverride = Phrase.op_Implicit(storeFeaturing.SubtitleText);
		HeaderPhrase = Phrase.op_Implicit(storeFeaturing.HeaderText);
		ImageURL = storeFeaturing.ImageUrl;
		VideoURL = storeFeaturing.VideoUrl;
		ItemId = storeFeaturing.ItemID;
		IconOverride = null;
		IconPortraitOverride = null;
		IconSquareOverride = null;
		PagePrefab = null;
		TilePrefabOverride = null;
		Item = null;
	}

	public readonly bool IsValid()
	{
		return GetItemID() != 0;
	}

	public void OverridesWith(ItemStoreTakeover other)
	{
		if (!string.IsNullOrEmpty(other.NameOverride.translated))
		{
			NameOverride = other.NameOverride;
		}
		if (!string.IsNullOrEmpty(other.SubtitleOverride.translated))
		{
			SubtitleOverride = other.SubtitleOverride;
		}
		if (other.HeaderPhrase != null && !string.IsNullOrEmpty(other.HeaderPhrase.translated))
		{
			HeaderPhrase = other.HeaderPhrase;
		}
		if ((Object)(object)other.IconOverride != (Object)null)
		{
			IconOverride = other.IconOverride;
		}
		if ((Object)(object)other.IconPortraitOverride != (Object)null)
		{
			IconPortraitOverride = other.IconPortraitOverride;
		}
		if ((Object)(object)other.IconSquareOverride != (Object)null)
		{
			IconSquareOverride = other.IconSquareOverride;
		}
		if (!string.IsNullOrEmpty(other.ImageURL))
		{
			ImageURL = other.ImageURL;
		}
		if (!string.IsNullOrEmpty(other.VideoURL))
		{
			VideoURL = other.VideoURL;
		}
		if ((Object)(object)other.PagePrefab != (Object)null)
		{
			PagePrefab = other.PagePrefab;
		}
		if ((Object)(object)other.TilePrefabOverride != (Object)null)
		{
			TilePrefabOverride = other.TilePrefabOverride;
		}
		if ((Object)(object)other.Item != (Object)null)
		{
			Item = other.Item;
		}
		if (other.ItemId != 0)
		{
			ItemId = other.ItemId;
		}
	}

	public Sprite GetBestIconForRect(float width, float height)
	{
		float num = width / height;
		bool flag = num > 1.15f;
		bool flag2 = num < 0.8f;
		if (flag)
		{
			return IconOverride;
		}
		if (flag2)
		{
			if ((Object)(object)IconPortraitOverride != (Object)null)
			{
				return IconPortraitOverride;
			}
			return IconOverride;
		}
		if ((Object)(object)IconSquareOverride != (Object)null)
		{
			return IconSquareOverride;
		}
		return IconOverride;
	}
}


using System;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreTakeover : MonoBehaviour
{
	public bool ignoreFeaturingTakeovers;

	public ItemStoreTakeover[] Takeovers = Array.Empty<ItemStoreTakeover>();
}


using UnityEngine;

public class UI_BackgroundAspectRatioFitter : MonoBehaviour
{
	public RectTransform rectTransform;

	public Vector2 offset;
}


using UnityEngine;

public class UI_MainMenuNavigate : MonoBehaviour
{
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_Popup : UI_Window
{
	[SerializeField]
	[Space]
	private Transform buttonsParent;

	[SerializeField]
	private RustText titleText;

	[SerializeField]
	private RustText messageText;

	[SerializeField]
	private RustButton buttonTemplate;

	[SerializeField]
	private RustButton[] buttons;
}


using System;
using Facepunch.Flexbox;
using UnityEngine;

public class UI_Window : BaseMonoBehaviour
{
	[SerializeField]
	private bool _skipAutoFixState;

	[Header("Window - Transitions")]
	[SerializeField]
	private FlexTransition _openTransition;

	[SerializeField]
	private bool _oneShotTransition;

	[SerializeField]
	[Header("Window - Canvas")]
	protected CanvasGroup _group;

	[Header("Window - Escape Capture")]
	[SerializeField]
	protected UIEscapeCapture _escape;

	[SerializeField]
	[Header("Window - Flex Element")]
	private FlexElement _flex;

	protected bool _firstTimeOpened = true;

	protected bool _opened;

	public event Action OnOpen;

	public event Action OnClose;

	protected virtual void Awake()
	{
		if (!_opened && !_skipAutoFixState)
		{
			FixBrokenState();
		}
	}

	private void FixBrokenState()
	{
		TimeWarning val = TimeWarning.New("UI_Window.FixBrokenState", 0);
		try
		{
			if ((Object)(object)_group == (Object)null)
			{
				if (((Component)this).gameObject.activeSelf)
				{
					((Component)this).gameObject.SetActive(false);
				}
				return;
			}
			if (!((Component)this).gameObject.activeSelf)
			{
				((Component)this).gameObject.SetActive(true);
			}
			SetUI(state: false);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void Open()
	{
		if (!_opened)
		{
			_opened = true;
			SetUI(state: true);
			OnOpened();
			if (_firstTimeOpened)
			{
				_firstTimeOpened = false;
			}
		}
	}

	public virtual void Close()
	{
		if (_opened)
		{
			_opened = false;
			SetUI(state: false);
			OnClosed();
		}
	}

	public bool IsOpen()
	{
		return _opened;
	}

	protected virtual void OnOpened()
	{
		this.OnOpen?.Invoke();
		if ((Object)(object)_openTransition != (Object)null)
		{
			if (_oneShotTransition)
			{
				_openTransition.PlayOneOff();
			}
			else
			{
				_openTransition.SwitchState(true, true);
			}
		}
	}

	protected virtual void OnClosed()
	{
		this.OnClose?.Invoke();
		if (Object.op_Implicit((Object)(object)_openTransition))
		{
			_openTransition.SwitchState(false, false);
		}
	}

	public virtual void SetUI(bool state)
	{
		if ((Object)(object)_group == (Object)null)
		{
			((Component)this).gameObject.SetActive(state);
		}
		else
		{
			if (state && !((Component)this).gameObject.activeSelf)
			{
				((Component)this).gameObject.SetActive(true);
			}
			_group.alpha = (state ? 1 : 0);
			_group.interactable = state;
			_group.blocksRaycasts = state;
		}
		if ((Object)(object)_escape != (Object)null)
		{
			((Behaviour)_escape).enabled = state;
		}
		if ((Object)(object)_flex != (Object)null)
		{
			((Behaviour)_flex).enabled = state;
		}
	}
}


using Rust.UI;
using Rust.UI.MainMenu;
using Rust.UI.MainMenu.Workshop;
using UnityEngine;

public class UI_Workshop : UI_Page
{
	public static UI_Workshop Instance;

	[SerializeField]
	private UI_WorkshopItemList itemList;

	[SerializeField]
	private RustButton initialTabButton;

	public static Phrase loading_workshop = (Phrase)(object)new TokenisedPhrase("loading.workshop", "Loading Workshop");

	public static Phrase loading_workshop_setup = (Phrase)(object)new TokenisedPhrase("loading.workshop.initializing", "Setting Up Scene");

	public static Phrase loading_workshop_skinnables = (Phrase)(object)new TokenisedPhrase("loading.workshop.skinnables", "Getting Skinnables");

	public static Phrase loading_workshop_item = (Phrase)(object)new TokenisedPhrase("loading.workshop.item", "Loading Item Data");

	private readonly Phrase createNewSkinPhrase = new Phrase("workshop.createskin.title", "Create skin");

	private readonly Phrase createNewSkinBodyPhrase = new Phrase("workshop.createskin.body", "Do you want to create a new skin? This will load the workshop scene.");

	private readonly Phrase yesPhrase = new Phrase("workshop.continue", "Continue");

	private readonly Phrase cancelPhrase = new Phrase("workshop.cancel", "Cancel");
}


using Rust.UI;
using UnityEngine;

public class UI_WorkshopItemButton : MonoBehaviour
{
	[SerializeField]
	private HttpImage httpImage;

	[SerializeField]
	private Transform scaledParent;

	[SerializeField]
	private GameObject loadingIndicator;
}


using Rust.UI;
using Rust.UI.MainMenu.Workshop;
using UnityEngine;

public class UI_WorkshopItemList : MonoBehaviour
{
	[SerializeField]
	private RustButton previousPageButton;

	[SerializeField]
	private RustButton nextPageButton;

	[SerializeField]
	private UI_WorkshopItemButton itemPrefab;

	[SerializeField]
	private UI_WorkshopItemButton myItemPrefab;

	[SerializeField]
	private Transform itemsParent;

	[SerializeField]
	private RustText pageInfoText;

	[SerializeField]
	private Dropdown itemTypeSelector;
}


using System;
using System.Collections.Generic;
using Benchmark;
using ProtoBuf;
using UnityEngine;

[JsonModel]
public class Building
{
	[JsonModel]
	public class Entity
	{
		public ulong NetId;

		public string ResPath;

		public ulong ParentNetId;

		public Vector3 Pos;

		public Vector3 RotEuler;

		public ulong SkinID;

		public virtual void FromProto(Entity ent)
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			NetId = ent.baseNetworkable.uid.Value;
			ResPath = StringPool.Get(ent.baseNetworkable.prefabID);
			ParentNetId = ent.parent?.uid.Value ?? 0;
			Pos = ent.baseEntity.pos;
			RotEuler = ent.baseEntity.rot;
			SkinID = ent.baseEntity.skinid;
		}
	}

	[JsonModel]
	public class BuildingEntity : Entity
	{
		public BuildingGrade.Enum Grade;

		public ulong Model;

		public override void FromProto(Entity ent)
		{
			base.FromProto(ent);
			if (ent.buildingBlock != null)
			{
				Grade = (BuildingGrade.Enum)ent.buildingBlock.grade;
				Model = ent.buildingBlock.model;
			}
			else
			{
				Grade = BuildingGrade.Enum.None;
				Model = 0uL;
			}
		}
	}

	[JsonModel]
	public class SpawnMarker
	{
		[Flags]
		public enum SpawnType
		{
			LocalPlayer = 1,
			RemotePlayer = 2
		}

		public Vector3 Pos;

		public Vector3 RotEuler;

		public SpawnType Type;
	}

	public const uint InvalidBuildingId = 0u;

	public uint Id;

	public List<BuildingEntity> BuildingEntities;

	public List<SpawnMarker> SpawnMarkers;

	public Building(uint id)
	{
		Id = id;
		BuildingEntities = new List<BuildingEntity>();
		SpawnMarkers = new List<SpawnMarker>();
	}

	public override string ToString()
	{
		return $"{Id}: {BuildingEntities.Count} entities";
	}
}


using ProtoBuf;
using UnityEngine;

[JsonModel]
public class Entity
{
	public ulong NetId;

	public string ResPath;

	public ulong ParentNetId;

	public Vector3 Pos;

	public Vector3 RotEuler;

	public ulong SkinID;

	public virtual void FromProto(Entity ent)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		NetId = ent.baseNetworkable.uid.Value;
		ResPath = StringPool.Get(ent.baseNetworkable.prefabID);
		ParentNetId = ent.parent?.uid.Value ?? 0;
		Pos = ent.baseEntity.pos;
		RotEuler = ent.baseEntity.rot;
		SkinID = ent.baseEntity.skinid;
	}
}


using ProtoBuf;

[JsonModel]
public class BuildingEntity : Entity
{
	public BuildingGrade.Enum Grade;

	public ulong Model;

	public override void FromProto(Entity ent)
	{
		base.FromProto(ent);
		if (ent.buildingBlock != null)
		{
			Grade = (BuildingGrade.Enum)ent.buildingBlock.grade;
			Model = ent.buildingBlock.model;
		}
		else
		{
			Grade = BuildingGrade.Enum.None;
			Model = 0uL;
		}
	}
}


using System;
using UnityEngine;

[JsonModel]
public class SpawnMarker
{
	[Flags]
	public enum SpawnType
	{
		LocalPlayer = 1,
		RemotePlayer = 2
	}

	public Vector3 Pos;

	public Vector3 RotEuler;

	public SpawnType Type;
}


using System;

[Flags]
public enum SpawnType
{
	LocalPlayer = 1,
	RemotePlayer = 2
}


using System;
using AntiHackJobs;
using BasePlayerJobs;
using CoarseQueryGridJobs;
using CompanionServer.Cameras;
using Facepunch.MarchingCubes;
using Facepunch.NativeMeshSimplification;
using GamePhysicsJobs;
using GenerateErosionJobs;
using HitBoxSystemJobs;
using Instancing;
using OceanSimulationJobs;
using ProjectileJobs;
using Rust.Water5;
using ServerOcclusionJobs;
using TerrainHeightMapJobs;
using TerrainTexturingJobs;
using TerrainTopologyMapJobs;
using TerrainWaterMapJobs;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Jobs;
using UtilityJobs;
using WaterLevelJobs;
using WaterSystemJobs;

[DOTSCompilerGenerated]
internal class __JobReflectionRegistrationOutput__1221673671587648887
{
	public static void CreateJobReflectionData()
	{
		try
		{
			IJobExtensions.EarlyJobInit<FishShoal.FishCollisionGatherJob>();
			IJobExtensions.EarlyJobInit<FishShoal.FishCollisionProcessJob>();
			IJobParallelForExtensions.EarlyJobInit<FishShoal.FishUpdateJob>();
			IJobExtensions.EarlyJobInit<FishShoal.KillFish>();
			IJobParallelForTransformExtensions.EarlyJobInit<QueryVisJobs.ConstructCommandsJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<QueryVisJobs.CheckWaterLevelVisibilityJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<TransformLineRenderer.LineRendererUpdateJob>();
			IJobExtensions.EarlyJobInit<AddAndBlurSphereJob>();
			IJobForExtensions.EarlyJobInit<BoxBlur3DJob>();
			IJobExtensions.EarlyJobInit<BoxBlurCylinderJob>();
			IJobExtensions.EarlyJobInit<BoxBlurSphereJob>();
			IJobExtensions.EarlyJobInit<CarveAndBlurCylinderJob>();
			IJobExtensions.EarlyJobInit<CarveAndBlurSphereJob>();
			IJobExtensions.EarlyJobInit<CleanFloatingIslandsJob>();
			IJobParallelForExtensions.EarlyJobInit<Hopper.FillRaycastJob>();
			IJobExtensions.EarlyJobInit<GenerateSpawnPoints>();
			IJobExtensions.EarlyJobInit<PostCullingJob>();
			IJobExtensions.EarlyJobInit<DistanceField.GenerateJob>();
			IJobParallelForExtensions.EarlyJobInit<DistanceField.SobelGradientsJob>();
			IJobExtensions.EarlyJobInit<DistanceField.FixBoundaryGradientsJob>();
			IJobParallelForExtensions.EarlyJobInit<DistanceField.BlurHorizontalJob>();
			IJobParallelForExtensions.EarlyJobInit<DistanceField.BlurVerticalJob>();
			IJobExtensions.EarlyJobInit<DistanceField.GaussianBlurJob>();
			IJobExtensions.EarlyJobInit<FlipBoolJob>();
			IJobExtensions.EarlyJobInit<GenerateAscSeqListJob>();
			IJobExtensions.EarlyJobInit<InvertIndexListJob>();
			IJobExtensions.EarlyJobInit<RaycastSamplePositionsJob>();
			IJobExtensions.EarlyJobInit<RaycastBufferSetupJob>();
			IJobParallelForExtensions.EarlyJobInit<RaycastRaySetupJob>();
			IJobParallelForExtensions.EarlyJobInit<RaycastRayProcessingJob>();
			IJobExtensions.EarlyJobInit<RaycastOutputCompressJob>();
			IJobExtensions.EarlyJobInit<RaycastColliderProcessingJob>();
			IJobExtensions.EarlyJobInit<GatherPlayersWithTicksJob>();
			IJobExtensions.EarlyJobInit<BuildLayerMasksJob>();
			IJobExtensions.EarlyJobInit<GatherHitIndicesJob>();
			IJobExtensions.EarlyJobInit<BuildBatchLookupMapJob>();
			IJobExtensions.EarlyJobInit<GatherNoClipBatchesJob>();
			IJobExtensions.EarlyJobInit<FindValidIndicesJob>();
			IJobExtensions.EarlyJobInit<InsideTerrainHeightsChecksJob>();
			IJobExtensions.EarlyJobInit<ScatterInvertedBool>();
			IJobForExtensions.EarlyJobInit<GenerateInsideMeshCommandsJob>();
			IJobForExtensions.EarlyJobInit<CheckInsideMeshHitsJob>();
			IJobForExtensions.EarlyJobInit<FilterInsideMeshHitsJob>();
			IJobExtensions.EarlyJobInit<PreCullingJob>();
			IJobParallelForDeferExtensions.EarlyJobInit<FillFalseJobDefer>();
			IJobParallelForDeferExtensions.EarlyJobInit<AdjustByTopologyJob>();
			IJobParallelForDeferExtensions.EarlyJobInit<SmallDisplacementPlaneTraceJob>();
			IJobParallelForDeferExtensions.EarlyJobInit<OceanTraceJob>();
			IJobForExtensions.EarlyJobInit<PaintSplatJob>();
			IJobParallelForExtensions.EarlyJobInit<PopulateDeltaHeightJob>();
			IJobParallelForExtensions.EarlyJobInit<CopyBackFloatHeightToShortHeightJob>();
			IJobParallelForExtensions.EarlyJobInit<EvaporationJob>();
			IJobParallelForBatchExtensions.EarlyJobInit<PrepareMapJob>();
			IJobParallelForExtensions.EarlyJobInit<TransportSedimentJob>();
			IJobParallelForExtensions.EarlyJobInit<CalcMinHeightMapJob>();
			IJobParallelForExtensions.EarlyJobInit<ErosionAndDepositionJob>();
			IJobParallelForExtensions.EarlyJobInit<TileCalculateAngleMap>();
			IJobParallelForExtensions.EarlyJobInit<AdjustWaterHeightByFluxJob>();
			IJobParallelForExtensions.EarlyJobInit<CalculateOutputFluxJob>();
			IJobParallelForExtensions.EarlyJobInit<RefillOceanJob>();
			IJobParallelForExtensions.EarlyJobInit<WaterIncrementationJob>();
			IJobExtensions.EarlyJobInit<GetCoarseDistsToShoreJobIndirect>();
			IJobExtensions.EarlyJobInit<GenSamplePoints>();
			IJobParallelForExtensions.EarlyJobInit<GenShoreVecBitMapJob>();
			IJobParallelForExtensions.EarlyJobInit<GenTopologyRadiiJob>();
			IJobParallelForExtensions.EarlyJobInit<ProcessTopologyJob>();
			IJobParallelForExtensions.EarlyJobInit<FillAsOceanTopologyJob>();
			IJobParallelForExtensions.EarlyJobInit<PopulateTextureDataJob>();
			IJobExtensions.EarlyJobInit<GetHeightByPosJob>();
			IJobExtensions.EarlyJobInit<GetHeightByUVJob>();
			IJobExtensions.EarlyJobInit<GetHeightByUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightByIndexJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByPosJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByUVJob>();
			IJobExtensions.EarlyJobInit<GetTopologyRadiusJob>();
			IJobParallelForExtensions.EarlyJobInit<GetTopologyRadiusJobIndirect>();
			IJobParallelForExtensions.EarlyJobInit<GetTopologyRadiusNormalizedJobIndirect>();
			IJobExtensions.EarlyJobInit<GetTopologyByIndexJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightsFastJobIndirect>();
			IJobParallelForExtensions.EarlyJobInit<GetHeightsJob>();
			IJobExtensions.EarlyJobInit<TerrainHeightMapJobs.GetHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckPosRadJob>();
			IJobExtensions.EarlyJobInit<CheckPosRadBatchJob>();
			IJobExtensions.EarlyJobInit<CheckPosRadBatchJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckBoundsJob>();
			IJobExtensions.EarlyJobInit<CheckBoundsJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckRayJob>();
			IJobExtensions.EarlyJobInit<CalculatePathBetweenGridsJob>();
			IJobParallelForBatchExtensions.EarlyJobInit<CalculatePathsBetweenGridsJob>();
			IJobForExtensions.EarlyJobInit<CalculateSubGridSamplePointsJob>();
			IJobExtensions.EarlyJobInit<GatherMaxWaterLevelsJob>();
			IJobExtensions.EarlyJobInit<ToUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherWavesIndicesJobIndirect>();
			IJobExtensions.EarlyJobInit<ApplyMaxHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<SelectMaxWaterLevelJobIndirect>();
			IJobExtensions.EarlyJobInit<CalcCenterJobIndirect>();
			IJobExtensions.EarlyJobInit<InitialValidateInfoJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherValidInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherInvalidInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<UpdateWaterHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<SetupHeadQueryJobIndirect>();
			IJobExtensions.EarlyJobInit<ApplyHeadQueryResultsJobIndirect>();
			IJobExtensions.EarlyJobInit<ResolveWaterInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<UpdateWaterCache>();
			IJobExtensions.EarlyJobInit<GatherPosToValidateJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<RecacheTransforms>();
			IJobExtensions.EarlyJobInit<CalcWaterFactorsJobIndirect>();
			IJobExtensions.EarlyJobInit<GetWaterFactorsParamsJobIndirect>();
			IJobForExtensions.EarlyJobInit<TraceAllJob>();
			IJobExtensions.EarlyJobInit<CalcMidpoingJob>();
			IJobExtensions.EarlyJobInit<CheckHitsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapBoxCommandsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapBoxCommandsFromOBBsJob>();
			IJobExtensions.EarlyJobInit<GatherPosFromOBBsJob>();
			IJobExtensions.EarlyJobInit<ValidateOverlapBoxCommandsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapCapsuleCommandsJob>();
			IJobExtensions.EarlyJobInit<ValidateOverlapCapsuleCommandsJob>();
			IJobExtensions.EarlyJobInit<FindSphereCmdsInCapsuleCmdsJob>();
			IJobExtensions.EarlyJobInit<GenerateSphereCmdsFromCapsuleCmdsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapSphereCommandsJob>();
			IJobExtensions.EarlyJobInit<ValidateOverlapSphereCommandsJob>();
			IJobExtensions.EarlyJobInit<RemoveLayerMaskJob>();
			IJobExtensions.EarlyJobInit<CountRaycastHitsJobs>();
			IJobExtensions.EarlyJobInit<ScatterColliderHitsJob>();
			IJobExtensions.EarlyJobInit<PreProcessWaterSpheresJob>();
			IJobExtensions.EarlyJobInit<PreProcessWaterRaysJob>();
			IJobExtensions.EarlyJobInit<PostProcessWaterRaysJob>();
			IJobExtensions.EarlyJobInit<AppendRaycastHitsJob>();
			IJobExtensions.EarlyJobInit<SelectNearestHitsJob>();
			IJobExtensions.EarlyJobInit<SelectNearestNHitsJob>();
			IJobExtensions.EarlyJobInit<FilterRaycastHitsJob>();
			IJobExtensions.EarlyJobInit<RemoveInvalidRaycastHitsJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<ReadPositionDataTransformJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<BatchUpdateVelocityEndJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<GenerateRaysJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<GenerateRaysMidstepJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<PosRotReadJob>();
			IJobExtensions.EarlyJobInit<CopyBackJob>();
			IJobExtensions.EarlyJobInit<PopulateArraysJob>();
			IJobExtensions.EarlyJobInit<SimplifyMeshJob>();
			IJobParallelForExtensions.EarlyJobInit<BakePhysicsMeshesJob>();
			IJobExtensions.EarlyJobInit<CleanupDuplicateVerticesJob>();
			IJobExtensions.EarlyJobInit<MarchJob>();
			IJobExtensions.EarlyJobInit<GetHeightBatchedJob>();
			IJobParallelForExtensions.EarlyJobInit<GetHeightBatchedJob>();
			IJobExtensions.EarlyJobInit<Rust.Water5.GetHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherJob<OverlapCapsuleCommand>>();
			IJobExtensions.EarlyJobInit<ScatterToJob<bool>>();
			IJobExtensions.EarlyJobInit<FillJob<bool>>();
			IJobExtensions.EarlyJobInit<FillJob<float>>();
			IJobExtensions.EarlyJobInit<GenerateRaycastSortJobs<RaycastHit, RaycastHitComparer>>();
			IJobExtensions.EarlyJobInit<FillJob<Vector3>>();
			IJobExtensions.EarlyJobInit<FillJob<int>>();
			IJobExtensions.EarlyJobInit<GatherJob<Vector3>>();
			IJobExtensions.EarlyJobInit<GatherJob<float>>();
			IJobExtensions.EarlyJobInit<CopyArrayJob<float>>();
			IJobExtensions.EarlyJobInit<GatherJob<int>>();
			IJobExtensions.EarlyJobInit<FillJob<Vector4>>();
		}
		catch (Exception ex)
		{
			EarlyInitHelpers.JobReflectionDataCreationFailed(ex);
		}
	}

	[RuntimeInitializeOnLoadMethod(/*Could not decode attribute arguments.*/)]
	public static void EarlyInit()
	{
		CreateJobReflectionData();
	}
}


using GamePhysicsJobs;
using UnityEngine;
using WaterLevelJobs;

internal static class $BurstDirectCallInitializer
{
	[RuntimeInitializeOnLoadMethod(/*Could not decode attribute arguments.*/)]
	private static void Initialize()
	{
		BuoyancyBurstUtility.FillPointData_00004E82$BurstDirectCall.Initialize();
		BuoyancyForceAccumulationBurst.Compute_00004E84$BurstDirectCall.Initialize();
		EnvironmentVolumeMath.CalculateTransformationBoundsBurst_000054B3$BurstDirectCall.Initialize();
		EnvironmentVolumeMath.MultiplyPoint3X4_000054B4$BurstDirectCall.Initialize();
		EnvironmentVolumeMath.UpdateVolumeTransformationAndBoundsBurst_000054B5$BurstDirectCall.Initialize();
		WaterVolumeBurst.TestBurst_00005936$BurstDirectCall.Initialize();
		TerrainWaterFlowMapBurst.GetFlowDirections_0000620B$BurstDirectCall.Initialize();
		WaterSystemBurst.GetHeightArray_Burst_00006507$BurstDirectCall.Initialize();
		WaterSystemBurst.ComputeOceanSimHeight_Burst_00006508$BurstDirectCall.Initialize();
		WaterLevelBurst.GetBuoyancyWaterInfoBatched_0000772E$BurstDirectCall.Initialize();
		WaterLevelBurst.ConstructDeepWaterCommands_0000772F$BurstDirectCall.Initialize();
		Util.FindFreeSlot_00007B65$BurstDirectCall.Initialize();
		Util.FindFreeSlot_00007B66$BurstDirectCall.Initialize();
	}
}


