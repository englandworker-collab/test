using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class FreeableLootContainer : LootContainer
{
	private const Flags tiedDown = Flags.Reserved8;

	public Buoyancy buoyancy;

	public GameObjectRef freedEffect;

	private Rigidbody rb;

	private const float untieTime = 6f;

	public uint skinOverride;

	private float startUntieTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("FreeableLootContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 2202685945u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_FreeCrate "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_FreeCrate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2202685945u, "RPC_FreeCrate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_FreeCrate(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_FreeCrate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1460413277 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_FreeCrateTimer "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_FreeCrateTimer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1460413277u, "RPC_FreeCrateTimer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_FreeCrateTimer(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_FreeCrateTimer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public Rigidbody GetRB()
	{
		if ((Object)(object)rb == (Object)null)
		{
			rb = ((Component)this).GetComponent<Rigidbody>();
		}
		return rb;
	}

	public bool IsTiedDown()
	{
		return HasFlag(Flags.Reserved8);
	}

	public override void ServerInit()
	{
		GetRB().isKinematic = true;
		buoyancy.buoyancyScale = 0f;
		((Behaviour)buoyancy).enabled = false;
		base.ServerInit();
		if (skinOverride != 0)
		{
			skinID = skinOverride;
			SendNetworkUpdate();
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if (base.isServer && (Object)(object)info.Weapon != (Object)null)
		{
			BaseMelee component = ((Component)info.Weapon).GetComponent<BaseMelee>();
			if (Object.op_Implicit((Object)(object)component) && component.canUntieCrates && IsTiedDown())
			{
				base.health -= 1f;
				info.DidGather = true;
				if (base.health <= 0f)
				{
					base.health = MaxHealth();
					Release(info.InitiatorPlayer);
				}
			}
		}
		base.OnAttacked(info);
	}

	public void Release(BasePlayer ply)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnFreeableContainerRelease", (object)this, (object)ply) == null)
		{
			GetRB().isKinematic = false;
			((Behaviour)buoyancy).enabled = true;
			buoyancy.buoyancyScale = 1f;
			SetFlag(Flags.Reserved8, b: false);
			ToggleNetworkPositionTick(isEnabled: true);
			if (freedEffect.isValid)
			{
				Effect.server.Run(freedEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
			if ((Object)(object)ply != (Object)null && !ply.IsNpc && ply.IsConnected && net != null)
			{
				ply.ProcessMissionEvent(BaseMission.MissionEventType.FREE_CRATE, net.ID, 1f);
				Analytics.Azure.OnFreeUnderwaterCrate(ply, this);
			}
			Interface.CallHook("OnFreeableContainerReleased", (object)this, (object)ply);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_FreeCrate(RPCMessage msg)
	{
		if (IsTiedDown() && !(Mathf.Abs(startUntieTime + 6f - Time.realtimeSinceStartup) > ConVar.AntiHack.rpc_timer_forgiveness))
		{
			BasePlayer player = msg.player;
			Release(player);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_FreeCrateTimer(RPCMessage msg)
	{
		if (IsTiedDown())
		{
			startUntieTime = Time.realtimeSinceStartup;
			Interface.CallHook("OnFreeableContainerReleaseStarted", (object)this, (object)msg.player);
		}
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class FuelGenerator : ContainerIOEntity
{
	public int outputEnergy = 35;

	public float fuelPerSec = 1f;

	protected float fuelTickRate = 3f;

	private float pendingFuel;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("FuelGenerator.OnRpcMessage", 0);
		try
		{
			if (rpc == 1401355317 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_EngineSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_EngineSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1401355317u, "RPC_EngineSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_EngineSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_EngineSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int MaximalPowerOutput()
	{
		return outputEnergy;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void Init()
	{
		if (IsOn())
		{
			UpdateCurrentEnergy();
			((FacepunchBehaviour)this).InvokeRepeating((Action)FuelConsumption, fuelTickRate, fuelTickRate);
		}
		base.Init();
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0 && inputAmount > 0)
		{
			TurnOn();
		}
		if (inputSlot == 1 && inputAmount > 0)
		{
			TurnOff();
		}
		base.UpdateFromInput(inputAmount, inputSlot);
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		if (!IsOn())
		{
			return 0;
		}
		return outputEnergy;
	}

	public void UpdateCurrentEnergy()
	{
		currentEnergy = CalculateCurrentEnergy(0, 0);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot != 0)
		{
			return 0;
		}
		return currentEnergy;
	}

	public override bool AllowDrainFrom(int outputSlot)
	{
		return false;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_EngineSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnSwitchToggle", (object)this, (object)msg.player) == null)
		{
			bool generatorState = msg.read.Bit();
			SetGeneratorState(generatorState);
			Interface.CallHook("OnSwitchToggled", (object)this, (object)msg.player);
		}
	}

	public void SetGeneratorState(bool wantsOn)
	{
		if (wantsOn)
		{
			TurnOn();
		}
		else
		{
			TurnOff();
		}
	}

	public int GetFuelAmount()
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		return slot.amount;
	}

	public bool HasFuel()
	{
		return GetFuelAmount() >= 1;
	}

	public bool UseFuel(float seconds)
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return false;
		}
		pendingFuel += seconds * fuelPerSec;
		if (pendingFuel >= 1f)
		{
			int num = Mathf.FloorToInt(pendingFuel);
			slot.UseItem(num);
			Analytics.Azure.AddPendingItems(this, slot.info.shortname, num, "generator");
			pendingFuel -= num;
		}
		return true;
	}

	public void TurnOn()
	{
		if (!IsOn() && UseFuel(1f))
		{
			SetFlag(Flags.On, b: true);
			UpdateCurrentEnergy();
			MarkDirty();
			((FacepunchBehaviour)this).InvokeRepeating((Action)FuelConsumption, fuelTickRate, fuelTickRate);
		}
	}

	public void FuelConsumption()
	{
		if (!UseFuel(fuelTickRate))
		{
			TurnOff();
		}
	}

	public void TurnOff()
	{
		if (IsOn())
		{
			SetFlag(Flags.On, b: false);
			UpdateCurrentEnergy();
			MarkDirty();
			((FacepunchBehaviour)this).CancelInvoke((Action)FuelConsumption);
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class GestureDoor : Door
{
	public GestureConfig OpenGesture;

	public GestureConfig KickGesture;

	public float KickAnimationDelay = 1f;

	public float PushAnimationDelay = 0.25f;

	public float WeaponAdditiveDelay = 0.1f;

	private bool wasKick;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("GestureDoor.OnRpcMessage", 0);
		try
		{
			if (rpc == 872065295 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerKick "));
				}
				TimeWarning val2 = TimeWarning.New("ServerKick", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(872065295u, "ServerKick", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerKick(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerKick");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	protected override void OnPlayerOpenedDoor(BasePlayer p)
	{
		base.OnPlayerOpenedDoor(p);
		if (wasKick)
		{
			p.Server_StartGesture(KickGesture, BasePlayer.GestureStartSource.ServerAction);
		}
		else
		{
			p.Server_StartGesture(OpenGesture, BasePlayer.GestureStartSource.ServerAction);
		}
		wasKick = false;
	}

	protected override bool ShouldDelayOpen(BasePlayer player, out float delay)
	{
		delay = PushAnimationDelay;
		if (wasKick)
		{
			delay = KickAnimationDelay;
		}
		if ((Object)(object)player.GetHeldEntity() != (Object)null)
		{
			delay += WeaponAdditiveDelay;
		}
		return delay > 0f;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void ServerKick(RPCMessage msg)
	{
		wasKick = true;
		RPC_OpenDoor(msg);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;

public class GlobalNetworkHandler : PointEntity
{
	public static GlobalNetworkHandler server;

	[NonSerialized]
	public Dictionary<NetworkableId, GlobalEntityData> serverData = new Dictionary<NetworkableId, GlobalEntityData>();

	private List<Connection> globalConnections = new List<Connection>();

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("GlobalNetworkHandler.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static bool ShouldSendEntity(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null || entity.IsDestroyed)
		{
			return false;
		}
		if (entity.HasParent())
		{
			return false;
		}
		if (entity.net != null && entity.net.group != null && entity.net.group.restricted)
		{
			return false;
		}
		if (entity.globalBuildingBlock)
		{
			return true;
		}
		return false;
	}

	public override void ServerInit()
	{
		server = this;
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			LoadEntitiesOnStartup();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		LoadEntitiesOnStartup();
	}

	public void OnClientConnected(Connection connection)
	{
		if (connection.globalNetworking)
		{
			globalConnections.Add(connection);
		}
	}

	public void OnClientDisconnected(Connection connection)
	{
		globalConnections.Remove(connection);
	}

	private void LoadEntitiesOnStartup()
	{
		Stopwatch stopwatch = Stopwatch.StartNew();
		Debug.Log((object)"Starting to load entities into GlobalNetworkHandler...");
		foreach (BaseEntity item in BaseNetworkable.serverEntities.OfType<BaseEntity>())
		{
			if (ShouldSendEntity(item))
			{
				OnEntityUpdate(item, sendNetworkUpdate: false);
			}
		}
		Debug.Log((object)$"Took {stopwatch.ElapsedMilliseconds}ms to load entities into GlobalNetworkHandler");
	}

	public void TrySendNetworkUpdate(BaseNetworkable net)
	{
		if (net is BaseEntity entity && ShouldSendEntity(entity))
		{
			OnEntityUpdate(entity);
		}
	}

	private void OnEntityUpdate(BaseEntity entity, bool sendNetworkUpdate = true)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		if (entity.net != null)
		{
			GlobalEntityData val = Pool.Get<GlobalEntityData>();
			val.prefabId = entity.prefabID;
			val.uid = entity.net.ID;
			val.pos = ((Component)entity).transform.position;
			Quaternion rotation = ((Component)entity).transform.rotation;
			val.rot = ((Quaternion)(ref rotation)).eulerAngles;
			if (entity is BuildingBlock buildingBlock)
			{
				val.grade = (int)buildingBlock.grade;
				val.modelState = buildingBlock.modelState;
				val.skin = buildingBlock.skinID;
				val.customColor = (int)buildingBlock.customColour;
			}
			if (entity is Door door)
			{
				val.flags = (int)(door.flags & Flags.Open);
			}
			if (serverData.TryGetValue(entity.net.ID, out var value))
			{
				Pool.Free<GlobalEntityData>(ref value);
			}
			serverData[entity.net.ID] = val;
			if (sendNetworkUpdate)
			{
				SendGlobalEntity(val, new SendInfo(Net.limit_global_update_broadcast ? globalConnections : Net.sv.connections));
			}
		}
	}

	public void OnEntityKilled(BaseNetworkable entity)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (serverData.Remove(entity.net.ID))
		{
			SendEntityDelete(entity.net.ID, new SendInfo(Net.limit_global_update_broadcast ? globalConnections : Net.sv.connections));
		}
	}

	public void StartSendingSnapshot(BasePlayer player)
	{
		OnClientConnected(player.Connection);
		if (!Net.limit_global_update_broadcast || player.Connection.globalNetworking)
		{
			SendAsSnapshot(player.Connection);
			SendSnapshot(player);
		}
	}

	private void SendSnapshot(BasePlayer player)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		if (!Net.globalNetworkedBases)
		{
			return;
		}
		Stopwatch stopwatch = Stopwatch.StartNew();
		GlobalEntityCollection val = Pool.Get<GlobalEntityCollection>();
		try
		{
			val.entities = Pool.Get<List<GlobalEntityData>>();
			foreach (GlobalEntityData value in serverData.Values)
			{
				val.entities.Add(value);
				if (val.entities.Count >= ConVar.Server.maxpacketsize_globalentities)
				{
					SendGlobalEntities(val, new SendInfo(player.Connection));
					val.entities.Clear();
				}
			}
			if (val.entities.Count > 0)
			{
				SendGlobalEntities(val, new SendInfo(player.Connection));
				val.entities.Clear();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		stopwatch.Stop();
		if (Net.global_network_debug)
		{
			Debug.Log((object)$"Took {stopwatch.ElapsedMilliseconds}ms to send {serverData.Count} global entities to {((object)player).ToString()}");
		}
	}

	private void SendEntityDelete(NetworkableId networkableId, SendInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (Net.globalNetworkedBases)
		{
			NetWrite val = ClientRPCStart("CLIENT_EntityDeletes");
			int num = Math.Min(ConVar.Server.maxpacketsize_globalentities, 1);
			val.UInt16((ushort)num);
			for (int i = 0; i < num; i++)
			{
				val.EntityID(networkableId);
			}
			ClientRPCSend(val, info);
		}
	}

	private void SendGlobalEntities(GlobalEntityCollection entities, SendInfo info)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (Net.globalNetworkedBases)
		{
			ClientRPC(RpcTarget.SendInfo("CLIENT_EntityUpdates", info), entities);
		}
	}

	private void SendGlobalEntity(GlobalEntityData entity, SendInfo info)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!Net.globalNetworkedBases)
		{
			return;
		}
		GlobalEntityCollection val = Pool.Get<GlobalEntityCollection>();
		try
		{
			val.entities = Pool.Get<List<GlobalEntityData>>();
			val.entities.Add(entity);
			SendGlobalEntities(val, info);
			val.entities.Clear();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class GrowableEntity : BaseCombatEntity, IInstanceDataReceiver, IHeatSourceListener
{
	public class GrowableEntityUpdateQueue : ObjectWorkQueue<GrowableEntity>
	{
		protected override void RunJob(GrowableEntity entity)
		{
			if (((ObjectWorkQueue<GrowableEntity>)this).ShouldAdd(entity))
			{
				entity.CalculateQualities_Water();
			}
		}

		protected override bool ShouldAdd(GrowableEntity entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.IsValid();
			}
			return false;
		}
	}

	public PlantProperties Properties;

	public ItemDefinition SourceItemDef;

	public float stageAge;

	public GrowableGenes Genes = new GrowableGenes();

	public const float startingHealth = 10f;

	public const float artificalLightQuality = 1f;

	public const float planterGroundModifierBase = 0.6f;

	public const float fertilizerGroundModifierBonus = 0.4f;

	public const float growthGeneSpeedMultiplier = 0.25f;

	public const float waterGeneRequirementMultiplier = 0.1f;

	public const float hardinessGeneModifierBonus = 0.2f;

	public const float hardinessGeneTemperatureModifierBonus = 0.05f;

	public const float baseYieldIncreaseMultiplier = 1f;

	public const float yieldGeneBonusMultiplier = 0.25f;

	public const float maxNonPlanterGroundQuality = 0.6f;

	public const float deathRatePerQuality = 0.1f;

	public TimeCachedValue<float> sunExposure;

	public TimeCachedValue<float> artificialLightExposure;

	public TimeCachedValue<float> artificialTemperatureExposure;

	[Help("How many miliseconds to budget for processing growable quality updates per frame")]
	[ServerVar]
	public static float framebudgetms = 0.25f;

	public const Flags GodSpawn = Flags.Reserved1;

	public static GrowableEntityUpdateQueue growableEntityUpdateQueue = new GrowableEntityUpdateQueue();

	public bool underWater;

	public int seasons;

	public int harvests;

	public float terrainTypeValue;

	public float yieldPool;

	public PlanterBox planter;

	public PlantProperties.State State { get; set; }

	public float Age { get; set; }

	public float LightQuality { get; set; }

	public float GroundQuality { get; set; } = 1f;

	public float WaterQuality { get; set; }

	public float WaterConsumption { get; set; }

	public bool Fertilized { get; set; }

	public float TemperatureQuality { get; set; }

	public float OverallQuality { get; set; }

	public float Yield { get; set; }

	public float StageProgressFraction => stageAge / currentStage.lifeLengthSeconds;

	public PlantProperties.Stage currentStage => Properties.stages[(int)State];

	public static float ThinkDeltaTime => ConVar.Server.planttick;

	public float growDeltaTime => ConVar.Server.planttick * ConVar.Server.planttickscale;

	public int CurrentPickAmount => Mathf.RoundToInt(CurrentPickAmountFloat);

	public float CurrentPickAmountFloat => (currentStage.resources + Yield) * (float)Properties.pickupMultiplier;

	private bool god => HasFlag(Flags.Reserved1);

	public float CurrentTemperature
	{
		get
		{
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)GetPlanter() != (Object)null)
			{
				return GetPlanter().GetPlantTemperature();
			}
			return Climate.GetTemperature(((Component)this).transform.position) + (artificialTemperatureExposure?.Get(force: false) ?? 0f);
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("GrowableEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 759768385 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_EatFruit "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_EatFruit", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(759768385u, "RPC_EatFruit", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(759768385u, "RPC_EatFruit", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_EatFruit(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_EatFruit");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 598660365 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_PickFruit "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_PickFruit", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(598660365u, "RPC_PickFruit", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(598660365u, "RPC_PickFruit", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_PickFruit(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_PickFruit");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3465633431u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_PickFruitAll "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_PickFruitAll", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3465633431u, "RPC_PickFruitAll", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3465633431u, "RPC_PickFruitAll", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_PickFruitAll(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_PickFruitAll");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1959480148 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RemoveDying "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RemoveDying", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1959480148u, "RPC_RemoveDying", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_RemoveDying(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_RemoveDying");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1771718099 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RemoveDyingAll "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RemoveDyingAll", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1771718099u, "RPC_RemoveDyingAll", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							RPC_RemoveDyingAll(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in RPC_RemoveDyingAll");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 232075937 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestQualityUpdate "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestQualityUpdate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(232075937u, "RPC_RequestQualityUpdate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							RPC_RequestQualityUpdate(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in RPC_RequestQualityUpdate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2222960834u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TakeClone "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TakeClone", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2222960834u, "RPC_TakeClone", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2222960834u, "RPC_TakeClone", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							RPC_TakeClone(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in RPC_TakeClone");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 95639240 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TakeCloneAll "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TakeCloneAll", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(95639240u, "RPC_TakeCloneAll", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(95639240u, "RPC_TakeCloneAll", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg9 = rPCMessage;
							RPC_TakeCloneAll(msg9);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogException(ex8);
						player.Kick("RPC Error in RPC_TakeCloneAll");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void ReceiveInstanceData(InstanceData data)
	{
		GrowableGeneEncoding.DecodeIntToGenes(data.dataInt, Genes);
		GrowableGeneEncoding.DecodeIntToPreviousGenes(data.dataInt, Genes);
	}

	public override void ResetState()
	{
		base.ResetState();
		State = PlantProperties.State.Seed;
	}

	private bool BlockedInDeepSea(BasePlayer player)
	{
		if (HasParent() && DeepSeaManager.IsInsideDeepSea((BaseNetworkable)this) && (Object)(object)DeepSeaManager.Get(base.isServer) != (Object)null)
		{
			return !DeepSeaManager.Get(base.isServer).HasPaidFoodToll(player);
		}
		return false;
	}

	public bool CanPick(BasePlayer player)
	{
		if (BlockedInDeepSea(player))
		{
			return false;
		}
		return currentStage.resources > 0f;
	}

	public bool CanTakeSeeds()
	{
		if (currentStage.resources > 0f)
		{
			return (Object)(object)Properties.SeedItem != (Object)null;
		}
		return false;
	}

	public bool CanClone(BasePlayer player)
	{
		if (BlockedInDeepSea(player))
		{
			return false;
		}
		if (currentStage.resources > 0f)
		{
			return (Object)(object)Properties.CloneItem != (Object)null;
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.growableEntity = Pool.Get<GrowableEntity>();
		info.msg.growableEntity.state = (int)State;
		info.msg.growableEntity.totalAge = Age;
		info.msg.growableEntity.stageAge = stageAge;
		info.msg.growableEntity.yieldFraction = Yield;
		info.msg.growableEntity.yieldPool = yieldPool;
		info.msg.growableEntity.fertilized = Fertilized;
		if (Genes != null)
		{
			Genes.Save(info);
		}
		if (!info.forDisk)
		{
			info.msg.growableEntity.lightModifier = LightQuality;
			info.msg.growableEntity.groundModifier = GroundQuality;
			info.msg.growableEntity.waterModifier = WaterQuality;
			info.msg.growableEntity.happiness = OverallQuality;
			info.msg.growableEntity.temperatureModifier = TemperatureQuality;
			info.msg.growableEntity.waterConsumption = WaterConsumption;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.growableEntity != null)
		{
			Age = info.msg.growableEntity.totalAge;
			stageAge = info.msg.growableEntity.stageAge;
			Yield = info.msg.growableEntity.yieldFraction;
			Fertilized = info.msg.growableEntity.fertilized;
			yieldPool = info.msg.growableEntity.yieldPool;
			Genes.Load(info);
			ChangeState((PlantProperties.State)info.msg.growableEntity.state, resetAge: false, loading: true);
		}
		else
		{
			Genes.GenerateRandom(this);
		}
	}

	public void ChangeState(PlantProperties.State state, bool resetAge, bool loading = false)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnGrowableStateChange", (object)this, (object)state) != null || (base.isServer && State == state))
		{
			return;
		}
		State = state;
		if (!base.isServer)
		{
			return;
		}
		if (!loading)
		{
			if (currentStage.resources > 0f)
			{
				yieldPool = currentStage.yield;
			}
			if (state == PlantProperties.State.Crossbreed)
			{
				if (Properties.CrossBreedEffect.isValid)
				{
					Effect.server.Run(Properties.CrossBreedEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
				}
				GrowableGenetics.CrossBreed(this);
			}
			SendNetworkUpdate();
		}
		if (resetAge)
		{
			stageAge = 0f;
		}
	}

	public void OnHeatSourceChanged()
	{
		CalculateQualities(firstTime: false, forceArtificialLightUpdates: false, forceArtificialTemperatureUpdates: true);
		SendNetworkUpdate();
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		float num = (((Object)(object)deployedBy.modifiers != (Object)null) ? deployedBy.modifiers.GetValue(Modifier.ModifierType.Farming_BetterGenes) : 0f);
		if (num != 0f && fromItem.instanceData == null)
		{
			Genes.GenerateFavourableGenes(this, num);
			SendNetworkUpdate();
		}
		if ((Object)(object)parent != (Object)null && parent is PlanterBox planterBox)
		{
			planterBox.OnPlantInserted(this, deployedBy);
		}
	}

	public void QueueForQualityUpdate()
	{
		((ObjectWorkQueue<GrowableEntity>)growableEntityUpdateQueue).Add(this);
	}

	public void SetGodQuality(bool qual)
	{
		SetFlag(Flags.Reserved1, qual);
	}

	public void CalculateQualities(bool firstTime, bool forceArtificialLightUpdates = false, bool forceArtificialTemperatureUpdates = false)
	{
		if (IsDead())
		{
			return;
		}
		if (god)
		{
			SetMaxGrowingConditions();
			return;
		}
		if (sunExposure == null)
		{
			sunExposure = new TimeCachedValue<float>
			{
				refreshCooldown = 30f,
				refreshRandomRange = 5f,
				updateValue = SunRaycast
			};
		}
		if (artificialLightExposure == null)
		{
			artificialLightExposure = new TimeCachedValue<float>
			{
				refreshCooldown = 60f,
				refreshRandomRange = 5f,
				updateValue = CalculateArtificialLightExposure
			};
		}
		if (artificialTemperatureExposure == null)
		{
			artificialTemperatureExposure = new TimeCachedValue<float>
			{
				refreshCooldown = 60f,
				refreshRandomRange = 5f,
				updateValue = CalculateArtificialTemperature
			};
		}
		if (forceArtificialTemperatureUpdates)
		{
			artificialTemperatureExposure.ForceNextRun();
		}
		CalculateLightQuality(forceArtificialLightUpdates || firstTime);
		CalculateWaterQuality();
		CalculateWaterConsumption();
		CalculateGroundQuality(firstTime);
		CalculateTemperatureQuality();
		CalculateOverallQuality();
	}

	private void CalculateQualities_Water()
	{
		CalculateWaterQuality();
		CalculateWaterConsumption();
		CalculateOverallQuality();
	}

	public void CalculateLightQuality(bool forceArtificalUpdate)
	{
		float num = Mathf.Clamp01(Properties.timeOfDayHappiness.Evaluate(TOD_Sky.Instance.Cycle.Hour));
		if (!ConVar.Server.plantlightdetection)
		{
			LightQuality = num;
			return;
		}
		LightQuality = CalculateSunExposure(forceArtificalUpdate) * num;
		if (LightQuality <= 0f)
		{
			LightQuality = GetArtificialLightExposure(forceArtificalUpdate);
		}
		LightQuality = RemapValue(LightQuality, 0f, Properties.OptimalLightQuality, 0f, 1f);
	}

	public float CalculateSunExposure(bool force)
	{
		if (TOD_Sky.Instance.IsNight)
		{
			return 0f;
		}
		if ((Object)(object)GetPlanter() != (Object)null)
		{
			return GetPlanter().GetSunExposure();
		}
		return sunExposure?.Get(force) ?? 0f;
	}

	public float SunRaycast()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return SunRaycast(((Component)this).transform.position + new Vector3(0f, 1f, 0f));
	}

	public float GetArtificialLightExposure(bool force)
	{
		if ((Object)(object)GetPlanter() != (Object)null)
		{
			return GetPlanter().GetArtificialLightExposure();
		}
		return artificialLightExposure?.Get(force) ?? 0f;
	}

	public float CalculateArtificialLightExposure()
	{
		return CalculateArtificialLightExposure(((Component)this).transform);
	}

	public static float CalculateArtificialLightExposure(Transform forTransform)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		float result = 0f;
		List<CeilingLight> list = Pool.Get<List<CeilingLight>>();
		Vector3 position = forTransform.position;
		float ceilingLightGrowableRange = ConVar.Server.ceilingLightGrowableRange;
		CeilingLight.FarmLightGrid.Query(position.x, position.z, ceilingLightGrowableRange, list);
		foreach (CeilingLight item in list)
		{
			if (!(item.SqrDistance(position) > ceilingLightGrowableRange * ceilingLightGrowableRange) && item.IsOn())
			{
				result = 1f;
				break;
			}
		}
		Pool.FreeUnmanaged<CeilingLight>(ref list);
		return result;
	}

	public static float SunRaycast(Vector3 checkPosition)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = TOD_Sky.Instance.Components.Sun.transform.position - checkPosition;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		RaycastHit val2 = default(RaycastHit);
		if (!Physics.Raycast(checkPosition, normalized, ref val2, 100f, 10551297))
		{
			return 1f;
		}
		return 0f;
	}

	public void CalculateWaterQuality()
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Invalid comparison between Unknown and I4
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Invalid comparison between Unknown and I4
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Invalid comparison between Unknown and I4
		if ((Object)(object)GetPlanter() != (Object)null)
		{
			float soilSaturationFraction = planter.soilSaturationFraction;
			if (soilSaturationFraction > ConVar.Server.optimalPlanterQualitySaturation)
			{
				WaterQuality = RemapValue(soilSaturationFraction, ConVar.Server.optimalPlanterQualitySaturation, 1f, 1f, 0.6f);
			}
			else
			{
				WaterQuality = RemapValue(soilSaturationFraction, 0f, ConVar.Server.optimalPlanterQualitySaturation, 0f, 1f);
			}
		}
		else
		{
			Enum val = (Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(((Component)this).transform.position);
			if (val - 1 > 1 && (int)val != 4)
			{
				if ((int)val == 8)
				{
					WaterQuality = 0.1f;
				}
				else
				{
					WaterQuality = 0f;
				}
			}
			else
			{
				WaterQuality = 0.3f;
			}
		}
		WaterQuality = Mathf.Clamp01(WaterQuality);
		WaterQuality = RemapValue(WaterQuality, 0f, Properties.OptimalWaterQuality, 0f, 1f);
	}

	public void CalculateGroundQuality(bool firstCheck)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (underWater && !firstCheck)
		{
			GroundQuality = 0f;
			return;
		}
		if (firstCheck)
		{
			Vector3 position = ((Component)this).transform.position;
			if (WaterLevel.Test(position, waves: true, volumes: true, this))
			{
				underWater = true;
				GroundQuality = 0f;
				return;
			}
			underWater = false;
			terrainTypeValue = GetGroundTypeValue(position);
		}
		if ((Object)(object)GetPlanter() != (Object)null)
		{
			GroundQuality = 0.6f;
			GroundQuality += (Fertilized ? 0.4f : 0f);
		}
		else
		{
			GroundQuality = terrainTypeValue;
			float num = (float)Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Hardiness) * 0.2f;
			float num2 = GroundQuality + num;
			GroundQuality = Mathf.Min(0.6f, num2);
		}
		GroundQuality = RemapValue(GroundQuality, 0f, Properties.OptimalGroundQuality, 0f, 1f);
	}

	public float GetGroundTypeValue(Vector3 pos)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Invalid comparison between Unknown and I4
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Invalid comparison between Unknown and I4
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected I4, but got Unknown
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Invalid comparison between Unknown and I4
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Invalid comparison between Unknown and I4
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Invalid comparison between Unknown and I4
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Invalid comparison between Unknown and I4
		Enum val = (Enum)TerrainMeta.SplatMap.GetSplatMaxType(pos);
		if ((int)val <= 16)
		{
			switch (val - 1)
			{
			default:
				if ((int)val != 8)
				{
					if ((int)val != 16)
					{
						break;
					}
					return 0.3f;
				}
				return 0f;
			case 1:
				return 0f;
			case 0:
				return 0.3f;
			case 3:
				return 0f;
			case 2:
				break;
			}
		}
		else
		{
			if ((int)val == 32)
			{
				return 0.2f;
			}
			if ((int)val == 64)
			{
				return 0f;
			}
			if ((int)val == 128)
			{
				return 0f;
			}
		}
		return 0.5f;
	}

	public void CalculateTemperatureQuality()
	{
		TemperatureQuality = Mathf.Clamp01(Properties.temperatureHappiness.Evaluate(CurrentTemperature));
		float num = (float)Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Hardiness) * 0.05f;
		TemperatureQuality = Mathf.Clamp01(TemperatureQuality + num);
		TemperatureQuality = RemapValue(TemperatureQuality, 0f, Properties.OptimalTemperatureQuality, 0f, 1f);
	}

	public void SetMaxGrowingConditions()
	{
		LightQuality = 1f;
		WaterQuality = 1f;
		GroundQuality = 1f;
		TemperatureQuality = 1f;
		OverallQuality = 1f;
	}

	public float CalculateOverallQuality()
	{
		float num = 1f;
		if (ConVar.Server.useMinimumPlantCondition)
		{
			num = Mathf.Min(num, LightQuality);
			num = Mathf.Min(num, WaterQuality);
			num = Mathf.Min(num, GroundQuality);
			num = Mathf.Min(num, TemperatureQuality);
		}
		else
		{
			num = LightQuality * WaterQuality * GroundQuality * TemperatureQuality;
		}
		OverallQuality = num;
		return OverallQuality;
	}

	public void CalculateWaterConsumption()
	{
		float num = Properties.temperatureWaterRequirementMultiplier.Evaluate(CurrentTemperature);
		float num2 = 1f + (float)Genes.GetGeneTypeCount(GrowableGenetics.GeneType.WaterRequirement) * 0.1f;
		WaterConsumption = Properties.WaterIntake * num * num2;
	}

	public float CalculateArtificialTemperature()
	{
		return CalculateArtificialTemperature(((Component)this).transform);
	}

	public static float CalculateArtificialTemperature(Transform forTransform)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = forTransform.position;
		List<GrowableHeatSource> list = Pool.Get<List<GrowableHeatSource>>();
		Vector3 position2 = forTransform.position;
		float artificialTemperatureGrowableRange = ConVar.Server.artificialTemperatureGrowableRange;
		GrowableHeatSource.FarmHeatSourceGrid.Query(position2.x, position2.z, artificialTemperatureGrowableRange, list);
		float num = 0f;
		foreach (GrowableHeatSource item in list)
		{
			if (!(Vector3.Distance(((Component)item.GetBaseEntity()).transform.position, position2) > artificialTemperatureGrowableRange))
			{
				num = Mathf.Max(item.ApplyHeat(position), num);
			}
		}
		Pool.FreeUnmanaged<GrowableHeatSource>(ref list);
		return num;
	}

	public int CalculateMarketValue()
	{
		int baseMarketValue = Properties.BaseMarketValue;
		int num = Genes.GetPositiveGeneCount() * 10;
		int num2 = Genes.GetNegativeGeneCount() * -10;
		baseMarketValue += num;
		baseMarketValue += num2;
		return Mathf.Max(0, baseMarketValue);
	}

	private static float RemapValue(float inValue, float minA, float maxA, float minB, float maxB)
	{
		if (inValue >= maxA)
		{
			return maxB;
		}
		float num = Mathf.InverseLerp(minA, maxA, inValue);
		return Mathf.Lerp(minB, maxB, num);
	}

	public bool IsFood()
	{
		if (Properties.pickupItem.category == ItemCategory.Food)
		{
			return (Object)(object)((Component)Properties.pickupItem).GetComponent<ItemModConsume>() != (Object)null;
		}
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)RunUpdate, ThinkDeltaTime, ThinkDeltaTime, ThinkDeltaTime * 0.1f);
		base.health = 10f;
		ResetSeason();
		Genes.GenerateRandom(this);
		if (!Application.isLoadingSave)
		{
			CalculateQualities(firstTime: true);
		}
	}

	public PlanterBox GetPlanter()
	{
		if ((Object)(object)planter == (Object)null)
		{
			BaseEntity baseEntity = GetParentEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				planter = baseEntity as PlanterBox;
			}
		}
		return planter;
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		planter = newParent as PlanterBox;
		if (!Application.isLoadingSave && (Object)(object)planter != (Object)null)
		{
			planter.FertilizeGrowables();
		}
		CalculateQualities(firstTime: true);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		CalculateQualities(firstTime: true);
	}

	public void ResetSeason()
	{
		Yield = 0f;
		yieldPool = 0f;
	}

	public void RunUpdate()
	{
		if (!IsDead())
		{
			CalculateQualities(firstTime: false);
			float overallQuality = CalculateOverallQuality();
			float actualStageAgeIncrease = UpdateAge(overallQuality);
			UpdateHealthAndYield(overallQuality, actualStageAgeIncrease);
			if (base.health <= 0f)
			{
				TellPlanter();
				Die();
			}
			else
			{
				UpdateState();
				ConsumeWater();
				SendNetworkUpdate();
			}
		}
	}

	public float UpdateAge(float overallQuality)
	{
		Age += growDeltaTime;
		float num = (currentStage.IgnoreConditions ? 1f : (Mathf.Max(overallQuality, 0f) * GetGrowthBonus(overallQuality)));
		float num2 = growDeltaTime * num;
		stageAge += num2;
		return num2;
	}

	public void UpdateHealthAndYield(float overallQuality, float actualStageAgeIncrease)
	{
		if ((Object)(object)GetPlanter() == (Object)null && Random.Range(0f, 1f) <= ConVar.Server.nonPlanterDeathChancePerTick)
		{
			base.health = 0f;
			return;
		}
		if (overallQuality <= 0f)
		{
			ApplyDeathRate();
		}
		base.health += overallQuality * currentStage.health * growDeltaTime;
		if (yieldPool > 0f)
		{
			float num = currentStage.yield / (currentStage.lifeLengthSeconds / growDeltaTime);
			float num2 = Mathf.Min(yieldPool, num * (actualStageAgeIncrease / growDeltaTime));
			yieldPool -= num;
			float num3 = 1f + (float)Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) * 0.25f;
			Yield += num2 * 1f * num3;
		}
	}

	public void ApplyDeathRate()
	{
		float num = 0f;
		if (WaterQuality <= 0f)
		{
			num += 0.1f;
		}
		if (LightQuality <= 0f)
		{
			num += 0.1f;
		}
		if (GroundQuality <= 0f)
		{
			num += 0.1f;
		}
		if (TemperatureQuality <= 0f)
		{
			num += 0.1f;
		}
		base.health -= num;
	}

	public float GetGrowthBonus(float overallQuality)
	{
		float result = 1f + (float)Genes.GetGeneTypeCount(GrowableGenetics.GeneType.GrowthSpeed) * 0.25f;
		if (overallQuality <= 0f)
		{
			result = 1f;
		}
		return result;
	}

	public PlantProperties.State UpdateState()
	{
		if (stageAge <= currentStage.lifeLengthSeconds)
		{
			return State;
		}
		if (State == PlantProperties.State.Dying)
		{
			TellPlanter();
			Die();
			return PlantProperties.State.Dying;
		}
		if (currentStage.nextState <= State)
		{
			seasons++;
		}
		if (seasons >= Properties.MaxSeasons)
		{
			ChangeState(PlantProperties.State.Dying, resetAge: true);
		}
		else
		{
			ChangeState(currentStage.nextState, resetAge: true);
		}
		return State;
	}

	public void ConsumeWater()
	{
		if (State != PlantProperties.State.Dying && !((Object)(object)GetPlanter() == (Object)null))
		{
			int num = Mathf.CeilToInt(Mathf.Min((float)planter.soilSaturation, WaterConsumption));
			if ((float)num > 0f)
			{
				planter.ConsumeWater(num, this);
			}
		}
	}

	public void Fertilize()
	{
		if (!Fertilized)
		{
			Fertilized = true;
			CalculateQualities(firstTime: false);
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_TakeClone(RPCMessage msg)
	{
		TakeClones(msg.player);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_TakeCloneAll(RPCMessage msg)
	{
		if ((Object)(object)GetParentEntity() != (Object)null)
		{
			List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
			foreach (BaseEntity child in GetParentEntity().children)
			{
				if ((Object)(object)child != (Object)(object)this && child is GrowableEntity item)
				{
					list.Add(item);
				}
			}
			foreach (GrowableEntity item2 in list)
			{
				item2.TakeClones(msg.player);
			}
			Pool.FreeUnmanaged<GrowableEntity>(ref list);
		}
		TakeClones(msg.player);
	}

	public void TakeClones(BasePlayer player)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null || !CanClone(player) || Interface.CallHook("CanTakeCutting", (object)player, (object)this) != null)
		{
			return;
		}
		int num = Properties.BaseCloneCount + Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) / 2;
		if (num > 0)
		{
			Item item = ItemManager.Create(Properties.CloneItem, num, 0uL);
			item.SetItemOwnership(player, ItemOwnershipPhrases.Cloned);
			GrowableGeneEncoding.EncodeGenesToItem(this, item);
			Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);
			player.GiveItem(item, GiveItemReason.ResourceHarvested, GiveItemOptions.BackpackOverflow);
			if (Properties.pickEffect.isValid)
			{
				Effect.server.Run(Properties.pickEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
			TellPlanter();
			Die();
		}
	}

	public void PickFruit(BasePlayer player, bool eat = false)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		if (!CanPick(player) || Interface.CallHook("OnGrowableGather", (object)this, (object)player, (object)eat) != null)
		{
			return;
		}
		harvests++;
		GiveFruit(player, CurrentPickAmount, eat);
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(player, ((Component)this).transform.position);
		}
		ResetSeason();
		if (Properties.pickEffect.isValid)
		{
			Effect.server.Run(Properties.pickEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		}
		if (harvests >= Properties.maxHarvests)
		{
			if (Properties.disappearAfterHarvest)
			{
				TellPlanter();
				Die();
			}
			else
			{
				ChangeState(PlantProperties.State.Dying, resetAge: true);
			}
		}
		else
		{
			ChangeState(PlantProperties.State.Mature, resetAge: true);
		}
	}

	public void GiveFruit(BasePlayer player, int amount, bool eat)
	{
		if (amount <= 0)
		{
			return;
		}
		bool enabled = Properties.pickupItem.condition.enabled;
		if (enabled)
		{
			for (int i = 0; i < amount; i++)
			{
				GiveFruit(player, 1, enabled, eat);
			}
		}
		else
		{
			GiveFruit(player, amount, enabled, eat);
		}
	}

	public void GiveFruit(BasePlayer player, int amount, bool applyCondition, bool eat)
	{
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		Item item = ItemManager.Create(Properties.pickupItem, amount, 0uL);
		item.SetItemOwnership(player, ItemOwnershipPhrases.Harvested);
		if (applyCondition)
		{
			item.conditionNormalized = Properties.fruitVisualScaleCurve.Evaluate(StageProgressFraction);
		}
		if (eat && (Object)(object)player != (Object)null && IsFood())
		{
			ItemModConsume component = ((Component)item.info).GetComponent<ItemModConsume>();
			if ((Object)(object)component != (Object)null)
			{
				component.DoAction(item, player);
				return;
			}
		}
		if ((Object)(object)player != (Object)null)
		{
			Interface.CallHook("OnGrowableGathered", (object)this, (object)item, (object)player);
			Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);
			player.GiveItem(item, GiveItemReason.ResourceHarvested, GiveItemOptions.BackpackOverflow);
		}
		else
		{
			item.Drop(((Component)this).transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_PickFruit(RPCMessage msg)
	{
		PickFruit(msg.player);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_EatFruit(RPCMessage msg)
	{
		PickFruit(msg.player, eat: true);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_PickFruitAll(RPCMessage msg)
	{
		if ((Object)(object)GetParentEntity() != (Object)null)
		{
			List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
			foreach (BaseEntity child in GetParentEntity().children)
			{
				if ((Object)(object)child != (Object)(object)this && child is GrowableEntity item)
				{
					list.Add(item);
				}
			}
			foreach (GrowableEntity item2 in list)
			{
				item2.PickFruit(msg.player);
			}
			Pool.FreeUnmanaged<GrowableEntity>(ref list);
		}
		PickFruit(msg.player);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_RemoveDying(RPCMessage msg)
	{
		RemoveDying(msg.player);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_RemoveDyingAll(RPCMessage msg)
	{
		if ((Object)(object)GetParentEntity() != (Object)null)
		{
			List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
			foreach (BaseEntity child in GetParentEntity().children)
			{
				if ((Object)(object)child != (Object)(object)this && child is GrowableEntity item)
				{
					list.Add(item);
				}
			}
			foreach (GrowableEntity item2 in list)
			{
				item2.RemoveDying(msg.player);
			}
			Pool.FreeUnmanaged<GrowableEntity>(ref list);
		}
		RemoveDying(msg.player);
	}

	public void RemoveAllForce()
	{
		if ((Object)(object)GetParentEntity() != (Object)null)
		{
			List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
			foreach (BaseEntity child in GetParentEntity().children)
			{
				if ((Object)(object)child != (Object)(object)this && child is GrowableEntity item)
				{
					list.Add(item);
				}
			}
			foreach (GrowableEntity item2 in list)
			{
				item2.RemoveDying(null);
			}
			Pool.FreeUnmanaged<GrowableEntity>(ref list);
		}
		ForceRemove();
	}

	public void ForceRemove()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)Properties.removeDyingItem == (Object)null))
		{
			if (Properties.removeDyingEffect.isValid)
			{
				Effect.server.Run(Properties.removeDyingEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
			TellPlanter();
			Die();
		}
	}

	public void RemoveDying(BasePlayer receiver)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		if (State == PlantProperties.State.Dying && !((Object)(object)Properties.removeDyingItem == (Object)null) && Interface.CallHook("OnRemoveDying", (object)this, (object)receiver) == null)
		{
			if (Properties.removeDyingEffect.isValid)
			{
				Effect.server.Run(Properties.removeDyingEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
			Item item = ItemManager.Create(Properties.removeDyingItem, 1, 0uL);
			if ((Object)(object)receiver != (Object)null)
			{
				receiver.GiveItem(item, GiveItemReason.PickedUp, GiveItemOptions.BackpackOverflow);
			}
			else
			{
				item.Drop(((Component)this).transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
			}
			TellPlanter();
			Die();
		}
	}

	private void TellPlanter()
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity is PlanterBox planterBox)
		{
			planterBox.OnPlantRemoved(this, null);
		}
	}

	[ServerVar(ServerAdmin = true)]
	public static void GrowAll(Arg arg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin)
		{
			return;
		}
		List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
		Vis.Entities(basePlayer.ServerPosition, 6f, list, -1, (QueryTriggerInteraction)2);
		foreach (GrowableEntity item in list)
		{
			if (item.isServer)
			{
				item.ChangeState(item.currentStage.nextState, resetAge: false);
			}
		}
		Pool.FreeUnmanaged<GrowableEntity>(ref list);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_RequestQualityUpdate(RPCMessage msg)
	{
		if ((Object)(object)msg.player != (Object)null)
		{
			GrowableEntity val = Pool.Get<GrowableEntity>();
			val.lightModifier = LightQuality;
			val.groundModifier = GroundQuality;
			val.waterModifier = WaterQuality;
			val.happiness = OverallQuality;
			val.temperatureModifier = TemperatureQuality;
			val.waterConsumption = WaterConsumption;
			ClientRPC(RpcTarget.Player("RPC_ReceiveQualityUpdate", msg.player), val);
		}
	}
}


public class GrowableEntityUpdateQueue : ObjectWorkQueue<GrowableEntity>
{
	protected override void RunJob(GrowableEntity entity)
	{
		if (((ObjectWorkQueue<GrowableEntity>)this).ShouldAdd(entity))
		{
			entity.CalculateQualities_Water();
		}
	}

	protected override bool ShouldAdd(GrowableEntity entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.IsValid();
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;

public class GunTrap : StorageContainer
{
	public class GunTrapScanWorkQueue : PersistentObjectWorkQueue<GunTrap>
	{
		protected override void RunJob(GunTrap entity)
		{
			if (((PersistentObjectWorkQueue<GunTrap>)this).ShouldAdd(entity))
			{
				entity.ServerThink();
			}
		}

		protected override bool ShouldAdd(GunTrap entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.IsValid();
			}
			return false;
		}
	}

	public GameObjectRef gun_fire_effect;

	public GameObjectRef bulletEffect;

	public GameObjectRef triggeredEffect;

	public Transform muzzlePos;

	public Transform eyeTransform;

	public int numPellets = 15;

	public int aimCone = 30;

	public float sensorRadius = 1.25f;

	public ItemDefinition ammoType;

	public TargetTrigger trigger;

	public const Flags Flag_Triggered = Flags.Reserved4;

	private float triggeredTime;

	private readonly float triggerCooldownDuration = 0.5f;

	private float triggerCooldown;

	private BuildingPrivlidge _cachedTc;

	private float _cacheTimeout;

	[ServerVar(Help = "How many milliseconds to spend on target scanning per frame")]
	public static float gun_trap_budget_ms = 0.5f;

	public static GunTrapScanWorkQueue updateGunTrapWorkQueue = new GunTrapScanWorkQueue();

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("GunTrap.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override string Categorize()
	{
		return "GunTrap";
	}

	public bool IsTriggered()
	{
		return HasFlag(Flags.Reserved4);
	}

	public Vector3 GetEyePosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return eyeTransform.position;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((PersistentObjectWorkQueue<GunTrap>)updateGunTrapWorkQueue).Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		((PersistentObjectWorkQueue<GunTrap>)updateGunTrapWorkQueue).Remove(this);
	}

	public void ServerThink()
	{
		if (IsTriggered() && Time.realtimeSinceStartup - triggeredTime > triggerCooldownDuration)
		{
			SetTriggered(triggered: false);
		}
		if (!(triggerCooldown > Time.realtimeSinceStartup) && CanFire() && CheckTrigger())
		{
			SetTriggered(triggered: true);
			FireWeapon();
			triggerCooldown = Time.realtimeSinceStartup + triggerCooldownDuration;
		}
	}

	public bool CheckTrigger()
	{
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		List<RaycastHit> list = null;
		try
		{
			HashSet<BaseEntity> entityContents = trigger.entityContents;
			if (entityContents == null || entityContents.Count == 0)
			{
				return false;
			}
			if (!CanFire())
			{
				return false;
			}
			bool flag = false;
			bool flag2 = false;
			BuildingPrivlidge buildingPrivlidge = null;
			foreach (BaseEntity item in entityContents)
			{
				BasePlayer basePlayer = item as BasePlayer;
				if ((Object)(object)basePlayer == (Object)null || basePlayer.IsSleeping() || !basePlayer.IsAlive())
				{
					continue;
				}
				object obj = Interface.CallHook("CanBeTargeted", (object)basePlayer, (object)this);
				if (obj is bool)
				{
					flag = (bool)obj;
					break;
				}
				if (!flag2)
				{
					flag2 = true;
					buildingPrivlidge = GetCachedTc();
				}
				if ((Object)(object)buildingPrivlidge != (Object)null && buildingPrivlidge.IsAuthed(basePlayer))
				{
					continue;
				}
				if (list == null)
				{
					list = Pool.Get<List<RaycastHit>>();
				}
				else
				{
					list.Clear();
				}
				Vector3 position = basePlayer.eyes.position;
				Vector3 val = GetEyePosition() - basePlayer.eyes.position;
				GamePhysics.TraceAll(new Ray(position, ((Vector3)(ref val)).normalized), 0f, list, 9f, 1218519297, (QueryTriggerInteraction)0);
				for (int i = 0; i < list.Count; i++)
				{
					BaseEntity entity = list[i].GetEntity();
					if ((Object)(object)entity != (Object)null && ((Object)(object)entity == (Object)(object)this || entity.EqualNetID((BaseNetworkable)this)))
					{
						flag = true;
						break;
					}
					if (!((Object)(object)entity != (Object)null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
			return flag;
		}
		finally
		{
			if (list != null)
			{
				Pool.FreeUnmanaged<RaycastHit>(ref list);
			}
		}
	}

	public void FireWeapon()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (UseAmmo())
		{
			Effect.server.Run(gun_fire_effect.resourcePath, this, StringPool.Get(((Object)((Component)muzzlePos).gameObject).name), Vector3.zero, Vector3.zero);
			for (int i = 0; i < numPellets; i++)
			{
				FireBullet();
			}
		}
	}

	public void FireBullet()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		float damageAmount = 10f;
		Vector3 val = ((Component)muzzlePos).transform.position - muzzlePos.forward * 0.25f;
		Vector3 val2 = AimConeUtil.GetModifiedAimConeDirection(inputVec: ((Component)muzzlePos).transform.forward, aimCone: aimCone);
		ClientRPC(arg1: val + val2 * 300f, target: RpcTarget.NetworkGroup("CLIENT_FireGun"));
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		int layerMask = 1220225793;
		GamePhysics.TraceAll(new Ray(val, val2), 0.1f, list, 300f, layerMask, (QueryTriggerInteraction)0);
		for (int i = 0; i < list.Count; i++)
		{
			RaycastHit hit = list[i];
			BaseEntity entity = hit.GetEntity();
			if ((Object)(object)entity != (Object)null && ((Object)(object)entity == (Object)(object)this || entity.EqualNetID((BaseNetworkable)this)))
			{
				continue;
			}
			if ((Object)(object)(entity as BaseCombatEntity) != (Object)null)
			{
				HitInfo info = new HitInfo(this, entity, DamageType.Bullet, damageAmount, ((RaycastHit)(ref hit)).point);
				entity.OnAttacked(info);
				if (entity is BasePlayer || entity is BaseNpc)
				{
					Effect.server.ImpactEffect(new HitInfo
					{
						HitPositionWorld = ((RaycastHit)(ref hit)).point,
						HitNormalWorld = -((RaycastHit)(ref hit)).normal,
						HitMaterial = StringPool.Get("Flesh")
					});
				}
			}
			if (!((Object)(object)entity != (Object)null) || entity.ShouldBlockProjectiles())
			{
				Vector3 point = ((RaycastHit)(ref hit)).point;
				break;
			}
		}
	}

	public bool CanFire()
	{
		foreach (Item item in base.inventory.itemList)
		{
			if ((Object)(object)item.info == (Object)(object)ammoType && item.amount > 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool UseAmmo()
	{
		foreach (Item item in base.inventory.itemList)
		{
			if ((Object)(object)item.info == (Object)(object)ammoType && item.amount > 0)
			{
				item.UseItem();
				return true;
			}
		}
		return false;
	}

	private BuildingPrivlidge GetCachedTc()
	{
		if ((Object)(object)_cachedTc != (Object)null && _cachedTc.IsDestroyed)
		{
			_cachedTc = null;
		}
		if ((Object)(object)_cachedTc == (Object)null || Time.realtimeSinceStartup > _cacheTimeout)
		{
			_cachedTc = null;
			BuildingManager.Building building = GetBuilding();
			if (building != null)
			{
				_cachedTc = building.GetDominatingBuildingPrivilege();
			}
			if ((Object)(object)_cachedTc == (Object)null)
			{
				return GetNearestBuildingPrivilege(cached: true, 3f);
			}
			_cacheTimeout = Time.realtimeSinceStartup + 3f;
		}
		return _cachedTc;
	}

	public void SetTriggered(bool triggered)
	{
		if (triggered && CanFire())
		{
			triggeredTime = Time.realtimeSinceStartup;
		}
		SetFlag(Flags.Reserved4, triggered && CanFire());
	}
}


public class GunTrapScanWorkQueue : PersistentObjectWorkQueue<GunTrap>
{
	protected override void RunJob(GunTrap entity)
	{
		if (((PersistentObjectWorkQueue<GunTrap>)this).ShouldAdd(entity))
		{
			entity.ServerThink();
		}
	}

	protected override bool ShouldAdd(GunTrap entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.IsValid();
		}
		return false;
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UI;

public class HackableLockedCrate : LootContainer
{
	public const Flags Flag_Hacking = Flags.Reserved1;

	public const Flags Flag_FullyHacked = Flags.Reserved2;

	public Text timerText;

	[ServerVar(Help = "How many seconds for the crate to unlock")]
	public static float requiredHackSeconds = 900f;

	[ServerVar(Help = "How many seconds until the crate is destroyed without any hack attempts")]
	public static float decaySeconds = 7200f;

	public SoundPlayer hackProgressBeep;

	public float hackSeconds;

	public GameObjectRef shockEffect;

	public GameObjectRef mapMarkerEntityPrefab;

	public GameObjectRef landEffect;

	public bool shouldDecay = true;

	public bool shouldParent = true;

	public BasePlayer originalHackerPlayer;

	public ulong originalHackerPlayerId;

	public bool hasBeenOpened;

	public BaseEntity mapMarkerInstance;

	public bool hasLanded;

	public bool wasDropped;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HackableLockedCrate.OnRpcMessage", 0);
		try
		{
			if (rpc == 888500940 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Hack "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Hack", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(888500940u, "RPC_Hack", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Hack(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Hack");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsBeingHacked()
	{
		return HasFlag(Flags.Reserved1);
	}

	public bool IsFullyHacked()
	{
		return HasFlag(Flags.Reserved2);
	}

	public override void DestroyShared()
	{
		if (base.isServer && Object.op_Implicit((Object)(object)mapMarkerInstance))
		{
			mapMarkerInstance.Kill();
		}
		base.DestroyShared();
	}

	public void CreateMapMarker(float durationMinutes)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if (mapMarkerEntityPrefab.isValid)
		{
			if (Object.op_Implicit((Object)(object)mapMarkerInstance))
			{
				mapMarkerInstance.Kill();
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, ((Component)this).transform.position, Quaternion.identity);
			if (shouldParent)
			{
				baseEntity.SetParent(this);
				((Component)baseEntity).transform.localPosition = Vector3.zero;
			}
			baseEntity.Spawn();
			baseEntity.SendNetworkUpdate();
			mapMarkerInstance = baseEntity;
		}
	}

	public void RefreshDecay()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)DelayedDestroy);
		if (shouldDecay)
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, decaySeconds);
		}
	}

	public void DelayedDestroy()
	{
		Kill();
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			if (StringPool.Get(info.HitBone) == "laptopcollision")
			{
				if (Interface.CallHook("OnCrateLaptopAttack", (object)this, (object)info) != null)
				{
					return;
				}
				Effect.server.Run(shockEffect.resourcePath, this, info.HitBone, info.HitPositionLocal, Vector3.up);
				hackSeconds -= 8f * (info.damageTypes.Total() / 50f);
				if (hackSeconds < 0f)
				{
					hackSeconds = 0f;
				}
			}
			RefreshDecay();
		}
		base.OnAttacked(info);
	}

	public void SetWasDropped()
	{
		wasDropped = true;
		Interface.CallHook("OnCrateDropped", (object)this);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (base.isClient)
		{
			return;
		}
		if (!Application.isLoadingSave)
		{
			SetFlag(Flags.Reserved1, b: false);
			SetFlag(Flags.Reserved2, b: false);
			if (wasDropped)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)LandCheck, 0f, 0.015f);
			}
		}
		RefreshDecay();
		isLootable = IsFullyHacked();
		CreateMapMarker(120f);
		base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		if (!added && (Object)(object)mapMarkerInstance != (Object)null)
		{
			mapMarkerInstance.Kill();
		}
		base.OnItemAddedOrRemoved(item, added);
	}

	public void LandCheck()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (!hasLanded && Physics.Raycast(new Ray(((Component)this).transform.position + Vector3.up * 0.5f, Vector3.down), ref val, 1f, 1084293377))
		{
			Effect.server.Run(landEffect.resourcePath, ((RaycastHit)(ref val)).point, Vector3.up);
			hasLanded = true;
			Interface.CallHook("OnCrateLanded", (object)this);
			((FacepunchBehaviour)this).CancelInvoke((Action)LandCheck);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Reserved1, b: false);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Hack(RPCMessage msg)
	{
		if (!IsBeingHacked() && Interface.CallHook("CanHackCrate", (object)msg.player, (object)this) == null)
		{
			Analytics.Azure.OnLockedCrateStarted(msg.player, this);
			originalHackerPlayerId = msg.player.userID;
			originalHackerPlayer = msg.player;
			StartHacking();
		}
	}

	public void StartHacking()
	{
		Interface.CallHook("OnCrateHack", (object)this);
		BroadcastEntityMessage("HackingStarted", 20f, 257);
		SetFlag(Flags.Reserved1, b: true);
		OnStartHacking();
		((FacepunchBehaviour)this).InvokeRepeating((Action)HackProgress, 1f, 1f);
		ClientRPC(RpcTarget.NetworkGroup("UpdateHackProgress"), 0, (int)requiredHackSeconds);
		RefreshDecay();
	}

	protected virtual void OnStartHacking()
	{
	}

	public void HackProgress()
	{
		hackSeconds += 1f;
		if (hackSeconds > requiredHackSeconds)
		{
			Interface.CallHook("OnCrateHackEnd", (object)this);
			Analytics.Azure.OnLockedCrateFinished(originalHackerPlayerId, this);
			if ((Object)(object)originalHackerPlayer != (Object)null && originalHackerPlayer.serverClan != null)
			{
				originalHackerPlayer.AddClanScore((ClanScoreEventType)5);
			}
			RefreshDecay();
			SetFlag(Flags.Reserved2, b: true);
			isLootable = true;
			((FacepunchBehaviour)this).CancelInvoke((Action)HackProgress);
		}
		ClientRPC(RpcTarget.NetworkGroup("UpdateHackProgress"), (int)hackSeconds, (int)requiredHackSeconds);
	}

	public override bool OnStartBeingLooted(BasePlayer player)
	{
		bool num = base.OnStartBeingLooted(player);
		if (num && !hasBeenOpened)
		{
			hasBeenOpened = true;
			player.AddClanScore((ClanScoreEventType)6);
		}
		return num;
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class Handcuffs : BaseMelee
{
	public static int PrisonerHoodItemID = -892718768;

	[ServerVar]
	public static float restrainedPushDamage = 5f;

	[ServerVar]
	public static float maxConditionRepairLossOnPush = 0.4f;

	[Header("Handcuffs")]
	public AnimatorOverrideController CaptiveHoldAnimationOverride;

	public GameObjectRef lockEffect;

	public GameObjectRef escapeEffect;

	[Header("Handcuff Behaviour")]
	public bool BlockInventory = true;

	public bool BlockSuicide = true;

	public bool BlockUse = true;

	public bool BlockCrafting = true;

	public float UnlockMiniGameDuration = 60f;

	public float UseDistance = 1.8f;

	public float ConditionLossPerSecond = 1f;

	private float unlockStartTime;

	private float startCondition;

	public bool Locked
	{
		get
		{
			if (GetItem() != null)
			{
				return GetItem().IsOn();
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Handcuffs.OnRpcMessage", 0);
		try
		{
			if (rpc == 695796023 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqCancelUnlockMiniGame "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqCancelUnlockMiniGame", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(695796023u, "RPC_ReqCancelUnlockMiniGame", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(695796023u, "RPC_ReqCancelUnlockMiniGame", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_ReqCancelUnlockMiniGame(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_ReqCancelUnlockMiniGame");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3883360127u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqCompleteUnlockMiniGame "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqCompleteUnlockMiniGame", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3883360127u, "RPC_ReqCompleteUnlockMiniGame", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(3883360127u, "RPC_ReqCompleteUnlockMiniGame", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_ReqCompleteUnlockMiniGame(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_ReqCompleteUnlockMiniGame");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1571851761 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqLock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqLock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1571851761u, "RPC_ReqLock", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1571851761u, "RPC_ReqLock", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							RPC_ReqLock(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_ReqLock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3248381320u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqStartUnlockMiniGame "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqStartUnlockMiniGame", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3248381320u, "RPC_ReqStartUnlockMiniGame", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(3248381320u, "RPC_ReqStartUnlockMiniGame", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc5 = rPCMessage;
							RPC_ReqStartUnlockMiniGame(rpc5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_ReqStartUnlockMiniGame");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		Item item = GetItem();
		if (base.isServer && item != null)
		{
			SetLocked(Locked);
		}
		SetWMLocked(Locked);
	}

	private void SetWMLocked(bool flag)
	{
	}

	private void StartUnlockMiniGame()
	{
		InterruptUnlockMiniGame();
		unlockStartTime = Time.realtimeSinceStartup;
	}

	public void HeldWhenOwnerDied(BasePlayer player)
	{
		if (Locked)
		{
			SetLocked(flag: false, player);
		}
	}

	public void SetLocked(bool flag, BasePlayer player = null, Item handcuffsItem = null)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		if (handcuffsItem == null)
		{
			handcuffsItem = GetOwnerItem();
		}
		handcuffsItem?.SetFlag(Item.Flag.IsOn, flag);
		if ((Object)(object)player == (Object)null)
		{
			player = GetOwnerPlayer();
		}
		if (!((Object)(object)player == (Object)null))
		{
			player.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, flag);
			if (handcuffsItem != null)
			{
				player.restraintItemId = (flag ? new ItemId?(handcuffsItem.uid) : ((ItemId?)null));
			}
			else
			{
				player.restraintItemId = null;
			}
			if (BlockInventory)
			{
				player.inventory.SetLockedByRestraint(flag);
			}
			ClientRPC(RpcTarget.Player("CL_SetLocked", player), Locked);
		}
	}

	[ServerVar]
	public static void togglecuffslocked(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		HeldEntity heldEntity = basePlayer.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			Handcuffs handcuffs = heldEntity as Handcuffs;
			if (!((Object)(object)handcuffs == (Object)null))
			{
				handcuffs.SetLocked(!handcuffs.Locked, basePlayer);
			}
		}
	}

	private void ModifyConditionForElapsedTime(float elapsed)
	{
		if (unlockStartTime <= 0f || elapsed <= 0f)
		{
			return;
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem == null)
		{
			return;
		}
		float num = elapsed * ConditionLossPerSecond;
		if (num + 1f >= ownerItem.condition)
		{
			num = ownerItem.condition;
		}
		if (!(num > 1f) && !(num >= ownerItem.condition))
		{
			return;
		}
		ownerItem.condition -= num;
		if (ownerItem.condition <= 0f)
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				ownerPlayer.ApplyWoundedStartTime();
			}
			SetLocked(flag: false);
			ownerItem.UseItem();
		}
	}

	public void RepairOnPush()
	{
		if (base.isServer)
		{
			GetOwnerItem()?.DoRepair(maxConditionRepairLossOnPush);
		}
	}

	public void InterruptUnlockMiniGame(bool wasPushedOrDamaged = false)
	{
		if (base.isServer && unlockStartTime > 0f && !wasPushedOrDamaged)
		{
			ModifyConditionForElapsedTime(Time.realtimeSinceStartup - unlockStartTime);
		}
		unlockStartTime = 0f;
		if (base.isServer)
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if (!((Object)(object)ownerPlayer == (Object)null))
			{
				ClientRPC(RpcTarget.Player("CL_CancelUnlockMiniGame", ownerPlayer), wasPushedOrDamaged ? 2f : 0f);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(5uL)]
	private void RPC_ReqStartUnlockMiniGame(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null))
		{
			SV_StartUnlockMiniGame(player);
		}
	}

	private void SV_StartUnlockMiniGame(BasePlayer player)
	{
		if (!player.IsDead() && !player.IsWounded())
		{
			StartUnlockMiniGame();
			ClientRPC(RpcTarget.Player("CL_StartUnlockMiniGame", player));
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	private void RPC_ReqCancelUnlockMiniGame(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null))
		{
			SV_CancelUnlockMiniGame(player);
		}
	}

	private void SV_CancelUnlockMiniGame(BasePlayer player)
	{
		InterruptUnlockMiniGame();
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	private void RPC_ReqCompleteUnlockMiniGame(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null))
		{
			SV_ReqCompleteUnlockMiniGame(player);
		}
	}

	private void SV_ReqCompleteUnlockMiniGame(BasePlayer player)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		InterruptUnlockMiniGame();
		Effect.server.Run(escapeEffect.resourcePath, player, 0u, Vector3.zero, Vector3.zero);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void RPC_ReqLock(RPCMessage rpc)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null))
		{
			NetworkableId uid = rpc.read.EntityID();
			BasePlayer basePlayer = BaseNetworkable.serverEntities.Find(uid) as BasePlayer;
			if (!((Object)(object)basePlayer == (Object)null))
			{
				SV_HandcuffVictim(basePlayer, player);
			}
		}
	}

	private void SV_HandcuffVictim(BasePlayer victim, BasePlayer handcuffer)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)victim == (Object)null || (Object)(object)handcuffer == (Object)null || victim.IsRestrained || (!victim.CurrentGestureIsSurrendering && !victim.IsWounded()) || Vector3.Distance(((Component)victim).transform.position, ((Component)handcuffer).transform.position) > UseDistance)
		{
			return;
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem == null || Interface.CallHook("OnPlayerHandcuff", (object)victim, (object)handcuffer) != null)
		{
			return;
		}
		victim.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, b: true);
		victim.SendNetworkUpdateImmediate();
		ownerItem.SetFlag(Item.Flag.IsOn, b: true);
		bool flag = true;
		if (!ownerItem.MoveToContainer(victim.inventory.containerBelt))
		{
			Item slot = victim.inventory.containerBelt.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(victim.inventory.containerMain))
				{
					if (slot.contents != null)
					{
						slot.contents.SetLocked(isLocked: false, lockSubItems: true);
					}
					slot.DropAndTossUpwards(((Component)victim).transform.position);
				}
				if (!ownerItem.MoveToContainer(victim.inventory.containerBelt))
				{
					flag = false;
				}
			}
		}
		if (!flag)
		{
			ownerItem.SetFlag(Item.Flag.IsOn, b: false);
			victim.SetPlayerFlag(BasePlayer.PlayerFlags.IsRestrained, b: false);
		}
		ownerItem.MarkDirty();
		if (flag)
		{
			victim.Server_CancelGesture();
			if (victim.IsBot)
			{
				Inventory.EquipItemInSlot(victim, 0);
			}
			victim.ClientRPC(RpcTarget.Player("SetActiveBeltSlot", victim), ownerItem.position, ownerItem.uid);
			SetLocked(flag: true, victim, ownerItem);
			Effect.server.Run(lockEffect.resourcePath, victim, 0u, Vector3.zero, Vector3.zero);
			Interface.CallHook("OnPlayerHandcuffed", (object)victim, (object)handcuffer);
		}
	}

	public void UnlockAndReturnToPlayer(BasePlayer returnToPlayer)
	{
		SetLocked(flag: false);
		if (!((Object)(object)returnToPlayer == (Object)null))
		{
			Item ownerItem = GetOwnerItem();
			if (ownerItem != null)
			{
				returnToPlayer.GiveItem(ownerItem);
			}
		}
	}

	public override bool CanHit(HitTest info)
	{
		if (info.HitEntity is BasePlayer basePlayer)
		{
			if (!basePlayer.CurrentGestureIsSurrendering && !basePlayer.IsSleeping())
			{
				return basePlayer.IsWounded();
			}
			return true;
		}
		return false;
	}

	public override void DoAttackShared(HitInfo info)
	{
		if (!base.isServer)
		{
			return;
		}
		BasePlayer basePlayer = info.HitEntity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null && (Object)(object)basePlayer != (Object)null)
			{
				SV_HandcuffVictim(basePlayer, ownerPlayer);
			}
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class HBHFSensor : BaseDetector
{
	public static int MinRange = 2;

	public static int MaxRange = 10;

	public int range = 10;

	public GameObjectRef detectUp;

	public GameObjectRef detectDown;

	public GameObjectRef panelPrefab;

	public const Flags Flag_IncludeOthers = Flags.Reserved2;

	public const Flags Flag_IncludeAuthed = Flags.Reserved3;

	private int detectedPlayers;

	public int DetectedPlayers => detectedPlayers;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HBHFSensor.OnRpcMessage", 0);
		try
		{
			if (rpc == 4073303808u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetConfig "));
				}
				TimeWarning val2 = TimeWarning.New("SetConfig", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4073303808u, "SetConfig", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4073303808u, "SetConfig", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage config = rPCMessage;
							SetConfig(config);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetConfig");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return Mathf.Min(detectedPlayers, GetCurrentEnergy());
	}

	public override void OnObjects()
	{
		base.OnObjects();
		UpdatePassthroughAmount();
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdatePassthroughAmount, 0f, 1f, 0.1f);
	}

	public override void OnEmpty()
	{
		base.OnEmpty();
		UpdatePassthroughAmount();
		((FacepunchBehaviour)this).CancelInvoke((Action)UpdatePassthroughAmount);
	}

	public void UpdatePassthroughAmount()
	{
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || !IsPowered())
		{
			return;
		}
		int num = detectedPlayers;
		detectedPlayers = 0;
		if (myTrigger.entityContents != null && myTrigger.entityContents.Count > 0)
		{
			BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
			foreach (BaseEntity entityContent in myTrigger.entityContents)
			{
				if (entityContent is BasePlayer basePlayer && Interface.CallHook("OnSensorDetect", (object)this, (object)basePlayer) == null && !((Object)(object)basePlayer == (Object)null) && !basePlayer.IsDead() && !basePlayer.IsSleeping() && basePlayer.isServer)
				{
					bool flag = (Object)(object)buildingPrivilege != (Object)null && buildingPrivilege.IsAuthed(basePlayer);
					if ((!flag || ShouldIncludeAuthorized()) && (flag || ShouldIncludeOthers()) && entityContent.IsVisible(((Component)this).transform.position + ((Component)this).transform.forward * 0.1f, (float)range))
					{
						detectedPlayers++;
					}
				}
			}
		}
		if (num != detectedPlayers)
		{
			MarkDirty();
			if (detectedPlayers > num)
			{
				Effect.server.Run(detectUp.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
			else if (detectedPlayers < num)
			{
				Effect.server.Run(detectDown.resourcePath, ((Component)this).transform.position, Vector3.up);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void SetConfig(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanUse(player))
		{
			bool b = msg.read.Bit();
			bool b2 = msg.read.Bit();
			SetFlag(Flags.Reserved3, b);
			SetFlag(Flags.Reserved2, b2);
			int num = msg.read.Int32();
			SetRange(num);
		}
	}

	public void SetRange(int value)
	{
		value = Mathf.Clamp(value, MinRange, MaxRange);
		range = value;
		SendNetworkUpdate();
	}

	public bool CanUse(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseHBHFSensor", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

	public bool ShouldIncludeAuthorized()
	{
		return HasFlag(Flags.Reserved3);
	}

	public bool ShouldIncludeOthers()
	{
		return HasFlag(Flags.Reserved2);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity.genericInt1 = range;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			range = info.msg.ioEntity.genericInt1;
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class HeldBoomBox : HeldEntity, ICassettePlayer
{
	public BoomBox BoxController;

	public SwapKeycard cassetteSwapper;

	public BaseEntity ToBaseEntity => this;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HeldBoomBox.OnRpcMessage", 0);
		try
		{
			if (rpc == 1918716764 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_UpdateRadioIP "));
				}
				TimeWarning val2 = TimeWarning.New("Server_UpdateRadioIP", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1918716764u, "Server_UpdateRadioIP", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(1918716764u, "Server_UpdateRadioIP", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_UpdateRadioIP(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_UpdateRadioIP");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1785864031 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerTogglePlay "));
				}
				TimeWarning val2 = TimeWarning.New("ServerTogglePlay", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1785864031u, "ServerTogglePlay", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(1785864031u, "ServerTogglePlay", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ServerTogglePlay(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ServerTogglePlay");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		BoxController.HurtCallback = HurtCallback;
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	public void ServerTogglePlay(RPCMessage msg)
	{
		BoxController.ServerTogglePlay(msg);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server.IsActiveItem]
	private void Server_UpdateRadioIP(RPCMessage msg)
	{
		BoxController.Server_UpdateRadioIP(msg);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		BoxController.Save(info);
	}

	public void OnCassetteInserted(Cassette c)
	{
		BoxController.OnCassetteInserted(c);
	}

	public void OnCassetteRemoved(Cassette c)
	{
		BoxController.OnCassetteRemoved(c);
	}

	public bool ClearRadioByUserId(ulong id)
	{
		return BoxController.ClearRadioByUserId(id);
	}

	public void HurtCallback(float amount)
	{
		if ((Object)(object)GetOwnerPlayer() != (Object)null && GetOwnerPlayer().IsSleeping())
		{
			BoxController.ServerTogglePlay(play: false);
		}
		else
		{
			GetItem()?.LoseCondition(amount);
		}
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		if (IsDisabled())
		{
			BoxController.ServerTogglePlay(play: false);
		}
	}

	public override void Load(LoadInfo info)
	{
		BoxController.Load(info);
		base.Load(info);
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class HeldEntity : BaseEntity
{
	[Serializable]
	public class HolsterInfo
	{
		public enum HolsterSlot
		{
			BACK,
			RIGHT_THIGH,
			LEFT_THIGH,
			BACK_SHIELD
		}

		public enum BackpackSlot
		{
			LEFT,
			RIGHT
		}

		public HolsterSlot slot;

		public BackpackSlot backpackSlot;

		public bool displayWhenHolstered;

		public string holsterBone = "spine3";

		public Vector3 holsterOffset;

		public Vector3 holsterRotationOffset;

		public Vector3 backpackHolsterOffset;

		public Vector3 backpackHolsterRotationOffset;

		public Quaternion holsterRotationOffsetQ
		{
			get
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_001e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_0018: Unknown result type (might be due to invalid IL or missing references)
				if (!(holsterRotationOffset == Vector3.zero))
				{
					return Quaternion.Euler(holsterRotationOffset);
				}
				return Quaternion.identity;
			}
		}

		public Quaternion backpackHolsterRotationOffsetQ
		{
			get
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_001e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_0018: Unknown result type (might be due to invalid IL or missing references)
				if (!(backpackHolsterRotationOffset == Vector3.zero))
				{
					return Quaternion.Euler(backpackHolsterRotationOffset);
				}
				return Quaternion.identity;
			}
		}
	}

	public static class HeldEntityFlags
	{
		public const Flags Deployed = Flags.Reserved4;

		public const Flags LightsOn = Flags.Reserved5;

		public const Flags ShieldEquipped = Flags.Reserved13;
	}

	public enum heldEntityVisState
	{
		UNSET,
		Invis,
		Hand,
		Holster,
		GenericVis
	}

	private static int param_deploy = Animator.StringToHash("deploy");

	public Animator worldModelAnimator;

	public SoundDefinition thirdPersonDeploySound;

	public SoundDefinition thirdPersonAimSound;

	public SoundDefinition thirdPersonAimEndSound;

	public const Flags Flag_ForceVisible = Flags.Reserved8;

	[Header("Held Entity")]
	public string handBone = "r_prop";

	public AnimatorOverrideController HoldAnimationOverride;

	public bool isBuildingTool;

	public bool canBeUsedWithShield;

	public BasePlayer forcedOwner;

	public bool useOwnerForward = true;

	public HolsterInfo holsterInfo;

	[Header("Hostility")]
	public float hostileScore;

	[Header("Camera")]
	public BasePlayer.CameraMode HeldCameraMode;

	public Vector3 FirstPersonArmOffset;

	public Vector3 FirstPersonArmRotation;

	[Range(0f, 1f)]
	public float FirstPersonRotationStrength = 1f;

	public bool holsterVisible;

	public bool genericVisible;

	private heldEntityVisState currentVisState;

	public ItemId ownerItemUID;

	private Item cachedItem;

	public bool hostile => hostileScore > 0f;

	public virtual Transform MuzzleTransform => null;

	public virtual ItemModWearable WearableWhileEquipped => null;

	public virtual bool IsShield => false;

	protected bool UsingInfiniteAmmoCheat
	{
		get
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer == (Object)null || (!ownerPlayer.IsAdmin && !ownerPlayer.IsDeveloper))
			{
				return false;
			}
			return ownerPlayer.GetInfoBool("player.infiniteammo", defaultVal: false);
		}
	}

	public virtual bool IsUsableByTurret => false;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HeldEntity.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool LightsOn()
	{
		return HasFlag(Flags.Reserved5);
	}

	public bool IsDeployed()
	{
		return HasFlag(Flags.Reserved4);
	}

	public bool HasShieldEquipped()
	{
		return HasFlag(Flags.Reserved13);
	}

	public BasePlayer GetOwnerPlayer()
	{
		if ((Object)(object)forcedOwner != (Object)null)
		{
			return forcedOwner;
		}
		BaseEntity baseEntity = GetParentEntity();
		if (!baseEntity.IsValid())
		{
			return null;
		}
		BasePlayer basePlayer = baseEntity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return null;
		}
		if (basePlayer.IsDead())
		{
			return null;
		}
		return basePlayer;
	}

	public bool TryGetOwnerPlayer(out BasePlayer ownerPlayer)
	{
		ownerPlayer = GetOwnerPlayer();
		return (Object)(object)ownerPlayer != (Object)null;
	}

	public Connection GetOwnerConnection()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return null;
		}
		if (ownerPlayer.net == null)
		{
			return null;
		}
		return ownerPlayer.net.connection;
	}

	public virtual void SetOwnerPlayer(BasePlayer player)
	{
		Assert.IsTrue(base.isServer, "Should be server!");
		Assert.IsTrue(player.isServer, "Player should be serverside!");
		((Component)this).gameObject.Identity();
		SetParent(player, handBone);
		if (!IsShield)
		{
			SetHeld(bHeld: false);
		}
	}

	public virtual void ClearOwnerPlayer()
	{
		Assert.IsTrue(base.isServer, "Should be server!");
		SetHeld(bHeld: false);
		SetParent(null);
	}

	public virtual void SetVisibleWhileHolstered(bool visible)
	{
		if (holsterInfo.displayWhenHolstered)
		{
			holsterVisible = visible;
			genericVisible = false;
			UpdateHeldItemVisibility();
		}
	}

	public virtual void SetGenericVisible(bool wantsVis)
	{
		genericVisible = wantsVis;
		SetFlag(Flags.Reserved8, wantsVis);
		UpdateHeldItemVisibility();
	}

	public uint GetBone(string bone)
	{
		return StringPool.Get(bone);
	}

	public virtual void SetLightsOn(bool isOn)
	{
		SetFlag(Flags.Reserved5, isOn);
	}

	public void UpdateHeldItemVisibility()
	{
		bool flag = false;
		if (!genericVisible && Object.op_Implicit((Object)(object)GetOwnerPlayer()))
		{
			bool flag2 = (Object)(object)GetOwnerPlayer().GetHeldEntity() == (Object)(object)this || IsShield;
			flag = ((!Server.showHolsteredItems && !flag2) ? UpdateVisiblity_Invis() : (flag2 ? UpdateVisibility_Hand() : ((!holsterVisible) ? UpdateVisiblity_Invis() : UpdateVisiblity_Holster())));
		}
		else if (genericVisible)
		{
			flag = UpdateVisibility_GenericVis();
		}
		else if (!genericVisible)
		{
			flag = UpdateVisiblity_Invis();
		}
		if (flag)
		{
			SendNetworkUpdate();
		}
	}

	public bool UpdateVisibility_Hand()
	{
		if (currentVisState == heldEntityVisState.Hand)
		{
			return false;
		}
		currentVisState = heldEntityVisState.Hand;
		base.limitNetworking = false;
		SetFlag(Flags.Disabled, b: false);
		SetParent(GetOwnerPlayer(), GetBone(handBone));
		return true;
	}

	public bool UpdateVisibility_GenericVis()
	{
		if (currentVisState == heldEntityVisState.GenericVis)
		{
			return false;
		}
		currentVisState = heldEntityVisState.GenericVis;
		base.limitNetworking = false;
		SetFlag(Flags.Disabled, b: false);
		return true;
	}

	public bool UpdateVisiblity_Holster()
	{
		if (currentVisState == heldEntityVisState.Holster)
		{
			return false;
		}
		currentVisState = heldEntityVisState.Holster;
		base.limitNetworking = false;
		SetFlag(Flags.Disabled, b: false);
		SetParent(GetOwnerPlayer(), GetBone(holsterInfo.holsterBone));
		return true;
	}

	public bool UpdateVisiblity_Invis()
	{
		if (currentVisState == heldEntityVisState.Invis)
		{
			return false;
		}
		currentVisState = heldEntityVisState.Invis;
		SetParent(GetOwnerPlayer(), GetBone(handBone));
		base.limitNetworking = true;
		SetFlag(Flags.Disabled, b: true);
		return true;
	}

	public virtual void SetHeld(bool bHeld)
	{
		Assert.IsTrue(base.isServer, "Should be server!");
		bool num = HasFlag(Flags.Reserved4);
		SetFlag(Flags.Reserved4, bHeld);
		if (!bHeld)
		{
			UpdateVisiblity_Invis();
		}
		if (num || bHeld)
		{
			UpdateShieldState(bHeld && canBeUsedWithShield);
		}
		base.limitNetworking = !bHeld;
		SetFlag(Flags.Disabled, !bHeld);
		SendNetworkUpdate();
		OnHeldChanged();
	}

	public void UpdateShieldState(bool bHeld)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!((Object)(object)ownerPlayer != (Object)null))
		{
			return;
		}
		Item anyBackpack = ownerPlayer.inventory.GetAnyBackpack();
		ItemModShield itemModShield = default(ItemModShield);
		if (canBeUsedWithShield && anyBackpack != null && ((Component)anyBackpack.info).TryGetComponent<ItemModShield>(ref itemModShield))
		{
			HeldEntity heldEntity = anyBackpack.GetHeldEntity() as HeldEntity;
			if (anyBackpack.isBroken)
			{
				bHeld = false;
			}
			if ((Object)(object)heldEntity != (Object)null && bHeld)
			{
				heldEntity.UpdateVisibility_Hand();
				heldEntity.SetFlag(Flags.Reserved4, b: true);
				SetFlag(Flags.Reserved13, b: true);
				return;
			}
			if ((Object)(object)heldEntity != (Object)null)
			{
				heldEntity.UpdateVisiblity_Holster();
				heldEntity.SetFlag(Flags.Reserved4, b: false);
			}
			SetFlag(Flags.Reserved13, b: false);
		}
		else
		{
			SetFlag(Flags.Reserved13, b: false);
		}
	}

	public virtual void OnHeldChanged()
	{
	}

	public virtual bool CanBeUsedInWater()
	{
		return false;
	}

	public virtual bool BlocksGestures()
	{
		return false;
	}

	protected Item GetOwnerItem()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null || (Object)(object)ownerPlayer.inventory == (Object)null)
		{
			return null;
		}
		return ownerPlayer.inventory.FindItemByUID(ownerItemUID);
	}

	public override Item GetItem()
	{
		return GetOwnerItem();
	}

	public ItemDefinition GetOwnerItemDefinition()
	{
		Item ownerItem = GetOwnerItem();
		if (ownerItem == null)
		{
			Debug.LogWarning((object)"GetOwnerItem - null!", (Object)(object)this);
			return null;
		}
		return ownerItem.info;
	}

	public virtual void CollectedForCrafting(Item item, BasePlayer crafter)
	{
	}

	public virtual void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
	{
	}

	public virtual void ServerCommand(Item item, string command, BasePlayer player)
	{
	}

	public virtual void SetupHeldEntity(Item item)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		ownerItemUID = item.uid;
		InitOwnerPlayer();
	}

	public Item GetCachedItem()
	{
		return cachedItem;
	}

	public void OnItemChanged(Item item)
	{
		cachedItem = item;
	}

	public override void PostServerLoad()
	{
		InitOwnerPlayer();
	}

	private void InitOwnerPlayer()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			SetOwnerPlayer(ownerPlayer);
		}
		else
		{
			ClearOwnerPlayer();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.heldEntity = Pool.Get<HeldEntity>();
		info.msg.heldEntity.itemUID = ownerItemUID;
	}

	public void DestroyThis()
	{
		GetOwnerItem()?.Remove();
	}

	protected bool HasItemAmount()
	{
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			return ownerItem.amount > 0;
		}
		return false;
	}

	protected bool UseItemAmount(int iAmount, bool reduceItemOwnership = true)
	{
		if (iAmount <= 0)
		{
			return true;
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem == null)
		{
			DestroyThis();
			return true;
		}
		ownerItem.amount -= iAmount;
		ownerItem.MarkDirty();
		if (reduceItemOwnership)
		{
			ownerItem.ReduceItemOwnership(iAmount);
		}
		if (ownerItem.amount <= 0)
		{
			DestroyThis();
			return true;
		}
		return false;
	}

	public virtual void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
	}

	public virtual void ServerTick(BasePlayer byPlayer)
	{
	}

	public virtual bool IsInstrument()
	{
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.heldEntity != null)
		{
			ownerItemUID = info.msg.heldEntity.itemUID;
		}
	}

	public void SendPunch(Vector3 amount, float duration)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.Player("CL_Punch", GetOwnerPlayer()), amount, duration);
	}
}


using System;
using UnityEngine;

[Serializable]
public class HolsterInfo
{
	public enum HolsterSlot
	{
		BACK,
		RIGHT_THIGH,
		LEFT_THIGH,
		BACK_SHIELD
	}

	public enum BackpackSlot
	{
		LEFT,
		RIGHT
	}

	public HolsterSlot slot;

	public BackpackSlot backpackSlot;

	public bool displayWhenHolstered;

	public string holsterBone = "spine3";

	public Vector3 holsterOffset;

	public Vector3 holsterRotationOffset;

	public Vector3 backpackHolsterOffset;

	public Vector3 backpackHolsterRotationOffset;

	public Quaternion holsterRotationOffsetQ
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (!(holsterRotationOffset == Vector3.zero))
			{
				return Quaternion.Euler(holsterRotationOffset);
			}
			return Quaternion.identity;
		}
	}

	public Quaternion backpackHolsterRotationOffsetQ
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (!(backpackHolsterRotationOffset == Vector3.zero))
			{
				return Quaternion.Euler(backpackHolsterRotationOffset);
			}
			return Quaternion.identity;
		}
	}
}


public enum HolsterSlot
{
	BACK,
	RIGHT_THIGH,
	LEFT_THIGH,
	BACK_SHIELD
}


public enum BackpackSlot
{
	LEFT,
	RIGHT
}


public static class HeldEntityFlags
{
	public const Flags Deployed = Flags.Reserved4;

	public const Flags LightsOn = Flags.Reserved5;

	public const Flags ShieldEquipped = Flags.Reserved13;
}


public enum heldEntityVisState
{
	UNSET,
	Invis,
	Hand,
	Holster,
	GenericVis
}


using System;
using System.Runtime.CompilerServices;
using ConVar;
using Network;
using UnityEngine;

public class HelicopterFlares : StorageContainer
{
	[Header("Helicopter Flares")]
	[SerializeField]
	private ItemDefinition flareItemDef;

	[SerializeField]
	private float timeBetweenFlares = 30f;

	[SerializeField]
	private float flareLaunchVel = 10f;

	[SerializeField]
	private GameObjectRef flareFireFX;

	[SerializeField]
	private GameObjectRef serverFlarePrefab;

	[SerializeField]
	private Transform leftFlareLaunchPos;

	[SerializeField]
	private Transform rightFlareLaunchPos;

	[HideInInspector]
	public ICanFireHelicopterFlares owner;

	private TimeSince timeSinceFlareFired;

	private bool __sync_HasFlares;

	[Sync]
	public bool HasFlares
	{
		[CompilerGenerated]
		get
		{
			return __sync_HasFlares;
		}
		[CompilerGenerated]
		private set
		{
			if (!IsSyncVarEqual(__sync_HasFlares, value))
			{
				__sync_HasFlares = value;
				byte nameID = __GetWeaverID("HasFlares");
				QueueSyncVar(nameID);
			}
		}
	}

	public bool CanFireFlare
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			if (TimeSince.op_Implicit(timeSinceFlareFired) >= timeBetweenFlares)
			{
				return HasFlareAmmo();
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HelicopterFlares.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool HasFlareAmmo()
	{
		if (base.isServer)
		{
			HasFlares = base.inventory.HasAny(flareItemDef);
			return HasFlares;
		}
		return false;
	}

	private void ResetFiringTimes()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		timeSinceFlareFired = TimeSince.op_Implicit(9999f);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (owner.flareEntity.IsOn())
		{
			return false;
		}
		return base.CanBeLooted(player);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		HasFlares = HasFlareAmmo();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		HasFlares = HasFlareAmmo();
	}

	public bool TryFireFlare()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (!CanFireFlare)
		{
			return false;
		}
		if (owner == null)
		{
			return false;
		}
		if (!base.inventory.TryTakeOne(flareItemDef.itemid, out var item))
		{
			return false;
		}
		item.Remove();
		timeSinceFlareFired = TimeSince.op_Implicit(0f);
		LaunchFlare();
		ClientRPC(RpcTarget.NetworkGroup("RPCFlareFired"), HasFlareAmmo());
		return true;
	}

	public void LaunchFlare()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(flareFireFX.resourcePath, owner.flareEntity, StringPool.Get("FlareLaunchPos"), Vector3.zero, Vector3.zero);
		GameManager.server.CreatePrefab(serverFlarePrefab.resourcePath, leftFlareLaunchPos.position, Quaternion.identity).GetComponent<HeliPilotFlare>().Init(-((Component)owner.flareEntity).transform.right * flareLaunchVel);
		GameManager.server.CreatePrefab(serverFlarePrefab.resourcePath, rightFlareLaunchPos.position, Quaternion.identity).GetComponent<HeliPilotFlare>().Init(((Component)owner.flareEntity).transform.right * flareLaunchVel);
	}

	public void RefillFlares()
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("flare");
		int amount = itemDefinition.stackable * 2;
		base.inventory.AddItem(itemDefinition, amount, 0uL, ItemContainer.LimitStack.All);
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (id == 0)
		{
			if (Global.developer > 2)
			{
				NetworkableId iD = net.ID;
				Debug.Log((object)("SyncVar Writing: HasFlares for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_HasFlares);
			return true;
		}
		return base.WriteSyncVar(id, writer);
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		if (id == 0)
		{
			try
			{
				_ = __sync_HasFlares;
				bool _sync_HasFlares = reader.Bool();
				__sync_HasFlares = _sync_HasFlares;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			return true;
		}
		return base.OnSyncVar(id, reader, fromAutoSave);
	}

	private byte __GetWeaverID(string propertyName)
	{
		if (propertyName == "HasFlares")
		{
			return 0;
		}
		return byte.MaxValue;
	}

	protected override void WriteAutoSaveSyncVars(NetWrite writer)
	{
		base.WriteAutoSaveSyncVars(writer);
	}

	protected override void ReadAutoSaveSyncVars(NetRead reader)
	{
		base.ReadAutoSaveSyncVars(reader);
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		base.AutoSaveSyncVars(save);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		base.AutoLoadSyncVars(load);
		return true;
	}

	protected override void ResetSyncVars()
	{
		base.ResetSyncVars();
		__sync_HasFlares = false;
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		if (id == 0)
		{
			return true;
		}
		return base.ShouldInvalidateCache(id);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class HotAirBalloon : BaseCombatEntity, VehicleSpawner.IVehicleSpawnUser, SamSite.ISamSiteTarget, SeekerTarget.ISeekerTargetOwner, TriggerHurtNotChild.IHurtTriggerUser
{
	[Serializable]
	public struct UpgradeOption
	{
		public ItemDefinition TokenItem;

		public Phrase Title;

		public Phrase Description;

		public Sprite Icon;

		public int order;
	}

	public const Flags Flag_HasFuel = Flags.Reserved6;

	public const Flags Flag_Grounded = Flags.Reserved7;

	public const Flags Flag_CanModifyEquipment = Flags.Reserved8;

	public const Flags Flag_HalfInflated = Flags.Reserved1;

	public const Flags Flag_FullInflated = Flags.Reserved2;

	public const Flags Flag_OnlyOwnerEntry = Flags.Locked;

	public Transform centerOfMass;

	public Rigidbody myRigidbody;

	public Transform buoyancyPoint;

	public float liftAmount = 10f;

	public Transform windSock;

	public Transform[] windFlags;

	public GameObject staticBalloonDeflated;

	public GameObject staticBalloon;

	public GameObject animatedBalloon;

	public Animator balloonAnimator;

	public Transform groundSample;

	public GameObject parentTrigger;

	[Tooltip("Turning off the engine for this long will prevent homing missiles from locking on")]
	public float engineOffTimeToPreventHomingTarget = 4f;

	public float inflationLevel;

	[Header("Fuel")]
	public GameObjectRef fuelStoragePrefab;

	public float fuelPerSec = 0.25f;

	[Header("Storage")]
	public GameObjectRef storageUnitPrefab;

	public EntityRef<StorageContainer> storageUnitInstance;

	[Header("Damage")]
	public DamageRenderer damageRenderer;

	public Transform engineHeight;

	public GameObject[] crushTriggers;

	[Header("Upgrades")]
	public List<UpgradeOption> UpgradeOptions;

	public EntityFuelSystem fuelSystem;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population = 1f;

	[ServerVar(Help = "How long before a HAB loses all its health while outside")]
	public static float outsidedecayminutes = 180f;

	public float NextUpgradeTime;

	public float windForce = 30000f;

	public Vector3 currentWindVec = Vector3.zero;

	public Bounds collapsedBounds;

	public Bounds raisedBounds;

	public GameObject[] balloonColliders;

	private TimeSince engineOffTime;

	[ServerVar]
	public static float serviceCeiling = 175f;

	[ServerVar]
	public static float minimumAltitudeTerrain = 25f;

	public Vector3 lastFailedDecayPosition = Vector3.zero;

	public float currentBuoyancy;

	public TimeSince sinceLastBlast;

	public float avgTerrainHeight;

	public bool grounded;

	public float spawnTime = -1f;

	public float safeAreaRadius;

	public Vector3 safeAreaOrigin;

	public bool IsFullyInflated => inflationLevel >= 1f;

	public bool Grounded => HasFlag(Flags.Reserved7);

	public SamSite.SamTargetType SAMTargetType => SamSite.targetTypeVehicle;

	public bool IsClient => base.isClient;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HotAirBalloon.OnRpcMessage", 0);
		try
		{
			if (rpc == 578721460 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - EngineSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("EngineSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(578721460u, "EngineSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							EngineSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in EngineSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						RPC_OpenFuel(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2441951484u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqEquipItem "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqEquipItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2441951484u, "RPC_ReqEquipItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_ReqEquipItem(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_ReqEquipItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		fuelSystem = new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
	}

	public override void Load(LoadInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.hotAirBalloon != null)
		{
			inflationLevel = info.msg.hotAirBalloon.inflationAmount;
			sinceLastBlast = TimeSince.op_Implicit(info.msg.hotAirBalloon.sinceLastBlast);
			if (info.fromDisk && Object.op_Implicit((Object)(object)myRigidbody))
			{
				myRigidbody.velocity = info.msg.hotAirBalloon.velocity;
			}
		}
		if (info.msg.motorBoat != null)
		{
			fuelSystem.SetInstanceID(info.msg.motorBoat.fuelStorageID);
			storageUnitInstance.uid = info.msg.motorBoat.storageid;
		}
	}

	public bool CanModifyEquipment()
	{
		if (base.isServer && Time.time < NextUpgradeTime)
		{
			return false;
		}
		return true;
	}

	public void DelayNextUpgrade(float delay)
	{
		if (Time.time + delay > NextUpgradeTime)
		{
			NextUpgradeTime = Time.time + delay;
		}
	}

	public int GetEquipmentCount(ItemModHABEquipment item)
	{
		int num = 0;
		for (int num2 = children.Count - 1; num2 >= 0; num2--)
		{
			BaseEntity baseEntity = children[num2];
			if (!((Object)(object)baseEntity == (Object)null) && baseEntity.prefabID == item.Prefab.resourceID)
			{
				num++;
			}
		}
		return num;
	}

	public void RemoveItemsOfType(ItemModHABEquipment item)
	{
		for (int num = children.Count - 1; num >= 0; num--)
		{
			BaseEntity baseEntity = children[num];
			if (!((Object)(object)baseEntity == (Object)null) && baseEntity.prefabID == item.Prefab.resourceID)
			{
				baseEntity.Kill();
			}
		}
	}

	public bool WaterLogged()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return WaterLevel.Test(engineHeight.position, waves: true, volumes: true, this);
	}

	public bool OnlyOwnerAccessible()
	{
		return HasFlag(Flags.Locked);
	}

	public override void OnAttacked(HitInfo info)
	{
		if (IsSafe() && !info.damageTypes.Has(DamageType.Decay))
		{
			info.damageTypes.ScaleAll(0f);
		}
		base.OnAttacked(info);
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer)
		{
			if (isSpawned)
			{
				fuelSystem.CheckNewChild(child);
			}
			if (child.prefabID == storageUnitPrefab.GetEntity().prefabID)
			{
				storageUnitInstance.Set((StorageContainer)child);
				_ = storageUnitInstance.Get(serverside: true).inventory;
			}
			bool isLoadingSave = Application.isLoadingSave;
			HotAirBalloonEquipment hotAirBalloonEquipment = child as HotAirBalloonEquipment;
			if ((Object)(object)hotAirBalloonEquipment != (Object)null)
			{
				hotAirBalloonEquipment.Added(this, isLoadingSave);
			}
		}
	}

	protected override void OnChildRemoved(BaseEntity child)
	{
		base.OnChildRemoved(child);
		if (base.isServer)
		{
			HotAirBalloonEquipment hotAirBalloonEquipment = child as HotAirBalloonEquipment;
			if ((Object)(object)hotAirBalloonEquipment != (Object)null)
			{
				hotAirBalloonEquipment.Removed(this);
			}
		}
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot && storageUnitInstance.IsValid(base.isServer))
		{
			storageUnitInstance.Get(base.isServer).DropItems();
		}
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		base.DoServerDestroy();
	}

	public bool IsValidSAMTarget(bool staticRespawn)
	{
		if (myRigidbody.IsSleeping() || myRigidbody.isKinematic)
		{
			return false;
		}
		if (staticRespawn)
		{
			return IsFullyInflated;
		}
		if (IsFullyInflated)
		{
			return !InSafeZone();
		}
		return false;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		ClearOwnerEntry();
		SetFlag(Flags.On, b: false);
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && (!OnlyOwnerAccessible() || !((Object)(object)msg.player != (Object)(object)creatorEntity)))
		{
			fuelSystem.LootFuel(player);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.hotAirBalloon = Pool.Get<HotAirBalloon>();
		info.msg.hotAirBalloon.inflationAmount = inflationLevel;
		info.msg.hotAirBalloon.sinceLastBlast = TimeSince.op_Implicit(sinceLastBlast);
		if (info.forDisk && Object.op_Implicit((Object)(object)myRigidbody))
		{
			info.msg.hotAirBalloon.velocity = myRigidbody.velocity;
		}
		info.msg.motorBoat = Pool.Get<Motorboat>();
		info.msg.motorBoat.storageid = storageUnitInstance.uid;
		info.msg.motorBoat.fuelStorageID = fuelSystem.GetInstanceID();
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		myRigidbody.centerOfMass = centerOfMass.localPosition;
		myRigidbody.isKinematic = false;
		avgTerrainHeight = TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position);
		base.ServerInit();
		bounds = collapsedBounds;
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayTick, Random.Range(30f, 60f), 60f, 6f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateIsGrounded, 0f, 3f, 0.2f);
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
	}

	public void DecayTick()
	{
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (base.healthFraction == 0f)
		{
			return;
		}
		if (IsFullyInflated)
		{
			bool flag = true;
			if (lastFailedDecayPosition != Vector3.zero && Distance(lastFailedDecayPosition) < 2f)
			{
				flag = false;
			}
			lastFailedDecayPosition = ((Component)this).transform.position;
			if (flag)
			{
				return;
			}
			myRigidbody.AddForceAtPosition(Vector3.up * (0f - Physics.gravity.y) * myRigidbody.mass * 20f, buoyancyPoint.position, (ForceMode)0);
			myRigidbody.AddForceAtPosition(Vector3Ex.WithY(Random.onUnitSphere, 0f) * 20f, buoyancyPoint.position, (ForceMode)0);
		}
		if (!(TimeSince.op_Implicit(sinceLastBlast) < 600f))
		{
			float num = 1f / outsidedecayminutes;
			if (IsOutside() || IsFullyInflated)
			{
				Hurt(MaxHealth() * num, DamageType.Decay, this, useProtection: false);
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void EngineSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnHotAirBalloonToggle", (object)this, (object)msg.player) != null)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && (!OnlyOwnerAccessible() || !((Object)(object)player != (Object)(object)creatorEntity)))
		{
			bool b = msg.read.Bit();
			SetFlag(Flags.On, b);
			if (IsOn())
			{
				((FacepunchBehaviour)this).Invoke((Action)ScheduleOff, 60f);
				Interface.CallHook("OnHotAirBalloonToggled", (object)this, (object)msg.player);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ScheduleOff);
				Interface.CallHook("OnHotAirBalloonToggled", (object)this, (object)msg.player);
			}
		}
	}

	public void ScheduleOff()
	{
		SetFlag(Flags.On, b: false);
	}

	public void UpdateIsGrounded()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(((Component)groundSample).transform.position, 1.25f, list, 1218511105, (QueryTriggerInteraction)1);
		grounded = list.Count > 0;
		CheckGlobal(flags);
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			CheckGlobal(next);
			if ((Object)(object)myRigidbody != (Object)null)
			{
				myRigidbody.isKinematic = IsTransferProtected();
			}
		}
	}

	public void CheckGlobal(Flags flags)
	{
		bool wants = flags.HasFlag(Flags.On) || flags.HasFlag(Flags.Reserved2) || flags.HasFlag(Flags.Reserved1) || !grounded;
		EnableGlobalBroadcast(wants);
	}

	protected void FixedUpdate()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0407: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0411: Unknown result type (might be due to invalid IL or missing references)
		//IL_0428: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0470: Unknown result type (might be due to invalid IL or missing references)
		//IL_047a: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0484: Unknown result type (might be due to invalid IL or missing references)
		//IL_0489: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0500: Unknown result type (might be due to invalid IL or missing references)
		//IL_050d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0512: Unknown result type (might be due to invalid IL or missing references)
		//IL_051d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0524: Unknown result type (might be due to invalid IL or missing references)
		//IL_052f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0540: Unknown result type (might be due to invalid IL or missing references)
		//IL_0547: Unknown result type (might be due to invalid IL or missing references)
		//IL_056d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0573: Unknown result type (might be due to invalid IL or missing references)
		if (!isSpawned || base.isClient || IsTransferProtected())
		{
			return;
		}
		if (!fuelSystem.HasFuel() || WaterLogged())
		{
			SetFlag(Flags.On, b: false);
		}
		if (IsOn())
		{
			fuelSystem.TryUseFuel(Time.fixedDeltaTime, fuelPerSec);
			engineOffTime = TimeSince.op_Implicit(0f);
		}
		SetFlag(Flags.Reserved6, fuelSystem.HasFuel());
		SetFlag(Flags.Reserved7, grounded);
		SetFlag(Flags.Reserved8, CanModifyEquipment());
		bool flag = (IsFullyInflated && myRigidbody.velocity.y < 0f) || (myRigidbody.velocity.y > 0f && myRigidbody.velocity.y < 0.75f);
		GameObject[] array = crushTriggers;
		foreach (GameObject val in array)
		{
			if (val.activeSelf != flag)
			{
				val.SetActive(flag);
			}
		}
		float num = inflationLevel;
		if (IsOn() && !IsFullyInflated)
		{
			inflationLevel = Mathf.Clamp01(inflationLevel + Time.fixedDeltaTime / 10f);
		}
		else if (grounded && inflationLevel > 0f && !IsOn() && (TimeSince.op_Implicit(sinceLastBlast) > 30f || WaterLogged()))
		{
			inflationLevel = Mathf.Clamp01(inflationLevel - Time.fixedDeltaTime / 10f);
		}
		if (num != inflationLevel)
		{
			if (IsFullyInflated)
			{
				bounds = raisedBounds;
			}
			else if (inflationLevel == 0f)
			{
				bounds = collapsedBounds;
			}
			SetFlag(Flags.Reserved1, inflationLevel > 0.3f);
			SetFlag(Flags.Reserved2, inflationLevel >= 1f);
			SendNetworkUpdate();
			_ = inflationLevel;
		}
		bool flag2 = !myRigidbody.IsSleeping() || inflationLevel > 0f;
		array = balloonColliders;
		foreach (GameObject val2 in array)
		{
			if (val2.activeSelf != flag2)
			{
				val2.SetActive(flag2);
			}
		}
		if (IsOn())
		{
			if (IsFullyInflated)
			{
				currentBuoyancy += Time.fixedDeltaTime * 0.2f;
				sinceLastBlast = TimeSince.op_Implicit(0f);
			}
		}
		else
		{
			currentBuoyancy -= Time.fixedDeltaTime * 0.1f;
		}
		currentBuoyancy = Mathf.Clamp(currentBuoyancy, 0f, 0.8f + 0.2f * base.healthFraction);
		if (inflationLevel > 0f)
		{
			float num2 = Mathf.Max(minimumAltitudeTerrain, TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position));
			avgTerrainHeight = Mathf.Lerp(avgTerrainHeight, num2, Time.deltaTime);
			float num3 = 1f - Mathf.InverseLerp(avgTerrainHeight + serviceCeiling - 20f, avgTerrainHeight + serviceCeiling, buoyancyPoint.position.y);
			myRigidbody.AddForceAtPosition(Vector3.up * (0f - Physics.gravity.y) * myRigidbody.mass * 0.5f * inflationLevel, buoyancyPoint.position, (ForceMode)0);
			myRigidbody.AddForceAtPosition(Vector3.up * liftAmount * currentBuoyancy * num3, buoyancyPoint.position, (ForceMode)0);
			Vector3 windAtPos = GetWindAtPos(buoyancyPoint.position);
			_ = ((Vector3)(ref windAtPos)).magnitude;
			float num4 = 1f;
			float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(buoyancyPoint.position, waves: false, volumes: false);
			float num5 = Mathf.InverseLerp(waterOrTerrainSurface + 20f, waterOrTerrainSurface + 60f, buoyancyPoint.position.y);
			float num6 = 1f;
			RaycastHit val3 = default(RaycastHit);
			if (Physics.SphereCast(new Ray(((Component)this).transform.position + Vector3.up * 2f, Vector3.down), 1.5f, ref val3, 5f, 1218511105))
			{
				num6 = Mathf.Clamp01(((RaycastHit)(ref val3)).distance / 5f);
			}
			num4 *= num5 * num3 * num6;
			num4 *= 0.2f + 0.8f * base.healthFraction;
			Vector3 val4 = ((Vector3)(ref windAtPos)).normalized * num4 * windForce;
			currentWindVec = Vector3.Lerp(currentWindVec, val4, Time.fixedDeltaTime * 0.25f);
			myRigidbody.AddForceAtPosition(val4 * 0.1f, buoyancyPoint.position, (ForceMode)0);
			myRigidbody.AddForce(val4 * 0.9f, (ForceMode)0);
		}
		if (OnlyOwnerAccessible() && safeAreaRadius != -1f && Vector3.Distance(((Component)this).transform.position, safeAreaOrigin) > safeAreaRadius)
		{
			ClearOwnerEntry();
		}
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)myRigidbody == (Object)null)
		{
			return Vector3.zero;
		}
		return myRigidbody.velocity;
	}

	public override Quaternion GetAngularVelocityServer()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)myRigidbody == (Object)null)
		{
			return Quaternion.identity;
		}
		return Quaternion.Euler(myRigidbody.angularVelocity * 57.29578f);
	}

	public void ClearOwnerEntry()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		creatorEntity = null;
		SetFlag(Flags.Locked, b: false);
		safeAreaRadius = -1f;
		safeAreaOrigin = Vector3.zero;
	}

	public bool IsSafe()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (OnlyOwnerAccessible())
		{
			return Vector3.Distance(safeAreaOrigin, ((Component)this).transform.position) <= safeAreaRadius;
		}
		return false;
	}

	public void SetupOwner(BasePlayer owner, Vector3 newSafeAreaOrigin, float newSafeAreaRadius)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)owner != (Object)null)
		{
			creatorEntity = owner;
			base.OwnerID = owner.userID;
			bool b = true;
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(base.isServer);
			if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.safeZone)
			{
				b = false;
			}
			SetFlag(Flags.Locked, b);
			safeAreaRadius = newSafeAreaRadius;
			safeAreaOrigin = newSafeAreaOrigin;
			spawnTime = Time.realtimeSinceStartup;
		}
	}

	public bool IsDespawnEligable()
	{
		if (spawnTime != -1f)
		{
			return spawnTime + 300f < Time.realtimeSinceStartup;
		}
		return true;
	}

	public IFuelSystem GetFuelSystem()
	{
		return fuelSystem;
	}

	public int StartingFuelUnits()
	{
		return 75;
	}

	public BasePlayer GetPlayerDamageInitiator()
	{
		BasePlayer basePlayer = null;
		TriggerParentEnclosed component = parentTrigger.GetComponent<TriggerParentEnclosed>();
		if ((Object)(object)component == (Object)null || component.contents == null || component.contents.Count == 0)
		{
			return null;
		}
		foreach (GameObject content in component.contents)
		{
			BaseEntity baseEntity = content.ToBaseEntity();
			if ((Object)(object)baseEntity == (Object)null)
			{
				continue;
			}
			BasePlayer basePlayer2 = baseEntity.ToPlayer();
			if (!((Object)(object)basePlayer2 == (Object)null) && !basePlayer2.isClient && !basePlayer2.IsDead())
			{
				if ((Object)(object)basePlayer == (Object)null)
				{
					basePlayer = basePlayer2;
				}
				else
				{
					basePlayer2.MarkHostileFor();
				}
			}
		}
		return basePlayer;
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	public Vector3 GetWindAtPos(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		float num = pos.y * 6f;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.Sin(num * (MathF.PI / 180f)), 0f, Mathf.Cos(num * (MathF.PI / 180f)));
		return ((Vector3)(ref val)).normalized * 1f;
	}

	public bool PlayerHasEquipmentItem(BasePlayer player, int tokenItemID)
	{
		return GetEquipmentItem(player, tokenItemID) != null;
	}

	public Item GetEquipmentItem(BasePlayer player, int tokenItemID)
	{
		return player.inventory.FindItemByItemID(tokenItemID);
	}

	public override float MaxHealth()
	{
		if (maxHealthOverride > 0f)
		{
			return maxHealthOverride;
		}
		if (base.isServer)
		{
			return base.MaxHealth();
		}
		float num = base.MaxHealth();
		float num2 = 0f;
		foreach (BaseEntity child in children)
		{
			if (child is HotAirBalloonArmor hotAirBalloonArmor)
			{
				num2 += hotAirBalloonArmor.AdditionalHealth;
			}
		}
		return num + num2;
	}

	public override List<ItemAmount> BuildCost()
	{
		List<ItemAmount> list = new List<ItemAmount>(base.BuildCost());
		foreach (BaseEntity child in children)
		{
			if (child is HotAirBalloonEquipment hotAirBalloonEquipment)
			{
				list.AddRange(hotAirBalloonEquipment.BuildCost());
			}
		}
		return list;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_ReqEquipItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		int tokenItemID = msg.read.Int32();
		Item equipmentItem = GetEquipmentItem(player, tokenItemID);
		if (equipmentItem != null)
		{
			ItemModHABEquipment component = ((Component)equipmentItem.info).GetComponent<ItemModHABEquipment>();
			if (!((Object)(object)component == (Object)null) && component.CanEquipToHAB(this))
			{
				component.ApplyToHAB(this);
				equipmentItem.UseItem();
				SendNetworkUpdateImmediate();
			}
		}
	}

	public bool IsValidHomingTarget()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.Server.homingMissileTargetsHab && flags.HasFlag(Flags.Reserved2))
		{
			return TimeSince.op_Implicit(engineOffTime) <= engineOffTimeToPreventHomingTarget;
		}
		return false;
	}

	public bool AdminFixUp()
	{
		if (IsDead())
		{
			return false;
		}
		GetFuelSystem()?.FillFuel();
		SetHealth(MaxHealth());
		foreach (BaseEntity child in children)
		{
			if (!(child is HotAirBalloonEquipment hotAirBalloonEquipment) || hotAirBalloonEquipment.IsDead())
			{
				continue;
			}
			foreach (BaseEntity child2 in hotAirBalloonEquipment.children)
			{
				if (child2 is Door door && !door.IsDead())
				{
					door.SetHealth(door.MaxHealth());
					door.SendNetworkUpdate();
					break;
				}
			}
			break;
		}
		SendNetworkUpdate();
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct UpgradeOption
{
	public ItemDefinition TokenItem;

	public Phrase Title;

	public Phrase Description;

	public Sprite Icon;

	public int order;
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust.UI;
using UnityEngine;
using UnityEngine.Assertions;

public class HuntingTrophy : StorageContainer
{
	[Serializable]
	public struct TrophyRoot
	{
		public GameObjectRef SourceEntity;

		public GameObject Root;

		public uint GetSourcePrefabId()
		{
			BaseEntity entity = SourceEntity.GetEntity();
			if ((Object)(object)entity != (Object)null)
			{
				return entity.prefabID;
			}
			return 0u;
		}

		public bool Matches(HeadEntity headEnt)
		{
			BaseEntity entity = SourceEntity.GetEntity();
			bool flag = (Object)(object)entity != (Object)null && headEnt.CurrentTrophyData != null && entity.prefabID == headEnt.CurrentTrophyData.entitySource;
			if (!flag)
			{
				GameObject headSource = headEnt.GetHeadSource();
				BasePlayer basePlayer = default(BasePlayer);
				if ((Object)(object)headSource != (Object)null && headSource.TryGetComponent<BasePlayer>(ref basePlayer) && ((Component)entity).TryGetComponent<BasePlayer>(ref basePlayer))
				{
					flag = true;
				}
			}
			return flag;
		}

		public bool Matches(HeadData data)
		{
			if (data == null)
			{
				return false;
			}
			BaseEntity entity = SourceEntity.GetEntity();
			bool flag = (Object)(object)entity != (Object)null && entity.prefabID == data.entitySource;
			if (!flag)
			{
				GameObject val = null;
				val = GameManager.server.FindPrefab(data.entitySource);
				BasePlayer basePlayer = default(BasePlayer);
				if ((Object)(object)val != (Object)null && val.TryGetComponent<BasePlayer>(ref basePlayer) && ((Component)entity).TryGetComponent<BasePlayer>(ref basePlayer))
				{
					flag = true;
				}
			}
			return flag;
		}
	}

	public HeadData CurrentTrophyData;

	public PlayerModel Player;

	public GameObject MaleRope;

	public GameObject FemaleRope;

	public Renderer[] HorseRenderers;

	public Renderer[] HorseHairRenderers;

	public const uint HORSE_PREFAB_ID = 497279334u;

	public GameObject NameRoot;

	public RustText NameText;

	public TrophyRoot[] Trophies;

	public HeadData TrophyData => CurrentTrophyData;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("HuntingTrophy.OnRpcMessage", 0);
		try
		{
			if (rpc == 1170506026 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerRequestClear "));
				}
				TimeWarning val2 = TimeWarning.New("ServerRequestClear", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1170506026u, "ServerRequestClear", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerRequestClear(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerRequestClear");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3878554182u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerRequestSubmit "));
				}
				TimeWarning val2 = TimeWarning.New("ServerRequestSubmit", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3878554182u, "ServerRequestSubmit", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							ServerRequestSubmit();
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ServerRequestSubmit");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return 0;
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if ((Object)(object)ItemModAssociatedEntity<HeadEntity>.GetAssociatedEntity(item) == (Object)null)
		{
			return false;
		}
		return base.ItemFilter(item, targetSlot);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ServerRequestSubmit()
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot == null)
		{
			return;
		}
		HeadEntity associatedEntity = ItemModAssociatedEntity<HeadEntity>.GetAssociatedEntity(slot);
		if ((Object)(object)associatedEntity != (Object)null && !CanSubmitHead(associatedEntity))
		{
			return;
		}
		if ((Object)(object)associatedEntity != (Object)null)
		{
			if (CurrentTrophyData == null)
			{
				CurrentTrophyData = Pool.Get<HeadData>();
				associatedEntity.CurrentTrophyData.CopyTo(CurrentTrophyData);
				CurrentTrophyData.count = 1u;
			}
			else
			{
				HeadData currentTrophyData = CurrentTrophyData;
				currentTrophyData.count++;
			}
		}
		for (int i = 1; i <= base.inventory.capacity; i++)
		{
			if (base.inventory.GetSlot(i) == null)
			{
				slot.MoveToContainer(base.inventory, i);
				break;
			}
		}
		SendNetworkUpdate();
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ServerRequestClear(RPCMessage msg)
	{
		if (CurrentTrophyData != null)
		{
			Pool.Free<HeadData>(ref CurrentTrophyData);
			Item[] array = base.inventory.itemList.ToArray();
			foreach (Item item in array)
			{
				msg.player.GiveItem(item);
			}
			SendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (CurrentTrophyData != null)
		{
			info.msg.headData = Pool.Get<HeadData>();
			CurrentTrophyData.CopyTo(info.msg.headData);
		}
	}

	public bool CanSubmitHead(HeadEntity headEnt)
	{
		bool flag = false;
		if ((Object)(object)headEnt == (Object)null || headEnt.CurrentTrophyData == null)
		{
			return false;
		}
		bool flag2 = CurrentTrophyData != null;
		if (flag2 && headEnt.CurrentTrophyData.entitySource == CurrentTrophyData.entitySource && headEnt.CurrentTrophyData.playerId == CurrentTrophyData.playerId && headEnt.CurrentTrophyData.horseBreed == CurrentTrophyData.horseBreed)
		{
			flag = true;
		}
		if (!flag && flag2)
		{
			GameObject headSource = headEnt.GetHeadSource();
			BasePlayer basePlayer = default(BasePlayer);
			if ((Object)(object)headSource != (Object)null && headSource.TryGetComponent<BasePlayer>(ref basePlayer) && (Object)(object)GetCurrentTrophyDataSource() == (Object)(object)headSource)
			{
				flag = true;
			}
		}
		if (!flag2)
		{
			TrophyRoot[] trophies = Trophies;
			foreach (TrophyRoot trophyRoot in trophies)
			{
				if (trophyRoot.Matches(headEnt))
				{
					flag = true;
					break;
				}
			}
		}
		return flag;
		GameObject GetCurrentTrophyDataSource()
		{
			return GameManager.server.FindPrefab(CurrentTrophyData.entitySource);
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.headData != null)
		{
			if (CurrentTrophyData == null)
			{
				CurrentTrophyData = Pool.Get<HeadData>();
			}
			info.msg.headData.CopyTo(CurrentTrophyData);
		}
		else if (CurrentTrophyData != null)
		{
			Pool.Free<HeadData>(ref CurrentTrophyData);
		}
	}

	public override void ResetState()
	{
		base.ResetState();
		if (CurrentTrophyData != null)
		{
			Pool.Free<HeadData>(ref CurrentTrophyData);
		}
		TrophyRoot[] trophies = Trophies;
		for (int i = 0; i < trophies.Length; i++)
		{
			TrophyRoot trophyRoot = trophies[i];
			if ((Object)(object)trophyRoot.Root != (Object)null)
			{
				trophyRoot.Root.SetActive(false);
			}
		}
		if ((Object)(object)NameRoot != (Object)null)
		{
			NameRoot.SetActive(false);
		}
		if ((Object)(object)MaleRope != (Object)null)
		{
			MaleRope.SetActive(false);
		}
		if ((Object)(object)FemaleRope != (Object)null)
		{
			FemaleRope.SetActive(false);
		}
	}
}


using System;
using ProtoBuf;
using UnityEngine;

[Serializable]
public struct TrophyRoot
{
	public GameObjectRef SourceEntity;

	public GameObject Root;

	public uint GetSourcePrefabId()
	{
		BaseEntity entity = SourceEntity.GetEntity();
		if ((Object)(object)entity != (Object)null)
		{
			return entity.prefabID;
		}
		return 0u;
	}

	public bool Matches(HeadEntity headEnt)
	{
		BaseEntity entity = SourceEntity.GetEntity();
		bool flag = (Object)(object)entity != (Object)null && headEnt.CurrentTrophyData != null && entity.prefabID == headEnt.CurrentTrophyData.entitySource;
		if (!flag)
		{
			GameObject headSource = headEnt.GetHeadSource();
			BasePlayer basePlayer = default(BasePlayer);
			if ((Object)(object)headSource != (Object)null && headSource.TryGetComponent<BasePlayer>(ref basePlayer) && ((Component)entity).TryGetComponent<BasePlayer>(ref basePlayer))
			{
				flag = true;
			}
		}
		return flag;
	}

	public bool Matches(HeadData data)
	{
		if (data == null)
		{
			return false;
		}
		BaseEntity entity = SourceEntity.GetEntity();
		bool flag = (Object)(object)entity != (Object)null && entity.prefabID == data.entitySource;
		if (!flag)
		{
			GameObject val = null;
			val = GameManager.server.FindPrefab(data.entitySource);
			BasePlayer basePlayer = default(BasePlayer);
			if ((Object)(object)val != (Object)null && val.TryGetComponent<BasePlayer>(ref basePlayer) && ((Component)entity).TryGetComponent<BasePlayer>(ref basePlayer))
			{
				flag = true;
			}
		}
		return flag;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class ImageStorageEntity : BaseEntity
{
	private struct ImageRequest
	{
		public IImageReceiver Receiver;

		public float Time;
	}

	private List<ImageRequest> _requests;

	protected virtual FileStorage.Type StorageType => FileStorage.Type.jpg;

	protected virtual uint CrcToLoad => 0u;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ImageStorageEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 652912521 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ImageRequested "));
				}
				TimeWarning val2 = TimeWarning.New("ImageRequested", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(652912521u, "ImageRequested", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ImageRequested(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ImageRequested");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	private void ImageRequested(RPCMessage msg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)msg.player == (Object)null))
		{
			byte[] array = FileStorage.server.Get(CrcToLoad, StorageType, net.ID);
			if (array == null)
			{
				Debug.LogWarning((object)"Image entity has no image!");
				return;
			}
			SendInfo val = default(SendInfo);
			((SendInfo)(ref val))..ctor(msg.connection);
			val.method = (SendMethod)0;
			val.channel = 2;
			SendInfo sendInfo = val;
			ClientRPC(RpcTarget.SendInfo("ReceiveImage", sendInfo), (uint)array.Length, array);
		}
	}
}


private struct ImageRequest
{
	public IImageReceiver Receiver;

	public float Time;
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class IndustrialConveyor : IndustrialEntity
{
	public enum ConveyorMode
	{
		Any,
		And,
		Not
	}

	public struct ActiveBufferTransfer
	{
		public ItemFilter ForFilter;

		public int Remaining;
	}

	[JsonModel]
	public struct ItemFilter : IEquatable<ItemFilter>
	{
		[JsonIgnore]
		public ItemDefinition TargetItem;

		public ItemCategory? TargetCategory;

		public int MaxAmountInOutput;

		public int BufferAmount;

		public int MinAmountInInput;

		public bool IsBlueprint;

		public string TargetItemName
		{
			get
			{
				if (!((Object)(object)TargetItem != (Object)null))
				{
					return string.Empty;
				}
				return TargetItem.shortname;
			}
			set
			{
				TargetItem = ItemManager.FindItemDefinition(value);
			}
		}

		public void CopyTo(ItemFilter target)
		{
			if ((Object)(object)TargetItem != (Object)null)
			{
				target.itemDef = TargetItem.itemid;
			}
			target.maxAmountInDestination = MaxAmountInOutput;
			if (TargetCategory.HasValue)
			{
				target.itemCategory = (int)TargetCategory.Value;
			}
			else
			{
				target.itemCategory = -1;
			}
			target.isBlueprint = (IsBlueprint ? 1 : 0);
			target.bufferAmount = BufferAmount;
			target.retainMinimum = MinAmountInInput;
		}

		public ItemFilter(ItemFilter from)
		{
			this = new ItemFilter
			{
				TargetItem = ItemManager.FindItemDefinition(from.itemDef),
				MaxAmountInOutput = from.maxAmountInDestination
			};
			if (from.itemCategory >= 0)
			{
				TargetCategory = (ItemCategory)from.itemCategory;
			}
			else
			{
				TargetCategory = null;
			}
			IsBlueprint = from.isBlueprint == 1;
			BufferAmount = from.bufferAmount;
			MinAmountInInput = from.retainMinimum;
		}

		public bool Equals(ItemFilter other)
		{
			if (object.Equals(TargetItem, other.TargetItem) && TargetCategory == other.TargetCategory && MaxAmountInOutput == other.MaxAmountInOutput && BufferAmount == other.BufferAmount && MinAmountInInput == other.MinAmountInInput)
			{
				return IsBlueprint == other.IsBlueprint;
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj is ItemFilter other)
			{
				return Equals(other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(TargetItem, TargetCategory, MaxAmountInOutput, BufferAmount, MinAmountInInput, IsBlueprint);
		}
	}

	public int MaxStackSizePerMove = 128;

	public GameObjectRef FilterDialog;

	private const float ScreenUpdateRange = 30f;

	public const Flags FilterPassFlag = Flags.Reserved9;

	public const Flags FilterFailFlag = Flags.Reserved10;

	public const int MaxContainerDepth = 32;

	public SoundDefinition transferItemSoundDef;

	public SoundDefinition transferItemStartSoundDef;

	public List<ItemFilter> filterItems = new List<ItemFilter>();

	public ConveyorMode mode;

	public const int MAX_FILTER_SIZE = 30;

	public SpriteRenderer IconTransferSprite;

	private bool refreshInputOutputs;

	private IIndustrialStorage workerOutput;

	private Func<IIndustrialStorage, int, bool> filterFunc;

	private List<ContainerInputOutput> splitOutputs = new List<ContainerInputOutput>();

	private List<ContainerInputOutput> splitInputs = new List<ContainerInputOutput>();

	private bool? lastFilterState;

	private Stopwatch transferStopWatch = new Stopwatch();

	private bool multiFrameTransferInProcess;

	private int multiFrameOutputIndex;

	private int multiFrameInputIndex;

	private bool isFirstTransfer = true;

	private TimeUntil strictModeUntil;

	private static List<Item> inputItemSortedList = new List<Item>(64);

	private static List<Item> outputItemSortedList = new List<Item>(64);

	private static ListHashSet<ContainerInputOutput> notifyContainerMoveEnd = new ListHashSet<ContainerInputOutput>(64);

	private static Dictionary<Item, (ItemFilter filter, int index)> filterPassList = new Dictionary<Item, (ItemFilter, int)>(256);

	private static Dictionary<Item, ContainerInputOutput> item2ContainerLookup = new Dictionary<Item, ContainerInputOutput>(256);

	private bool filtersNeedParsing = true;

	private Dictionary<ItemDefinition, (ItemFilter filter, int index)> quickItemFilterLookup = new Dictionary<ItemDefinition, (ItemFilter, int)>(32);

	private Dictionary<ItemCategory, (ItemFilter filter, int index)> quickItemCategoryLookup = new Dictionary<ItemCategory, (ItemFilter, int)>(32);

	private Dictionary<ItemDefinition, (ItemFilter filter, int index)> quickItemBlueprintLookup = new Dictionary<ItemDefinition, (ItemFilter, int)>(32);

	private List<ActiveBufferTransfer> activeBuffers = new List<ActiveBufferTransfer>();

	private bool wasOnWhenPowerLost;

	public bool strictMode { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("IndustrialConveyor.OnRpcMessage", 0);
		try
		{
			if (rpc == 617569194 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ChangeFilters "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ChangeFilters", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(617569194u, "RPC_ChangeFilters", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(617569194u, "RPC_ChangeFilters", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_ChangeFilters(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_ChangeFilters");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3731379386u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestUpToDateFilters "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestUpToDateFilters", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3731379386u, "Server_RequestUpToDateFilters", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3731379386u, "Server_RequestUpToDateFilters", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_RequestUpToDateFilters(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_RequestUpToDateFilters");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SvSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SvSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4167839872u, "SvSwitch", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4167839872u, "SvSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SvSwitch(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SvSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool flag = next.HasFlag(Flags.On);
		if (old.HasFlag(Flags.On) != flag && base.isServer)
		{
			float conveyorMoveFrequency = Server.conveyorMoveFrequency;
			if (flag && conveyorMoveFrequency > 0f)
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)ScheduleMove, conveyorMoveFrequency, conveyorMoveFrequency, conveyorMoveFrequency * 0.5f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ScheduleMove);
			}
		}
	}

	private void ScheduleMove()
	{
		((ObjectWorkQueue<IndustrialEntity>)IndustrialEntity.Queue).Add((IndustrialEntity)this);
	}

	private Item GetItemToMove(IIndustrialStorage storage, out ItemFilter associatedFilter, int slot, ItemContainer targetContainer = null)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		associatedFilter = default(ItemFilter);
		(ItemFilter, int) tuple = default((ItemFilter, int));
		if (storage == null || storage.Container == null)
		{
			return null;
		}
		if (storage.Container.IsEmpty())
		{
			return null;
		}
		Vector2i val = storage.OutputSlotRange(slot);
		foreach (Item item in storage.Container.itemList)
		{
			if (item.position < val.x || item.position > val.y)
			{
				continue;
			}
			tuple = default((ItemFilter, int));
			if (item != null && (filterItems.Count == 0 || FilterHasItem(item, out tuple)))
			{
				(associatedFilter, _) = tuple;
				if (targetContainer == null || !((Object)(object)associatedFilter.TargetItem != (Object)null) || associatedFilter.MaxAmountInOutput <= 0 || targetContainer.GetTotalItemAmount(item, val.x, val.y) < associatedFilter.MaxAmountInOutput)
				{
					return item;
				}
			}
		}
		return null;
	}

	private bool FilterHasItem(Item item, out (ItemFilter filter, int index) filter)
	{
		filter = default((ItemFilter, int));
		TimeWarning val = TimeWarning.New("FilterHasItem", 0);
		try
		{
			if (quickItemFilterLookup.TryGetValue(item.info, out filter))
			{
				return true;
			}
			if (quickItemCategoryLookup.TryGetValue(item.info.category, out filter))
			{
				return true;
			}
			if (item.IsBlueprint() && quickItemBlueprintLookup.TryGetValue(item.blueprintTargetDef, out filter))
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool FilterMatches(ItemFilter filter, Item item)
	{
		if (item.IsBlueprint() && filter.IsBlueprint && (Object)(object)item.blueprintTargetDef == (Object)(object)filter.TargetItem)
		{
			return true;
		}
		if ((Object)(object)filter.TargetItem == (Object)(object)item.info && !filter.IsBlueprint)
		{
			return true;
		}
		if ((Object)(object)filter.TargetItem != (Object)null && (Object)(object)item.info.isRedirectOf == (Object)(object)filter.TargetItem)
		{
			return true;
		}
		if (filter.TargetCategory.HasValue && item.info.category == filter.TargetCategory)
		{
			return true;
		}
		return false;
	}

	private bool FilterContainerInput(IIndustrialStorage storage, int slot)
	{
		ItemFilter associatedFilter;
		return GetItemToMove(storage, out associatedFilter, slot, workerOutput?.Container) != null;
	}

	private int GetBufferRemainingForFilter(ItemFilter f)
	{
		TimeWarning val = TimeWarning.New("GetBufferRemainingForFilter", 0);
		try
		{
			foreach (ActiveBufferTransfer activeBuffer in activeBuffers)
			{
				if (f.Equals(activeBuffer.ForFilter))
				{
					return activeBuffer.Remaining;
				}
			}
			return 0;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void DeductBufferRemaining(ItemFilter f, int amount)
	{
		TimeWarning val = TimeWarning.New("DeductBufferRemaining", 0);
		try
		{
			for (int num = activeBuffers.Count - 1; num >= 0; num--)
			{
				ActiveBufferTransfer value = activeBuffers[num];
				if (f.Equals(value.ForFilter))
				{
					value.Remaining -= amount;
					if (value.Remaining <= 0)
					{
						activeBuffers.RemoveAt(num);
						num--;
					}
					else
					{
						activeBuffers[num] = value;
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ClearBufferForFilter(ItemFilter f)
	{
		TimeWarning val = TimeWarning.New("ClearBufferForFilter", 0);
		try
		{
			for (int num = activeBuffers.Count - 1; num >= 0; num--)
			{
				if (f.Equals(activeBuffers[num].ForFilter))
				{
					activeBuffers.RemoveAt(num);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void LoadContainerIntoItemList(List<Item> targetList, ItemContainer container)
	{
		targetList.Clear();
		for (int i = 0; i < container.capacity; i++)
		{
			targetList.Add(null);
		}
		foreach (Item item in container.itemList)
		{
			if (item != null && item.position >= 0 && item.position < targetList.Count)
			{
				targetList[item.position] = item;
			}
		}
	}

	protected override void RunJob()
	{
		base.RunJob();
		RunConveyor();
	}

	public void RunConveyor()
	{
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e54: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e9e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e18: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f15: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f1a: Unknown result type (might be due to invalid IL or missing references)
		//IL_055e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0563: Unknown result type (might be due to invalid IL or missing references)
		//IL_058d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0592: Unknown result type (might be due to invalid IL or missing references)
		//IL_0666: Unknown result type (might be due to invalid IL or missing references)
		//IL_066d: Unknown result type (might be due to invalid IL or missing references)
		//IL_075e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0765: Unknown result type (might be due to invalid IL or missing references)
		//IL_0707: Unknown result type (might be due to invalid IL or missing references)
		//IL_070e: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0873: Unknown result type (might be due to invalid IL or missing references)
		//IL_087a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0822: Unknown result type (might be due to invalid IL or missing references)
		//IL_0829: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a37: Unknown result type (might be due to invalid IL or missing references)
		//IL_0af7: Unknown result type (might be due to invalid IL or missing references)
		if (Server.conveyorMoveFrequency <= 0f)
		{
			return;
		}
		if (filterFunc == null)
		{
			filterFunc = FilterContainerInput;
		}
		notifyContainerMoveEnd.Clear();
		if (refreshInputOutputs)
		{
			refreshInputOutputs = false;
			splitInputs.Clear();
			splitOutputs.Clear();
			List<IOEntity> list = Pool.Get<List<IOEntity>>();
			FindContainerSource(splitInputs, 32, input: true, list);
			list.Clear();
			FindContainerSource(splitOutputs, 32, input: false, list, -1, MaxStackSizePerMove);
			Pool.FreeUnmanaged<IOEntity>(ref list);
			multiFrameTransferInProcess = false;
			multiFrameInputIndex = 0;
			multiFrameOutputIndex = 0;
		}
		TimeWarning val = TimeWarning.New("ParseFilter", 0);
		try
		{
			if (filtersNeedParsing)
			{
				quickItemFilterLookup.Clear();
				quickItemCategoryLookup.Clear();
				quickItemBlueprintLookup.Clear();
				for (int i = 0; i < filterItems.Count; i++)
				{
					ItemFilter item2 = filterItems[i];
					if (!item2.IsBlueprint && (Object)(object)item2.TargetItem != (Object)null)
					{
						quickItemFilterLookup.Add(item2.TargetItem, (item2, i));
					}
					if (item2.TargetCategory.HasValue)
					{
						quickItemCategoryLookup.Add(item2.TargetCategory.Value, (item2, i));
					}
					if (item2.IsBlueprint)
					{
						quickItemBlueprintLookup.Add(item2.TargetItem, (item2, i));
					}
				}
				filtersNeedParsing = false;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		bool hasItems = CheckIfAnyInputPassesFilters(splitInputs);
		if ((!lastFilterState.HasValue || hasItems != lastFilterState) && !hasItems)
		{
			UpdateFilterPassthroughs();
		}
		if (!hasItems)
		{
			return;
		}
		transferStopWatch.Restart();
		IndustrialConveyorTransfer transfer = Pool.Get<IndustrialConveyorTransfer>();
		try
		{
			bool flag = false;
			bool flag2 = false;
			transfer.ItemTransfers = Pool.Get<List<ItemTransfer>>();
			transfer.inputEntities = Pool.Get<List<NetworkableId>>();
			transfer.outputEntities = Pool.Get<List<NetworkableId>>();
			List<int> list2 = Pool.Get<List<int>>();
			filterPassList.Clear();
			item2ContainerLookup.Clear();
			foreach (ContainerInputOutput splitInput in splitInputs)
			{
				IIndustrialStorage storage = splitInput.Storage;
				ItemContainer container = storage.Container;
				if (container == null || container.IsEmpty())
				{
					continue;
				}
				Vector2i val2 = storage.OutputSlotRange(splitInput.SlotIndex);
				foreach (Item item7 in container.itemList)
				{
					if (filterPassList.ContainsKey(item7))
					{
						continue;
					}
					bool flag3 = item7.position >= val2.x && item7.position <= val2.y;
					(ItemFilter, int) filter2 = default((ItemFilter, int));
					if (filterItems.Count > 0 && flag3)
					{
						if (mode == ConveyorMode.Any || mode == ConveyorMode.And)
						{
							flag3 = FilterHasItem(item7, out filter2);
						}
						if (mode == ConveyorMode.Not)
						{
							flag3 = !FilterHasItem(item7, out filter2);
						}
					}
					if (flag3)
					{
						filterPassList.Add(item7, filter2);
						item2ContainerLookup.Add(item7, splitInput);
					}
				}
			}
			if (filterPassList.Count == 0)
			{
				TimeWarning val3 = TimeWarning.New("EarlyAbortPreFilter", 0);
				try
				{
					return;
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			int num = 0;
			int count = splitOutputs.Count;
			bool flag4 = false;
			foreach (ContainerInputOutput splitOutput in splitOutputs)
			{
				TimeWarning val4 = TimeWarning.New("RunOutput", 0);
				try
				{
					workerOutput = splitOutput.Storage;
					if (workerOutput == null || workerOutput.Container == null)
					{
						continue;
					}
					if (multiFrameTransferInProcess && multiFrameOutputIndex > num)
					{
						num++;
						continue;
					}
					int num2 = 0;
					LoadContainerIntoItemList(outputItemSortedList, splitOutput.Storage.Container);
					foreach (KeyValuePair<Item, (ItemFilter, int)> filterPass in filterPassList)
					{
						TimeWarning val5 = TimeWarning.New("AttemptMoveFilteredItem", 0);
						try
						{
							int num3 = 0;
							num2++;
							if (multiFrameTransferInProcess && num2 < multiFrameInputIndex)
							{
								continue;
							}
							if (multiFrameTransferInProcess)
							{
								multiFrameTransferInProcess = false;
							}
							if (filterPass.Key.parent == splitOutput.Storage.Container)
							{
								continue;
							}
							ItemContainer container2 = splitOutput.Storage.Container;
							ItemContainer container3 = item2ContainerLookup[filterPass.Key].Storage.Container;
							ContainerInputOutput containerInputOutput = item2ContainerLookup[filterPass.Key];
							(ItemFilter, int) value = filterPass.Value;
							notifyContainerMoveEnd.TryAdd(containerInputOutput);
							containerInputOutput.Storage.OnStorageItemTransferBegin();
							Vector2i val6 = containerInputOutput.Storage.OutputSlotRange(containerInputOutput.SlotIndex);
							bool flag5 = !container2.IsFull();
							TimeWarning val7 = TimeWarning.New("OutSlot", 0);
							try
							{
								Vector2i val8 = splitOutput.Storage.InputSlotRange(splitOutput.SlotIndex);
								Item key = filterPass.Key;
								if (key.parent != containerInputOutput.Storage.Container)
								{
									continue;
								}
								if (key == null)
								{
									goto IL_0cab;
								}
								bool flag6 = true;
								if (flag6 && key.info.stackable == 1 && !flag5)
								{
									flag6 = false;
								}
								if (flag6 && key.info.stackable > 1 && !flag5 && !container2.HasAnyWithSpace(key.info))
								{
									flag6 = false;
								}
								if (!flag6)
								{
									continue;
								}
								bool flag7 = mode == ConveyorMode.And || mode == ConveyorMode.Any;
								val = TimeWarning.New("MinMaxCheck_CountInOutput", 0);
								try
								{
									if (flag7 && (Object)(object)value.Item1.TargetItem != (Object)null && value.Item1.MaxAmountInOutput > 0 && splitOutput.Storage.Container.GetTotalItemAmount(key, val8.x, val8.y) >= value.Item1.MaxAmountInOutput)
									{
										flag = true;
										continue;
									}
								}
								finally
								{
									((IDisposable)val)?.Dispose();
								}
								int num4 = (int)((float)Mathf.Min(MaxStackSizePerMove, key.info.stackable) / (float)count);
								val = TimeWarning.New("MinMax_Amounts", 0);
								try
								{
									if (!flag7 || value.Item1.MinAmountInInput <= 0)
									{
										goto IL_078e;
									}
									if ((Object)(object)value.Item1.TargetItem != (Object)null && FilterMatchItem(value.Item1, key))
									{
										int totalItemAmount = container3.GetTotalItemAmount(key, val6.x, val6.y);
										num4 = Mathf.Min(num4, totalItemAmount - value.Item1.MinAmountInInput);
									}
									else if (value.Item1.TargetCategory.HasValue)
									{
										num4 = Mathf.Min(num4, container3.GetTotalCategoryAmount(value.Item1.TargetCategory.Value, val8.x, val8.y) - value.Item1.MinAmountInInput);
									}
									if (num4 != 0)
									{
										goto IL_078e;
									}
									goto end_IL_06c6;
									IL_078e:
									if (key.amount == 1 || (num4 <= 0 && key.amount > 0))
									{
										num4 = 1;
									}
									if (flag7 && value.Item1.BufferAmount > 0)
									{
										num4 = Mathf.Min(num4, GetBufferRemainingForFilter(value.Item1));
									}
									if (flag7 && value.Item1.MaxAmountInOutput > 0)
									{
										if ((Object)(object)value.Item1.TargetItem != (Object)null && FilterMatchItem(value.Item1, key))
										{
											num4 = Mathf.Min(num4, value.Item1.MaxAmountInOutput - container2.GetTotalItemAmount(key, val8.x, val8.y));
										}
										else if (value.Item1.TargetCategory.HasValue)
										{
											num4 = Mathf.Min(num4, value.Item1.MaxAmountInOutput - container2.GetTotalCategoryAmount(value.Item1.TargetCategory.Value, val8.x, val8.y));
										}
										if ((float)num4 <= 0f)
										{
											flag = true;
										}
									}
									goto IL_08a7;
									end_IL_06c6:;
								}
								finally
								{
									((IDisposable)val)?.Dispose();
								}
								goto end_IL_057f;
								IL_0cab:
								if (flag4)
								{
									break;
								}
								goto end_IL_057f;
								IL_08a7:
								float num5 = Mathf.Min(key.amount, num4);
								if (num5 > 0f && num5 < 1f)
								{
									num5 = 1f;
								}
								num4 = (int)num5;
								if (num4 <= 0 || !container2.QuickIndustrialPreCheck(key, val8, 0, out var foundSlot))
								{
									continue;
								}
								val = TimeWarning.New("OnStorageItemTransferBegin", 0);
								try
								{
									splitOutput.Storage.OnStorageItemTransferBegin();
								}
								finally
								{
									((IDisposable)val)?.Dispose();
								}
								val = TimeWarning.New("NotifyContainerMoveEnd", 0);
								try
								{
									notifyContainerMoveEnd.TryAdd(splitOutput);
								}
								finally
								{
									((IDisposable)val)?.Dispose();
								}
								bool flag8 = false;
								int amount2 = key.amount;
								Item item3 = ((foundSlot == -1) ? null : outputItemSortedList[foundSlot]);
								if (Server.industrialAllowQuickMove && foundSlot >= 0 && item3 != null && !item3.IsRemoved() && item3.info.itemid == key.info.itemid && item3 != key && key.CanStack(item3))
								{
									int num6 = Mathf.Min(num4, item3.info.stackable - item3.amount);
									item3.amount += num6;
									key.UseItem(num6);
									amount2 = num6;
									item3.MarkDirty();
									flag8 = true;
									if (key.amount <= 0)
									{
										flag2 = true;
									}
								}
								Item item4 = null;
								if (!flag8 && key.amount > num4)
								{
									item4 = key.SplitItem(num4);
									amount2 = item4.amount;
								}
								val = TimeWarning.New("AttemptMove", 0);
								try
								{
									if (!flag8)
									{
										for (int j = val8.x; j <= val8.y; j++)
										{
											Item item5 = ((j == -1) ? null : outputItemSortedList[j]);
											if (item5 != null && (item5.info.itemid != key.info.itemid || item5.condition != key.condition || item5.amount >= item5.info.stackable))
											{
												continue;
											}
											TimeWarning val9 = TimeWarning.New("MoveToContainer", 0);
											try
											{
												if ((item4 ?? key).MoveToContainer(container2, j, allowStack: true, ignoreStackLimit: false, null, allowSwap: false))
												{
													flag8 = true;
													flag5 = !container2.IsFull();
													break;
												}
												flag5 = !container2.IsFull();
											}
											finally
											{
												((IDisposable)val9)?.Dispose();
											}
										}
									}
								}
								finally
								{
									((IDisposable)val)?.Dispose();
								}
								DeductBufferRemaining(value.Item1, amount2);
								val = TimeWarning.New("ItemCleanup", 0);
								try
								{
									if (!flag8 && item4 != null)
									{
										key.amount += item4.amount;
										key.MarkDirty();
										item4.Remove();
										item4 = null;
									}
								}
								finally
								{
									((IDisposable)val)?.Dispose();
								}
								val = TimeWarning.New("UpdateTransfers", 0);
								try
								{
									if (flag8)
									{
										num3++;
										TimeWarning val10 = TimeWarning.New("AddTransfer", 0);
										try
										{
											if (item4 != null)
											{
												AddTransfer(item4.info.itemid, amount2, containerInputOutput.Storage.IndustrialEntity, splitOutput.Storage.IndustrialEntity);
											}
											else
											{
												AddTransfer(key.info.itemid, amount2, containerInputOutput.Storage.IndustrialEntity, splitOutput.Storage.IndustrialEntity);
											}
										}
										finally
										{
											((IDisposable)val10)?.Dispose();
										}
										val10 = TimeWarning.New("UpdateHashes", 0);
										try
										{
											LoadContainerIntoItemList(inputItemSortedList, container3);
											LoadContainerIntoItemList(outputItemSortedList, container2);
										}
										finally
										{
											((IDisposable)val10)?.Dispose();
										}
									}
									else if (!list2.Contains(num))
									{
										list2.Add(num);
									}
								}
								finally
								{
									((IDisposable)val)?.Dispose();
								}
								if (strictMode && transferStopWatch.Elapsed.TotalMilliseconds >= (double)(Server.industrialFrameBudgetMs * 3f) && !isFirstTransfer)
								{
									flag4 = true;
									multiFrameTransferInProcess = true;
									multiFrameOutputIndex = num;
									multiFrameInputIndex = num2;
									break;
								}
								if (num3 >= Server.maxItemStacksMovedPerTickIndustrial)
								{
									break;
								}
								goto IL_0cab;
								end_IL_057f:;
							}
							finally
							{
								((IDisposable)val7)?.Dispose();
							}
						}
						finally
						{
							((IDisposable)val5)?.Dispose();
						}
					}
					if (flag4)
					{
						break;
					}
					if (strictMode && !flag4 && transferStopWatch.Elapsed.TotalMilliseconds >= (double)(Server.industrialFrameBudgetMs * 3f) && !isFirstTransfer)
					{
						multiFrameTransferInProcess = true;
						multiFrameOutputIndex = num;
						multiFrameInputIndex = 0;
						break;
					}
					num++;
				}
				finally
				{
					((IDisposable)val4)?.Dispose();
				}
			}
			if (transfer.ItemTransfers.Count == 0 && hasItems && flag)
			{
				hasItems = false;
			}
			if (!lastFilterState.HasValue || hasItems != lastFilterState)
			{
				UpdateFilterPassthroughs();
			}
			double totalMilliseconds = transferStopWatch.Elapsed.TotalMilliseconds;
			if (Server.industrialTransferStrictTimeLimits && !strictMode)
			{
				if (totalMilliseconds >= (double)(Server.industrialFrameBudgetMs * 3f))
				{
					TimeWarning val11 = TimeWarning.New("EnterStrictMode", 0);
					try
					{
						strictMode = true;
						strictModeUntil = TimeUntil.op_Implicit(120f);
					}
					finally
					{
						((IDisposable)val11)?.Dispose();
					}
				}
				else
				{
					TimeWarning val12 = TimeWarning.New("NoStrictModeNecessary", 0);
					try
					{
					}
					finally
					{
						((IDisposable)val12)?.Dispose();
					}
				}
			}
			else if (strictMode && TimeUntil.op_Implicit(strictModeUntil) < 0f)
			{
				strictMode = false;
			}
			Pool.FreeUnmanaged<int>(ref list2);
			if (flag2)
			{
				ItemManager.DoRemoves();
			}
			if (transfer.ItemTransfers.Count > 0)
			{
				List<Connection> list3 = Pool.Get<List<Connection>>();
				BaseNetworkable.GetCloseConnections(((Component)this).transform.position, 30f, list3);
				ClientRPC(RpcTarget.Players("ReceiveItemTransferDetails", list3), transfer);
				Pool.FreeUnmanaged<Connection>(ref list3);
			}
			isFirstTransfer = false;
		}
		finally
		{
			if (transfer != null)
			{
				((IDisposable)transfer).Dispose();
			}
		}
		if (multiFrameTransferInProcess && multiFrameOutputIndex == splitOutputs.Count)
		{
			multiFrameTransferInProcess = false;
		}
		Enumerator<ContainerInputOutput> enumerator4 = notifyContainerMoveEnd.GetEnumerator();
		try
		{
			while (enumerator4.MoveNext())
			{
				enumerator4.Current.Storage.OnStorageItemTransferEnd();
			}
		}
		finally
		{
			((IDisposable)enumerator4/*cast due to .constrained prefix*/).Dispose();
		}
		void AddTransfer(int itemId, int amount, BaseEntity fromEntity, BaseEntity toEntity)
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			if (transfer != null && transfer.ItemTransfers != null)
			{
				if ((Object)(object)fromEntity != (Object)null && !transfer.inputEntities.Contains(fromEntity.net.ID))
				{
					transfer.inputEntities.Add(fromEntity.net.ID);
				}
				if ((Object)(object)toEntity != (Object)null && !transfer.outputEntities.Contains(toEntity.net.ID))
				{
					transfer.outputEntities.Add(toEntity.net.ID);
				}
				for (int k = 0; k < transfer.ItemTransfers.Count; k++)
				{
					ItemTransfer val13 = transfer.ItemTransfers[k];
					if (val13.itemId == itemId)
					{
						val13.amount += amount;
						transfer.ItemTransfers[k] = val13;
						return;
					}
				}
				ItemTransfer val14 = default(ItemTransfer);
				val14.itemId = itemId;
				val14.amount = amount;
				ItemTransfer item6 = val14;
				transfer.ItemTransfers.Add(item6);
			}
		}
		static bool FilterMatchItem(ItemFilter filter, Item item)
		{
			if ((Object)(object)filter.TargetItem != (Object)null && ((Object)(object)filter.TargetItem == (Object)(object)item.info || (item.IsBlueprint() == filter.IsBlueprint && (Object)(object)filter.TargetItem == (Object)(object)item.blueprintTargetDef)))
			{
				return true;
			}
			return false;
		}
		void UpdateFilterPassthroughs()
		{
			lastFilterState = hasItems;
			SetFlag(Flags.Reserved9, hasItems, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved10, !hasItems);
			ensureOutputsUpdated = true;
			MarkDirty();
		}
	}

	protected override void OnIndustrialNetworkChanged()
	{
		base.OnIndustrialNetworkChanged();
		refreshInputOutputs = true;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		refreshInputOutputs = true;
		filtersNeedParsing = true;
	}

	private bool CheckIfAnyInputPassesFilters(List<ContainerInputOutput> inputs)
	{
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		if (filterItems.Count == 0)
		{
			foreach (ContainerInputOutput input in inputs)
			{
				if (GetItemToMove(input.Storage, out var _, input.SlotIndex) != null)
				{
					return true;
				}
			}
		}
		else
		{
			int num = 0;
			int num2 = 0;
			if (mode == ConveyorMode.And)
			{
				num2 = activeBuffers.Count;
			}
			for (int i = 0; i < filterItems.Count; i++)
			{
				ItemFilter itemFilter = filterItems[i];
				int num3 = 0;
				int num4 = 0;
				foreach (ContainerInputOutput input2 in inputs)
				{
					if (input2.Storage.Container == null)
					{
						continue;
					}
					Vector2i val = input2.Storage.OutputSlotRange(input2.SlotIndex);
					foreach (Item item in input2.Storage.Container.itemList)
					{
						if (item == null || item.position < val.x || item.position > val.y)
						{
							continue;
						}
						bool flag = FilterMatches(itemFilter, item);
						if (mode == ConveyorMode.Not)
						{
							flag = !flag;
						}
						if (!flag)
						{
							continue;
						}
						if (itemFilter.BufferAmount > 0)
						{
							num3 += item.amount;
							if (GetBufferRemainingForFilter(itemFilter) > 0)
							{
								num++;
								break;
							}
							if (num3 >= itemFilter.BufferAmount + itemFilter.MinAmountInInput)
							{
								if (mode != ConveyorMode.And)
								{
									activeBuffers.Add(new ActiveBufferTransfer
									{
										ForFilter = itemFilter,
										Remaining = itemFilter.BufferAmount
									});
									filterItems[i] = itemFilter;
								}
								num++;
								break;
							}
						}
						if (itemFilter.MinAmountInInput > 0)
						{
							num4 += item.amount;
							if (num4 > itemFilter.MinAmountInInput + itemFilter.BufferAmount)
							{
								num++;
								break;
							}
						}
						if (itemFilter.BufferAmount == 0 && itemFilter.MinAmountInInput == 0)
						{
							num++;
							break;
						}
					}
					if ((mode == ConveyorMode.Any || mode == ConveyorMode.Not) && num > 0)
					{
						return true;
					}
					if (itemFilter.MinAmountInInput > 0)
					{
						num4 = 0;
					}
				}
				if (GetBufferRemainingForFilter(itemFilter) > 0 && num3 == 0)
				{
					ClearBufferForFilter(itemFilter);
					filterItems[i] = itemFilter;
				}
			}
			if (mode == ConveyorMode.And && num > 0 && (num == filterItems.Count || num == num2))
			{
				if (num2 == 0)
				{
					for (int j = 0; j < filterItems.Count; j++)
					{
						activeBuffers.Add(new ActiveBufferTransfer
						{
							ForFilter = filterItems[j],
							Remaining = filterItems[j].BufferAmount
						});
					}
				}
				return true;
			}
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (filterItems.Count == 0)
		{
			return;
		}
		info.msg.industrialConveyor = Pool.Get<IndustrialConveyor>();
		info.msg.industrialConveyor.filters = Pool.Get<List<ItemFilter>>();
		info.msg.industrialConveyor.conveyorMode = (int)mode;
		foreach (ItemFilter filterItem in filterItems)
		{
			ItemFilter val = Pool.Get<ItemFilter>();
			filterItem.CopyTo(val);
			info.msg.industrialConveyor.filters.Add(val);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	private void RPC_ChangeFilters(RPCMessage msg)
	{
		if ((Object)(object)msg.player == (Object)null || !msg.player.CanBuild())
		{
			return;
		}
		mode = (ConveyorMode)msg.read.Int32();
		filterItems.Clear();
		ItemFilterList val = msg.read.Proto<ItemFilterList>((ItemFilterList)null);
		try
		{
			if (val.filters == null || Interface.CallHook("OnConveyorFiltersChange", (object)this, (object)msg.player, (object)val) != null)
			{
				return;
			}
			int num = Mathf.Min(val.filters.Count, 60);
			for (int i = 0; i < num; i++)
			{
				if (filterItems.Count >= 30)
				{
					break;
				}
				ItemFilter item = new ItemFilter(val.filters[i]);
				if ((Object)(object)item.TargetItem != (Object)null || item.TargetCategory.HasValue)
				{
					filterItems.Add(item);
				}
			}
			SendNetworkUpdate();
			filtersNeedParsing = true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void SetFilters(List<ItemFilter> newFilter)
	{
		filterItems.Clear();
		filterItems.AddRange(newFilter);
		SendNetworkUpdate();
	}

	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void SvSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnSwitchToggle", (object)this, (object)msg.player) == null)
		{
			SetSwitch(!IsOn());
			Interface.CallHook("OnSwitchToggled", (object)this, (object)msg.player);
		}
	}

	public virtual void SetSwitch(bool wantsOn)
	{
		if (wantsOn != IsOn())
		{
			SetFlag(Flags.On, wantsOn);
			SetFlag(Flags.Busy, b: true);
			SetFlag(Flags.Reserved10, b: false);
			SetFlag(Flags.Reserved9, b: false);
			if (!wantsOn)
			{
				lastFilterState = null;
			}
			ensureOutputsUpdated = true;
			((FacepunchBehaviour)this).Invoke((Action)Unbusy, 0.5f);
			activeBuffers.Clear();
			SendNetworkUpdateImmediate();
			MarkDirty();
		}
	}

	public void Unbusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (inputSlot == 1)
		{
			bool flag = inputAmount >= ConsumptionAmount() && inputAmount > 0;
			if (IsPowered() && IsOn() && !flag)
			{
				wasOnWhenPowerLost = true;
			}
			SetFlag(Flags.Reserved8, flag);
			if (!flag)
			{
				SetFlag(Flags.Reserved9, b: false);
				SetFlag(Flags.Reserved10, b: false);
			}
			currentEnergy = inputAmount;
			ensureOutputsUpdated = true;
			if (inputAmount <= 0 && IsOn())
			{
				SetSwitch(wantsOn: false);
			}
			if (inputAmount > 0 && wasOnWhenPowerLost && !IsOn())
			{
				SetSwitch(wantsOn: true);
				wasOnWhenPowerLost = false;
			}
			MarkDirty();
		}
		if (inputSlot == 2 && !IsOn() && inputAmount > 0 && IsPowered())
		{
			SetSwitch(wantsOn: true);
		}
		if (inputSlot == 3 && IsOn() && inputAmount > 0)
		{
			SetSwitch(wantsOn: false);
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int result = Mathf.Min(1, GetCurrentEnergy());
		switch (outputSlot)
		{
		case 2:
			if (!HasFlag(Flags.Reserved10))
			{
				return 0;
			}
			return result;
		case 3:
			if (!HasFlag(Flags.Reserved9))
			{
				return 0;
			}
			return result;
		case 1:
			return GetCurrentEnergy();
		default:
			return 0;
		}
	}

	public override bool ShouldDrainBattery(IOEntity battery)
	{
		return IsOn();
	}

	public override bool WantsPower(int inputIndex)
	{
		return inputIndex == 1;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	private void Server_RequestUpToDateFilters(RPCMessage msg)
	{
		if (!IsOn())
		{
			return;
		}
		ItemFilterList val = Pool.Get<ItemFilterList>();
		try
		{
			val.filters = Pool.Get<List<ItemFilter>>();
			foreach (ItemFilter filterItem in filterItems)
			{
				ItemFilter val2 = Pool.Get<ItemFilter>();
				filterItem.CopyTo(val2);
				val2.bufferTransferRemaining = GetBufferRemainingForFilter(filterItem);
				val.filters.Add(val2);
			}
			ClientRPC(RpcTarget.Player("Client_ReceiveBufferInfo", msg.player), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		filterItems.Clear();
		if (info.msg.industrialConveyor?.filters == null)
		{
			return;
		}
		mode = (ConveyorMode)info.msg.industrialConveyor.conveyorMode;
		foreach (ItemFilter filter in info.msg.industrialConveyor.filters)
		{
			ItemFilter item = new ItemFilter(filter);
			if ((Object)(object)item.TargetItem != (Object)null || item.TargetCategory.HasValue)
			{
				filterItems.Add(item);
			}
		}
	}
}


public enum ConveyorMode
{
	Any,
	And,
	Not
}


public struct ActiveBufferTransfer
{
	public ItemFilter ForFilter;

	public int Remaining;
}


using System;
using Newtonsoft.Json;
using ProtoBuf;
using UnityEngine;

[JsonModel]
public struct ItemFilter : IEquatable<ItemFilter>
{
	[JsonIgnore]
	public ItemDefinition TargetItem;

	public ItemCategory? TargetCategory;

	public int MaxAmountInOutput;

	public int BufferAmount;

	public int MinAmountInInput;

	public bool IsBlueprint;

	public string TargetItemName
	{
		get
		{
			if (!((Object)(object)TargetItem != (Object)null))
			{
				return string.Empty;
			}
			return TargetItem.shortname;
		}
		set
		{
			TargetItem = ItemManager.FindItemDefinition(value);
		}
	}

	public void CopyTo(ItemFilter target)
	{
		if ((Object)(object)TargetItem != (Object)null)
		{
			target.itemDef = TargetItem.itemid;
		}
		target.maxAmountInDestination = MaxAmountInOutput;
		if (TargetCategory.HasValue)
		{
			target.itemCategory = (int)TargetCategory.Value;
		}
		else
		{
			target.itemCategory = -1;
		}
		target.isBlueprint = (IsBlueprint ? 1 : 0);
		target.bufferAmount = BufferAmount;
		target.retainMinimum = MinAmountInInput;
	}

	public ItemFilter(ItemFilter from)
	{
		this = new ItemFilter
		{
			TargetItem = ItemManager.FindItemDefinition(from.itemDef),
			MaxAmountInOutput = from.maxAmountInDestination
		};
		if (from.itemCategory >= 0)
		{
			TargetCategory = (ItemCategory)from.itemCategory;
		}
		else
		{
			TargetCategory = null;
		}
		IsBlueprint = from.isBlueprint == 1;
		BufferAmount = from.bufferAmount;
		MinAmountInInput = from.retainMinimum;
	}

	public bool Equals(ItemFilter other)
	{
		if (object.Equals(TargetItem, other.TargetItem) && TargetCategory == other.TargetCategory && MaxAmountInOutput == other.MaxAmountInOutput && BufferAmount == other.BufferAmount && MinAmountInInput == other.MinAmountInInput)
		{
			return IsBlueprint == other.IsBlueprint;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is ItemFilter other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(TargetItem, TargetCategory, MaxAmountInOutput, BufferAmount, MinAmountInInput, IsBlueprint);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class IndustrialCrafter : IndustrialEntity, IItemContainerEntity, IIdealSlotEntity, ILootableEntity, IInventoryProvider, LootPanel.IHasLootPanel, IContainerSounds, IIndustrialStorage
{
	public string LootPanelName = "generic";

	public bool NeedsBuildingPrivilegeToUse;

	public bool OnlyOneUser;

	public SoundDefinition ContainerOpenSound;

	public SoundDefinition ContainerCloseSound;

	public AnimationCurve MaterialOffsetCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public const Flags Crafting = Flags.Reserved1;

	public const Flags FullOutput = Flags.Reserved2;

	public Renderer MeshRenderer;

	public ParticleSystemContainer JobCompleteFx;

	public SoundDefinition JobCompleteSoundDef;

	public const int BlueprintSlotStart = 0;

	public const int BlueprintSlotEnd = 3;

	public ItemContainer _inventory;

	private ItemDefinition currentlyCrafting;

	private int currentlyCraftingAmount;

	private const int StorageSize = 13;

	private const int InputSlotStart = 4;

	private const int InputSlotEnd = 8;

	private const int OutputSlotStart = 9;

	private const int OutputSlotEnd = 12;

	private Phrase _lootPanelTitle = new Phrase("industrial.crafter.loot", "Industrial Crafter");

	public TimeUntilWithDuration jobFinishes { get; private set; }

	ItemContainer IItemContainerEntity.inventory => _inventory;

	Transform IItemContainerEntity.Transform => ((Component)this).transform;

	bool IItemContainerEntity.DropsLoot => true;

	float IItemContainerEntity.DestroyLootPercent => 0f;

	bool IItemContainerEntity.DropFloats { get; }

	ulong ILootableEntity.LastLootedBy { get; set; }

	BasePlayer ILootableEntity.LastLootedByPlayer { get; set; }

	ItemContainer IIndustrialStorage.Container => _inventory;

	BaseEntity IIndustrialStorage.IndustrialEntity => this;

	Phrase LootPanel.IHasLootPanel.LootPanelTitle => _lootPanelTitle;

	public SoundDefinition OpenSound => ContainerOpenSound;

	public SoundDefinition CloseSound => ContainerCloseSound;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("IndustrialCrafter.OnRpcMessage", 0);
		try
		{
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SvSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SvSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4167839872u, "SvSwitch", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4167839872u, "SvSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SvSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SvSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool flag = next.HasFlag(Flags.On);
		if (old.HasFlag(Flags.On) != flag && base.isServer)
		{
			float industrialCrafterFrequency = Server.industrialCrafterFrequency;
			if (flag && industrialCrafterFrequency > 0f)
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)CheckCraft, industrialCrafterFrequency, industrialCrafterFrequency, industrialCrafterFrequency * 0.5f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)CheckCraft);
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		DropItems(info?.Initiator);
	}

	public void DropItems(BaseEntity initiator = null)
	{
		StorageContainer.DropItems(this, initiator);
	}

	public bool ShouldDropItemsIndividually()
	{
		return false;
	}

	public void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (_inventory != null)
		{
			BasePlayer player = rpc.player;
			if (Object.op_Implicit((Object)(object)player) && player.CanInteract())
			{
				PlayerOpenLoot(player);
			}
		}
	}

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", (object)player, (object)this) != null)
		{
			return false;
		}
		if (NeedsBuildingPrivilegeToUse && !player.CanBuild())
		{
			return false;
		}
		if (OnlyOneUser && IsOpen())
		{
			player.ChatMessage("Already in use");
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(_inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), LootPanelName);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		CreateInventory(giveUID: true);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Pool.Free<ItemContainer>(ref _inventory);
	}

	public void CreateInventory(bool giveUID)
	{
		Debug.Assert(_inventory == null, "Double init of inventory!");
		_inventory = Pool.Get<ItemContainer>();
		_inventory.entityOwner = this;
		_inventory.canAcceptItem = CanAcceptItem;
		_inventory.ServerInitialize(null, 13);
		if (giveUID)
		{
			_inventory.GiveUID();
		}
	}

	private bool CanAcceptItem(Item item, int index)
	{
		if (index >= 0 && index <= 3 && !item.IsBlueprint())
		{
			return false;
		}
		return true;
	}

	private void CheckCraft()
	{
		((ObjectWorkQueue<IndustrialEntity>)IndustrialEntity.Queue).Add((IndustrialEntity)this);
	}

	private Item GetTargetBlueprint(int index)
	{
		if (_inventory == null)
		{
			return null;
		}
		if (index < 0 || index > 3)
		{
			return null;
		}
		Item slot = _inventory.GetSlot(index);
		if (slot == null || !slot.IsBlueprint())
		{
			return null;
		}
		return slot;
	}

	protected override void RunJob()
	{
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		base.RunJob();
		if (Server.industrialCrafterFrequency <= 0f || HasFlag(Flags.Reserved1) || (Object)(object)currentlyCrafting != (Object)null)
		{
			return;
		}
		for (int i = 0; i <= 3; i++)
		{
			Item targetBlueprint = GetTargetBlueprint(i);
			if (targetBlueprint == null || (Object)(object)GetWorkbench() == (Object)null || GetWorkbench().Workbenchlevel < targetBlueprint.blueprintTargetDef.Blueprint.GetWorkbenchLevel())
			{
				continue;
			}
			ItemBlueprint blueprint = targetBlueprint.blueprintTargetDef.Blueprint;
			if (Interface.CallHook("OnItemCraft", (object)this, (object)blueprint) != null)
			{
				break;
			}
			bool flag = true;
			foreach (ItemAmount ingredient in blueprint.GetIngredients())
			{
				if ((float)GetInputAmount(ingredient.itemDef) < ingredient.amount)
				{
					flag = false;
					break;
				}
			}
			if (!flag)
			{
				continue;
			}
			flag = false;
			for (int j = 9; j <= 12; j++)
			{
				Item slot = _inventory.GetSlot(j);
				if (slot == null || ((Object)(object)slot.info == (Object)(object)targetBlueprint.blueprintTargetDef && slot.amount + blueprint.amountToCreate <= slot.MaxStackable()))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				SetFlag(Flags.Reserved2, b: true);
				continue;
			}
			SetFlag(Flags.Reserved2, b: false);
			foreach (ItemAmount ingredient2 in blueprint.GetIngredients())
			{
				ConsumeInputIngredient(ingredient2);
			}
			currentlyCrafting = targetBlueprint.blueprintTargetDef;
			currentlyCraftingAmount = blueprint.amountToCreate;
			float craftTime = blueprint.GetCraftTime();
			((FacepunchBehaviour)this).Invoke((Action)CompleteCraft, craftTime);
			jobFinishes = TimeUntilWithDuration.op_Implicit(craftTime);
			SetFlag(Flags.Reserved1, b: true);
			ClientRPC(RpcTarget.NetworkGroup("ClientUpdateCraftTimeRemaining"), TimeUntilWithDuration.op_Implicit(jobFinishes), jobFinishes.Duration);
			break;
		}
	}

	private void CompleteCraft()
	{
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		for (int i = 9; i <= 12; i++)
		{
			Item slot = _inventory.GetSlot(i);
			if (slot == null)
			{
				Item item = ItemManager.Create(currentlyCrafting, currentlyCraftingAmount, 0uL);
				item.SetItemOwnership(ItemOwnership.username, ItemOwnershipPhrases.IndustrialCrafter);
				item.position = i;
				_inventory.Insert(item);
				flag = true;
				break;
			}
			if ((Object)(object)slot.info == (Object)(object)currentlyCrafting && slot.amount + currentlyCraftingAmount <= slot.MaxStackable())
			{
				slot.amount += currentlyCraftingAmount;
				slot.MarkDirty();
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			Item item2 = ItemManager.Create(currentlyCrafting, currentlyCraftingAmount, 0uL);
			item2.SetItemOwnership(ItemOwnership.username, ItemOwnershipPhrases.IndustrialCrafter);
			item2.Drop(((Component)this).transform.position + ((Component)this).transform.forward * 0.5f, Vector3.zero);
		}
		currentlyCrafting = null;
		currentlyCraftingAmount = 0;
		SetFlag(Flags.Reserved1, b: false);
	}

	private int GetInputAmount(ItemDefinition def)
	{
		if ((Object)(object)def == (Object)null)
		{
			return 0;
		}
		int num = 0;
		for (int i = 4; i <= 8; i++)
		{
			Item slot = _inventory.GetSlot(i);
			if (slot != null && (Object)(object)def == (Object)(object)slot.info)
			{
				num += slot.amount;
			}
		}
		return num;
	}

	private bool ConsumeInputIngredient(ItemAmount am)
	{
		if ((Object)(object)am.itemDef == (Object)null)
		{
			return false;
		}
		float num = am.amount;
		for (int i = 4; i <= 8; i++)
		{
			Item slot = _inventory.GetSlot(i);
			if (slot != null && (Object)(object)am.itemDef == (Object)(object)slot.info)
			{
				float num2 = Mathf.Min(num, (float)slot.amount);
				slot.UseItem((int)num2);
				num -= num2;
				if (num2 <= 0f)
				{
					return true;
				}
			}
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if ((Object)(object)currentlyCrafting != (Object)null)
			{
				info.msg.industrialCrafter = Pool.Get<IndustrialCrafter>();
				info.msg.industrialCrafter.currentlyCrafting = currentlyCrafting.itemid;
				info.msg.industrialCrafter.currentlyCraftingAmount = currentlyCraftingAmount;
			}
			if (_inventory != null)
			{
				info.msg.storageBox = Pool.Get<StorageBox>();
				info.msg.storageBox.contents = _inventory.Save();
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.storageBox != null && _inventory != null)
		{
			_inventory.Load(info.msg.storageBox.contents);
			_inventory.capacity = 13;
		}
		if (base.isServer && info.fromDisk && info.msg.industrialCrafter != null)
		{
			currentlyCrafting = ItemManager.FindItemDefinition(info.msg.industrialCrafter.currentlyCrafting);
			currentlyCraftingAmount = info.msg.industrialCrafter.currentlyCraftingAmount;
			CompleteCraft();
		}
	}

	public Vector2i InputSlotRange(int slotIndex)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		if (slotIndex == 3)
		{
			return new Vector2i(0, 3);
		}
		return new Vector2i(4, 8);
	}

	public Vector2i OutputSlotRange(int slotIndex)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		if (slotIndex == 1)
		{
			return new Vector2i(0, 3);
		}
		return new Vector2i(9, 12);
	}

	public void OnStorageItemTransferBegin()
	{
	}

	public void OnStorageItemTransferEnd()
	{
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (inputSlot == 1)
		{
			SetFlag(Flags.Reserved8, inputAmount >= ConsumptionAmount() && inputAmount > 0);
			currentEnergy = inputAmount;
			ensureOutputsUpdated = true;
			MarkDirty();
		}
		if (inputSlot == 1 && inputAmount <= 0 && IsOn())
		{
			SetSwitch(wantsOn: false);
		}
		if (inputSlot == 2)
		{
			if (IsOn() && inputAmount == 0)
			{
				SetSwitch(wantsOn: false);
			}
			else if (!IsOn() && inputAmount > 0 && HasFlag(Flags.Reserved8))
			{
				SetSwitch(wantsOn: true);
			}
		}
		if (inputSlot == 4 && inputAmount > 0 && HasFlag(Flags.Reserved8))
		{
			SetSwitch(wantsOn: true);
		}
		if (inputSlot == 5 && inputAmount > 0 && HasFlag(Flags.Reserved8))
		{
			SetSwitch(wantsOn: false);
		}
	}

	public override bool ShouldDrainBattery(IOEntity battery)
	{
		return IsOn();
	}

	public override bool WantsPassthroughPower()
	{
		return false;
	}

	public override bool WantsPower(int inputIndex)
	{
		return inputIndex == 1;
	}

	public virtual void SetSwitch(bool wantsOn)
	{
		if (wantsOn != IsOn())
		{
			SetFlag(Flags.On, wantsOn, recursive: false, networkupdate: false);
			SetFlag(Flags.Busy, b: true, recursive: false, networkupdate: false);
			if (!wantsOn)
			{
				SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
			}
			((FacepunchBehaviour)this).Invoke((Action)Unbusy, 0.5f);
			SendNetworkUpdateImmediate();
			MarkDirty();
		}
	}

	public void Unbusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server.IsVisible(3f)]
	private void SvSwitch(RPCMessage msg)
	{
		SetSwitch(!IsOn());
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (_inventory != null && !_inventory.IsEmpty())
		{
			pickupErrorToFormat = (format: PickupErrors.ItemInventoryMustBeEmpty, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public void GetAllInventories(List<ItemContainer> list)
	{
		list.Add(_inventory);
	}

	public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return -1;
	}

	public ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return default(ItemContainerId);
	}

	public Workbench GetWorkbench()
	{
		return GetParentEntity() as Workbench;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class IndustrialStorageAdaptor : IndustrialEntity, IIndustrialStorage
{
	public struct SortSettings
	{
		public enum SortMode
		{
			Name = 0,
			Count = 1,
			Condition = 2,
			Category = 3,
			Custom = 4,
			LAST = 4
		}

		public bool enabled;

		public SortMode mode;

		public bool reverse;

		public bool stack;

		public string translateLanguage;

		public List<string> customList;

		public void SaveTo(SortSettings settings)
		{
			settings.enabled = enabled;
			settings.sortMode = (int)mode;
			settings.reverse = reverse;
			settings.stack = stack;
			settings.translateLanguage = translateLanguage;
			if (customList == null)
			{
				return;
			}
			settings.customList = Pool.GetList<string>();
			foreach (string custom in customList)
			{
				settings.customList.Add(custom);
			}
		}

		public void LoadFrom(SortSettings settings)
		{
			enabled = settings.enabled;
			mode = (SortMode)settings.sortMode;
			reverse = settings.reverse;
			stack = settings.stack;
			translateLanguage = settings.translateLanguage;
			if (settings.customList != null)
			{
				if (customList == null)
				{
					customList = new List<string>();
				}
				else
				{
					customList.Clear();
				}
				{
					foreach (string custom in settings.customList)
					{
						customList.Add(custom);
					}
					return;
				}
			}
			customList = null;
		}
	}

	public class NameComparer : IComparer<Item>
	{
		public string language = string.Empty;

		public int Compare(Item x, Item y)
		{
			if (x == y)
			{
				return 0;
			}
			if (y == null)
			{
				return 1;
			}
			if (x == null)
			{
				return -1;
			}
			return string.Compare(GetStringForItem(x), GetStringForItem(y), StringComparison.InvariantCultureIgnoreCase);
			string GetStringForItem(Item i)
			{
				if (i.IsBlueprint())
				{
					return Translate.GetServerTranslation(i.blueprintTargetDef.displayName.token, language);
				}
				return Translate.GetServerTranslation(i.info.displayName.token, language);
			}
		}
	}

	public class SlotComparer : IComparer<Item>
	{
		public int Compare(Item x, Item y)
		{
			return CompareStatic(x, y);
		}

		public static int CompareStatic(Item x, Item y)
		{
			if (x == y)
			{
				return 0;
			}
			if (y == null)
			{
				return 1;
			}
			return x?.position.CompareTo(y.position) ?? (-1);
		}
	}

	public class CountComparer : IComparer<Item>
	{
		public int Compare(Item x, Item y)
		{
			if (x == y)
			{
				return 0;
			}
			if (y == null)
			{
				return 1;
			}
			if (x == null)
			{
				return -1;
			}
			if (x.amount > y.amount)
			{
				return 1;
			}
			if (x.amount < y.amount)
			{
				return -1;
			}
			return SlotComparer.CompareStatic(x, y);
		}
	}

	public class ConditionComparer : IComparer<Item>
	{
		public int Compare(Item x, Item y)
		{
			if (x == y)
			{
				return 0;
			}
			if (y == null)
			{
				return 1;
			}
			if (x == null)
			{
				return -1;
			}
			if (!x.hasCondition || !y.hasCondition)
			{
				if (x.hasCondition == y.hasCondition)
				{
					return SlotComparer.CompareStatic(x, y);
				}
				if (!x.hasCondition)
				{
					return 1;
				}
				return -1;
			}
			if (x.condition > y.condition)
			{
				return 1;
			}
			if (x.condition < y.condition)
			{
				return -1;
			}
			return SlotComparer.CompareStatic(x, y);
		}
	}

	public class CategoryComparer : IComparer<Item>
	{
		public int Compare(Item x, Item y)
		{
			if (x == y)
			{
				return 0;
			}
			if (y == null)
			{
				return 1;
			}
			if (x == null)
			{
				return -1;
			}
			ItemCategory category = x.info.category;
			ItemCategory category2 = y.info.category;
			if (category > category2)
			{
				return 1;
			}
			if (category < category2)
			{
				return -1;
			}
			return SlotComparer.CompareStatic(x, y);
		}
	}

	public class CustomListComparer : IComparer<Item>
	{
		public List<string> compareList;

		public int Compare(Item x, Item y)
		{
			if (x == y)
			{
				return 0;
			}
			if (y == null)
			{
				return 1;
			}
			if (x == null)
			{
				return -1;
			}
			int num = compareList.IndexOf(x.IsBlueprint() ? ("bp" + x.blueprintTargetDef.shortname) : x.info.shortname);
			int num2 = compareList.IndexOf(y.IsBlueprint() ? ("bp" + y.blueprintTargetDef.shortname) : y.info.shortname);
			if (num == -1 || num2 == -1)
			{
				if (num == num2)
				{
					return 0;
				}
				if (num <= num2)
				{
					return 1;
				}
				return -1;
			}
			if (num > num2)
			{
				return 1;
			}
			if (num < num2)
			{
				return -1;
			}
			return 0;
		}
	}

	public class SortingQueue : ObjectWorkQueue<IndustrialStorageAdaptor>
	{
		protected override void RunJob(IndustrialStorageAdaptor entity)
		{
			entity.ApplySorting();
		}
	}

	public SortSettings currentSortSettings;

	private static NameComparer nameComparer = new NameComparer();

	private static CountComparer countComparer = new CountComparer();

	private static ConditionComparer conditionComparer = new ConditionComparer();

	private static CategoryComparer categoryComparer = new CategoryComparer();

	private static CustomListComparer customListComparer = new CustomListComparer();

	private static SlotComparer slotComparer = new SlotComparer();

	public static SortingQueue SortQueue = new SortingQueue();

	private Action addToQueueAction;

	private bool ignoreRequest;

	public GameObject GreenLight;

	public GameObject RedLight;

	public BaseEntity _cachedParent;

	public ItemContainer cachedContainer;

	private int cachedPassthroughPower;

	public bool sortingEnabled => currentSortSettings.enabled;

	public BaseEntity cachedParent
	{
		get
		{
			if ((Object)(object)_cachedParent == (Object)null)
			{
				_cachedParent = GetParentEntity();
			}
			return _cachedParent;
		}
	}

	public ItemContainer Container
	{
		get
		{
			if (cachedContainer == null)
			{
				cachedContainer = (cachedParent as StorageContainer)?.inventory;
				if (cachedContainer == null)
				{
					cachedContainer = (cachedParent as ContainerIOEntity)?.inventory;
				}
			}
			return cachedContainer;
		}
	}

	public BaseEntity IndustrialEntity => this;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("IndustrialStorageAdaptor.OnRpcMessage", 0);
		try
		{
			if (rpc == 3920035167u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdatedStorageSettings "));
				}
				TimeWarning val2 = TimeWarning.New("UpdatedStorageSettings", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						UpdatedStorageSettings(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in UpdatedStorageSettings");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private void SaveSorting(SaveInfo info)
	{
		if (sortingEnabled)
		{
			info.msg.storageAdaptor = Pool.Get<StorageAdaptor>();
			SortSettings val = Pool.Get<SortSettings>();
			currentSortSettings.SaveTo(val);
			info.msg.storageAdaptor.sortingSettings = val;
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return GetCurrentEnergy();
	}

	public void RequestSort()
	{
		TimeWarning val = TimeWarning.New("RequestSort", 0);
		try
		{
			if (!ignoreRequest && IsPowered())
			{
				if (addToQueueAction == null)
				{
					addToQueueAction = AddToQueue;
				}
				if (((FacepunchBehaviour)this).IsInvoking(addToQueueAction))
				{
					((FacepunchBehaviour)this).CancelInvoke(addToQueueAction);
				}
				((FacepunchBehaviour)this).Invoke(addToQueueAction, 1f);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void AddToQueue()
	{
		((ObjectWorkQueue<IndustrialStorageAdaptor>)SortQueue).Add(this);
	}

	private bool ApplySorting()
	{
		ItemContainer container = Container;
		if (!sortingEnabled)
		{
			return false;
		}
		if (!Server.allowSorting)
		{
			return false;
		}
		if (!((Object)(object)cachedParent != (Object)null) || !(cachedParent is StorageContainer { allowSorting: not false }))
		{
			return false;
		}
		if (container == null || container.itemList == null || container.itemList.Count == 0)
		{
			return false;
		}
		List<Item> list = Pool.GetList<Item>();
		if (currentSortSettings.stack)
		{
			foreach (Item item2 in container.itemList)
			{
				if (item2.amount < item2.info.stackable)
				{
					list.Add(item2);
				}
			}
			for (int i = 0; i < container.itemList.Count; i++)
			{
				Item item = container.itemList[i];
				if (item.amount <= 0 || item.amount >= item.info.stackable)
				{
					continue;
				}
				int num = -1;
				for (int j = 0; j < list.Count; j++)
				{
					if (list[j].CanStack(item))
					{
						num = j;
						break;
					}
				}
				if (num != -1)
				{
					int num2 = Mathf.Clamp(item.amount, 0, list[num].info.stackable - list[num].amount);
					list[num].amount += num2;
					item.UseItem(num2);
				}
			}
			list.Clear();
		}
		foreach (Item item3 in container.itemList)
		{
			list.Add(item3);
		}
		switch (currentSortSettings.mode)
		{
		case SortSettings.SortMode.Name:
		{
			TimeWarning val = TimeWarning.New("NameComparer", 0);
			try
			{
				nameComparer.language = currentSortSettings.translateLanguage;
				list.Sort(nameComparer);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
			break;
		}
		case SortSettings.SortMode.Count:
		{
			TimeWarning val = TimeWarning.New("CountComparer", 0);
			try
			{
				list.Sort(countComparer);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
			break;
		}
		case SortSettings.SortMode.Condition:
		{
			TimeWarning val = TimeWarning.New("ConditionComparer", 0);
			try
			{
				list.Sort(conditionComparer);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
			break;
		}
		case SortSettings.SortMode.Category:
		{
			TimeWarning val = TimeWarning.New("CategoryComparer", 0);
			try
			{
				list.Sort(categoryComparer);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
			break;
		}
		case SortSettings.SortMode.Custom:
		{
			TimeWarning val = TimeWarning.New("CustomListComparer", 0);
			try
			{
				list.Sort(slotComparer);
				customListComparer.compareList = currentSortSettings.customList;
				list.Sort(customListComparer);
				customListComparer.compareList = null;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
			break;
		}
		}
		if (currentSortSettings.reverse)
		{
			TimeWarning val = TimeWarning.New("Reverse", 0);
			try
			{
				list.Reverse();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		bool result = false;
		for (int k = 0; k < list.Count; k++)
		{
			if (list[k].position != k)
			{
				list[k].position = k;
				result = true;
			}
		}
		Pool.FreeList<Item>(ref list);
		try
		{
			ignoreRequest = true;
			container.MarkDirty();
			return result;
		}
		finally
		{
			ignoreRequest = false;
		}
	}

	[RPC_Server]
	public void UpdatedStorageSettings(RPCMessage msg)
	{
		SortSettings val = msg.read.Proto<SortSettings>((SortSettings)null);
		try
		{
			if (val == null)
			{
				currentSortSettings = default(SortSettings);
			}
			else
			{
				currentSortSettings.LoadFrom(val);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		Container.MarkDirty();
		SendNetworkUpdate();
	}

	private void LoadSorting(LoadInfo info)
	{
		if (info.msg.storageAdaptor != null && info.msg.storageAdaptor.sortingSettings != null)
		{
			if (currentSortSettings.enabled)
			{
				currentSortSettings = default(SortSettings);
			}
			currentSortSettings.LoadFrom(info.msg.storageAdaptor.sortingSettings);
		}
		else
		{
			currentSortSettings = default(SortSettings);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		_cachedParent = null;
		cachedContainer = null;
	}

	public Vector2i InputSlotRange(int slotIndex)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedParent != (Object)null)
		{
			if (cachedParent is IIndustrialStorage industrialStorage)
			{
				return industrialStorage.InputSlotRange(slotIndex);
			}
			if (cachedParent is Locker locker)
			{
				Vector3 localPosition = ((Component)this).transform.localPosition;
				return locker.GetIndustrialSlotRange(localPosition);
			}
		}
		if (Container != null)
		{
			return new Vector2i(0, Container.capacity - 1);
		}
		return new Vector2i(0, 0);
	}

	public Vector2i OutputSlotRange(int slotIndex)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedParent != (Object)null)
		{
			if (cachedParent is DropBox && Container != null)
			{
				return new Vector2i(0, Container.capacity - 1);
			}
			if (cachedParent is IIndustrialStorage industrialStorage)
			{
				return industrialStorage.OutputSlotRange(slotIndex);
			}
			if (cachedParent is Locker locker)
			{
				Vector3 localPosition = ((Component)this).transform.localPosition;
				return locker.GetIndustrialSlotRange(localPosition);
			}
		}
		if (Container != null)
		{
			return new Vector2i(0, Container.capacity - 1);
		}
		return new Vector2i(0, 0);
	}

	public void OnStorageItemTransferBegin()
	{
		if ((Object)(object)cachedParent != (Object)null && cachedParent is IIndustrialStorageCallbackReceiver industrialStorageCallbackReceiver)
		{
			TimeWarning val = TimeWarning.New("IIndustrialStorageCallbackReceiver::OnIndustrialItemTransferBegins", 0);
			try
			{
				industrialStorageCallbackReceiver.OnIndustrialItemTransferBegins();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public void OnStorageItemTransferEnd()
	{
		if ((Object)(object)cachedParent != (Object)null && cachedParent is IIndustrialStorageCallbackReceiver industrialStorageCallbackReceiver)
		{
			industrialStorageCallbackReceiver.OnIndustrialItemTransferEnd();
		}
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		if ((Object)(object)newParent != (Object)null)
		{
			cachedContainer = null;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		SaveSorting(info);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (inputSlot == 1)
		{
			cachedPassthroughPower = inputAmount;
			UpdateHasPower(inputAmount, inputSlot);
			MarkDirtyForceUpdateOutputs();
		}
	}

	public override int GetCurrentEnergy()
	{
		return Mathf.Clamp(cachedPassthroughPower - ConsumptionAmount(), 0, cachedPassthroughPower);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		LoadSorting(info);
	}

	public override int ConsumptionAmount()
	{
		return 1;
	}

	public void ClientNotifyItemAddRemoved(bool add)
	{
		if (add)
		{
			GreenLight.SetActive(false);
			GreenLight.SetActive(true);
		}
		else
		{
			RedLight.SetActive(false);
			RedLight.SetActive(true);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public struct SortSettings
{
	public enum SortMode
	{
		Name = 0,
		Count = 1,
		Condition = 2,
		Category = 3,
		Custom = 4,
		LAST = 4
	}

	public bool enabled;

	public SortMode mode;

	public bool reverse;

	public bool stack;

	public string translateLanguage;

	public List<string> customList;

	public void SaveTo(SortSettings settings)
	{
		settings.enabled = enabled;
		settings.sortMode = (int)mode;
		settings.reverse = reverse;
		settings.stack = stack;
		settings.translateLanguage = translateLanguage;
		if (customList == null)
		{
			return;
		}
		settings.customList = Pool.GetList<string>();
		foreach (string custom in customList)
		{
			settings.customList.Add(custom);
		}
	}

	public void LoadFrom(SortSettings settings)
	{
		enabled = settings.enabled;
		mode = (SortMode)settings.sortMode;
		reverse = settings.reverse;
		stack = settings.stack;
		translateLanguage = settings.translateLanguage;
		if (settings.customList != null)
		{
			if (customList == null)
			{
				customList = new List<string>();
			}
			else
			{
				customList.Clear();
			}
			{
				foreach (string custom in settings.customList)
				{
					customList.Add(custom);
				}
				return;
			}
		}
		customList = null;
	}
}


public enum SortMode
{
	Name = 0,
	Count = 1,
	Condition = 2,
	Category = 3,
	Custom = 4,
	LAST = 4
}


using System;
using System.Collections.Generic;

public class NameComparer : IComparer<Item>
{
	public string language = string.Empty;

	public int Compare(Item x, Item y)
	{
		if (x == y)
		{
			return 0;
		}
		if (y == null)
		{
			return 1;
		}
		if (x == null)
		{
			return -1;
		}
		return string.Compare(GetStringForItem(x), GetStringForItem(y), StringComparison.InvariantCultureIgnoreCase);
		string GetStringForItem(Item i)
		{
			if (i.IsBlueprint())
			{
				return Translate.GetServerTranslation(i.blueprintTargetDef.displayName.token, language);
			}
			return Translate.GetServerTranslation(i.info.displayName.token, language);
		}
	}
}


using System.Collections.Generic;

public class SlotComparer : IComparer<Item>
{
	public int Compare(Item x, Item y)
	{
		return CompareStatic(x, y);
	}

	public static int CompareStatic(Item x, Item y)
	{
		if (x == y)
		{
			return 0;
		}
		if (y == null)
		{
			return 1;
		}
		return x?.position.CompareTo(y.position) ?? (-1);
	}
}


using System.Collections.Generic;

public class CountComparer : IComparer<Item>
{
	public int Compare(Item x, Item y)
	{
		if (x == y)
		{
			return 0;
		}
		if (y == null)
		{
			return 1;
		}
		if (x == null)
		{
			return -1;
		}
		if (x.amount > y.amount)
		{
			return 1;
		}
		if (x.amount < y.amount)
		{
			return -1;
		}
		return SlotComparer.CompareStatic(x, y);
	}
}


using System.Collections.Generic;

public class ConditionComparer : IComparer<Item>
{
	public int Compare(Item x, Item y)
	{
		if (x == y)
		{
			return 0;
		}
		if (y == null)
		{
			return 1;
		}
		if (x == null)
		{
			return -1;
		}
		if (!x.hasCondition || !y.hasCondition)
		{
			if (x.hasCondition == y.hasCondition)
			{
				return SlotComparer.CompareStatic(x, y);
			}
			if (!x.hasCondition)
			{
				return 1;
			}
			return -1;
		}
		if (x.condition > y.condition)
		{
			return 1;
		}
		if (x.condition < y.condition)
		{
			return -1;
		}
		return SlotComparer.CompareStatic(x, y);
	}
}


using System.Collections.Generic;

public class CategoryComparer : IComparer<Item>
{
	public int Compare(Item x, Item y)
	{
		if (x == y)
		{
			return 0;
		}
		if (y == null)
		{
			return 1;
		}
		if (x == null)
		{
			return -1;
		}
		ItemCategory category = x.info.category;
		ItemCategory category2 = y.info.category;
		if (category > category2)
		{
			return 1;
		}
		if (category < category2)
		{
			return -1;
		}
		return SlotComparer.CompareStatic(x, y);
	}
}


using System.Collections.Generic;

public class CustomListComparer : IComparer<Item>
{
	public List<string> compareList;

	public int Compare(Item x, Item y)
	{
		if (x == y)
		{
			return 0;
		}
		if (y == null)
		{
			return 1;
		}
		if (x == null)
		{
			return -1;
		}
		int num = compareList.IndexOf(x.IsBlueprint() ? ("bp" + x.blueprintTargetDef.shortname) : x.info.shortname);
		int num2 = compareList.IndexOf(y.IsBlueprint() ? ("bp" + y.blueprintTargetDef.shortname) : y.info.shortname);
		if (num == -1 || num2 == -1)
		{
			if (num == num2)
			{
				return 0;
			}
			if (num <= num2)
			{
				return 1;
			}
			return -1;
		}
		if (num > num2)
		{
			return 1;
		}
		if (num < num2)
		{
			return -1;
		}
		return 0;
	}
}


public class SortingQueue : ObjectWorkQueue<IndustrialStorageAdaptor>
{
	protected override void RunJob(IndustrialStorageAdaptor entity)
	{
		entity.ApplySorting();
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class InstantCameraTool : HeldEntity
{
	public ItemDefinition photoItem;

	public GameObjectRef screenshotEffect;

	public SoundDefinition startPhotoSoundDef;

	public SoundDefinition finishPhotoSoundDef;

	[Range(640f, 1920f)]
	public int resolutionX = 640;

	[Range(480f, 1080f)]
	public int resolutionY = 480;

	[Range(10f, 100f)]
	public int quality = 75;

	[Range(0f, 5f)]
	public float cooldownSeconds = 3f;

	[Header("Flash")]
	public GameObjectRef flashEffect;

	public InstantCameraFlashController localFlash;

	public float flashDuration = 0.2f;

	public TimeSince _sinceLastPhoto;

	private bool hasSentAchievement;

	public const string PhotographPlayerAchievement = "SUMMER_PAPARAZZI";

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("InstantCameraTool.OnRpcMessage", 0);
		try
		{
			if (rpc == 3122234259u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - TakePhoto "));
				}
				TimeWarning val2 = TimeWarning.New("TakePhoto", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3122234259u, "TakePhoto", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(3122234259u, "TakePhoto", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							TakePhoto(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in TakePhoto");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	private void TakePhoto(RPCMessage msg)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		Item item = GetItem();
		if ((Object)(object)player == (Object)null || item == null || item.condition <= 0f)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (array.Length > 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))
		{
			return;
		}
		Item item2 = ItemManager.Create(photoItem, 1, 0uL);
		if (item2 == null)
		{
			Debug.LogError((object)"Failed to create photo item");
			return;
		}
		item2.SetItemOwnership(msg.player, ItemOwnershipPhrases.Photographed);
		if (!((NetworkableId)(ref item2.instanceData.subEntity)).IsValid)
		{
			item2.Remove();
			Debug.LogError((object)"Photo has no sub-entity");
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);
		if ((Object)(object)baseNetworkable == (Object)null)
		{
			item2.Remove();
			Debug.LogError((object)"Sub-entity was not found");
		}
		else if (!(baseNetworkable is PhotoEntity photoEntity))
		{
			item2.Remove();
			Debug.LogError((object)"Sub-entity is not a photo");
		}
		else
		{
			if (Interface.CallHook("OnPhotoCapture", (object)photoEntity, (object)item, (object)player, (object)array) != null)
			{
				return;
			}
			photoEntity.SetImageData(player.userID, array);
			if (!player.inventory.GiveItem(item2))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			EffectNetwork.Send(new Effect(screenshotEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.forward, msg.connection));
			if (HasFlag(Flags.Reserved5))
			{
				EffectNetwork.Send(new Effect(flashEffect.resourcePath, ((Component)localFlash).transform.position, ((Component)localFlash).transform.forward, msg.connection));
			}
			if (!hasSentAchievement && !string.IsNullOrEmpty("SUMMER_PAPARAZZI"))
			{
				Vector3 position = GetOwnerPlayer().eyes.position;
				Vector3 val = GetOwnerPlayer().eyes.HeadForward();
				List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
				Vis.Entities(position + val * 5f, 5f, list, 131072, (QueryTriggerInteraction)2);
				foreach (BasePlayer item3 in list)
				{
					if (item3.isServer && (Object)(object)item3 != (Object)(object)GetOwnerPlayer() && item3.IsVisible(GetOwnerPlayer().eyes.position))
					{
						hasSentAchievement = true;
						GetOwnerPlayer().GiveAchievement("SUMMER_PAPARAZZI");
						break;
					}
				}
				Pool.FreeUnmanaged<BasePlayer>(ref list);
			}
			item.LoseCondition(1f);
			Interface.CallHook("OnPhotoCaptured", (object)photoEntity, (object)item, (object)player, (object)array);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		hasSentAchievement = false;
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class InstrumentTool : HeldEntity
{
	public InstrumentKeyController KeyController;

	public SoundDefinition DeploySound;

	public Vector2 PitchClamp = new Vector2(-90f, 90f);

	public bool UseAnimationSlotEvents;

	public Transform MuzzleT;

	public bool UsableByAutoTurrets;

	private NoteBindingCollection.NoteData lastPlayedTurretData;

	public override Transform MuzzleTransform => MuzzleT;

	public override bool IsUsableByTurret => UsableByAutoTurrets;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("InstrumentTool.OnRpcMessage", 0);
		try
		{
			if (rpc == 1625188589 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_PlayNote "));
				}
				TimeWarning val2 = TimeWarning.New("Server_PlayNote", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_PlayNote(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_PlayNote");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 705843933 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_StopNote "));
				}
				TimeWarning val2 = TimeWarning.New("Server_StopNote", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						Server_StopNote(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in Server_StopNote");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	private void Server_PlayNote(RPCMessage msg)
	{
		int arg = msg.read.Int32();
		int arg2 = msg.read.Int32();
		int arg3 = msg.read.Int32();
		float num = msg.read.Float();
		if (!FloatEx.IsNaNOrInfinity(num))
		{
			KeyController.ProcessServerPlayedNote(GetOwnerPlayer());
			ClientRPC(RpcTarget.NetworkGroup("Client_PlayNote"), arg, arg2, arg3, num);
		}
	}

	[RPC_Server]
	private void Server_StopNote(RPCMessage msg)
	{
		int arg = msg.read.Int32();
		int arg2 = msg.read.Int32();
		int arg3 = msg.read.Int32();
		ClientRPC(RpcTarget.NetworkGroup("Client_StopNote"), arg, arg2, arg3);
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		base.ServerUse(damageModifier, speedModifier, originOverride, useBulletThickness);
		if (!((FacepunchBehaviour)this).IsInvoking((Action)StopAfterTime))
		{
			lastPlayedTurretData = KeyController.Bindings.BaseBindings[Random.Range(0, KeyController.Bindings.BaseBindings.Length)];
			ClientRPC(RpcTarget.NetworkGroup("Client_PlayNote"), (int)lastPlayedTurretData.Note, (int)lastPlayedTurretData.Type, lastPlayedTurretData.NoteOctave, 1f);
			((FacepunchBehaviour)this).Invoke((Action)StopAfterTime, 0.2f);
		}
	}

	private void StopAfterTime()
	{
		ClientRPC(RpcTarget.NetworkGroup("Client_StopNote"), (int)lastPlayedTurretData.Note, (int)lastPlayedTurretData.Type, lastPlayedTurretData.NoteOctave);
	}

	public override bool IsInstrument()
	{
		return true;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class IOEntity : DecayEntity
{
	public enum IOType
	{
		Electric,
		Fluidic,
		Kinetic,
		Generic,
		Industrial
	}

	public enum QueueType
	{
		ElectricLowPriority,
		ElectricHighPriority,
		Fluidic,
		Kinetic,
		Generic,
		Industrial
	}

	[Serializable]
	public class IORef
	{
		public EntityRef entityRef;

		public IOEntity ioEnt;

		public void Init()
		{
			if ((Object)(object)ioEnt != (Object)null && !entityRef.IsValid(serverside: true))
			{
				entityRef.Set(ioEnt);
			}
			if (entityRef.IsValid(serverside: true))
			{
				ioEnt = ((Component)entityRef.Get(serverside: true)).GetComponent<IOEntity>();
			}
		}

		public void InitClient()
		{
			if (entityRef.IsValid(serverside: false) && (Object)(object)ioEnt == (Object)null)
			{
				ioEnt = ((Component)entityRef.Get(serverside: false)).GetComponent<IOEntity>();
			}
		}

		public IOEntity Get(bool isServer = true)
		{
			if ((Object)(object)ioEnt == (Object)null && entityRef.IsValid(isServer))
			{
				ioEnt = entityRef.Get(isServer) as IOEntity;
			}
			return ioEnt;
		}

		public void Clear()
		{
			IOEntity iOEntity = ioEnt;
			ioEnt = null;
			entityRef.Set(null);
			Interface.CallHook("OnIORefCleared", (object)this, (object)iOEntity);
		}

		public void Set(IOEntity newIOEnt)
		{
			entityRef.Set(newIOEnt);
		}
	}

	[Serializable]
	public class IOSlot
	{
		public string niceName;

		public IOType type;

		public IORef connectedTo;

		public int connectedToSlot;

		public IOHandlePriority importance;

		public float ArrowOffset;

		public Vector3[] linePoints;

		public LineAnchor[] lineAnchors;

		public float[] slackLevels;

		public Vector3 worldSpaceLineEndRotation;

		[HideInInspector]
		public Vector3 originPosition;

		[HideInInspector]
		public Vector3 originRotation;

		public ClientIOLine line;

		public Vector3 handlePosition;

		public Vector3 handleDirection;

		public bool rootConnectionsOnly;

		public bool mainPowerSlot;

		public WireTool.WireColour wireColour;

		public float lineThickness;

		public void Clear()
		{
			if (connectedTo == null)
			{
				connectedTo = new IORef();
			}
			else
			{
				connectedTo.Clear();
			}
			connectedToSlot = 0;
			linePoints = null;
			lineAnchors = null;
		}

		public void Preserve(ref SprayCan.IOPreserveInfo target)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			target.connectedTo = connectedTo.Get();
			target.connectedToSlot = connectedToSlot;
			target.linePoints = linePoints;
			target.slackLevels = slackLevels;
			target.lineAnchors = lineAnchors;
			target.worldSpaceLineEndRotation = worldSpaceLineEndRotation;
			target.originPosition = originPosition;
			target.originRotation = originRotation;
			target.wireColour = wireColour;
		}

		public void Restore(SprayCan.IOPreserveInfo from)
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			connectedTo.Set(from.connectedTo);
			connectedToSlot = from.connectedToSlot;
			linePoints = from.linePoints;
			slackLevels = from.slackLevels;
			lineAnchors = from.lineAnchors;
			worldSpaceLineEndRotation = from.worldSpaceLineEndRotation;
			originPosition = from.originPosition;
			originRotation = from.originRotation;
			wireColour = from.wireColour;
		}

		public bool IsConnected()
		{
			return (Object)(object)connectedTo.Get() != (Object)null;
		}
	}

	private struct FrameTiming
	{
		public string PrefabName;

		public double Time;
	}

	public struct LineAnchor
	{
		public EntityRef<Door> entityRef;

		public string boneName;

		public int index;

		public Vector3 position;

		public LineAnchor(WireLineAnchorInfo info)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			entityRef = new EntityRef<Door>(info.parentID);
			boneName = info.boneName;
			index = (int)info.index;
			position = info.position;
		}

		public WireLineAnchorInfo ToInfo()
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Expected O, but got Unknown
			return new WireLineAnchorInfo
			{
				parentID = entityRef.Get(serverside: true).net.ID,
				boneName = boneName,
				index = index,
				position = position
			};
		}
	}

	public struct ContainerInputOutput : IEquatable<ContainerInputOutput>
	{
		public IIndustrialStorage Storage;

		public int SlotIndex;

		public int MaxStackSize;

		public int ParentStorage;

		public int IndustrialSiblingCount;

		public bool Equals(ContainerInputOutput other)
		{
			if (object.Equals(Storage, other.Storage) && SlotIndex == other.SlotIndex && MaxStackSize == other.MaxStackSize && ParentStorage == other.ParentStorage)
			{
				return IndustrialSiblingCount == other.IndustrialSiblingCount;
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj is ContainerInputOutput other)
			{
				return Equals(other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(Storage, SlotIndex, MaxStackSize, ParentStorage, IndustrialSiblingCount);
		}
	}

	[Header("IOEntity")]
	public Transform debugOrigin;

	[ItemSelector]
	public ItemDefinition sourceItem;

	[NonSerialized]
	public int lastResetIndex;

	[Help("How many milliseconds to budget for processing high priority electric io entities per server frame (monuments)")]
	[ServerVar]
	public static float frameBudgetElectricHighPriorityMs = 1f;

	[Help("How many milliseconds to budget for processing low priority io entities per server frame (player placed)")]
	[ServerVar]
	public static float frameBudgetElectricLowPriorityMs = 0.5f;

	[ServerVar]
	[Help("How many milliseconds to budget for processing fluid io entities per server frame")]
	public static float frameBudgetFluidMs = 0.25f;

	[Help("How many milliseconds to budget for processing kinetic io entities per server frame (monuments)")]
	[ServerVar]
	public static float frameBudgetKineticMs = 1f;

	[ServerVar]
	[Help("How many milliseconds to budget for processing generic io entities per server frame (unused for now)")]
	public static float frameBudgetGenericMs = 1f;

	[ServerVar]
	[Help("How many milliseconds to budget for processing industrial entities per server frame")]
	public static float frameBudgetIndustrialMs = 0.25f;

	[ServerVar]
	public static float responsetime = 0.1f;

	[ServerVar]
	public static int backtracking = 8;

	[ServerVar(Help = "Print out what is taking so long in the IO frame budget")]
	public static bool debugBudget = false;

	[ServerVar(Help = "Ignore frames with a lower ms than this while debugBudget is active")]
	public static float debugBudgetThreshold = 2f;

	private static bool _infinitePower = false;

	public const Flags Flag_ShortCircuit = Flags.Reserved7;

	public const Flags Flag_HasPower = Flags.Reserved8;

	public IOSlot[] inputs;

	public IOSlot[] outputs;

	public IOType ioType;

	public static Dictionary<QueueType, Queue<IOEntity>> _processQueues = new Dictionary<QueueType, Queue<IOEntity>>
	{
		{
			QueueType.ElectricHighPriority,
			new Queue<IOEntity>()
		},
		{
			QueueType.ElectricLowPriority,
			new Queue<IOEntity>()
		},
		{
			QueueType.Fluidic,
			new Queue<IOEntity>()
		},
		{
			QueueType.Kinetic,
			new Queue<IOEntity>()
		},
		{
			QueueType.Generic,
			new Queue<IOEntity>()
		},
		{
			QueueType.Industrial,
			new Queue<IOEntity>()
		}
	};

	public static Dictionary<QueueType, string> _processQueueProfilerString = new Dictionary<QueueType, string>
	{
		{
			QueueType.ElectricHighPriority,
			"HighPriorityElectric"
		},
		{
			QueueType.ElectricLowPriority,
			"LowPriorityElectric"
		},
		{
			QueueType.Fluidic,
			"Fluid"
		},
		{
			QueueType.Kinetic,
			"Kinetic"
		},
		{
			QueueType.Generic,
			"Generic"
		},
		{
			QueueType.Industrial,
			"Industrial"
		}
	};

	private static List<FrameTiming> timings = new List<FrameTiming>();

	public int cachedOutputsUsed;

	public int lastPassthroughEnergy = -1;

	public int lastEnergy;

	public int currentEnergy;

	private int changedCount;

	private float lastChangeTime;

	public float lastUpdateTime;

	public int lastUpdateBlockedFrame;

	public bool ensureOutputsUpdated;

	public const int MaxContainerSourceCount = 32;

	private List<Collider> spawnedColliders = new List<Collider>();

	public virtual bool IsGravitySource => false;

	[ReplicatedVar(Help = "All player placed electrical entities will receive full power without needing to be plugged into anything")]
	public static bool infiniteIoPower
	{
		get
		{
			return _infinitePower;
		}
		set
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if (_infinitePower == value)
			{
				return;
			}
			_infinitePower = value;
			Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					if (!(enumerator.Current is IOEntity iOEntity) || (iOEntity.GetQueueType() != 0 && iOEntity.GetQueueType() != QueueType.Industrial))
					{
						continue;
					}
					if (infiniteIoPower)
					{
						iOEntity.ApplyInfinitePower();
						continue;
					}
					iOEntity.MarkDirtyForceUpdateOutputs();
					bool flag = false;
					IOSlot[] array = iOEntity.inputs;
					for (int i = 0; i < array.Length; i++)
					{
						if ((Object)(object)array[i].connectedTo.Get() != (Object)null)
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						for (int j = 0; j < iOEntity.inputs.Length; j++)
						{
							iOEntity.UpdateFromInput(0, j);
						}
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
	}

	protected virtual bool PreventDuplicatesInQueue => false;

	private bool HasBlockedUpdatedOutputsThisFrame => Time.frameCount == lastUpdateBlockedFrame;

	public virtual bool BlockFluidDraining => false;

	protected virtual float LiquidPassthroughGravityThreshold => 1f;

	protected virtual bool DisregardGravityRestrictionsOnLiquid => false;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("IOEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 4161541566u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestData "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestData", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4161541566u, "Server_RequestData", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4161541566u, "Server_RequestData", this, player, 6f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_RequestData(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_RequestData");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		if (base.isServer)
		{
			lastResetIndex = 0;
			cachedOutputsUsed = 0;
			lastPassthroughEnergy = 0;
			lastEnergy = 0;
			currentEnergy = 0;
			lastUpdateTime = 0f;
			ensureOutputsUpdated = false;
		}
		ClearIndustrialPreventBuilding();
	}

	public Phrase GetDisplayName()
	{
		if (!((Object)(object)sourceItem != (Object)null))
		{
			return Phrase.op_Implicit(base.ShortPrefabName);
		}
		return sourceItem.displayName;
	}

	public virtual bool ShowDisplayName()
	{
		return true;
	}

	public virtual bool IsRootEntity()
	{
		return false;
	}

	public IOEntity FindGravitySource(ref Vector3 worldHandlePosition, int depth, bool ignoreSelf)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		if (depth <= 0)
		{
			return null;
		}
		if (!ignoreSelf && IsGravitySource)
		{
			worldHandlePosition = ((Component)this).transform.TransformPoint(outputs[0].handlePosition);
			return this;
		}
		IOSlot[] array = inputs;
		for (int i = 0; i < array.Length; i++)
		{
			IOEntity iOEntity = array[i].connectedTo.Get(base.isServer);
			if ((Object)(object)iOEntity != (Object)null)
			{
				if (iOEntity.IsGravitySource)
				{
					worldHandlePosition = ((Component)iOEntity).transform.TransformPoint(iOEntity.outputs[0].handlePosition);
					return iOEntity;
				}
				iOEntity = iOEntity.FindGravitySource(ref worldHandlePosition, depth - 1, ignoreSelf: false);
				if ((Object)(object)iOEntity != (Object)null)
				{
					worldHandlePosition = ((Component)iOEntity).transform.TransformPoint(iOEntity.outputs[0].handlePosition);
					return iOEntity;
				}
			}
		}
		return null;
	}

	public virtual void SetFuelType(ItemDefinition def, IOEntity source)
	{
	}

	public virtual bool WantsPower(int inputIndex)
	{
		return true;
	}

	public virtual bool AllowWireConnections()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)((Component)this).GetComponentInParent<BaseVehicle>() != (Object)null)
		{
			return false;
		}
		if ((Object)(object)BoatBuildingStation.GetStationOverlappingPosition(((Component)this).transform.position, base.isServer) != (Object)null)
		{
			return false;
		}
		return true;
	}

	public virtual bool WantsPassthroughPower()
	{
		return true;
	}

	public virtual int ConsumptionAmount()
	{
		return 1;
	}

	public virtual bool ShouldDrainBattery(IOEntity battery)
	{
		return ioType == battery.ioType;
	}

	public virtual bool ShouldBlockCircuit(IOEntity battery)
	{
		return false;
	}

	public virtual int MaximalPowerOutput()
	{
		return 0;
	}

	public virtual bool AllowDrainFrom(int outputSlot)
	{
		return true;
	}

	public QueueType GetQueueType()
	{
		switch (ioType)
		{
		case IOType.Electric:
			if ((Object)(object)sourceItem == (Object)null)
			{
				return QueueType.ElectricHighPriority;
			}
			return QueueType.ElectricLowPriority;
		case IOType.Fluidic:
			return QueueType.Fluidic;
		case IOType.Kinetic:
			return QueueType.Kinetic;
		case IOType.Generic:
			return QueueType.Generic;
		case IOType.Industrial:
			return QueueType.Industrial;
		default:
			return QueueType.ElectricLowPriority;
		}
	}

	public static float GetFrameBudgetForQueue(QueueType type)
	{
		return type switch
		{
			QueueType.ElectricLowPriority => frameBudgetElectricLowPriorityMs, 
			QueueType.ElectricHighPriority => frameBudgetElectricHighPriorityMs, 
			QueueType.Fluidic => frameBudgetFluidMs, 
			QueueType.Kinetic => frameBudgetKineticMs, 
			QueueType.Generic => frameBudgetGenericMs, 
			QueueType.Industrial => frameBudgetIndustrialMs, 
			_ => frameBudgetElectricLowPriorityMs, 
		};
	}

	public virtual bool IsPowered()
	{
		return HasFlag(Flags.Reserved8);
	}

	public bool IsConnectedToAnySlot(IOEntity entity, int slot, int depth, bool defaultReturn = false)
	{
		if (depth > 0 && slot < inputs.Length)
		{
			IOEntity iOEntity = inputs[slot].connectedTo.Get();
			if ((Object)(object)iOEntity != (Object)null)
			{
				if ((Object)(object)iOEntity == (Object)(object)entity)
				{
					return true;
				}
				if (ConsiderConnectedTo(entity))
				{
					return true;
				}
				if (iOEntity.IsConnectedTo(entity, depth - 1, defaultReturn))
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool IsConnectedTo(IOEntity entity, int slot, int depth, bool defaultReturn = false)
	{
		if (depth > 0 && slot < inputs.Length)
		{
			IOSlot iOSlot = inputs[slot];
			if (iOSlot.mainPowerSlot)
			{
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if ((Object)(object)iOEntity != (Object)null)
				{
					if ((Object)(object)iOEntity == (Object)(object)entity)
					{
						return true;
					}
					if (ConsiderConnectedTo(entity))
					{
						return true;
					}
					if (iOEntity.IsConnectedTo(entity, depth - 1, defaultReturn))
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	public bool IsConnectedTo(IOEntity entity, int depth, bool defaultReturn = false)
	{
		if (depth > 0)
		{
			for (int i = 0; i < inputs.Length; i++)
			{
				IOSlot iOSlot = inputs[i];
				if (!iOSlot.mainPowerSlot)
				{
					continue;
				}
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if ((Object)(object)iOEntity != (Object)null)
				{
					if ((Object)(object)iOEntity == (Object)(object)entity)
					{
						return true;
					}
					if (ConsiderConnectedTo(entity))
					{
						return true;
					}
					if (iOEntity.IsConnectedTo(entity, depth - 1, defaultReturn))
					{
						return true;
					}
				}
			}
			return false;
		}
		return defaultReturn;
	}

	protected virtual bool ConsiderConnectedTo(IOEntity entity)
	{
		return false;
	}

	[RPC_Server.IsVisible(6f)]
	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server]
	private void Server_RequestData(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int slot = msg.read.Int32();
		bool input = msg.read.Int32() == 1;
		SendAdditionalData(player, slot, input);
	}

	public virtual void SendAdditionalData(BasePlayer player, int slot, bool input)
	{
		int passthroughAmountForAnySlot = GetPassthroughAmountForAnySlot(slot, input);
		ClientRPC(RpcTarget.Player("Client_ReceiveAdditionalData", player), currentEnergy, passthroughAmountForAnySlot, 0f, 0f);
	}

	protected int GetPassthroughAmountForAnySlot(int slot, bool isInputSlot)
	{
		int result = 0;
		if (isInputSlot)
		{
			if (slot >= 0 && slot < inputs.Length)
			{
				IOSlot iOSlot = inputs[slot];
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if ((Object)(object)iOEntity != (Object)null && iOSlot.connectedToSlot >= 0 && iOSlot.connectedToSlot < iOEntity.outputs.Length)
				{
					result = iOEntity.GetPassthroughAmount(inputs[slot].connectedToSlot);
				}
			}
		}
		else if (slot >= 0 && slot < outputs.Length)
		{
			result = GetPassthroughAmount(slot);
		}
		return result;
	}

	public static void ProcessQueue()
	{
		if (debugBudget)
		{
			timings.Clear();
		}
		double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
		foreach (KeyValuePair<QueueType, Queue<IOEntity>> processQueue in _processQueues)
		{
			double num = Time.realtimeSinceStartup;
			double num2 = GetFrameBudgetForQueue(processQueue.Key) / 1000f;
			while (processQueue.Value.Count > 0 && Time.realtimeSinceStartupAsDouble < num + num2 && !processQueue.Value.Peek().HasBlockedUpdatedOutputsThisFrame)
			{
				double realtimeSinceStartupAsDouble2 = Time.realtimeSinceStartupAsDouble;
				IOEntity iOEntity = processQueue.Value.Dequeue();
				if (iOEntity.IsValid())
				{
					iOEntity.UpdateOutputs();
				}
				if (debugBudget)
				{
					timings.Add(new FrameTiming
					{
						PrefabName = iOEntity.ShortPrefabName,
						Time = (Time.realtimeSinceStartupAsDouble - realtimeSinceStartupAsDouble2) * 1000.0
					});
				}
			}
		}
		if (!debugBudget)
		{
			return;
		}
		double num3 = Time.realtimeSinceStartupAsDouble - realtimeSinceStartupAsDouble;
		double num4 = (double)debugBudgetThreshold / 1000.0;
		if (!(num3 > num4))
		{
			return;
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[2] { "Prefab Name", "Time (in ms)" });
			foreach (FrameTiming timing in timings)
			{
				string[] obj = new string[2] { timing.PrefabName, null };
				double time = timing.Time;
				obj[1] = time.ToString();
				val.AddRow(obj);
			}
			val.AddRow(new string[2]
			{
				"Total time",
				(num3 * 1000.0).ToString()
			});
			Debug.Log((object)((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(ServerAdmin = true)]
	public static void DebugQueue(Arg arg)
	{
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		foreach (KeyValuePair<QueueType, Queue<IOEntity>> processQueue in _processQueues)
		{
			QueueType key = processQueue.Key;
			Queue<IOEntity> value = processQueue.Value;
			stringBuilder.AppendLine($"{key} queue size: {value.Count}");
			if (value.Count == 0)
			{
				continue;
			}
			var list = (from e in value
				group e by e.PrefabName into g
				select new
				{
					PrefabName = g.Key,
					Count = g.Count(),
					Entities = g.ToList()
				} into g
				orderby g.Count descending
				select g).Take(10).ToList();
			stringBuilder.AppendLine("-----Top queue occupants-----");
			foreach (var item in list)
			{
				IOEntity iOEntity = item.Entities.First();
				stringBuilder.AppendLine($"[{item.Count} times] {iOEntity.PrefabName} @ {((Component)iOEntity).transform.position}");
			}
			if (list.Count > 0)
			{
				IOEntity iOEntity2 = list.First().Entities.First();
				stringBuilder.AppendLine("-----Showing top entity-----");
				stringBuilder.AppendLine($"Entity type: {iOEntity2.ioType}");
				stringBuilder.AppendLine("Entity prefab: " + iOEntity2.PrefabName);
				stringBuilder.AppendLine($"Entity net id: {iOEntity2.net.ID}");
				stringBuilder.AppendLine($"Entity position: teleportpos {((Component)iOEntity2).transform.position}");
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	public virtual void ResetIOState()
	{
	}

	public virtual void Init()
	{
		for (int i = 0; i < outputs.Length; i++)
		{
			IOSlot iOSlot = outputs[i];
			iOSlot.connectedTo.Init();
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				int connectedToSlot = iOSlot.connectedToSlot;
				if (connectedToSlot < 0 || connectedToSlot >= iOSlot.connectedTo.Get().inputs.Length)
				{
					Debug.LogError((object)("Slot IOR Error: " + ((Object)this).name + " setting up inputs for " + ((Object)iOSlot.connectedTo.Get()).name + " slot : " + iOSlot.connectedToSlot));
				}
				else
				{
					iOSlot.connectedTo.Get().inputs[iOSlot.connectedToSlot].connectedTo.Set(this);
					iOSlot.connectedTo.Get().inputs[iOSlot.connectedToSlot].connectedToSlot = i;
					iOSlot.connectedTo.Get().inputs[iOSlot.connectedToSlot].connectedTo.Init();
				}
			}
		}
		UpdateUsedOutputs();
		if (IsRootEntity())
		{
			((FacepunchBehaviour)this).Invoke((Action)MarkDirtyForceUpdateOutputs, Random.Range(1f, 1f));
		}
		ApplyInfinitePower();
	}

	private void ApplyInfinitePower()
	{
		if (!infiniteIoPower || (GetQueueType() != 0 && GetQueueType() != QueueType.Industrial))
		{
			return;
		}
		for (int i = 0; i < inputs.Length; i++)
		{
			if (inputs[i].mainPowerSlot)
			{
				UpdateFromInput(999, i);
			}
		}
	}

	internal override void DoServerDestroy()
	{
		if (base.isServer)
		{
			Shutdown();
		}
		base.DoServerDestroy();
	}

	public void ClearConnections()
	{
		List<IOEntity> list = Pool.Get<List<IOEntity>>();
		List<IOEntity> list2 = Pool.Get<List<IOEntity>>();
		IOSlot[] array = inputs;
		foreach (IOSlot iOSlot in array)
		{
			IOEntity iOEntity = null;
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOEntity = iOSlot.connectedTo.Get();
				if (iOSlot.type == IOType.Industrial)
				{
					list2.Add(iOEntity);
				}
				IOSlot[] array2 = iOSlot.connectedTo.Get().outputs;
				foreach (IOSlot iOSlot2 in array2)
				{
					if ((Object)(object)iOSlot2.connectedTo.Get() != (Object)null && iOSlot2.connectedTo.Get().EqualNetID((BaseNetworkable)this))
					{
						iOSlot2.Clear();
					}
				}
			}
			iOSlot.Clear();
			if (Object.op_Implicit((Object)(object)iOEntity))
			{
				iOEntity.SendNetworkUpdate();
			}
		}
		array = outputs;
		foreach (IOSlot iOSlot3 in array)
		{
			if ((Object)(object)iOSlot3.connectedTo.Get() != (Object)null)
			{
				list.Add(iOSlot3.connectedTo.Get());
				if (iOSlot3.type == IOType.Industrial)
				{
					list2.Add(list[list.Count - 1]);
				}
				IOSlot[] array2 = iOSlot3.connectedTo.Get().inputs;
				foreach (IOSlot iOSlot4 in array2)
				{
					if ((Object)(object)iOSlot4.connectedTo.Get() != (Object)null && iOSlot4.connectedTo.Get().EqualNetID((BaseNetworkable)this))
					{
						iOSlot4.Clear();
					}
				}
			}
			if (Object.op_Implicit((Object)(object)iOSlot3.connectedTo.Get()))
			{
				iOSlot3.connectedTo.Get().UpdateFromInput(0, iOSlot3.connectedToSlot);
			}
			iOSlot3.Clear();
		}
		SendNetworkUpdate();
		foreach (IOEntity item in list)
		{
			if ((Object)(object)item != (Object)null)
			{
				item.MarkDirty();
				item.SendNetworkUpdate();
			}
		}
		for (int k = 0; k < inputs.Length; k++)
		{
			UpdateFromInput(0, k);
		}
		foreach (IOEntity item2 in list2)
		{
			if ((Object)(object)item2 != (Object)null)
			{
				item2.NotifyIndustrialNetworkChanged();
			}
			item2.RefreshIndustrialPreventBuilding();
		}
		Pool.FreeUnmanaged<IOEntity>(ref list);
		Pool.FreeUnmanaged<IOEntity>(ref list2);
		RefreshIndustrialPreventBuilding();
	}

	public void Shutdown()
	{
		SendChangedToRoot(forceUpdate: true);
		ClearConnections();
	}

	public void MarkDirtyForceUpdateOutputs()
	{
		ensureOutputsUpdated = true;
		MarkDirty();
	}

	public void UpdateUsedOutputs()
	{
		cachedOutputsUsed = 0;
		IOSlot[] array = outputs;
		for (int i = 0; i < array.Length; i++)
		{
			IOEntity iOEntity = array[i].connectedTo.Get();
			if ((Object)(object)iOEntity != (Object)null && !iOEntity.IsDestroyed)
			{
				cachedOutputsUsed++;
			}
		}
	}

	public virtual void MarkDirty()
	{
		if (!base.isClient)
		{
			UpdateUsedOutputs();
			TouchIOState();
		}
	}

	public virtual int DesiredPower(int inputIndex = 0)
	{
		if (!inputs[inputIndex].mainPowerSlot)
		{
			return 0;
		}
		int num = ConsumptionAmount();
		if (IsFlickering())
		{
			return num;
		}
		if (currentEnergy < num)
		{
			return 0;
		}
		return num;
	}

	public virtual int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		return inputAmount;
	}

	public virtual int GetCurrentEnergy()
	{
		return Mathf.Clamp(currentEnergy - ConsumptionAmount(), 0, currentEnergy);
	}

	public virtual int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot < 0 || outputSlot >= outputs.Length)
		{
			return 0;
		}
		int num = ((cachedOutputsUsed == 0) ? 1 : cachedOutputsUsed);
		return GetCurrentEnergy() / num;
	}

	public virtual void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, inputAmount >= ConsumptionAmount() && inputAmount > 0, recursive: false, networkupdate: false);
	}

	public void TouchInternal()
	{
		int num = GetPassthroughAmount();
		if (infiniteIoPower && GetQueueType() == QueueType.ElectricLowPriority)
		{
			num = 999;
		}
		bool num2 = lastPassthroughEnergy != num;
		lastPassthroughEnergy = num;
		if (num2)
		{
			IOStateChanged(currentEnergy, 0);
			ensureOutputsUpdated = true;
		}
		if (!PreventDuplicatesInQueue || !_processQueues[GetQueueType()].Contains(this))
		{
			_processQueues[GetQueueType()].Enqueue(this);
		}
	}

	public virtual void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (Interface.CallHook("OnInputUpdate", (object)this, (object)inputAmount, (object)inputSlot) != null)
		{
			return;
		}
		if (inputs[inputSlot].type != ioType || inputs[inputSlot].type == IOType.Industrial)
		{
			IOStateChanged(inputAmount, inputSlot);
			return;
		}
		UpdateHasPower(inputAmount, inputSlot);
		lastEnergy = currentEnergy;
		currentEnergy = CalculateCurrentEnergy(inputAmount, inputSlot);
		int num = GetPassthroughAmount();
		if (infiniteIoPower && GetQueueType() == QueueType.ElectricLowPriority)
		{
			num = 999;
		}
		bool flag = lastPassthroughEnergy != num;
		lastPassthroughEnergy = num;
		if (currentEnergy != lastEnergy || flag)
		{
			IOStateChanged(inputAmount, inputSlot);
			ensureOutputsUpdated = true;
		}
		_processQueues[GetQueueType()].Enqueue(this);
	}

	public virtual void TouchIOState()
	{
		if (!base.isClient)
		{
			TouchInternal();
		}
	}

	public virtual void SendIONetworkUpdate()
	{
		SendNetworkUpdate_Flags();
	}

	public bool IsFlickering()
	{
		if (changedCount > 5)
		{
			return Time.realtimeSinceStartup - lastChangeTime < 1f;
		}
		return false;
	}

	public virtual void IOStateChanged(int inputAmount, int inputSlot)
	{
		if (Time.realtimeSinceStartup - lastChangeTime > 1f)
		{
			changedCount = 1;
		}
		else
		{
			changedCount++;
		}
		lastChangeTime = Time.realtimeSinceStartup;
	}

	public virtual void OnCircuitChanged(bool forceUpdate)
	{
		if (forceUpdate)
		{
			MarkDirtyForceUpdateOutputs();
		}
	}

	public virtual void SendChangedToRoot(bool forceUpdate)
	{
		List<IOEntity> existing = Pool.Get<List<IOEntity>>();
		SendChangedToRootRecursive(forceUpdate, ref existing);
		Pool.FreeUnmanaged<IOEntity>(ref existing);
	}

	public virtual void SendChangedToRootRecursive(bool forceUpdate, ref List<IOEntity> existing)
	{
		bool flag = IsRootEntity();
		if (existing.Contains(this))
		{
			return;
		}
		existing.Add(this);
		bool flag2 = false;
		for (int i = 0; i < inputs.Length; i++)
		{
			IOSlot iOSlot = inputs[i];
			if (!iOSlot.mainPowerSlot)
			{
				continue;
			}
			IOEntity iOEntity = iOSlot.connectedTo.Get();
			if (!((Object)(object)iOEntity == (Object)null) && !existing.Contains(iOEntity))
			{
				flag2 = true;
				if (forceUpdate)
				{
					iOEntity.ensureOutputsUpdated = true;
				}
				iOEntity.SendChangedToRootRecursive(forceUpdate, ref existing);
			}
		}
		if (flag)
		{
			forceUpdate = forceUpdate && !flag2;
			OnCircuitChanged(forceUpdate);
		}
	}

	public void NotifyIndustrialNetworkChanged()
	{
		List<IOEntity> list = Pool.Get<List<IOEntity>>();
		OnIndustrialNetworkChanged();
		NotifyIndustrialNetworkChanged(list, input: true, 128);
		list.Clear();
		NotifyIndustrialNetworkChanged(list, input: false, 128);
		Pool.FreeUnmanaged<IOEntity>(ref list);
	}

	private void NotifyIndustrialNetworkChanged(List<IOEntity> existing, bool input, int maxDepth)
	{
		if (maxDepth <= 0 || existing.Contains(this))
		{
			return;
		}
		if (existing.Count != 0)
		{
			OnIndustrialNetworkChanged();
		}
		existing.Add(this);
		IOSlot[] array = (input ? inputs : outputs);
		foreach (IOSlot iOSlot in array)
		{
			if (iOSlot.type == IOType.Industrial && (Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOSlot.connectedTo.Get().NotifyIndustrialNetworkChanged(existing, input, maxDepth - 1);
			}
		}
	}

	protected virtual void OnIndustrialNetworkChanged()
	{
	}

	public bool ShouldUpdateOutputs()
	{
		if (Time.realtimeSinceStartup - lastUpdateTime < responsetime)
		{
			lastUpdateBlockedFrame = Time.frameCount;
			_processQueues[GetQueueType()].Enqueue(this);
			return false;
		}
		lastUpdateTime = Time.realtimeSinceStartup;
		SendIONetworkUpdate();
		if (outputs.Length == 0)
		{
			ensureOutputsUpdated = false;
			return false;
		}
		return true;
	}

	public virtual void UpdateOutputs()
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnOutputUpdate", (object)this) != null || !ShouldUpdateOutputs() || !ensureOutputsUpdated)
		{
			return;
		}
		ensureOutputsUpdated = false;
		TimeWarning val = TimeWarning.New("ProcessIOOutputs", 0);
		try
		{
			for (int i = 0; i < outputs.Length; i++)
			{
				IOSlot iOSlot = outputs[i];
				bool flag = true;
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if (!((Object)(object)iOEntity != (Object)null))
				{
					continue;
				}
				if (iOSlot.type == IOType.Fluidic && !DisregardGravityRestrictionsOnLiquid && !iOEntity.DisregardGravityRestrictionsOnLiquid)
				{
					TimeWarning val2 = TimeWarning.New("FluidOutputProcessing", 0);
					try
					{
						if (!iOEntity.AllowLiquidPassthrough(this, ((Component)this).transform.TransformPoint(iOSlot.handlePosition)))
						{
							flag = false;
						}
					}
					finally
					{
						((IDisposable)val2)?.Dispose();
					}
				}
				int passthroughAmount = GetPassthroughAmount(i);
				iOEntity.UpdateFromInput(flag ? passthroughAmount : 0, iOSlot.connectedToSlot);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			Init();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Init();
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		Init();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.inputs = Pool.Get<List<IOConnection>>();
		info.msg.ioEntity.outputs = Pool.Get<List<IOConnection>>();
		IOSlot[] array = inputs;
		foreach (IOSlot iOSlot in array)
		{
			IOConnection val = Pool.Get<IOConnection>();
			val.connectedID = iOSlot.connectedTo.entityRef.uid;
			val.connectedToSlot = iOSlot.connectedToSlot;
			val.niceName = iOSlot.niceName;
			val.type = (int)iOSlot.type;
			val.inUse = ((NetworkableId)(ref val.connectedID)).IsValid;
			val.colour = (int)iOSlot.wireColour;
			val.lineThickness = iOSlot.lineThickness;
			val.originPosition = iOSlot.originPosition;
			val.originRotation = iOSlot.originRotation;
			info.msg.ioEntity.inputs.Add(val);
		}
		array = outputs;
		foreach (IOSlot iOSlot2 in array)
		{
			IOConnection val2 = Pool.Get<IOConnection>();
			val2.connectedID = iOSlot2.connectedTo.entityRef.uid;
			val2.connectedToSlot = iOSlot2.connectedToSlot;
			val2.niceName = iOSlot2.niceName;
			val2.type = (int)iOSlot2.type;
			val2.inUse = ((NetworkableId)(ref val2.connectedID)).IsValid;
			val2.colour = (int)iOSlot2.wireColour;
			val2.worldSpaceRotation = iOSlot2.worldSpaceLineEndRotation;
			val2.lineThickness = iOSlot2.lineThickness;
			val2.originPosition = iOSlot2.originPosition;
			val2.originRotation = iOSlot2.originRotation;
			if (iOSlot2.linePoints != null)
			{
				val2.linePointList = Pool.Get<List<LineVec>>();
				for (int j = 0; j < iOSlot2.linePoints.Length; j++)
				{
					Vector3 val3 = iOSlot2.linePoints[j];
					LineVec val4 = Pool.Get<LineVec>();
					val4.vec = Vector4.op_Implicit(val3);
					if (iOSlot2.slackLevels.Length > j)
					{
						val4.vec.w = iOSlot2.slackLevels[j];
					}
					val2.linePointList.Add(val4);
				}
			}
			if (iOSlot2.slackLevels != null)
			{
				val2.slackLevels = Pool.Get<List<float>>();
				val2.slackLevels.AddRange(iOSlot2.slackLevels);
			}
			if (iOSlot2.lineAnchors != null)
			{
				val2.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
				for (int k = 0; k < iOSlot2.lineAnchors.Length; k++)
				{
					if (iOSlot2.lineAnchors[k].entityRef.IsValid(serverside: true))
					{
						WireLineAnchorInfo item = iOSlot2.lineAnchors[k].ToInfo();
						val2.lineAnchorList.Add(item);
					}
				}
			}
			info.msg.ioEntity.outputs.Add(val2);
		}
	}

	public virtual float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot = 0)
	{
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				inputAmount = iOSlot.connectedTo.Get().IOInput(this, iOSlot.type, inputAmount, iOSlot.connectedToSlot);
			}
		}
		return inputAmount;
	}

	public bool Disconnect(int index, bool isInput)
	{
		if (index >= (isInput ? inputs.Length : outputs.Length))
		{
			return false;
		}
		IOSlot iOSlot = (isInput ? inputs[index] : outputs[index]);
		if ((Object)(object)iOSlot.connectedTo.Get() == (Object)null)
		{
			return false;
		}
		IOEntity iOEntity = iOSlot.connectedTo.Get();
		IOSlot obj = (isInput ? iOEntity.outputs[iOSlot.connectedToSlot] : iOEntity.inputs[iOSlot.connectedToSlot]);
		if (isInput)
		{
			UpdateFromInput(0, index);
		}
		else if (Object.op_Implicit((Object)(object)iOEntity))
		{
			iOEntity.UpdateFromInput(0, iOSlot.connectedToSlot);
		}
		iOSlot.Clear();
		obj.Clear();
		MarkDirtyForceUpdateOutputs();
		SendNetworkUpdateImmediate();
		RefreshIndustrialPreventBuilding();
		if ((Object)(object)iOEntity != (Object)null)
		{
			iOEntity.RefreshIndustrialPreventBuilding();
		}
		if (isInput && (Object)(object)iOEntity != (Object)null)
		{
			iOEntity.SendChangedToRoot(forceUpdate: true);
		}
		else if (!isInput)
		{
			IOSlot[] array = inputs;
			foreach (IOSlot iOSlot2 in array)
			{
				if (iOSlot2.mainPowerSlot && Object.op_Implicit((Object)(object)iOSlot2.connectedTo.Get()))
				{
					iOSlot2.connectedTo.Get().SendChangedToRoot(forceUpdate: true);
				}
			}
		}
		iOEntity.SendNetworkUpdateImmediate();
		if (ioType == IOType.Industrial)
		{
			NotifyIndustrialNetworkChanged();
		}
		if ((Object)(object)iOEntity != (Object)null && iOEntity.ioType == IOType.Industrial)
		{
			iOEntity.NotifyIndustrialNetworkChanged();
		}
		return true;
	}

	public void DisconnectAll()
	{
		for (int i = 0; i < inputs.Length; i++)
		{
			Disconnect(i, isInput: true);
		}
		for (int j = 0; j < outputs.Length; j++)
		{
			Disconnect(j, isInput: false);
		}
	}

	public void ConnectTo(IOEntity entity, int outputIndex, int inputIndex)
	{
		ConnectTo(entity, outputIndex, inputIndex, new List<Vector3>(), new List<float>(), new LineAnchor[0]);
	}

	public void ConnectTo(IOEntity entity, int outputIndex, int inputIndex, List<Vector3> points, List<float> slackLevels, LineAnchor[] lineAnchors, WireTool.WireColour colour = WireTool.WireColour.Gray)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		IOSlot obj = entity.inputs[inputIndex];
		obj.connectedTo.Set(this);
		obj.connectedToSlot = outputIndex;
		obj.wireColour = colour;
		obj.connectedTo.Init();
		IOSlot obj2 = outputs[outputIndex];
		obj2.connectedTo.Set(entity);
		obj2.connectedToSlot = inputIndex;
		obj2.linePoints = points.ToArray();
		obj2.slackLevels = slackLevels.ToArray();
		obj2.lineAnchors = lineAnchors;
		obj2.wireColour = colour;
		obj2.connectedTo.Init();
		obj2.worldSpaceLineEndRotation = ((Component)entity).transform.TransformDirection(entity.inputs[inputIndex].handleDirection);
		obj2.originPosition = ((Component)this).transform.position;
		Quaternion rotation = ((Component)this).transform.rotation;
		obj2.originRotation = ((Quaternion)(ref rotation)).eulerAngles;
		MarkDirtyForceUpdateOutputs();
		SendNetworkUpdate();
		entity.SendNetworkUpdate();
		SendChangedToRoot(forceUpdate: true);
		RefreshIndustrialPreventBuilding();
	}

	public void FindContainerSource(List<ContainerInputOutput> found, int depth, bool input, List<IOEntity> ignoreList, int parentId = -1, int stackSize = 0)
	{
		if (depth <= 0 || found.Count >= 32)
		{
			return;
		}
		int num = 0;
		int num2 = 1;
		IOSlot[] array;
		if (!input)
		{
			num2 = 0;
			array = outputs;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].type == IOType.Industrial)
				{
					num2++;
				}
			}
		}
		List<int> list = Pool.Get<List<int>>();
		array = (input ? inputs : outputs);
		foreach (IOSlot iOSlot in array)
		{
			num++;
			if (iOSlot.type != IOType.Industrial)
			{
				continue;
			}
			IOEntity iOEntity = iOSlot.connectedTo.Get(base.isServer);
			if (!((Object)(object)iOEntity != (Object)null) || ignoreList.Contains(iOEntity))
			{
				continue;
			}
			int num3 = -1;
			if (iOEntity is IIndustrialStorage storage2)
			{
				num = iOSlot.connectedToSlot;
				if (GetExistingCount(storage2) < 2)
				{
					found.Add(new ContainerInputOutput
					{
						SlotIndex = num,
						Storage = storage2,
						ParentStorage = parentId,
						MaxStackSize = stackSize / num2
					});
					num3 = found.Count - 1;
					list.Add(num3);
				}
			}
			else
			{
				ignoreList.Add(iOEntity);
			}
			if ((!(iOEntity is IIndustrialStorage) || iOEntity is IndustrialStorageAdaptor) && !(iOEntity is IndustrialConveyor) && (Object)(object)iOEntity != (Object)null)
			{
				iOEntity.FindContainerSource(found, depth - 1, input, ignoreList, (num3 == -1) ? parentId : num3, stackSize / num2);
			}
		}
		int count = list.Count;
		foreach (int item in list)
		{
			ContainerInputOutput value = found[item];
			value.IndustrialSiblingCount = count;
			found[item] = value;
		}
		Pool.FreeUnmanaged<int>(ref list);
		int GetExistingCount(IIndustrialStorage storage)
		{
			int num4 = 0;
			foreach (ContainerInputOutput item2 in found)
			{
				if (item2.Storage == storage)
				{
					num4++;
				}
			}
			return num4;
		}
	}

	public virtual bool AllowLiquidPassthrough(IOEntity fromSource, Vector3 sourceWorldPosition, bool forPlacement = false)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (fromSource.DisregardGravityRestrictionsOnLiquid || DisregardGravityRestrictionsOnLiquid)
		{
			return true;
		}
		if (inputs.Length == 0)
		{
			return false;
		}
		Vector3 val = ((Component)this).transform.TransformPoint(inputs[0].handlePosition);
		float num = sourceWorldPosition.y - val.y;
		if (num > 0f)
		{
			return true;
		}
		if (Mathf.Abs(num) < LiquidPassthroughGravityThreshold)
		{
			return true;
		}
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_036e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_0445: Unknown result type (might be due to invalid IL or missing references)
		//IL_044a: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ioEntity == null)
		{
			return;
		}
		if (!info.fromDisk && info.msg.ioEntity.inputs != null)
		{
			int count = info.msg.ioEntity.inputs.Count;
			if (inputs.Length != count)
			{
				inputs = new IOSlot[count];
			}
			for (int i = 0; i < count; i++)
			{
				if (inputs[i] == null)
				{
					inputs[i] = new IOSlot();
				}
				IOConnection val = info.msg.ioEntity.inputs[i];
				inputs[i].connectedTo = new IORef();
				inputs[i].connectedTo.entityRef.uid = val.connectedID;
				if (base.isClient)
				{
					inputs[i].connectedTo.InitClient();
				}
				inputs[i].connectedToSlot = val.connectedToSlot;
				inputs[i].niceName = val.niceName;
				inputs[i].type = (IOType)val.type;
				inputs[i].wireColour = (WireTool.WireColour)val.colour;
				inputs[i].lineThickness = val.lineThickness;
				inputs[i].originPosition = val.originPosition;
				inputs[i].originRotation = val.originRotation;
			}
		}
		if (info.msg.ioEntity.outputs != null)
		{
			int count2 = info.msg.ioEntity.outputs.Count;
			IOSlot[] array = null;
			if (outputs.Length != count2 && count2 > 0)
			{
				array = outputs;
				outputs = new IOSlot[count2];
				for (int j = 0; j < array.Length; j++)
				{
					if (j < count2)
					{
						outputs[j] = array[j];
					}
				}
			}
			for (int k = 0; k < count2; k++)
			{
				if (outputs[k] == null)
				{
					outputs[k] = new IOSlot();
				}
				IOConnection val2 = info.msg.ioEntity.outputs[k];
				if (val2.linePointList == null || val2.linePointList.Count == 0 || !((NetworkableId)(ref val2.connectedID)).IsValid)
				{
					outputs[k].Clear();
				}
				outputs[k].connectedTo = new IORef();
				outputs[k].connectedTo.entityRef.uid = val2.connectedID;
				if (base.isClient)
				{
					outputs[k].connectedTo.InitClient();
				}
				outputs[k].connectedToSlot = val2.connectedToSlot;
				outputs[k].niceName = val2.niceName;
				outputs[k].type = (IOType)val2.type;
				outputs[k].wireColour = (WireTool.WireColour)val2.colour;
				outputs[k].worldSpaceLineEndRotation = val2.worldSpaceRotation;
				outputs[k].lineThickness = val2.lineThickness;
				outputs[k].originPosition = (info.fromCopy ? ((Component)this).transform.position : val2.originPosition);
				IOSlot obj = outputs[k];
				Vector3 originRotation;
				if (!info.fromCopy)
				{
					originRotation = val2.originRotation;
				}
				else
				{
					Quaternion rotation = ((Component)this).transform.rotation;
					originRotation = ((Quaternion)(ref rotation)).eulerAngles;
				}
				obj.originRotation = originRotation;
				if (!info.fromDisk && !base.isClient)
				{
					continue;
				}
				List<LineVec> list = val2.linePointList ?? new List<LineVec>();
				if (outputs[k].linePoints == null || outputs[k].linePoints.Length != list.Count)
				{
					outputs[k].linePoints = (Vector3[])(object)new Vector3[list.Count];
				}
				if (outputs[k].slackLevels == null || outputs[k].slackLevels.Length != list.Count)
				{
					outputs[k].slackLevels = new float[list.Count];
				}
				for (int l = 0; l < list.Count; l++)
				{
					outputs[k].linePoints[l] = Vector4.op_Implicit(list[l].vec);
					outputs[k].slackLevels[l] = list[l].vec.w;
				}
				List<WireLineAnchorInfo> list2 = val2.lineAnchorList ?? new List<WireLineAnchorInfo>();
				if (outputs[k].lineAnchors == null || outputs[k].lineAnchors.Length != list2.Count)
				{
					outputs[k].lineAnchors = new LineAnchor[list2.Count];
				}
				for (int m = 0; m < list2.Count; m++)
				{
					WireLineAnchorInfo val3 = list2[m];
					if (((NetworkableId)(ref val3.parentID)).IsValid)
					{
						LineAnchor lineAnchor = new LineAnchor(val3);
						outputs[k].lineAnchors[m] = lineAnchor;
					}
				}
			}
		}
		RefreshIndustrialPreventBuilding();
	}

	public int GetConnectedInputCount()
	{
		int num = 0;
		IOSlot[] array = inputs;
		for (int i = 0; i < array.Length; i++)
		{
			if ((Object)(object)array[i].connectedTo.Get(base.isServer) != (Object)null)
			{
				num++;
			}
		}
		return num;
	}

	public int GetConnectedOutputCount()
	{
		int num = 0;
		IOSlot[] array = outputs;
		for (int i = 0; i < array.Length; i++)
		{
			if ((Object)(object)array[i].connectedTo.Get(base.isServer) != (Object)null)
			{
				num++;
			}
		}
		return num;
	}

	public bool HasConnections()
	{
		if (GetConnectedInputCount() <= 0)
		{
			return GetConnectedOutputCount() > 0;
		}
		return true;
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		ClearIndustrialPreventBuilding();
	}

	public void RefreshIndustrialPreventBuilding()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		ClearIndustrialPreventBuilding();
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		CapsuleCollider val5 = default(CapsuleCollider);
		ColliderInfo_Pipe colliderInfo_Pipe = default(ColliderInfo_Pipe);
		for (int i = 0; i < outputs.Length; i++)
		{
			IOSlot iOSlot = outputs[i];
			if (iOSlot.type != IOType.Industrial || iOSlot.linePoints == null || iOSlot.linePoints.Length <= 1)
			{
				continue;
			}
			Vector3 val = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(iOSlot.linePoints[0]);
			for (int j = 1; j < iOSlot.linePoints.Length; j++)
			{
				Vector3 val2 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(iOSlot.linePoints[j]);
				Vector3 pos = Vector3.Lerp(val2, val, 0.5f);
				float num = Vector3.Distance(val2, val);
				Vector3 val3 = val2 - val;
				Quaternion val4;
				if (!(((Vector3)(ref val3)).normalized != Vector3.zero))
				{
					val4 = Quaternion.identity;
				}
				else
				{
					val3 = val2 - val;
					val4 = Quaternion.LookRotation(((Vector3)(ref val3)).normalized);
				}
				Quaternion rot = val4;
				GameObject obj = base.gameManager.CreatePrefab("assets/prefabs/misc/ioentitypreventbuilding.prefab", pos, rot);
				obj.transform.SetParent(((Component)this).transform);
				if (obj.TryGetComponent<CapsuleCollider>(ref val5))
				{
					val5.height = num + val5.radius;
					spawnedColliders.Add((Collider)(object)val5);
				}
				if (obj.TryGetComponent<ColliderInfo_Pipe>(ref colliderInfo_Pipe))
				{
					colliderInfo_Pipe.OutputSlotIndex = i;
					colliderInfo_Pipe.ParentEntity = this;
				}
				val = val2;
			}
		}
	}

	private void ClearIndustrialPreventBuilding()
	{
		foreach (Collider spawnedCollider in spawnedColliders)
		{
			base.gameManager.Retire(((Component)spawnedCollider).gameObject);
		}
		spawnedColliders.Clear();
	}
}


public enum IOType
{
	Electric,
	Fluidic,
	Kinetic,
	Generic,
	Industrial
}


public enum QueueType
{
	ElectricLowPriority,
	ElectricHighPriority,
	Fluidic,
	Kinetic,
	Generic,
	Industrial
}


using System;
using Oxide.Core;
using UnityEngine;

[Serializable]
public class IORef
{
	public EntityRef entityRef;

	public IOEntity ioEnt;

	public void Init()
	{
		if ((Object)(object)ioEnt != (Object)null && !entityRef.IsValid(serverside: true))
		{
			entityRef.Set(ioEnt);
		}
		if (entityRef.IsValid(serverside: true))
		{
			ioEnt = ((Component)entityRef.Get(serverside: true)).GetComponent<IOEntity>();
		}
	}

	public void InitClient()
	{
		if (entityRef.IsValid(serverside: false) && (Object)(object)ioEnt == (Object)null)
		{
			ioEnt = ((Component)entityRef.Get(serverside: false)).GetComponent<IOEntity>();
		}
	}

	public IOEntity Get(bool isServer = true)
	{
		if ((Object)(object)ioEnt == (Object)null && entityRef.IsValid(isServer))
		{
			ioEnt = entityRef.Get(isServer) as IOEntity;
		}
		return ioEnt;
	}

	public void Clear()
	{
		IOEntity iOEntity = ioEnt;
		ioEnt = null;
		entityRef.Set(null);
		Interface.CallHook("OnIORefCleared", (object)this, (object)iOEntity);
	}

	public void Set(IOEntity newIOEnt)
	{
		entityRef.Set(newIOEnt);
	}
}


using System;
using UnityEngine;

[Serializable]
public class IOSlot
{
	public string niceName;

	public IOType type;

	public IORef connectedTo;

	public int connectedToSlot;

	public IOHandlePriority importance;

	public float ArrowOffset;

	public Vector3[] linePoints;

	public LineAnchor[] lineAnchors;

	public float[] slackLevels;

	public Vector3 worldSpaceLineEndRotation;

	[HideInInspector]
	public Vector3 originPosition;

	[HideInInspector]
	public Vector3 originRotation;

	public ClientIOLine line;

	public Vector3 handlePosition;

	public Vector3 handleDirection;

	public bool rootConnectionsOnly;

	public bool mainPowerSlot;

	public WireTool.WireColour wireColour;

	public float lineThickness;

	public void Clear()
	{
		if (connectedTo == null)
		{
			connectedTo = new IORef();
		}
		else
		{
			connectedTo.Clear();
		}
		connectedToSlot = 0;
		linePoints = null;
		lineAnchors = null;
	}

	public void Preserve(ref SprayCan.IOPreserveInfo target)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		target.connectedTo = connectedTo.Get();
		target.connectedToSlot = connectedToSlot;
		target.linePoints = linePoints;
		target.slackLevels = slackLevels;
		target.lineAnchors = lineAnchors;
		target.worldSpaceLineEndRotation = worldSpaceLineEndRotation;
		target.originPosition = originPosition;
		target.originRotation = originRotation;
		target.wireColour = wireColour;
	}

	public void Restore(SprayCan.IOPreserveInfo from)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		connectedTo.Set(from.connectedTo);
		connectedToSlot = from.connectedToSlot;
		linePoints = from.linePoints;
		slackLevels = from.slackLevels;
		lineAnchors = from.lineAnchors;
		worldSpaceLineEndRotation = from.worldSpaceLineEndRotation;
		originPosition = from.originPosition;
		originRotation = from.originRotation;
		wireColour = from.wireColour;
	}

	public bool IsConnected()
	{
		return (Object)(object)connectedTo.Get() != (Object)null;
	}
}


private struct FrameTiming
{
	public string PrefabName;

	public double Time;
}


using ProtoBuf;
using UnityEngine;

public struct LineAnchor
{
	public EntityRef<Door> entityRef;

	public string boneName;

	public int index;

	public Vector3 position;

	public LineAnchor(WireLineAnchorInfo info)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		entityRef = new EntityRef<Door>(info.parentID);
		boneName = info.boneName;
		index = (int)info.index;
		position = info.position;
	}

	public WireLineAnchorInfo ToInfo()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Expected O, but got Unknown
		return new WireLineAnchorInfo
		{
			parentID = entityRef.Get(serverside: true).net.ID,
			boneName = boneName,
			index = index,
			position = position
		};
	}
}


using System;

public struct ContainerInputOutput : IEquatable<ContainerInputOutput>
{
	public IIndustrialStorage Storage;

	public int SlotIndex;

	public int MaxStackSize;

	public int ParentStorage;

	public int IndustrialSiblingCount;

	public bool Equals(ContainerInputOutput other)
	{
		if (object.Equals(Storage, other.Storage) && SlotIndex == other.SlotIndex && MaxStackSize == other.MaxStackSize && ParentStorage == other.ParentStorage)
		{
			return IndustrialSiblingCount == other.IndustrialSiblingCount;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is ContainerInputOutput other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(Storage, SlotIndex, MaxStackSize, ParentStorage, IndustrialSiblingCount);
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ItemBasedFlowRestrictor : IOEntity, IContainerSounds
{
	public ItemDefinition passthroughItem;

	public ItemContainer.ContentsType allowedContents = ItemContainer.ContentsType.Generic;

	public int maxStackSize = 1;

	public int numSlots;

	public string lootPanelName = "generic";

	public const Flags HasPassthrough = Flags.Reserved1;

	public const Flags Sparks = Flags.Reserved2;

	public float passthroughItemConditionLossPerSec = 1f;

	public SoundDefinition openSound;

	public SoundDefinition closeSound;

	public ItemContainer inventory;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ItemBasedFlowRestrictor.OnRpcMessage", 0);
		try
		{
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetIOState()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.On, b: false);
		if (inventory != null)
		{
			inventory.GetSlot(0)?.Drop(((Component)debugOrigin).transform.position + ((Component)this).transform.forward * 0.5f, GetInheritedDropVelocity() + ((Component)this).transform.forward * 2f);
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!HasFlag(Flags.Reserved1))
		{
			return 0;
		}
		return base.GetPassthroughAmount(outputSlot);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		SetFlag(Flags.On, IsPowered());
		SetFlag(Flags.Reserved1, HasPassthroughItem());
		SetFlag(Flags.Reserved2, IsOn() && !HasFlag(Flags.Reserved1));
	}

	public virtual bool HasPassthroughItem()
	{
		if (inventory.itemList.Count <= 0)
		{
			return false;
		}
		Item slot = inventory.GetSlot(0);
		if (slot == null)
		{
			return false;
		}
		if (passthroughItemConditionLossPerSec > 0f && slot.hasCondition && slot.conditionNormalized <= 0f)
		{
			return false;
		}
		if ((Object)(object)slot.info == (Object)(object)passthroughItem)
		{
			return true;
		}
		return false;
	}

	public virtual void TickPassthroughItem()
	{
		if (inventory.itemList.Count > 0 && HasFlag(Flags.On))
		{
			Item slot = inventory.GetSlot(0);
			if (slot != null && slot.hasCondition)
			{
				slot.LoseCondition(1f);
			}
		}
	}

	public override void ServerInit()
	{
		if (inventory == null)
		{
			CreateInventory(giveUID: true);
			OnInventoryFirstCreated(inventory);
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)TickPassthroughItem, 1f, 1f, 0.015f);
		base.ServerInit();
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Pool.Free<ItemContainer>(ref inventory);
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		CreateInventory(giveUID: false);
	}

	public void CreateInventory(bool giveUID)
	{
		Debug.Assert(inventory == null, "Double init of inventory!");
		inventory = Pool.Get<ItemContainer>();
		inventory.entityOwner = this;
		inventory.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
		inventory.SetOnlyAllowedItem(passthroughItem);
		inventory.maxStackSize = maxStackSize;
		inventory.ServerInitialize(null, numSlots);
		if (giveUID)
		{
			inventory.GiveUID();
		}
		inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if (inventory != null)
			{
				info.msg.storageBox = Pool.Get<StorageBox>();
				info.msg.storageBox.contents = inventory.Save();
			}
			else
			{
				Debug.LogWarning((object)("Storage container without inventory: " + ((object)this).ToString()));
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.storageBox != null)
		{
			if (inventory != null)
			{
				inventory.Load(info.msg.storageBox.contents);
				inventory.capacity = numSlots;
			}
			else
			{
				Debug.LogWarning((object)("Storage container without inventory: " + ((object)this).ToString()));
			}
		}
	}

	public virtual void OnInventoryFirstCreated(ItemContainer container)
	{
	}

	public virtual void OnItemAddedOrRemoved(Item item, bool added)
	{
		SetFlag(Flags.Reserved1, HasPassthroughItem());
		MarkDirty();
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if (Object.op_Implicit((Object)(object)player) && player.CanInteract() && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", (object)player, (object)this);
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class Jackhammer : BaseMelee
{
	public float HotspotBonusScale = 1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Jackhammer.OnRpcMessage", 0);
		try
		{
			if (rpc == 1699910227 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetEngineStatus "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetEngineStatus", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_SetEngineStatus(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_SetEngineStatus");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool HasAmmo()
	{
		return true;
	}

	[RPC_Server]
	public void Server_SetEngineStatus(RPCMessage msg)
	{
		SetEngineStatus(msg.read.Bit());
	}

	public void SetEngineStatus(bool on)
	{
		SetFlag(Flags.Reserved8, on);
	}

	public override void SetHeld(bool bHeld)
	{
		if (!bHeld)
		{
			SetEngineStatus(on: false);
		}
		base.SetHeld(bHeld);
	}
}


using System;
using System.Collections;
using Network;
using UnityEngine;

public class JunkPile : BaseEntity
{
	public GameObjectRef sinkEffect;

	public SpawnGroup[] spawngroups;

	public NPCSpawner NPCSpawn;

	private const float lifetimeMinutes = 30f;

	protected bool isSinking;

	private float timeWantingDespawn;

	private float timeBeforeDespawn = 90f;

	private const float CheckEmptyDelay = 30f;

	private const float DelayRandomness = 5f;

	public virtual bool DespawnIfAnyLootTaken => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("JunkPile.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		StartTimeout();
		((MonoBehaviour)this).StartCoroutine(SpawnInitialCoroutine());
		isSinking = false;
	}

	protected virtual void StartTimeout()
	{
		((FacepunchBehaviour)this).Invoke((Action)TimeOut, 1800f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckEmpty, 10f, 30f, 5f);
	}

	internal override void DoServerDestroy()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		StabilityEntity.UpdateSurroundingsQueue updateSurroundingsQueue = StabilityEntity.updateSurroundingsQueue;
		OBB val = WorldSpaceBounds();
		((ObjectWorkQueue<Bounds>)updateSurroundingsQueue).Add(((OBB)(ref val)).ToBounds());
	}

	private IEnumerator SpawnInitialCoroutine()
	{
		yield return CoroutineEx.waitForSeconds(1f);
		SpawnGroup[] array = spawngroups;
		foreach (SpawnGroup s in array)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			s.SpawnInitial();
		}
	}

	public bool SpawnGroupsEmpty()
	{
		SpawnGroup[] array = spawngroups;
		foreach (SpawnGroup spawnGroup in array)
		{
			if (spawnGroup.resetBehavior == SpawnGroupResetBehavior.Exclude || (spawnGroup.DoesGroupContainNPCs() && spawnGroup.resetBehavior != SpawnGroupResetBehavior.Include))
			{
				continue;
			}
			if (DespawnIfAnyLootTaken)
			{
				if (spawnGroup.ObjectsRemoved > 0)
				{
					return true;
				}
				foreach (SpawnPointInstance spawnInstance in spawnGroup.SpawnInstances)
				{
					if (spawnInstance.Entity is LootContainer { HasBeenLooted: not false })
					{
						return true;
					}
				}
			}
			else if (spawnGroup.currentPopulation > 0)
			{
				return false;
			}
		}
		if ((Object)(object)NPCSpawn != (Object)null && NPCSpawn.currentPopulation > 0)
		{
			return false;
		}
		if (DespawnIfAnyLootTaken)
		{
			return false;
		}
		return true;
	}

	public virtual void CheckEmpty()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (SpawnGroupsEmpty() && !BaseNetworkable.HasCloseConnections(((Component)this).transform.position, TimeoutPlayerCheckRadius()))
		{
			timeWantingDespawn += 30f;
			if (timeWantingDespawn >= timeBeforeDespawn)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)CheckEmpty);
				SinkAndDestroy();
			}
		}
		else
		{
			timeWantingDespawn = 0f;
		}
	}

	public virtual float TimeoutPlayerCheckRadius()
	{
		return 15f;
	}

	public void TimeOut()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		if (BaseNetworkable.HasCloseConnections(((Component)this).transform.position, TimeoutPlayerCheckRadius()))
		{
			((FacepunchBehaviour)this).Invoke((Action)TimeOut, 30f);
			return;
		}
		SpawnGroupsEmpty();
		SinkAndDestroy();
	}

	public void SinkAndDestroy()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SinkAndDestroy);
			SpawnGroup[] array = spawngroups;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Clear();
			}
			SetFlag(Flags.Reserved8, b: true, recursive: true);
			if ((Object)(object)NPCSpawn != (Object)null)
			{
				NPCSpawn.Clear();
			}
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_StartSink"));
			Transform transform = ((Component)this).transform;
			transform.position -= new Vector3(0f, 5f, 0f);
			isSinking = true;
			((FacepunchBehaviour)this).Invoke((Action)KillMe, 22f);
		}
	}

	public void KillMe()
	{
		Kill();
	}

	public static void NotifyLootContainerLooted(BaseEntity entity)
	{
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}
}


using System;
using Network;
using Rust;
using UnityEngine;

public class Kayak : BaseBoat, IPoolVehicle
{
	private enum PaddleDirection
	{
		Left,
		Right,
		LeftBack,
		RightBack
	}

	public ItemDefinition OarItem;

	public float maxPaddleFrequency = 0.5f;

	public float forwardPaddleForce = 5f;

	public float multiDriverPaddleForceMultiplier = 0.75f;

	public float rotatePaddleForce = 3f;

	public GameObjectRef forwardSplashEffect;

	public GameObjectRef backSplashEffect;

	public ParticleSystem moveSplashEffect;

	public float animationLerpSpeed = 6f;

	[Header("Audio")]
	public BlendedSoundLoops waterLoops;

	public float waterSoundSpeedDivisor = 10f;

	public GameObjectRef pushLandEffect;

	public GameObjectRef pushWaterEffect;

	public PlayerModel.MountPoses noPaddlePose;

	public TimeSince[] playerPaddleCooldowns = (TimeSince[])(object)new TimeSince[2];

	public TimeCachedValue<float> fixedDragUpdate;

	public TimeSince timeSinceLastUsed;

	private const float DECAY_TICK_TIME = 60f;

	private Vector3 lastTravelPos;

	private bool inCinematic;

	private Quaternion cinematicWorldRotation;

	private int lastDownhillUpdate;

	private float distanceRemainder;

	protected override bool SkipBoatForcedUpdate => buoyancy.BuoyancyPriority == Buoyancy.Priority.Low;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Kayak.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		inCinematic = false;
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)BoatDecay, Random.Range(30f, 60f), 60f, 6f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)LowPriorityCheck, 0f, 5f, 2.5f);
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		buoyancy.wavesEffect = (((Object)(object)deployedBy != (Object)null && deployedBy.IsInTutorial) ? 0f : 1f);
	}

	public override void OnPlayerMounted()
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		base.OnPlayerMounted();
		if (!((FacepunchBehaviour)this).IsInvoking((Action)TravelDistanceUpdate) && GameInfo.HasAchievements)
		{
			int num = 0;
			foreach (MountPointInfo allMountPoint in base.allMountPoints)
			{
				if ((Object)(object)allMountPoint.mountable != (Object)null && allMountPoint.mountable.AnyMounted())
				{
					num++;
				}
			}
			if (num == 2)
			{
				lastTravelPos = Vector3Ex.WithY(((Component)this).transform.position, 0f);
				((FacepunchBehaviour)this).InvokeRandomized((Action)TravelDistanceUpdate, 5f, 5f, 3f);
			}
		}
		buoyancy.LowPriorityCheck(forceHighPriority: true);
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		if (((FacepunchBehaviour)this).IsInvoking((Action)TravelDistanceUpdate))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TravelDistanceUpdate);
		}
	}

	public override void DriverInput(InputState inputState, BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		if (!IsPlayerHoldingPaddle(player))
		{
			return;
		}
		int playerSeat = GetPlayerSeat(player);
		if (!(TimeSince.op_Implicit(playerPaddleCooldowns[playerSeat]) > maxPaddleFrequency))
		{
			return;
		}
		bool flag = inputState.IsDown(BUTTON.BACKWARD);
		bool flag2 = false;
		Vector3 val = ((Component)this).transform.forward;
		if (flag)
		{
			val = -val;
		}
		float num = forwardPaddleForce;
		if (NumMounted() >= 2)
		{
			num *= multiDriverPaddleForceMultiplier;
		}
		if (inputState.IsDown(BUTTON.LEFT) || inputState.IsDown(BUTTON.FIRE_PRIMARY))
		{
			flag2 = true;
			rigidBody.AddForceAtPosition(val * num, GetPaddlePoint(playerSeat, PaddleDirection.Left), (ForceMode)1);
			Rigidbody obj = rigidBody;
			obj.angularVelocity += -((Component)this).transform.up * rotatePaddleForce;
			ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), flag ? 2 : 0, playerSeat);
		}
		else if (inputState.IsDown(BUTTON.RIGHT) || inputState.IsDown(BUTTON.FIRE_SECONDARY))
		{
			flag2 = true;
			rigidBody.AddForceAtPosition(val * num, GetPaddlePoint(playerSeat, PaddleDirection.Right), (ForceMode)1);
			Rigidbody obj2 = rigidBody;
			obj2.angularVelocity += ((Component)this).transform.up * rotatePaddleForce;
			ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), (!flag) ? 1 : 3, playerSeat);
		}
		if (flag2)
		{
			playerPaddleCooldowns[playerSeat] = TimeSince.op_Implicit(0f);
			if (!flag)
			{
				Vector3 velocity = rigidBody.velocity;
				rigidBody.velocity = Vector3.Lerp(velocity, val * ((Vector3)(ref velocity)).magnitude, 0.4f);
			}
		}
	}

	private void TravelDistanceUpdate()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.WithY(((Component)this).transform.position, 0f);
		if (GameInfo.HasAchievements)
		{
			float num = Vector3.Distance(lastTravelPos, val) + distanceRemainder;
			float num2 = Mathf.Max(Mathf.Floor(num), 0f);
			distanceRemainder = num - num2;
			foreach (MountPointInfo allMountPoint in base.allMountPoints)
			{
				if ((Object)(object)allMountPoint.mountable != (Object)null && allMountPoint.mountable.AnyMounted() && (int)num2 > 0)
				{
					allMountPoint.mountable.GetMounted().stats.Add("kayak_distance_travelled", (int)num2);
					allMountPoint.mountable.GetMounted().stats.Save(forceSteamSave: true);
				}
			}
		}
		lastTravelPos = val;
	}

	public override bool EngineOn()
	{
		return false;
	}

	public override void DoPushAction(BasePlayer player)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		if (IsFlipped())
		{
			rigidBody.AddRelativeTorque(Vector3.forward * 8f, (ForceMode)2);
		}
		else
		{
			Vector3 val = Vector3Ex.Direction2D(((Component)player).transform.position + player.eyes.BodyForward() * 3f, ((Component)player).transform.position);
			Vector3 val2 = Vector3.up * 0.1f + val;
			val = ((Vector3)(ref val2)).normalized;
			Vector3 position = ((Component)this).transform.position;
			float num = 5f;
			if (IsInWater())
			{
				num *= 0.75f;
			}
			rigidBody.AddForceAtPosition(val * num, position, (ForceMode)2);
		}
		if (IsInWater())
		{
			if (pushWaterEffect.isValid)
			{
				Effect.server.Run(pushWaterEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		else if (pushLandEffect.isValid)
		{
			Effect.server.Run(pushLandEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
		WakeUp();
	}

	public override void VehicleFixedUpdate()
	{
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Kayak.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (fixedDragUpdate == null)
			{
				fixedDragUpdate = new TimeCachedValue<float>
				{
					refreshCooldown = 0.5f,
					refreshRandomRange = 0.2f,
					updateValue = CalculateDesiredDrag
				};
			}
			if (inCinematic)
			{
				if (!rigidBody.isKinematic)
				{
					Vector3 velocity = rigidBody.velocity;
					velocity = Vector3.MoveTowards(velocity, Vector3Ex.WithZ(Vector3Ex.WithX(velocity, 0f), 0f), Time.fixedDeltaTime);
					rigidBody.velocity = velocity;
				}
				((Component)this).transform.rotation = Quaternion.RotateTowards(((Component)this).transform.rotation, cinematicWorldRotation, 180f * Time.fixedDeltaTime);
			}
			rigidBody.drag = fixedDragUpdate.Get(force: false);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public float CalculateDesiredDrag()
	{
		int num = NumMounted();
		if (num == 0)
		{
			return 1f;
		}
		if (num < 2)
		{
			return 0.05f;
		}
		return 0.1f;
	}

	public void BoatDecay()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		BaseBoat.WaterVehicleDecay(this, 60f, TimeSince.op_Implicit(timeSinceLastUsed), MotorRowboat.outsidedecayminutes, MotorRowboat.deepwaterdecayminutes, MotorRowboat.decaystartdelayminutes, preventDecayIndoors);
	}

	private void LowPriorityCheck()
	{
		buoyancy.LowPriorityCheck(AnyMounted());
	}

	public void PrepareForTutorialCinematic(Quaternion worldRotation)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		inCinematic = true;
		cinematicWorldRotation = worldRotation;
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (!HasFlag(Flags.Reserved17))
		{
			return base.ShouldDisplayPickupOption(player);
		}
		return false;
	}

	public bool IsPlayerHoldingPaddle(BasePlayer player)
	{
		if ((Object)(object)player.GetHeldEntity() != (Object)null)
		{
			return (Object)(object)player.GetHeldEntity().GetItem().info == (Object)(object)OarItem;
		}
		return false;
	}

	public Vector3 GetPaddlePoint(int index, PaddleDirection direction)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		index = Mathf.Clamp(index, 0, mountPoints.Count);
		Vector3 pos = mountPoints[index].pos;
		switch (direction)
		{
		case PaddleDirection.Left:
			pos.x -= 1f;
			break;
		case PaddleDirection.Right:
			pos.x += 1f;
			break;
		}
		pos.y -= 0.2f;
		return ((Component)this).transform.TransformPoint(pos);
	}

	public bool IsInWater()
	{
		if (base.isServer)
		{
			return buoyancy.timeOutOfWater < 0.1f;
		}
		return false;
	}
}


private enum PaddleDirection
{
	Left,
	Right,
	LeftBack,
	RightBack
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class KeyLock : BaseLock
{
	[ItemSelector]
	public ItemDefinition keyItemType;

	public int keyCode;

	public bool firstKeyCreated;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("KeyLock.OnRpcMessage", 0);
		try
		{
			if (rpc == 4135414453u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_CreateKey "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_CreateKey", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4135414453u, "RPC_CreateKey", this, player, 3f, checkParent: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_CreateKey(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_CreateKey");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 954115386 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Lock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Lock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(954115386u, "RPC_Lock", this, player, 3f, checkParent: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_Lock(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Lock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1663222372 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Unlock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Unlock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1663222372u, "RPC_Unlock", this, player, 3f, checkParent: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							RPC_Unlock(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_Unlock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool HasLockPermission(BasePlayer player)
	{
		if (player.IsDead())
		{
			return false;
		}
		if ((ulong)player.userID == base.OwnerID)
		{
			return true;
		}
		PooledList<Item> val = Pool.Get<PooledList<Item>>();
		try
		{
			player.inventory.FindItemsByItemID((List<Item>)(object)val, keyItemType.itemid);
			for (int i = 0; i < ((List<Item>)(object)val).Count; i++)
			{
				if (CanKeyUnlockUs(((List<Item>)(object)val)[i]))
				{
					return true;
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool CanKeyUnlockUs(Item key)
	{
		if (key.instanceData == null)
		{
			return false;
		}
		if (key.instanceData.dataInt != keyCode)
		{
			return false;
		}
		return true;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.keyLock != null)
		{
			LoadKeylockData(info.msg.keyLock);
		}
	}

	public void LoadKeylockData(KeyLock keyLock)
	{
		if (keyLock != null)
		{
			keyCode = keyLock.code;
		}
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (base.OwnerID == 0L && Object.op_Implicit((Object)(object)GetParentEntity()))
		{
			base.OwnerID = GetParentEntity().OwnerID;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.keyLock = Pool.Get<KeyLock>();
			info.msg.keyLock.code = keyCode;
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		keyCode = Random.Range(1, 100000);
		Lock(deployedBy);
	}

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

	public override bool OnTryToClose(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	private void RPC_Unlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", (object)rpc.player, (object)this) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	private void RPC_Lock(RPCMessage rpc)
	{
		Lock(rpc.player);
	}

	private void Lock(BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) && player.CanInteract() && !IsLocked() && Interface.CallHook("CanLock", (object)player, (object)this) == null && HasLockPermission(player))
		{
			LockLock(player);
			SendNetworkUpdate();
		}
	}

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void RPC_CreateKey(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || (IsLocked() && !HasLockPermission(rpc.player)))
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(keyItemType.itemid);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			Debug.LogWarning((object)("RPC_CreateKey: Itemdef is missing! " + (object)keyItemType));
			return;
		}
		ItemBlueprint bp = ItemManager.FindBlueprint(itemDefinition);
		if (rpc.player.inventory.crafting.CanCraft(bp))
		{
			InstanceData val = Pool.Get<InstanceData>();
			val.dataInt = keyCode;
			rpc.player.inventory.crafting.CraftItem(bp, rpc.player, val);
			if (!firstKeyCreated)
			{
				LockLock(rpc.player);
				SendNetworkUpdate();
				firstKeyCreated = true;
			}
		}
	}

	public void LockLock(BasePlayer player)
	{
		SetFlag(Flags.Locked, b: true);
		if (player.IsValid())
		{
			player.GiveAchievement("LOCK_LOCK");
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Landmine : BaseTrap
{
	public GameObjectRef explosionEffect;

	public GameObjectRef triggeredEffect;

	public float minExplosionRadius;

	public float explosionRadius;

	public int vibrationLevel = 1;

	public bool blocked;

	private ulong triggerPlayerID;

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Landmine.OnRpcMessage", 0);
		try
		{
			if (rpc == 1552281787 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Disarm "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Disarm", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1552281787u, "RPC_Disarm", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_Disarm(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Disarm");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool Triggered()
	{
		return HasFlag(Flags.Open);
	}

	public bool Armed()
	{
		return HasFlag(Flags.On);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.landmine = Pool.Get<Landmine>();
			info.msg.landmine.triggeredID = triggerPlayerID;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!info.fromDisk && info.msg.landmine != null)
		{
			triggerPlayerID = info.msg.landmine.triggeredID;
		}
	}

	public override void ServerInit()
	{
		SetFlag(Flags.On, b: false);
		((FacepunchBehaviour)this).Invoke((Action)Arm, 1.5f);
		base.ServerInit();
	}

	public override void ObjectEntered(GameObject obj)
	{
		if (!base.isClient)
		{
			if (!Armed())
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Arm);
				blocked = true;
			}
			else if (Interface.CallHook("OnTrapTrigger", (object)this, (object)obj) == null)
			{
				BasePlayer ply = obj.ToBaseEntity() as BasePlayer;
				Trigger(ply);
			}
		}
	}

	public void Trigger(BasePlayer ply = null)
	{
		if ((Object)(object)ply != (Object)null)
		{
			triggerPlayerID = ply.userID;
		}
		SetFlag(Flags.Open, b: true);
		SendNetworkUpdate();
	}

	public override void OnEmpty()
	{
		if (blocked)
		{
			Arm();
			blocked = false;
		}
		else if (Triggered())
		{
			((FacepunchBehaviour)this).Invoke((Action)TryExplode, 0.05f);
		}
	}

	public virtual void Explode()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		base.health = float.PositiveInfinity;
		Effect.server.Run(explosionEffect.resourcePath, PivotPoint(), ((Component)this).transform.up, null, broadcast: true);
		DamageUtil.RadiusDamage(this, LookupPrefab(), CenterPoint(), minExplosionRadius, explosionRadius, damageTypes, 2263296, useLineOfSight: true);
		SeismicSensor.Notify(CenterPoint(), vibrationLevel);
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public override void OnDied(HitInfo info)
	{
		((FacepunchBehaviour)this).Invoke((Action)Explode, Random.Range(0.1f, 0.3f));
	}

	private void OnGroundMissing()
	{
		Explode();
	}

	private void TryExplode()
	{
		if (Armed())
		{
			Explode();
		}
	}

	public override void Arm()
	{
		SetFlag(Flags.On, b: true);
		SendNetworkUpdate();
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Disarm(RPCMessage rpc)
	{
		if ((ulong)rpc.player.userID != triggerPlayerID && Armed() && Interface.CallHook("OnTrapDisarm", (object)this, (object)rpc.player) == null && Triggered())
		{
			if (Random.Range(0, 100) < 15)
			{
				((FacepunchBehaviour)this).Invoke((Action)TryExplode, 0.05f);
				return;
			}
			SetFlag(Flags.On, b: false);
			rpc.player.GiveItem(ItemManager.CreateByName("trap.landmine", 1, 0uL), GiveItemReason.PickedUp);
			Kill();
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Lift : AnimatedBuildingBlock
{
	public GameObjectRef triggerPrefab;

	public string triggerBone;

	public float resetDelay = 5f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Lift.OnRpcMessage", 0);
		try
		{
			if (rpc == 2657791441u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_UseLift "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_UseLift", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2657791441u, "RPC_UseLift", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_UseLift(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_UseLift");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_UseLift(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && Interface.CallHook("OnLiftUse", (object)this, (object)rpc.player) == null)
		{
			MoveUp();
		}
	}

	private void MoveUp()
	{
		if (!IsOpen() && !IsBusy())
		{
			SetFlag(Flags.Open, b: true);
			SendNetworkUpdateImmediate();
		}
	}

	private void MoveDown()
	{
		if (IsOpen() && !IsBusy())
		{
			SetFlag(Flags.Open, b: false);
			SendNetworkUpdateImmediate();
		}
	}

	protected override void OnAnimatorDisabled()
	{
		if (base.isServer && IsOpen())
		{
			((FacepunchBehaviour)this).Invoke((Action)MoveDown, resetDelay);
		}
	}

	public override void Spawn()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(triggerPrefab.resourcePath, Vector3.zero, Quaternion.identity);
			baseEntity.Spawn();
			baseEntity.SetParent(this, triggerBone);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class LiquidContainer : ContainerIOEntity
{
	public ItemDefinition defaultLiquid;

	public int startingAmount;

	public bool autofillOutputs;

	public float autofillTickRate = 2f;

	public int autofillTickAmount = 2;

	public int maxOutputFlow = 6;

	public ItemDefinition[] ValidItems;

	private int currentDrainAmount;

	private HashSet<IOEntity> connectedList = new HashSet<IOEntity>();

	private HashSet<ContainerIOEntity> pushTargets = new HashSet<ContainerIOEntity>();

	private const int maxPushTargets = 12;

	private IOEntity considerConnectedTo;

	private Action updateDrainAmountAction;

	private Action updatePushLiquidTargetsAction;

	private Action pushLiquidAction;

	private Action deductFuelAction;

	private TimeUntil waterTransferStartTime;

	private float lastOutputDrainUpdate;

	private static HashSet<IOEntity> pushLiquidCheckEntityHash = new HashSet<IOEntity>();

	public override bool IsGravitySource => true;

	protected override bool DisregardGravityRestrictionsOnLiquid
	{
		get
		{
			if (!HasFlag(Flags.Reserved8))
			{
				return base.DisregardGravityRestrictionsOnLiquid;
			}
			return true;
		}
	}

	public override bool BlockFluidDraining => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("LiquidContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 2002733690 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVDrink "));
				}
				TimeWarning val2 = TimeWarning.New("SVDrink", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2002733690u, "SVDrink", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							SVDrink(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SVDrink");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool AllowWireConnections()
	{
		if (HasParent() && (Object)(object)parentEntity.Get(base.isServer) != (Object)null && parentEntity.Get(base.isServer) is VehicleModuleStorage)
		{
			return true;
		}
		return base.AllowWireConnections();
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	private bool CanAcceptItem(Item item, int count)
	{
		if (ValidItems == null || ValidItems.Length == 0)
		{
			return true;
		}
		ItemDefinition[] validItems = ValidItems;
		for (int i = 0; i < validItems.Length; i++)
		{
			if ((Object)(object)validItems[i] == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	public override void ServerInit()
	{
		updateDrainAmountAction = UpdateDrainAmount;
		pushLiquidAction = PushLiquidThroughOutputs;
		deductFuelAction = DeductFuel;
		updatePushLiquidTargetsAction = UpdatePushLiquidTargets;
		base.ServerInit();
		if (startingAmount > 0)
		{
			base.inventory.AddItem(defaultLiquid, startingAmount, 0uL);
		}
		if (autofillOutputs && HasLiquidItem())
		{
			UpdatePushLiquidTargets();
		}
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
	}

	public override void OnCircuitChanged(bool forceUpdate)
	{
		base.OnCircuitChanged(forceUpdate);
		ClearDrains();
		((FacepunchBehaviour)this).Invoke(updateDrainAmountAction, 0.1f);
		if (autofillOutputs && HasLiquidItem())
		{
			((FacepunchBehaviour)this).Invoke(updatePushLiquidTargetsAction, 0.1f);
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		base.OnItemAddedOrRemoved(item, added);
		UpdateOnFlag();
		MarkDirtyForceUpdateOutputs();
		((FacepunchBehaviour)this).Invoke(updateDrainAmountAction, 0.1f);
		if (connectedList.Count > 0)
		{
			List<IOEntity> list = Pool.Get<List<IOEntity>>();
			foreach (IOEntity connected in connectedList)
			{
				if ((Object)(object)connected != (Object)null)
				{
					list.Add(connected);
				}
			}
			foreach (IOEntity item2 in list)
			{
				item2.SendChangedToRoot(forceUpdate: true);
			}
			Pool.FreeUnmanaged<IOEntity>(ref list);
		}
		if (HasLiquidItem() && autofillOutputs)
		{
			((FacepunchBehaviour)this).Invoke(updatePushLiquidTargetsAction, 0.1f);
		}
		if (added)
		{
			waterTransferStartTime = TimeUntil.op_Implicit(10f);
		}
	}

	private void ClearDrains()
	{
		foreach (IOEntity connected in connectedList)
		{
			if ((Object)(object)connected != (Object)null)
			{
				connected.SetFuelType(null, null);
			}
		}
		connectedList.Clear();
	}

	public override int GetCurrentEnergy()
	{
		return Mathf.Clamp(GetLiquidCount(), 0, maxOutputFlow);
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		if (!HasLiquidItem())
		{
			return base.CalculateCurrentEnergy(inputAmount, inputSlot);
		}
		return GetCurrentEnergy();
	}

	private void UpdateDrainAmount()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		int amount = 0;
		Item liquidItem = GetLiquidItem();
		if (liquidItem != null)
		{
			IOSlot[] array = outputs;
			foreach (IOSlot iOSlot in array)
			{
				if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
				{
					CalculateDrain(iOSlot.connectedTo.Get(), ((Component)this).transform.TransformPoint(iOSlot.handlePosition), IOEntity.backtracking * 2, ref amount, this, liquidItem?.info);
				}
			}
		}
		currentDrainAmount = Mathf.Clamp(amount, 0, maxOutputFlow);
		if (currentDrainAmount <= 0 && ((FacepunchBehaviour)this).IsInvoking(deductFuelAction))
		{
			((FacepunchBehaviour)this).CancelInvoke(deductFuelAction);
		}
		else if (currentDrainAmount > 0 && !((FacepunchBehaviour)this).IsInvoking(deductFuelAction))
		{
			((FacepunchBehaviour)this).InvokeRepeating(deductFuelAction, 0f, 1f);
		}
	}

	private void CalculateDrain(IOEntity ent, Vector3 fromSlotWorld, int depth, ref int amount, IOEntity lastEntity, ItemDefinition waterType)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)(object)this || depth <= 0 || (Object)(object)ent == (Object)null || (Object)(object)lastEntity == (Object)null || ent is LiquidContainer)
		{
			return;
		}
		if (!ent.BlockFluidDraining && ent.HasFlag(Flags.On))
		{
			int num = ent.DesiredPower();
			amount += num;
			ent.SetFuelType(waterType, this);
			connectedList.Add(ent);
		}
		if (!ent.AllowLiquidPassthrough(lastEntity, fromSlotWorld))
		{
			return;
		}
		IOSlot[] array = ent.outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null && (Object)(object)iOSlot.connectedTo.Get() != (Object)(object)ent)
			{
				CalculateDrain(iOSlot.connectedTo.Get(), ((Component)ent).transform.TransformPoint(iOSlot.handlePosition), depth - 1, ref amount, ent, waterType);
			}
		}
	}

	public override void UpdateOutputs()
	{
		base.UpdateOutputs();
		if (!(Time.realtimeSinceStartup - lastOutputDrainUpdate < 0.2f))
		{
			lastOutputDrainUpdate = Time.realtimeSinceStartup;
			ClearDrains();
			((FacepunchBehaviour)this).Invoke(updateDrainAmountAction, 0.1f);
		}
	}

	private void DeductFuel()
	{
		if (HasLiquidItem())
		{
			Item liquidItem = GetLiquidItem();
			liquidItem.amount -= currentDrainAmount;
			liquidItem.MarkDirty();
			if (liquidItem.amount <= 0)
			{
				liquidItem.Remove();
			}
		}
	}

	protected void UpdateOnFlag()
	{
		SetFlag(Flags.On, base.inventory.itemList.Count > 0 && base.inventory.itemList[0].amount > 0);
	}

	public virtual void OpenTap(float duration)
	{
		if (!HasFlag(Flags.Reserved5))
		{
			SetFlag(Flags.Reserved5, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ShutTap, duration);
			SendNetworkUpdateImmediate();
		}
	}

	public virtual void ShutTap()
	{
		SetFlag(Flags.Reserved5, b: false);
		SendNetworkUpdateImmediate();
	}

	public bool HasLiquidItem()
	{
		return GetLiquidItem() != null;
	}

	public Item GetLiquidItem()
	{
		if (base.inventory == null || base.inventory.itemList.Count == 0)
		{
			return null;
		}
		return base.inventory.itemList[0];
	}

	public int GetLiquidCount()
	{
		if (!HasLiquidItem())
		{
			return 0;
		}
		return GetLiquidItem().amount;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void SVDrink(RPCMessage rpc)
	{
		if (!rpc.player.metabolism.CanConsume() || Interface.CallHook("OnPlayerDrink", (object)rpc.player, (object)this) != null)
		{
			return;
		}
		foreach (Item item in base.inventory.itemList)
		{
			ItemModConsume component = ((Component)item.info).GetComponent<ItemModConsume>();
			if (!((Object)(object)component == (Object)null) && component.CanDoAction(item, rpc.player))
			{
				component.DoAction(item, rpc.player);
				break;
			}
		}
	}

	private void UpdatePushLiquidTargets()
	{
		pushTargets.Clear();
		if (!HasLiquidItem() || IsConnectedTo(this, IOEntity.backtracking * 2))
		{
			return;
		}
		Item liquidItem = GetLiquidItem();
		pushLiquidCheckEntityHash.Clear();
		TimeWarning val = TimeWarning.New("UpdatePushTargets", 0);
		try
		{
			IOSlot[] array = outputs;
			foreach (IOSlot iOSlot in array)
			{
				if (iOSlot.type == IOType.Fluidic)
				{
					IOEntity iOEntity = iOSlot.connectedTo.Get();
					if ((Object)(object)iOEntity != (Object)null)
					{
						CheckPushLiquid(iOEntity, liquidItem, this, IOEntity.backtracking * 4, pushLiquidCheckEntityHash);
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (pushTargets.Count > 0)
		{
			((FacepunchBehaviour)this).InvokeRandomized(pushLiquidAction, 0f, autofillTickRate, autofillTickRate * 0.2f);
		}
	}

	private void PushLiquidThroughOutputs()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeUntil.op_Implicit(waterTransferStartTime) > 0f)
		{
			return;
		}
		if (!HasLiquidItem())
		{
			((FacepunchBehaviour)this).CancelInvoke(pushLiquidAction);
			return;
		}
		Item liquidItem = GetLiquidItem();
		if (pushTargets.Count > 0)
		{
			int num = Mathf.Clamp(autofillTickAmount, 0, liquidItem.amount) / pushTargets.Count;
			if (num == 0 && liquidItem.amount > 0)
			{
				num = liquidItem.amount;
			}
			if (Server.waterContainersLeaveWaterBehind && num == liquidItem.amount)
			{
				num--;
			}
			if (num == 0)
			{
				return;
			}
			foreach (ContainerIOEntity pushTarget in pushTargets)
			{
				if (pushTarget.inventory == null)
				{
					if (!((FacepunchBehaviour)this).IsInvoking(updatePushLiquidTargetsAction))
					{
						((FacepunchBehaviour)this).Invoke(updatePushLiquidTargetsAction, 0.1f);
					}
				}
				else if (pushTarget.inventory.CanAcceptItem(liquidItem, 0) == ItemContainer.CanAcceptResult.CanAccept && (pushTarget.inventory.CanAccept(liquidItem) || pushTarget.inventory.FindItemByItemID(liquidItem.info.itemid) != null))
				{
					int num2 = Mathf.Clamp(num, 0, pushTarget.inventory.GetMaxTransferAmount(liquidItem.info));
					pushTarget.inventory.AddItem(liquidItem.info, num2, 0uL);
					liquidItem.amount -= num2;
					liquidItem.MarkDirty();
					if (liquidItem.amount <= 0)
					{
						break;
					}
				}
			}
		}
		if (liquidItem.amount <= 0 || pushTargets.Count == 0)
		{
			if (liquidItem.amount <= 0)
			{
				liquidItem.Remove();
			}
			((FacepunchBehaviour)this).CancelInvoke(pushLiquidAction);
		}
	}

	private void CheckPushLiquid(IOEntity connected, Item ourFuel, IOEntity fromSource, int depth, HashSet<IOEntity> checkEntities)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		if (depth <= 0 || ourFuel.amount <= 0)
		{
			return;
		}
		Vector3 worldHandlePosition = Vector3.zero;
		IOEntity iOEntity = connected.FindGravitySource(ref worldHandlePosition, IOEntity.backtracking * 2, ignoreSelf: true);
		if (((Object)(object)iOEntity != (Object)null && !connected.AllowLiquidPassthrough(iOEntity, worldHandlePosition)) || (Object)(object)connected == (Object)(object)this || ConsiderConnectedTo(connected))
		{
			return;
		}
		if (connected is ContainerIOEntity containerIOEntity && !pushTargets.Contains(containerIOEntity) && containerIOEntity.inventory.CanAcceptItem(ourFuel, 0) == ItemContainer.CanAcceptResult.CanAccept)
		{
			pushTargets.Add(containerIOEntity);
			return;
		}
		IOSlot[] array = connected.outputs;
		foreach (IOSlot iOSlot in array)
		{
			IOEntity iOEntity2 = iOSlot.connectedTo.Get();
			if (!((Object)(object)iOEntity2 != (Object)null) || !((Object)(object)iOEntity2 != (Object)(object)fromSource) || !checkEntities.Add(iOEntity2))
			{
				continue;
			}
			Vector3 sourceWorldPosition = ((Component)connected).transform.TransformPoint(iOSlot.handlePosition);
			if (iOEntity2.AllowLiquidPassthrough(fromSource, sourceWorldPosition))
			{
				CheckPushLiquid(iOEntity2, ourFuel, fromSource, depth - 1, checkEntities);
				if (pushTargets.Count >= 12)
				{
					break;
				}
			}
		}
	}

	public void SetConnectedTo(IOEntity entity)
	{
		considerConnectedTo = entity;
	}

	protected override bool ConsiderConnectedTo(IOEntity entity)
	{
		return (Object)(object)entity == (Object)(object)considerConnectedTo;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class LiquidVessel : HeldEntity
{
	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("LiquidVessel.OnRpcMessage", 0);
		try
		{
			if (rpc == 4034725537u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoEmpty "));
				}
				TimeWarning val2 = TimeWarning.New("DoEmpty", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(4034725537u, "DoEmpty", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoEmpty(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoEmpty");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool CanDrink()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return false;
		}
		if (!ownerPlayer.metabolism.CanConsume())
		{
			return false;
		}
		Item item = GetItem();
		if (item == null)
		{
			return false;
		}
		if (item.contents == null)
		{
			return false;
		}
		if (item.contents.itemList == null)
		{
			return false;
		}
		if (item.contents.itemList.Count == 0)
		{
			return false;
		}
		return true;
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void DoEmpty(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		Item item = GetItem();
		if (item == null || item.contents == null || !msg.player.metabolism.CanConsume())
		{
			return;
		}
		using List<Item>.Enumerator enumerator = item.contents.itemList.GetEnumerator();
		if (enumerator.MoveNext())
		{
			enumerator.Current.UseItem(50);
		}
	}

	public void AddLiquid(ItemDefinition liquidType, int amount)
	{
		if (amount <= 0)
		{
			return;
		}
		Item item = GetItem();
		Item item2 = item.contents.GetSlot(0);
		ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
		if (item2 == null)
		{
			ItemManager.Create(liquidType, amount, 0uL)?.MoveToContainer(item.contents);
			return;
		}
		int num = Mathf.Clamp(item2.amount + amount, 0, component.maxStackSize);
		ItemDefinition itemDefinition = WaterResource.Merge(item2.info, liquidType);
		if ((Object)(object)itemDefinition != (Object)(object)item2.info)
		{
			item2.Remove();
			item2 = ItemManager.Create(itemDefinition, num, 0uL);
			item2.MoveToContainer(item.contents);
		}
		else
		{
			item2.amount = num;
		}
		item2.MarkDirty();
		SendNetworkUpdateImmediate();
	}

	public bool CanFillHere(Vector3 pos)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return false;
		}
		if ((double)ownerPlayer.WaterFactor() > 0.05)
		{
			return true;
		}
		return false;
	}

	public int AmountHeld()
	{
		return GetItem().contents.GetSlot(0)?.amount ?? 0;
	}

	public float HeldFraction()
	{
		return (float)AmountHeld() / (float)MaxHoldable();
	}

	public bool IsFull()
	{
		return HeldFraction() >= 1f;
	}

	public int MaxHoldable()
	{
		return ((Component)GetItem().info).GetComponent<ItemModContainer>().maxStackSize;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class LiquidWeapon : BaseLiquidVessel
{
	[Header("Liquid Weapon")]
	public float FireRate = 0.2f;

	public float MaxRange = 10f;

	public int FireAmountML = 100;

	public int MaxPressure = 100;

	public int PressureLossPerTick = 5;

	public int PressureGainedPerPump = 25;

	public float MinDmgRadius = 0.15f;

	public float MaxDmgRadius = 0.15f;

	public float SplashRadius = 2f;

	public GameObjectRef ImpactSplashEffect;

	public AnimationCurve PowerCurve;

	public List<DamageTypeEntry> Damage;

	public LiquidWeaponEffects EntityWeaponEffects;

	public bool RequiresPumping;

	public bool AutoPump;

	public bool WaitForFillAnim;

	public bool UseFalloffCurve;

	public AnimationCurve FalloffCurve;

	public float PumpingBlockDuration = 0.5f;

	public float StartFillingBlockDuration = 2f;

	public float StopFillingBlockDuration = 1f;

	public float cooldownTime;

	public bool HoldFireInput;

	public int pressure;

	public const string RadiationFightAchievement = "SUMMER_RADICAL";

	public const string SoakedAchievement = "SUMMER_SOAKED";

	public const string LiquidatorAchievement = "SUMMER_LIQUIDATOR";

	public const string NoPressureAchievement = "SUMMER_NO_PRESSURE";

	public float PressureFraction => (float)pressure / (float)MaxPressure;

	public float MinimumPressureFraction => (float)PressureGainedPerPump / (float)MaxPressure;

	public float CurrentRange
	{
		get
		{
			if (!UseFalloffCurve)
			{
				return MaxRange;
			}
			return MaxRange * FalloffCurve.Evaluate((float)(MaxPressure - pressure) / (float)MaxPressure);
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("LiquidWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 1600824953 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - PumpWater "));
				}
				TimeWarning val2 = TimeWarning.New("PumpWater", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1600824953u, "PumpWater", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							PumpWater(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in PumpWater");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3724096303u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartFiring "));
				}
				TimeWarning val2 = TimeWarning.New("StartFiring", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3724096303u, "StartFiring", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							StartFiring(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in StartFiring");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 789289044 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StopFiring "));
				}
				TimeWarning val2 = TimeWarning.New("StopFiring", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(789289044u, "StopFiring", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							StopFiring();
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in StopFiring");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void StartFiring(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (OnCooldown())
		{
			return;
		}
		if (!RequiresPumping)
		{
			pressure = MaxPressure;
		}
		if (CanFire(player))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FireTick);
			((FacepunchBehaviour)this).InvokeRepeating((Action)FireTick, 0f, FireRate);
			SetFlag(Flags.On, b: true);
			StartCooldown(FireRate);
			if (base.isServer)
			{
				SendNetworkUpdateImmediate();
			}
			Interface.CallHook("OnLiquidWeaponFired", (object)this, (object)player);
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StopFiring()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)FireTick);
		if (!RequiresPumping)
		{
			pressure = MaxPressure;
		}
		SetFlag(Flags.On, b: false);
		if (base.isServer)
		{
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnLiquidWeaponFiringStopped", (object)this);
	}

	private bool CanFire(BasePlayer player)
	{
		object obj = Interface.CallHook("CanFireLiquidWeapon", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (RequiresPumping && pressure < PressureLossPerTick)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (HasFlag(Flags.Open))
		{
			return false;
		}
		if (AmountHeld() <= 0)
		{
			return false;
		}
		if (!player.CanInteract())
		{
			return false;
		}
		if (!player.CanAttack() || player.IsRunning())
		{
			return false;
		}
		Item item = GetItem();
		if (item == null || item.contents == null)
		{
			return false;
		}
		return true;
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void PumpWater(RPCMessage msg)
	{
		PumpWater();
	}

	private void PumpWater()
	{
		if (!((Object)(object)GetOwnerPlayer() == (Object)null) && !OnCooldown() && !Firing())
		{
			pressure += PressureGainedPerPump;
			pressure = Mathf.Min(pressure, MaxPressure);
			StartCooldown(PumpingBlockDuration);
			GetOwnerPlayer().SignalBroadcast(Signal.Reload);
			SendNetworkUpdateImmediate();
		}
	}

	private void FireTick()
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!CanFire(ownerPlayer))
		{
			StopFiring();
			return;
		}
		int num = Mathf.Min(FireAmountML, AmountHeld());
		if (num == 0)
		{
			StopFiring();
			return;
		}
		float currentRange = CurrentRange;
		pressure -= PressureLossPerTick;
		if (pressure <= 0)
		{
			StopFiring();
		}
		Ray val = ownerPlayer.eyes.BodyRay();
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(val, ref val2, currentRange, 1218652417))
		{
			DoSplash(ownerPlayer, ((RaycastHit)(ref val2)).point, ((Ray)(ref val)).direction, num);
		}
		LoseWater(num);
		SendNetworkUpdate();
	}

	private void DoSplash(BasePlayer attacker, Vector3 position, Vector3 direction, int amount)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		Item contents = GetContents();
		if (contents != null && contents.amount > 0 && !((Object)(object)contents.info == (Object)null))
		{
			WaterBall.DoSplash(position, SplashRadius, contents.info, amount, funWater: true);
			DamageUtil.RadiusDamage(attacker, LookupPrefab(), position, MinDmgRadius, MaxDmgRadius, Damage, 131072, useLineOfSight: true);
		}
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		StopFiring();
	}

	private void StartCooldown(float duration)
	{
		if (Time.realtimeSinceStartup + duration > cooldownTime)
		{
			cooldownTime = Time.realtimeSinceStartup + duration;
		}
	}

	private bool OnCooldown()
	{
		return Time.realtimeSinceStartup < cooldownTime;
	}

	private bool Firing()
	{
		return HasFlag(Flags.On);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseProjectile = Pool.Get<BaseProjectile>();
		info.msg.baseProjectile.primaryMagazine = Pool.Get<Magazine>();
		info.msg.baseProjectile.primaryMagazine.contents = pressure;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.baseProjectile != null && info.msg.baseProjectile.primaryMagazine != null)
		{
			pressure = info.msg.baseProjectile.primaryMagazine.contents;
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class Locker : StorageContainer
{
	public enum RowType
	{
		Clothing,
		Belt
	}

	public static class LockerFlags
	{
		public const Flags IsEquipping = Flags.Reserved1;
	}

	public GameObjectRef equipSound;

	public const int maxGearSets = 3;

	public const int attireSize = 8;

	public const int beltSize = 6;

	public const int columnSize = 2;

	public const int backpackSlotIndex = 7;

	public const int setSize = 14;

	private static Item[] clothingBuffer = new Item[8];

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Locker.OnRpcMessage", 0);
		try
		{
			if (rpc == 1799659668 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Equip "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Equip", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1799659668u, "RPC_Equip", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Equip(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Equip");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsEquipping()
	{
		return HasFlag(Flags.Reserved1);
	}

	public RowType GetRowType(int slot)
	{
		if (slot == -1)
		{
			return RowType.Clothing;
		}
		if (slot % 14 >= 8)
		{
			return RowType.Belt;
		}
		return RowType.Clothing;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Reserved1, b: false);
	}

	public void ClearEquipping()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanLockerAcceptItem", (object)this, (object)item, (object)targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!base.ItemFilter(item, targetSlot))
		{
			return false;
		}
		bool num = item.IsBackpack();
		bool flag = IsBackpackSlot(targetSlot);
		if (num != flag)
		{
			return false;
		}
		if (isTransferringIndustrialItem && GetRowType(targetSlot) == RowType.Belt && item.info.category == ItemCategory.Attire)
		{
			return false;
		}
		if (item.info.category == ItemCategory.Attire)
		{
			return true;
		}
		return GetRowType(targetSlot) == RowType.Belt;
	}

	public bool IsBackpackSlot(int slot)
	{
		return (slot - 7) % 14 == 0;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Equip(RPCMessage msg)
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		int num = msg.read.Int32();
		if (num < 0 || num >= 3 || Interface.CallHook("OnLockerSwap", (object)this, (object)num, (object)msg.player) != null || IsEquipping())
		{
			return;
		}
		BasePlayer player = msg.player;
		if (player.IsDead())
		{
			return;
		}
		BaseLock @lock = GetLock();
		if ((Object)(object)@lock != (Object)null && !@lock.OnTryToOpen(player))
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
			return;
		}
		int startSlot = num * 14;
		if (SwapPlayerInventoryWithContainer(player, base.inventory, startSlot, GetDropPosition(), GetDropVelocity(), doBelt: true))
		{
			Effect.server.Run(equipSound.resourcePath, player, StringPool.Get("spine3"), Vector3.zero, Vector3.zero);
			SetFlag(Flags.Reserved1, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearEquipping, 1.5f);
		}
	}

	public static bool SwapPlayerInventoryWithContainer(BasePlayer player, ItemContainer inventory, int startSlot, Vector3 dropPosition, Vector3 dropVelocity, bool doBelt, Func<Item, bool> filterItems = null)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		for (int i = 0; i < clothingBuffer.Length; i++)
		{
			Item slot = player.inventory.containerWear.GetSlot(i);
			if (slot != null && (filterItems == null || filterItems(slot)))
			{
				slot.RemoveFromContainer();
				clothingBuffer[i] = slot;
			}
		}
		for (int j = 0; j < 8; j++)
		{
			int num = startSlot + j;
			Item slot2 = inventory.GetSlot(num);
			Item item = clothingBuffer[j];
			if (slot2 != null)
			{
				result = true;
				if (slot2.info.category != ItemCategory.Attire || !slot2.MoveToContainer(player.inventory.containerWear, j))
				{
					slot2.Drop(dropPosition, dropVelocity);
				}
			}
			if (item != null)
			{
				result = true;
				if (!item.MoveToContainer(inventory, num) && !item.MoveToContainer(player.inventory.containerWear, j))
				{
					item.Drop(dropPosition, dropVelocity);
				}
			}
			clothingBuffer[j] = null;
		}
		if (doBelt)
		{
			for (int k = 0; k < 6; k++)
			{
				int num2 = startSlot + k + 8;
				int iTargetPos = k;
				Item slot3 = inventory.GetSlot(num2);
				Item slot4 = player.inventory.containerBelt.GetSlot(k);
				slot4?.RemoveFromContainer();
				if (slot3 != null)
				{
					result = true;
					if (!slot3.MoveToContainer(player.inventory.containerBelt, iTargetPos))
					{
						slot3.Drop(dropPosition, dropVelocity);
					}
				}
				if (slot4 != null)
				{
					result = true;
					if (!slot4.MoveToContainer(inventory, num2))
					{
						slot4.Drop(dropPosition, dropVelocity);
					}
				}
			}
		}
		return result;
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		for (int i = 0; i < inventorySlots; i++)
		{
			RowType rowType = GetRowType(i);
			if (item.info.category == ItemCategory.Attire)
			{
				if (rowType != 0)
				{
					continue;
				}
			}
			else if (rowType != RowType.Belt)
			{
				continue;
			}
			if (!base.inventory.SlotTaken(item, i) && (rowType != 0 || !DoesWearableConflictWithRow(item, i)))
			{
				return i;
			}
		}
		return int.MinValue;
	}

	public bool DoesWearableConflictWithRow(Item item, int pos)
	{
		int num = pos / 14 * 14;
		ItemModWearable itemModWearable = item.info.ItemModWearable;
		if ((Object)(object)itemModWearable == (Object)null)
		{
			return false;
		}
		bool num2 = item.IsBackpack();
		bool flag = IsBackpackSlot(pos);
		if (num2 != flag)
		{
			return true;
		}
		for (int i = num; i < num + 8; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				ItemModWearable itemModWearable2 = slot.info.ItemModWearable;
				if (!((Object)(object)itemModWearable2 == (Object)null) && !itemModWearable2.CanExistWith(itemModWearable))
				{
					return true;
				}
			}
		}
		return false;
	}

	public Vector2i GetIndustrialSlotRange(Vector3 localPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (localPosition.x < -0.3f)
		{
			return new Vector2i(28, 41);
		}
		if (localPosition.x > 0.3f)
		{
			return new Vector2i(0, 13);
		}
		return new Vector2i(14, 27);
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (HasAttachedStorageAdaptor())
		{
			pickupErrorToFormat = (format: PickupErrors.ItemHasAttachment, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}
}


public enum RowType
{
	Clothing,
	Belt
}


public static class LockerFlags
{
	public const Flags IsEquipping = Flags.Reserved1;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class LootableCorpse : BaseCorpse, LootPanel.IHasLootPanel, IInventoryProvider
{
	public string lootPanelName = "generic";

	[NonSerialized]
	public ulong playerSteamID;

	[NonSerialized]
	public string _playerName;

	[NonSerialized]
	public ItemContainer[] containers;

	[NonSerialized]
	private bool firstLooted;

	public virtual string playerName
	{
		get
		{
			return NameHelper.Get(playerSteamID, _playerName, base.isClient);
		}
		set
		{
			_playerName = value;
		}
	}

	public virtual string streamerName { get; set; }

	public Phrase LootPanelTitle => Phrase.op_Implicit(playerName);

	public Phrase LootPanelName => Phrase.op_Implicit("N/A");

	public bool blockBagDrop { get; set; }

	public override int NumberOfItemsToTransfer
	{
		get
		{
			int num = base.NumberOfItemsToTransfer;
			for (int i = 0; i < containers.Length; i++)
			{
				ItemContainer itemContainer = containers[i];
				if (CanLootContainer(itemContainer, i))
				{
					num += itemContainer.itemList.Count;
				}
			}
			return num;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("LootableCorpse.OnRpcMessage", 0);
		try
		{
			if (rpc == 2278459738u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_LootCorpse "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_LootCorpse", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2278459738u, "RPC_LootCorpse", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_LootCorpse(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_LootCorpse");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		firstLooted = false;
		base.ResetState();
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (!blockBagDrop)
		{
			PreDropItems();
			DropItems();
		}
		blockBagDrop = false;
		if (containers != null)
		{
			ItemContainer[] array = containers;
			for (int i = 0; i < array.Length; i++)
			{
				ItemContainer itemContainer = array[i];
				Pool.Free<ItemContainer>(ref itemContainer);
			}
		}
		containers = null;
	}

	public void TakeFrom(BaseEntity fromEntity, params ItemContainer[] source)
	{
		Assert.IsTrue(containers == null, "Initializing Twice");
		TimeWarning val = TimeWarning.New("Corpse.TakeFrom", 0);
		try
		{
			containers = new ItemContainer[source.Length];
			for (int i = 0; i < source.Length; i++)
			{
				containers[i] = SetUpContainerFromSource(source[i]);
			}
			ResetRemovalTime();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		SetupLootableHeadDispenser(fromEntity);
	}

	public void TakeFrom(BaseEntity fromEntity, ItemContainer containerA, ItemContainer containerB, ItemContainer containerC)
	{
		Assert.IsTrue(containers == null, "Initializing Twice");
		TimeWarning val = TimeWarning.New("Corpse.TakeFrom", 0);
		try
		{
			containers = new ItemContainer[3];
			containers[0] = SetUpContainerFromSource(containerA);
			containers[1] = SetUpContainerFromSource(containerB);
			containers[2] = SetUpContainerFromSource(containerC);
			ResetRemovalTime();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		SetupLootableHeadDispenser(fromEntity);
	}

	public void TakeFrom(BaseEntity fromEntity, ItemContainer containerA)
	{
		Assert.IsTrue(containers == null, "Initializing Twice");
		TimeWarning val = TimeWarning.New("Corpse.TakeFrom", 0);
		try
		{
			containers = new ItemContainer[1];
			containers[0] = SetUpContainerFromSource(containerA);
			ResetRemovalTime();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		SetupLootableHeadDispenser(fromEntity);
	}

	private ItemContainer SetUpContainerFromSource(ItemContainer source)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.ServerInitialize(null, source.capacity);
		itemContainer.GiveUID();
		itemContainer.entityOwner = this;
		itemContainer.containerVolume = source.containerVolume;
		Item[] array = source.itemList.ToArray();
		foreach (Item item in array)
		{
			if (!item.MoveToContainer(itemContainer))
			{
				item.DropAndTossUpwards(((Component)this).transform.position);
			}
		}
		return itemContainer;
	}

	private void SetupLootableHeadDispenser(BaseEntity fromEntity)
	{
		HeadDispenser headDispenser = default(HeadDispenser);
		if (((Component)this).gameObject.TryGetComponent<HeadDispenser>(ref headDispenser))
		{
			GameObject val = GameManager.server.FindPrefab(fromEntity.prefabID);
			BasePlayer overrideEntity = default(BasePlayer);
			if ((Object)(object)val != (Object)null && val.TryGetComponent<BasePlayer>(ref overrideEntity))
			{
				headDispenser.overrideEntity = overrideEntity;
			}
		}
	}

	public void CreateEmptyContainer(int capacity)
	{
		Assert.IsTrue(containers == null, "Initializing Twice");
		containers = new ItemContainer[1];
		ItemContainer itemContainer = new ItemContainer();
		itemContainer.ServerInitialize(null, capacity);
		itemContainer.GiveUID();
		itemContainer.entityOwner = this;
		containers[0] = itemContainer;
	}

	public override bool CanRemove()
	{
		return !IsOpen();
	}

	public virtual bool CanLoot()
	{
		return true;
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		if (!firstLooted)
		{
			if (playerSteamID <= 10000000)
			{
				Analytics.Azure.OnFirstLooted(this, baseEntity);
				ItemContainer[] array = containers;
				for (int i = 0; i < array.Length; i++)
				{
					foreach (Item item in array[i].itemList)
					{
						item.SetItemOwnership(baseEntity, ItemOwnershipPhrases.LootedPhrase);
					}
				}
			}
			firstLooted = true;
		}
		return base.OnStartBeingLooted(baseEntity);
	}

	protected virtual bool CanLootContainer(ItemContainer c, int index)
	{
		return true;
	}

	public float GetRadsInCorpse()
	{
		float num = 0f;
		ItemContainer[] array = containers;
		foreach (ItemContainer itemContainer in array)
		{
			num += itemContainer.GetRadioactiveMaterialInContainer();
		}
		return num;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_LootCorpse(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!Object.op_Implicit((Object)(object)player) || !player.CanInteract() || !CanLoot() || containers == null || Interface.CallHook("CanLootEntity", (object)player, (object)this) != null || !player.inventory.loot.StartLootingEntity(this))
		{
			return;
		}
		SetFlag(Flags.Open, b: true);
		for (int i = 0; i < containers.Length; i++)
		{
			ItemContainer itemContainer = containers[i];
			if (CanLootContainer(itemContainer, i))
			{
				player.inventory.loot.AddContainer(itemContainer);
			}
		}
		player.inventory.loot.SendImmediate();
		player.RadioactiveLootCheck(player.inventory.loot.containers);
		ClientRPC(RpcTarget.Player("RPC_ClientLootCorpse", player));
		SendNetworkUpdate();
	}

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", (object)player, (object)this);
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

	protected virtual void PreDropItems()
	{
	}

	public void DropItems()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!Global.disableBagDropping && containers != null)
		{
			DroppedItemContainer droppedItemContainer = ItemContainer.Drop("assets/prefabs/misc/item drop/item_drop_backpack.prefab", ((Component)this).transform.position, Quaternion.identity, containers);
			if ((Object)(object)droppedItemContainer != (Object)null)
			{
				droppedItemContainer.playerName = playerName;
				droppedItemContainer.playerSteamID = playerSteamID;
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.lootableCorpse = Pool.Get<LootableCorpse>();
		info.msg.lootableCorpse.playerName = playerName;
		info.msg.lootableCorpse.playerID = playerSteamID;
		info.msg.lootableCorpse.streamerName = streamerName;
		if (!info.forDisk || containers == null)
		{
			return;
		}
		info.msg.lootableCorpse.privateData = Pool.Get<Private>();
		info.msg.lootableCorpse.privateData.container = Pool.Get<List<ItemContainer>>();
		ItemContainer[] array = containers;
		foreach (ItemContainer itemContainer in array)
		{
			if (itemContainer != null)
			{
				ItemContainer val = itemContainer.Save();
				if (val != null)
				{
					info.msg.lootableCorpse.privateData.container.Add(val);
				}
			}
		}
	}

	public void GetAllInventories(List<ItemContainer> list)
	{
		if (containers != null)
		{
			list.AddRange(containers);
		}
	}

	public override void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 itemFallbackPosition)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < containers.Length; i++)
		{
			ItemContainer itemContainer2 = containers[i];
			if (!CanLootContainer(itemContainer2, i))
			{
				continue;
			}
			for (int j = 0; j < itemContainer2.capacity; j++)
			{
				Item slot = itemContainer2.GetSlot(j);
				if (slot != null && !slot.MoveToContainer(itemContainer))
				{
					slot.DropAndTossUpwards(itemFallbackPosition);
				}
			}
		}
		base.TransferAllItemsToContainer(itemContainer, itemFallbackPosition);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.lootableCorpse == null)
		{
			return;
		}
		playerName = info.msg.lootableCorpse.playerName;
		streamerName = info.msg.lootableCorpse.streamerName;
		playerSteamID = info.msg.lootableCorpse.playerID;
		if (info.fromDisk && info.msg.lootableCorpse.privateData != null && info.msg.lootableCorpse.privateData.container != null)
		{
			int count = info.msg.lootableCorpse.privateData.container.Count;
			Debug.Assert(containers == null, "Double init of containers!");
			containers = new ItemContainer[count];
			for (int i = 0; i < count; i++)
			{
				containers[i] = Pool.Get<ItemContainer>();
				containers[i].ServerInitialize(null, info.msg.lootableCorpse.privateData.container[i].slots);
				containers[i].GiveUID();
				containers[i].entityOwner = this;
				containers[i].Load(info.msg.lootableCorpse.privateData.container[i]);
			}
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class MagnetCrane : GroundVehicle, CarPhysics<MagnetCrane>.ICar
{
	[Header("Magnet Crane")]
	public Animator animator;

	[SerializeField]
	private Transform COM;

	[SerializeField]
	public float arm1Speed = 0.01f;

	[SerializeField]
	public float arm2Speed = 0.01f;

	[SerializeField]
	public float turnYawSpeed = 0.01f;

	[SerializeField]
	public BaseMagnet Magnet;

	[SerializeField]
	private MagnetCraneAudio mcAudio;

	[SerializeField]
	public Rigidbody myRigidbody;

	[SerializeField]
	private Transform[] collisionTestingPoints;

	[SerializeField]
	public float maxDistanceFromOrigin;

	[SerializeField]
	private GameObject sleepingCollider;

	[SerializeField]
	public GameObjectRef selfDamageEffect;

	[SerializeField]
	private GameObjectRef explosionEffect;

	[SerializeField]
	private Transform explosionPoint;

	[SerializeField]
	private CapsuleCollider driverCollision;

	[SerializeField]
	private Transform leftHandTarget;

	[SerializeField]
	private Transform rightHandTarget;

	[SerializeField]
	private Transform leftFootTarget;

	[SerializeField]
	private Transform rightFootTarget;

	[SerializeField]
	public float idleFuelPerSec;

	[SerializeField]
	public float maxFuelPerSec;

	[SerializeField]
	private GameObject[] OnTriggers;

	[SerializeField]
	public TriggerHurtEx magnetDamage;

	[SerializeField]
	public int engineKW = 250;

	[SerializeField]
	private CarWheel[] wheels;

	[SerializeField]
	public CarSettings carSettings;

	[SerializeField]
	private ParticleSystem exhaustInner;

	[SerializeField]
	private ParticleSystem exhaustOuter;

	[SerializeField]
	private EmissionToggle lightToggle;

	public static readonly Phrase ReturnMessage = new Phrase("junkyardcrane.return", "Return to the Junkyard. Excessive damage will occur.");

	private const Flags Flag_ArmMovement = Flags.Reserved7;

	private const Flags Flag_BaseMovementInput = Flags.Reserved10;

	private static int leftTreadParam = Animator.StringToHash("left tread movement");

	private static int rightTreadParam = Animator.StringToHash("right tread movement");

	private static int yawParam = Animator.StringToHash("Yaw");

	private static int arm1Param = Animator.StringToHash("Arm_01");

	private static int arm2Param = Animator.StringToHash("Arm_02");

	public float steerInput;

	public float throttleInput;

	private float brakeInput;

	public float yawInput;

	public float extensionInput;

	public float raiseArmInput;

	public float extensionMove;

	public float yawMove;

	public float raiseArmMove;

	public float nextToggleTime;

	public Vector3 spawnOrigin = Vector3.zero;

	public float lastExtensionArmState;

	public float lastRaiseArmState;

	public float lastYawState;

	public bool handbrakeOn = true;

	public float nextSelfHealTime;

	public Vector3 lastDamagePos = Vector3.zero;

	public float lastDrivenTime;

	public float lastFixedUpdateTime;

	public CarPhysics<MagnetCrane> carPhysics;

	public VehicleTerrainHandler serverTerrainHandler;

	private Vector3 customInertiaTensor = new Vector3(25000f, 11000f, 19000f);

	public float extensionArmState;

	public float raiseArmState;

	public float yawState = 1f;

	public override float DriveWheelVelocity => GetSpeed();

	public VehicleTerrainHandler.Surface OnSurface
	{
		get
		{
			if (serverTerrainHandler == null)
			{
				return VehicleTerrainHandler.Surface.Default;
			}
			return serverTerrainHandler.OnSurface;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MagnetCrane.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float GetThrottleInput()
	{
		if (base.isServer)
		{
			return throttleInput;
		}
		throw new NotImplementedException("We don't know magnet crane throttle input on the client.");
	}

	public override float GetBrakeInput()
	{
		if (base.isServer)
		{
			if (handbrakeOn)
			{
				return 1f;
			}
			return brakeInput;
		}
		throw new NotImplementedException("We don't know magnet crane brake input on the client.");
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.crane != null && base.isServer)
		{
			yawState = info.msg.crane.yaw;
			extensionArmState = info.msg.crane.arm1;
			raiseArmState = info.msg.crane.arm2;
		}
	}

	public override float GetMaxForwardSpeed()
	{
		return 13f;
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		if (!PlayerIsMounted(player))
		{
			return !IsOn();
		}
		return true;
	}

	public override void ServerInit()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateParams, 0f, 0.1f);
		animator.cullingMode = (AnimatorCullingMode)0;
		animator.updateMode = (AnimatorUpdateMode)1;
		myRigidbody.centerOfMass = COM.localPosition;
		carPhysics = new CarPhysics<MagnetCrane>(this, ((Component)this).transform, rigidBody, carSettings);
		serverTerrainHandler = new VehicleTerrainHandler(this);
		Magnet.SetMagnetEnabled(wantsOn: false, null);
		spawnOrigin = ((Component)this).transform.position;
		lastDrivenTime = Time.realtimeSinceStartup;
		GameObject[] onTriggers = OnTriggers;
		for (int i = 0; i < onTriggers.Length; i++)
		{
			onTriggers[i].SetActive(false);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (!IsDriver(player))
		{
			return;
		}
		throttleInput = 0f;
		steerInput = 0f;
		extensionInput = 0f;
		yawInput = 0f;
		raiseArmInput = 0f;
		if (engineController.IsOff)
		{
			if (inputState.IsAnyDown())
			{
				engineController.TryStartEngine(player);
			}
		}
		else if (engineController.IsOn)
		{
			bool num = inputState.IsDown(BUTTON.SPRINT);
			if (inputState.IsDown(BUTTON.RELOAD) && Time.realtimeSinceStartup > nextToggleTime)
			{
				Magnet.SetMagnetEnabled(!Magnet.IsMagnetOn(), player);
				nextToggleTime = Time.realtimeSinceStartup + 0.5f;
			}
			if (num)
			{
				float speed = GetSpeed();
				float num2 = 0f;
				if (inputState.IsDown(BUTTON.FORWARD))
				{
					num2 = 1f;
				}
				else if (inputState.IsDown(BUTTON.BACKWARD))
				{
					num2 = -1f;
				}
				if (speed > 1f && num2 < 0f)
				{
					throttleInput = 0f;
					brakeInput = 0f - num2;
				}
				else if (speed < -1f && num2 > 0f)
				{
					throttleInput = 0f;
					brakeInput = num2;
				}
				else
				{
					throttleInput = num2;
					brakeInput = 0f;
				}
				if (inputState.IsDown(BUTTON.RIGHT))
				{
					steerInput = -1f;
				}
				if (inputState.IsDown(BUTTON.LEFT))
				{
					steerInput = 1f;
				}
			}
			else
			{
				if (inputState.IsDown(BUTTON.LEFT))
				{
					yawInput = 1f;
				}
				else if (inputState.IsDown(BUTTON.RIGHT))
				{
					yawInput = -1f;
				}
				else if (inputState.IsDown(BUTTON.DUCK))
				{
					float @float = animator.GetFloat(yawParam);
					if (@float > 0.01f && @float < 0.99f)
					{
						yawInput = ((@float <= 0.5f) ? (-1f) : 1f);
					}
				}
				if (inputState.IsDown(BUTTON.FORWARD))
				{
					raiseArmInput = 1f;
				}
				else if (inputState.IsDown(BUTTON.BACKWARD))
				{
					raiseArmInput = -1f;
				}
			}
			if (inputState.IsDown(BUTTON.FIRE_PRIMARY))
			{
				extensionInput = 1f;
			}
			if (inputState.IsDown(BUTTON.FIRE_SECONDARY))
			{
				extensionInput = -1f;
			}
		}
		handbrakeOn = throttleInput == 0f && steerInput == 0f;
	}

	public override float AntiHackVelocity()
	{
		return Mathf.Max(GetMaxForwardSpeed() * 1.3f, 30f);
	}

	public float GetSteerInput()
	{
		return steerInput;
	}

	public bool GetSteerSpeedMod(float speed)
	{
		return false;
	}

	public float GetSteerMaxMult(float speed)
	{
		return 1f;
	}

	public override void OnEngineStartFailed()
	{
	}

	public override bool MeetsEngineRequirements()
	{
		return HasDriver();
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_038b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("MagnetCrane.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			rigidBody.ResetInertiaTensor();
			rigidBody.inertiaTensor = Vector3.Lerp(rigidBody.inertiaTensor, customInertiaTensor, 0.5f);
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float num = Mathf.Clamp(realtimeSinceStartup - lastFixedUpdateTime, 0f, 0.5f);
			lastFixedUpdateTime = realtimeSinceStartup;
			float speed = GetSpeed();
			carPhysics.FixedUpdate(Time.fixedDeltaTime, speed);
			if ((Object)(object)sleepingCollider != (Object)null)
			{
				sleepingCollider.SetActive(rigidBody.IsSleeping());
			}
			serverTerrainHandler.FixedUpdate();
			bool flag = IsOn();
			if (IsOn())
			{
				float num2 = Mathf.Max(Mathf.Abs(throttleInput), Mathf.Abs(steerInput));
				float num3 = Mathf.Lerp(idleFuelPerSec, maxFuelPerSec, num2);
				if (!Magnet.HasConnectedObject())
				{
					num3 = Mathf.Min(num3, maxFuelPerSec * 0.75f);
				}
				engineController.TickFuel(num3);
			}
			engineController.CheckEngineState();
			if (IsOn() != flag)
			{
				GameObject[] onTriggers = OnTriggers;
				for (int i = 0; i < onTriggers.Length; i++)
				{
					onTriggers[i].SetActive(IsOn());
				}
			}
			if (Vector3.Dot(((Component)this).transform.up, Vector3.down) >= 0.4f)
			{
				Kill(DestroyMode.Gib);
				return;
			}
			if (realtimeSinceStartup > lastDrivenTime + 14400f)
			{
				Kill(DestroyMode.Gib);
				return;
			}
			if (spawnOrigin != Vector3.zero && maxDistanceFromOrigin != 0f)
			{
				if (Vector3Ex.Distance2D(((Component)this).transform.position, spawnOrigin) > maxDistanceFromOrigin)
				{
					if (Vector3Ex.Distance2D(((Component)this).transform.position, lastDamagePos) > 6f)
					{
						if ((Object)(object)GetDriver() != (Object)null)
						{
							GetDriver().ShowToast(GameTip.Styles.Red_Normal, ReturnMessage, false);
						}
						Hurt(MaxHealth() * 0.15f, DamageType.Generic, this, useProtection: false);
						lastDamagePos = ((Component)this).transform.position;
						nextSelfHealTime = realtimeSinceStartup + 3600f;
						Effect.server.Run(selfDamageEffect.resourcePath, ((Component)this).transform.position + Vector3.up * 2f, Vector3.up);
						return;
					}
				}
				else if (base.healthFraction < 1f && realtimeSinceStartup > nextSelfHealTime && base.SecondsSinceAttacked > 600f)
				{
					Heal(1000f);
				}
			}
			if (!HasDriver() || !IsOn())
			{
				handbrakeOn = true;
				throttleInput = 0f;
				steerInput = 0f;
				SetFlag(Flags.Reserved10, b: false);
				Magnet.SetMagnetEnabled(wantsOn: false, null);
			}
			else
			{
				lastDrivenTime = realtimeSinceStartup;
				if (Magnet.IsMagnetOn() && Magnet.HasConnectedObject() && GamePhysics.CheckOBB(Magnet.GetConnectedOBB(0.75f), 1084293121, (QueryTriggerInteraction)1))
				{
					Magnet.SetMagnetEnabled(wantsOn: false, null);
					nextToggleTime = realtimeSinceStartup + 2f;
					Effect.server.Run(selfDamageEffect.resourcePath, ((Component)Magnet).transform.position, Vector3.up);
				}
			}
			extensionMove = UpdateMoveInput(extensionInput, extensionMove, 3f, Time.fixedDeltaTime);
			yawMove = UpdateMoveInput(yawInput, yawMove, 3f, Time.fixedDeltaTime);
			raiseArmMove = UpdateMoveInput(raiseArmInput, raiseArmMove, 3f, Time.fixedDeltaTime);
			bool flag2 = extensionInput != 0f || raiseArmInput != 0f || yawInput != 0f;
			SetFlag(Flags.Reserved7, flag2);
			magnetDamage.damageEnabled = IsOn() && flag2;
			extensionArmState += extensionInput * arm1Speed * num;
			raiseArmState += raiseArmInput * arm2Speed * num;
			yawState += yawInput * turnYawSpeed * num;
			yawState %= 1f;
			if (yawState < 0f)
			{
				yawState += 1f;
			}
			extensionArmState = Mathf.Clamp(extensionArmState, -1f, 1f);
			raiseArmState = Mathf.Clamp(raiseArmState, -1f, 1f);
			UpdateAnimator(Time.fixedDeltaTime);
			Magnet.MagnetThink(Time.fixedDeltaTime);
			SetFlag(Flags.Reserved10, throttleInput != 0f || steerInput != 0f);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		static float UpdateMoveInput(float input, float move, float slowRate, float dt)
		{
			if (input != 0f)
			{
				return input;
			}
			return Mathf.MoveTowards(move, 0f, dt * slowRate);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.crane = Pool.Get<Crane>();
		info.msg.crane.arm1 = extensionArmState;
		info.msg.crane.arm2 = raiseArmState;
		info.msg.crane.yaw = yawState;
		info.msg.crane.time = GetNetworkTime();
		byte num = (byte)((carPhysics.TankThrottleLeft + 1f) * 7f);
		byte b = (byte)((carPhysics.TankThrottleRight + 1f) * 7f);
		byte treadInput = (byte)(num + (b << 4));
		info.msg.crane.treadInput = treadInput;
	}

	public void UpdateParams()
	{
		SendNetworkUpdate();
	}

	public void LateUpdate()
	{
		if (!base.isClient)
		{
			if (HasDriver() && IsColliding())
			{
				extensionArmState = lastExtensionArmState;
				raiseArmState = lastRaiseArmState;
				yawState = lastYawState;
				extensionInput = 0f - extensionInput;
				yawInput = 0f - yawInput;
				raiseArmInput = 0f - raiseArmInput;
				UpdateAnimator(Time.deltaTime);
			}
			else
			{
				lastExtensionArmState = extensionArmState;
				lastRaiseArmState = raiseArmState;
				lastYawState = yawState;
			}
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			BasePlayer driver = GetDriver();
			if ((Object)(object)driver != (Object)null && info.damageTypes.Has(DamageType.Bullet))
			{
				Capsule val = default(Capsule);
				((Capsule)(ref val))..ctor(((Component)driverCollision).transform.position, driverCollision.radius, driverCollision.height);
				float num = Vector3.Distance(info.PointStart, info.PointEnd);
				Ray val2 = default(Ray);
				((Ray)(ref val2))..ctor(info.PointStart, Vector3Ex.Direction(info.PointEnd, info.PointStart));
				RaycastHit val3 = default(RaycastHit);
				if (((Capsule)(ref val)).Trace(val2, ref val3, 0.05f, num * 1.2f))
				{
					driver.Hurt(info.damageTypes.Total() * 0.15f, DamageType.Bullet, info.Initiator);
				}
			}
		}
		base.OnAttacked(info);
	}

	public override void OnDied(HitInfo info)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (HasDriver())
		{
			GetDriver().Hurt(10000f, DamageType.Blunt, info.Initiator, useProtection: false);
		}
		if (explosionEffect.isValid)
		{
			Effect.server.Run(explosionEffect.resourcePath, explosionPoint.position, Vector3.up);
		}
		base.OnDied(info);
	}

	public bool IsColliding()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		Transform[] array = collisionTestingPoints;
		foreach (Transform val in array)
		{
			if (((Component)val).gameObject.activeSelf)
			{
				Vector3 position = val.position;
				Quaternion rotation = val.rotation;
				if (GamePhysics.CheckOBB(new OBB(position, new Vector3(val.localScale.x, val.localScale.y, val.localScale.z), rotation), 1084293121, (QueryTriggerInteraction)1))
				{
					return true;
				}
			}
		}
		return false;
	}

	public float GetMaxDriveForce()
	{
		return (float)engineKW * 10f;
	}

	public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		float num = MathEx.BiasedLerp(1f - absSpeed / topSpeed, 0.5f);
		num = Mathf.Lerp(num, 1f, Mathf.Abs(steerInput));
		return GetMaxDriveForce() * num;
	}

	public CarWheel[] GetWheels()
	{
		return wheels;
	}

	public float GetWheelsMidPos()
	{
		return 0f;
	}

	public void UpdateAnimator(float dt)
	{
		animator.SetFloat("Arm_01", extensionArmState);
		animator.SetFloat("Arm_02", raiseArmState);
		animator.SetFloat("Yaw", yawState);
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Mailbox : StorageContainer
{
	public string ownerPanel;

	public GameObjectRef mailDropSound;

	public bool autoSubmitWhenClosed;

	public bool shouldMarkAsFull;

	public int InputSlotCount = 1;

	[NonSerialized]
	public ItemContainer InputContainer;

	public int mailInputSlot => 0;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Mailbox.OnRpcMessage", 0);
		try
		{
			if (rpc == 131727457 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Submit "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Submit", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_Submit(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_Submit");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual bool PlayerIsOwner(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseMailbox", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

	public bool IsFull()
	{
		if (shouldMarkAsFull)
		{
			return HasFlag(Flags.Reserved1);
		}
		return false;
	}

	public void MarkFull(bool full)
	{
		SetFlag(Flags.Reserved1, shouldMarkAsFull && full);
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		return base.PlayerOpenLoot(player, PlayerIsOwner(player) ? ownerPanel : panelToOpen);
	}

	public override void AddContainers(PlayerLoot loot)
	{
		if (PlayerIsOwner(loot.GetCastedEntity()))
		{
			loot.AddContainer(base.inventory);
		}
		else
		{
			loot.AddContainer(InputContainer);
		}
	}

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		if (panelName == ownerPanel)
		{
			if (PlayerIsOwner(player))
			{
				return base.CanOpenLootPanel(player, panelName);
			}
			return false;
		}
		if (!HasFreeSpace())
		{
			return !shouldMarkAsFull;
		}
		return true;
	}

	private bool HasFreeSpace()
	{
		if (base.inventory != null)
		{
			return !base.inventory.IsFull();
		}
		return false;
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (autoSubmitWhenClosed)
		{
			SubmitInputItems(player);
		}
		if (IsFull())
		{
			base.inventory.GetSlot(mailInputSlot)?.Drop(GetDropPosition(), GetDropVelocity());
		}
		base.PlayerStoppedLooting(player);
		if (PlayerIsOwner(player))
		{
			SetFlag(Flags.On, b: false);
		}
	}

	[RPC_Server]
	public void RPC_Submit(RPCMessage msg)
	{
		if (!IsFull())
		{
			BasePlayer player = msg.player;
			SubmitInputItems(player);
		}
	}

	public void SubmitInputItems(BasePlayer fromPlayer)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < InputContainer.capacity; i++)
		{
			Item slot = InputContainer.GetSlot(i);
			if (slot != null && Interface.CallHook("OnItemSubmit", (object)slot, (object)this, (object)fromPlayer) == null && slot.MoveToContainer(base.inventory))
			{
				Effect.server.Run(mailDropSound.resourcePath, GetDropPosition());
				if ((Object)(object)fromPlayer != (Object)null && !PlayerIsOwner(fromPlayer))
				{
					SetFlag(Flags.On, b: true);
				}
			}
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		MarkFull(!HasFreeSpace());
		base.OnItemAddedOrRemoved(item, added);
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (allowedItems == null || allowedItems.Length == 0)
		{
			return base.ItemFilter(item, targetSlot);
		}
		ItemDefinition[] array = allowedItems;
		foreach (ItemDefinition itemDefinition in array)
		{
			if ((Object)(object)item.info == (Object)(object)itemDefinition)
			{
				return true;
			}
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		Mailbox val = Pool.Get<Mailbox>();
		val.inventory = InputContainer.Save();
		info.msg.mailbox = val;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer && info.msg.mailbox != null && info.msg.mailbox.inventory != null)
		{
			InputContainer.Load(info.msg.mailbox.inventory);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (InputContainer == null)
		{
			InputContainer = Pool.Get<ItemContainer>();
			InputContainer.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
			InputContainer.SetOnlyAllowedItem(allowedItem);
			InputContainer.entityOwner = this;
			InputContainer.maxStackSize = maxStackSize;
			InputContainer.ServerInitialize(null, InputSlotCount);
			InputContainer.GiveUID();
			InputContainer.onDirty += OnInventoryDirty;
			InputContainer.onItemAddedRemoved = OnItemAddedOrRemoved;
			ItemContainer inputContainer = InputContainer;
			inputContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(inputContainer.canAcceptItem, new Func<Item, int, bool>(ItemFilter));
			OnInventoryFirstCreated(InputContainer);
		}
	}

	public override void GetAllInventories(List<ItemContainer> list)
	{
		base.GetAllInventories(list);
		list.Add(InputContainer);
	}
}


using System;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Mannequin : StorageContainer
{
	public static class MannequinFlags
	{
		public const Flags IsEquipping = Flags.Reserved1;
	}

	[Header("Mannequin Settings")]
	public GameObjectRef EquipSound;

	public GameObjectRef ChangePoseSound;

	public GameObject SupportRoot;

	public Transform MannequinSpawnPoint;

	public BaseCollision HitBoxCollision;

	public PhysicMaterial OverrideHitBoxMaterial;

	[Range(0f, 1f)]
	public float LodRange0 = 0.3f;

	[Range(0f, 1f)]
	public float LodRange1 = 0.15f;

	[Range(0f, 1f)]
	public float LodRange2 = 0.08f;

	[Range(0f, 1f)]
	public float LodRange3 = 0.02f;

	private const int BACKPACK_SLOT_INDEX = 7;

	protected static string headPartPath = "assets/prefabs/clothes/skin/mannequin/head.male.mannequin.prefab";

	protected static string torsoPartPath = "assets/prefabs/clothes/skin/mannequin/torso.male.mannequin.prefab";

	protected static string handsPartPath = "assets/prefabs/clothes/skin/mannequin/hands.male.mannequin.prefab";

	protected static string legsPartPath = "assets/prefabs/clothes/skin/mannequin/legs.male.mannequin.prefab";

	public static HumanBodyBones[] ValidBoneArray;

	public MannequinPose[] AvailablePoses;

	private static Item[] clothingBuffer;

	private static Item[] lockerBuffer;

	private int __sync_PoseIndex;

	[Sync(Autosave = true)]
	public int PoseIndex
	{
		[CompilerGenerated]
		get
		{
			return __sync_PoseIndex;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_PoseIndex, value))
			{
				__sync_PoseIndex = value;
				byte nameID = __GetWeaverID("PoseIndex");
				QueueSyncVar(nameID);
			}
		}
	}

	public TimeSince LastPoseChange { get; set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Mannequin.OnRpcMessage", 0);
		try
		{
			if (rpc == 1116452643 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_ChangePose "));
				}
				TimeWarning val2 = TimeWarning.New("Server_ChangePose", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1116452643u, "Server_ChangePose", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1116452643u, "Server_ChangePose", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_ChangePose(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_ChangePose");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1422897100 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestSwap "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestSwap", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1422897100u, "Server_RequestSwap", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1422897100u, "Server_RequestSwap", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_RequestSwap(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_RequestSwap");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsEquipping()
	{
		return HasFlag(Flags.Reserved1);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	public override void Save(SaveInfo info)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.mannequin = Pool.Get<Mannequin>();
		info.msg.mannequin.clothingItems = Pool.GetList<ClothingItem>();
		foreach (Item item in base.inventory.itemList)
		{
			ClothingItem val = Pool.Get<ClothingItem>();
			val.itemId = item.info.itemid;
			val.skin = item.skin;
			val.uid = item.uid;
			val.reserved_int_0 = item.reserved_int_0;
			info.msg.mannequin.clothingItems.Add(val);
		}
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		SendNetworkUpdate();
	}

	private bool IsBackpackSlot(int slot)
	{
		return (slot - 7) % 14 == 0;
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (!base.ItemFilter(item, targetSlot))
		{
			return false;
		}
		bool num = item.IsBackpack();
		bool flag = IsBackpackSlot(targetSlot);
		if (num != flag)
		{
			return false;
		}
		if ((Object)(object)item.info.ItemModWearable != (Object)null && item.info.ItemModWearable.blockFromMannequin)
		{
			return false;
		}
		return CanAcceptItem(item, targetSlot);
	}

	private bool CanAcceptItem(Item newItem, int slot)
	{
		ItemModWearable itemModWearable = default(ItemModWearable);
		if (!((Component)newItem.info).TryGetComponent<ItemModWearable>(ref itemModWearable))
		{
			return false;
		}
		ItemModWearable wearable = default(ItemModWearable);
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot2 = base.inventory.GetSlot(i);
			if (slot2 != null && ((Component)slot2.info).TryGetComponent<ItemModWearable>(ref wearable) && !itemModWearable.CanExistWith(wearable) && slot != i)
			{
				return false;
			}
		}
		return true;
	}

	public void ClearEquipping()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public override void OnInventoryFirstCreated(ItemContainer container)
	{
		base.OnInventoryFirstCreated(container);
		container.flags = ItemContainer.Flag.Clothing;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	private void Server_ChangePose(RPCMessage msg)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)msg.player == (Object)null) && msg.player.CanBuild(cached: true) && Interface.CallHook("CanMannequinChangePose", (object)this, (object)msg.player) == null)
		{
			int num = PoseIndex + 1;
			if (num >= AvailablePoses.Length)
			{
				num = 0;
			}
			PoseIndex = num;
			if (ChangePoseSound.isValid)
			{
				Effect.server.Run(ChangePoseSound.resourcePath, ((Component)this).transform.position);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	private void Server_RequestSwap(RPCMessage msg)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		if (IsEquipping())
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!CanBeLooted(player) || player.IsDead() || Interface.CallHook("CanMannequinSwap", (object)this, (object)player) != null)
		{
			return;
		}
		BaseLock @lock = GetLock();
		if ((Object)(object)@lock != (Object)null && !@lock.OnTryToOpen(player))
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
		}
		else if (SwapPlayerInventoryWithContainer(msg.player, base.inventory, GetDropPosition(), GetDropVelocity(), FilterItems))
		{
			if (EquipSound != null)
			{
				Effect.server.Run(EquipSound.resourcePath, player, StringPool.Get("spine3"), Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.Reserved1, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearEquipping, 1.5f);
		}
	}

	private bool FilterItems(Item item)
	{
		if ((Object)(object)item.info.ItemModWearable != (Object)null && item.info.ItemModWearable.blockFromMannequin)
		{
			return false;
		}
		return true;
	}

	public static bool SwapPlayerInventoryWithContainer(BasePlayer player, ItemContainer inventory, Vector3 dropPosition, Vector3 dropVelocity, Func<Item, bool> filterItems = null)
	{
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		for (int i = 0; i < clothingBuffer.Length; i++)
		{
			Item slot = player.inventory.containerWear.GetSlot(i);
			if (slot != null && (filterItems == null || filterItems(slot)))
			{
				slot.RemoveFromContainer();
				clothingBuffer[i] = slot;
			}
		}
		for (int j = 0; j < lockerBuffer.Length; j++)
		{
			Item slot2 = inventory.GetSlot(j);
			if (slot2 != null && (filterItems == null || filterItems(slot2)))
			{
				slot2.RemoveFromContainer();
				lockerBuffer[j] = slot2;
			}
		}
		for (int k = 0; k < clothingBuffer.Length; k++)
		{
			Item item = lockerBuffer[k];
			Item item2 = clothingBuffer[k];
			if (item != null)
			{
				result = true;
				if (item.info.category != ItemCategory.Attire || !item.MoveToContainer(player.inventory.containerWear, k))
				{
					item.Drop(dropPosition, dropVelocity);
				}
			}
			if (item2 != null)
			{
				result = true;
				if (!item2.MoveToContainer(inventory, k) && !item2.MoveToContainer(player.inventory.containerWear, k) && !item2.MoveToContainer(player.inventory.containerMain))
				{
					item2.Drop(dropPosition, dropVelocity);
				}
			}
			clothingBuffer[k] = null;
			lockerBuffer[k] = null;
		}
		return result;
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (id == 0)
		{
			if (Global.developer > 2)
			{
				NetworkableId iD = net.ID;
				Debug.Log((object)("SyncVar Writing: PoseIndex for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_PoseIndex);
			return true;
		}
		return base.WriteSyncVar(id, writer);
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		if (id == 0)
		{
			try
			{
				_ = __sync_PoseIndex;
				int _sync_PoseIndex = reader.Int32();
				__sync_PoseIndex = _sync_PoseIndex;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			return true;
		}
		return base.OnSyncVar(id, reader, fromAutoSave);
	}

	private byte __GetWeaverID(string propertyName)
	{
		if (propertyName == "PoseIndex")
		{
			return 0;
		}
		return byte.MaxValue;
	}

	protected override void WriteAutoSaveSyncVars(NetWrite writer)
	{
		base.WriteAutoSaveSyncVars(writer);
		WriteSyncVar(0, writer);
	}

	protected override void ReadAutoSaveSyncVars(NetRead reader)
	{
		base.ReadAutoSaveSyncVars(reader);
		OnSyncVar(0, reader, fromAutoSave: true);
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		base.AutoSaveSyncVars(save);
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteAutoSaveSyncVars(val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		base.AutoLoadSyncVars(load);
		if (load.msg.baseEntity != null && load.msg.baseEntity.syncVars != null)
		{
			NetRead val = Pool.Get<NetRead>();
			val.Init(load.msg.baseEntity.syncVars.AsSpan());
			ReadAutoSaveSyncVars(val);
			Pool.Free<NetRead>(ref val);
		}
		return true;
	}

	protected override void ResetSyncVars()
	{
		base.ResetSyncVars();
		__sync_PoseIndex = 0;
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		if (id == 0)
		{
			return true;
		}
		return base.ShouldInvalidateCache(id);
	}

	static Mannequin()
	{
		HumanBodyBones[] array = new HumanBodyBones[49];
		RuntimeHelpers.InitializeArray(array, (RuntimeFieldHandle)/*OpCode not supported: LdMemberToken*/);
		ValidBoneArray = (HumanBodyBones[])(object)array;
		clothingBuffer = new Item[8];
		lockerBuffer = new Item[8];
	}
}


public static class MannequinFlags
{
	public const Flags IsEquipping = Flags.Reserved1;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class MapEntity : HeldEntity
{
	[NonSerialized]
	public uint[] fogImages = new uint[1];

	[NonSerialized]
	public uint[] paintImages = new uint[144];

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MapEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 1443560440 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ImageUpdate "));
				}
				TimeWarning val2 = TimeWarning.New("ImageUpdate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1443560440u, "ImageUpdate", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1443560440u, "ImageUpdate", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ImageUpdate(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ImageUpdate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.mapEntity != null)
		{
			if (info.msg.mapEntity.fogImages.Count == fogImages.Length)
			{
				fogImages = info.msg.mapEntity.fogImages.ToArray();
			}
			if (info.msg.mapEntity.paintImages.Count == paintImages.Length)
			{
				paintImages = info.msg.mapEntity.paintImages.ToArray();
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.mapEntity = Pool.Get<MapEntity>();
		info.msg.mapEntity.fogImages = Pool.Get<List<uint>>();
		info.msg.mapEntity.fogImages.AddRange(fogImages);
		info.msg.mapEntity.paintImages = Pool.Get<List<uint>>();
		info.msg.mapEntity.paintImages.AddRange(paintImages);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	public void ImageUpdate(RPCMessage msg)
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null)
		{
			return;
		}
		byte b = msg.read.UInt8();
		byte b2 = msg.read.UInt8();
		uint num = msg.read.UInt32();
		if ((b == 0 && fogImages[b2] == num) || (b == 1 && paintImages[b2] == num))
		{
			return;
		}
		uint num2 = (uint)(b * 1000 + b2);
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (array != null)
		{
			FileStorage.server.RemoveEntityNum(net.ID, num2);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);
			if (b == 0)
			{
				fogImages[b2] = num3;
			}
			if (b == 1)
			{
				paintImages[b2] = num3;
			}
			InvalidateNetworkCache();
			Interface.CallHook("OnMapImageUpdated");
		}
	}
}


using System;
using Network;
using ProtoBuf;
using UnityEngine;

public class MapMarkerGenericRadius : MapMarker
{
	public float radius;

	public Color color1;

	public Color color2;

	public float alpha;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MapMarkerGenericRadius.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void SendUpdate(bool fullUpdate = true)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		float a = color1.a;
		Vector3 arg = default(Vector3);
		((Vector3)(ref arg))..ctor(color1.r, color1.g, color1.b);
		Vector3 arg2 = default(Vector3);
		((Vector3)(ref arg2))..ctor(color2.r, color2.g, color2.b);
		ClientRPC(RpcTarget.NetworkGroup("MarkerUpdate"), arg, a, arg2, alpha, radius);
	}

	public override AppMarker GetAppMarkerData()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		AppMarker appMarkerData = base.GetAppMarkerData();
		appMarkerData.radius = radius;
		appMarkerData.color1 = Color.op_Implicit(color1);
		appMarkerData.color2 = Color.op_Implicit(color2);
		appMarkerData.alpha = alpha;
		return appMarkerData;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.UI;
using UnityEngine;
using UnityEngine.Assertions;

public class MarketTerminal : StorageContainer
{
	public const Flags Flag_HasItems = Flags.Reserved1;

	public const Flags Flag_InventoryFull = Flags.Reserved2;

	[Header("Market Terminal")]
	public GameObjectRef menuPrefab;

	public ulong lockToCustomerDuration = 300uL;

	public ulong orderTimeout = 180uL;

	public ItemDefinition deliveryFeeCurrency;

	public int deliveryFeeAmount;

	public DeliveryDroneConfig config;

	public RustText userLabel;

	private ulong _customerSteamId;

	private string _customerName;

	private TimeUntil _timeUntilCustomerExpiry;

	private EntityRef<Marketplace> _marketplace;

	public List<PendingOrder> pendingOrders;

	private static readonly Phrase _cantFitPhrase = new Phrase("marketterminal.cantfit", "This drone marketplace is full. Can't process sale.");

	public Action<BasePlayer, Item> _onCurrencyRemovedCached;

	public Action<BasePlayer, Item> _onItemPurchasedCached;

	private Action _checkForExpiredOrdersCached;

	private bool _transactionActive;

	private static readonly List<NetworkableId> _deliveryEligible = new List<NetworkableId>(128);

	private static RealTimeSince _deliveryEligibleLastCalculated;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MarketTerminal.OnRpcMessage", 0);
		try
		{
			if (rpc == 3793918752u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_Purchase "));
				}
				TimeWarning val2 = TimeWarning.New("Server_Purchase", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3793918752u, "Server_Purchase", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3793918752u, "Server_Purchase", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_Purchase(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_Purchase");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1382511247 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_TryOpenMarket "));
				}
				TimeWarning val2 = TimeWarning.New("Server_TryOpenMarket", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1382511247u, "Server_TryOpenMarket", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1382511247u, "Server_TryOpenMarket", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_TryOpenMarket(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_TryOpenMarket");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool CanPlayerAffordOrderAndDeliveryFee(BasePlayer player, SellOrder sellOrder, int numberOfTransactions)
	{
		PooledList<Item> val = Pool.Get<PooledList<Item>>();
		try
		{
			player.inventory.FindItemsByItemID((List<Item>)(object)val, deliveryFeeCurrency.itemid);
			int num = ((IEnumerable<Item>)val).Sum((Item i) => i.amount);
			int num2 = deliveryFeeAmount;
			if (num < num2)
			{
				return false;
			}
			if (sellOrder != null)
			{
				int num3 = VendingMachine.GetTotalPriceForOrder(sellOrder) * numberOfTransactions;
				if (sellOrder.currencyID == deliveryFeeCurrency.itemid && !sellOrder.currencyIsBP && num < num2 + num3)
				{
					return false;
				}
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool HasPendingOrderFor(NetworkableId vendingMachineId)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		List<PendingOrder> list = pendingOrders;
		return ((list != null) ? List.FindWith<PendingOrder, NetworkableId>((IReadOnlyCollection<PendingOrder>)list, (Func<PendingOrder, NetworkableId>)((PendingOrder o) => o.vendingMachineId), vendingMachineId, (IEqualityComparer<NetworkableId>)null) : null) != null;
	}

	public bool CanPlayerInteract(BasePlayer player)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (_customerSteamId == 0L || TimeUntil.op_Implicit(_timeUntilCustomerExpiry) <= 0f)
		{
			return true;
		}
		return (ulong)player.userID == _customerSteamId;
	}

	public override void Load(LoadInfo info)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.marketTerminal == null)
		{
			return;
		}
		_customerSteamId = info.msg.marketTerminal.customerSteamId;
		_customerName = info.msg.marketTerminal.customerName;
		_timeUntilCustomerExpiry = info.msg.marketTerminal.timeUntilExpiry;
		_marketplace = new EntityRef<Marketplace>(info.msg.marketTerminal.marketplaceId);
		if (info.msg.marketTerminal.deliveryFeeCurrency != 0)
		{
			deliveryFeeCurrency = ItemManager.FindItemDefinition(info.msg.marketTerminal.deliveryFeeCurrency);
		}
		if (info.msg.marketTerminal.deliveryFeeAmount != 0)
		{
			deliveryFeeAmount = info.msg.marketTerminal.deliveryFeeAmount;
		}
		if (pendingOrders == null)
		{
			pendingOrders = Pool.Get<List<PendingOrder>>();
		}
		if (pendingOrders.Count > 0)
		{
			foreach (PendingOrder pendingOrder in pendingOrders)
			{
				PendingOrder current = pendingOrder;
				Pool.Free<PendingOrder>(ref current);
			}
			pendingOrders.Clear();
		}
		foreach (PendingOrder order in info.msg.marketTerminal.orders)
		{
			PendingOrder item = order.Copy();
			pendingOrders.Add(item);
		}
	}

	public void Setup(Marketplace marketplace)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		_marketplace = new EntityRef<Marketplace>(marketplace.net.ID);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		_onCurrencyRemovedCached = OnCurrencyRemoved;
		_onItemPurchasedCached = OnItemPurchased;
		_checkForExpiredOrdersCached = CheckForExpiredOrders;
	}

	private void RegisterOrder(BasePlayer player, VendingMachine vendingMachine)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (pendingOrders == null)
		{
			pendingOrders = Pool.Get<List<PendingOrder>>();
		}
		if (HasPendingOrderFor(vendingMachine.net.ID))
		{
			return;
		}
		if (!_marketplace.TryGet(serverside: true, out var entity))
		{
			Debug.LogError((object)"Marketplace is not set", (Object)(object)this);
			return;
		}
		NetworkableId droneId = entity.SendDrone(player, this, vendingMachine);
		if (!((NetworkableId)(ref droneId)).IsValid)
		{
			Debug.LogError((object)"Failed to spawn delivery drone");
			return;
		}
		PendingOrder val = Pool.Get<PendingOrder>();
		val.vendingMachineId = vendingMachine.net.ID;
		val.timeUntilExpiry = TimeUntil.op_Implicit((float)orderTimeout);
		val.droneId = droneId;
		pendingOrders.Add(val);
		CheckForExpiredOrders();
		UpdateHasItems(sendNetworkUpdate: false);
		SendNetworkUpdateImmediate();
	}

	public void CompleteOrder(NetworkableId vendingMachineId)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (pendingOrders != null)
		{
			int num = List.FindIndexWith<PendingOrder, NetworkableId>((IReadOnlyList<PendingOrder>)pendingOrders, (Func<PendingOrder, NetworkableId>)((PendingOrder o) => o.vendingMachineId), vendingMachineId, (IEqualityComparer<NetworkableId>)null);
			if (num < 0)
			{
				Debug.LogError((object)"Completed market order that doesn't exist?");
				return;
			}
			pendingOrders[num].Dispose();
			pendingOrders.RemoveAt(num);
			CheckForExpiredOrders();
			UpdateHasItems(sendNetworkUpdate: false);
			SendNetworkUpdateImmediate();
		}
	}

	private void CheckForExpiredOrders()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		if (pendingOrders != null && pendingOrders.Count > 0)
		{
			bool flag = false;
			float? num = null;
			for (int i = 0; i < pendingOrders.Count; i++)
			{
				PendingOrder val = pendingOrders[i];
				if (TimeUntil.op_Implicit(val.timeUntilExpiry) <= 0f)
				{
					if (new EntityRef<DeliveryDrone>(val.droneId).TryGet(serverside: true, out var entity))
					{
						Debug.LogError((object)"Delivery timed out waiting for drone (too slow speed?)", (Object)(object)this);
						entity.Kill();
					}
					else
					{
						Debug.LogError((object)"Delivery timed out waiting for drone, and the drone seems to have been destroyed?", (Object)(object)this);
					}
					pendingOrders.RemoveAt(i);
					i--;
					flag = true;
				}
				else if (!num.HasValue || TimeUntil.op_Implicit(val.timeUntilExpiry) < num.Value)
				{
					num = TimeUntil.op_Implicit(val.timeUntilExpiry);
				}
			}
			if (flag)
			{
				UpdateHasItems(sendNetworkUpdate: false);
				SendNetworkUpdate();
			}
			if (num.HasValue)
			{
				((FacepunchBehaviour)this).Invoke(_checkForExpiredOrdersCached, num.Value);
			}
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke(_checkForExpiredOrdersCached);
		}
	}

	private void RestrictToPlayer(BasePlayer player)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (_customerSteamId == (ulong)player.userID)
		{
			_timeUntilCustomerExpiry = TimeUntil.op_Implicit((float)lockToCustomerDuration);
			SendNetworkUpdate();
			return;
		}
		if (_customerSteamId != 0L)
		{
			Debug.LogError((object)"Overwriting player restriction! It should be cleared first.", (Object)(object)this);
		}
		_customerSteamId = player.userID;
		_customerName = player.displayName;
		_timeUntilCustomerExpiry = TimeUntil.op_Implicit((float)lockToCustomerDuration);
		SendNetworkUpdateImmediate();
		ClientRPC(RpcTarget.NetworkGroup("Client_CloseMarketUI"), _customerSteamId);
		RemoveAnyLooters();
		if (IsOpen())
		{
			Debug.LogError((object)"Market terminal's inventory is still open after removing looters!", (Object)(object)this);
		}
	}

	private void ClearRestriction()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (_customerSteamId != 0L)
		{
			_customerSteamId = 0uL;
			_customerName = null;
			_timeUntilCustomerExpiry = TimeUntil.op_Implicit(0f);
			SendNetworkUpdateImmediate();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	public void Server_TryOpenMarket(RPCMessage msg)
	{
		if (!CanPlayerInteract(msg.player))
		{
			return;
		}
		if (!_marketplace.IsValid(serverside: true))
		{
			Debug.LogError((object)"Marketplace is not set", (Object)(object)this);
			return;
		}
		EntityIdList val = Pool.Get<EntityIdList>();
		try
		{
			val.entityIds = Pool.Get<List<NetworkableId>>();
			GetDeliveryEligibleVendingMachines(val.entityIds);
			ClientRPC(RpcTarget.Player("Client_OpenMarket", msg.player), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(10uL)]
	public void Server_Purchase(RPCMessage msg)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		if (!CanPlayerInteract(msg.player))
		{
			return;
		}
		if (!_marketplace.IsValid(serverside: true))
		{
			Debug.LogError((object)"Marketplace is not set", (Object)(object)this);
			return;
		}
		NetworkableId val = msg.read.EntityID();
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		VendingMachine vendingMachine = BaseNetworkable.serverEntities.Find(val) as VendingMachine;
		if ((Object)(object)vendingMachine == (Object)null || !vendingMachine.IsValid() || num < 0 || num >= vendingMachine.sellOrders.sellOrders.Count || num2 <= 0 || base.inventory.IsFull())
		{
			return;
		}
		GetDeliveryEligibleVendingMachines(null);
		if (_deliveryEligible == null || !_deliveryEligible.Contains(val))
		{
			return;
		}
		try
		{
			_transactionActive = true;
			int num3 = deliveryFeeAmount;
			SellOrder sellOrder = vendingMachine.sellOrders.sellOrders[num];
			if (!CanPlayerAffordOrderAndDeliveryFee(msg.player, sellOrder, num2))
			{
				return;
			}
			int num4 = msg.player.inventory.Take(null, deliveryFeeCurrency.itemid, num3);
			if (num4 != num3)
			{
				Debug.LogError((object)$"Took an incorrect number of items for the delivery fee (took {num4}, should have taken {num3})");
			}
			ClientRPC(RpcTarget.Player("Client_ShowItemNotice", msg.player), deliveryFeeCurrency.itemid, -num3, arg3: false);
			int? slotsRequiredForTransaction = vendingMachine.GetSlotsRequiredForTransaction(num, num2);
			if (slotsRequiredForTransaction.HasValue && !CheckItem.CanFitSimple(base.inventory, slotsRequiredForTransaction.Value))
			{
				msg.player.ShowToast(GameTip.Styles.Red_Normal, _cantFitPhrase, true);
			}
			else if (!vendingMachine.DoTransaction(msg.player, num, num2, base.inventory, _onCurrencyRemovedCached, _onItemPurchasedCached, this))
			{
				Item item = ItemManager.CreateByItemID(deliveryFeeCurrency.itemid, num3, 0uL);
				if (!msg.player.inventory.GiveItem(item))
				{
					item.Drop(msg.player.inventory.containerMain.dropPosition, msg.player.inventory.containerMain.dropVelocity);
				}
			}
			else
			{
				RestrictToPlayer(msg.player);
				RegisterOrder(msg.player, vendingMachine);
			}
		}
		finally
		{
			_transactionActive = false;
		}
	}

	private void UpdateHasItems(bool sendNetworkUpdate = true)
	{
		if (!Application.isLoadingSave)
		{
			bool flag = base.inventory.itemList.Count > 0;
			bool flag2 = pendingOrders != null && pendingOrders.Count != 0;
			SetFlag(Flags.Reserved1, flag && !flag2, recursive: false, sendNetworkUpdate);
			SetFlag(Flags.Reserved2, base.inventory.IsFull(), recursive: false, sendNetworkUpdate);
			if (!flag && !flag2)
			{
				ClearRestriction();
			}
		}
	}

	private void OnCurrencyRemoved(BasePlayer player, Item currencyItem)
	{
		if ((Object)(object)player != (Object)null && currencyItem != null)
		{
			ClientRPC(RpcTarget.Player("Client_ShowItemNotice", player), currencyItem.info.itemid, -currencyItem.amount, arg3: false);
		}
	}

	private void OnItemPurchased(BasePlayer player, Item purchasedItem)
	{
		if ((Object)(object)player != (Object)null && purchasedItem != null)
		{
			ClientRPC(RpcTarget.Player("Client_ShowItemNotice", player), purchasedItem.info.itemid, purchasedItem.amount, arg3: true);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.marketTerminal = Pool.Get<MarketTerminal>();
		info.msg.marketTerminal.customerSteamId = _customerSteamId;
		info.msg.marketTerminal.customerName = _customerName;
		info.msg.marketTerminal.timeUntilExpiry = _timeUntilCustomerExpiry;
		info.msg.marketTerminal.marketplaceId = _marketplace.uid;
		if (!info.forDisk)
		{
			info.msg.marketTerminal.deliveryFeeAmount = deliveryFeeAmount;
			info.msg.marketTerminal.deliveryFeeCurrency = deliveryFeeCurrency?.itemid ?? 0;
		}
		info.msg.marketTerminal.orders = Pool.Get<List<PendingOrder>>();
		if (pendingOrders == null)
		{
			return;
		}
		foreach (PendingOrder pendingOrder in pendingOrders)
		{
			PendingOrder item = pendingOrder.Copy();
			info.msg.marketTerminal.orders.Add(item);
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (_transactionActive)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (item.parent == base.inventory)
		{
			return true;
		}
		return false;
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		UpdateHasItems();
	}

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		if (CanPlayerInteract(player) && HasFlag(Flags.Reserved1))
		{
			return base.CanOpenLootPanel(player, panelName);
		}
		return false;
	}

	private void RemoveAnyLooters()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		ItemContainer item = base.inventory;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && !((Object)(object)current.inventory == (Object)null) && !((Object)(object)current.inventory.loot == (Object)null) && current.inventory.loot.containers.Contains(item))
				{
					current.inventory.loot.Clear();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public void GetDeliveryEligibleVendingMachines(List<NetworkableId> vendingMachineIds)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		if (RealTimeSince.op_Implicit(_deliveryEligibleLastCalculated) < 5f)
		{
			if (vendingMachineIds == null)
			{
				return;
			}
			{
				foreach (NetworkableId item in _deliveryEligible)
				{
					vendingMachineIds.Add(item);
				}
				return;
			}
		}
		_deliveryEligibleLastCalculated = RealTimeSince.op_Implicit(0f);
		_deliveryEligible.Clear();
		foreach (MapMarker serverMapMarker in MapMarker.serverMapMarkers)
		{
			if (serverMapMarker is VendingMachineMapMarker vendingMachineMapMarker && !((Object)(object)vendingMachineMapMarker.server_vendingMachine == (Object)null))
			{
				VendingMachine server_vendingMachine = vendingMachineMapMarker.server_vendingMachine;
				if (!((Object)(object)server_vendingMachine == (Object)null) && (IsEligible(server_vendingMachine, config.vendingMachineOffset, 1) || IsEligible(server_vendingMachine, config.vendingMachineOffset + Vector3.forward * config.maxDistanceFromVendingMachine, 2)))
				{
					_deliveryEligible.Add(server_vendingMachine.net.ID);
				}
			}
		}
		if (vendingMachineIds == null)
		{
			return;
		}
		foreach (NetworkableId item2 in _deliveryEligible)
		{
			vendingMachineIds.Add(item2);
		}
		bool IsEligible(VendingMachine vendingMachine, Vector3 offset, int n)
		{
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			object obj = Interface.CallHook("CanAccessVendingMachine", (object)config, (object)vendingMachine);
			if (obj is bool)
			{
				return (bool)obj;
			}
			if (vendingMachine.IsInDeepSeaCached)
			{
				return false;
			}
			if (vendingMachine is NPCVendingMachine)
			{
				return true;
			}
			if (!vendingMachine.IsBroadcasting())
			{
				return false;
			}
			if (!config.IsVendingMachineAccessible(vendingMachine, offset, out var _))
			{
				return false;
			}
			return true;
		}
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class MedicalTool : AttackEntity
{
	public float healDurationSelf = 4f;

	public float healDurationOther = 4f;

	public float healDurationOtherWounded = 7f;

	public float maxDistanceOther = 2f;

	public bool canUseOnOther = true;

	public bool canRevive = true;

	public static readonly int USE_SELF_ANIMATOR_HASH = Animator.StringToHash("use_self");

	public static readonly int USE_OTHER_ANIMATOR_HASH = Animator.StringToHash("use_other");

	public static readonly int USE_OTHER_WOUNDED_ANIMATOR_HASH = Animator.StringToHash("use_other_wounded");

	private const float SERVER_VALID_OTHER_DISTANCE = 4f;

	private const float SERVER_VALID_OTHER_DISTANCE_SQR = 16f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MedicalTool.OnRpcMessage", 0);
		try
		{
			if (rpc == 789049461 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UseOther "));
				}
				TimeWarning val2 = TimeWarning.New("UseOther", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(789049461u, "UseOther", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							UseOther(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in UseOther");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2918424470u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UseSelf "));
				}
				TimeWarning val2 = TimeWarning.New("UseSelf", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(2918424470u, "UseSelf", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							UseSelf(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UseSelf");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void UseOther(RPCMessage msg)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		BaseEntity entity;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else if (player.CanInteract() && HasItemAmount() && canUseOnOther && BaseNetworkable.serverEntities.TryGetEntity(msg.read.EntityID(), out entity) && entity is IMedicalToolTarget medicalToolTarget && Vector3.SqrMagnitude(((Component)entity).transform.position - ((Component)player).transform.position) < 16f && medicalToolTarget.IsValidMedicalToolItem(GetOwnerItemDefinition()))
		{
			ClientRPC(RpcTarget.Player("Reset", player));
			GiveEffectsTo(player, medicalToolTarget);
			UseItemAmount(1);
			StartAttackCooldown(repeatDelay);
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void UseSelf(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else if (player.CanInteract() && HasItemAmount() && ((IMedicalToolTarget)player).IsValidMedicalToolItem(GetOwnerItemDefinition()))
		{
			ClientRPC(RpcTarget.Player("Reset", player));
			GiveEffectsTo(player, player);
			UseItemAmount(1);
			StartAttackCooldown(repeatDelay);
		}
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		if (base.isClient)
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!((Object)(object)ownerPlayer == (Object)null) && ownerPlayer.CanInteract() && HasItemAmount() && ((IMedicalToolTarget)ownerPlayer).IsValidMedicalToolItem(GetOwnerItemDefinition()))
		{
			GiveEffectsTo(ownerPlayer, ownerPlayer);
			UseItemAmount(1);
			StartAttackCooldown(repeatDelay);
			SignalBroadcast(Signal.Attack, string.Empty);
			if (ownerPlayer.IsNpc)
			{
				ownerPlayer.SignalBroadcast(Signal.Attack);
			}
		}
	}

	private void GiveEffectsTo(BasePlayer fromPlayer, IMedicalToolTarget toTarget)
	{
		if ((Object)(object)fromPlayer == (Object)null || (Object)(object)toTarget.GetEntity() == (Object)null)
		{
			return;
		}
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		if (!((Object)(object)ownerItemDefinition == (Object)null))
		{
			ItemModConsumable component = ((Component)ownerItemDefinition).GetComponent<ItemModConsumable>();
			if ((Object)(object)component == (Object)null)
			{
				Debug.LogWarning((object)("No consumable for medicaltool: " + ((Object)this).name));
			}
			else if (Interface.CallHook("OnHealingItemUse", (object)this, (object)fromPlayer, (object)toTarget) == null)
			{
				Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, fromPlayer, toTarget.GetEntity());
				toTarget.OnMedicalToolApplied(fromPlayer, ownerItemDefinition, component, this, canRevive);
			}
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class Megaphone : HeldEntity
{
	[Header("Megaphone")]
	public VoiceProcessor voiceProcessor;

	public float VoiceDamageMinFrequency = 2f;

	public float VoiceDamageAmount = 1f;

	public AudioSource VoiceSource;

	public SoundDefinition StartBroadcastingSfx;

	public SoundDefinition StopBroadcastingSfx;

	[ReplicatedVar(Default = "100")]
	public static float MegaphoneVoiceRange { get; set; } = 100f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Megaphone.OnRpcMessage", 0);
		try
		{
			if (rpc == 4196056309u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_ToggleBroadcasting "));
				}
				TimeWarning val2 = TimeWarning.New("Server_ToggleBroadcasting", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(4196056309u, "Server_ToggleBroadcasting", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_ToggleBroadcasting(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_ToggleBroadcasting");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void UpdateItemCondition()
	{
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null && ownerItem.hasCondition)
		{
			ownerItem.LoseCondition(VoiceDamageAmount);
		}
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void Server_ToggleBroadcasting(RPCMessage msg)
	{
		bool flag = msg.read.Int8() == 1;
		SetFlag(Flags.On, flag);
		if (flag)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)UpdateItemCondition))
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateItemCondition, 0f, VoiceDamageMinFrequency);
			}
		}
		else if (((FacepunchBehaviour)this).IsInvoking((Action)UpdateItemCondition))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateItemCondition);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Audio;

public class MicrophoneStand : BaseMountable
{
	public enum SpeechMode
	{
		Normal,
		HighPitch,
		LowPitch
	}

	public VoiceProcessor VoiceProcessor;

	public AudioSource VoiceSource;

	private SpeechMode currentSpeechMode;

	public AudioMixerGroup NormalMix;

	public AudioMixerGroup HighPitchMix;

	public AudioMixerGroup LowPitchMix;

	public Phrase NormalPhrase = new Phrase("microphone_normal", "Normal");

	public Phrase NormalDescPhrase = new Phrase("microphone_normal_desc", "No voice effect");

	public Phrase HighPitchPhrase = new Phrase("microphone_high", "High Pitch");

	public Phrase HighPitchDescPhrase = new Phrase("microphone_high_desc", "High pitch voice");

	public Phrase LowPitchPhrase = new Phrase("microphone_low", "Low");

	public Phrase LowPitchDescPhrase = new Phrase("microphone_low_desc", "Low pitch voice");

	public GameObjectRef IOSubEntity;

	public Transform IOSubEntitySpawnPos;

	public bool IsStatic;

	public EntityRef<IOEntity> ioEntity;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MicrophoneStand.OnRpcMessage", 0);
		try
		{
			if (rpc == 1420522459 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetMode "));
				}
				TimeWarning val2 = TimeWarning.New("SetMode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage mode = rPCMessage;
						SetMode(mode);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in SetMode");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	public void SetMode(RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)GetMounted()))
		{
			SpeechMode speechMode = (SpeechMode)msg.read.Int32();
			if (speechMode != currentSpeechMode)
			{
				currentSpeechMode = speechMode;
				SendNetworkUpdate();
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.microphoneStand == null)
		{
			info.msg.microphoneStand = Pool.Get<MicrophoneStand>();
		}
		info.msg.microphoneStand.microphoneMode = (int)currentSpeechMode;
		info.msg.microphoneStand.IORef = ioEntity.uid;
	}

	public void SpawnChildEntity()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		MicrophoneStandIOEntity microphoneStandIOEntity = GameManager.server.CreateEntity(IOSubEntity.resourcePath, IOSubEntitySpawnPos.localPosition, IOSubEntitySpawnPos.localRotation) as MicrophoneStandIOEntity;
		microphoneStandIOEntity.enableSaving = enableSaving;
		microphoneStandIOEntity.SetParent(this);
		microphoneStandIOEntity.Spawn();
		ioEntity.Set(microphoneStandIOEntity);
		SendNetworkUpdate();
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		SpawnChildEntity();
	}

	public override void PostMapEntitySpawn()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		base.PostMapEntitySpawn();
		if (!IsStatic)
		{
			return;
		}
		SpawnChildEntity();
		int num = 128;
		List<ConnectedSpeaker> list = Pool.Get<List<ConnectedSpeaker>>();
		GamePhysics.OverlapSphere<ConnectedSpeaker>(((Component)this).transform.position, (float)num, list, 256, (QueryTriggerInteraction)1);
		IOEntity iOEntity = ioEntity.Get(serverside: true);
		List<MicrophoneStand> list2 = Pool.Get<List<MicrophoneStand>>();
		int num2 = 0;
		foreach (ConnectedSpeaker item in list)
		{
			bool flag = true;
			list2.Clear();
			GamePhysics.OverlapSphere<MicrophoneStand>(((Component)item).transform.position, (float)num, list2, 256, (QueryTriggerInteraction)1);
			if (list2.Count > 1)
			{
				float num3 = Distance((BaseEntity)item);
				foreach (MicrophoneStand item2 in list2)
				{
					if (!item2.isClient && item2.Distance((BaseEntity)item) < num3)
					{
						flag = false;
						break;
					}
				}
			}
			if (flag)
			{
				iOEntity.outputs[0].connectedTo.Set(item);
				item.inputs[0].connectedTo.Set(iOEntity);
				iOEntity = item;
				num2++;
			}
		}
		Pool.FreeUnmanaged<ConnectedSpeaker>(ref list);
		Pool.FreeUnmanaged<MicrophoneStand>(ref list2);
	}

	public override void Load(LoadInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.microphoneStand != null)
		{
			currentSpeechMode = (SpeechMode)info.msg.microphoneStand.microphoneMode;
			ioEntity.uid = info.msg.microphoneStand.IORef;
		}
	}
}


public enum SpeechMode
{
	Normal,
	HighPitch,
	LowPitch
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class MissionSlowUseObject : BaseEntity
{
	public float InteractTime = 5f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MissionSlowUseObject.OnRpcMessage", 0);
		try
		{
			if (rpc == 2005407348 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerUse "));
				}
				TimeWarning val2 = TimeWarning.New("ServerUse", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2005407348u, "ServerUse", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerUse(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerUse");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool CanPlayerUse(BasePlayer player)
	{
		if (player.TryGetActiveMissionInstance(out var instance))
		{
			BaseMission.MissionObjectiveEntry[] objectives = instance.GetMission().objectives;
			for (int i = 0; i < objectives.Length; i++)
			{
				MissionObjective objective = objectives[i].objective;
				if (objective is MissionObjective_ActivateLongUseObject missionObjective_ActivateLongUseObject && !objective.IsCompleted(i, instance) && objective.CanProgress(i, instance) && missionObjective_ActivateLongUseObject.RequiredEntity.prefabID == prefabID)
				{
					return true;
				}
			}
		}
		return false;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ServerUse(RPCMessage msg)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (CanPlayerUse(player))
		{
			player.ProcessMissionEvent(BaseMission.MissionEventType.LONG_USE_OBJECT, net.ID, 1f);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class MixingTable : StorageContainer
{
	public enum Type
	{
		Mixing,
		Cooking
	}

	public GameObject Particles;

	public Type TableType;

	public RecipeList Recipes;

	public bool OnlyAcceptValidIngredients;

	public bool visualFood;

	public bool dropFromEyeLevel;

	public float lastTickTimestamp;

	private List<Item> inventoryItems = new List<Item>();

	private const float mixTickInterval = 1f;

	protected Recipe currentRecipe;

	public int currentQuantity;

	public ItemDefinition currentProductionItem;

	private int pendingItemId;

	private static Dictionary<int, int> itemCostCache = new Dictionary<int, int>();

	public float RemainingMixTime { get; set; }

	public float TotalMixTime { get; set; }

	public int CookingItemId { get; private set; }

	public BasePlayer MixStartingPlayer { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MixingTable.OnRpcMessage", 0);
		try
		{
			if (rpc == 4291077201u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_FillInventoryForRecipe "));
				}
				TimeWarning val2 = TimeWarning.New("SV_FillInventoryForRecipe", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4291077201u, "SV_FillInventoryForRecipe", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4291077201u, "SV_FillInventoryForRecipe", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(4291077201u, "SV_FillInventoryForRecipe", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_FillInventoryForRecipe(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_FillInventoryForRecipe");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SVSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4167839872u, "SVSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SVSwitch(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SVSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
		base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
		RecipeDictionary.CacheRecipes(Recipes);
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		if (item == null)
		{
			return false;
		}
		if (!OnlyAcceptValidIngredients)
		{
			return true;
		}
		if (GetItemWaterAmount(item) > 0)
		{
			item = item.contents.itemList[0];
		}
		if (!((Object)(object)item.info == (Object)(object)currentProductionItem))
		{
			return RecipeDictionary.ValidIngredientForARecipe(item, Recipes);
		}
		return true;
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		if (IsOn())
		{
			StopMixing();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void SV_FillInventoryForRecipe(RPCMessage msg)
	{
		if ((Object)(object)msg.player == (Object)null)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num >= 0 && num < Recipes.AllRecipes.Count)
		{
			Recipe recipe = Recipes.AllRecipes[num];
			if (!((Object)(object)recipe == (Object)null))
			{
				int amount = msg.read.Int32();
				TryFillInventoryForRecipe(recipe, msg.player, amount);
			}
		}
	}

	private void TryFillInventoryForRecipe(Recipe recipe, BasePlayer player, int amount)
	{
		if ((Object)(object)recipe == (Object)null || (Object)(object)player == (Object)null || amount <= 0)
		{
			return;
		}
		Recipe matchingInventoryRecipe = GetMatchingInventoryRecipe(base.inventory);
		ItemContainer tableContainer = (((Object)(object)matchingInventoryRecipe != (Object)(object)recipe) ? base.inventory : null);
		if (!CanPlayerAffordRecipe(player, recipe, tableContainer, amount))
		{
			return;
		}
		if ((Object)(object)matchingInventoryRecipe != (Object)(object)recipe)
		{
			ReturnInventory(player);
		}
		int num = 0;
		Recipe.RecipeIngredient[] ingredients = recipe.Ingredients;
		for (int i = 0; i < ingredients.Length; i++)
		{
			Recipe.RecipeIngredient recipeIngredient = ingredients[i];
			int num2 = base.inventory.GetSlot(num)?.amount ?? 0;
			int ingredientCount = recipeIngredient.GetIngredientCount(recipe.ProducedItem);
			int num3 = ingredientCount * amount;
			int num4 = Mathf.Clamp(recipeIngredient.Ingredient.stackable - num2, 0, recipeIngredient.Ingredient.stackable);
			if (num3 > num4)
			{
				int num5 = num4 / ingredientCount;
				if (num5 < amount)
				{
					amount = num5;
				}
			}
			num++;
		}
		if (amount <= 0)
		{
			return;
		}
		num = 0;
		ingredients = recipe.Ingredients;
		for (int i = 0; i < ingredients.Length; i++)
		{
			Recipe.RecipeIngredient recipeIngredient2 = ingredients[i];
			PooledList<Item> val = Pool.Get<PooledList<Item>>();
			try
			{
				int num6 = recipeIngredient2.GetIngredientCount(recipe.ProducedItem) * amount;
				if (player.inventory.Take((List<Item>)(object)val, recipeIngredient2.Ingredient.itemid, num6) >= num6)
				{
					foreach (Item item in (List<Item>)(object)val)
					{
						if (!item.MoveToContainer(base.inventory, num))
						{
							player.inventory.GiveItem(item);
						}
					}
				}
				num++;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		ItemManager.DoRemoves();
	}

	private void ReturnInventory(BasePlayer player)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null && !slot.MoveToContainer(player.inventory.containerMain) && !slot.MoveToContainer(player.inventory.containerBelt))
			{
				Vector3 vPos = (dropFromEyeLevel ? player.GetDropPosition() : base.inventory.dropPosition);
				Vector3 vVelocity = (dropFromEyeLevel ? player.GetDropVelocity() : base.inventory.dropVelocity);
				slot.Drop(vPos, vVelocity);
			}
		}
		ItemManager.DoRemoves();
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnMixingTableToggle", (object)this, (object)msg.player) != null)
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag != IsOn() && !((Object)(object)msg.player == (Object)null))
		{
			if (flag)
			{
				StartMixing(msg.player);
			}
			else
			{
				StopMixing();
			}
		}
	}

	public void StartMixing(BasePlayer player)
	{
		if (IsOn() || !CanStartMixing(player))
		{
			return;
		}
		MixStartingPlayer = player;
		bool itemsAreContiguous;
		List<Item> orderedContainerItems = GetOrderedContainerItems(base.inventory, out itemsAreContiguous);
		currentRecipe = RecipeDictionary.GetMatchingRecipeAndQuantity(Recipes, orderedContainerItems, out var quantity);
		currentQuantity = quantity;
		if (!((Object)(object)currentRecipe == (Object)null) && itemsAreContiguous && (!currentRecipe.RequiresBlueprint || !((Object)(object)currentRecipe.ProducedItem != (Object)null) || player.blueprints.HasUnlocked(currentRecipe.ProducedItem)))
		{
			if (base.isServer)
			{
				lastTickTimestamp = Time.realtimeSinceStartup;
			}
			RemainingMixTime = currentRecipe.MixingDuration * (float)currentQuantity;
			TotalMixTime = RemainingMixTime;
			ReturnExcessItems(orderedContainerItems, player);
			if (RemainingMixTime == 0f)
			{
				ProduceItem(currentRecipe, currentQuantity);
				return;
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)TickMix, 1f, 1f);
			SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
		}
	}

	protected virtual bool CanStartMixing(BasePlayer player)
	{
		return true;
	}

	public void StopMixing()
	{
		if (IsOn())
		{
			SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
			currentRecipe = null;
			currentQuantity = 0;
			RemainingMixTime = 0f;
			((FacepunchBehaviour)this).CancelInvoke((Action)TickMix);
			SendNetworkUpdateImmediate();
		}
	}

	public void TickMix()
	{
		if ((Object)(object)currentRecipe == (Object)null)
		{
			StopMixing();
			return;
		}
		if (base.isServer)
		{
			lastTickTimestamp = Time.realtimeSinceStartup;
			RemainingMixTime -= 1f;
		}
		SendNetworkUpdateImmediate();
		if (RemainingMixTime <= 0f)
		{
			ProduceItem(currentRecipe, currentQuantity);
		}
	}

	public void ProduceItem(Recipe recipe, int quantity)
	{
		pendingItemId = recipe.ProducedItem.itemid;
		StopMixing();
		ConsumeInventory(recipe, quantity);
		CreateRecipeItems(recipe, quantity);
		Interface.CallHook("OnMixingTableFinished", (object)this, (object)MixStartingPlayer, (object)recipe, (object)quantity);
	}

	private void ConsumeInventory(Recipe recipe, int quantity)
	{
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item item = base.inventory.GetSlot(i);
			if (item != null)
			{
				if (GetItemWaterAmount(item) > 0)
				{
					item = item.contents.itemList[0];
				}
				int num = recipe.Ingredients[i].GetIngredientCount(recipe.ProducedItem) * quantity;
				if (num > 0)
				{
					Analytics.Azure.OnCraftMaterialConsumed(item.info.shortname, item.amount, MixStartingPlayer, this, inSafezone: false, recipe.ProducedItem?.shortname);
					item.UseItem(num);
				}
			}
		}
		ItemManager.DoRemoves();
	}

	private void ReturnExcessItems(List<Item> orderedContainerItems, BasePlayer player)
	{
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null || (Object)(object)currentRecipe == (Object)null || orderedContainerItems == null || orderedContainerItems.Count != currentRecipe.Ingredients.Length)
		{
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot == null)
			{
				break;
			}
			int num = slot.amount - currentRecipe.Ingredients[i].GetIngredientCount(currentRecipe.ProducedItem) * currentQuantity;
			if (num > 0)
			{
				Item item = slot.SplitItem(num);
				if (!item.MoveToContainer(player.inventory.containerMain) && !item.MoveToContainer(player.inventory.containerBelt))
				{
					item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
				}
			}
		}
		ItemManager.DoRemoves();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		if (!added && item.info.itemid == pendingItemId)
		{
			pendingItemId = 0;
			SendNetworkUpdateImmediate();
		}
	}

	protected virtual void CreateRecipeItems(Recipe recipe, int quantity)
	{
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)recipe == (Object)null || (Object)(object)recipe.ProducedItem == (Object)null)
		{
			return;
		}
		int num = quantity * recipe.ProducedItemCount;
		int stackable = recipe.ProducedItem.stackable;
		int num2 = Mathf.CeilToInt((float)num / (float)stackable);
		currentProductionItem = recipe.ProducedItem;
		for (int i = 0; i < num2; i++)
		{
			int num3 = ((num > stackable) ? stackable : num);
			Item item = ItemManager.Create(recipe.ProducedItem, num3, 0uL);
			if ((Object)(object)MixStartingPlayer != (Object)null && !MixStartingPlayer.IsDestroyed)
			{
				item.SetItemOwnership(MixStartingPlayer, ItemOwnershipPhrases.MixingTable);
			}
			Analytics.Azure.OnCraftItem(item.info.shortname, item.amount, MixStartingPlayer, this, inSafezone: false, 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
			num -= num3;
			if (num <= 0)
			{
				break;
			}
		}
		currentProductionItem = null;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.mixingTable = Pool.Get<MixingTable>();
		info.msg.mixingTable.pendingItem = pendingItemId;
		if (info.forDisk)
		{
			info.msg.mixingTable.remainingMixTime = RemainingMixTime;
		}
		else
		{
			info.msg.mixingTable.remainingMixTime = RemainingMixTime - Mathf.Max(Time.realtimeSinceStartup - lastTickTimestamp, 0f);
			info.msg.mixingTable.currentRecipe = (((Object)(object)currentRecipe != (Object)null && (Object)(object)currentRecipe.ProducedItem != (Object)null) ? currentRecipe.ProducedItem.itemid : (-1));
		}
		info.msg.mixingTable.totalMixTime = TotalMixTime;
	}

	private int GetItemWaterAmount(Item item)
	{
		if (item == null)
		{
			return 0;
		}
		if (item.contents != null && item.contents.capacity == 1 && item.contents.allowedContents == ItemContainer.ContentsType.Liquid && item.contents.itemList.Count > 0)
		{
			return item.contents.itemList[0].amount;
		}
		return 0;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.mixingTable != null)
		{
			RemainingMixTime = info.msg.mixingTable.remainingMixTime;
			TotalMixTime = info.msg.mixingTable.totalMixTime;
			CookingItemId = info.msg.mixingTable.currentRecipe;
			pendingItemId = info.msg.mixingTable.pendingItem;
		}
	}

	public Recipe GetMatchingInventoryRecipe(ItemContainer container)
	{
		bool itemsAreContiguous;
		int quantity;
		Recipe matchingRecipeAndQuantity = RecipeDictionary.GetMatchingRecipeAndQuantity(Recipes, GetOrderedContainerItems(container, out itemsAreContiguous), out quantity);
		if ((Object)(object)matchingRecipeAndQuantity == (Object)null)
		{
			return null;
		}
		if (!itemsAreContiguous)
		{
			return null;
		}
		if (quantity <= 0)
		{
			return null;
		}
		return matchingRecipeAndQuantity;
	}

	public List<Item> GetOrderedContainerItems(ItemContainer container, out bool itemsAreContiguous)
	{
		itemsAreContiguous = true;
		if (container == null)
		{
			return null;
		}
		if (container.itemList == null)
		{
			return null;
		}
		if (container.itemList.Count == 0)
		{
			return null;
		}
		inventoryItems.Clear();
		bool flag = false;
		for (int i = 0; i < container.capacity; i++)
		{
			Item item = container.GetSlot(i);
			if (item != null && flag)
			{
				itemsAreContiguous = false;
				break;
			}
			if (item == null)
			{
				flag = true;
				continue;
			}
			if (GetItemWaterAmount(item) > 0)
			{
				item = item.contents.itemList[0];
			}
			inventoryItems.Add(item);
		}
		return inventoryItems;
	}

	public int GetMaxPlayerCanAfford(BasePlayer player, Recipe recipe, ItemContainer tableContainer)
	{
		if ((Object)(object)player == (Object)null)
		{
			return 0;
		}
		if ((Object)(object)recipe == (Object)null)
		{
			return 0;
		}
		ItemContainer itemContainer = (((Object)(object)GetMatchingInventoryRecipe(tableContainer) != (Object)(object)recipe) ? tableContainer : null);
		itemCostCache.Clear();
		Recipe.RecipeIngredient[] ingredients = recipe.Ingredients;
		for (int i = 0; i < ingredients.Length; i++)
		{
			Recipe.RecipeIngredient recipeIngredient = ingredients[i];
			if (!itemCostCache.ContainsKey(recipeIngredient.Ingredient.itemid))
			{
				itemCostCache[recipeIngredient.Ingredient.itemid] = 0;
			}
			itemCostCache[recipeIngredient.Ingredient.itemid] += recipeIngredient.GetIngredientCount(recipe.ProducedItem);
		}
		int num = int.MaxValue;
		foreach (KeyValuePair<int, int> item in itemCostCache)
		{
			int amount = player.inventory.GetAmount(item.Key);
			int num2 = itemContainer?.GetAmount(item.Key, onlyUsableAmounts: true) ?? 0;
			int num3 = (amount + num2) / itemCostCache[item.Key];
			if (num3 < num)
			{
				num = num3;
			}
		}
		return num;
	}

	public bool CanPlayerAffordRecipe(BasePlayer player, Recipe recipe, ItemContainer tableContainer, int amount)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if ((Object)(object)recipe == (Object)null)
		{
			return false;
		}
		itemCostCache.Clear();
		Recipe.RecipeIngredient[] ingredients = recipe.Ingredients;
		for (int i = 0; i < ingredients.Length; i++)
		{
			Recipe.RecipeIngredient recipeIngredient = ingredients[i];
			if (!itemCostCache.ContainsKey(recipeIngredient.Ingredient.itemid))
			{
				itemCostCache[recipeIngredient.Ingredient.itemid] = 0;
			}
			itemCostCache[recipeIngredient.Ingredient.itemid] += recipeIngredient.GetIngredientCount(recipe.ProducedItem) * amount;
		}
		foreach (KeyValuePair<int, int> item in itemCostCache)
		{
			int amount2 = player.inventory.GetAmount(item.Key);
			int num = tableContainer?.GetAmount(item.Key, onlyUsableAmounts: true) ?? 0;
			if (amount2 + num < itemCostCache[item.Key])
			{
				return false;
			}
		}
		return true;
	}
}


public enum Type
{
	Mixing,
	Cooking
}


using System;
using System.IO;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class MLRS : BaseMountable
{
	[Serializable]
	public class RocketTube
	{
		public Vector3 firingOffset;

		public Transform hinge;

		public Renderer rocket;
	}

	[Header("MLRS Components")]
	[SerializeField]
	private GameObjectRef rocketStoragePrefab;

	[SerializeField]
	private GameObjectRef dashboardStoragePrefab;

	[Header("MLRS Rotation")]
	[SerializeField]
	private Transform hRotator;

	[SerializeField]
	public float hRotSpeed = 25f;

	[SerializeField]
	private Transform vRotator;

	[SerializeField]
	public float vRotSpeed = 10f;

	[Range(50f, 90f)]
	[SerializeField]
	public float vRotMax = 85f;

	[SerializeField]
	private Transform hydraulics;

	[Header("MLRS Weaponry")]
	[Tooltip("Minimum distance from the MLRS to a targeted hit point. In metres.")]
	[SerializeField]
	public float minRange = 200f;

	[Tooltip("The size of the area that the rockets may hit, minus rocket damage radius.")]
	[SerializeField]
	public float targetAreaRadius = 30f;

	[SerializeField]
	private GameObjectRef mlrsRocket;

	[SerializeField]
	public Transform firingPoint;

	[SerializeField]
	public RocketTube[] rocketTubes;

	[SerializeField]
	[Header("MLRS Dashboard/FX")]
	private GameObject screensChild;

	[SerializeField]
	private Transform leftHandGrip;

	[SerializeField]
	private Transform leftJoystick;

	[SerializeField]
	private Transform rightHandGrip;

	[SerializeField]
	private Transform rightJoystick;

	[SerializeField]
	private Transform controlKnobHeight;

	[SerializeField]
	private Transform controlKnobAngle;

	[SerializeField]
	private GameObjectRef uiDialogPrefab;

	[SerializeField]
	private Light fireButtonLight;

	[SerializeField]
	private GameObject brokenDownEffect;

	[SerializeField]
	private ParticleSystem topScreenShutdown;

	[SerializeField]
	private ParticleSystem bottomScreenShutdown;

	[ServerVar(Help = "How many minutes before the MLRS recovers from use and can be used again")]
	public static float brokenDownMinutes = 20f;

	public const Flags FLAG_FIRING_ROCKETS = Flags.Reserved6;

	public const Flags FLAG_HAS_AIMING_MODULE = Flags.Reserved8;

	private EntityRef rocketStorageInstance;

	private EntityRef dashboardStorageInstance;

	public float rocketBaseGravity;

	public float rocketSpeed;

	private bool isInitialLoad = true;

	public const string MLRS_PLAYER_KILL_STAT = "mlrs_kills";

	private float leftRightInput;

	private float upDownInput;

	public Vector3 lastSentTargetHitPos;

	public Vector3 lastSentTrueHitPos;

	public int nextRocketIndex;

	public EntityRef rocketOwnerRef;

	public TimeSince timeSinceBroken;

	public int radiusModIndex;

	private float[] radiusMods = new float[4]
	{
		0.1f,
		0.2f,
		1f / 3f,
		2f / 3f
	};

	public Vector3 trueTargetHitPos;

	public Vector3 UserTargetHitPos { get; set; }

	public Vector3 TrueHitPos { get; set; }

	public bool HasAimingModule => HasFlag(Flags.Reserved8);

	public bool CanBeUsed
	{
		get
		{
			if (HasAimingModule)
			{
				return !IsBroken();
			}
			return false;
		}
	}

	public bool CanFire
	{
		get
		{
			if (CanBeUsed && RocketAmmoCount > 0 && !IsFiringRockets)
			{
				return !IsRealigning;
			}
			return false;
		}
	}

	public float HRotation
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return hRotator.eulerAngles.y;
		}
		set
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			Vector3 eulerAngles = hRotator.eulerAngles;
			eulerAngles.y = value;
			hRotator.eulerAngles = eulerAngles;
		}
	}

	public float VRotation
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return vRotator.localEulerAngles.x;
		}
		set
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			Vector3 localEulerAngles = vRotator.localEulerAngles;
			if (value < 0f)
			{
				localEulerAngles.x = Mathf.Clamp(value, 0f - vRotMax, 0f);
			}
			else if (value > 0f)
			{
				localEulerAngles.x = Mathf.Clamp(value, 360f - vRotMax, 360f);
			}
			vRotator.localEulerAngles = localEulerAngles;
		}
	}

	public float CurGravityMultiplier { get; set; }

	public int RocketAmmoCount { get; set; }

	public bool IsRealigning { get; set; }

	public bool IsFiringRockets => HasFlag(Flags.Reserved6);

	public float RocketDamageRadius { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("MLRS.OnRpcMessage", 0);
		try
		{
			if (rpc == 455279877 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Fire_Rockets "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Fire_Rockets", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(455279877u, "RPC_Fire_Rockets", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Fire_Rockets(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Fire_Rockets");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 751446792 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open_Dashboard "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open_Dashboard", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(751446792u, "RPC_Open_Dashboard", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_Open_Dashboard(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Open_Dashboard");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1311007340 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open_Rockets "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open_Rockets", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1311007340u, "RPC_Open_Rockets", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_Open_Rockets(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_Open_Rockets");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 858951307 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SetTargetHitPos "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SetTargetHitPos", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						long position = ((Stream)(object)msg.read).Position;
						if (!RPC_Server.InputValidation.Test(msg.read.Read<Vector3>()))
						{
							return true;
						}
						((Stream)(object)msg.read).Position = position;
						if (!RPC_Server.MaxDistance.Test(858951307u, "RPC_SetTargetHitPos", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_SetTargetHitPos(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_SetTargetHitPos");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		GameObject obj = mlrsRocket.Get();
		ServerProjectile component = obj.GetComponent<ServerProjectile>();
		rocketBaseGravity = (0f - Physics.gravity.y) * component.gravityModifier;
		rocketSpeed = component.speed;
		TimedExplosive component2 = obj.GetComponent<TimedExplosive>();
		RocketDamageRadius = component2.explosionRadius;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.mlrs != null)
		{
			SetUserTargetHitPos(info.msg.mlrs.targetPos);
			TrueHitPos = info.msg.mlrs.curHitPos;
			HitPosToRotation(TrueHitPos, out var hRot, out var vRot, out var g);
			CurGravityMultiplier = g / (0f - Physics.gravity.y);
			if (base.isServer)
			{
				HRotation = hRot;
				VRotation = vRot;
			}
			rocketStorageInstance.uid = info.msg.mlrs.rocketStorageID;
			dashboardStorageInstance.uid = info.msg.mlrs.dashboardStorageID;
			RocketAmmoCount = (int)info.msg.mlrs.ammoCount;
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!IsFiringRockets)
		{
			return base.CanBeLooted(player);
		}
		return false;
	}

	public void SetUserTargetHitPos(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		if (UserTargetHitPos == worldPos)
		{
			return;
		}
		if (base.isServer)
		{
			Vector3 position = TerrainMeta.Position;
			Vector3 val = position + TerrainMeta.Size;
			worldPos.x = Mathf.Clamp(worldPos.x, position.x, val.x);
			worldPos.z = Mathf.Clamp(worldPos.z, position.z, val.z);
			worldPos.y = GetSurfaceHeight(worldPos);
		}
		if (Interface.CallHook("OnMlrsTarget", (object)this, (object)worldPos, (object)_mounted) != null)
		{
			return;
		}
		UserTargetHitPos = worldPos;
		if (base.isServer)
		{
			trueTargetHitPos = UserTargetHitPos;
			foreach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)
			{
				Bounds val2 = allSafeZone.triggerCollider.bounds;
				Vector3 center = ((Bounds)(ref val2)).center;
				center.y = 0f;
				float num = allSafeZone.triggerCollider.GetRadius(((Component)allSafeZone).transform.localScale) + targetAreaRadius;
				trueTargetHitPos.y = 0f;
				if (Vector3.Distance(center, trueTargetHitPos) < num)
				{
					Vector3 val3 = trueTargetHitPos - center;
					trueTargetHitPos = center + ((Vector3)(ref val3)).normalized * num;
					trueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);
					break;
				}
			}
		}
		Interface.CallHook("OnMlrsTargetSet", (object)this, (object)trueTargetHitPos, (object)_mounted);
	}

	public StorageContainer GetRocketContainer()
	{
		BaseEntity baseEntity = rocketStorageInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	public StorageContainer GetDashboardContainer()
	{
		BaseEntity baseEntity = dashboardStorageInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	public void HitPosToRotation(Vector3 hitPos, out float hRot, out float vRot, out float g)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 aimToTarget = Ballistics.GetAimToTarget(firingPoint.position, hitPos, rocketSpeed, vRotMax, rocketBaseGravity, minRange, out g);
		Quaternion val = Quaternion.LookRotation(aimToTarget, Vector3.up);
		Vector3 eulerAngles = ((Quaternion)(ref val)).eulerAngles;
		vRot = eulerAngles.x - 360f;
		aimToTarget.y = 0f;
		hRot = eulerAngles.y;
	}

	public static float ProjectileDistToSpeed(float x, float y, float angle, float g, float fallbackV)
	{
		float num = angle * (MathF.PI / 180f);
		float num2 = Mathf.Sqrt(x * x * g / (x * Mathf.Sin(2f * num) - 2f * y * Mathf.Cos(num) * Mathf.Cos(num)));
		if (float.IsNaN(num2) || num2 < 1f)
		{
			num2 = fallbackV;
		}
		return num2;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer)
		{
			if (child.prefabID == rocketStoragePrefab.GetEntity().prefabID)
			{
				rocketStorageInstance.Set(child);
			}
			if (child.prefabID == dashboardStoragePrefab.GetEntity().prefabID)
			{
				dashboardStorageInstance.Set(child);
			}
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("MLRS.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (IsBroken())
			{
				if (!(TimeSince.op_Implicit(timeSinceBroken) >= brokenDownMinutes * 60f))
				{
					SetFlag(Flags.Reserved8, TryGetAimingModule(out var _));
					return;
				}
				SetRepaired();
			}
			int rocketAmmoCount = RocketAmmoCount;
			UpdateStorageState();
			if (CanBeUsed && AnyMounted())
			{
				Vector3 userTargetHitPos = UserTargetHitPos;
				userTargetHitPos += Vector3.forward * upDownInput * 75f * Time.fixedDeltaTime;
				userTargetHitPos += Vector3.right * leftRightInput * 75f * Time.fixedDeltaTime;
				SetUserTargetHitPos(userTargetHitPos);
			}
			if (!IsFiringRockets)
			{
				HitPosToRotation(trueTargetHitPos, out var hRot, out var vRot, out var g);
				float num = g / (0f - Physics.gravity.y);
				IsRealigning = Mathf.Abs(Mathf.DeltaAngle(VRotation, vRot)) > 0.001f || Mathf.Abs(Mathf.DeltaAngle(HRotation, hRot)) > 0.001f || !Mathf.Approximately(CurGravityMultiplier, num);
				if (IsRealigning)
				{
					if (isInitialLoad)
					{
						VRotation = vRot;
						HRotation = hRot;
						isInitialLoad = false;
					}
					else
					{
						VRotation = Mathf.MoveTowardsAngle(VRotation, vRot, Time.deltaTime * vRotSpeed);
						HRotation = Mathf.MoveTowardsAngle(HRotation, hRot, Time.deltaTime * hRotSpeed);
					}
					CurGravityMultiplier = num;
					Ballistics.TryGetPhysicsProjectileHitPos(firingPoint.position, firingPoint.forward, rocketSpeed, Physics.gravity.y * CurGravityMultiplier, out var result, 2f, 0.66f, 128f, this);
					TrueHitPos = result;
				}
			}
			if (UserTargetHitPos != lastSentTargetHitPos || TrueHitPos != lastSentTrueHitPos || RocketAmmoCount != rocketAmmoCount)
			{
				SendNetworkUpdate();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public float GetSurfaceHeight(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return WaterLevel.GetWaterOrTerrainSurface(pos, waves: false, volumes: false);
	}

	public void SetRepaired()
	{
		SetFlag(Flags.Broken, b: false);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			upDownInput = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			upDownInput = -1f;
		}
		else
		{
			upDownInput = 0f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			leftRightInput = -1f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			leftRightInput = 1f;
		}
		else
		{
			leftRightInput = 0f;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.mlrs = Pool.Get<MLRS>();
		info.msg.mlrs.targetPos = UserTargetHitPos;
		info.msg.mlrs.curHitPos = TrueHitPos;
		info.msg.mlrs.rocketStorageID = rocketStorageInstance.uid;
		info.msg.mlrs.dashboardStorageID = dashboardStorageInstance.uid;
		info.msg.mlrs.ammoCount = (uint)RocketAmmoCount;
		lastSentTargetHitPos = UserTargetHitPos;
		lastSentTrueHitPos = TrueHitPos;
	}

	public bool AdminFixUp()
	{
		if (IsDead() || IsFiringRockets)
		{
			return false;
		}
		StorageContainer dashboardContainer = GetDashboardContainer();
		if (!HasAimingModule)
		{
			dashboardContainer.inventory.AddItem(ItemManager.FindItemDefinition("aiming.module.mlrs"), 1, 0uL);
		}
		StorageContainer rocketContainer = GetRocketContainer();
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("ammo.rocket.mlrs");
		int num = rocketContainer.inventory.capacity * itemDefinition.stackable;
		if (RocketAmmoCount < num)
		{
			int num2 = num - RocketAmmoCount;
			while (num2 > 0)
			{
				int num3 = Mathf.Min(num2, itemDefinition.stackable);
				rocketContainer.inventory.AddItem(itemDefinition, itemDefinition.stackable, 0uL);
				num2 -= num3;
			}
		}
		SetRepaired();
		SendNetworkUpdate();
		return true;
	}

	public void Fire(BasePlayer owner)
	{
		UpdateStorageState();
		if (CanFire && !((Object)(object)GetMounted() == (Object)null) && Interface.CallHook("OnMlrsFire", (object)this, (object)owner) == null)
		{
			SetFlag(Flags.Reserved6, b: true);
			radiusModIndex = 0;
			nextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);
			rocketOwnerRef.Set(owner);
			((FacepunchBehaviour)this).InvokeRepeating((Action)FireNextRocket, 0f, 0.5f);
			Interface.CallHook("OnMlrsFired", (object)this, (object)owner);
		}
	}

	public void EndFiring()
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		((FacepunchBehaviour)this).CancelInvoke((Action)FireNextRocket);
		rocketOwnerRef.Set(null);
		if (TryGetAimingModule(out var item))
		{
			item.LoseCondition(1f);
		}
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Broken, b: true, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		timeSinceBroken = TimeSince.op_Implicit(0f);
		Interface.CallHook("OnMlrsFiringEnded", (object)this);
	}

	public void FireNextRocket()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		RocketAmmoCount = GetRocketContainer().inventory.GetAmmoAmount((AmmoTypes)2048);
		if (nextRocketIndex < 0 || nextRocketIndex >= RocketAmmoCount || IsBroken())
		{
			EndFiring();
			return;
		}
		StorageContainer rocketContainer = GetRocketContainer();
		Vector3 firingPos = firingPoint.position + firingPoint.rotation * rocketTubes[nextRocketIndex].firingOffset;
		float num = 1f;
		if (radiusModIndex < radiusMods.Length)
		{
			num = radiusMods[radiusModIndex];
		}
		radiusModIndex++;
		Vector2 val = Random.insideUnitCircle * (targetAreaRadius - RocketDamageRadius) * num;
		Vector3 target = TrueHitPos + new Vector3(val.x, 0f, val.y);
		float requiredGravity;
		Vector3 aimToTarget = Ballistics.GetAimToTarget(firingPoint.position, target, rocketSpeed, vRotMax, rocketBaseGravity, minRange, out requiredGravity);
		if (TryFireProjectile(rocketContainer, (AmmoTypes)2048, firingPos, aimToTarget, rocketOwnerRef.Get(serverside: true) as BasePlayer, 0f, 0f, out var projectile))
		{
			projectile.gravityModifier = requiredGravity / (0f - Physics.gravity.y);
			Interface.CallHook("OnMlrsRocketFired", (object)this, (object)projectile);
			nextRocketIndex--;
		}
		else
		{
			EndFiring();
		}
	}

	private void UpdateStorageState()
	{
		Item item;
		bool b = TryGetAimingModule(out item);
		SetFlag(Flags.Reserved8, b);
		RocketAmmoCount = GetRocketContainer().inventory.GetAmmoAmount((AmmoTypes)2048);
	}

	public bool TryGetAimingModule(out Item item)
	{
		if ((Object)(object)GetDashboardContainer() == (Object)null)
		{
			item = null;
			return false;
		}
		ItemContainer inventory = GetDashboardContainer().inventory;
		if (!inventory.IsEmpty())
		{
			item = inventory.itemList[0];
			return true;
		}
		item = null;
		return false;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	[RPC_Server.InputValidation(new Type[] { typeof(Vector3) })]
	public void RPC_SetTargetHitPos(RPCMessage msg)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (PlayerIsMounted(player))
		{
			SetUserTargetHitPos(msg.read.Vector3());
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_Fire_Rockets(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (PlayerIsMounted(player))
		{
			Fire(player);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_Open_Rockets(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			IItemContainerEntity rocketContainer = GetRocketContainer();
			if (!rocketContainer.IsUnityNull())
			{
				rocketContainer.PlayerOpenLoot(player, "", doPositionChecks: false);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_Open_Dashboard(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			IItemContainerEntity dashboardContainer = GetDashboardContainer();
			if (!dashboardContainer.IsUnityNull())
			{
				dashboardContainer.PlayerOpenLoot(player);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class RocketTube
{
	public Vector3 firingOffset;

	public Transform hinge;

	public Renderer rocket;
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class MobilePhone : HeldEntity
{
	public PhoneController Controller;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MobilePhone.OnRpcMessage", 0);
		try
		{
			if (rpc == 1529322558 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AnswerPhone "));
				}
				TimeWarning val2 = TimeWarning.New("AnswerPhone", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(1529322558u, "AnswerPhone", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AnswerPhone(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AnswerPhone");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2754362156u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearCurrentUser "));
				}
				TimeWarning val2 = TimeWarning.New("ClearCurrentUser", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(2754362156u, "ClearCurrentUser", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ClearCurrentUser(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ClearCurrentUser");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1095090232 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - InitiateCall "));
				}
				TimeWarning val2 = TimeWarning.New("InitiateCall", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(1095090232u, "InitiateCall", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							InitiateCall(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in InitiateCall");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2606442785u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AddSavedNumber "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AddSavedNumber", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2606442785u, "Server_AddSavedNumber", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2606442785u, "Server_AddSavedNumber", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							Server_AddSavedNumber(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in Server_AddSavedNumber");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1402406333 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RemoveSavedNumber "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RemoveSavedNumber", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1402406333u, "Server_RemoveSavedNumber", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1402406333u, "Server_RemoveSavedNumber", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							Server_RemoveSavedNumber(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in Server_RemoveSavedNumber");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2704491961u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestCurrentState "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestCurrentState", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(2704491961u, "Server_RequestCurrentState", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							Server_RequestCurrentState(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in Server_RequestCurrentState");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 942544266 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestPhoneDirectory "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestPhoneDirectory", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(942544266u, "Server_RequestPhoneDirectory", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(942544266u, "Server_RequestPhoneDirectory", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							Server_RequestPhoneDirectory(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in Server_RequestPhoneDirectory");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1240133378 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerDeleteVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerDeleteVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1240133378u, "ServerDeleteVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1240133378u, "ServerDeleteVoicemail", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg9 = rPCMessage;
							ServerDeleteVoicemail(msg9);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogException(ex8);
						player.Kick("RPC Error in ServerDeleteVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1221129498 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerHangUp "));
				}
				TimeWarning val2 = TimeWarning.New("ServerHangUp", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(1221129498u, "ServerHangUp", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg10 = rPCMessage;
							ServerHangUp(msg10);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in ServerHangUp");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 239260010 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerPlayVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerPlayVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(239260010u, "ServerPlayVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(239260010u, "ServerPlayVoicemail", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg11 = rPCMessage;
							ServerPlayVoicemail(msg11);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogException(ex10);
						player.Kick("RPC Error in ServerPlayVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 189198880 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSendVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSendVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(189198880u, "ServerSendVoicemail", this, player, 5uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg12 = rPCMessage;
							ServerSendVoicemail(msg12);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogException(ex11);
						player.Kick("RPC Error in ServerSendVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2760189029u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerStopVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerStopVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2760189029u, "ServerStopVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2760189029u, "ServerStopVoicemail", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg13 = rPCMessage;
							ServerStopVoicemail(msg13);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex12)
					{
						Debug.LogException(ex12);
						player.Kick("RPC Error in ServerStopVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3900772076u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetCurrentUser "));
				}
				TimeWarning val2 = TimeWarning.New("SetCurrentUser", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(3900772076u, "SetCurrentUser", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage currentUser = rPCMessage;
							SetCurrentUser(currentUser);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex13)
					{
						Debug.LogException(ex13);
						player.Kick("RPC Error in SetCurrentUser");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2760249627u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdatePhoneName "));
				}
				TimeWarning val2 = TimeWarning.New("UpdatePhoneName", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2760249627u, "UpdatePhoneName", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2760249627u, "UpdatePhoneName", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg14 = rPCMessage;
							UpdatePhoneName(msg14);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex14)
					{
						Debug.LogException(ex14);
						player.Kick("RPC Error in UpdatePhoneName");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.telephone == null)
		{
			info.msg.telephone = Pool.Get<Telephone>();
		}
		info.msg.telephone.phoneNumber = Controller.PhoneNumber;
		info.msg.telephone.phoneName = Controller.PhoneName;
		info.msg.telephone.lastNumber = Controller.lastDialedNumber;
		info.msg.telephone.savedNumbers = Controller.savedNumbers;
		if (!info.forDisk)
		{
			info.msg.telephone.usingPlayer = Controller.currentPlayerRef.uid;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Controller.ServerInit();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Controller.PostServerLoad();
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Controller.DoServerDestroy();
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		Controller.OnParentChanged(newParent);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void ClearCurrentUser(RPCMessage msg)
	{
		Controller.ClearCurrentUser(msg);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void SetCurrentUser(RPCMessage msg)
	{
		Controller.SetCurrentUser(msg);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void InitiateCall(RPCMessage msg)
	{
		Controller.InitiateCall(msg);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	public void AnswerPhone(RPCMessage msg)
	{
		Controller.AnswerPhone(msg);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void ServerHangUp(RPCMessage msg)
	{
		Controller.ServerHangUp(msg);
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		Controller.DestroyShared();
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void UpdatePhoneName(RPCMessage msg)
	{
		Controller.UpdatePhoneName(msg);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_RequestPhoneDirectory(RPCMessage msg)
	{
		Controller.Server_RequestPhoneDirectory(msg);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	public void Server_AddSavedNumber(RPCMessage msg)
	{
		Controller.Server_AddSavedNumber(msg);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	public void Server_RemoveSavedNumber(RPCMessage msg)
	{
		Controller.Server_RemoveSavedNumber(msg);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	public void Server_RequestCurrentState(RPCMessage msg)
	{
		Controller.SetPhoneStateWithPlayer(Controller.serverState);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void ServerSendVoicemail(RPCMessage msg)
	{
		Controller.ServerSendVoicemail(msg);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void ServerPlayVoicemail(RPCMessage msg)
	{
		Controller.ServerPlayVoicemail(msg);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void ServerStopVoicemail(RPCMessage msg)
	{
		Controller.ServerStopVoicemail(msg);
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void ServerDeleteVoicemail(RPCMessage msg)
	{
		Controller.ServerDeleteVoicemail(msg);
	}

	public void ToggleRinging(bool state)
	{
		MobileInventoryEntity associatedEntity = ItemModAssociatedEntity<MobileInventoryEntity>.GetAssociatedEntity(GetItem());
		if ((Object)(object)associatedEntity != (Object)null)
		{
			associatedEntity.ToggleRinging(state);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg?.telephone != null)
		{
			Controller.PhoneNumber = info.msg.telephone.phoneNumber;
			Controller.PhoneName = info.msg.telephone.phoneName;
			Controller.lastDialedNumber = info.msg.telephone.lastNumber;
			Controller.currentPlayerRef.uid = info.msg.telephone.usingPlayer;
			PhoneDirectory savedNumbers = Controller.savedNumbers;
			if (savedNumbers != null)
			{
				savedNumbers.ResetToPool();
			}
			Controller.savedNumbers = info.msg.telephone.savedNumbers;
			if (Controller.savedNumbers != null)
			{
				Controller.savedNumbers.ShouldPool = false;
			}
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && old.HasFlag(Flags.Busy) != next.HasFlag(Flags.Busy))
		{
			if (next.HasFlag(Flags.Busy))
			{
				if (!((FacepunchBehaviour)this).IsInvoking((Action)Controller.WatchForDisconnects))
				{
					((FacepunchBehaviour)this).InvokeRepeating((Action)Controller.WatchForDisconnects, 0f, 0.1f);
				}
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Controller.WatchForDisconnects);
			}
		}
		Controller.OnFlagsChanged(old, next);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Modular;
using UnityEngine;
using UnityEngine.Assertions;

public class ModularCar : BaseModularVehicle, IVehicleLockUser, VehicleChassisVisuals<ModularCar>.IClientWheelUser, TakeCollisionDamage.ICanRestoreVelocity, CarPhysics<ModularCar>.ICar
{
	[Serializable]
	public class SpawnSettings
	{
		public enum AdminBonus
		{
			None,
			T1PlusFuel,
			T2PlusFuel,
			T3PlusFuel
		}

		[Tooltip("Must be true to use any of these settings.")]
		public bool useSpawnSettings;

		[Tooltip("Specify a list of possible module configurations that'll automatically spawn with this vehicle.")]
		public ModularCarPresetConfig[] configurationOptions;

		[Tooltip("Min health % at spawn for any modules that spawn with this chassis.")]
		public float minStartHealthPercent = 0.15f;

		[Tooltip("Max health  % at spawn for any modules that spawn with this chassis.")]
		public float maxStartHealthPercent = 0.5f;

		public AdminBonus adminBonus;
	}

	private class DriverSeatInputs
	{
		public float steerInput;

		public bool steerMod;

		public float brakeInput;

		public float throttleInput;
	}

	[Header("Modular Car")]
	public ModularCarChassisVisuals chassisVisuals;

	public VisualCarWheel wheelFL;

	public VisualCarWheel wheelFR;

	public VisualCarWheel wheelRL;

	public VisualCarWheel wheelRR;

	[SerializeField]
	public CarSettings carSettings;

	[SerializeField]
	public float hurtTriggerMinSpeed = 1f;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerFront;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerRear;

	[SerializeField]
	public ProtectionProperties immortalProtection;

	[SerializeField]
	public ProtectionProperties mortalProtection;

	[SerializeField]
	private BoxCollider mainChassisCollider;

	[SerializeField]
	[Header("Towing")]
	private TriggerTowing towingTrigger;

	[SerializeField]
	private Transform towingPoint;

	[SerializeField]
	public SpawnSettings spawnSettings;

	[HideInInspector]
	[SerializeField]
	public MeshRenderer[] damageShowingRenderers;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population = 3f;

	[ServerVar(Help = "How many minutes before a ModularCar loses all its health while outside")]
	public static float outsidedecayminutes = 864f;

	public const BUTTON RapidSteerButton = BUTTON.SPRINT;

	public VehicleEngineController<GroundVehicle>.EngineState lastSetEngineState;

	public float cachedFuelFraction;

	public static HashSet<ModularCar> allCarsList = new HashSet<ModularCar>();

	public readonly ListDictionary<BaseMountable, DriverSeatInputs> driverSeatInputs = new ListDictionary<BaseMountable, DriverSeatInputs>();

	public CarPhysics<ModularCar> carPhysics;

	public VehicleTerrainHandler serverTerrainHandler;

	private CarWheel[] wheels;

	public float lastEngineOnTime;

	private const float DECAY_TICK_TIME = 60f;

	private const float INSIDE_DECAY_MULTIPLIER = 0.1f;

	private const float CORPSE_DECAY_MINUTES = 5f;

	public Vector3 prevPosition;

	public Quaternion prevRotation;

	private Bounds collisionCheckBounds;

	private Vector3 lastGoodPos;

	private Quaternion lastGoodRot;

	private bool lastPosWasBad;

	public float deathDamageCounter;

	private const float DAMAGE_TO_GIB = 600f;

	public TimeSince timeSinceDeath;

	private const float IMMUNE_TIME = 1f;

	public readonly Vector3 groundedCOMMultiplier = new Vector3(0.25f, 0.3f, 0.25f);

	public readonly Vector3 airbourneCOMMultiplier = new Vector3(0.25f, 0.75f, 0.25f);

	public Vector3 prevCOMMultiplier;

	public override float DriveWheelVelocity
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.DriveWheelVelocity;
			}
			return 0f;
		}
	}

	public float DriveWheelSlip
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.DriveWheelSlip;
			}
			return 0f;
		}
	}

	public float SteerAngle
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.SteerAngle;
			}
			return 0f;
		}
	}

	public new ItemDefinition AssociatedItemDef => repair.itemTarget;

	public float MaxSteerAngle => carSettings.maxSteerAngle;

	public override bool IsLockable => CarLock.HasALock;

	public ModularCarCodeLock CarLock { get; private set; }

	public override bool AlwaysAllowBradleyTargeting => true;

	public bool IsTowing => HasFlag(Flags.Reserved14);

	public BaseEntity TowEntity => this;

	public Transform TowAnchor => towingPoint;

	public Rigidbody TowBody => rigidBody;

	public VehicleTerrainHandler.Surface OnSurface
	{
		get
		{
			if (serverTerrainHandler == null)
			{
				return VehicleTerrainHandler.Surface.Default;
			}
			return serverTerrainHandler.OnSurface;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ModularCar.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1382140449 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuelWithKeycode "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuelWithKeycode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						RPC_OpenFuelWithKeycode(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in RPC_OpenFuelWithKeycode");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2818660542u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TryMountWithKeycode "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TryMountWithKeycode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2818660542u, "RPC_TryMountWithKeycode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_TryMountWithKeycode(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_TryMountWithKeycode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(process, rootObj, name, serverside, clientside, bundling);
		damageShowingRenderers = ((Component)this).GetComponentsInChildren<MeshRenderer>();
	}

	public override void InitShared()
	{
		base.InitShared();
		if (CarLock == null)
		{
			CarLock = new ModularCarCodeLock(this, base.isServer);
		}
	}

	public override float MaxHealth()
	{
		if (maxHealthOverride > 0f)
		{
			return maxHealthOverride;
		}
		return AssociatedItemDef.condition.max;
	}

	public override float StartHealth()
	{
		return AssociatedItemDef.condition.max;
	}

	public float TotalHealth()
	{
		float num = 0f;
		for (int i = 0; i < base.AttachedModuleEntities.Count; i++)
		{
			num += base.AttachedModuleEntities[i].Health();
		}
		return num;
	}

	public float TotalMaxHealth()
	{
		float num = 0f;
		for (int i = 0; i < base.AttachedModuleEntities.Count; i++)
		{
			num += base.AttachedModuleEntities[i].MaxHealth();
		}
		return num;
	}

	public override float GetMaxForwardSpeed()
	{
		float num = GetMaxDriveForce() / base.TotalMass * 30f;
		return Mathf.Pow(0.9945f, num) * num;
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.modularCar == null)
		{
			return;
		}
		engineController.FuelSystem.SetInstanceID(info.msg.modularCar.fuelStorageID);
		cachedFuelFraction = info.msg.modularCar.fuelFraction;
		bool hasALock = CarLock.HasALock;
		CarLock.Load(info);
		if (CarLock.HasALock != hasALock)
		{
			for (int i = 0; i < base.AttachedModuleEntities.Count; i++)
			{
				base.AttachedModuleEntities[i].RefreshConditionals(canGib: true);
			}
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next)
		{
			RefreshEngineState();
		}
	}

	public override float GetThrottleInput()
	{
		if (base.isServer)
		{
			float num = 0f;
			BufferList<DriverSeatInputs> values = driverSeatInputs.Values;
			for (int i = 0; i < values.Count; i++)
			{
				num += values[i].throttleInput;
			}
			return Mathf.Clamp(num, -1f, 1f);
		}
		return 0f;
	}

	public override float GetBrakeInput()
	{
		if (base.isServer)
		{
			float num = 0f;
			BufferList<DriverSeatInputs> values = driverSeatInputs.Values;
			for (int i = 0; i < values.Count; i++)
			{
				num += values[i].brakeInput;
			}
			return Mathf.Clamp01(num);
		}
		return 0f;
	}

	public float GetMaxDriveForce()
	{
		float num = 0f;
		for (int i = 0; i < base.AttachedModuleEntities.Count; i++)
		{
			num += base.AttachedModuleEntities[i].GetMaxDriveForce();
		}
		return RollOffDriveForce(num);
	}

	public float GetFuelFraction()
	{
		if (base.isServer)
		{
			return engineController.FuelSystem.GetFuelFraction();
		}
		return cachedFuelFraction;
	}

	public bool PlayerHasUnlockPermission(BasePlayer player)
	{
		return CarLock.HasLockPermission(player);
	}

	public bool KeycodeEntryBlocked(BasePlayer player)
	{
		return CarLock.CodeEntryBlocked(player);
	}

	public override bool PlayerCanUseThis(BasePlayer player, ModularCarCodeLock.LockType lockType)
	{
		return CarLock.PlayerCanUseThis(player, lockType);
	}

	public bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule)
	{
		object obj = Interface.CallHook("CanDestroyLock", (object)player, (object)this, (object)viaModule);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return CarLock.PlayerCanDestroyLock(viaModule);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (PlayerIsMounted(player))
		{
			return true;
		}
		if (!PlayerCanUseThis(player, ModularCarCodeLock.LockType.General))
		{
			return false;
		}
		if (!IsOn())
		{
			return base.CanBeLooted(player);
		}
		return false;
	}

	public override bool CanPushNow(BasePlayer pusher)
	{
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (pusher.InSafeZone() && !CarLock.HasLockPermission(pusher))
		{
			return false;
		}
		return true;
	}

	public bool RefreshEngineState()
	{
		if (lastSetEngineState == base.CurEngineState)
		{
			return false;
		}
		if (base.isServer && base.CurEngineState == VehicleEngineController<GroundVehicle>.EngineState.Off)
		{
			lastEngineOnTime = Time.time;
		}
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			attachedModuleEntity.OnEngineStateChanged(lastSetEngineState, base.CurEngineState);
		}
		if (base.isServer && GameInfo.HasAchievements && NumMounted() >= 5)
		{
			foreach (MountPointInfo allMountPoint in base.allMountPoints)
			{
				if ((Object)(object)allMountPoint.mountable != (Object)null && (Object)(object)allMountPoint.mountable.GetMounted() != (Object)null)
				{
					allMountPoint.mountable.GetMounted().GiveAchievement("BATTLE_BUS");
				}
			}
		}
		lastSetEngineState = base.CurEngineState;
		return true;
	}

	public float RollOffDriveForce(float driveForce)
	{
		return Mathf.Pow(0.9999175f, driveForce) * driveForce;
	}

	public void RefreshChassisProtectionState()
	{
		if (base.HasAnyModules)
		{
			baseProtection = immortalProtection;
			if (base.isServer)
			{
				SetHealth(MaxHealth());
			}
		}
		else
		{
			baseProtection = mortalProtection;
		}
	}

	public override void ModuleEntityAdded(BaseVehicleModule addedModule)
	{
		base.ModuleEntityAdded(addedModule);
		RefreshChassisProtectionState();
	}

	public override void ModuleEntityRemoved(BaseVehicleModule removedModule)
	{
		base.ModuleEntityRemoved(removedModule);
		RefreshChassisProtectionState();
	}

	public override void ServerInit()
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		carPhysics = new CarPhysics<ModularCar>(this, ((Component)this).transform, rigidBody, carSettings);
		serverTerrainHandler = new VehicleTerrainHandler(this);
		if (!Application.isLoadingSave)
		{
			SpawnPreassignedModules();
		}
		lastEngineOnTime = Time.realtimeSinceStartup;
		allCarsList.Add(this);
		collisionCheckBounds = new Bounds(mainChassisCollider.center, new Vector3(mainChassisCollider.size.x - 0.5f, 0.05f, mainChassisCollider.size.z - 0.5f));
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.15f, 0.02f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayTick, Random.Range(30f, 60f), 60f, 6f);
	}

	public override void DoServerDestroy()
	{
		base.DoServerDestroy();
		allCarsList.Remove(this);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		CarLock.PostServerLoad();
		if (IsDead())
		{
			Kill();
		}
	}

	public float GetSteerInput()
	{
		float num = 0f;
		BufferList<DriverSeatInputs> values = driverSeatInputs.Values;
		for (int i = 0; i < values.Count; i++)
		{
			num += values[i].steerInput;
		}
		return Mathf.Clamp(num, -1f, 1f);
	}

	public bool GetSteerSpeedMod(float speed)
	{
		BufferList<DriverSeatInputs> values = driverSeatInputs.Values;
		for (int i = 0; i < values.Count; i++)
		{
			if (values[i].steerMod)
			{
				return true;
			}
		}
		return false;
	}

	public float GetSteerMaxMult(float speed)
	{
		return 1f;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ModularCar.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			float speed = GetSpeed();
			carPhysics.FixedUpdate(Time.fixedDeltaTime, speed);
			engineController.CheckEngineState();
			((Component)hurtTriggerFront).gameObject.SetActive(speed > hurtTriggerMinSpeed);
			((Component)hurtTriggerRear).gameObject.SetActive(speed < 0f - hurtTriggerMinSpeed);
			serverTerrainHandler.FixedUpdate();
			float num = Mathf.Abs(speed);
			if (lastPosWasBad || num > 15f)
			{
				if (GamePhysics.CheckOBB(new OBB(((Component)mainChassisCollider).transform, collisionCheckBounds), 1084293377, (QueryTriggerInteraction)1))
				{
					rigidBody.position = lastGoodPos;
					rigidBody.rotation = lastGoodRot;
					((Component)this).transform.position = lastGoodPos;
					((Component)this).transform.rotation = lastGoodRot;
					rigidBody.velocity = Vector3.zero;
					rigidBody.angularVelocity = Vector3.zero;
					lastPosWasBad = true;
				}
				else
				{
					lastGoodPos = rigidBody.position;
					lastGoodRot = rigidBody.rotation;
					lastPosWasBad = false;
				}
			}
			else
			{
				lastGoodPos = rigidBody.position;
				lastGoodRot = rigidBody.rotation;
				lastPosWasBad = false;
			}
			if (IsMoving())
			{
				Vector3 cOMMultiplier = GetCOMMultiplier();
				if (cOMMultiplier != prevCOMMultiplier)
				{
					rigidBody.centerOfMass = Vector3.Scale(realLocalCOM, cOMMultiplier);
					prevCOMMultiplier = cOMMultiplier;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override bool DetermineIfStationary()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = rigidBody.position;
		Quaternion rotation = rigidBody.rotation;
		bool result = position == prevPosition && rotation == prevRotation;
		prevPosition = position;
		prevRotation = rotation;
		return result;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		MountPointInfo playerSeatInfo = GetPlayerSeatInfo(player);
		if (playerSeatInfo == null || !playerSeatInfo.isDriver)
		{
			return;
		}
		if (!this.driverSeatInputs.Contains(playerSeatInfo.mountable))
		{
			this.driverSeatInputs.Add(playerSeatInfo.mountable, new DriverSeatInputs());
		}
		DriverSeatInputs driverSeatInputs = this.driverSeatInputs[playerSeatInfo.mountable];
		if (inputState.IsDown(BUTTON.FIRE_THIRD))
		{
			driverSeatInputs.steerInput += inputState.MouseDelta().x * 0.1f;
		}
		else
		{
			driverSeatInputs.steerInput = 0f;
			if (inputState.IsDown(BUTTON.LEFT))
			{
				driverSeatInputs.steerInput = -1f;
			}
			else if (inputState.IsDown(BUTTON.RIGHT))
			{
				driverSeatInputs.steerInput = 1f;
			}
		}
		driverSeatInputs.steerMod = inputState.IsDown(BUTTON.SPRINT);
		float num = 0f;
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			num = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			num = -1f;
		}
		driverSeatInputs.throttleInput = 0f;
		driverSeatInputs.brakeInput = 0f;
		if (GetSpeed() > 3f && num < -0.1f)
		{
			driverSeatInputs.throttleInput = 0f;
			driverSeatInputs.brakeInput = 0f - num;
		}
		else
		{
			driverSeatInputs.throttleInput = num;
			driverSeatInputs.brakeInput = 0f;
		}
		for (int i = 0; i < base.NumAttachedModules; i++)
		{
			base.AttachedModuleEntities[i].PlayerServerInput(inputState, player);
		}
		if (engineController.IsOff && ((inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD)) || (inputState.IsDown(BUTTON.BACKWARD) && !inputState.WasDown(BUTTON.BACKWARD))))
		{
			engineController.TryStartEngine(player);
		}
	}

	public override void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerDismounted(player, seat);
		DriverSeatInputs driverSeatInputs = default(DriverSeatInputs);
		if (this.driverSeatInputs.TryGetValue(seat, ref driverSeatInputs))
		{
			this.driverSeatInputs.Remove(seat);
		}
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			if ((Object)(object)attachedModuleEntity != (Object)null)
			{
				attachedModuleEntity.OnPlayerDismountedVehicle(player);
			}
		}
		CarLock.CheckEnableCentralLocking();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.modularCar = Pool.Get<ModularCar>();
		info.msg.modularCar.steerAngle = SteerAngle;
		info.msg.modularCar.driveWheelVel = DriveWheelVelocity;
		info.msg.modularCar.throttleInput = GetThrottleInput();
		info.msg.modularCar.brakeInput = GetBrakeInput();
		info.msg.modularCar.fuelStorageID = GetFuelSystem().GetInstanceID();
		info.msg.modularCar.fuelFraction = GetFuelFraction();
		CarLock.Save(info);
	}

	public override void Hurt(HitInfo info)
	{
		if (!IsDead() && !IsTransferProtected() && info.damageTypes.Get(DamageType.Decay) == 0f)
		{
			PropagateDamageToModules(info, 0.5f / (float)base.NumAttachedModules, 0.9f / (float)base.NumAttachedModules, null);
		}
		base.Hurt(info);
	}

	public void TickFuel(float fuelUsedPerSecond)
	{
		engineController.TickFuel(fuelUsedPerSecond);
	}

	public override bool MountEligable(BasePlayer player)
	{
		if (!base.MountEligable(player))
		{
			return false;
		}
		ModularCarSeat modularCarSeat = GetIdealMountPointFor(player) as ModularCarSeat;
		if ((Object)(object)modularCarSeat != (Object)null && (Object)(object)modularCarSeat.associatedSeatingModule != (Object)null && !modularCarSeat.associatedSeatingModule.DoorsAreLockable)
		{
			return true;
		}
		return PlayerCanUseThis(player, ModularCarCodeLock.LockType.Door);
	}

	public override bool IsComplete()
	{
		if (HasAnyEngines() && HasDriverMountPoints())
		{
			return !IsDead();
		}
		return false;
	}

	public void DoDecayDamage(float damage)
	{
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			if (!attachedModuleEntity.IsDestroyed)
			{
				attachedModuleEntity.Hurt(damage, DamageType.Decay);
			}
		}
		if (!base.HasAnyModules)
		{
			Hurt(damage, DamageType.Decay);
		}
	}

	public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		float num = 0f;
		for (int i = 0; i < base.AttachedModuleEntities.Count; i++)
		{
			num += base.AttachedModuleEntities[i].GetAdjustedDriveForce(absSpeed, topSpeed);
		}
		return RollOffDriveForce(num);
	}

	public bool HasAnyEngines()
	{
		for (int i = 0; i < base.AttachedModuleEntities.Count; i++)
		{
			if (base.AttachedModuleEntities[i].HasAnEngine)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasAnyWorkingEngines()
	{
		return GetMaxDriveForce() > 0f;
	}

	public override bool MeetsEngineRequirements()
	{
		if (HasAnyWorkingEngines())
		{
			return HasDriver();
		}
		return false;
	}

	public override void OnEngineStartFailed()
	{
		bool arg = !HasAnyWorkingEngines() || engineController.IsWaterlogged();
		ClientRPC(RpcTarget.NetworkGroup("EngineStartFailed"), arg);
	}

	public CarWheel[] GetWheels()
	{
		if (wheels == null)
		{
			wheels = new CarWheel[4] { wheelFL, wheelFR, wheelRL, wheelRR };
		}
		return wheels;
	}

	public float GetWheelsMidPos()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		return (((Component)wheels[0].wheelCollider).transform.localPosition.z - ((Component)wheels[2].wheelCollider).transform.localPosition.z) * 0.5f;
	}

	public override bool AdminFixUp(int tier)
	{
		if (!base.AdminFixUp(tier))
		{
			return false;
		}
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			attachedModuleEntity.AdminFixUp(tier);
		}
		SendNetworkUpdate();
		return true;
	}

	public override void ModuleHurt(BaseVehicleModule hurtModule, HitInfo info)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.ModuleHurt(hurtModule, info);
		if (IsDead())
		{
			if (TimeSince.op_Implicit(timeSinceDeath) > 1f)
			{
				for (int i = 0; i < info.damageTypes.types.Length; i++)
				{
					deathDamageCounter += info.damageTypes.types[i];
				}
			}
			if (deathDamageCounter > 600f && !base.IsDestroyed)
			{
				Kill(DestroyMode.Gib);
			}
		}
		else if (hurtModule.PropagateDamage && info.damageTypes.Get(DamageType.Decay) == 0f)
		{
			PropagateDamageToModules(info, 0.15f, 0.4f, hurtModule);
		}
	}

	public void PropagateDamageToModules(HitInfo info, float minPropagationPercent, float maxPropagationPercent, BaseVehicleModule ignoreModule)
	{
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			if ((Object)(object)attachedModuleEntity == (Object)(object)ignoreModule || attachedModuleEntity.Health() <= 0f)
			{
				continue;
			}
			if (IsDead())
			{
				break;
			}
			float num = Random.Range(minPropagationPercent, maxPropagationPercent);
			for (int i = 0; i < info.damageTypes.types.Length; i++)
			{
				float num2 = info.damageTypes.types[i];
				if (num2 > 0f)
				{
					attachedModuleEntity.AcceptPropagatedDamage(num2 * num, (DamageType)i, info.Initiator, info.UseProtection);
				}
				if (IsDead())
				{
					break;
				}
			}
		}
	}

	public override void ModuleReachedZeroHealth()
	{
		if (IsDead())
		{
			return;
		}
		bool flag = true;
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			if (attachedModuleEntity.health > 0f)
			{
				flag = false;
				break;
			}
		}
		if (flag)
		{
			Die();
		}
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		DismountAllPlayers();
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			attachedModuleEntity.repair.enabled = false;
		}
		if (CarLock != null)
		{
			CarLock.RemoveLock();
		}
		timeSinceDeath = TimeSince.op_Implicit(0f);
		if (vehicle.carwrecks)
		{
			if (!base.HasAnyModules)
			{
				Kill(DestroyMode.Gib);
			}
			else
			{
				SendNetworkUpdate();
			}
		}
		else
		{
			Kill(DestroyMode.Gib);
		}
	}

	public void RemoveLock()
	{
		CarLock.RemoveLock();
	}

	public void RestoreVelocity(Vector3 vel)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 velocity = rigidBody.velocity;
		if (((Vector3)(ref velocity)).sqrMagnitude < ((Vector3)(ref vel)).sqrMagnitude)
		{
			vel.y = rigidBody.velocity.y;
			rigidBody.velocity = vel;
		}
	}

	public override Vector3 GetCOMMultiplier()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (carPhysics == null || !carPhysics.IsGrounded() || !IsOn())
		{
			return airbourneCOMMultiplier;
		}
		return groundedCOMMultiplier;
	}

	public void UpdateClients()
	{
		if (HasDriver())
		{
			byte num = (byte)((GetThrottleInput() + 1f) * 7f);
			byte b = (byte)(GetBrakeInput() * 15f);
			byte arg = (byte)(num + (b << 4));
			byte arg2 = (byte)(GetFuelFraction() * 255f);
			ClientRPC(RpcTarget.NetworkGroup("ModularCarUpdate"), SteerAngle, arg, DriveWheelVelocity, arg2);
		}
	}

	public void DecayTick()
	{
		if (base.IsDestroyed || IsOn() || immuneToDecay || Time.time < lastEngineOnTime + 600f)
		{
			return;
		}
		float num = 1f;
		if (IsDead())
		{
			int num2 = Mathf.Max(1, base.AttachedModuleEntities.Count);
			num /= 5f * (float)num2;
			DoDecayDamage(600f * num);
			return;
		}
		num /= outsidedecayminutes;
		if (!IsOutside())
		{
			num *= 0.1f;
		}
		float num3 = (base.HasAnyModules ? base.AttachedModuleEntities.Max((BaseVehicleModule module) => module.MaxHealth()) : MaxHealth());
		DoDecayDamage(num3 * num);
	}

	public override void DoCollisionDamage(BaseEntity hitEntity, float damage)
	{
		if ((Object)(object)hitEntity == (Object)null)
		{
			return;
		}
		if (hitEntity is BaseVehicleModule baseVehicleModule)
		{
			baseVehicleModule.Hurt(damage, DamageType.Collision, this, useProtection: false);
		}
		else
		{
			if (!((Object)(object)hitEntity == (Object)(object)this))
			{
				return;
			}
			if (base.HasAnyModules)
			{
				float amount = damage / (float)base.NumAttachedModules;
				{
					foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
					{
						attachedModuleEntity.AcceptPropagatedDamage(amount, DamageType.Collision, this, useProtection: false);
					}
					return;
				}
			}
			Hurt(damage, DamageType.Collision, this, useProtection: false);
		}
	}

	public void SpawnPreassignedModules()
	{
		if (!spawnSettings.useSpawnSettings || spawnSettings.configurationOptions.IsNullOrEmpty())
		{
			return;
		}
		ModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[Random.Range(0, spawnSettings.configurationOptions.Length)];
		if (Interface.CallHook("OnVehicleModulesAssign", (object)this, (object)modularCarPresetConfig.socketItemDefs) != null)
		{
			return;
		}
		for (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)
		{
			ItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];
			if ((Object)(object)itemModVehicleModule != (Object)null && base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))
			{
				Item item = ItemManager.Create(((Component)itemModVehicleModule).GetComponent<ItemDefinition>(), 1, 0uL);
				float num = Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);
				item.condition = item.maxCondition * num;
				if (!TryAddModule(item))
				{
					item.Remove();
				}
			}
		}
		Interface.CallHook("OnVehicleModulesAssigned", (object)this, (object)modularCarPresetConfig.socketItemDefs);
		((FacepunchBehaviour)this).Invoke((Action)HandleAdminBonus, 0f);
	}

	public void HandleAdminBonus()
	{
		switch (spawnSettings.adminBonus)
		{
		case SpawnSettings.AdminBonus.T1PlusFuel:
			AdminFixUp(1);
			break;
		case SpawnSettings.AdminBonus.T2PlusFuel:
			AdminFixUp(2);
			break;
		case SpawnSettings.AdminBonus.T3PlusFuel:
			AdminFixUp(3);
			break;
		}
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}

	[RPC_Server]
	public void RPC_OpenFuelWithKeycode(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		string codeEntered = msg.read.String(256, false);
		if (CarLock.TryOpenWithCode(player, codeEntered))
		{
			if (CanBeLooted(player))
			{
				GetFuelSystem().LootFuel(player);
			}
		}
		else
		{
			ClientRPC(RpcTarget.NetworkGroup("CodeEntryFailed"));
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_TryMountWithKeycode(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			string codeEntered = msg.read.String(256, false);
			if (CarLock.TryOpenWithCode(player, codeEntered))
			{
				WantsMount(player);
			}
			else
			{
				ClientRPC(RpcTarget.NetworkGroup("CodeEntryFailed"));
			}
		}
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		foreach (BaseVehicleModule attachedModuleEntity in base.AttachedModuleEntities)
		{
			if (attachedModuleEntity.HasSeating && attachedModuleEntity is VehicleModuleSeating vehicleModuleSeating && vehicleModuleSeating.IsOnThisModule(player))
			{
				attachedModuleEntity.ScaleDamageForPlayer(player, info);
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class SpawnSettings
{
	public enum AdminBonus
	{
		None,
		T1PlusFuel,
		T2PlusFuel,
		T3PlusFuel
	}

	[Tooltip("Must be true to use any of these settings.")]
	public bool useSpawnSettings;

	[Tooltip("Specify a list of possible module configurations that'll automatically spawn with this vehicle.")]
	public ModularCarPresetConfig[] configurationOptions;

	[Tooltip("Min health % at spawn for any modules that spawn with this chassis.")]
	public float minStartHealthPercent = 0.15f;

	[Tooltip("Max health  % at spawn for any modules that spawn with this chassis.")]
	public float maxStartHealthPercent = 0.5f;

	public AdminBonus adminBonus;
}


public enum AdminBonus
{
	None,
	T1PlusFuel,
	T2PlusFuel,
	T3PlusFuel
}


private class DriverSeatInputs
{
	public float steerInput;

	public bool steerMod;

	public float brakeInput;

	public float throttleInput;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ModularCarGarage : ContainerIOEntity
{
	[Serializable]
	public class ChassisBuildOption
	{
		public GameObjectRef prefab;

		public ItemDefinition itemDef;
	}

	public enum OccupantLock
	{
		CannotHaveLock,
		NoLock,
		HasLock
	}

	private enum VehicleLiftState
	{
		Down,
		Up
	}

	[SerializeField]
	public Transform vehicleLift;

	[SerializeField]
	public Animation vehicleLiftAnim;

	[SerializeField]
	private string animName = "LiftUp";

	[SerializeField]
	public VehicleLiftOccupantTrigger occupantTrigger;

	[SerializeField]
	public float liftMoveTime = 1f;

	[SerializeField]
	public EmissionToggle poweredLight;

	[SerializeField]
	public EmissionToggle inUseLight;

	[SerializeField]
	public Transform vehicleLiftPos;

	[Range(0f, 1f)]
	[SerializeField]
	public float recycleEfficiency = 0.5f;

	[SerializeField]
	public Transform recycleDropPos;

	[SerializeField]
	public bool needsElectricity;

	[SerializeField]
	private SoundDefinition liftStartSoundDef;

	[SerializeField]
	private SoundDefinition liftStopSoundDef;

	[SerializeField]
	private SoundDefinition liftStopDownSoundDef;

	[SerializeField]
	private SoundDefinition liftLoopSoundDef;

	[SerializeField]
	private GameObjectRef addRemoveLockEffect;

	[SerializeField]
	private GameObjectRef changeLockCodeEffect;

	[SerializeField]
	private GameObjectRef repairEffect;

	[SerializeField]
	private TriggerBase playerTrigger;

	public ChassisBuildOption[] chassisBuildOptions;

	public ItemAmount lockResourceCost;

	public VehicleLiftState vehicleLiftState;

	private Sound liftLoopSound;

	public Vector3 downPos;

	public const Flags Flag_DestroyingChassis = Flags.Reserved6;

	public const float TimeToDestroyChassis = 10f;

	public const Flags Flag_EnteringKeycode = Flags.Reserved7;

	public const Flags Flag_PlayerObstructing = Flags.Reserved8;

	public ModularCar lockedOccupant;

	public readonly HashSet<BasePlayer> lootingPlayers = new HashSet<BasePlayer>();

	public MagnetSnap magnetSnap;

	public bool PlatformIsOccupied { get; set; }

	public bool HasEditableOccupant { get; set; }

	public bool HasDriveableOccupant { get; set; }

	public OccupantLock OccupantLockState { get; set; }

	public bool LiftIsUp => vehicleLiftState == VehicleLiftState.Up;

	public bool LiftIsMoving => vehicleLiftAnim.isPlaying;

	public bool LiftIsDown => vehicleLiftState == VehicleLiftState.Down;

	public bool IsDestroyingChassis => HasFlag(Flags.Reserved6);

	private bool IsEnteringKeycode => HasFlag(Flags.Reserved7);

	public bool PlayerObstructingLift => HasFlag(Flags.Reserved8);

	public ModularCar carOccupant
	{
		get
		{
			if (!((Object)(object)lockedOccupant != (Object)null))
			{
				return occupantTrigger.carOccupant;
			}
			return lockedOccupant;
		}
	}

	public bool HasOccupant
	{
		get
		{
			if ((Object)(object)carOccupant != (Object)null)
			{
				return carOccupant.IsFullySpawned();
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ModularCarGarage.OnRpcMessage", 0);
		try
		{
			if (rpc == 554177909 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_DeselectedLootItem "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_DeselectedLootItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(554177909u, "RPC_DeselectedLootItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_DeselectedLootItem(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_DeselectedLootItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3683966290u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_DiedWithKeypadOpen "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_DiedWithKeypadOpen", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3683966290u, "RPC_DiedWithKeypadOpen", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3683966290u, "RPC_DiedWithKeypadOpen", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_DiedWithKeypadOpen(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_DiedWithKeypadOpen");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3659332720u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenEditing "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenEditing", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3659332720u, "RPC_OpenEditing", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3659332720u, "RPC_OpenEditing", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_OpenEditing(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_OpenEditing");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1582295101 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RepairItem "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RepairItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1582295101u, "RPC_RepairItem", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1582295101u, "RPC_RepairItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_RepairItem(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_RepairItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3710764312u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestAddLock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestAddLock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3710764312u, "RPC_RequestAddLock", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3710764312u, "RPC_RequestAddLock", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							RPC_RequestAddLock(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in RPC_RequestAddLock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3305106830u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestNewCode "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestNewCode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3305106830u, "RPC_RequestNewCode", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3305106830u, "RPC_RequestNewCode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							RPC_RequestNewCode(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in RPC_RequestNewCode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1046853419 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestRemoveLock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestRemoveLock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1046853419u, "RPC_RequestRemoveLock", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1046853419u, "RPC_RequestRemoveLock", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							RPC_RequestRemoveLock(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in RPC_RequestRemoveLock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4033916654u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SelectedLootItem "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SelectedLootItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4033916654u, "RPC_SelectedLootItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg9 = rPCMessage;
							RPC_SelectedLootItem(msg9);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogException(ex8);
						player.Kick("RPC Error in RPC_SelectedLootItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2974124904u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_StartDestroyingChassis "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_StartDestroyingChassis", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2974124904u, "RPC_StartDestroyingChassis", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2974124904u, "RPC_StartDestroyingChassis", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2974124904u, "RPC_StartDestroyingChassis", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg10 = rPCMessage;
							RPC_StartDestroyingChassis(msg10);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in RPC_StartDestroyingChassis");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3872977075u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_StartKeycodeEntry "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_StartKeycodeEntry", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3872977075u, "RPC_StartKeycodeEntry", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg11 = rPCMessage;
							RPC_StartKeycodeEntry(msg11);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogException(ex10);
						player.Kick("RPC Error in RPC_StartKeycodeEntry");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3830531963u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_StopDestroyingChassis "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_StopDestroyingChassis", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3830531963u, "RPC_StopDestroyingChassis", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3830531963u, "RPC_StopDestroyingChassis", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3830531963u, "RPC_StopDestroyingChassis", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg12 = rPCMessage;
							RPC_StopDestroyingChassis(msg12);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogException(ex11);
						player.Kick("RPC Error in RPC_StopDestroyingChassis");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		downPos = ((Component)vehicleLift).transform.position;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			UpdateOccupantMode();
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (IsOn())
		{
			return base.CanBeLooted(player);
		}
		return false;
	}

	public override int ConsumptionAmount()
	{
		return 5;
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}

	public void SetOccupantState(bool hasOccupant, bool editableOccupant, bool driveableOccupant, OccupantLock occupantLockState, bool forced = false)
	{
		if (PlatformIsOccupied == hasOccupant && HasEditableOccupant == editableOccupant && HasDriveableOccupant == driveableOccupant && OccupantLockState == occupantLockState && !forced)
		{
			return;
		}
		bool hasEditableOccupant = HasEditableOccupant;
		PlatformIsOccupied = hasOccupant;
		HasEditableOccupant = editableOccupant;
		HasDriveableOccupant = driveableOccupant;
		OccupantLockState = occupantLockState;
		if (base.isServer)
		{
			UpdateOccupantMode();
			SendNetworkUpdate();
			if (hasEditableOccupant && !editableOccupant)
			{
				EditableOccupantLeft();
			}
			else if (editableOccupant && !hasEditableOccupant)
			{
				EditableOccupantEntered();
			}
		}
		RefreshLiftState();
	}

	public void RefreshLiftState(bool forced = false)
	{
		VehicleLiftState desiredLiftState = ((IsOpen() || IsEnteringKeycode || (HasEditableOccupant && !HasDriveableOccupant)) ? VehicleLiftState.Up : VehicleLiftState.Down);
		MoveLift(desiredLiftState, 0f, forced);
	}

	public void MoveLift(VehicleLiftState desiredLiftState, float startDelay = 0f, bool forced = false)
	{
		if (vehicleLiftState != desiredLiftState || forced)
		{
			_ = vehicleLiftState;
			vehicleLiftState = desiredLiftState;
			if (base.isServer)
			{
				UpdateOccupantMode();
				WakeNearbyRigidbodies();
			}
			if (!((Component)this).gameObject.activeSelf)
			{
				vehicleLiftAnim[animName].time = ((desiredLiftState == VehicleLiftState.Up) ? 1f : 0f);
				vehicleLiftAnim.Play();
			}
			else if (desiredLiftState == VehicleLiftState.Up)
			{
				((FacepunchBehaviour)this).Invoke((Action)MoveLiftUp, startDelay);
			}
			else
			{
				((FacepunchBehaviour)this).Invoke((Action)MoveLiftDown, startDelay);
			}
		}
	}

	public void MoveLiftUp()
	{
		AnimationState obj = vehicleLiftAnim[animName];
		obj.speed = obj.length / liftMoveTime;
		vehicleLiftAnim.Play();
	}

	public void MoveLiftDown()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		AnimationState val = vehicleLiftAnim[animName];
		val.speed = val.length / liftMoveTime;
		if (!vehicleLiftAnim.isPlaying && Vector3.Distance(((Component)vehicleLift).transform.position, downPos) > 0.01f)
		{
			val.time = 1f;
		}
		val.speed *= -1f;
		vehicleLiftAnim.Play();
	}

	public void FixedUpdate()
	{
		if (!base.isServer || magnetSnap == null)
		{
			return;
		}
		if ((Object)(object)playerTrigger != (Object)null)
		{
			bool hasAnyContents = playerTrigger.HasAnyContents;
			if (PlayerObstructingLift != hasAnyContents)
			{
				SetFlag(Flags.Reserved8, hasAnyContents);
			}
		}
		UpdateCarOccupant();
		if (HasOccupant && carOccupant.CouldBeEdited() && carOccupant.GetSpeed() <= 1f)
		{
			if (IsOn() || !carOccupant.IsComplete())
			{
				if ((Object)(object)lockedOccupant == (Object)null && !carOccupant.rigidBody.isKinematic)
				{
					GrabOccupant(occupantTrigger.carOccupant);
				}
				magnetSnap.FixedUpdate(((Component)carOccupant).transform);
			}
			if (carOccupant.CarLock.HasALock && !carOccupant.CarLock.CanHaveALock())
			{
				carOccupant.CarLock.RemoveLock();
			}
		}
		else if (HasOccupant && carOccupant.rigidBody.isKinematic)
		{
			ReleaseOccupant();
		}
		if (HasOccupant && IsDestroyingChassis && carOccupant.HasAnyModules)
		{
			StopChassisDestroy();
		}
	}

	internal override void DoServerDestroy()
	{
		if (HasOccupant)
		{
			ReleaseOccupant();
			if (!HasDriveableOccupant)
			{
				carOccupant.Kill(DestroyMode.Gib);
			}
		}
		base.DoServerDestroy();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		magnetSnap = new MagnetSnap(vehicleLiftPos);
		RefreshOnOffState();
		SetOccupantState(hasOccupant: false, editableOccupant: false, driveableOccupant: false, OccupantLock.CannotHaveLock, forced: true);
		RefreshLiftState(forced: true);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.vehicleLift = Pool.Get<VehicleLift>();
		info.msg.vehicleLift.platformIsOccupied = PlatformIsOccupied;
		info.msg.vehicleLift.editableOccupant = HasEditableOccupant;
		info.msg.vehicleLift.driveableOccupant = HasDriveableOccupant;
		info.msg.vehicleLift.occupantLockState = (int)OccupantLockState;
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (PlatformIsOccupied)
		{
			pickupErrorToFormat = (format: PickupErrors.ItemIsOccupied, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public override ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return default(ItemContainerId);
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		SetFlag(Flags.Reserved7, b: false);
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		bool flag = base.PlayerOpenLoot(player, panelToOpen);
		if (!flag)
		{
			return false;
		}
		if (HasEditableOccupant)
		{
			player.inventory.loot.AddContainer(carOccupant.Inventory.ModuleContainer);
			player.inventory.loot.AddContainer(carOccupant.Inventory.ChassisContainer);
			player.inventory.loot.SendImmediate();
		}
		lootingPlayers.Add(player);
		RefreshLiftState();
		return flag;
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		if (!IsEnteringKeycode)
		{
			lootingPlayers.Remove(player);
			RefreshLiftState();
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		RefreshOnOffState();
	}

	public bool TryGetModuleForItem(Item item, out BaseVehicleModule result)
	{
		if (!HasOccupant)
		{
			result = null;
			return false;
		}
		result = carOccupant.GetModuleForItem(item);
		return (Object)(object)result != (Object)null;
	}

	public void RefreshOnOffState()
	{
		bool flag = !needsElectricity || currentEnergy >= ConsumptionAmount();
		if (flag != IsOn())
		{
			SetFlag(Flags.On, flag);
		}
	}

	public void UpdateCarOccupant()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			if (HasOccupant)
			{
				bool editableOccupant = Vector3.SqrMagnitude(((Component)carOccupant).transform.position - vehicleLiftPos.position) < 1f && carOccupant.CouldBeEdited() && !PlayerObstructingLift;
				bool driveableOccupant = carOccupant.IsComplete();
				SetOccupantState(occupantLockState: carOccupant.CarLock.CanHaveALock() ? ((!carOccupant.CarLock.HasALock) ? OccupantLock.NoLock : OccupantLock.HasLock) : OccupantLock.CannotHaveLock, hasOccupant: HasOccupant, editableOccupant: editableOccupant, driveableOccupant: driveableOccupant);
			}
			else
			{
				SetOccupantState(hasOccupant: false, editableOccupant: false, driveableOccupant: false, OccupantLock.CannotHaveLock);
			}
		}
	}

	public void UpdateOccupantMode()
	{
		if (HasOccupant)
		{
			carOccupant.inEditableLocation = HasEditableOccupant && LiftIsUp;
			carOccupant.immuneToDecay = IsOn();
		}
	}

	public void WakeNearbyRigidbodies()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(((Component)this).transform.position, 7f, list, 34816, (QueryTriggerInteraction)2);
		foreach (Collider item in list)
		{
			Rigidbody attachedRigidbody = item.attachedRigidbody;
			if ((Object)(object)attachedRigidbody != (Object)null && attachedRigidbody.IsSleeping())
			{
				attachedRigidbody.WakeUp();
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	public void EditableOccupantEntered()
	{
		RefreshLoot();
	}

	public void EditableOccupantLeft()
	{
		RefreshLoot();
	}

	public void RefreshLoot()
	{
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		list.AddRange(lootingPlayers);
		foreach (BasePlayer item in list)
		{
			item.inventory.loot.Clear();
			PlayerOpenLoot(item);
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	public void GrabOccupant(ModularCar occupant)
	{
		if (!((Object)(object)occupant == (Object)null))
		{
			lockedOccupant = occupant;
			lockedOccupant.DisablePhysics();
		}
	}

	public void ReleaseOccupant()
	{
		if (HasOccupant)
		{
			carOccupant.inEditableLocation = false;
			carOccupant.immuneToDecay = false;
			if ((Object)(object)lockedOccupant != (Object)null)
			{
				lockedOccupant.EnablePhysics();
				lockedOccupant = null;
			}
		}
	}

	public void StopChassisDestroy()
	{
		if (((FacepunchBehaviour)this).IsInvoking((Action)FinishDestroyingChassis))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FinishDestroyingChassis);
		}
		SetFlag(Flags.Reserved6, b: false);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RepairItem(RPCMessage msg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		ItemId val = msg.read.ItemID();
		if (!((Object)(object)player == (Object)null) && HasOccupant)
		{
			Item vehicleItem = carOccupant.GetVehicleItem(val);
			if (vehicleItem != null)
			{
				RepairBench.RepairAnItem(vehicleItem, player, this, 0f, mustKnowBlueprint: false);
				Effect.server.Run(repairEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			else
			{
				string name = ((object)this).GetType().Name;
				ItemId val2 = val;
				Debug.LogError((object)(name + ": Couldn't get item to repair, with ID: " + ((object)(ItemId)(ref val2)/*cast due to .constrained prefix*/).ToString()));
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_OpenEditing(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !LiftIsMoving)
		{
			PlayerOpenLoot(player);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_DiedWithKeypadOpen(RPCMessage msg)
	{
		SetFlag(Flags.Reserved7, b: false);
		lootingPlayers.Clear();
		RefreshLiftState();
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_SelectedLootItem(RPCMessage msg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		ItemId itemUID = msg.read.ItemID();
		if ((Object)(object)player == (Object)null || !player.inventory.loot.IsLooting() || (Object)(object)player.inventory.loot.entitySource != (Object)(object)this || !HasOccupant)
		{
			return;
		}
		Item vehicleItem = carOccupant.GetVehicleItem(itemUID);
		if (vehicleItem == null || Interface.CallHook("OnVehicleModuleSelect", (object)vehicleItem, (object)this, (object)player) != null)
		{
			return;
		}
		bool flag = player.inventory.loot.RemoveContainerAt(3);
		if (TryGetModuleForItem(vehicleItem, out var result))
		{
			if (result is VehicleModuleStorage vehicleModuleStorage)
			{
				IItemContainerEntity container = vehicleModuleStorage.GetContainer();
				if (!container.IsUnityNull())
				{
					player.inventory.loot.AddContainer(container.inventory);
					flag = true;
				}
			}
			else if (result is VehicleModuleCamper vehicleModuleCamper)
			{
				IItemContainerEntity container2 = vehicleModuleCamper.GetContainer();
				if (!container2.IsUnityNull())
				{
					player.inventory.loot.AddContainer(container2.inventory);
					flag = true;
				}
			}
		}
		if (flag)
		{
			player.inventory.loot.SendImmediate();
		}
		Interface.CallHook("OnVehicleModuleSelected", (object)vehicleItem, (object)this, (object)player);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_DeselectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.inventory.loot.IsLooting() && !((Object)(object)player.inventory.loot.entitySource != (Object)(object)this))
		{
			if (player.inventory.loot.RemoveContainerAt(3))
			{
				player.inventory.loot.SendImmediate();
			}
			Interface.CallHook("OnVehicleModuleDeselected", (object)this, (object)player);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_StartKeycodeEntry(RPCMessage msg)
	{
		SetFlag(Flags.Reserved7, b: true);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RequestAddLock(RPCMessage msg)
	{
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		if (!HasOccupant || carOccupant.CarLock.HasALock)
		{
			return;
		}
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		string text = msg.read.String(256, false);
		if (Interface.CallHook("OnVehicleLockRequest", (object)this, (object)player, (object)text) == null)
		{
			ItemAmount itemAmount = lockResourceCost;
			if ((float)player.inventory.GetAmount(itemAmount.itemDef.itemid) >= itemAmount.amount && carOccupant.CarLock.TryAddALock(text, player.userID))
			{
				player.inventory.Take(null, itemAmount.itemDef.itemid, Mathf.CeilToInt(itemAmount.amount));
				Effect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RequestRemoveLock(RPCMessage msg)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (HasOccupant && carOccupant.CarLock.HasALock && Interface.CallHook("OnLockRemove", (object)carOccupant, (object)msg.player) == null)
		{
			carOccupant.CarLock.RemoveLock();
			Effect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RequestNewCode(RPCMessage msg)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (!HasOccupant || !carOccupant.CarLock.HasALock)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			string text = msg.read.String(256, false);
			if (Interface.CallHook("OnCodeChange", (object)carOccupant, (object)player, (object)text) == null && carOccupant.CarLock.TrySetNewCode(text, player.userID))
			{
				Effect.server.Run(changeLockCodeEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_StartDestroyingChassis(RPCMessage msg)
	{
		if (!carOccupant.HasAnyModules)
		{
			((FacepunchBehaviour)this).Invoke((Action)FinishDestroyingChassis, 10f);
			SetFlag(Flags.Reserved6, b: true);
		}
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_StopDestroyingChassis(RPCMessage msg)
	{
		StopChassisDestroy();
	}

	public void FinishDestroyingChassis()
	{
		if (HasOccupant && !carOccupant.HasAnyModules)
		{
			carOccupant.Kill(DestroyMode.Gib);
			SetFlag(Flags.Reserved6, b: false);
		}
	}
}


using System;

[Serializable]
public class ChassisBuildOption
{
	public GameObjectRef prefab;

	public ItemDefinition itemDef;
}


public enum OccupantLock
{
	CannotHaveLock,
	NoLock,
	HasLock
}


private enum VehicleLiftState
{
	Down,
	Up
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class ModularCarOven : BaseOven
{
	private BaseVehicleModule moduleParent;

	private BaseVehicleModule ModuleParent
	{
		get
		{
			if ((Object)(object)moduleParent != (Object)null)
			{
				return moduleParent;
			}
			moduleParent = GetParentEntity() as BaseVehicleModule;
			return moduleParent;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ModularCarOven.OnRpcMessage", 0);
		try
		{
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SVSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4167839872u, "SVSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SVSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SVSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		moduleParent = null;
	}

	protected override void SVSwitch(RPCMessage msg)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)ModuleParent == (Object)null) && ModuleParent.CanBeLooted(msg.player) && !WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: false))
		{
			base.SVSwitch(msg);
		}
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if ((Object)(object)ModuleParent == (Object)null || !ModuleParent.CanBeLooted(player))
		{
			return false;
		}
		return base.PlayerOpenLoot(player, panelToOpen, doPositionChecks);
	}

	protected override void OnCooked()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.OnCooked();
		if (WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: false))
		{
			StopCooking();
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class ModularCarRadio : BaseCombatEntity
{
	public BoomBox CarRadio;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ModularCarRadio.OnRpcMessage", 0);
		try
		{
			if (rpc == 1918716764 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_UpdateRadioIP "));
				}
				TimeWarning val2 = TimeWarning.New("Server_UpdateRadioIP", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1918716764u, "Server_UpdateRadioIP", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1918716764u, "Server_UpdateRadioIP", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_UpdateRadioIP(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_UpdateRadioIP");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1785864031 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerTogglePlay "));
				}
				TimeWarning val2 = TimeWarning.New("ServerTogglePlay", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1785864031u, "ServerTogglePlay", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1785864031u, "ServerTogglePlay", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ServerTogglePlay(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ServerTogglePlay");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	public void TryForceOff()
	{
		if ((Object)(object)CarRadio != (Object)null)
		{
			CarRadio.ServerTogglePlay(play: false);
		}
	}

	public BaseVehicleModule GetParentModule()
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity is BaseVehicleModule result)
		{
			return result;
		}
		return null;
	}

	public ModularCar GetParentCar()
	{
		BaseVehicleModule parentModule = GetParentModule();
		if ((Object)(object)parentModule != (Object)null && parentModule.Vehicle is ModularCar result)
		{
			return result;
		}
		return null;
	}

	private bool CanPickupRadio(BasePlayer player)
	{
		ModularCar parentCar = GetParentCar();
		if ((Object)(object)parentCar != (Object)null)
		{
			return parentCar.PlayerHasUnlockPermission(player);
		}
		return false;
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (CanPickupRadio(player))
		{
			return base.ShouldDisplayPickupOption(player);
		}
		return false;
	}

	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void ServerTogglePlay(RPCMessage msg)
	{
		CarRadio.ServerTogglePlay(msg, bypassPower: true);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	private void Server_UpdateRadioIP(RPCMessage msg)
	{
		CarRadio.Server_UpdateRadioIP(msg);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		CarRadio.Save(info);
	}

	public override void Load(LoadInfo info)
	{
		CarRadio.Load(info);
		base.Load(info);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class MotorRowboat : BaseBoat
{
	[Header("Audio")]
	public BlendedSoundLoops engineLoops;

	public BlendedSoundLoops waterLoops;

	public BlendedLoopEngineSound rpmEngineLoops;

	public SoundDefinition engineStartSoundDef;

	public SoundDefinition engineStopSoundDef;

	public SoundDefinition movementSplashAccentSoundDef;

	public SoundDefinition engineSteerSoundDef;

	public GameObjectRef pushLandEffect;

	public GameObjectRef pushWaterEffect;

	public float waterSpeedDivisor = 10f;

	public float turnPitchModScale = -0.25f;

	public float tiltPitchModScale = 0.3f;

	public float splashAccentFrequencyMin = 1f;

	public float splashAccentFrequencyMax = 10f;

	protected const Flags Flag_ReverseThrottle = Flags.Reserved12;

	protected const Flags Flag_ThrottleOn = Flags.Reserved2;

	protected const Flags Flag_TurnLeft = Flags.Reserved3;

	protected const Flags Flag_TurnRight = Flags.Reserved4;

	protected const Flags Flag_HasFuel = Flags.Reserved6;

	protected const Flags Flag_RecentlyPushed = Flags.Reserved8;

	protected const Flags Flag_Submerged = Flags.Reserved9;

	protected const Flags Flag_Dying = Flags.Broken;

	public const float submergeFractionMinimum = 0.85f;

	public float deathSinkRate = 0.1f;

	[Header("Fuel")]
	public GameObjectRef fuelStoragePrefab;

	public float fuelPerSec;

	[Header("Storage")]
	public GameObjectRef storageUnitPrefab;

	public EntityRef<StorageContainer> storageUnitInstance;

	[Header("Effects")]
	public Transform boatRear;

	public ParticleSystemContainer wakeEffect;

	public ParticleSystemContainer engineEffectIdle;

	public ParticleSystemContainer engineEffectThrottle;

	[Tooltip("If not supplied, with use engineEffectThrottle for both")]
	public ParticleSystemContainer engineEffectThrottleReverse;

	[Tooltip("Only needed if using a forwardTravelEffect")]
	public Transform boatFront;

	public ParticleSystemContainer forwardTravelEffect;

	public float forwardTravelEffectMinSpeed = 1f;

	public Projector causticsProjector;

	public Transform causticsDepthTest;

	public Transform engineLeftHandPosition;

	public Transform engineRotate;

	public float engineRotateRangeMultiplier = 1f;

	public Transform propellerRotate;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population = 1f;

	[ServerVar(Help = "How long before a boat loses all its health while outside. If it's in deep water, deepwaterdecayminutes is used")]
	public static float outsidedecayminutes = 180f;

	[ServerVar(Help = "How long before a boat loses all its health while in deep water")]
	public static float deepwaterdecayminutes = 120f;

	[ServerVar(Help = "How long until decay begins after the boat was last used")]
	public static float decaystartdelayminutes = 45f;

	public EntityFuelSystem fuelSystem;

	public Transform[] stationaryDismounts;

	public TimeSince timeSinceLastUsedFuel;

	public float angularDragBase = 0.5f;

	public float engineOffAngularDragMultiplier = 1f;

	public float angularDragVelocity = 0.5f;

	public float landDrag = 0.2f;

	public float waterDrag = 0.8f;

	public float engineOffWaterDragMultiplier = 1f;

	public float offAxisDrag = 1f;

	public float offAxisDot = 0.25f;

	protected const float DECAY_TICK_TIME = 60f;

	private TimeSince startedFlip;

	protected float lastHadDriverTime;

	public const float maxVelForStationaryDismount = 4f;

	public bool IsDying => HasFlag(Flags.Broken);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MotorRowboat.OnRpcMessage", 0);
		try
		{
			if (rpc == 1873751172 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_EngineToggle "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_EngineToggle", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_EngineToggle(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_EngineToggle");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						RPC_OpenFuel(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		fuelSystem = new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		timeSinceLastUsedFuel = TimeSince.op_Implicit(0f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)BoatDecay, Random.Range(30f, 60f), 60f, 6f);
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer)
		{
			if (isSpawned)
			{
				fuelSystem.CheckNewChild(child);
			}
			if (storageUnitPrefab.isValid && child.prefabID == storageUnitPrefab.GetEntity().prefabID)
			{
				storageUnitInstance.Set((StorageContainer)child);
			}
		}
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot && storageUnitInstance.IsValid(base.isServer))
		{
			storageUnitInstance.Get(base.isServer).DropItems();
		}
		base.DoServerDestroy();
	}

	public override IFuelSystem GetFuelSystem()
	{
		return fuelSystem;
	}

	public override int StartingFuelUnits()
	{
		return 50;
	}

	public virtual void BoatDecay()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!IsDying)
		{
			BaseBoat.WaterVehicleDecay(this, 60f, TimeSince.op_Implicit(timeSinceLastUsedFuel), outsidedecayminutes, deepwaterdecayminutes, decaystartdelayminutes, preventDecayIndoors);
		}
	}

	public override void DoPushAction(BasePlayer player)
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		if (IsFlipped())
		{
			Vector3 val = ((Component)this).transform.InverseTransformPoint(((Component)player).transform.position);
			float num = 4f;
			if (val.x > 0f)
			{
				num = 0f - num;
			}
			rigidBody.AddRelativeTorque(Vector3.forward * num, (ForceMode)2);
			rigidBody.AddForce(Vector3.up * 4f, (ForceMode)2);
			startedFlip = TimeSince.op_Implicit(0f);
			((FacepunchBehaviour)this).InvokeRepeatingFixedTime((Action)FlipMonitor);
		}
		else
		{
			Vector3 val2 = Vector3Ex.Direction2D(((Component)player).transform.position, ((Component)this).transform.position);
			Vector3 val3 = Vector3Ex.Direction2D(((Component)player).transform.position + player.eyes.BodyForward() * 3f, ((Component)player).transform.position);
			Vector3 val4 = Vector3.up * 0.1f + val3;
			val3 = ((Vector3)(ref val4)).normalized;
			Vector3 val5 = ((Component)this).transform.position + val2 * 2f;
			float num2 = 3f;
			float num3 = Vector3.Dot(((Component)this).transform.forward, val3);
			num2 += Mathf.InverseLerp(0.8f, 1f, num3) * 3f;
			rigidBody.AddForceAtPosition(val3 * num2, val5, (ForceMode)2);
		}
		if (HasFlag(Flags.Reserved9))
		{
			if (pushWaterEffect.isValid)
			{
				Effect.server.Run(pushWaterEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		else if (pushLandEffect.isValid)
		{
			Effect.server.Run(pushLandEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
		WakeUp();
	}

	private void FlipMonitor()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Dot(Vector3.up, ((Component)this).transform.up);
		rigidBody.angularVelocity = Vector3.Lerp(rigidBody.angularVelocity, Vector3.zero, Time.fixedDeltaTime * 8f * num);
		if (TimeSince.op_Implicit(startedFlip) > 3f)
		{
			((FacepunchBehaviour)this).CancelInvokeFixedTime((Action)FlipMonitor);
		}
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && IsDriver(player))
		{
			fuelSystem.LootFuel(player);
		}
	}

	[RPC_Server]
	public void RPC_EngineToggle(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			bool flag = msg.read.Bit();
			if (InDryDock())
			{
				flag = false;
			}
			if (IsDriver(player) && flag != EngineOn())
			{
				EngineToggle(flag);
			}
		}
	}

	public void EngineToggle(bool wantsOn)
	{
		if (!fuelSystem.HasFuel(forceCheck: true))
		{
			return;
		}
		BasePlayer driver = GetDriver();
		if (!wantsOn || Interface.CallHook("OnEngineStart", (object)this, (object)driver) == null)
		{
			SetFlag(Flags.On, wantsOn);
			if (wantsOn)
			{
				Interface.CallHook("OnEngineStarted", (object)this, (object)driver);
			}
			if (wantsOn)
			{
				rigidBody.WakeUp();
				buoyancy.Wake();
			}
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		((FacepunchBehaviour)this).Invoke((Action)CheckInvalidBoat, 1f);
		if (base.health <= 0f)
		{
			EnterCorpseState();
			buoyancy.buoyancyScale = 0f;
			SetFlag(Flags.Broken, b: true);
		}
	}

	public virtual void CheckInvalidBoat()
	{
		bool num = fuelStoragePrefab.isValid && !fuelSystem.HasValidInstance(base.isServer);
		bool flag = storageUnitPrefab.isValid && !storageUnitInstance.IsValid(base.isServer);
		if (num || flag)
		{
			Debug.Log((object)"Destroying invalid boat ");
			((FacepunchBehaviour)this).Invoke((Action)ActualDeath, 1f);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
	}

	public override bool EngineOn()
	{
		return IsOn();
	}

	public float TimeSinceDriver()
	{
		return Time.time - lastHadDriverTime;
	}

	public void DriverHeartbeat()
	{
		lastHadDriverTime = Time.time;
	}

	public override void DriverInput(InputState inputState, BasePlayer player)
	{
		base.DriverInput(inputState, player);
		DriverHeartbeat();
	}

	public override void VehicleFixedUpdate()
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		if (IsTransferProtected())
		{
			return;
		}
		TimeWarning val = TimeWarning.New("MotorRowboat.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			float num = TimeSinceDriver();
			if (num > 15f)
			{
				steering += Mathf.InverseLerp(15f, 30f, num);
				steering = Mathf.Clamp(-1f, 1f, steering);
				if (num > 75f)
				{
					gasPedal = 0f;
				}
			}
			SetFlags();
			UpdateDrag();
			if (IsDying)
			{
				buoyancy.buoyancyScale = Mathf.Lerp(buoyancy.buoyancyScale, 0f, Time.fixedDeltaTime * deathSinkRate);
			}
			else
			{
				float num2 = 1f;
				float num3 = Vector3Ex.Magnitude2D(rigidBody.velocity);
				float num4 = Mathf.InverseLerp(1f, 10f, num3) * 0.5f * base.healthFraction;
				if (!EngineOn())
				{
					num4 = 0f;
				}
				float num5 = 1f - 0.3f * (1f - base.healthFraction);
				buoyancy.buoyancyScale = (num2 + num4) * num5;
			}
			if (EngineOn())
			{
				float num6 = (HasFlag(Flags.Reserved2) ? 1f : 0.0333f);
				fuelSystem.TryUseFuel(Time.fixedDeltaTime * num6, fuelPerSec);
				timeSinceLastUsedFuel = TimeSince.op_Implicit(0f);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SetFlags()
	{
		TimeWarning val = TimeWarning.New("SetFlag", 0);
		try
		{
			Flags num = flags;
			SetFlag(Flags.Reserved3, steering > 0f, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved4, steering < 0f, recursive: false, networkupdate: false);
			SetFlag(Flags.On, EngineOnEligible(), recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, EngineOn() && gasPedal != 0f, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved12, EngineOn() && gasPedal < 0f, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved9, buoyancy.submergedFraction > 0.85f, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved6, fuelSystem.HasFuel(), recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved8, base.RecentlyPushed, recursive: false, networkupdate: false);
			if (num != flags)
			{
				((FacepunchBehaviour)this).Invoke((Action)base.SendNetworkUpdate_Flags, 0f);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override bool EngineOnEligible()
	{
		if (!base.EngineOnEligible())
		{
			return false;
		}
		if (fuelSystem.HasFuel())
		{
			return TimeSinceDriver() < 75f;
		}
		return false;
	}

	protected override bool DetermineIfStationary()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localVelocity = GetLocalVelocity();
		if (((Vector3)(ref localVelocity)).sqrMagnitude < 0.5f)
		{
			return !AnyMounted();
		}
		return false;
	}

	public override void SeatClippedWorld(BaseMountable mountable)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer mounted = mountable.GetMounted();
		if (!((Object)(object)mounted == (Object)null))
		{
			if (IsDriver(mounted))
			{
				steering = 0f;
				gasPedal = 0f;
			}
			Vector3 velocity = rigidBody.velocity;
			float num = Mathf.InverseLerp(4f, 20f, ((Vector3)(ref velocity)).magnitude);
			if (num > 0f)
			{
				mounted.Hurt(num * 100f, DamageType.Blunt, this, useProtection: false);
			}
			if ((Object)(object)mounted != (Object)null && mounted.isMounted)
			{
				base.SeatClippedWorld(mountable);
			}
		}
	}

	public void UpdateDrag()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3Ex.SqrMagnitude2D(rigidBody.velocity);
		float num2 = Mathf.InverseLerp(0f, 2f, num);
		float num3 = angularDragBase * (IsOn() ? 1f : engineOffAngularDragMultiplier);
		rigidBody.angularDrag = num3 + angularDragVelocity * num2;
		float num4 = (IsOn() ? waterDrag : (waterDrag * engineOffWaterDragMultiplier));
		rigidBody.drag = landDrag + num4 * Mathf.InverseLerp(0f, 1f, buoyancy.submergedFraction);
		if (offAxisDrag > 0f)
		{
			Vector3 forward = ((Component)this).transform.forward;
			Vector3 velocity = rigidBody.velocity;
			float num5 = Vector3.Dot(forward, ((Vector3)(ref velocity)).normalized);
			float num6 = Mathf.InverseLerp(0.98f, 0.92f, num5);
			Rigidbody obj = rigidBody;
			obj.drag += num6 * offAxisDrag * buoyancy.submergedFraction;
		}
	}

	public override void OnDied(HitInfo info)
	{
		if (!IsDying)
		{
			SetFlag(Flags.Broken, b: true);
			repair.enabled = false;
			((FacepunchBehaviour)this).Invoke((Action)DismountAllPlayers, 10f);
			EnterCorpseState();
		}
	}

	protected virtual void EnterCorpseState()
	{
		((FacepunchBehaviour)this).Invoke((Action)ActualDeath, vehicle.boat_corpse_seconds);
	}

	public void ActualDeath()
	{
		Kill(DestroyMode.Gib);
	}

	public override bool MountEligable(BasePlayer player)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (IsDying)
		{
			return false;
		}
		Vector3 velocity = rigidBody.velocity;
		if (((Vector3)(ref velocity)).magnitude >= 5f && HasDriver())
		{
			return false;
		}
		return base.MountEligable(player);
	}

	public override bool HasValidDismountPosition(BasePlayer player)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 worldVelocity = GetWorldVelocity();
		if (((Vector3)(ref worldVelocity)).magnitude <= 4f)
		{
			Transform[] array = stationaryDismounts;
			foreach (Transform val in array)
			{
				if (ValidDismountPosition(player, ((Component)val).transform.position))
				{
					return true;
				}
			}
		}
		return base.HasValidDismountPosition(player);
	}

	public override bool GetDismountPosition(BasePlayer player, out Vector3 res, bool silent = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		Vector3 velocity = rigidBody.velocity;
		if (((Vector3)(ref velocity)).magnitude <= 4f)
		{
			List<Vector3> list = Pool.Get<List<Vector3>>();
			Transform[] array = stationaryDismounts;
			foreach (Transform val in array)
			{
				if (ValidDismountPosition(player, ((Component)val).transform.position))
				{
					list.Add(((Component)val).transform.position);
				}
			}
			if (list.Count > 0)
			{
				Vector3 pos = ((Component)player).transform.position;
				list.Sort((Vector3 a, Vector3 b) => Vector3.Distance(a, pos).CompareTo(Vector3.Distance(b, pos)));
				res = list[0];
				Pool.FreeUnmanaged<Vector3>(ref list);
				return true;
			}
			Pool.FreeUnmanaged<Vector3>(ref list);
		}
		return base.GetDismountPosition(player, out res, silent: false);
	}

	public override void DisableTransferProtection()
	{
		if ((Object)(object)GetDriver() != (Object)null && IsOn())
		{
			gasPedal = 0f;
			steering = 0f;
			lastHadDriverTime = Time.time;
		}
		base.DisableTransferProtection();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.motorBoat = Pool.Get<Motorboat>();
		info.msg.motorBoat.storageid = storageUnitInstance.uid;
		info.msg.motorBoat.fuelStorageID = fuelSystem.GetInstanceID();
	}

	public override bool CanPushNow(BasePlayer pusher)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (!IsStationary() || (!(pusher.WaterFactor() <= 0.6f) && !IsFlipped()))
		{
			return false;
		}
		if (!IsFlipped() && pusher.IsStandingOnEntity(this, 8192))
		{
			return false;
		}
		if (Vector3.Distance(((Component)pusher).transform.position, ((Component)this).transform.position) > 5f)
		{
			return false;
		}
		if (IsDying)
		{
			return false;
		}
		if (!pusher.isMounted && pusher.IsOnGround() && base.healthFraction > 0f)
		{
			return ShowPushMenu(pusher);
		}
		return false;
	}

	private bool ShowPushMenu(BasePlayer player)
	{
		if (!IsFlipped() && player.IsStandingOnEntity(this, 8192))
		{
			return false;
		}
		if (IsStationary())
		{
			if (!(player.WaterFactor() <= 0.6f))
			{
				return IsFlipped();
			}
			return true;
		}
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.motorBoat != null)
		{
			fuelSystem.SetInstanceID(info.msg.motorBoat.fuelStorageID);
			storageUnitInstance.uid = info.msg.motorBoat.storageid;
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using Rust.Safety;
using UnityEngine;
using UnityEngine.Assertions;

public class MountedWeapon : StorageContainer
{
	private struct LoadDataCache
	{
		public int ammoId;

		public int ammoCount;
	}

	[ServerVar]
	public static int antihack_level = 0;

	[ServerVar]
	public static float antihack_max_snap_degrees = 35f;

	[ServerVar]
	public static float antihack_max_degrees_per_second_yaw = 720f;

	[ServerVar]
	public static float antihack_max_degrees_per_second_pitch = 720f;

	[ReplicatedVar]
	public static bool ENABLE_CLIENT_AUTHORITY = true;

	[ReplicatedVar]
	public static bool DEBUG = false;

	private static readonly int Up = Animator.StringToHash("up");

	[SerializeField]
	[Header("Mounted Weapon")]
	private Transform _eyes;

	[SerializeField]
	private bool _usingSights;

	[SerializeField]
	private bool _flipPitch;

	[SerializeField]
	private bool _invertForward;

	[SerializeField]
	private bool _clientAuthority;

	[ItemSelector]
	[SerializeField]
	private ItemDefinition _ammoItem;

	[Header("Mounted Weapon - Weapon")]
	[SerializeField]
	private ItemDefinition _weapon;

	[SerializeField]
	private Transform _attachPoint;

	[SerializeField]
	private Transform _yawPivot;

	[SerializeField]
	private Transform _pitchPivot;

	[SerializeField]
	private GameObjectRef _screenshakeEffect;

	[SerializeField]
	private GameObjectRef _dryFireEffect;

	[ItemSelector]
	public ItemDefinition AmmoDef;

	[Header("Mounted Weapon - Second Weapon")]
	[SerializeField]
	private ItemDefinition _weapon2;

	[SerializeField]
	private Transform _attachPoint2;

	[SerializeField]
	[Header("Mounted Weapon - Player General Animation")]
	private int _turretAnimationType;

	[SerializeField]
	private Transform _leftHandIdleIKPosition;

	[SerializeField]
	private Transform _rightHandIdleIKPosition;

	[SerializeField]
	private bool _walkAroundTurret;

	[SerializeField]
	private float _minWalkAroundDistance = 1.11f;

	[SerializeField]
	private float _walkAroundDistance = 1.11f;

	[SerializeField]
	private float _reloadWalkAroundDistance = 1.11f;

	[SerializeField]
	private AnimationCurve _walkAroundDistanceCurve;

	[SerializeField]
	private bool _forceSeatPositionUpdates;

	[SerializeField]
	[Header("Mounted Weapon - Player Camera Animation")]
	private Transform _cameraAnimation;

	[SerializeField]
	private Animator _cameraAnimationController;

	[SerializeField]
	private float _fovMultiplier = 1f;

	[Header("Mounted Weapon - Viewmodel")]
	[SerializeField]
	private bool _useViewmodel;

	[SerializeField]
	private ViewModel _viewmodel;

	[SerializeField]
	[Header("Mounted Weapon - Aim Movement Sounds")]
	private SoundDefinition aimMovementSoundDef;

	[SerializeField]
	private SoundDefinition aimMovementYawSoundDef;

	[SerializeField]
	private SoundDefinition aimMovementPitchSoundDef;

	[SerializeField]
	private AnimationCurve aimMovementGainCurve;

	[SerializeField]
	private float aimMovementSpeedDecayRate = 200f;

	[SerializeField]
	private float aimMovementSpeedMax = 100f;

	public const Flags Flag_WeaponAttached = Flags.Reserved15;

	public const Flags Flag_Lights = Flags.Reserved5;

	private static readonly Phrase _ammoPhrase = new Phrase("mountedweapon.reload.tip", "You need regular 5.56 ammo in your inventory to reload.");

	private static readonly Phrase _ammoFullPhrase = new Phrase("mountedweapon.reload.full.tip", "Can't reload. Ammo is already full!");

	private Vector3 _defaultEyePosition;

	private Quaternion _defaultEyeRotation;

	private EntityRef<HeldEntity> _attachedEntity;

	private EntityRef<HeldEntity> _attachedEntity2;

	private float _reloadTime;

	private MountedWeaponSeat _seat;

	private BasePlayer _mountedPlayer;

	private Vector3 _seatRelativePosition;

	private float _targetWorldYaw;

	private float _targetWorldPitch;

	private float _worldPitch;

	private float _worldYaw;

	private float _startTime;

	private float _reloadServerTimer;

	private float _lastAimRpcTime;

	private float _lastAimYaw;

	private float _lastAimPitch;

	private int[] _reloadStartMag = new int[2];

	private int[] _reloadTaken = new int[2];

	private LoadDataCache? _loadDataCache;

	private ServersideMountedWeaponSnapshot __sync_Snapshot;

	private NetworkableId __sync_GunId;

	private NetworkableId __sync_Gun2Id;

	private bool __sync_IsReloading;

	private bool __sync_IsEmpty;

	[SerializeField]
	private GameObject _worldModel => ((Component)((Component)this).GetComponentInChildren<BaseProjectile>(true)).gameObject;

	public ItemDefinition WeaponDef => _weapon;

	[Sync(RequireChange = false, Pack = false)]
	private ServersideMountedWeaponSnapshot Snapshot
	{
		[CompilerGenerated]
		get
		{
			return __sync_Snapshot;
		}
		[CompilerGenerated]
		set
		{
			__sync_Snapshot = value;
			byte nameID = __GetWeaverID("Snapshot");
			SV_SyncVarSend(nameID);
		}
	}

	[Sync(Autosave = true)]
	private NetworkableId GunId
	{
		[CompilerGenerated]
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return __sync_GunId;
		}
		[CompilerGenerated]
		set
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!IsSyncVarEqual<NetworkableId>(__sync_GunId, value))
			{
				__sync_GunId = value;
				byte nameID = __GetWeaverID("GunId");
				QueueSyncVar(nameID);
			}
		}
	}

	[Sync(Autosave = true)]
	private NetworkableId Gun2Id
	{
		[CompilerGenerated]
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return __sync_Gun2Id;
		}
		[CompilerGenerated]
		set
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!IsSyncVarEqual<NetworkableId>(__sync_Gun2Id, value))
			{
				__sync_Gun2Id = value;
				byte nameID = __GetWeaverID("Gun2Id");
				QueueSyncVar(nameID);
			}
		}
	}

	[Sync(Pack = false)]
	public bool IsReloading
	{
		[CompilerGenerated]
		get
		{
			return __sync_IsReloading;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_IsReloading, value))
			{
				__sync_IsReloading = value;
				byte nameID = __GetWeaverID("IsReloading");
				SV_SyncVarSend(nameID);
			}
		}
	}

	[Sync(Autosave = true)]
	public bool IsEmpty
	{
		[CompilerGenerated]
		get
		{
			return __sync_IsEmpty;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_IsEmpty, value))
			{
				__sync_IsEmpty = value;
				byte nameID = __GetWeaverID("IsEmpty");
				QueueSyncVar(nameID);
			}
		}
	}

	private bool HasSecondWeapon
	{
		get
		{
			if ((Object)(object)_attachPoint2 != (Object)null)
			{
				return (Object)(object)_weapon2 != (Object)null;
			}
			return false;
		}
	}

	public Transform PitchPivot => _pitchPivot;

	public bool PilotedByAi
	{
		get
		{
			if ((Object)(object)_seat != (Object)null)
			{
				return _seat.GetMounted() is HumanNPC;
			}
			return false;
		}
	}

	private bool HasServerAuthority
	{
		get
		{
			if (_clientAuthority)
			{
				if ((Object)(object)_seat != (Object)null)
				{
					return _seat.GetMounted() is HumanNPC;
				}
				return false;
			}
			return true;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("MountedWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 2998965234u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_ReceiveClientAim "));
				}
				TimeWarning val2 = TimeWarning.New("SV_ReceiveClientAim", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2998965234u, "SV_ReceiveClientAim", this, player, 100uL))
						{
							return true;
						}
						long position = ((Stream)(object)msg.read).Position;
						ServersideMountedWeaponSnapshot val4 = msg.read.Proto<ServersideMountedWeaponSnapshot>((ServersideMountedWeaponSnapshot)null);
						try
						{
							if (!RPC_Server.InputValidation.Test(val4.time))
							{
								return true;
							}
							if (!RPC_Server.InputValidation.Test(val4.pitch))
							{
								return true;
							}
							if (!RPC_Server.InputValidation.Test(val4.yaw))
							{
								return true;
							}
							((Stream)(object)msg.read).Position = position;
							if (!RPC_Server.MaxDistance.Test(2998965234u, "SV_ReceiveClientAim", this, player, 3f))
							{
								return true;
							}
						}
						finally
						{
							((IDisposable)val4)?.Dispose();
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_ReceiveClientAim(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_ReceiveClientAim");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public BaseEntity GetOwnerEntity()
	{
		return this;
	}

	public MountedWeaponSeat GetSeat()
	{
		return _seat;
	}

	public void AssignSeat(MountedWeaponSeat seat)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		_seat = seat;
		_seatRelativePosition = ((Component)this).transform.InverseTransformPoint(((Component)seat).transform.position);
	}

	public Quaternion EyeRotationForPlayer(BasePlayer player, Quaternion baseEyeRot)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (IsReloading && (Object)(object)_cameraAnimation != (Object)null)
		{
			return baseEyeRot * _cameraAnimation.localRotation;
		}
		return baseEyeRot;
	}

	public Transform GetCustomEyes()
	{
		return _eyes;
	}

	private void ShowDebug()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (DEBUG && base.isServer)
		{
			Vector3 val = ((Component)this).transform.position + Vector3.up * 3.5f;
			UnityEngine.DDraw.BroadcastText(val, "SERVER\n" + $"WorldYaw:   {_worldYaw:F1}\n" + $"WorldPitch: {_worldPitch:F1}\n" + $"TargetYaw:  {_targetWorldYaw:F1}\n" + $"TargetPitch:{_targetWorldPitch:F1}", Color.yellow, 0f);
			WorldAngleToTurretAngle(_worldYaw, _worldPitch, out var turretYaw, out var turretPitch);
			UnityEngine.DDraw.BroadcastText(val + Vector3.up * 1.2f, $"Server Local\nYaw: {turretYaw:F1}\nPitch: {turretPitch:F1}", Color.white, 0f);
		}
	}

	public Vector3 EyePositionForPlayer(BasePlayer player, Quaternion lookRot, Vector3 baseEyePos)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (IsReloading && (Object)(object)_cameraAnimation != (Object)null)
		{
			return baseEyePos + _cameraAnimation.localPosition;
		}
		return baseEyePos;
	}

	private void Tick()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		_clientAuthority = ENABLE_CLIENT_AUTHORITY;
		ShowDebug();
		if (!Object.op_Implicit((Object)(object)_seat) || !_seat.AnyMounted())
		{
			return;
		}
		if (IsReloading)
		{
			LerpToZero();
		}
		Vector3 gunForward = GetGunForward();
		((Component)_seat).transform.forward = gunForward;
		if (_walkAroundTurret || _forceSeatPositionUpdates)
		{
			TimeWarning val = TimeWarning.New("MountedWeapon.Update.SeatPosition", 0);
			try
			{
				_seatRelativePosition = ((Component)this).transform.InverseTransformPoint(((Component)_seat).transform.position);
				float num = _walkAroundDistance;
				if (!IsReloading)
				{
					Vector2 pitchClamp = _seat.GetPitchClamp();
					float num2 = 0f;
					if (base.isServer)
					{
						num2 = _worldPitch;
					}
					if (true)
					{
						float num3 = Mathf.InverseLerp(pitchClamp.x, pitchClamp.y, num2);
						float num4 = _walkAroundDistanceCurve.Evaluate(num3);
						num4 = Mathf.Clamp01(num4);
						num = Mathf.Lerp(_minWalkAroundDistance, _walkAroundDistance, num4);
					}
				}
				else
				{
					num = _reloadWalkAroundDistance;
				}
				Vector3 position = ((Component)this).transform.position + -GetGunForward() * num;
				position.y = ((Component)this).transform.TransformPoint(_seatRelativePosition).y;
				((Component)_seat).transform.position = position;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		float num5 = 65f;
		if (_usingSights)
		{
			num5 = 110f;
		}
		if (!base.isServer)
		{
			return;
		}
		TimeWarning val2 = TimeWarning.New("MountedWeapon.Tick.Server", 0);
		try
		{
			if (!_clientAuthority || ((Object)(object)_seat != (Object)null && _seat.GetMounted() is HumanNPC))
			{
				_worldYaw = Mathf.LerpAngle(_worldYaw, _targetWorldYaw, Time.deltaTime * num5);
				_worldPitch = Mathf.LerpAngle(_worldPitch, _targetWorldPitch, Time.deltaTime * num5);
				WorldAngleToTurretAngle(_worldYaw, _worldPitch, out var turretYaw, out var turretPitch);
				Vector2 yawClamp = GetSeat().GetYawClamp();
				Vector2 pitchClamp2 = GetSeat().GetPitchClamp();
				turretYaw = Mathf.Clamp(turretYaw, yawClamp.x, yawClamp.y);
				turretPitch = Mathf.Clamp(turretPitch, pitchClamp2.x, pitchClamp2.y);
				_yawPivot.localRotation = Quaternion.Euler(0f, turretYaw, 0f);
				_pitchPivot.localRotation = Quaternion.Euler(turretPitch, 0f, 0f);
			}
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	private void Update()
	{
		Tick();
	}

	public override void Load(LoadInfo info)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		_attachedEntity.uid = GunId;
		_attachedEntity2.uid = Gun2Id;
		CalculateReloadTime();
		if (!info.fromDisk)
		{
			return;
		}
		if (base.isServer)
		{
			UpdateClient(force: true);
			if (info.msg.mountedWeapon != null)
			{
				_loadDataCache = new LoadDataCache
				{
					ammoId = info.msg.mountedWeapon.ammoItemID,
					ammoCount = info.msg.mountedWeapon.ammoStackSize
				};
				SetupTurretsWithLoadData();
			}
		}
		GetZeroInWorldAngles(out var worldYaw, out var worldPitch);
		SetTargetAngles(worldYaw, worldPitch, set: true);
	}

	private void SetTargetAngles(float worldYaw, float worldPitch, bool set = false)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)GetOwnerEntity() == (Object)null || (Object)(object)GetSeat() == (Object)null)
		{
			return;
		}
		_targetWorldYaw = worldYaw;
		_targetWorldPitch = worldPitch;
		if (set)
		{
			if (base.isServer)
			{
				_worldYaw = worldYaw;
				_worldPitch = worldPitch;
			}
			_targetWorldYaw = worldYaw;
			_targetWorldPitch = worldPitch;
			WorldAngleToTurretAngle(_targetWorldYaw, _targetWorldPitch, out var turretYaw, out var turretPitch);
			Vector2 yawClamp = GetSeat().GetYawClamp();
			Vector2 pitchClamp = GetSeat().GetPitchClamp();
			turretYaw = Mathf.Clamp(turretYaw, yawClamp.x, yawClamp.y);
			turretPitch = Mathf.Clamp(turretPitch, pitchClamp.x, pitchClamp.y);
			_yawPivot.localRotation = Quaternion.Euler(0f, turretYaw, 0f);
			_pitchPivot.localRotation = Quaternion.Euler(turretPitch, 0f, 0f);
		}
		Transform transform = ((Component)this).transform;
		Quaternion rotation = ((Component)this).transform.rotation;
		transform.rotation = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
	}

	private void GetZeroInWorldAngles(out float worldYaw, out float worldPitch)
	{
		TurretAngleToWorldAngle(0f, 0f, out worldYaw, out worldPitch);
	}

	private Vector3 GetGunForward()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)PitchPivot == (Object)null)
		{
			return Vector3.forward;
		}
		Vector3 val = PitchPivot.forward;
		if (_invertForward)
		{
			val = -val;
		}
		return val;
	}

	private void CalculateReloadTime()
	{
		_reloadTime = 0f;
		BaseProjectile baseProjectile = GetWeaponEntity() as BaseProjectile;
		if ((Object)(object)baseProjectile != (Object)null)
		{
			_reloadTime = baseProjectile.reloadTime;
		}
		BaseProjectile baseProjectile2 = GetWeaponEntity2() as BaseProjectile;
		if ((Object)(object)baseProjectile2 != (Object)null)
		{
			_reloadTime = Mathf.Max(_reloadTime, baseProjectile2.reloadTime);
		}
	}

	private static float NormalizeAngle(float angle)
	{
		angle %= 360f;
		if (angle > 180f)
		{
			angle -= 360f;
		}
		if (angle < -180f)
		{
			angle += 360f;
		}
		return angle;
	}

	private HeldEntity GetWeaponEntity()
	{
		HeldEntity heldEntity = _attachedEntity.Get(base.isServer);
		if (heldEntity.IsValid())
		{
			return heldEntity;
		}
		return null;
	}

	private HeldEntity GetWeaponEntity2()
	{
		HeldEntity heldEntity = _attachedEntity2.Get(base.isServer);
		if (heldEntity.IsValid())
		{
			return heldEntity;
		}
		return null;
	}

	private void TurretAngleToWorldAngle(float turretYaw, float turretPitch, out float worldYaw, out float worldPitch)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		float num = (_flipPitch ? (-1f) : 1f);
		Vector3 val = Quaternion.Euler((0f - turretPitch) * num, turretYaw, 0f) * Vector3.forward;
		Vector3 val2 = ((Component)this).transform.TransformDirection(val);
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		worldYaw = Mathf.Atan2(normalized.x, normalized.z) * 57.29578f;
		worldPitch = (0f - Mathf.Asin(normalized.y)) * 57.29578f;
	}

	private void WorldAngleToTurretAngle(float worldYaw, float worldPitch, out float turretYaw, out float turretPitch)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Quaternion.Euler(new Vector3(worldPitch, worldYaw, 0f)) * Vector3.forward;
		Transform transform = ((Component)this).transform;
		Quaternion val2 = ((Component)this).transform.rotation;
		transform.rotation = Quaternion.Euler(0f, ((Quaternion)(ref val2)).eulerAngles.y, 0f);
		Vector3 val3 = ((Component)this).transform.InverseTransformDirection(val);
		val2 = Quaternion.LookRotation(((Vector3)(ref val3)).normalized, ((Component)this).transform.up);
		Vector3 eulerAngles = ((Quaternion)(ref val2)).eulerAngles;
		turretYaw = eulerAngles.y;
		turretPitch = (0f - eulerAngles.x) * (_flipPitch ? (-1f) : 1f);
		turretYaw = NormalizeAngle(turretYaw);
		turretPitch = NormalizeAngle(turretPitch);
	}

	private void LerpToZero()
	{
		float num = 25f;
		TurretAngleToWorldAngle(0f, 0f, out var worldYaw, out var worldPitch);
		if (base.isServer)
		{
			_worldYaw = Mathf.MoveTowardsAngle(_worldYaw, worldYaw, Time.deltaTime * num);
			_worldPitch = Mathf.MoveTowardsAngle(_worldPitch, worldPitch, Time.deltaTime * num);
			SetTargetAngles(_worldYaw, _worldPitch);
			UpdateClient(force: true);
		}
	}

	private void HandleAiming(InputState inputState, BasePlayer player, bool asClient, float currentPitch, float currentYaw)
	{
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		float num = 1.5f;
		bool flag = false;
		if (base.isServer)
		{
			flag = HasServerAuthority && !asClient;
		}
		if ((Object)(object)_seat == (Object)null || !_seat.AnyMounted() || IsReloading || (Object)(object)player == (Object)null || (Object)(object)player.eyes == (Object)null || Snapshot == null)
		{
			return;
		}
		bool flag2 = false;
		if (!flag)
		{
			return;
		}
		if (_usingSights)
		{
			float num2 = (0f - inputState.current.mouseDelta.y) * num;
			float num3 = inputState.current.mouseDelta.x * num;
			WorldAngleToTurretAngle(currentYaw, currentPitch, out var turretYaw, out var turretPitch);
			turretYaw += num3;
			turretPitch -= num2;
			Vector2 yawClamp = _seat.GetYawClamp();
			Vector2 pitchClamp = _seat.GetPitchClamp();
			turretYaw = Mathf.Clamp(turretYaw, yawClamp.x, yawClamp.y);
			turretPitch = Mathf.Clamp(turretPitch, pitchClamp.x, pitchClamp.y);
			TurretAngleToWorldAngle(turretYaw, turretPitch, out var worldYaw, out var worldPitch);
			SetTargetAngles(worldYaw, worldPitch);
			float num4 = 0.15f;
			if (Mathf.Abs(Mathf.DeltaAngle(worldYaw, currentYaw)) > num4 || Mathf.Abs(Mathf.DeltaAngle(worldPitch, currentPitch)) > num4)
			{
				flag2 = true;
			}
		}
		else
		{
			Quaternion val = Quaternion.LookRotation(Ballistics.GetBulletHitPoint(new Ray(player.eyes.position + player.eyes.HeadForward() * 0.5f, player.eyes.HeadForward()), (BaseEntity)this) - ((Component)this).transform.position);
			Quaternion.Euler(currentPitch, currentYaw, 0f);
			Vector3 eulerAngles = ((Quaternion)(ref val)).eulerAngles;
			float y = eulerAngles.y;
			float x = eulerAngles.x;
			WorldAngleToTurretAngle(y, x, out var turretYaw2, out var turretPitch2);
			Vector2 yawClamp2 = _seat.GetYawClamp();
			Vector2 pitchClamp2 = _seat.GetPitchClamp();
			turretYaw2 = Mathf.Clamp(turretYaw2, yawClamp2.x, yawClamp2.y);
			turretPitch2 = Mathf.Clamp(turretPitch2, pitchClamp2.x, pitchClamp2.y);
			TurretAngleToWorldAngle(turretYaw2, turretPitch2, out var worldYaw2, out var worldPitch2);
			if (Mathf.Abs(Mathf.DeltaAngle(worldYaw2, currentYaw)) > 0.05f || Mathf.Abs(Mathf.DeltaAngle(worldPitch2, currentPitch)) > 0.05f)
			{
				SetTargetAngles(worldYaw2, worldPitch2);
			}
			float num5 = 1f;
			if (Mathf.Abs(Mathf.DeltaAngle(worldYaw2, currentYaw)) > num5 || Mathf.Abs(Mathf.DeltaAngle(worldPitch2, currentPitch)) > num5)
			{
				flag2 = true;
			}
		}
		if (flag2 && !base.isClient)
		{
			UpdateClient();
		}
	}

	public void OnPlayerMounted()
	{
		UpdateClient(force: true);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			UpdateAttachedWeapon(_weapon, _attachPoint);
			if (HasSecondWeapon)
			{
				UpdateAttachedWeapon(_weapon, _attachPoint2, second: true);
			}
		}, 0.5f);
		_startTime = Time.realtimeSinceStartup;
		_reloadServerTimer = 0f;
		GetZeroInWorldAngles(out var worldYaw, out var worldPitch);
		_worldYaw = worldYaw;
		_worldPitch = worldPitch;
		SetTargetAngles(_worldYaw, _worldPitch);
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			UpdateClient(force: true);
		}, 1f);
		SetFlag(Flags.Reserved5, b: false);
		_lastAimRpcTime = Time.realtimeSinceStartup;
		_lastAimYaw = _worldYaw;
		_lastAimPitch = _worldPitch;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.mountedWeapon = Pool.Get<MountedWeapon>();
			BaseProjectile baseProjectile = GetWeaponEntity() as BaseProjectile;
			if ((Object)(object)baseProjectile != (Object)null)
			{
				info.msg.mountedWeapon.ammoItemID = baseProjectile.primaryMagazine.ammoType.itemid;
				info.msg.mountedWeapon.ammoStackSize = baseProjectile.primaryMagazine.contents;
			}
		}
	}

	private void RefundAmmo(BasePlayer player, int amount)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (amount > 0 && !((Object)(object)player == (Object)null))
		{
			Item item = ItemManager.Create(AmmoDef, amount, 0uL);
			if (!item.MoveToContainer(player.inventory.containerMain))
			{
				item.Drop(((Component)player).transform.position + Vector3.up, Vector3.down);
			}
		}
	}

	public void OnPlayerDismounted(BasePlayer player)
	{
		HeldEntity weaponEntity = GetWeaponEntity();
		HeldEntity weaponEntity2 = GetWeaponEntity2();
		bool isReloading = IsReloading;
		if ((Object)(object)weaponEntity != (Object)null)
		{
			weaponEntity.forcedOwner = null;
			if (isReloading)
			{
				IsReloading = false;
				_reloadServerTimer = 0f;
				((FacepunchBehaviour)this).CancelInvoke((Action)ProcessServerReloadTimer);
				if (weaponEntity is BaseProjectile baseProjectile)
				{
					RefundAmmo(player, _reloadTaken[0]);
					baseProjectile.primaryMagazine.contents = _reloadStartMag[0];
					IsEmpty = _reloadStartMag[0] == 0;
					baseProjectile.SkipReload();
				}
			}
		}
		if ((Object)(object)weaponEntity2 != (Object)null)
		{
			weaponEntity2.forcedOwner = null;
			if (isReloading && weaponEntity2 is BaseProjectile baseProjectile2)
			{
				RefundAmmo(player, _reloadTaken[1]);
				baseProjectile2.primaryMagazine.contents = _reloadStartMag[1];
				IsEmpty = _reloadStartMag[1] == 0;
				baseProjectile2.SkipReload();
			}
		}
		_reloadTaken[0] = (_reloadTaken[1] = 0);
		_reloadStartMag[0] = (_reloadStartMag[1] = 0);
	}

	private void SetupTurretsWithLoadData()
	{
		if (!_loadDataCache.HasValue)
		{
			return;
		}
		BaseProjectile baseProjectile = GetWeaponEntity() as BaseProjectile;
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(_loadDataCache.Value.ammoId);
		if (!((Object)(object)itemDefinition == (Object)null))
		{
			if ((Object)(object)baseProjectile != (Object)null)
			{
				baseProjectile.primaryMagazine.ammoType = itemDefinition;
				baseProjectile.primaryMagazine.contents = _loadDataCache.Value.ammoCount;
			}
			BaseProjectile baseProjectile2 = GetWeaponEntity2() as BaseProjectile;
			if ((Object)(object)baseProjectile2 != (Object)null)
			{
				baseProjectile2.primaryMagazine.ammoType = itemDefinition;
				baseProjectile2.primaryMagazine.contents = _loadDataCache.Value.ammoCount;
			}
		}
	}

	public void LightToggle(BasePlayer basePlayer)
	{
		SetFlag(Flags.Reserved5, !HasFlag(Flags.Reserved5));
	}

	public override void AdminKill()
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			baseEntity.AdminKill();
		}
		base.AdminKill();
	}

	public override BasePlayer ToPlayer()
	{
		BaseEntity ownerEntity = GetOwnerEntity();
		if ((Object)(object)ownerEntity != (Object)null && ownerEntity is BaseVehicleSeat baseVehicleSeat)
		{
			return baseVehicleSeat.GetMounted();
		}
		return null;
	}

	public bool Fire(bool isAi = false)
	{
		if (IsReloading)
		{
			return false;
		}
		BaseProjectile baseProjectile = GetWeaponEntity() as BaseProjectile;
		BaseProjectile baseProjectile2 = GetWeaponEntity2() as BaseProjectile;
		int num = (int)(0u | (TryFireWeapon(baseProjectile) ? 1u : 0u)) | (TryFireWeapon(baseProjectile2) ? 1 : 0);
		if ((Object)(object)baseProjectile != (Object)null)
		{
			IsEmpty = baseProjectile.AmmoFraction() <= 0f && ((Object)(object)baseProjectile2 == (Object)null || baseProjectile2.AmmoFraction() <= 0f);
		}
		if (((uint)num & (isAi ? 1u : 0u)) != 0)
		{
			ClientRPC(RpcTarget.NetworkGroup("CL_OnAttack"));
		}
		return (byte)num != 0;
	}

	public void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		TimeWarning val = TimeWarning.New("ServersideMountedWeapon.ServerInput", 0);
		try
		{
			if (inputState.IsDown(BUTTON.FIRE_PRIMARY) && !IsReloading)
			{
				if (player.InSafeZone())
				{
					return;
				}
				if (Fire())
				{
					player.MarkHostileFor();
					ClientRPC(RpcTarget.NetworkGroup("CL_OnAttack"));
				}
			}
			inputState.IsDown(BUTTON.FIRE_SECONDARY);
			if (inputState.IsDown(BUTTON.RELOAD) && !IsReloading)
			{
				PooledList<Item> val2 = Pool.Get<PooledList<Item>>();
				try
				{
					player.inventory.FindAmmo((List<Item>)(object)val2, (AmmoTypes)2);
					bool flag = false;
					foreach (Item item in (List<Item>)(object)val2)
					{
						if (item.info.itemid == _ammoItem.itemid)
						{
							flag = true;
						}
					}
					if (flag)
					{
						BaseProjectile baseProjectile = GetWeaponEntity() as BaseProjectile;
						BaseProjectile baseProjectile2 = GetWeaponEntity2() as BaseProjectile;
						if ((Object)(object)baseProjectile != (Object)null && baseProjectile.AmmoFraction() >= 1f && ((Object)(object)baseProjectile2 == (Object)null || baseProjectile2.AmmoFraction() >= 1f))
						{
							player.ShowToast(GameTip.Styles.Blue_Normal, _ammoFullPhrase, false);
							return;
						}
						if (_reloadTime == 0f)
						{
							CalculateReloadTime();
						}
						_reloadServerTimer = _reloadTime;
						StartReload();
					}
					else
					{
						player.ShowToast(GameTip.Styles.Blue_Normal, _ammoPhrase, false);
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			if (!IsReloading)
			{
				HandleAiming(inputState, player, asClient: false, _worldPitch, _worldYaw);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void CheckAiReload()
	{
		bool isReloading = false;
		bool flag = false;
		if (GetWeaponEntity() is BaseProjectile baseProjectile)
		{
			if (baseProjectile.ServerIsReloading())
			{
				isReloading = true;
			}
			if (!baseProjectile.ServerIsReloading() && baseProjectile.primaryMagazine.contents <= 0)
			{
				flag = true;
				baseProjectile.ServerReload();
			}
		}
		if (GetWeaponEntity2() is BaseProjectile baseProjectile2)
		{
			if (baseProjectile2.ServerIsReloading())
			{
				isReloading = true;
			}
			if (!baseProjectile2.ServerIsReloading() && baseProjectile2.primaryMagazine.contents <= 0)
			{
				flag = true;
				baseProjectile2.ServerReload();
			}
		}
		IsReloading = isReloading;
		if (flag)
		{
			float time = Time.time;
			float arg = time + _reloadTime;
			ClientRPC(RpcTarget.NetworkGroup("CL_StartReloading"), time, arg);
		}
	}

	public void AimAt(Vector3 origin, Vector3 desiredGunForward, bool forceFlip)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float worldYaw = Mathf.Atan2(desiredGunForward.x, desiredGunForward.z) * 57.29578f;
		float worldPitch = (0f - Mathf.Asin(desiredGunForward.y)) * 57.29578f;
		WorldAngleToTurretAngle(worldYaw, worldPitch, out var turretYaw, out var turretPitch);
		if (forceFlip)
		{
			turretPitch = 0f - turretPitch;
		}
		turretYaw = NormalizeAngle(turretYaw);
		turretPitch = NormalizeAngle(turretPitch);
		TurretAngleToWorldAngle(turretYaw, turretPitch, out var worldYaw2, out var worldPitch2);
		_worldYaw = Mathf.MoveTowardsAngle(_worldYaw, worldYaw2, Time.deltaTime * 105f);
		_worldPitch = Mathf.MoveTowardsAngle(_worldPitch, worldPitch2, Time.deltaTime * 105f);
		SetTargetAngles(_worldYaw, _worldPitch, set: true);
		if (Snapshot == null || Mathf.Abs(Mathf.DeltaAngle(Snapshot.yaw, _worldYaw)) > 3f || Mathf.Abs(Mathf.DeltaAngle(Snapshot.pitch, _worldPitch)) > 3f)
		{
			UpdateClient(force: true);
		}
	}

	private void UpdateClient(bool force = false)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		Snapshot = new ServersideMountedWeaponSnapshot
		{
			time = Time.realtimeSinceStartup - _startTime,
			yaw = _worldYaw,
			pitch = _worldPitch,
			force = force
		};
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		if (Check.IsValidWeapon(item, checkCanUseTurret: true) && targetSlot == 0)
		{
			return true;
		}
		if (item.info.category == ItemCategory.Ammunition)
		{
			return true;
		}
		return false;
	}

	private bool TryFireWeapon(HeldEntity heldEntity)
	{
		if ((Object)(object)heldEntity == (Object)null)
		{
			return false;
		}
		if ((Object)(object)_seat != (Object)null)
		{
			BasePlayer mounted = _seat.GetMounted();
			heldEntity.forcedOwner = mounted;
			heldEntity.useOwnerForward = false;
		}
		if (heldEntity is BaseProjectile baseProjectile)
		{
			if (baseProjectile.NextAttackTime > Time.time)
			{
				return false;
			}
			if (baseProjectile.primaryMagazine.contents <= 0)
			{
				ClientRPC(RpcTarget.NetworkGroup("CL_OnDryFire"), _mountedPlayer);
				baseProjectile.StartAttackCooldown(1f);
				return false;
			}
			if (baseProjectile is ITurretNotify turretNotify)
			{
				turretNotify.WarmupTick(wantsShoot: true);
				if (!turretNotify.CanShoot())
				{
					return false;
				}
			}
		}
		heldEntity.ServerUse(1f, 1f, null);
		heldEntity.useOwnerForward = false;
		heldEntity.forcedOwner = null;
		return true;
	}

	private void UpdateAttachedWeapon(ItemDefinition weapon, Transform attachPoint, bool second = false)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		HeldEntity heldEntity = AutoTurret.TryAddWeaponToTurret(ItemManager.Create(second ? _weapon2 : weapon, 1, 0uL), attachPoint, this, -0.5f);
		((Component)heldEntity).transform.localPosition = Vector3.zero;
		if (HasSecondWeapon)
		{
			Vector3 val = (_attachPoint.position + _attachPoint2.position) / 2f + attachPoint.forward * 10f - attachPoint.position;
			Quaternion val2 = Quaternion.LookRotation(((Vector3)(ref val)).normalized, ((Component)this).transform.up);
			((Component)heldEntity).transform.localRotation = Quaternion.Inverse(attachPoint.rotation) * val2;
		}
		bool flag = (Object)(object)heldEntity != (Object)null;
		if (flag)
		{
			if (!second)
			{
				_attachedEntity.Set(heldEntity);
				GunId = _attachedEntity.uid;
			}
			else
			{
				_attachedEntity2.Set(heldEntity);
				Gun2Id = _attachedEntity2.uid;
			}
		}
		else
		{
			HeldEntity heldEntity2 = GetWeaponEntity();
			if (second)
			{
				heldEntity2 = GetWeaponEntity2();
			}
			if ((Object)(object)heldEntity2 != (Object)null)
			{
				heldEntity2.SetGenericVisible(wantsVis: false);
				heldEntity2.SetLightsOn(isOn: false);
				if (heldEntity2 is ITurretNotify turretNotify)
				{
					turretNotify.WarmupTick(wantsShoot: false);
				}
			}
			if (!second)
			{
				_attachedEntity.Set(null);
				GunId = _attachedEntity.uid;
			}
			else
			{
				_attachedEntity2.Set(null);
				Gun2Id = _attachedEntity2.uid;
			}
		}
		SetupTurretsWithLoadData();
		SetFlag(Flags.Reserved15, flag);
		SendNetworkUpdate();
	}

	private void StartReload()
	{
		if ((Object)(object)_seat == (Object)null)
		{
			return;
		}
		BasePlayer mounted = _seat.GetMounted();
		if (!((Object)(object)mounted == (Object)null))
		{
			CalculateReloadTime();
			BaseProjectile baseProjectile = GetWeaponEntity() as BaseProjectile;
			BaseProjectile baseProjectile2 = GetWeaponEntity2() as BaseProjectile;
			_reloadStartMag[0] = (Object.op_Implicit((Object)(object)baseProjectile) ? baseProjectile.primaryMagazine.contents : 0);
			_reloadStartMag[1] = (Object.op_Implicit((Object)(object)baseProjectile2) ? baseProjectile2.primaryMagazine.contents : 0);
			bool num = (Object)(object)baseProjectile != (Object)null && baseProjectile.ServerTryReload(mounted.inventory);
			bool flag = (Object)(object)baseProjectile2 != (Object)null && baseProjectile2.ServerTryReload(mounted.inventory);
			int num2 = (Object.op_Implicit((Object)(object)baseProjectile) ? baseProjectile.primaryMagazine.contents : 0);
			int num3 = (Object.op_Implicit((Object)(object)baseProjectile2) ? baseProjectile2.primaryMagazine.contents : 0);
			_reloadTaken[0] = Mathf.Max(0, num2 - _reloadStartMag[0]);
			_reloadTaken[1] = Mathf.Max(0, num3 - _reloadStartMag[1]);
			bool num4 = num || flag;
			if (_reloadTime == 0f)
			{
				CalculateReloadTime();
			}
			float time = Time.time;
			float arg = time + _reloadTime;
			if (num4)
			{
				IsEmpty = false;
				IsReloading = true;
				mounted.userID.Get();
				_reloadServerTimer = 0f;
				ClientRPC(RpcTarget.NetworkGroup("CL_StartReloading"), time, arg);
				((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessServerReloadTimer, 0f, 0f);
			}
		}
	}

	private void ProcessServerReloadTimer()
	{
		_reloadServerTimer += Time.deltaTime;
		if (_reloadServerTimer >= _reloadTime)
		{
			IsReloading = false;
			((FacepunchBehaviour)this).CancelInvoke((Action)ProcessServerReloadTimer);
			_reloadServerTimer = 0f;
		}
	}

	[RPC_Server.CallsPerSecond(100uL)]
	[RPC_Server.InputValidation(new Type[] { typeof(ServersideMountedWeaponSnapshot) })]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void SV_ReceiveClientAim(RPCMessage msg)
	{
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if (!_clientAuthority)
		{
			return;
		}
		BasePlayer player = msg.player;
		if ((Object)(object)_seat == (Object)null)
		{
			return;
		}
		BasePlayer mounted = _seat.GetMounted();
		if ((Object)(object)mounted == (Object)null || (Object)(object)player == (Object)null || (Object)(object)player != (Object)(object)mounted || (Object)(object)mounted != (Object)(object)player)
		{
			return;
		}
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		float num = Mathf.Clamp(realtimeSinceStartup - _lastAimRpcTime, 0.0001f, 0.2f);
		ServersideMountedWeaponSnapshot val = msg.read.Proto<ServersideMountedWeaponSnapshot>((ServersideMountedWeaponSnapshot)null);
		try
		{
			float yaw = val.yaw;
			float pitch = val.pitch;
			WorldAngleToTurretAngle(yaw, pitch, out var turretYaw, out var turretPitch);
			Vector2 yawClamp = GetSeat().GetYawClamp();
			Vector2 pitchClamp = GetSeat().GetPitchClamp();
			if (antihack_level >= 1 && (turretYaw < yawClamp.x || turretYaw > yawClamp.y || turretPitch < pitchClamp.x || turretPitch > pitchClamp.y))
			{
				turretYaw = Mathf.Clamp(turretYaw, yawClamp.x, yawClamp.y);
				turretPitch = Mathf.Clamp(turretPitch, pitchClamp.x, pitchClamp.y);
				TurretAngleToWorldAngle(turretYaw, turretPitch, out _worldYaw, out _worldPitch);
				UpdateClient(force: true);
				return;
			}
			float num2 = Mathf.Abs(Mathf.DeltaAngle(_lastAimYaw, yaw));
			float num3 = Mathf.Abs(Mathf.DeltaAngle(_lastAimPitch, pitch));
			if (antihack_level >= 2 && (num2 > antihack_max_snap_degrees || num3 > antihack_max_snap_degrees))
			{
				UpdateClient(force: true);
				return;
			}
			if (antihack_level >= 3)
			{
				float num4 = num2 / num;
				float num5 = num3 / num;
				if (num4 > antihack_max_degrees_per_second_yaw || num5 > antihack_max_degrees_per_second_pitch)
				{
					UpdateClient(force: true);
					return;
				}
			}
			_worldYaw = yaw;
			_worldPitch = pitch;
			SetTargetAngles(_worldYaw, _worldPitch, set: true);
			if (Snapshot == null || Time.realtimeSinceStartup - _startTime - Snapshot.time >= 0.05f)
			{
				UpdateClient();
			}
			_lastAimRpcTime = realtimeSinceStartup;
			_lastAimYaw = yaw;
			_lastAimPitch = pitch;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId iD;
		switch (id)
		{
		case 0:
		{
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: Snapshot for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			TimeWarning val = TimeWarning.New("Objects", 0);
			try
			{
				if (__sync_Snapshot == null)
				{
					__sync_Snapshot = Pool.Get<ServersideMountedWeaponSnapshot>();
				}
				SyncVarNetWrite<ServersideMountedWeaponSnapshot>(writer, __sync_Snapshot);
				return true;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		case 1:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: GunId for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite<NetworkableId>(writer, __sync_GunId);
			return true;
		case 2:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: Gun2Id for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite<NetworkableId>(writer, __sync_Gun2Id);
			return true;
		case 3:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: IsReloading for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_IsReloading);
			return true;
		case 4:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: IsEmpty for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_IsEmpty);
			return true;
		default:
			return base.WriteSyncVar(id, writer);
		}
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		switch (id)
		{
		case 0:
			try
			{
				ServersideMountedWeaponSnapshot _sync_Snapshot = __sync_Snapshot;
				ServersideMountedWeaponSnapshot _sync_Snapshot2 = reader.Proto<ServersideMountedWeaponSnapshot>((ServersideMountedWeaponSnapshot)null);
				__sync_Snapshot = _sync_Snapshot2;
				if (_sync_Snapshot != null)
				{
					_sync_Snapshot.Dispose();
				}
			}
			catch (Exception ex2)
			{
				Debug.LogException(ex2);
			}
			return true;
		case 1:
			try
			{
				_ = __sync_GunId;
				NetworkableId _sync_GunId = reader.EntityID();
				__sync_GunId = _sync_GunId;
			}
			catch (Exception ex4)
			{
				Debug.LogException(ex4);
			}
			return true;
		case 2:
			try
			{
				_ = __sync_Gun2Id;
				NetworkableId _sync_Gun2Id = reader.EntityID();
				__sync_Gun2Id = _sync_Gun2Id;
			}
			catch (Exception ex5)
			{
				Debug.LogException(ex5);
			}
			return true;
		case 3:
			try
			{
				_ = __sync_IsReloading;
				bool _sync_IsReloading = reader.Bool();
				__sync_IsReloading = _sync_IsReloading;
			}
			catch (Exception ex3)
			{
				Debug.LogException(ex3);
			}
			return true;
		case 4:
			try
			{
				_ = __sync_IsEmpty;
				bool _sync_IsEmpty = reader.Bool();
				__sync_IsEmpty = _sync_IsEmpty;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			return true;
		default:
			return base.OnSyncVar(id, reader, fromAutoSave);
		}
	}

	private byte __GetWeaverID(string propertyName)
	{
		return propertyName switch
		{
			"Snapshot" => 0, 
			"GunId" => 1, 
			"Gun2Id" => 2, 
			"IsReloading" => 3, 
			"IsEmpty" => 4, 
			_ => byte.MaxValue, 
		};
	}

	protected override void WriteAutoSaveSyncVars(NetWrite writer)
	{
		base.WriteAutoSaveSyncVars(writer);
		WriteSyncVar(1, writer);
		WriteSyncVar(2, writer);
		WriteSyncVar(4, writer);
	}

	protected override void ReadAutoSaveSyncVars(NetRead reader)
	{
		base.ReadAutoSaveSyncVars(reader);
		OnSyncVar(1, reader, fromAutoSave: true);
		OnSyncVar(2, reader, fromAutoSave: true);
		OnSyncVar(4, reader, fromAutoSave: true);
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		base.AutoSaveSyncVars(save);
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteAutoSaveSyncVars(val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		base.AutoLoadSyncVars(load);
		if (load.msg.baseEntity != null && load.msg.baseEntity.syncVars != null)
		{
			NetRead val = Pool.Get<NetRead>();
			val.Init(load.msg.baseEntity.syncVars.AsSpan());
			ReadAutoSaveSyncVars(val);
			Pool.Free<NetRead>(ref val);
		}
		return true;
	}

	protected override void ResetSyncVars()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		base.ResetSyncVars();
		__sync_Snapshot = null;
		__sync_GunId = default(NetworkableId);
		__sync_Gun2Id = default(NetworkableId);
		__sync_IsReloading = false;
		__sync_IsEmpty = false;
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		return id switch
		{
			0 => true, 
			1 => true, 
			2 => true, 
			3 => true, 
			4 => true, 
			_ => base.ShouldInvalidateCache(id), 
		};
	}
}


private struct LoadDataCache
{
	public int ammoId;

	public int ammoCount;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class NeonSign : Signage
{
	private const float FastSpeed = 0.5f;

	private const float MediumSpeed = 1f;

	private const float SlowSpeed = 2f;

	private const float MinSpeed = 0.5f;

	private const float MaxSpeed = 5f;

	[Header("Neon Sign")]
	public Light topLeft;

	public Light topRight;

	public Light bottomLeft;

	public Light bottomRight;

	public float lightIntensity = 2f;

	[Range(1f, 100f)]
	public int powerConsumption = 10;

	public Material activeMaterial;

	public Material inactiveMaterial;

	public float animationSpeed = 1f;

	public int currentFrame;

	public List<Lights> frameLighting;

	public const Flags Flag_HasAuxPower = Flags.Reserved9;

	public bool isAnimating;

	public Action animationLoopAction;

	private int[] cachedInputs;

	private readonly List<int> inputFrameHistory = new List<int>();

	public AmbienceEmitter ambientSoundEmitter;

	public SoundDefinition switchSoundDef;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("NeonSign.OnRpcMessage", 0);
		try
		{
			if (rpc == 2433901419u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetAnimationSpeed "));
				}
				TimeWarning val2 = TimeWarning.New("SetAnimationSpeed", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2433901419u, "SetAnimationSpeed", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2433901419u, "SetAnimationSpeed", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rPCMessage2 = rPCMessage;
							SetAnimationSpeed(rPCMessage2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetAnimationSpeed");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1919786296 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdateNeonColors "));
				}
				TimeWarning val2 = TimeWarning.New("UpdateNeonColors", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1919786296u, "UpdateNeonColors", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1919786296u, "UpdateNeonColors", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							UpdateNeonColors(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UpdateNeonColors");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return powerConsumption;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.neonSign == null)
		{
			return;
		}
		if (frameLighting != null)
		{
			foreach (Lights item in frameLighting)
			{
				Lights current = item;
				Pool.Free<Lights>(ref current);
			}
			Pool.Free<Lights>(ref frameLighting, false);
		}
		frameLighting = info.msg.neonSign.frameLighting;
		info.msg.neonSign.frameLighting = null;
		currentFrame = Mathf.Clamp(info.msg.neonSign.currentFrame, 0, paintableSources.Length);
		animationSpeed = Mathf.Clamp(info.msg.neonSign.animationSpeed, 0.5f, 5f);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		animationLoopAction = SwitchToNextFrame;
		cachedInputs = new int[inputs.Length];
	}

	public override void ResetState()
	{
		base.ResetState();
		((FacepunchBehaviour)this).CancelInvoke(animationLoopAction);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
		else
		{
			if (inputSlot <= 0)
			{
				return;
			}
			bool b = false;
			for (int i = 1; i < cachedInputs.Length; i++)
			{
				if (cachedInputs[i] >= powerConsumption)
				{
					b = true;
					break;
				}
			}
			SetFlag(Flags.Reserved9, b);
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (inputSlot >= 0 && inputSlot < cachedInputs.Length)
		{
			cachedInputs[inputSlot] = inputAmount;
		}
		base.UpdateFromInput(inputAmount, inputSlot);
		if (inputSlot > 0)
		{
			if (inputAmount > 0)
			{
				inputFrameHistory.Remove(inputSlot);
				inputFrameHistory.Add(inputSlot);
			}
			else
			{
				inputFrameHistory.Remove(inputSlot);
			}
		}
		int num = 0;
		int num2 = -1;
		if (HasFlag(Flags.Reserved9))
		{
			for (int i = 1; i < cachedInputs.Length; i++)
			{
				int num3 = cachedInputs[i];
				if (num3 > num)
				{
					num = num3;
					num2 = i - 1;
				}
				else if (num3 == num && num3 > 0)
				{
					int item = num2 + 1;
					if (inputFrameHistory.IndexOf(i) > inputFrameHistory.IndexOf(item))
					{
						num2 = i - 1;
					}
				}
			}
		}
		if (inputSlot == 0 && cachedInputs[0] != inputAmount)
		{
			cachedInputs[0] = inputAmount;
		}
		bool flag = HasFlag(Flags.Reserved8);
		if (flag && inputSlot == 0)
		{
			cachedInputs[0] = inputAmount;
			if (!isAnimating)
			{
				((FacepunchBehaviour)this).InvokeRepeating(animationLoopAction, animationSpeed, animationSpeed);
				isAnimating = true;
			}
			if (num2 >= 0)
			{
				currentFrame = num2;
				ClientRPC(RpcTarget.NetworkGroup("SetFrame"), currentFrame);
			}
		}
		if (HasFlag(Flags.Reserved9))
		{
			bool num4 = !flag && inputSlot == 0;
			bool flag2 = inputSlot > 0 && inputSlot - 1 == num2;
			bool flag3 = inputAmount == 0 && num2 != currentFrame && !flag;
			if (num4 || flag2 || flag3)
			{
				currentFrame = num2;
				if (isAnimating && flag)
				{
					((FacepunchBehaviour)this).CancelInvoke(animationLoopAction);
					((FacepunchBehaviour)this).InvokeRepeating(animationLoopAction, animationSpeed, animationSpeed);
				}
				ClientRPC(RpcTarget.NetworkGroup("SetFrame"), currentFrame);
				if (isAnimating && !flag)
				{
					((FacepunchBehaviour)this).CancelInvoke(animationLoopAction);
					isAnimating = false;
				}
			}
		}
		if (isAnimating && !flag)
		{
			((FacepunchBehaviour)this).CancelInvoke(animationLoopAction);
			isAnimating = false;
			MarkDirty();
		}
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if (inputIndex == 0)
		{
			return powerConsumption;
		}
		if (!HasFlag(Flags.Reserved8))
		{
			return powerConsumption;
		}
		return 0;
	}

	private void SwitchToFrame(int index)
	{
		if (index >= 0 && index < paintableSources.Length)
		{
			int num = currentFrame;
			currentFrame = index;
			if (currentFrame != num && textureIDs[currentFrame] != 0)
			{
				ClientRPC(RpcTarget.NetworkGroup("SetFrame"), currentFrame);
			}
		}
	}

	private void SwitchToNextFrame()
	{
		int index = (currentFrame + 1) % paintableSources.Length;
		SwitchToFrame(index);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		List<Lights> list = Pool.Get<List<Lights>>();
		if (frameLighting != null)
		{
			foreach (Lights item in frameLighting)
			{
				list.Add(item.Copy());
			}
		}
		info.msg.neonSign = Pool.Get<NeonSign>();
		info.msg.neonSign.frameLighting = list;
		info.msg.neonSign.currentFrame = currentFrame;
		info.msg.neonSign.animationSpeed = animationSpeed;
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SetAnimationSpeed(RPCMessage msg)
	{
		float num = Mathf.Clamp(msg.read.Float(), 0.5f, 5f);
		if (!FloatEx.IsNaN(num))
		{
			animationSpeed = num;
			if (isAnimating)
			{
				((FacepunchBehaviour)this).CancelInvoke(animationLoopAction);
				((FacepunchBehaviour)this).InvokeRepeating(animationLoopAction, animationSpeed, animationSpeed);
			}
			SendNetworkUpdate();
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void UpdateNeonColors(RPCMessage msg)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		if (CanUpdateSign(msg.player))
		{
			int num = msg.read.Int32();
			if (num >= 0 && num < paintableSources.Length)
			{
				EnsureInitialized();
				frameLighting[num].topLeft = ClampColor(msg.read.Color());
				frameLighting[num].topRight = ClampColor(msg.read.Color());
				frameLighting[num].bottomLeft = ClampColor(msg.read.Color());
				frameLighting[num].bottomRight = ClampColor(msg.read.Color());
				SendNetworkUpdate();
			}
		}
	}

	public new void EnsureInitialized()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (frameLighting == null)
		{
			frameLighting = Pool.Get<List<Lights>>();
		}
		while (frameLighting.Count < paintableSources.Length)
		{
			Lights val = Pool.Get<Lights>();
			val.topLeft = Color.clear;
			val.topRight = Color.clear;
			val.bottomLeft = Color.clear;
			val.bottomRight = Color.clear;
			frameLighting.Add(val);
		}
	}

	private static Color ClampColor(Color color)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		return new Color(FloatEx.IsNaN(color.r) ? 0f : Mathf.Clamp01(color.r), FloatEx.IsNaN(color.g) ? 0f : Mathf.Clamp01(color.g), FloatEx.IsNaN(color.b) ? 0f : Mathf.Clamp01(color.b), FloatEx.IsNaN(color.a) ? 0f : Mathf.Clamp01(color.a));
	}
}


using System;
using Network;
using Rust;
using UnityEngine;

public class NewYearGong : BaseCombatEntity
{
	public SoundDefinition gongSound;

	public float minTimeBetweenSounds = 0.25f;

	public GameObject soundRoot;

	public Transform gongCentre;

	public float gongRadius = 1f;

	public AnimationCurve pitchCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public Animator gongAnimator;

	private float lastSound;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("NewYearGong.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Hurt(HitInfo info)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (!info.damageTypes.IsMeleeType() && !info.damageTypes.Has(DamageType.Bullet) && !info.damageTypes.Has(DamageType.Arrow))
		{
			base.Hurt(info);
			return;
		}
		Vector3 val = gongCentre.InverseTransformPoint(info.HitPositionWorld);
		val.z = 0f;
		float num = Vector3.Distance(val, Vector3.zero);
		if (num < gongRadius)
		{
			if (Time.time - lastSound > minTimeBetweenSounds)
			{
				lastSound = Time.time;
				ClientRPC(RpcTarget.NetworkGroup("PlaySound"), Mathf.Clamp01(num / gongRadius));
			}
		}
		else
		{
			base.Hurt(info);
		}
	}
}


using System;
using Network;
using UnityEngine;

public class NPCHumanoidAnimController : EntityComponent<BaseEntity>
{
	public const BaseEntity.Flags FLAG_IS_AIMING = BaseEntity.Flags.Reserved3;

	private const BaseEntity.Flags FLAG_IS_RELAXED = BaseEntity.Flags.Reserved4;

	private const BaseEntity.Flags FLAG_IS_CROUCHING = BaseEntity.Flags.Reserved5;

	public Animator animator;

	public Animator weaponAnimator;

	public bool IsAiming
	{
		get
		{
			return base.baseEntity.flags.HasFlag(BaseEntity.Flags.Reserved3);
		}
		set
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Reserved3, value);
		}
	}

	public bool IsRelaxed
	{
		get
		{
			return base.baseEntity.flags.HasFlag(BaseEntity.Flags.Reserved4);
		}
		set
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Reserved4, value);
		}
	}

	public bool IsCrouching
	{
		get
		{
			return base.baseEntity.flags.HasFlag(BaseEntity.Flags.Reserved5);
		}
		set
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Reserved5, value);
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("NPCHumanoidAnimController.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class NPCTalking : NPCShopKeeper, IConversationProvider
{
	[Serializable]
	public class NPCConversationResultAction
	{
		public string action;

		public int scrapCost;

		public string broadcastMessage;

		public float broadcastRange;
	}

	public Phrase NPCName = new Phrase("", "");

	[ConversationData.DisplayGraphViewButton]
	public ConversationData[] conversations = Array.Empty<ConversationData>();

	public static ListHashSet<IMissionProvider> serverMissionProviders = new ListHashSet<IMissionProvider>();

	public NPCConversationResultAction[] conversationResultActions;

	[NonSerialized]
	public float maxConversationDistance = 5f;

	public List<BasePlayer> conversingPlayers = new List<BasePlayer>();

	public BasePlayer lastActionPlayer;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("NPCTalking.OnRpcMessage", 0);
		try
		{
			if (rpc == 2112414875 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_BeginTalking "));
				}
				TimeWarning val2 = TimeWarning.New("Server_BeginTalking", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2112414875u, "Server_BeginTalking", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2112414875u, "Server_BeginTalking", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_BeginTalking(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_BeginTalking");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1597539152 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_EndTalking "));
				}
				TimeWarning val2 = TimeWarning.New("Server_EndTalking", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1597539152u, "Server_EndTalking", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1597539152u, "Server_EndTalking", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_EndTalking(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_EndTalking");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2713250658u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_ResponsePressed "));
				}
				TimeWarning val2 = TimeWarning.New("Server_ResponsePressed", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2713250658u, "Server_ResponsePressed", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2713250658u, "Server_ResponsePressed", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							Server_ResponsePressed(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in Server_ResponsePressed");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 458746537 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RewardChoiceSelected "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RewardChoiceSelected", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(458746537u, "Server_RewardChoiceSelected", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(458746537u, "Server_RewardChoiceSelected", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							Server_RewardChoiceSelected(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in Server_RewardChoiceSelected");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public int GetConversationIndex(string conversationName)
	{
		for (int i = 0; i < conversations.Length; i++)
		{
			if (conversations[i].shortname == conversationName)
			{
				return i;
			}
		}
		return -1;
	}

	public Phrase GetNPCName()
	{
		return NPCName;
	}

	public bool ProviderBusy()
	{
		return HasFlag(Flags.Reserved1);
	}

	public BaseEntity Entity()
	{
		return this;
	}

	public virtual ConversationData GetConversationFor(BasePlayer player)
	{
		return conversations[0];
	}

	public void ForceEndConversation(BasePlayer player)
	{
		ClientRPC(RpcTarget.Player("Client_EndConversation", player));
		Server_OnConversationEnded(player);
	}

	public void ForceSpeechNode(BasePlayer player, ConversationData data, int speechNodeIndex)
	{
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		ConversationData.AbstractSpeechNodeData speechNodeData = data.GetSpeechNodeData(speechNodeIndex);
		ConversationResponseStatesList val = Pool.Get<ConversationResponseStatesList>();
		try
		{
			val.list = Pool.Get<List<bool>>();
			if (speechNodeData != null)
			{
				for (int i = 0; i < speechNodeData.responses.Length; i++)
				{
					val.list.Add(speechNodeData.responses[i].PassesConditions(player, this));
				}
			}
			ClientRPC(RpcTarget.Player("Client_ForceSpeechNode", player), speechNodeIndex, val);
			Pool.FreeUnmanaged<bool>(ref val.list);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void Server_OnConversationEnded(BasePlayer player)
	{
		Interface.CallHook("OnNpcConversationEnded", (object)this, (object)player);
		if (conversingPlayers.Contains(player))
		{
			conversingPlayers.Remove(player);
		}
	}

	public void CleanupConversingPlayers()
	{
		for (int num = conversingPlayers.Count - 1; num >= 0; num--)
		{
			BasePlayer basePlayer = conversingPlayers[num];
			if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAlive() || basePlayer.IsSleeping())
			{
				conversingPlayers.RemoveAt(num);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	public void Server_BeginTalking(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		Server_BeginTalking(player);
	}

	protected virtual bool CanTalkTo(BasePlayer bp)
	{
		if ((Object)(object)bp == (Object)null)
		{
			return false;
		}
		if (!bp.IsOnGround() && !bp.IsFlying)
		{
			return false;
		}
		return true;
	}

	public void Server_BeginTalking(BasePlayer ply)
	{
		if (!CanTalkTo(ply))
		{
			return;
		}
		CleanupConversingPlayers();
		BaseMission.MissionStatus num = ply.GetActiveMissionInstance()?.status ?? BaseMission.MissionStatus.Undefined;
		uint num2 = ply.GetActiveMissionInstance()?.missionID ?? 0;
		Server_OnConversationStarted(ply);
		bool flag = num == BaseMission.MissionStatus.Active && ply.HasCompletedMission(num2);
		ConversationData conversationFor = GetConversationFor(ply);
		if (!((Object)(object)conversationFor != (Object)null))
		{
			return;
		}
		if (conversingPlayers.Contains(ply))
		{
			Server_OnConversationEnded(ply);
		}
		if (Interface.CallHook("OnNpcConversationStart", (object)this, (object)ply, (object)conversationFor) != null)
		{
			return;
		}
		conversingPlayers.Add(ply);
		UpdateFlags();
		ConversationResponseStatesList val = Pool.Get<ConversationResponseStatesList>();
		try
		{
			string text = conversationFor.entryPoint.resultingNode;
			if (flag && !ply.IsInTutorial)
			{
				text = string.Empty;
				ConversationData.AbstractConversationNodeData[] controlNodes = conversationFor.controlNodes;
				for (int i = 0; i < controlNodes.Length; i++)
				{
					if (controlNodes[i] is ConversationData.ActionEventMissionCompletedNodeData actionEventMissionCompletedNodeData)
					{
						text = actionEventMissionCompletedNodeData.GetResultingNodeForMission(num2);
						break;
					}
				}
			}
			if (string.IsNullOrWhiteSpace(text) && (ply.IsInTutorial || !flag))
			{
				Debug.LogError((object)("Failed to start conversation " + ((Object)conversationFor).name + ", entry node has no output"), (Object)(object)conversationFor);
				return;
			}
			int nodeIndex;
			ConversationData.AbstractSpeechNodeData firstSpeechNodeFrom = conversationFor.GetFirstSpeechNodeFrom(ply, this, text, out nodeIndex);
			val.list = Pool.Get<List<bool>>();
			if (ply.IsInTutorial || !flag)
			{
				if (nodeIndex < 0)
				{
					Debug.LogError((object)("Failed to find a valid speech node starting from GUID: " + text + ", player: " + ((Object)ply).name + ", provider: " + ((Object)this).name), (Object)(object)this);
				}
				else
				{
					for (int j = 0; j < firstSpeechNodeFrom.responses.Length; j++)
					{
						val.list.Add(firstSpeechNodeFrom.responses[j].PassesConditions(ply, this));
					}
				}
			}
			if (this is IMissionProvider missionProvider && !flag)
			{
				ply.Server_SendCanAcceptMissionsFromProvider(missionProvider);
			}
			ClientRPC(RpcTarget.Player("Client_StartConversation", ply), GetConversationIndex(conversationFor.shortname), nodeIndex, flag, val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void Server_OnConversationStarted(BasePlayer speakingTo)
	{
	}

	public virtual void UpdateFlags()
	{
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_EndTalking(RPCMessage msg)
	{
		Server_OnConversationEnded(msg.player);
	}

	public bool ValidConversationPlayer(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3.Distance(((Component)player).transform.position, ((Component)this).transform.position) > maxConversationDistance)
		{
			return false;
		}
		if (conversingPlayers.Contains(player))
		{
			return false;
		}
		return true;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_ResponsePressed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		uint missionId = msg.read.UInt32();
		uint missionId2 = msg.read.UInt32();
		ConversationData conversationFor = GetConversationFor(player);
		if ((Object)(object)conversationFor == (Object)null)
		{
			return;
		}
		ConversationData.AbstractSpeechNodeData abstractSpeechNodeData = conversationFor.speechNodes[num];
		string guid = string.Empty;
		IMissionProvider missionProvider = this as IMissionProvider;
		ConversationData.ResponseNode responseNode = default(ConversationData.ResponseNode);
		if (abstractSpeechNodeData is ConversationData.MissionListSpeechNodeData missionListSpeechNodeData)
		{
			if (!(this is NPCSimpleMissionProvider) || missionProvider == null)
			{
				Debug.LogError((object)string.Format("Response {0} pressed on mission list speech node on {1} but is not a {2}", num2, ((Object)this).name, "NPCSimpleMissionProvider"));
				return;
			}
			if (missionProvider.TryGetMission(missionId2, out var mission))
			{
				bool flag = false;
				ConversationData.MissionListNodeOptionData[] resultingNodeOptions = missionListSpeechNodeData.resultingNodeOptions;
				foreach (ConversationData.MissionListNodeOptionData missionListNodeOptionData in resultingNodeOptions)
				{
					if (!(missionListNodeOptionData.selectedMission != mission))
					{
						guid = missionListNodeOptionData.resultingNode;
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					guid = missionListSpeechNodeData.defaultResultingNode;
				}
			}
		}
		else
		{
			if (abstractSpeechNodeData is ConversationData.MissionPreviewSpeechNodeData && this is NPCSimpleMissionProvider && num2 == 0 && missionProvider != null && missionProvider.TryGetMission(missionId, out var mission2) && player.Server_CanAcceptMission(missionProvider, mission2))
			{
				TryAssignMissionToPlayer(mission2, player);
			}
			responseNode = abstractSpeechNodeData.responses[num2];
			if (responseNode != null)
			{
				if (Interface.CallHook("OnNpcConversationRespond", (object)this, (object)player, (object)conversationFor, (object)responseNode) != null)
				{
					return;
				}
				if (responseNode.conditions.Length != 0)
				{
					UpdateFlags();
				}
				bool num3 = responseNode.PassesConditions(player, this);
				if (num3)
				{
					string actionString = responseNode.GetActionString();
					if (!string.IsNullOrEmpty(actionString))
					{
						OnConversationAction(player, actionString);
					}
				}
				guid = (num3 ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));
			}
		}
		conversationFor.GetFirstSpeechNodeFrom(player, this, guid, out var nodeIndex);
		if (nodeIndex == -1)
		{
			ForceEndConversation(player);
			return;
		}
		ForceSpeechNode(player, conversationFor, nodeIndex);
		Interface.CallHook("OnNpcConversationResponded", (object)this, (object)player, (object)conversationFor, (object)responseNode);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	public void Server_RewardChoiceSelected(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		uint num = msg.read.UInt32();
		int choice = msg.read.Int32();
		if (!MissionManifest.TryGetFromID(num, out var mission))
		{
			Debug.LogError((object)$"{((Object)this).name} failed to retrieve a mission from ID {num}", (Object)(object)this);
			return;
		}
		BaseMission.MissionInstance missionInstance = null;
		for (int i = 0; i < player.acceptedMissions.Count; i++)
		{
			BaseMission.MissionInstance missionInstance2 = player.acceptedMissions[i];
			if (missionInstance2 != null && missionInstance2.missionID == num)
			{
				BaseMission.MissionStatus status = missionInstance2.status;
				if ((status == BaseMission.MissionStatus.Accomplished || status == BaseMission.MissionStatus.Completed) && !missionInstance2.hasDispensedRewards)
				{
					missionInstance = missionInstance2;
					break;
				}
			}
		}
		if (missionInstance != null)
		{
			mission.DispenseRewards(missionInstance, player, choice);
		}
	}

	public BasePlayer GetActionPlayer()
	{
		return lastActionPlayer;
	}

	public virtual void OnConversationAction(BasePlayer player, string action)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (action == "openvending")
		{
			InvisibleVendingMachine vendingMachine = GetVendingMachine();
			if ((Object)(object)vendingMachine != (Object)null && Vector3.Distance(((Component)player).transform.position, ((Component)this).transform.position) < 5f)
			{
				ForceEndConversation(player);
				if (Interface.CallHook("OnVendingShopOpen", (object)vendingMachine, (object)player) == null)
				{
					vendingMachine.PlayerOpenLoot(player, "vendingmachine.customer", doPositionChecks: false);
					Interface.CallHook("OnVendingShopOpened", (object)vendingMachine, (object)player);
				}
				return;
			}
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("scrap");
		NPCConversationResultAction[] array = conversationResultActions;
		foreach (NPCConversationResultAction nPCConversationResultAction in array)
		{
			if (!(nPCConversationResultAction.action == action))
			{
				continue;
			}
			CleanupConversingPlayers();
			foreach (BasePlayer conversingPlayer in conversingPlayers)
			{
				if ((Object)(object)conversingPlayer == (Object)(object)player || (Object)(object)conversingPlayer == (Object)null)
				{
					continue;
				}
				int speechNodeIndex = -1;
				ConversationData conversationFor = GetConversationFor(player);
				ConversationData.AbstractConversationNodeData[] controlNodes = conversationFor.controlNodes;
				for (int j = 0; j < controlNodes.Length; j++)
				{
					if (controlNodes[j] is ConversationData.ActionEventOtherPlayerInvokedData actionEventOtherPlayerInvokedData)
					{
						speechNodeIndex = conversationFor.GetSpeechNodeIndex(actionEventOtherPlayerInvokedData.resultingNode);
						break;
					}
				}
				ForceSpeechNode(conversingPlayer, conversationFor, speechNodeIndex);
			}
			int num = nPCConversationResultAction.scrapCost;
			PooledList<Item> val = Pool.Get<PooledList<Item>>();
			try
			{
				player.inventory.FindItemsByItemID((List<Item>)(object)val, itemDefinition.itemid);
				foreach (Item item in (List<Item>)(object)val)
				{
					num -= item.amount;
				}
				if (num > 0)
				{
					int speechNodeIndex2 = -1;
					ConversationData conversationFor2 = GetConversationFor(player);
					ConversationData.AbstractConversationNodeData[] controlNodes = conversationFor2.controlNodes;
					for (int j = 0; j < controlNodes.Length; j++)
					{
						if (controlNodes[j] is ConversationData.ActionEventPlayerTooPoorNodeData actionEventPlayerTooPoorNodeData)
						{
							speechNodeIndex2 = conversationFor2.GetSpeechNodeIndex(actionEventPlayerTooPoorNodeData.resultingNode);
							break;
						}
					}
					ForceSpeechNode(player, conversationFor2, speechNodeIndex2);
					break;
				}
				Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);
				num = nPCConversationResultAction.scrapCost;
				foreach (Item item2 in (List<Item>)(object)val)
				{
					int num2 = Mathf.Min(num, item2.amount);
					item2.UseItem(num2);
					num -= num2;
					if (num <= 0)
					{
						break;
					}
				}
				lastActionPlayer = player;
				BroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);
				lastActionPlayer = null;
				break;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	protected virtual void TryAssignMissionToPlayer(BaseMission mission, BasePlayer player)
	{
	}
}


using System;

[Serializable]
public class NPCConversationResultAction
{
	public string action;

	public int scrapCost;

	public string broadcastMessage;

	public float broadcastRange;
}


using System;
using ConVar;
using Network;
using UnityEngine;

public class OilRigResetNotification : BaseEntity
{
	private enum OilRigType
	{
		Undefined,
		Small,
		Large
	}

	[SerializeField]
	private OilRigType oilRigType;

	[SerializeField]
	private Phrase smallRigResetPhrase;

	[SerializeField]
	private Phrase largeRigResetPhrase;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("OilRigResetNotification.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void OnPuzzleReset()
	{
		Server_HandlePuzzleReset();
	}

	public void Server_HandlePuzzleReset()
	{
		if (Global.legacymonumentnotifications)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_DoLegacyMonumentNotification"), (byte)oilRigType);
		}
		else
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_PuzzleResetRPC"), (byte)oilRigType);
		}
	}
}


private enum OilRigType
{
	Undefined,
	Small,
	Large
}


using System;
using Network;
using UnityEngine;

public class OreResourceEntity : StagedResourceEntity
{
	public GameObjectRef bonusPrefab;

	public GameObjectRef finishEffect;

	public GameObjectRef bonusFailEffect;

	public bool useHotspotMinigame = true;

	public SoundPlayer bonusSound;

	public float heightOffset;

	private int bonusesKilled;

	public int bonusesSpawned;

	public OreHotSpot _hotSpot;

	public Vector3 lastNodeDir = Vector3.zero;

	private Ray? spawnBonusHitRay;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("OreResourceEntity.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		if (!info.DidGather && info.gatherScale > 0f)
		{
			if (useHotspotMinigame)
			{
				Jackhammer jackhammer = info.Weapon as Jackhammer;
				bool flag = (Object)(object)_hotSpot == (Object)null;
				if ((Object)(object)_hotSpot == (Object)null)
				{
					_hotSpot = SpawnBonusSpotOnRay(new Ray(info.PointStart, info.attackNormal));
				}
				float num = (((Object)(object)_hotSpot != (Object)null) ? Vector3.Distance(info.HitPositionWorld, ((Component)_hotSpot).transform.position) : float.MaxValue);
				if (flag || num <= ((Component)_hotSpot).GetComponent<SphereCollider>().radius * 1.5f || (Object)(object)jackhammer != (Object)null)
				{
					float num2 = (((Object)(object)jackhammer == (Object)null) ? 1f : jackhammer.HotspotBonusScale);
					bonusesKilled++;
					info.gatherScale = 1f + Mathf.Clamp((float)bonusesKilled * 0.5f, 0f, 2f * num2);
					if ((Object)(object)_hotSpot != (Object)null)
					{
						_hotSpot.FireFinishEffect();
						ClientRPC<int, Vector3>(null, "PlayBonusLevelSound", bonusesKilled, ((Component)_hotSpot).transform.position);
					}
				}
				else if (bonusesKilled > 0)
				{
					bonusesKilled = 0;
					Effect.server.Run(bonusFailEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up);
				}
				if (bonusesKilled > 0)
				{
					CleanupBonus();
				}
				if ((Object)(object)_hotSpot == (Object)null)
				{
					if (flag)
					{
						spawnBonusHitRay = new Ray(info.PointStart, info.attackNormal);
						Vector3 val = info.PointStart - (((Component)this).transform.position + new Vector3(0f, 0.5f, 0f));
						lastNodeDir = ((Vector3)(ref val)).normalized;
						float num3 = 0.5f;
						if (lastNodeDir.y > num3)
						{
							float num4 = lastNodeDir.y - num3;
							lastNodeDir.y = num4;
							lastNodeDir.x += num4;
							lastNodeDir.z += num4;
						}
						lastNodeDir = ((Component)this).transform.InverseTransformDirection(lastNodeDir);
					}
					DelayedBonusSpawn();
				}
			}
			else
			{
				info.gatherScale = 1f;
			}
		}
		base.OnAttacked(info);
	}

	public OreHotSpot GetHotSpot()
	{
		return _hotSpot;
	}

	public override void UpdateNetworkStage()
	{
		int num = stage;
		base.UpdateNetworkStage();
		if (stage != num && Object.op_Implicit((Object)(object)_hotSpot) && useHotspotMinigame)
		{
			DelayedBonusSpawn();
		}
	}

	public void CleanupBonus()
	{
		if (Object.op_Implicit((Object)(object)_hotSpot))
		{
			_hotSpot.Kill();
		}
		_hotSpot = null;
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		CleanupBonus();
	}

	public override void OnDied(HitInfo info)
	{
		CleanupBonus();
		base.OnDied(info);
	}

	public void FinishBonusAssigned()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(finishEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up);
	}

	public void DelayedBonusSpawn()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)RespawnBonus);
		((FacepunchBehaviour)this).Invoke((Action)RespawnBonus, 0.25f);
	}

	public void RespawnBonus()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		CleanupBonus();
		if (spawnBonusHitRay.HasValue)
		{
			_hotSpot = SpawnBonusSpotOnRay(spawnBonusHitRay.Value);
			spawnBonusHitRay = null;
		}
		else
		{
			_hotSpot = SpawnBonusSpot(lastNodeDir);
		}
	}

	private OreHotSpot SpawnBonusSpotOnRay(Ray r)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return null;
		}
		if (!useHotspotMinigame)
		{
			return null;
		}
		if (!bonusPrefab.isValid)
		{
			return null;
		}
		RaycastHit val = default(RaycastHit);
		if (((Collider)ResourceMeshCollider).Raycast(r, ref val, 15f))
		{
			OreHotSpot obj = GameManager.server.CreateEntity(bonusPrefab.resourcePath, ((RaycastHit)(ref val)).point - ((Ray)(ref r)).direction * 0.025f, Quaternion.LookRotation(((RaycastHit)(ref val)).normal, Vector3.up)) as OreHotSpot;
			obj.Spawn();
			obj.OreOwner(this);
			return obj;
		}
		return SpawnBonusSpot(lastNodeDir);
	}

	public OreHotSpot SpawnBonusSpot(Vector3 lastDirection)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return null;
		}
		if (!useHotspotMinigame)
		{
			return null;
		}
		if (!bonusPrefab.isValid)
		{
			return null;
		}
		Vector3 zero = Vector3.zero;
		MeshCollider resourceMeshCollider = ResourceMeshCollider;
		Transform transform = ((Component)this).transform;
		Bounds val = ((Collider)resourceMeshCollider).bounds;
		Vector3 val2 = transform.InverseTransformPoint(((Bounds)(ref val)).center);
		Vector3 val6;
		if (lastDirection == Vector3.zero)
		{
			float num = 0.5f;
			if (heightOffset != 0f)
			{
				num = heightOffset;
			}
			Vector3 val3 = RandomCircle();
			Vector3 val4 = (lastNodeDir = ((Component)this).transform.TransformDirection(((Vector3)(ref val3)).normalized));
			val3 = ((Component)this).transform.position + ((Component)this).transform.up * (val2.y + num) + ((Vector3)(ref val4)).normalized * 5f;
			zero = val3;
		}
		else
		{
			Vector3 val5 = Vector3.Cross(lastNodeDir, Vector3.up);
			float num2 = Random.Range(0.25f, 0.5f) + (float)stage * 0.25f;
			float num3 = ((Random.Range(0, 2) == 0) ? (-1f) : 1f);
			val6 = lastNodeDir + val5 * (num2 * num3);
			Vector3 val7 = (lastNodeDir = ((Vector3)(ref val6)).normalized);
			zero = ((Component)this).transform.position + ((Component)this).transform.TransformDirection(val7) * 2f;
			float num4 = Random.Range(1f, 1.5f);
			zero += ((Component)this).transform.up * (val2.y + num4);
		}
		bonusesSpawned++;
		val = ((Collider)resourceMeshCollider).bounds;
		val6 = ((Bounds)(ref val)).center - zero;
		Vector3 normalized = ((Vector3)(ref val6)).normalized;
		RaycastHit val8 = default(RaycastHit);
		if (((Collider)resourceMeshCollider).Raycast(new Ray(zero, normalized), ref val8, 15f))
		{
			OreHotSpot obj = GameManager.server.CreateEntity(bonusPrefab.resourcePath, ((RaycastHit)(ref val8)).point - normalized * 0.025f, Quaternion.LookRotation(((RaycastHit)(ref val8)).normal, Vector3.up)) as OreHotSpot;
			obj.Spawn();
			obj.OreOwner(this);
			return obj;
		}
		return null;
	}

	public Vector3 RandomCircle(float distance = 1f, bool allowInside = false)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val;
		if (!allowInside)
		{
			Vector2 insideUnitCircle = Random.insideUnitCircle;
			val = ((Vector2)(ref insideUnitCircle)).normalized;
		}
		else
		{
			val = Random.insideUnitCircle;
		}
		Vector2 val2 = val;
		return new Vector3(val2.x, 0f, val2.y);
	}

	public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset, bool allowInside = true, bool changeHeight = true)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		degreesOffset = Mathf.Clamp(degreesOffset / 180f, -180f, 180f);
		Vector2 val;
		if (!allowInside)
		{
			Vector2 insideUnitCircle = Random.insideUnitCircle;
			val = ((Vector2)(ref insideUnitCircle)).normalized;
		}
		else
		{
			val = Random.insideUnitCircle;
		}
		Vector2 val2 = val;
		Vector3 val3 = default(Vector3);
		((Vector3)(ref val3))..ctor(val2.x * degreesOffset, changeHeight ? (Random.Range(-1f, 1f) * degreesOffset) : 0f, val2.y * degreesOffset);
		Vector3 val4 = input + val3;
		return ((Vector3)(ref val4)).normalized;
	}

	public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		degreesOffset = Mathf.Clamp(degreesOffset / 180f, -180f, 180f);
		Vector3 val = hemiInput + Vector3.one * degreesOffset;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = hemiInput + Vector3.one * (0f - degreesOffset);
		Vector3 normalized2 = ((Vector3)(ref val)).normalized;
		for (int i = 0; i < 3; i++)
		{
			((Vector3)(ref inputVec))[i] = Mathf.Clamp(((Vector3)(ref inputVec))[i], ((Vector3)(ref normalized2))[i], ((Vector3)(ref normalized))[i]);
		}
		return inputVec;
	}

	public static Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight = 0f, float maxHeight = 0f, bool allowInside = false)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val;
		if (!allowInside)
		{
			Vector2 insideUnitCircle = Random.insideUnitCircle;
			val = ((Vector2)(ref insideUnitCircle)).normalized;
		}
		else
		{
			val = Random.insideUnitCircle;
		}
		Vector2 val2 = val;
		Vector3 val3 = new Vector3(val2.x, 0f, val2.y);
		Vector3 result = ((Vector3)(ref val3)).normalized * distance;
		result.y = Random.Range(minHeight, maxHeight);
		return result;
	}

	public Vector3 ClampToCylinder(Vector3 localPos, Vector3 cylinderAxis, float cylinderDistance, float minHeight = 0f, float maxHeight = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.zero;
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class OrientableLight : SimpleLight
{
	public Transform pivotOrigin;

	public Transform yaw;

	public Transform pitch;

	public bool pivotAutoAdjust = true;

	[Space]
	public Vector2 pitchClamp = new Vector2(-50f, 50f);

	public Vector2 yawClamp = new Vector2(-50f, 50f);

	[Space]
	public float serverLerpSpeed = 15f;

	public float clientLerpSpeed = 10f;

	[Space]
	public GameObjectRef reorientEffect;

	public const Flags Flag_FacingDown = Flags.Reserved18;

	private float pitchAmount;

	private float yawAmount;

	private float lastPitchAmount;

	private float lastYawAmount;

	public static Phrase TipPhrase = new Phrase("gametip_spotlight", "Use a hammer to adjust the spotlight direction");

	private bool IsFacingDown => HasFlag(Flags.Reserved18);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("OrientableLight.OnRpcMessage", 0);
		try
		{
			if (rpc == 3353964129u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_SetDir "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_SetDir", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3353964129u, "SERVER_SetDir", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3353964129u, "SERVER_SetDir", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_SetDir(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_SetDir");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return 5;
	}

	public void UpdateRotation(float delta)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			Quaternion val = Quaternion.Euler(pitchAmount, 0f, 0f);
			Quaternion val2 = Quaternion.Euler(0f, yawAmount, 0f);
			((Component)pitch).transform.localRotation = Mathx.Lerp(((Component)pitch).transform.localRotation, val, serverLerpSpeed, delta);
			((Component)yaw).transform.localRotation = Mathx.Lerp(((Component)yaw).transform.localRotation, val2, serverLerpSpeed, delta);
		}
	}

	private void ResetRotation()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		lastPitchAmount = 0f;
		lastYawAmount = 0f;
		((Component)yaw).transform.localRotation = Quaternion.identity;
		((Component)pitch).transform.localRotation = Quaternion.identity;
		SetPivot();
	}

	private void SetPivot()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (pivotAutoAdjust)
		{
			if (IsFacingDown)
			{
				pivotOrigin.localRotation = Quaternion.Euler(90f, 0f, 180f);
			}
			else
			{
				pivotOrigin.localRotation = Quaternion.identity;
			}
		}
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		bool b = Mathf.Abs(Vector3.Dot(((Component)this).transform.forward, Vector3.up)) > 0.9f;
		SetFlag(Flags.Reserved18, b);
		SetPivot();
	}

	public void ServerTick()
	{
		if (!base.IsDestroyed)
		{
			UpdateRotation(Time.deltaTime);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		ResetRotation();
		ClientRPC(RpcTarget.Player("CLIENT_OnDeployed", deployedBy));
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_SetDir(RPCMessage msg)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (player.CanBuild())
		{
			Vector3 val = Vector3Ex.Direction(player.eyes.position, ((Component)yaw).transform.position);
			Ray val2 = player.eyes.HeadRay();
			Vector3 normWorld = ((Ray)(ref val2)).direction;
			Vector3 normalized = ((Vector3)(ref normWorld)).normalized;
			normWorld = Vector3.Lerp(val, normalized, 0.3f);
			Vector3 normalized2 = ((Vector3)(ref normWorld)).normalized;
			Quaternion val3 = Quaternion.LookRotation(Quaternion.Inverse(pivotOrigin.rotation) * normalized2);
			Vector3 val4 = BaseMountable.ConvertVector(((Quaternion)(ref val3)).eulerAngles);
			float num = val4.x;
			float num2 = val4.y;
			if (!IsFacingDown)
			{
				num = Mathf.Clamp(num, pitchClamp.x, pitchClamp.y);
				num2 = Mathf.Clamp(num2, yawClamp.x, yawClamp.y);
			}
			pitchAmount += Mathf.DeltaAngle(pitchAmount, num);
			yawAmount += Mathf.DeltaAngle(yawAmount, num2);
			if (reorientEffect.isValid)
			{
				string resourcePath = reorientEffect.resourcePath;
				Vector3 position = ((Component)this).transform.position;
				normWorld = default(Vector3);
				Effect.server.Run(resourcePath, position, normWorld);
			}
			SendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.rcEntity == null)
		{
			info.msg.rcEntity = Pool.Get<RCEntity>();
		}
		info.msg.rcEntity.aim.x = pitchAmount;
		info.msg.rcEntity.aim.y = yawAmount;
		info.msg.rcEntity.aim.z = 0f;
		if (!base.isServer)
		{
			return;
		}
		if (lastPitchAmount != pitchAmount || lastYawAmount != yawAmount)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)ServerTick, 0f, 0f);
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ServerTick);
			}, 5f);
		}
		lastPitchAmount = pitchAmount;
		lastYawAmount = yawAmount;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.rcEntity != null && base.isServer)
		{
			pitchAmount = info.msg.rcEntity.aim.x;
			yawAmount = info.msg.rcEntity.aim.y;
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using TMPro;
using UnityEngine;
using UnityEngine.Assertions;

public class OrnateFrame : PhotoFrame
{
	[Header("Ornate Frame Dependencies")]
	public TextMeshPro frameTextComponent;

	public GameObjectRef configureFrameDialog;

	private string __sync_FrameText;

	private Color __sync_TextColour;

	[Sync(Autosave = true)]
	public string FrameText
	{
		[CompilerGenerated]
		get
		{
			return __sync_FrameText;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_FrameText, value))
			{
				__sync_FrameText = value;
				byte nameID = __GetWeaverID("FrameText");
				QueueSyncVar(nameID);
			}
		}
	}

	[Sync(Autosave = true)]
	public Color TextColour
	{
		[CompilerGenerated]
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return __sync_TextColour;
		}
		[CompilerGenerated]
		set
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!IsSyncVarEqual<Color>(__sync_TextColour, value))
			{
				__sync_TextColour = value;
				byte nameID = __GetWeaverID("TextColour");
				QueueSyncVar(nameID);
			}
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("OrnateFrame.OnRpcMessage", 0);
		try
		{
			if (rpc == 3398916869u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ConfigureFrame "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ConfigureFrame", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3398916869u, "RPC_ConfigureFrame", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3398916869u, "RPC_ConfigureFrame", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_ConfigureFrame(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_ConfigureFrame");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual bool CanUpdateFrame(BasePlayer player)
	{
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

	public override void ServerInit()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		TextColour = Color.black;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	public void RPC_ConfigureFrame(RPCMessage msg)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		string frameText = msg.read.String(256, false);
		Color textColour = msg.read.Color();
		SetFrameText(frameText);
		SetTextColour(textColour);
	}

	public void SetFrameText(string text)
	{
		FrameText = text;
	}

	public void SetTextColour(Color colour)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		TextColour = colour;
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId iD;
		switch (id)
		{
		case 1:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: FrameText for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_FrameText);
			return true;
		case 2:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: TextColour for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite<Color>(writer, __sync_TextColour);
			return true;
		default:
			return base.WriteSyncVar(id, writer);
		}
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		switch (id)
		{
		case 1:
			try
			{
				_ = __sync_FrameText;
				string _sync_FrameText = reader.String(256, false);
				__sync_FrameText = _sync_FrameText;
			}
			catch (Exception ex2)
			{
				Debug.LogException(ex2);
			}
			return true;
		case 2:
			try
			{
				_ = __sync_TextColour;
				Color _sync_TextColour = reader.Color();
				__sync_TextColour = _sync_TextColour;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			return true;
		default:
			return base.OnSyncVar(id, reader, fromAutoSave);
		}
	}

	private byte __GetWeaverID(string propertyName)
	{
		if (!(propertyName == "FrameText"))
		{
			if (propertyName == "TextColour")
			{
				return 2;
			}
			return byte.MaxValue;
		}
		return 1;
	}

	protected override void WriteAutoSaveSyncVars(NetWrite writer)
	{
		base.WriteAutoSaveSyncVars(writer);
		WriteSyncVar(1, writer);
		WriteSyncVar(2, writer);
	}

	protected override void ReadAutoSaveSyncVars(NetRead reader)
	{
		base.ReadAutoSaveSyncVars(reader);
		OnSyncVar(1, reader, fromAutoSave: true);
		OnSyncVar(2, reader, fromAutoSave: true);
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		base.AutoSaveSyncVars(save);
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteAutoSaveSyncVars(val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		base.AutoLoadSyncVars(load);
		if (load.msg.baseEntity != null && load.msg.baseEntity.syncVars != null)
		{
			NetRead val = Pool.Get<NetRead>();
			val.Init(load.msg.baseEntity.syncVars.AsSpan());
			ReadAutoSaveSyncVars(val);
			Pool.Free<NetRead>(ref val);
		}
		return true;
	}

	protected override void ResetSyncVars()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		base.ResetSyncVars();
		__sync_FrameText = null;
		__sync_TextColour = default(Color);
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		return id switch
		{
			1 => true, 
			2 => true, 
			_ => base.ShouldInvalidateCache(id), 
		};
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class PagerEntity : BaseEntity, IRFObject
{
	public static Flags Flag_Silent = Flags.Reserved1;

	private int frequency = 55;

	public float beepRepeat = 2f;

	public GameObjectRef pagerEffect;

	public GameObjectRef silentEffect;

	private float nextChangeTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PagerEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 2778616053u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSetFrequency "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSetFrequency", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2778616053u, "ServerSetFrequency", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerSetFrequency(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerSetFrequency");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public int GetFrequency()
	{
		return frequency;
	}

	public override void SwitchParent(BaseEntity ent)
	{
		SetParent(ent, worldPositionStays: false, sendImmediate: true);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		RFManager.AddListener(frequency, this);
	}

	internal override void DoServerDestroy()
	{
		RFManager.RemoveListener(frequency, this);
		base.DoServerDestroy();
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public float GetMaxRange()
	{
		return float.PositiveInfinity;
	}

	public void RFSignalUpdate(bool on)
	{
		if (!base.IsDestroyed)
		{
			bool flag = IsOn();
			if (on != flag)
			{
				SetFlag(Flags.On, on);
				SendNetworkUpdate();
			}
		}
	}

	public void SetSilentMode(bool wantsSilent)
	{
		SetFlag(Flag_Silent, wantsSilent);
	}

	public void SetOff()
	{
		SetFlag(Flags.On, b: false);
	}

	public void ChangeFrequency(int newFreq)
	{
		RFManager.ChangeFrequency(frequency, newFreq, this, isListener: true);
		frequency = newFreq;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void ServerSetFrequency(RPCMessage msg)
	{
		if (!((Object)(object)msg.player == (Object)null) && msg.player.CanBuild() && !(Time.time < nextChangeTime))
		{
			nextChangeTime = Time.time + 2f;
			int num = msg.read.Int32();
			if (Interface.CallHook("OnRfFrequencyChange", (object)this, (object)num, (object)msg.player) == null)
			{
				RFManager.ChangeFrequency(frequency, num, this, isListener: true);
				frequency = num;
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnRfFrequencyChanged", (object)this, (object)num, (object)msg.player);
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.genericInt1 = frequency;
	}

	internal override void OnParentRemoved()
	{
		SetParent(null, worldPositionStays: false, sendImmediate: true);
	}

	public void OnParentDestroying()
	{
		if (base.isServer)
		{
			((Component)this).transform.parent = null;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			frequency = info.msg.ioEntity.genericInt1;
		}
		if (base.isServer && info.fromDisk)
		{
			ChangeFrequency(frequency);
		}
	}
}


using System;
using ConVar;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class PaintballGun : BaseProjectile
{
	[Header("Paintball Gun")]
	public Renderer[] worldModelAmmoRenderers;

	private static readonly int shaderProperty_Fill = Shader.PropertyToID("_Fill");

	private static readonly int shaderProperty_Color = Shader.PropertyToID("_Color");

	private static MaterialPropertyBlock ammoRendererBlock;

	private int currentPaintballColor;

	private int paintballColorPreReload;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PaintballGun.OnRpcMessage", 0);
		try
		{
			if (rpc == 3661258788u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_PaintballColorChanged "));
				}
				TimeWarning val2 = TimeWarning.New("Server_PaintballColorChanged", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3661258788u, "Server_PaintballColorChanged", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_PaintballColorChanged(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_PaintballColorChanged");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int GetImpactEffectNumberValue(HitInfo hitInfo)
	{
		BasePlayer initiatorPlayer = hitInfo.InitiatorPlayer;
		if ((Object)(object)initiatorPlayer == (Object)null)
		{
			return 0;
		}
		if (initiatorPlayer.isServer)
		{
			return initiatorPlayer.server_paintballColor;
		}
		return 0;
	}

	public override DamageType GetDamageTypeForEffect(HitInfo info)
	{
		return DamageType.Paintball;
	}

	public override Effect.Type GetEffectType(HitInfo info)
	{
		if (info.HitEntity.IsValid() && info.HitEntity.GetImpactEffect(info).isValid)
		{
			return base.GetEffectType(info);
		}
		return Effect.Type.PaintballSplat;
	}

	public override bool ForceSendMagazine(SaveInfo saveInfo)
	{
		return true;
	}

	public override void DidAttackServerside()
	{
		SendNetworkUpdate();
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Server_PaintballColorChanged(RPCMessage msg)
	{
		if (PaintballColorLookup.instance == null)
		{
			Debug.LogError((object)"Failed to retrieve PaintballColorLookup instance");
			return;
		}
		int num = currentPaintballColor;
		int num2 = msg.read.Int32();
		if (num != num2)
		{
			currentPaintballColor = Mathf.Clamp(num2, 0, PaintballColorLookup.instance.GetColorsCount() - 1);
			BasePlayer player = msg.player;
			player.Server_UpdatePaintballColor(currentPaintballColor);
			if (primaryMagazine.contents > 0)
			{
				player.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
				SetAmmoCount(0);
			}
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			player.inventory.ServerUpdate(0f);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class PaintedItemStorageEntity : BaseEntity, IServerFileReceiver, IUGCBrowserEntity
{
	public uint _currentImageCrc;

	private ulong lastEditedBy;

	public uint[] GetContentCRCs
	{
		get
		{
			if (_currentImageCrc == 0)
			{
				return Array.Empty<uint>();
			}
			return new uint[1] { _currentImageCrc };
		}
	}

	public UGCType ContentType => UGCType.ImageJpg;

	public List<ulong> EditingHistory
	{
		get
		{
			if (lastEditedBy == 0)
			{
				return new List<ulong>();
			}
			return new List<ulong> { lastEditedBy };
		}
	}

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public override bool ShouldTransferAssociatedFiles => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PaintedItemStorageEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 2439017595u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_UpdateImage "));
				}
				TimeWarning val2 = TimeWarning.New("Server_UpdateImage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2439017595u, "Server_UpdateImage", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_UpdateImage(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_UpdateImage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.paintedItem != null)
		{
			_currentImageCrc = info.msg.paintedItem.imageCrc;
			if (base.isServer)
			{
				lastEditedBy = info.msg.paintedItem.editedBy;
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.paintedItem = Pool.Get<PaintedItem>();
		info.msg.paintedItem.imageCrc = _currentImageCrc;
		info.msg.paintedItem.editedBy = lastEditedBy;
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	private void Server_UpdateImage(RPCMessage msg)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null || (ulong)msg.player.userID != base.OwnerID)
		{
			return;
		}
		foreach (Item item2 in msg.player.inventory.containerWear.itemList)
		{
			if (item2.instanceData != null && item2.instanceData.subEntity == net.ID)
			{
				return;
			}
		}
		Item item = msg.player.inventory.FindBySubEntityID(net.ID);
		if (item == null || item.isBroken)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (array == null)
		{
			if (_currentImageCrc != 0)
			{
				FileStorage.server.RemoveExact(_currentImageCrc, FileStorage.Type.png, net.ID, 0u);
			}
			_currentImageCrc = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 512, 512))
			{
				return;
			}
			uint currentImageCrc = _currentImageCrc;
			if (_currentImageCrc != 0)
			{
				FileStorage.server.RemoveExact(_currentImageCrc, FileStorage.Type.png, net.ID, 0u);
			}
			_currentImageCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
			if (_currentImageCrc != currentImageCrc)
			{
				item.LoseCondition(0.25f);
			}
			lastEditedBy = msg.player.userID;
		}
		Interface.CallHook("OnItemPainted", (object)this, (object)item, (object)msg.player, (object)array);
		SendNetworkUpdate();
	}

	internal override void DoServerDestroy()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		if (!Application.isQuitting && net != null)
		{
			FileStorage.server.RemoveAllByEntity(net.ID);
		}
	}

	public void ClearContent()
	{
		_currentImageCrc = 0u;
		SendNetworkUpdate();
	}

	[Conditional("PAINTED_ITEM_DEBUG")]
	private void DebugOnlyLog(string str)
	{
		Debug.Log((object)str, (Object)(object)this);
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using ntw.CurvedTextMeshPro;
using Rust.UI;
using UnityEngine;
using UnityEngine.Assertions;

public class PartyBalloon : BaseCombatEntity
{
	[Header("Party Balloon Dependencies")]
	public RustText balloonTextComponent;

	public RustText backsideBalloonTextComponent;

	public TextProOnACircle textProOnACircleComponent;

	public TextProOnACircle backsideTextProOnACircleComponent;

	public GameObjectRef configureBalloonDialog;

	public List<Renderer> balloonRenderers;

	[Header("Party Balloon Text Settings")]
	public int arcRadCharactersLimit = 20;

	public int minArcDegrees = 12;

	public int maxArcDegrees = 37;

	public int textLinesLimit = 4;

	public float minLineHeight = 10f;

	public float maxLineHeight = 30f;

	public float fontSizeDivider = 1f;

	[Header("Party Balloon FX")]
	public GameObjectRef partyBalloonPopFX;

	private static readonly int COLOR = Shader.PropertyToID("_Color");

	private string __sync_BalloonText;

	private Color __sync_BalloonColour;

	private Color __sync_TextColour;

	[Sync(Autosave = true)]
	public string BalloonText
	{
		[CompilerGenerated]
		get
		{
			return __sync_BalloonText;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_BalloonText, value))
			{
				__sync_BalloonText = value;
				byte nameID = __GetWeaverID("BalloonText");
				QueueSyncVar(nameID);
			}
		}
	}

	[Sync(Autosave = true)]
	public Color BalloonColour
	{
		[CompilerGenerated]
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return __sync_BalloonColour;
		}
		[CompilerGenerated]
		set
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!IsSyncVarEqual<Color>(__sync_BalloonColour, value))
			{
				__sync_BalloonColour = value;
				byte nameID = __GetWeaverID("BalloonColour");
				QueueSyncVar(nameID);
			}
		}
	}

	[Sync(Autosave = true)]
	public Color TextColour
	{
		[CompilerGenerated]
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return __sync_TextColour;
		}
		[CompilerGenerated]
		set
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!IsSyncVarEqual<Color>(__sync_TextColour, value))
			{
				__sync_TextColour = value;
				byte nameID = __GetWeaverID("TextColour");
				QueueSyncVar(nameID);
			}
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PartyBalloon.OnRpcMessage", 0);
		try
		{
			if (rpc == 1887711985 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - LockBalloon "));
				}
				TimeWarning val2 = TimeWarning.New("LockBalloon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1887711985u, "LockBalloon", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							LockBalloon(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in LockBalloon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 473707823 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ConfigureBalloon "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ConfigureBalloon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(473707823u, "RPC_ConfigureBalloon", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(473707823u, "RPC_ConfigureBalloon", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_ConfigureBalloon(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_ConfigureBalloon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2622659557u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UnLockBalloon "));
				}
				TimeWarning val2 = TimeWarning.New("UnLockBalloon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2622659557u, "UnLockBalloon", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							UnLockBalloon(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in UnLockBalloon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual bool CanUpdateBalloon(BasePlayer player)
	{
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

	public bool CanUnlockBalloon(BasePlayer player)
	{
		if (!IsLocked())
		{
			return false;
		}
		return CanUpdateBalloon(player);
	}

	public bool CanLockBalloon(BasePlayer player)
	{
		if (IsLocked())
		{
			return false;
		}
		return CanUpdateBalloon(player);
	}

	public override void ServerInit()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		BalloonColour = Color.white;
		TextColour = Color.white;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	public void RPC_ConfigureBalloon(RPCMessage msg)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		string balloonText = msg.read.String(256, false);
		Color balloonColour = msg.read.Color();
		Color textColour = msg.read.Color();
		SetBalloonText(balloonText);
		SetBalloonColour(balloonColour);
		SetTextColour(textColour);
	}

	public void SetBalloonText(string text)
	{
		BalloonText = text;
	}

	public void SetBalloonColour(Color colour)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		BalloonColour = colour;
	}

	public void SetTextColour(Color colour)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		TextColour = colour;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void LockBalloon(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateBalloon(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void UnLockBalloon(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUnlockBalloon(msg.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId iD;
		switch (id)
		{
		case 0:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: BalloonText for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_BalloonText);
			return true;
		case 1:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: BalloonColour for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite<Color>(writer, __sync_BalloonColour);
			return true;
		case 2:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: TextColour for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite<Color>(writer, __sync_TextColour);
			return true;
		default:
			return base.WriteSyncVar(id, writer);
		}
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		switch (id)
		{
		case 0:
			try
			{
				_ = __sync_BalloonText;
				string _sync_BalloonText = reader.String(256, false);
				__sync_BalloonText = _sync_BalloonText;
			}
			catch (Exception ex2)
			{
				Debug.LogException(ex2);
			}
			return true;
		case 1:
			try
			{
				_ = __sync_BalloonColour;
				Color _sync_BalloonColour = reader.Color();
				__sync_BalloonColour = _sync_BalloonColour;
			}
			catch (Exception ex3)
			{
				Debug.LogException(ex3);
			}
			return true;
		case 2:
			try
			{
				_ = __sync_TextColour;
				Color _sync_TextColour = reader.Color();
				__sync_TextColour = _sync_TextColour;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			return true;
		default:
			return base.OnSyncVar(id, reader, fromAutoSave);
		}
	}

	private byte __GetWeaverID(string propertyName)
	{
		return propertyName switch
		{
			"BalloonText" => 0, 
			"BalloonColour" => 1, 
			"TextColour" => 2, 
			_ => byte.MaxValue, 
		};
	}

	protected override void WriteAutoSaveSyncVars(NetWrite writer)
	{
		base.WriteAutoSaveSyncVars(writer);
		WriteSyncVar(0, writer);
		WriteSyncVar(1, writer);
		WriteSyncVar(2, writer);
	}

	protected override void ReadAutoSaveSyncVars(NetRead reader)
	{
		base.ReadAutoSaveSyncVars(reader);
		OnSyncVar(0, reader, fromAutoSave: true);
		OnSyncVar(1, reader, fromAutoSave: true);
		OnSyncVar(2, reader, fromAutoSave: true);
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		base.AutoSaveSyncVars(save);
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteAutoSaveSyncVars(val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		base.AutoLoadSyncVars(load);
		if (load.msg.baseEntity != null && load.msg.baseEntity.syncVars != null)
		{
			NetRead val = Pool.Get<NetRead>();
			val.Init(load.msg.baseEntity.syncVars.AsSpan());
			ReadAutoSaveSyncVars(val);
			Pool.Free<NetRead>(ref val);
		}
		return true;
	}

	protected override void ResetSyncVars()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		base.ResetSyncVars();
		__sync_BalloonText = null;
		__sync_BalloonColour = default(Color);
		__sync_TextColour = default(Color);
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		return id switch
		{
			0 => true, 
			1 => true, 
			2 => true, 
			_ => base.ShouldInvalidateCache(id), 
		};
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class PatrolHelicopter : BaseCombatEntity, SeekerTarget.ISeekerTargetOwner
{
	[Serializable]
	public class weakspot
	{
		[NonSerialized]
		public PatrolHelicopter body;

		public string[] bonenames;

		public float maxHealth;

		public float health;

		public float healthFractionOnDestroyed = 0.5f;

		public GameObjectRef destroyedParticles;

		public GameObjectRef damagedParticles;

		public GameObject damagedEffect;

		public GameObject destroyedEffect;

		public List<BasePlayer> attackers;

		private bool isDestroyed;

		public float HealthFraction()
		{
			return health / maxHealth;
		}

		public void Hurt(float amount, HitInfo info)
		{
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			if (!isDestroyed)
			{
				health -= amount;
				Effect.server.Run(damagedParticles.resourcePath, body, StringPool.Get(bonenames[Random.Range(0, bonenames.Length)]), Vector3.zero, Vector3.up, null, broadcast: true);
				if (health <= 0f)
				{
					health = 0f;
					WeakspotDestroyed();
				}
			}
		}

		public void Heal(float amount)
		{
			health += amount;
		}

		public void WeakspotDestroyed()
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			isDestroyed = true;
			Effect.server.Run(destroyedParticles.resourcePath, body, StringPool.Get(bonenames[Random.Range(0, bonenames.Length)]), Vector3.zero, Vector3.up, null, broadcast: true);
			body.Hurt(body.MaxHealth() * healthFractionOnDestroyed, DamageType.Generic, null, useProtection: false);
		}
	}

	public GameObject rotorPivot;

	public GameObject mainRotor;

	public GameObject mainRotor_blades;

	public GameObject mainRotor_blur;

	public GameObject tailRotor;

	public GameObject tailRotor_blades;

	public GameObject tailRotor_blur;

	public GameObject rocket_tube_left;

	public GameObject rocket_tube_right;

	public GameObject left_gun_yaw;

	public GameObject left_gun_pitch;

	public GameObject left_gun_muzzle;

	public GameObject right_gun_yaw;

	public GameObject right_gun_pitch;

	public GameObject right_gun_muzzle;

	public GameObject spotlight_rotation;

	public GameObjectRef rocket_fire_effect;

	public GameObjectRef gun_fire_effect;

	public GameObjectRef bulletEffect;

	public GameObjectRef explosionEffect;

	public GameObjectRef fireBall;

	public GameObjectRef crateToDrop;

	public int maxCratesToSpawn = 4;

	public float bulletSpeed = 250f;

	public float bulletDamage = 20f;

	public GameObjectRef servergibs;

	public GameObjectRef debrisFieldMarker;

	public float flareDuration = 5f;

	public SoundDefinition rotorWashSoundDef;

	private Sound _rotorWashSound;

	public SoundDefinition flightEngineSoundDef;

	public SoundDefinition flightThwopsSoundDef;

	private Sound flightEngineSound;

	private Sound flightThwopsSound;

	public SoundModulation.Modulator flightEngineGainMod;

	public SoundModulation.Modulator flightThwopsGainMod;

	public float rotorGainModSmoothing = 0.25f;

	public float engineGainMin = 0.5f;

	public float engineGainMax = 1f;

	public float thwopGainMin = 0.5f;

	public float thwopGainMax = 1f;

	public float spotlightJitterAmount = 5f;

	public float spotlightJitterSpeed = 5f;

	public GameObject[] nightLights;

	public Vector3 spotlightTarget;

	public float engineSpeed = 1f;

	public float targetEngineSpeed = 1f;

	public float blur_rotationScale = 0.05f;

	public ParticleSystem[] _rotorWashParticles;

	public PatrolHelicopterAI myAI;

	public GameObjectRef mapMarkerEntityPrefab;

	public GameObjectRef fleeMapMarkerEntityPrefab;

	public static PatrolHelicopter Instance;

	public static BaseEntity ClientFleeMapMarker;

	public float lastNetworkUpdate = float.NegativeInfinity;

	private const float networkUpdateRate = 0.25f;

	private BaseEntity mapMarkerInstance;

	private BaseEntity fleeMapMarkerInstance;

	public weakspot[] weakspots;

	private NetworkableId __sync_FleeMarkerId;

	[Sync(Autosave = true)]
	public NetworkableId FleeMarkerId
	{
		[CompilerGenerated]
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return __sync_FleeMarkerId;
		}
		[CompilerGenerated]
		set
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!IsSyncVarEqual<NetworkableId>(__sync_FleeMarkerId, value))
			{
				__sync_FleeMarkerId = value;
				byte nameID = __GetWeaverID("FleeMarkerId");
				QueueSyncVar(nameID);
			}
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PatrolHelicopter.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float AntiHackVelocity()
	{
		return 100f;
	}

	public override void InitShared()
	{
		base.InitShared();
		InitalizeWeakspots();
		Instance = this;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.helicopter != null)
		{
			spotlightTarget = info.msg.helicopter.spotlightVec;
		}
	}

	public void RadarLock(SeekingServerProjectile incoming)
	{
		if (!((FacepunchBehaviour)this).IsInvoking((Action)CancelRadar))
		{
			SetFlag(Flags.Reserved8, b: true);
			((FacepunchBehaviour)this).Invoke((Action)CancelRadar, 5f);
		}
	}

	public void CancelRadar()
	{
		SetFlag(Flags.Reserved8, b: false);
	}

	public override void Save(SaveInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.helicopter = Pool.Get<Helicopter>();
		Helicopter helicopter = info.msg.helicopter;
		Quaternion localRotation = rotorPivot.transform.localRotation;
		helicopter.tiltRot = ((Quaternion)(ref localRotation)).eulerAngles;
		info.msg.helicopter.spotlightVec = spotlightTarget;
		info.msg.helicopter.weakspothealths = Pool.Get<List<float>>();
		for (int i = 0; i < weakspots.Length; i++)
		{
			info.msg.helicopter.weakspothealths.Add(weakspots[i].health);
		}
	}

	public override void ServerInit()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		myAI = ((Component)this).GetComponent<PatrolHelicopterAI>();
		if (!myAI.hasInterestZone)
		{
			myAI.SetInitialDestination(Vector3.zero, 1.25f);
			myAI.targetThrottleSpeed = 1f;
			myAI.ExitCurrentState();
			myAI.State_Patrol_Enter();
		}
		CreateMapMarker();
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		}
		if ((Object)(object)fleeMapMarkerInstance != (Object)null)
		{
			DestroyFleeMarker();
		}
		Instance = null;
		base.DestroyShared();
	}

	public void CreateMapMarker()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)mapMarkerInstance))
		{
			mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.SetParent(this);
		baseEntity.Spawn();
		mapMarkerInstance = baseEntity;
	}

	public bool HasFleeMarker()
	{
		if ((Object)(object)fleeMapMarkerInstance != (Object)null)
		{
			return fleeMapMarkerInstance.IsValid();
		}
		return false;
	}

	public void CreateFleeMarker(Vector3 fleePosition)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)fleeMapMarkerInstance))
		{
			fleeMapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(fleeMapMarkerEntityPrefab.resourcePath, fleePosition, Quaternion.identity);
		baseEntity.Spawn();
		fleeMapMarkerInstance = baseEntity;
		FleeMarkerId = fleeMapMarkerInstance.net.ID;
	}

	public void DestroyFleeMarker()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (HasFleeMarker())
		{
			fleeMapMarkerInstance.Kill();
			fleeMapMarkerInstance = null;
			FleeMarkerId = default(NetworkableId);
		}
	}

	public override void OnPositionalNetworkUpdate()
	{
		SendNetworkUpdate();
		base.OnPositionalNetworkUpdate();
	}

	public void CreateExplosionMarker(float durationMinutes)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(debrisFieldMarker.resourcePath, ((Component)this).transform.position, Quaternion.identity);
		baseEntity.Spawn();
		((Component)baseEntity).SendMessage("SetDuration", (object)durationMinutes, (SendMessageOptions)1);
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_031e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		CreateExplosionMarker(10f);
		Effect.server.Run(explosionEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
		Vector3 val = myAI.GetLastMoveDir() * myAI.GetMoveSpeed() * 0.75f;
		GameObject gibSource = servergibs.Get().GetComponent<ServerGib>()._gibSource;
		List<ServerGib> list = ServerGib.CreateGibs(servergibs.resourcePath, ((Component)this).gameObject, gibSource, val, 3f);
		if (info.damageTypes.GetMajorityDamageType() != DamageType.Decay)
		{
			for (int i = 0; i < 12 - maxCratesToSpawn; i++)
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
				if (!Object.op_Implicit((Object)(object)baseEntity))
				{
					continue;
				}
				float num = 3f;
				float num2 = 10f;
				Vector3 onUnitSphere = Random.onUnitSphere;
				((Component)baseEntity).transform.position = ((Component)this).transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * Random.Range(-4f, 4f);
				Collider component = ((Component)baseEntity).GetComponent<Collider>();
				baseEntity.Spawn();
				baseEntity.SetVelocity(val + onUnitSphere * Random.Range(num, num2));
				foreach (ServerGib item in list)
				{
					Physics.IgnoreCollision(component, (Collider)(object)item.GetCollider(), true);
				}
			}
		}
		for (int j = 0; j < maxCratesToSpawn; j++)
		{
			Vector3 onUnitSphere2 = Random.onUnitSphere;
			Vector3 pos = ((Component)this).transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere2 * Random.Range(2f, 3f);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));
			baseEntity2.Spawn();
			LootContainer lootContainer = baseEntity2 as LootContainer;
			if (Object.op_Implicit((Object)(object)lootContainer))
			{
				((FacepunchBehaviour)lootContainer).Invoke((Action)lootContainer.RemoveMe, 1800f);
			}
			Collider component2 = ((Component)baseEntity2).GetComponent<Collider>();
			Rigidbody val2 = ((Component)baseEntity2).gameObject.AddComponent<Rigidbody>();
			val2.useGravity = true;
			val2.collisionDetectionMode = (CollisionDetectionMode)2;
			val2.mass = 2f;
			val2.interpolation = (RigidbodyInterpolation)1;
			val2.velocity = val + onUnitSphere2 * Random.Range(1f, 3f);
			val2.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
			val2.drag = 0.5f * (val2.mass / 5f);
			val2.angularDrag = 0.2f * (val2.mass / 5f);
			FireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;
			if (Object.op_Implicit((Object)(object)fireBall))
			{
				fireBall.SetParent(baseEntity2);
				fireBall.Spawn();
				((Component)fireBall).GetComponent<Rigidbody>().isKinematic = true;
				((Component)fireBall).GetComponent<Collider>().enabled = false;
			}
			((Component)baseEntity2).SendMessage("SetLockingEnt", (object)((Component)fireBall).gameObject, (SendMessageOptions)1);
			foreach (ServerGib item2 in list)
			{
				Physics.IgnoreCollision(component2, (Collider)(object)item2.GetCollider(), true);
			}
			Interface.CallHook("OnCrateSpawned", (object)this, (object)baseEntity2);
		}
		base.OnDied(info);
	}

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		base.OnEntityMessage(from, msg);
		if (msg == "RadarLock" && !((FacepunchBehaviour)this).IsInvoking((Action)DoFlare))
		{
			((FacepunchBehaviour)this).Invoke((Action)DoFlare, Random.Range(0.5f, 1f));
		}
	}

	public void DoFlare()
	{
		SetFlag(Flags.OnFire, b: true);
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		((FacepunchBehaviour)this).Invoke((Action)ClearFlares, flareDuration);
	}

	public void ClearFlares()
	{
		SetFlag(Flags.OnFire, b: false);
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
	}

	public void Update()
	{
		if (base.isServer && Time.realtimeSinceStartup - lastNetworkUpdate >= 0.25f)
		{
			SendNetworkUpdate();
			lastNetworkUpdate = Time.realtimeSinceStartup;
		}
	}

	public void InitalizeWeakspots()
	{
		weakspot[] array = weakspots;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].body = this;
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer)
		{
			myAI.WasAttacked(info);
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (Interface.CallHook("OnPatrolHelicopterTakeDamage", (object)this, (object)info) != null)
		{
			return;
		}
		bool flag = false;
		if (info.damageTypes.Total() >= base.health)
		{
			if (Interface.CallHook("OnPatrolHelicopterKill", (object)this, (object)info) != null)
			{
				return;
			}
			base.health = 10000f;
			myAI.CriticalDamage();
			flag = true;
		}
		base.Hurt(info);
		if (flag)
		{
			return;
		}
		myAI.OtherDamaged(info);
		weakspot[] array = weakspots;
		foreach (weakspot weakspot in array)
		{
			string[] bonenames = weakspot.bonenames;
			foreach (string str in bonenames)
			{
				if (info.HitBone == StringPool.Get(str))
				{
					weakspot.Hurt(info.damageTypes.Total(), info);
					myAI.WeakspotDamaged(weakspot, info);
				}
			}
		}
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (id == 0)
		{
			if (Global.developer > 2)
			{
				NetworkableId iD = net.ID;
				Debug.Log((object)("SyncVar Writing: FleeMarkerId for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite<NetworkableId>(writer, __sync_FleeMarkerId);
			return true;
		}
		return base.WriteSyncVar(id, writer);
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (id == 0)
		{
			try
			{
				_ = __sync_FleeMarkerId;
				NetworkableId _sync_FleeMarkerId = reader.EntityID();
				__sync_FleeMarkerId = _sync_FleeMarkerId;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			return true;
		}
		return base.OnSyncVar(id, reader, fromAutoSave);
	}

	private byte __GetWeaverID(string propertyName)
	{
		if (propertyName == "FleeMarkerId")
		{
			return 0;
		}
		return byte.MaxValue;
	}

	protected override void WriteAutoSaveSyncVars(NetWrite writer)
	{
		base.WriteAutoSaveSyncVars(writer);
		WriteSyncVar(0, writer);
	}

	protected override void ReadAutoSaveSyncVars(NetRead reader)
	{
		base.ReadAutoSaveSyncVars(reader);
		OnSyncVar(0, reader, fromAutoSave: true);
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		base.AutoSaveSyncVars(save);
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteAutoSaveSyncVars(val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		base.AutoLoadSyncVars(load);
		if (load.msg.baseEntity != null && load.msg.baseEntity.syncVars != null)
		{
			NetRead val = Pool.Get<NetRead>();
			val.Init(load.msg.baseEntity.syncVars.AsSpan());
			ReadAutoSaveSyncVars(val);
			Pool.Free<NetRead>(ref val);
		}
		return true;
	}

	protected override void ResetSyncVars()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.ResetSyncVars();
		__sync_FleeMarkerId = default(NetworkableId);
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		if (id == 0)
		{
			return true;
		}
		return base.ShouldInvalidateCache(id);
	}
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

[Serializable]
public class weakspot
{
	[NonSerialized]
	public PatrolHelicopter body;

	public string[] bonenames;

	public float maxHealth;

	public float health;

	public float healthFractionOnDestroyed = 0.5f;

	public GameObjectRef destroyedParticles;

	public GameObjectRef damagedParticles;

	public GameObject damagedEffect;

	public GameObject destroyedEffect;

	public List<BasePlayer> attackers;

	private bool isDestroyed;

	public float HealthFraction()
	{
		return health / maxHealth;
	}

	public void Hurt(float amount, HitInfo info)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (!isDestroyed)
		{
			health -= amount;
			Effect.server.Run(damagedParticles.resourcePath, body, StringPool.Get(bonenames[Random.Range(0, bonenames.Length)]), Vector3.zero, Vector3.up, null, broadcast: true);
			if (health <= 0f)
			{
				health = 0f;
				WeakspotDestroyed();
			}
		}
	}

	public void Heal(float amount)
	{
		health += amount;
	}

	public void WeakspotDestroyed()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		isDestroyed = true;
		Effect.server.Run(destroyedParticles.resourcePath, body, StringPool.Get(bonenames[Random.Range(0, bonenames.Length)]), Vector3.zero, Vector3.up, null, broadcast: true);
		body.Hurt(body.MaxHealth() * healthFractionOnDestroyed, DamageType.Generic, null, useProtection: false);
	}
}


using System;
using Network;
using Rust;
using UnityEngine;

public class PetBrain : BaseAIBrain
{
	[Header("Audio")]
	public SoundDefinition CommandGivenVocalSFX;

	[ServerVar]
	public static bool DrownInDeepWater = true;

	[ServerVar]
	public static bool IdleWhenOwnerOfflineOrDead = true;

	[ServerVar]
	public static bool IdleWhenOwnerMounted = true;

	[ServerVar]
	public static float DrownTimer = 15f;

	[ReplicatedVar]
	public static float ControlDistance = 100f;

	public static int Count;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PetBrain.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void AddStates()
	{
		base.AddStates();
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new HumanPathFinder();
		((HumanPathFinder)base.PathFinder).Init(GetBaseEntity());
		Count++;
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		Count--;
	}

	public override void Think(float delta)
	{
		base.Think(delta);
		if (DrownInDeepWater)
		{
			BaseCombatEntity baseCombatEntity = GetBaseEntity() as BaseCombatEntity;
			if ((Object)(object)baseCombatEntity != (Object)null && baseCombatEntity.WaterFactor() > 0.85f && !baseCombatEntity.IsDestroyed)
			{
				baseCombatEntity.Hurt(delta * (baseCombatEntity.MaxHealth() / DrownTimer), DamageType.Drowned);
			}
		}
		EvaluateLoadDefaultDesignTriggers();
	}

	private bool EvaluateLoadDefaultDesignTriggers()
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (loadedDesignIndex == 0)
		{
			return true;
		}
		bool flag = false;
		if (IdleWhenOwnerOfflineOrDead)
		{
			flag = (IdleWhenOwnerOfflineOrDead && (Object)(object)base.OwningPlayer == (Object)null) || base.OwningPlayer.IsSleeping() || base.OwningPlayer.IsDead();
		}
		if (IdleWhenOwnerMounted && !flag)
		{
			flag = (Object)(object)base.OwningPlayer != (Object)null && base.OwningPlayer.isMounted;
		}
		if ((Object)(object)base.OwningPlayer != (Object)null && Vector3.Distance(((Component)this).transform.position, ((Component)base.OwningPlayer).transform.position) > ControlDistance)
		{
			flag = true;
		}
		if (flag)
		{
			LoadDefaultAIDesign();
			return true;
		}
		return false;
	}

	public override void OnAIDesignLoadedAtIndex(int index)
	{
		base.OnAIDesignLoadedAtIndex(index);
		BaseEntity baseEntity = GetBaseEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(baseEntity.OwnerID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.SendClientPetStateIndex();
			}
			baseEntity.ClientRPC(RpcTarget.NetworkGroup("OnCommandGiven"));
		}
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class PhotoFrame : StorageContainer, ILOD, IImageReceiver, ISignage, IUGCBrowserEntity, IEaselPaintable
{
	private const float TextureRequestDistance = 100f;

	public EntityRef _photoEntity;

	public uint _overlayTextureCrc;

	private EaselDeployable _cachedParentEasel;

	private List<ulong> editHistory = new List<ulong>();

	public GameObjectRef SignEditorDialog;

	public OverlayMeshPaintableSource PaintableSource;

	private NetworkableId __sync_EaselId;

	public GameObject GameObject => ((Component)this).gameObject;

	[Sync(Autosave = true)]
	public NetworkableId EaselId
	{
		[CompilerGenerated]
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return __sync_EaselId;
		}
		[CompilerGenerated]
		set
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!IsSyncVarEqual<NetworkableId>(__sync_EaselId, value))
			{
				__sync_EaselId = value;
				byte nameID = __GetWeaverID("EaselId");
				QueueSyncVar(nameID);
			}
		}
	}

	public EaselDeployable parentEasel
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			NetworkableId easelId = EaselId;
			if (!((NetworkableId)(ref easelId)).IsValid)
			{
				return null;
			}
			if ((Object)(object)_cachedParentEasel == (Object)null)
			{
				_cachedParentEasel = new EntityRef<EaselDeployable>(EaselId).Get(base.isServer);
			}
			return _cachedParentEasel;
		}
	}

	public NetworkableId NetworkID => net.ID;

	public FileStorage.Type FileType => FileStorage.Type.png;

	public UGCType ContentType => UGCType.ImagePng;

	public List<ulong> EditingHistory => editHistory;

	public uint[] GetContentCRCs => new uint[1] { _overlayTextureCrc };

	public override bool ShouldTransferAssociatedFiles => true;

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public Vector2i TextureSize => new Vector2i(PaintableSource.texWidth, PaintableSource.texHeight);

	public int TextureCount => 1;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PhotoFrame.OnRpcMessage", 0);
		try
		{
			if (rpc == 1455609404 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - LockSign "));
				}
				TimeWarning val2 = TimeWarning.New("LockSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1455609404u, "LockSign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							LockSign(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in LockSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4149904254u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UnLockSign "));
				}
				TimeWarning val2 = TimeWarning.New("UnLockSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4149904254u, "UnLockSign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							UnLockSign(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UnLockSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1255380462 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdateSign "));
				}
				TimeWarning val2 = TimeWarning.New("UpdateSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1255380462u, "UpdateSign", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1255380462u, "UpdateSign", this, player, 5f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							UpdateSign(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in UpdateSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.photoFrame != null)
		{
			_photoEntity.uid = info.msg.photoFrame.photoEntityId;
			_overlayTextureCrc = info.msg.photoFrame.overlayImageCrc;
		}
		if (!base.isServer || info.msg.photoFrame == null)
		{
			return;
		}
		if (info.msg.photoFrame.editHistory != null)
		{
			if (editHistory == null)
			{
				editHistory = Pool.Get<List<ulong>>();
			}
			editHistory.Clear();
			{
				foreach (ulong item in info.msg.photoFrame.editHistory)
				{
					editHistory.Add(item);
				}
				return;
			}
		}
		if (editHistory != null)
		{
			Pool.FreeUnmanaged<ulong>(ref editHistory);
		}
	}

	public uint[] GetTextureCRCs()
	{
		return new uint[1] { _overlayTextureCrc };
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.photoFrame = Pool.Get<PhotoFrame>();
		info.msg.photoFrame.photoEntityId = _photoEntity.uid;
		info.msg.photoFrame.overlayImageCrc = _overlayTextureCrc;
		if (editHistory.Count <= 0)
		{
			return;
		}
		info.msg.photoFrame.editHistory = Pool.Get<List<ulong>>();
		foreach (ulong item in editHistory)
		{
			info.msg.photoFrame.editHistory.Add(item);
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		base.OnItemAddedOrRemoved(item, added);
		Item item2 = ((base.inventory.itemList.Count > 0) ? base.inventory.itemList[0] : null);
		NetworkableId val = (NetworkableId)((item2 != null && item2.IsValid()) ? item2.instanceData.subEntity : default(NetworkableId));
		if (val != _photoEntity.uid)
		{
			_photoEntity.uid = val;
			SendNetworkUpdate();
		}
	}

	public override void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
	{
		base.OnPickedUpPreItemMove(createdItem, player);
		RemoveFromEasel();
		SaveSignageToItem(createdItem);
	}

	public void SaveSignageToItem(Item createdItem)
	{
		ItemModSign itemModSign = default(ItemModSign);
		if (_overlayTextureCrc != 0 && ((Component)createdItem.info).TryGetComponent<ItemModSign>(ref itemModSign))
		{
			itemModSign.OnSignPickedUp(this, this, createdItem);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		AddToEasel(parent);
		ItemModSign itemModSign = default(ItemModSign);
		if (((Component)fromItem.info).TryGetComponent<ItemModSign>(ref itemModSign))
		{
			SignContent associatedEntity = ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(fromItem);
			if ((Object)(object)associatedEntity != (Object)null)
			{
				associatedEntity.CopyInfoToSign(this, this);
			}
		}
	}

	public void SetTextureCRCs(uint[] crcs)
	{
		if (crcs.Length != 0)
		{
			_overlayTextureCrc = crcs[0];
			SendNetworkUpdate();
		}
	}

	private void LogEdit(BasePlayer byPlayer)
	{
		if (!editHistory.Contains(byPlayer.userID))
		{
			editHistory.Insert(0, byPlayer.userID);
			int num = 0;
			while (editHistory.Count > 5 && num < 10)
			{
				editHistory.RemoveAt(5);
				num++;
			}
		}
	}

	public void ClearContent()
	{
		_overlayTextureCrc = 0u;
		SendNetworkUpdate();
	}

	public void RemoveFromEasel()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)parentEasel != (Object)null)
		{
			parentEasel.RemovePainting(this);
		}
		EaselId = default(NetworkableId);
	}

	public void AddToEasel(BaseEntity parent)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)parent != (Object)null && parent is EaselDeployable easelDeployable)
		{
			EaselId = easelDeployable.net.ID;
			easelDeployable.SetPainting(this);
		}
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId uid = _photoEntity.uid;
		if (((NetworkableId)(ref uid)).IsValid)
		{
			pickupErrorToFormat = (format: PickupErrors.ItemMustBeEmpty, arg0: pickup.itemTarget.displayName);
			return false;
		}
		if (base.CanCompletePickup(player))
		{
			uid = _photoEntity.uid;
			return !((NetworkableId)(ref uid)).IsValid;
		}
		return false;
	}

	public bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

	public bool CanUnlockSign(BasePlayer player)
	{
		if (!IsLocked())
		{
			return false;
		}
		return CanUpdateSign(player);
	}

	public bool CanLockSign(BasePlayer player)
	{
		if (IsLocked())
		{
			return false;
		}
		return CanUpdateSign(player);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(5f)]
	[RPC_Server.CallsPerSecond(3uL)]
	public void UpdateSign(RPCMessage msg)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)msg.player == (Object)null) && CanUpdateSign(msg.player))
		{
			byte[] array = msg.read.BytesWithSize(10485760u, false);
			if (array != null && ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				FileStorage.server.RemoveAllByEntity(net.ID);
				_overlayTextureCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
				LogEdit(msg.player);
				SendNetworkUpdate();
				Interface.CallHook("OnSignUpdated", (object)this, (object)msg.player);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", (object)this, (object)msg.player);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void UnLockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUnlockSign(msg.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (net != null)
		{
			FileStorage.server.RemoveAllByEntity(net.ID);
		}
		_overlayTextureCrc = 0u;
		RemoveFromEasel();
		base.OnDied(info);
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public override string Categorize()
	{
		return "sign";
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (id == 0)
		{
			if (Global.developer > 2)
			{
				NetworkableId iD = net.ID;
				Debug.Log((object)("SyncVar Writing: EaselId for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite<NetworkableId>(writer, __sync_EaselId);
			return true;
		}
		return base.WriteSyncVar(id, writer);
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (id == 0)
		{
			try
			{
				_ = __sync_EaselId;
				NetworkableId _sync_EaselId = reader.EntityID();
				__sync_EaselId = _sync_EaselId;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			return true;
		}
		return base.OnSyncVar(id, reader, fromAutoSave);
	}

	private byte __GetWeaverID(string propertyName)
	{
		if (propertyName == "EaselId")
		{
			return 0;
		}
		return byte.MaxValue;
	}

	protected override void WriteAutoSaveSyncVars(NetWrite writer)
	{
		base.WriteAutoSaveSyncVars(writer);
		WriteSyncVar(0, writer);
	}

	protected override void ReadAutoSaveSyncVars(NetRead reader)
	{
		base.ReadAutoSaveSyncVars(reader);
		OnSyncVar(0, reader, fromAutoSave: true);
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		base.AutoSaveSyncVars(save);
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteAutoSaveSyncVars(val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		base.AutoLoadSyncVars(load);
		if (load.msg.baseEntity != null && load.msg.baseEntity.syncVars != null)
		{
			NetRead val = Pool.Get<NetRead>();
			val.Init(load.msg.baseEntity.syncVars.AsSpan());
			ReadAutoSaveSyncVars(val);
			Pool.Free<NetRead>(ref val);
		}
		return true;
	}

	protected override void ResetSyncVars()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.ResetSyncVars();
		__sync_EaselId = default(NetworkableId);
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		if (id == 0)
		{
			return true;
		}
		return base.ShouldInvalidateCache(id);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Planner : HeldEntity
{
	public struct CanBuildResult
	{
		public bool Result;

		public Phrase Phrase;

		public string[] Arguments;
	}

	public BaseEntity[] buildableList;

	public virtual bool isTypeDeployable => (Object)(object)GetModDeployable() != (Object)null;

	public Vector3 serverStartDurationPlacementPosition { get; private set; }

	public TimeSince serverStartDurationPlacementTime { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Planner.OnRpcMessage", 0);
		try
		{
			if (rpc == 1872774636 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoPlace "));
				}
				TimeWarning val2 = TimeWarning.New("DoPlace", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1872774636u, "DoPlace", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoPlace(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoPlace");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3892284151u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartDurationPlace "));
				}
				TimeWarning val2 = TimeWarning.New("StartDurationPlace", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3892284151u, "StartDurationPlace", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(3892284151u, "StartDurationPlace", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							StartDurationPlace(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in StartDurationPlace");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public ItemModDeployable GetModDeployable()
	{
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		if ((Object)(object)ownerItemDefinition == (Object)null)
		{
			return null;
		}
		return ((Component)ownerItemDefinition).GetComponent<ItemModDeployable>();
	}

	public virtual Deployable GetDeployable()
	{
		ItemModDeployable modDeployable = GetModDeployable();
		if ((Object)(object)modDeployable == (Object)null)
		{
			return null;
		}
		return modDeployable.GetDeployable(this);
	}

	public virtual Deployable GetDeployable(NetworkableId entityId)
	{
		return GetDeployable();
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoPlace(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		CreateBuilding val = msg.read.Proto<CreateBuilding>((CreateBuilding)null);
		try
		{
			DoBuild(val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server.IsActiveItem]
	private void StartDurationPlace(RPCMessage msg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (Object.op_Implicit((Object)(object)ownerPlayer))
		{
			serverStartDurationPlacementPosition = ((Component)ownerPlayer).transform.position;
			serverStartDurationPlacementTime = TimeSince.op_Implicit(0f);
		}
	}

	public Socket_Base FindSocket(string name, uint prefabIDToFind)
	{
		return PrefabAttribute.server.FindAll<Socket_Base>(prefabIDToFind).FirstOrDefault((Socket_Base s) => s.socketName == name);
	}

	public virtual void DoBuild(CreateBuilding msg)
	{
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return;
		}
		if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredMovementAntiHack())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.AntihackWithReason, false, ownerPlayer.lastViolationType.ToString());
			return;
		}
		Construction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);
		if (construction == null)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindConstruction, false);
			ConstructionErrors.Log(ownerPlayer, msg.blockID.ToString());
			return;
		}
		if (!CanAffordToPlace(construction))
		{
			ItemAmountList val = Pool.Get<ItemAmountList>();
			try
			{
				val.amount = Pool.Get<List<float>>();
				val.itemID = Pool.Get<List<int>>();
				GetConstructionCost(val, construction);
				ownerPlayer.ClientRPC(RpcTarget.Player("Client_OnRepairFailedResources", ownerPlayer), val);
				return;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
			return;
		}
		Deployable deployable = GetDeployable(msg.entity);
		if (construction.deployable != deployable)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.DeployableMismatch, false);
			return;
		}
		Construction.Target target = default(Construction.Target);
		if (((NetworkableId)(ref msg.entity)).IsValid)
		{
			target.entity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;
			if ((Object)(object)target.entity == (Object)null)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindEntity, false);
				ConstructionErrors.Log(ownerPlayer, ((object)(NetworkableId)(ref msg.entity)/*cast due to .constrained prefix*/).ToString());
				return;
			}
			msg.ray = new Ray(((Component)target.entity).transform.TransformPoint(((Ray)(ref msg.ray)).origin), ((Component)target.entity).transform.TransformDirection(((Ray)(ref msg.ray)).direction));
			msg.position = ((Component)target.entity).transform.TransformPoint(msg.position);
			msg.normal = ((Component)target.entity).transform.TransformDirection(msg.normal);
			msg.rotation = ((Component)target.entity).transform.rotation * msg.rotation;
			if (msg.socket != 0)
			{
				string text = StringPool.Get(msg.socket);
				if (text != "")
				{
					target.socket = FindSocket(text, target.entity.prefabID);
				}
				if (target.socket == null)
				{
					ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindSocket, false);
					ConstructionErrors.Log(ownerPlayer, msg.socket.ToString());
					return;
				}
			}
			else if (target.entity is Door)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantDeployOnDoor, false);
				return;
			}
		}
		target.ray = msg.ray;
		target.onTerrain = msg.onterrain;
		target.position = msg.position;
		target.normal = msg.normal;
		target.rotation = msg.rotation;
		target.player = ownerPlayer;
		target.isHoldingShift = msg.isHoldingShift;
		target.valid = true;
		if (Interface.CallHook("CanBuild", (object)this, (object)construction, (object)target) != null)
		{
			return;
		}
		if (ShouldParent(target.entity, deployable))
		{
			PlayerBoat parentPlayerBoat = PlayerBoat.GetParentPlayerBoat(target.entity, includeEntityItself: true);
			if ((Object)(object)parentPlayerBoat != (Object)null)
			{
				if (!parentPlayerBoat.CanAcceptDeployable())
				{
					ownerPlayer.ShowToast(GameTip.Styles.Error, BoatBuildingStation.invalidTooManyDeployablesPhrase, false);
					return;
				}
				if (!construction.canBypassBuildingPermission && !parentPlayerBoat.IsAuthedForBuilding(ownerPlayer))
				{
					return;
				}
			}
			Vector3 position = ((target.socket != null) ? target.GetWorldPosition() : target.position);
			float num = target.entity.Distance(position);
			if (num > 1f)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.ParentTooFar, false);
				ConstructionErrors.Log(ownerPlayer, num.ToString());
				return;
			}
		}
		BaseEntity baseEntity = DoBuild(target, construction);
		if ((Object)(object)baseEntity != (Object)null && baseEntity is BuildingBlock buildingBlock && ownerPlayer.IsInCreativeMode && Creative.freeBuild)
		{
			ConstructionGrade constructionGrade = construction.grades[msg.setToGrade];
			if (buildingBlock.currentGrade != constructionGrade)
			{
				buildingBlock.ChangeGradeAndSkin(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
			}
		}
		if ((Object)(object)baseEntity != (Object)null && baseEntity is DecayEntity decayEntity)
		{
			decayEntity.timePlaced = GetNetworkTime();
		}
	}

	public virtual BaseEntity DoBuild(Construction.Target target, Construction component)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_0407: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_038b: Unknown result type (might be due to invalid IL or missing references)
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return null;
		}
		if (target.ray.IsNaNOrInfinity())
		{
			return null;
		}
		if (Vector3Ex.IsNaNOrInfinity(target.position))
		{
			return null;
		}
		if (Vector3Ex.IsNaNOrInfinity(target.normal))
		{
			return null;
		}
		Construction.lastPlacementError = Phrase.op_Implicit("");
		Construction.lastPlacementErrorDebug = "";
		Construction.lastBuildingBlockError = null;
		Construction.lastPlacementErrorIsDetailed = false;
		if (target.socket != null)
		{
			if (!target.socket.female)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.SocketNotFemale, false);
				Construction.lastPlacementErrorDebug = target.socket.socketName;
				return null;
			}
			if ((Object)(object)target.entity != (Object)null && target.entity.IsOccupied(target.socket))
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.SocketOccupied, false);
				Construction.lastPlacementErrorDebug = target.socket.socketName;
				return null;
			}
			if (target.onTerrain)
			{
				Construction.lastPlacementErrorDebug = "Target on terrain is not allowed when attaching to socket (" + target.socket.socketName + ")";
				return null;
			}
		}
		Vector3 deployPos = (((Object)(object)target.entity != (Object)null && target.socket != null) ? target.GetWorldPosition() : target.position);
		if (AntiHack.TestIsBuildingInsideSomething(target, deployPos))
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.InsideObjects, false);
			return null;
		}
		if (ConVar.AntiHack.eye_protection >= 2 && !component.HasAlternativeLOSChecks() && !HasLineOfSight(ownerPlayer, deployPos, target, component))
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.LineOfSightBlocked, false);
			return null;
		}
		if (Server.max_sleeping_bags > 0)
		{
			CanBuildResult? result = SleepingBag.CanBuildBed(ownerPlayer, component);
			if (HandleCanBuild(result, ownerPlayer))
			{
				return null;
			}
		}
		GameObject val = DoPlacement(target, component);
		if ((Object)(object)val == (Object)null)
		{
			if (!string.IsNullOrEmpty(Construction.lastPlacementError.translated))
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, Construction.lastPlacementError, false);
			}
			ConstructionErrors.Log(ownerPlayer, Construction.lastPlacementErrorDebug);
		}
		if ((Object)(object)val != (Object)null)
		{
			Interface.CallHook("OnEntityBuilt", (object)this, (object)val);
			Deployable deployable = GetDeployable();
			BaseEntity baseEntity = val.ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)null && deployable != null)
			{
				if (ShouldParent(target.entity, deployable))
				{
					if (target.socket is Socket_Specific_Female socket_Specific_Female)
					{
						if (socket_Specific_Female.parentToBone)
						{
							baseEntity.SetParent(target.entity, socket_Specific_Female.boneName, worldPositionStays: true);
						}
						else
						{
							baseEntity.SetParent(target.entity, worldPositionStays: true);
						}
					}
					else
					{
						baseEntity.SetParent(target.entity, worldPositionStays: true);
					}
				}
				if (deployable.wantsInstanceData && GetOwnerItem().instanceData != null)
				{
					(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);
				}
				if (deployable.copyInventoryFromItem)
				{
					StorageContainer component2 = ((Component)baseEntity).GetComponent<StorageContainer>();
					if (Object.op_Implicit((Object)(object)component2))
					{
						component2.ReceiveInventoryFromItem(GetOwnerItem());
					}
					if ((Object)(object)component2 == (Object)null)
					{
						ContainerIOEntity component3 = ((Component)baseEntity).GetComponent<ContainerIOEntity>();
						if (Object.op_Implicit((Object)(object)component3))
						{
							component3.ReceiveInventoryFromItem(GetOwnerItem());
						}
					}
				}
				ItemModDeployable modDeployable = GetModDeployable();
				if ((Object)(object)modDeployable != (Object)null)
				{
					modDeployable.OnDeployed(baseEntity, ownerPlayer);
				}
				baseEntity.OnDeployed(baseEntity.GetParentEntity(), ownerPlayer, GetOwnerItem());
				if (deployable.placeEffect.isValid)
				{
					if (Object.op_Implicit((Object)(object)target.entity) && target.socket != null)
					{
						Effect.server.Run(deployable.placeEffect.resourcePath, ((Component)target.entity).transform.TransformPoint(target.socket.worldPosition), ((Component)target.entity).transform.up);
					}
					else
					{
						Effect.server.Run(deployable.placeEffect.resourcePath, target.position, target.normal);
					}
				}
			}
			if ((Object)(object)baseEntity != (Object)null)
			{
				Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);
				if ((Object)(object)GetOwnerItemDefinition() != (Object)null)
				{
					ownerPlayer.ProcessMissionEvent(BaseMission.MissionEventType.DEPLOY, new BaseMission.MissionEventPayload
					{
						WorldPosition = ((Component)baseEntity).transform.position,
						UintIdentifier = baseEntity.prefabID,
						IntIdentifier = GetOwnerItemDefinition().itemid
					}, 1f);
				}
			}
			PayForPlacement(ownerPlayer, component);
			return baseEntity;
		}
		return null;
	}

	public GameObject DoPlacement(Construction.Target placement, Construction component)
	{
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return null;
		}
		BaseEntity baseEntity = component.CreateConstruction(placement, bNeedsValidPlacement: true);
		if (!Object.op_Implicit((Object)(object)baseEntity))
		{
			return null;
		}
		float num = 1f;
		float num2 = 0f;
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			baseEntity.skinID = ownerItem.skin;
			if (ownerItem.hasCondition)
			{
				num = ownerItem.conditionNormalized;
			}
		}
		((Component)baseEntity).gameObject.AwakeFromInstantiate();
		BuildingBlock buildingBlock = baseEntity as BuildingBlock;
		if (Object.op_Implicit((Object)(object)buildingBlock))
		{
			buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
			if (!buildingBlock.blockDefinition)
			{
				Debug.LogError((object)"Placing a building block that has no block definition!");
				return null;
			}
			buildingBlock.SetGrade(buildingBlock.blockDefinition.defaultGrade.gradeBase.type);
		}
		BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
		if (Object.op_Implicit((Object)(object)baseCombatEntity))
		{
			num2 = (((Object)(object)buildingBlock != (Object)null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth);
			baseCombatEntity.ResetLifeStateOnSpawn = false;
			baseCombatEntity.InitializeHealth(num2 * num, baseCombatEntity.StartMaxHealth());
		}
		if (Interface.CallHook("OnConstructionPlace", (object)baseEntity, (object)component, (object)placement, (object)ownerPlayer) != null)
		{
			if (baseEntity.IsValid())
			{
				baseEntity.KillMessage();
			}
			else
			{
				DecayEntity decayEntity = baseEntity as DecayEntity;
				if (Object.op_Implicit((Object)(object)decayEntity))
				{
					decayEntity.DoServerDestroy();
				}
				baseEntity.TerminateOnServer();
				baseEntity.EntityDestroy();
			}
			return null;
		}
		baseEntity.OnPlaced(ownerPlayer);
		baseEntity.OwnerID = ownerPlayer.userID;
		baseEntity.Spawn();
		if (Object.op_Implicit((Object)(object)buildingBlock))
		{
			Effect.server.Run(buildingBlock.blockDefinition.placeEffect.isValid ? buildingBlock.blockDefinition.placeEffect.resourcePath : "assets/bundled/prefabs/fx/build/frame_place.prefab", baseEntity, 0u, Vector3.zero, Vector3.zero);
		}
		StabilityEntity stabilityEntity = baseEntity as StabilityEntity;
		if (Object.op_Implicit((Object)(object)stabilityEntity))
		{
			stabilityEntity.UpdateSurroundingEntities();
		}
		return ((Component)baseEntity).gameObject;
	}

	public virtual void PayForPlacement(BasePlayer player, Construction component)
	{
		if (Interface.CallHook("OnPayForPlacement", (object)player, (object)this, (object)component) != null || (player.IsInCreativeMode && Creative.freeBuild))
		{
			return;
		}
		if (player.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = player.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.OnPlayerBuiltConstruction(player);
			}
		}
		if (isTypeDeployable)
		{
			GetItem().UseItem();
			return;
		}
		List<Item> list = Pool.Get<List<Item>>();
		foreach (ItemAmount item in component.defaultGrade.CostToBuild())
		{
			player.inventory.Take(list, item.itemDef.itemid, (int)item.amount);
			player.Command("note.inv", item.itemDef.itemid, item.amount * -1f);
			Analytics.Azure.LogResource(Analytics.Azure.ResourceMode.Consumed, "build_block", item.itemDef.shortname, (int)item.amount, null, null, safezone: false, null, player.userID, null, null, null, 0uL);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
		Pool.Free<Item>(ref list, false);
	}

	public virtual bool CanAffordToPlace(Construction component)
	{
		if (isTypeDeployable)
		{
			return true;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAffordToPlace", (object)ownerPlayer, (object)this, (object)component);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ownerPlayer.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		foreach (ItemAmount item in component.defaultGrade.CostToBuild())
		{
			if ((float)ownerPlayer.inventory.GetAmount(item.itemDef.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

	protected virtual void GetConstructionCost(ItemAmountList list, Construction component)
	{
		list.amount.Clear();
		list.itemID.Clear();
		foreach (ItemAmount item in component.defaultGrade.CostToBuild())
		{
			list.itemID.Add(item.itemDef.itemid);
			list.amount.Add((int)item.amount);
		}
	}

	private bool ShouldParent(BaseEntity targetEntity, Deployable deployable)
	{
		if ((Object)(object)targetEntity != (Object)null && targetEntity.SupportsChildDeployables() && (targetEntity.ForceDeployableSetParent() || (deployable != null && deployable.setSocketParent)))
		{
			return true;
		}
		return false;
	}

	private bool HandleCanBuild(CanBuildResult? result, BasePlayer player)
	{
		if (result.HasValue)
		{
			if (result.Value.Phrase != null && !player.IsInTutorial)
			{
				player.ShowToast((!result.Value.Result) ? GameTip.Styles.Red_Normal : GameTip.Styles.Blue_Long, result.Value.Phrase, overlay: false, result.Value.Arguments);
			}
			if (!result.Value.Result)
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool HasLineOfSight(BasePlayer player, Vector3 deployPos, Construction.Target target, Construction component)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 center = player.eyes.center;
		Vector3 position = player.eyes.position;
		Vector3 origin = ((Ray)(ref target.ray)).origin;
		Vector3 val = deployPos;
		int num = 2097152;
		int num2 = 2162688;
		if (ConVar.AntiHack.build_terraincheck)
		{
			num2 |= 0x800000;
		}
		if (ConVar.AntiHack.build_vehiclecheck)
		{
			num2 |= 0x8000000;
		}
		float num3 = ConVar.AntiHack.build_losradius;
		float padding = ConVar.AntiHack.build_losradius + 0.01f;
		int layerMask = num2;
		if (target.socket != null)
		{
			num3 = 0f;
			padding = 0.5f;
			layerMask = num;
		}
		if (component.isSleepingBag)
		{
			num3 = ConVar.AntiHack.build_losradius_sleepingbag;
			padding = ConVar.AntiHack.build_losradius_sleepingbag + 0.01f;
			layerMask = num2;
		}
		if (num3 > 0f)
		{
			val += ((Vector3)(ref target.normal)).normalized * num3;
		}
		if ((Object)(object)target.entity != (Object)null)
		{
			DeployShell deployShell = PrefabAttribute.server.Find<DeployShell>(target.entity.prefabID);
			if (deployShell != null)
			{
				val += ((Vector3)(ref target.normal)).normalized * deployShell.LineOfSightPadding();
			}
		}
		if (GamePhysics.LineOfSightRadius(center, position, layerMask, num3) && GamePhysics.LineOfSightRadius(position, origin, layerMask, num3))
		{
			return GamePhysics.LineOfSightRadius(origin, val, layerMask, num3, 0f, padding);
		}
		return false;
	}

	public static bool HasLineOfSight(ref Construction.Placement placement, Construction construction, Construction.Target target)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = target.player;
		Vector3 center = player.eyes.center;
		Vector3 position = player.eyes.position;
		Vector3 origin = ((Ray)(ref target.ray)).origin;
		Vector3 val = (((Object)(object)target.entity != (Object)null && target.socket != null) ? target.GetWorldPosition() : target.position);
		int num = 2097152;
		int num2 = 2162688;
		if (ConVar.AntiHack.build_terraincheck)
		{
			num2 |= 0x800000;
		}
		if (ConVar.AntiHack.build_vehiclecheck)
		{
			num2 |= 0x8000000;
		}
		float num3 = ConVar.AntiHack.build_losradius;
		float padding = ConVar.AntiHack.build_losradius + 0.01f;
		int num4 = num2;
		if (target.socket != null)
		{
			num3 = 0f;
			padding = 0.5f;
			num4 = num;
		}
		if (construction.isSleepingBag)
		{
			num3 = ConVar.AntiHack.build_losradius_sleepingbag;
			padding = ConVar.AntiHack.build_losradius_sleepingbag + 0.01f;
			num4 = num2;
		}
		if (num3 > 0f)
		{
			val += ((Vector3)(ref target.normal)).normalized * num3;
		}
		if ((Object)(object)target.entity != (Object)null)
		{
			DeployShell deployShell = PrefabAttribute.server.Find<DeployShell>(target.entity.prefabID);
			if (deployShell != null)
			{
				val += ((Vector3)(ref target.normal)).normalized * deployShell.LineOfSightPadding();
			}
		}
		if (!GamePhysics.LineOfSightRadius(center, position, num4, num3) || !GamePhysics.LineOfSightRadius(position, origin, num4, num3))
		{
			return false;
		}
		bool flag = GamePhysics.LineOfSightRadius(origin, val, num4, num3, 0f, padding);
		if (!flag && target.socket != null && construction.HasAlternativeLOSChecks())
		{
			Vector3[] alternativeLOSPositions = construction.alternativeLOSPositions;
			foreach (Vector3 val2 in alternativeLOSPositions)
			{
				Vector3 val3 = placement.position + placement.rotation * val2 - origin;
				if (!Physics.Raycast(origin, val3, ((Vector3)(ref val3)).magnitude, num4))
				{
					return true;
				}
			}
		}
		return flag;
	}
}


public struct CanBuildResult
{
	public bool Result;

	public Phrase Phrase;

	public string[] Arguments;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class PlanterBox : StorageContainer, ISplashable
{
	public bool PlantPot;

	public int soilSaturation;

	public int soilSaturationMax = 8000;

	public MeshRenderer soilRenderer;

	[ServerVar]
	public static float outsideTestDistance = 100f;

	private static readonly float MinimumSaturationTriggerLevel = ConVar.Server.optimalPlanterQualitySaturation - 0.2f;

	private static readonly float MaximumSaturationTriggerLevel = ConVar.Server.optimalPlanterQualitySaturation + 0.1f;

	public TimeCachedValue<float> sunExposure;

	public TimeCachedValue<float> artificialLightExposure;

	public TimeCachedValue<float> plantTemperature;

	public TimeCachedValue<float> plantArtificalTemperature;

	private TimeSince lastSplashNetworkUpdate;

	private TimeSince lastRainCheck;

	public float soilSaturationFraction => (float)soilSaturation / (float)soilSaturationMax;

	public int availableIdealWaterCapacity => Mathf.Max(availableIdealWaterCapacity, Mathf.Max(idealSaturation - soilSaturation, 0));

	public int availableWaterCapacity => soilSaturationMax - soilSaturation;

	public int idealSaturation => Mathf.FloorToInt((float)soilSaturationMax * ConVar.Server.optimalPlanterQualitySaturation);

	public bool BelowMinimumSaturationTriggerLevel => soilSaturationFraction < MinimumSaturationTriggerLevel;

	public bool AboveMaximumSaturationTriggerLevel => soilSaturationFraction > MaximumSaturationTriggerLevel;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlanterBox.OnRpcMessage", 0);
		try
		{
			if (rpc == 2965786167u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestSaturationUpdate "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestSaturationUpdate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2965786167u, "RPC_RequestSaturationUpdate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_RequestSaturationUpdate(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_RequestSaturationUpdate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
		base.inventory.SetOnlyAllowedItem(allowedItem);
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(InventoryItemFilter));
		SetupTimeCaches();
		SplashableStaticGrid.RegisterSplashable(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		SplashableStaticGrid.DeregisterSplashable(this);
	}

	public virtual void SetupTimeCaches()
	{
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		sunExposure = new TimeCachedValue<float>
		{
			refreshCooldown = 30f,
			refreshRandomRange = 5f,
			updateValue = CalculateSunExposure
		};
		artificialLightExposure = new TimeCachedValue<float>
		{
			refreshCooldown = 60f,
			refreshRandomRange = 5f,
			updateValue = CalculateArtificialLightExposure
		};
		plantTemperature = new TimeCachedValue<float>
		{
			refreshCooldown = 20f,
			refreshRandomRange = 5f,
			updateValue = CalculatePlantTemperature
		};
		plantArtificalTemperature = new TimeCachedValue<float>
		{
			refreshCooldown = 60f,
			refreshRandomRange = 5f,
			updateValue = CalculateArtificialTemperature
		};
		lastRainCheck = TimeSince.op_Implicit(0f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)CalculateRainFactor, 20f, 30f, 15f);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		if (added && ItemIsFertilizer(item))
		{
			FertilizeGrowables();
		}
	}

	public bool InventoryItemFilter(Item item, int targetSlot)
	{
		if (item == null)
		{
			return false;
		}
		if (ItemIsFertilizer(item))
		{
			return true;
		}
		return false;
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (HasPlants())
		{
			pickupErrorToFormat = (format: PickupErrors.ItemMustBeEmpty, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	private bool ItemIsFertilizer(Item item)
	{
		return item.info.shortname == "fertilizer";
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.resource = Pool.Get<BaseResource>();
		info.msg.resource.stage = soilSaturation;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.resource != null)
		{
			soilSaturation = info.msg.resource.stage;
		}
	}

	public void FertilizeGrowables()
	{
		if (Interface.CallHook("OnPlanterBoxFertilize", (object)this) != null)
		{
			return;
		}
		int num = GetFertilizerCount();
		if (num <= 0)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			if ((Object)(object)child == (Object)null)
			{
				continue;
			}
			GrowableEntity growableEntity = child as GrowableEntity;
			if (!((Object)(object)growableEntity == (Object)null) && !growableEntity.Fertilized && ConsumeFertilizer())
			{
				growableEntity.Fertilize();
				num--;
				if (num == 0)
				{
					break;
				}
			}
		}
	}

	public int GetFertilizerCount()
	{
		int num = 0;
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null && ItemIsFertilizer(slot))
			{
				num += slot.amount;
			}
		}
		return num;
	}

	public bool ConsumeFertilizer()
	{
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null && ItemIsFertilizer(slot))
			{
				int num = Mathf.Min(1, slot.amount);
				if (num > 0)
				{
					slot.UseItem(num);
					return true;
				}
			}
		}
		return false;
	}

	public int ConsumeWater(int amount, GrowableEntity ignoreEntity = null)
	{
		int num = Mathf.Min(amount, soilSaturation);
		soilSaturation -= num;
		RefreshGrowables(ignoreEntity);
		SendNetworkUpdate();
		return num;
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if (base.IsDestroyed)
		{
			return false;
		}
		if ((Object)(object)splashType == (Object)null || splashType.shortname == null)
		{
			return false;
		}
		if (!((Object)(object)splashType == (Object)(object)WaterTypes.SaltWaterItemDef) && !((Object)(object)splashType == (Object)(object)WaterTypes.RadioactiveWaterItemDef))
		{
			return soilSaturation < soilSaturationMax;
		}
		return true;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)splashType == (Object)(object)WaterTypes.SaltWaterItemDef)
		{
			soilSaturation = 0;
			RefreshGrowables();
			if (TimeSince.op_Implicit(lastSplashNetworkUpdate) > 60f)
			{
				SendNetworkUpdate();
				lastSplashNetworkUpdate = TimeSince.op_Implicit(0f);
			}
			return amount;
		}
		if ((Object)(object)splashType == (Object)(object)WaterTypes.RadioactiveWaterItemDef)
		{
			soilSaturation = 0;
			KillAllPlants();
			if (TimeSince.op_Implicit(lastSplashNetworkUpdate) > 60f)
			{
				SendNetworkUpdate();
				lastSplashNetworkUpdate = TimeSince.op_Implicit(0f);
			}
			return amount;
		}
		int num = Mathf.Min(availableWaterCapacity, amount);
		soilSaturation += num;
		RefreshGrowables();
		if (TimeSince.op_Implicit(lastSplashNetworkUpdate) > 60f)
		{
			SendNetworkUpdate();
			lastSplashNetworkUpdate = TimeSince.op_Implicit(0f);
		}
		return num;
	}

	private void KillAllPlants()
	{
		if (children == null)
		{
			return;
		}
		for (int num = children.Count - 1; num >= 0; num--)
		{
			BaseEntity baseEntity = children[num];
			if (!((Object)(object)baseEntity == (Object)null) && baseEntity is GrowableEntity growableEntity)
			{
				growableEntity.ForceRemove();
			}
		}
	}

	public virtual void RefreshGrowables(GrowableEntity ignoreEntity = null)
	{
		if (children == null)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			if (!((Object)(object)child == (Object)null) && !((Object)(object)child == (Object)(object)ignoreEntity) && child is GrowableEntity growableEntity)
			{
				growableEntity.QueueForQualityUpdate();
			}
		}
	}

	public void ForceLightUpdate()
	{
		sunExposure?.ForceNextRun();
		artificialLightExposure?.ForceNextRun();
	}

	public void ForceTemperatureUpdate()
	{
		plantArtificalTemperature?.ForceNextRun();
	}

	public float GetSunExposure()
	{
		return sunExposure?.Get(force: false) ?? 0f;
	}

	public float CalculateSunExposure()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return GrowableEntity.SunRaycast(((Component)this).transform.position + new Vector3(0f, 1f, 0f));
	}

	public float GetArtificialLightExposure()
	{
		return artificialLightExposure?.Get(force: false) ?? 0f;
	}

	public float CalculateArtificialLightExposure()
	{
		return GrowableEntity.CalculateArtificialLightExposure(((Component)this).transform);
	}

	public float GetPlantTemperature()
	{
		return (plantTemperature?.Get(force: false) ?? 0f) + (plantArtificalTemperature?.Get(force: false) ?? 0f);
	}

	public float CalculatePlantTemperature()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Mathf.Max(Climate.GetTemperature(((Component)this).transform.position), 15f);
	}

	private bool HasPlants()
	{
		foreach (BaseEntity child in children)
		{
			if (child is GrowableEntity)
			{
				return true;
			}
		}
		return false;
	}

	public void CalculateRainFactor()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		float rain = Climate.GetRain(((Component)this).transform.position);
		if (rain > 0f && WaterCatcher.TestIsOutside(((Component)this).transform, Vector3.up, 0.5f, outsideTestDistance))
		{
			soilSaturation = Mathf.Clamp(soilSaturation + Mathf.RoundToInt(4f * rain * TimeSince.op_Implicit(lastRainCheck)), 0, soilSaturationMax);
			RefreshGrowables();
			SendNetworkUpdate();
		}
		lastRainCheck = TimeSince.op_Implicit(0f);
	}

	public float CalculateArtificialTemperature()
	{
		return GrowableEntity.CalculateArtificialTemperature(((Component)this).transform);
	}

	public virtual void OnPlantRemoved(GrowableEntity entity, BasePlayer byPlayer)
	{
	}

	public void OnPlantInserted(GrowableEntity entity, BasePlayer byPlayer)
	{
		if (!GameInfo.HasAchievements)
		{
			return;
		}
		List<uint> list = Pool.Get<List<uint>>();
		foreach (BaseEntity child in children)
		{
			if (child is GrowableEntity growableEntity && !list.Contains(growableEntity.prefabID))
			{
				list.Add(growableEntity.prefabID);
			}
		}
		if (list.Count == 9)
		{
			byPlayer.GiveAchievement("HONEST_WORK");
		}
		Pool.FreeUnmanaged<uint>(ref list);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_RequestSaturationUpdate(RPCMessage msg)
	{
		if ((Object)(object)msg.player != (Object)null)
		{
			ClientRPC(RpcTarget.Player("RPC_ReceiveSaturationUpdate", msg.player), soilSaturation);
		}
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}
}


