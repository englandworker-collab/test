using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class PlayerHelicopter : BaseHelicopter, IEngineControllerUser, IEntity, SamSite.ISamSiteTarget
{
	[Serializable]
	public class Wheel
	{
		public WheelCollider wheelCollider;

		public Transform visualBone;

		public Flags groundedFlag = Flags.Reserved1;

		[NonSerialized]
		public float wheelVel;

		[NonSerialized]
		public Vector3 wheelRot = Vector3.zero;

		public bool steering;

		public bool IsGrounded(PlayerHelicopter parent)
		{
			if (parent.isServer)
			{
				return wheelCollider.isGrounded;
			}
			return parent.HasFlag(groundedFlag);
		}
	}

	[SerializeField]
	[Header("Player Helicopter")]
	public Wheel[] wheels;

	[SerializeField]
	public Transform waterSample;

	public PlayerHeliSounds playerHeliSounds;

	[SerializeField]
	private Transform joystickPositionLeft;

	[SerializeField]
	private Transform joystickPositionRight;

	[SerializeField]
	private Transform passengerJoystickPositionRight;

	[SerializeField]
	private Transform leftFootPosition;

	[SerializeField]
	private Transform rightFootPosition;

	[SerializeField]
	protected Animator animator;

	[SerializeField]
	public float maxRotorSpeed = 10f;

	[SerializeField]
	public float timeUntilMaxRotorSpeed = 7f;

	[SerializeField]
	private Transform mainRotorBlurBone;

	[SerializeField]
	private Renderer mainRotorBlurMesh;

	[SerializeField]
	public float rotorBlurThreshold = 8f;

	[SerializeField]
	private Transform mainRotorBladesBone;

	[SerializeField]
	private Renderer[] mainRotorBladeMeshes;

	[SerializeField]
	private Transform rearRotorBladesBone;

	[SerializeField]
	private Renderer[] rearRotorBladeMeshes;

	[SerializeField]
	private Transform rearRotorBlurBone;

	[SerializeField]
	private Renderer rearRotorBlurMesh;

	[SerializeField]
	public float motorForceConstant = 150f;

	[SerializeField]
	public float brakeForceConstant = 500f;

	[SerializeField]
	public float maxPitchAnim = 1f;

	[SerializeField]
	private GameObject preventBuildingObject;

	[SerializeField]
	public float maxRollAnim = 1f;

	[SerializeField]
	public float maxYawAnim = 1f;

	[Header("Fuel")]
	[SerializeField]
	public GameObjectRef fuelStoragePrefab;

	[SerializeField]
	public float fuelPerSec = 0.25f;

	[SerializeField]
	public float fuelGaugeMax = 100f;

	[ServerVar(Help = "How long before a player helicopter loses all its health while outside")]
	public static float outsidedecayminutes = 480f;

	[ServerVar(Help = "How long before a player helicopter loses all its health while indoors")]
	public static float insidedecayminutes = 2880f;

	public VehicleEngineController<PlayerHelicopter> engineController;

	public TimeSince timeSinceCachedFuelFraction;

	public float cachedFuelFraction;

	protected const Flags WHEEL_GROUNDED_LR = Flags.Reserved1;

	protected const Flags WHEEL_GROUNDED_RR = Flags.Reserved2;

	protected const Flags WHEEL_GROUNDED_FRONT = Flags.Reserved3;

	protected const Flags RADAR_WARNING_FLAG = Flags.Reserved12;

	protected const Flags RADAR_LOCK_FLAG = Flags.Reserved13;

	protected const Flags ENGINE_STARTING_FLAG = Flags.Reserved4;

	public bool isPushing;

	private float[] recentVelocities = new float[10];

	private int recentVelIndex;

	private bool cacheGrounded;

	public float lastEngineOnTime;

	private static readonly Phrase CantRepairWithEngineOn = new Phrase("error_cannot_repair_with_engine_on", "Cannot repair while the engine is running.");

	public VehicleEngineController<PlayerHelicopter>.EngineState CurEngineState
	{
		get
		{
			if (engineController == null)
			{
				return VehicleEngineController<PlayerHelicopter>.EngineState.Off;
			}
			return engineController.CurEngineState;
		}
	}

	public bool IsStartingUp
	{
		get
		{
			if (engineController != null)
			{
				return engineController.IsStarting;
			}
			return false;
		}
	}

	public float cachedPitch { get; set; }

	public float cachedYaw { get; set; }

	public float cachedRoll { get; set; }

	public SamSite.SamTargetType SAMTargetType => SamSite.targetTypeVehicle;

	public override bool ForceMovementHandling
	{
		protected get
		{
			if (isPushing)
			{
				return wheels.Length != 0;
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlayerHelicopter.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1851540757u, "RPC_OpenFuel", this, player, 6f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_OpenFuel(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenFuel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		EntityFuelSystem fuelSystem = new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
		engineController = new VehicleEngineController<PlayerHelicopter>(this, fuelSystem, base.isServer, 5f, waterSample, Flags.Reserved4);
	}

	public float GetFuelFraction(bool force = false)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && (TimeSince.op_Implicit(timeSinceCachedFuelFraction) > 1f || force))
		{
			cachedFuelFraction = Mathf.Clamp01((float)GetFuelSystem().GetFuelAmount() / fuelGaugeMax);
			timeSinceCachedFuelFraction = TimeSince.op_Implicit(0f);
		}
		return cachedFuelFraction;
	}

	public override bool CanPushNow(BasePlayer pusher)
	{
		if (base.CanPushNow(pusher) && pusher.IsOnGround())
		{
			return !pusher.isMounted;
		}
		return false;
	}

	public override float InheritedVelocityScale()
	{
		return 1f;
	}

	public override bool InheritedVelocityDirection()
	{
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.miniCopter != null)
		{
			engineController.FuelSystem.SetInstanceID(info.msg.miniCopter.fuelStorageID);
			cachedFuelFraction = info.msg.miniCopter.fuelFraction;
			cachedPitch = info.msg.miniCopter.pitch * maxPitchAnim;
			cachedRoll = info.msg.miniCopter.roll * maxRollAnim;
			cachedYaw = info.msg.miniCopter.yaw * maxYawAnim;
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			if (CurEngineState == VehicleEngineController<PlayerHelicopter>.EngineState.Off)
			{
				lastEngineOnTime = Time.time;
			}
			if ((Object)(object)rigidBody != (Object)null)
			{
				rigidBody.isKinematic = IsTransferProtected();
			}
		}
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned)
		{
			GetFuelSystem().CheckNewChild(child);
		}
	}

	public override float GetServiceCeiling()
	{
		return HotAirBalloon.serviceCeiling;
	}

	public override float GetMinimumAltitudeTerrain()
	{
		return HotAirBalloon.minimumAltitudeTerrain;
	}

	public override IFuelSystem GetFuelSystem()
	{
		return engineController.FuelSystem;
	}

	public override int StartingFuelUnits()
	{
		return 100;
	}

	public bool IsValidSAMTarget(bool staticRespawn)
	{
		if (rigidBody.IsSleeping() || rigidBody.isKinematic)
		{
			return false;
		}
		if (staticRespawn)
		{
			return true;
		}
		return !InSafeZone();
	}

	public override void PilotInput(InputState inputState, BasePlayer player)
	{
		base.PilotInput(inputState, player);
		if (!IsOn() && !IsStartingUp && inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD))
		{
			engineController.TryStartEngine(player);
		}
		currentInputState.groundControl = inputState.IsDown(BUTTON.DUCK);
		if (currentInputState.groundControl)
		{
			currentInputState.roll = 0f;
			currentInputState.throttle = (inputState.IsDown(BUTTON.FORWARD) ? 1f : 0f);
			currentInputState.throttle -= (inputState.IsDown(BUTTON.BACKWARD) ? 1f : 0f);
		}
		cachedRoll = currentInputState.roll;
		cachedYaw = currentInputState.yaw;
		cachedPitch = currentInputState.pitch;
	}

	public bool IsGrounded()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (IsStationary())
		{
			return cacheGrounded;
		}
		if (wheels.Length == 0)
		{
			flag = Physics.Raycast(((Component)this).transform.position + Vector3.up * 0.1f, Vector3.down, 0.5f);
		}
		else
		{
			float num = 1f;
			Wheel[] array = wheels;
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].wheelCollider.isGrounded)
				{
					num -= 1f / (float)wheels.Length;
				}
			}
			flag = num >= 0.5f;
		}
		cacheGrounded = flag;
		return flag;
	}

	public override void SetDefaultInputState()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		currentInputState.Reset();
		cachedRoll = 0f;
		cachedYaw = 0f;
		cachedPitch = 0f;
		if (IsGrounded())
		{
			return;
		}
		if (HasDriver())
		{
			float num = Vector3.Dot(Vector3.up, ((Component)this).transform.right);
			float num2 = Vector3.Dot(Vector3.up, ((Component)this).transform.forward);
			currentInputState.roll = ((num < 0f) ? 1f : 0f);
			currentInputState.roll -= ((num > 0f) ? 1f : 0f);
			if (num2 < -0f)
			{
				currentInputState.pitch = -1f;
			}
			else if (num2 > 0f)
			{
				currentInputState.pitch = 1f;
			}
		}
		else
		{
			currentInputState.throttle = -1f;
		}
	}

	public void ApplyForceAtWheels()
	{
		if (!((Object)(object)rigidBody == (Object)null))
		{
			float brakeScale;
			float num2;
			float num;
			if (currentInputState.groundControl)
			{
				brakeScale = ((currentInputState.throttle == 0f) ? 50f : 0f);
				num = currentInputState.throttle;
				num2 = currentInputState.yaw;
			}
			else
			{
				brakeScale = 20f;
				num2 = 0f;
				num = 0f;
			}
			num *= (IsOn() ? 1f : 0f);
			if (isPushing)
			{
				brakeScale = 0f;
				num = 0.1f;
				num2 = 0f;
			}
			Wheel[] array = wheels;
			foreach (Wheel wheel in array)
			{
				ApplyWheelForce(wheel.wheelCollider, num, brakeScale, wheel.steering ? num2 : 0f);
			}
		}
	}

	public void ApplyForceWithoutWheels()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (currentInputState.groundControl)
		{
			if (currentInputState.throttle != 0f)
			{
				rigidBody.AddRelativeForce(Vector3.forward * currentInputState.throttle * motorForceConstant * 15f, (ForceMode)0);
			}
			if (currentInputState.yaw != 0f)
			{
				rigidBody.AddRelativeTorque(new Vector3(0f, currentInputState.yaw * torqueScale.y, 0f), (ForceMode)0);
			}
			float num = rigidBody.mass * (0f - Physics.gravity.y);
			rigidBody.AddForce(((Component)this).transform.up * num * hoverForceScale, (ForceMode)0);
		}
	}

	public void ApplyWheelForce(WheelCollider wheel, float gasScale, float brakeScale, float turning)
	{
		if (wheel.isGrounded)
		{
			float num = gasScale * motorForceConstant;
			float num2 = brakeScale * brakeForceConstant;
			float num3 = 45f * turning;
			if (!Mathf.Approximately(wheel.motorTorque, num))
			{
				wheel.motorTorque = num;
			}
			if (!Mathf.Approximately(wheel.brakeTorque, num2))
			{
				wheel.brakeTorque = num2;
			}
			if (!Mathf.Approximately(wheel.steerAngle, num3))
			{
				wheel.steerAngle = num3;
			}
			SetWheelFrictionMultiplier(wheel, 1f);
		}
	}

	public override void MovementUpdate()
	{
		if (IsGrounded())
		{
			if (wheels.Length != 0)
			{
				ApplyForceAtWheels();
			}
			else
			{
				ApplyForceWithoutWheels();
			}
		}
		if (!currentInputState.groundControl || !IsGrounded())
		{
			base.MovementUpdate();
		}
	}

	public override void ServerInit()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		lastEngineOnTime = Time.realtimeSinceStartup;
		rigidBody.inertiaTensor = rigidBody.inertiaTensor;
		preventBuildingObject.SetActive(true);
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateNetwork, 0f, 0.2f, 0.05f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayTick, Random.Range(30f, 60f), 60f, 6f);
	}

	public void DecayTick()
	{
		if (base.healthFraction != 0f && !IsOn() && !(Time.time < lastEngineOnTime + 600f))
		{
			float num = 1f / (IsOutside() ? outsidedecayminutes : insidedecayminutes);
			Hurt(MaxHealth() * num, DamageType.Decay, this, useProtection: false);
		}
	}

	public override bool IsEngineOn()
	{
		return IsOn();
	}

	protected override void TryStartEngine(BasePlayer player)
	{
		engineController.TryStartEngine(player);
	}

	public bool MeetsEngineRequirements()
	{
		if (base.autoHover)
		{
			return true;
		}
		if (engineController.IsOff)
		{
			return HasDriver();
		}
		if (!HasDriver())
		{
			return Time.time <= lastPlayerInputTime + 1f;
		}
		return true;
	}

	public void OnEngineStartFailed()
	{
	}

	public override void VehicleFixedUpdate()
	{
		if (IsTransferProtected())
		{
			return;
		}
		TimeWarning val = TimeWarning.New("PlayerHelicopter.VehicleFixedUpdate", 0);
		try
		{
			if (!IsStationary())
			{
				TryWakeWheels();
			}
			else
			{
				SleepWheels();
			}
			base.VehicleFixedUpdate();
			engineController.CheckEngineState();
			engineController.TickFuel(fuelPerSec);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void UpdateNetwork()
	{
		Flags flags = base.flags;
		Wheel[] array = wheels;
		foreach (Wheel wheel in array)
		{
			SetFlag(wheel.groundedFlag, wheel.wheelCollider.isGrounded, recursive: false, networkupdate: false);
		}
		if (HasDriver())
		{
			SendNetworkUpdate();
		}
		else if (flags != base.flags)
		{
			SendNetworkUpdate_Flags();
		}
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == "RadarLock")
		{
			SetFlag(Flags.Reserved13, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearRadarLock, 1f);
		}
		else if (msg == "RadarWarning")
		{
			SetFlag(Flags.Reserved12, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearRadarWarning, 1f);
		}
		else
		{
			base.OnEntityMessage(from, msg);
		}
	}

	public void ClearRadarLock()
	{
		SetFlag(Flags.Reserved13, b: false);
	}

	public void ClearRadarWarning()
	{
		SetFlag(Flags.Reserved12, b: false);
	}

	public void UpdateCOM()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		rigidBody.centerOfMass = com.localPosition;
	}

	public override void Save(SaveInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.miniCopter = Pool.Get<Minicopter>();
		info.msg.miniCopter.fuelStorageID = engineController.FuelSystem.GetInstanceID();
		info.msg.miniCopter.fuelFraction = GetFuelFraction(force: true);
		info.msg.miniCopter.pitch = currentInputState.pitch;
		info.msg.miniCopter.roll = currentInputState.roll;
		info.msg.miniCopter.yaw = currentInputState.yaw;
	}

	public override void OnDied(HitInfo info)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if ((Object)(object)mountPoint.mountable != (Object)null)
			{
				BasePlayer mounted = mountPoint.mountable.GetMounted();
				if (Object.op_Implicit((Object)(object)mounted))
				{
					HitInfo hitInfo = new HitInfo(info.Initiator, this, DamageType.Explosion, 1000f, ((Component)this).transform.position);
					hitInfo.Weapon = info.Weapon;
					hitInfo.WeaponPrefab = info.WeaponPrefab;
					mounted.Hurt(hitInfo);
				}
			}
		}
		base.OnDied(info);
	}

	public override void DoPushAction(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.Direction2D(((Component)player).transform.position, ((Component)this).transform.position);
		Vector3 val2 = player.eyes.BodyForward();
		val2.y = 0.25f;
		Vector3 val3 = ((Component)this).transform.position + val * 2f;
		float num = rigidBody.mass * 2f;
		rigidBody.AddForceAtPosition(val2 * num, val3, (ForceMode)1);
		rigidBody.AddForce(Vector3.up * 3f, (ForceMode)1);
		isPushing = true;
		((FacepunchBehaviour)this).Invoke((Action)DisablePushing, 0.5f);
	}

	public void DisablePushing()
	{
		isPushing = false;
	}

	public override bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return IsOn();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(6f)]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			BasePlayer driver = GetDriver();
			if ((!((Object)(object)driver != (Object)null) || !((Object)(object)driver != (Object)(object)player)) && (!IsSafe() || !((Object)(object)player != (Object)(object)creatorEntity)))
			{
				engineController.FuelSystem.LootFuel(player);
			}
		}
	}

	public override bool ShouldDisableTransferProtectionOnLoad(BasePlayer player)
	{
		if (!IsDriver(player))
		{
			return !HasDriver();
		}
		return true;
	}

	public override void DisableTransferProtection()
	{
		SwapDriverIfInactive();
		if ((Object)(object)GetDriver() != (Object)null && IsOn())
		{
			SetDefaultInputState();
			lastPlayerInputTime = Time.time;
		}
		base.DisableTransferProtection();
	}

	private void SwapDriverIfInactive()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer driver = GetDriver();
		if ((Object)(object)driver == (Object)null || IsPlayerActive(driver))
		{
			return;
		}
		MountPointInfo mountPoint = GetMountPoint(GetPlayerSeat(driver));
		if (mountPoint == null)
		{
			Debug.LogError((object)"Helicopter driver is inactive but the driver seat was not found");
			return;
		}
		BasePlayer basePlayer = FindActivePassenger();
		if ((Object)(object)basePlayer == (Object)null)
		{
			Debug.LogError((object)"Helicopter driver is inactive and there is no passenger we can swap in");
			return;
		}
		MountPointInfo mountPoint2 = GetMountPoint(GetPlayerSeat(basePlayer));
		BaseEntity entity = basePlayer.GetParentEntity();
		Vector3 position = ((Component)basePlayer).transform.position;
		Quaternion rotation = ((Component)basePlayer).transform.rotation;
		driver.EnsureDismounted();
		basePlayer.EnsureDismounted();
		mountPoint.mountable.MountPlayer(basePlayer);
		if (mountPoint2 == null)
		{
			driver.SetParent(entity);
			driver.MovePosition(position);
			((Component)driver).transform.rotation = rotation;
			driver.ServerRotation = rotation;
		}
		else
		{
			mountPoint2.mountable.MountPlayer(driver);
		}
		driver.SendNetworkUpdateImmediate();
		basePlayer.SendNetworkUpdateImmediate();
		BasePlayer FindActivePassenger()
		{
			foreach (MountPointInfo allMountPoint in base.allMountPoints)
			{
				if (!allMountPoint.isDriver && !((Object)(object)allMountPoint.mountable == (Object)null))
				{
					BasePlayer mounted = allMountPoint.mountable.GetMounted();
					if (!((Object)(object)mounted == (Object)null) && IsPlayerActive(mounted))
					{
						return mounted;
					}
				}
			}
			foreach (BaseEntity child in children)
			{
				if (!((Object)(object)child == (Object)null) && child is BasePlayer basePlayer2 && IsPlayerActive(basePlayer2))
				{
					return basePlayer2;
				}
			}
			return null;
		}
		static bool IsPlayerActive(BasePlayer player)
		{
			if (player.IsConnected && !player.IsSleeping())
			{
				return !player.IsLoadingAfterTransfer();
			}
			return false;
		}
	}

	protected override void ApplyHandbrake()
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		if (!IsGrounded() || rigidBody.IsSleeping())
		{
			return;
		}
		Wheel[] array = wheels;
		foreach (Wheel wheel in array)
		{
			wheel.wheelCollider.motorTorque = 0f;
			wheel.wheelCollider.brakeTorque = 10000f;
			SetWheelFrictionMultiplier(wheel.wheelCollider, 3f);
		}
		float[] array2 = recentVelocities;
		int num = recentVelIndex;
		Vector3 velocity = rigidBody.velocity;
		array2[num] = ((Vector3)(ref velocity)).sqrMagnitude;
		recentVelIndex = ++recentVelIndex % recentVelocities.Length;
		bool flag = true;
		float[] array3 = recentVelocities;
		for (int i = 0; i < array3.Length; i++)
		{
			if (array3[i] >= 0.05f)
			{
				flag = false;
				break;
			}
		}
		if (flag && Time.time > lastEngineOnTime + 5f)
		{
			rigidBody.Sleep();
			((FacepunchBehaviour)this).Invoke((Action)SleepWheels, 0.1f, 0f);
		}
	}

	private void TryWakeWheels()
	{
		Wheel[] array = wheels;
		foreach (Wheel wheel in array)
		{
			if (!((Collider)wheel.wheelCollider).enabled)
			{
				((Collider)wheel.wheelCollider).enabled = true;
			}
		}
	}

	private void SleepWheels()
	{
		if (vehicle.disable_wheels_when_sleeping)
		{
			Wheel[] array = wheels;
			for (int i = 0; i < array.Length; i++)
			{
				((Collider)array[i].wheelCollider).enabled = false;
			}
		}
	}

	private void SetWheelFrictionMultiplier(WheelCollider wheel, float multiplier)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		WheelFrictionCurve val = wheel.forwardFriction;
		((WheelFrictionCurve)(ref val)).stiffness = multiplier;
		wheel.forwardFriction = val;
		val = wheel.sidewaysFriction;
		((WheelFrictionCurve)(ref val)).stiffness = multiplier;
		wheel.sidewaysFriction = val;
	}

	public override void DoRepair(BasePlayer player)
	{
		if (IsEngineOn())
		{
			OnRepairFailed(player, CantRepairWithEngineOn);
		}
		else
		{
			base.DoRepair(player);
		}
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


using System;
using UnityEngine;

[Serializable]
public class Wheel
{
	public WheelCollider wheelCollider;

	public Transform visualBone;

	public Flags groundedFlag = Flags.Reserved1;

	[NonSerialized]
	public float wheelVel;

	[NonSerialized]
	public Vector3 wheelRot = Vector3.zero;

	public bool steering;

	public bool IsGrounded(PlayerHelicopter parent)
	{
		if (parent.isServer)
		{
			return wheelCollider.isGrounded;
		}
		return parent.HasFlag(groundedFlag);
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class PlayerHelicopterWithFlares : PlayerHelicopter, ICanFireHelicopterFlares
{
	[Header("Helicopter Flares")]
	[SerializeField]
	private GameObjectRef flareStoragePrefab;

	[SerializeField]
	private Renderer flareLightOff;

	[SerializeField]
	private Renderer flareLightRed;

	[SerializeField]
	private Renderer flareLightGreen;

	public EntityRef<HelicopterFlares> flaresInstance;

	private TimeSince timeSinceFailedFlareRPC;

	public BaseEntity flareEntity => this;

	public HelicopterFlares FlaresInstance => flaresInstance.Get(base.isServer);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlayerHelicopterWithFlares.OnRpcMessage", 0);
		try
		{
			if (rpc == 4185921214u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenStorage "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenStorage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4185921214u, "RPC_OpenStorage", this, player, 6f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_OpenStorage(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenStorage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child.prefabID == flareStoragePrefab.GetEntity().prefabID)
		{
			HelicopterFlares helicopterFlares = (HelicopterFlares)child;
			flaresInstance.Set(helicopterFlares);
			helicopterFlares.owner = this;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.helicopterFlares != null)
		{
			flaresInstance.uid = info.msg.helicopterFlares.flareStorageID;
		}
	}

	public HelicopterFlares GetFlares()
	{
		HelicopterFlares helicopterFlares = flaresInstance.Get(base.isServer);
		if (helicopterFlares.IsValid())
		{
			return helicopterFlares;
		}
		return null;
	}

	public void FireFlares()
	{
		throw new NotImplementedException();
	}

	public void FlareFireFailed(BasePlayer player)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!(TimeSince.op_Implicit(timeSinceFailedFlareRPC) <= 1f))
		{
			ClientRPC(RpcTarget.Player("ClientFlareFireFailed", player));
			timeSinceFailedFlareRPC = TimeSince.op_Implicit(0f);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.helicopterFlares = Pool.Get<HelicopterFlares>();
		info.msg.helicopterFlares.flareStorageID = flaresInstance.uid;
	}

	public override void PilotInput(InputState inputState, BasePlayer player)
	{
		base.PilotInput(inputState, player);
		if (IsOn() && inputState.WasJustPressed(BUTTON.FIRE_SECONDARY) && !GetFlares().TryFireFlare())
		{
			FlareFireFailed(player);
		}
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot && flaresInstance.IsValid(base.isServer))
		{
			flaresInstance.Get(base.isServer).DropItems();
		}
		base.DoServerDestroy();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(6f)]
	public void RPC_OpenStorage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (IsOn() || !CanBeLooted(player) || player.isMounted || (IsSafe() && (Object)(object)player != (Object)(object)creatorEntity))
		{
			return;
		}
		StorageContainer flares = GetFlares();
		if (!((Object)(object)flares == (Object)null))
		{
			BasePlayer driver = GetDriver();
			if (!((Object)(object)driver != (Object)null) || !((Object)(object)driver != (Object)(object)player))
			{
				flares.PlayerOpenLoot(player);
			}
		}
	}

	public override bool AdminFixUp(int tier)
	{
		if (!base.AdminFixUp(tier))
		{
			return false;
		}
		GetFlares()?.RefillFlares();
		return true;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class PlayerInventory : EntityComponent<BasePlayer>, IAmmoContainer
{
	public enum Type
	{
		Main,
		Belt,
		Wear,
		BackpackContents
	}

	public readonly struct CanMoveFromResponse
	{
		public readonly bool allowed;

		public readonly Phrase reasonForFailure;

		public static CanMoveFromResponse Success()
		{
			return new CanMoveFromResponse(allowed: true, null);
		}

		public static CanMoveFromResponse Failure(Phrase reasonForFailure)
		{
			return new CanMoveFromResponse(allowed: false, reasonForFailure);
		}

		public CanMoveFromResponse(bool allowed, Phrase reasonForFailure)
		{
			this.allowed = allowed;
			this.reasonForFailure = reasonForFailure;
		}
	}

	public interface ICanMoveFrom
	{
		CanMoveFromResponse CanMoveFrom(BasePlayer player, Item item);
	}

	public enum NetworkInventoryMode
	{
		LocalPlayer,
		Everyone,
		EveryoneButLocal
	}

	private struct WearCheckResult
	{
		public bool Result;

		public List<Item> ChangedItem;
	}

	public ItemContainer containerMain;

	public ItemContainer containerBelt;

	public ItemContainer containerWear;

	public ItemCrafter crafting;

	public PlayerLoot loot;

	public static Phrase BackpackGroundedError = new Phrase("error.backpackGrounded", "You must be on a solid surface to equip a backpack");

	public float inventoryRadioactivity;

	public bool containsRadioactiveItems;

	private static Comparison<HeldEntity> hostileComparer = null;

	private Action _deferredServerUpdateAction;

	private List<Item> returnItems;

	[ServerVar]
	public static bool forceBirthday = false;

	[ServerVar]
	public static bool directionalDropEnabled = true;

	private static float nextCheckTime = 0f;

	private static bool wasBirthday = false;

	private Action DeferredServerUpdateAction => DeferredServerUpdate;

	public event Action<float, bool> onRadioactivityChanged;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlayerInventory.OnRpcMessage", 0);
		try
		{
			if (rpc == 3482449460u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ItemCmd "));
				}
				TimeWarning val2 = TimeWarning.New("ItemCmd", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!BaseEntity.RPC_Server.FromOwner.Test(3482449460u, "ItemCmd", GetBaseEntity(), player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							BaseEntity.RPCMessage rPCMessage = default(BaseEntity.RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							BaseEntity.RPCMessage msg2 = rPCMessage;
							ItemCmd(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ItemCmd");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3041092525u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - MoveItem "));
				}
				TimeWarning val2 = TimeWarning.New("MoveItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!BaseEntity.RPC_Server.FromOwner.Test(3041092525u, "MoveItem", GetBaseEntity(), player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							BaseEntity.RPCMessage rPCMessage = default(BaseEntity.RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							BaseEntity.RPCMessage msg3 = rPCMessage;
							MoveItem(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in MoveItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	protected void Initialize(BasePlayer owner)
	{
		Debug.Assert(containerMain == null, "Double init of main container!");
		containerMain = Pool.Get<ItemContainer>();
		containerMain.SetFlag(ItemContainer.Flag.IsPlayer, b: true);
		Debug.Assert(containerBelt == null, "Double init of belt container!");
		containerBelt = Pool.Get<ItemContainer>();
		containerBelt.SetFlag(ItemContainer.Flag.IsPlayer, b: true);
		containerBelt.SetFlag(ItemContainer.Flag.Belt, b: true);
		Debug.Assert(containerWear == null, "Double init of wear container!");
		containerWear = Pool.Get<ItemContainer>();
		containerWear.SetFlag(ItemContainer.Flag.IsPlayer, b: true);
		containerWear.SetFlag(ItemContainer.Flag.Clothing, b: true);
		containerWear.containerVolume = 2;
		crafting = ((Component)this).GetComponent<ItemCrafter>();
		if ((Object)(object)crafting != (Object)null)
		{
			crafting.owner = owner;
			crafting.AddContainer(containerMain);
			crafting.AddContainer(containerBelt);
		}
		loot = ((Component)this).GetComponent<PlayerLoot>();
		if (!Object.op_Implicit((Object)(object)loot))
		{
			loot = base.baseEntity.AddComponent<PlayerLoot>();
		}
	}

	public void DoDestroy()
	{
		if (containerMain != null)
		{
			Pool.Free<ItemContainer>(ref containerMain);
		}
		if (containerBelt != null)
		{
			Pool.Free<ItemContainer>(ref containerBelt);
		}
		if (containerWear != null)
		{
			Pool.Free<ItemContainer>(ref containerWear);
		}
	}

	public void SetLockedByRestraint(bool flag)
	{
		containerMain.SetLocked(flag, lockSubItems: true);
		containerWear.SetLocked(flag, lockSubItems: true);
		containerBelt.SetLocked(flag, lockSubItems: true);
		GetContainer(Type.BackpackContents)?.SetLocked(flag, lockSubItems: true);
	}

	public void ServerInit(BasePlayer owner)
	{
		Initialize(owner);
		containerMain.ServerInitialize(null, 24);
		if (!((ItemContainerId)(ref containerMain.uid)).IsValid)
		{
			containerMain.GiveUID();
		}
		containerBelt.ServerInitialize(null, 6);
		if (!((ItemContainerId)(ref containerBelt.uid)).IsValid)
		{
			containerBelt.GiveUID();
		}
		containerWear.ServerInitialize(null, 8);
		if (!((ItemContainerId)(ref containerWear.uid)).IsValid)
		{
			containerWear.GiveUID();
		}
		containerMain.playerOwner = owner;
		containerBelt.playerOwner = owner;
		containerWear.playerOwner = owner;
		containerWear.onItemContentsChanged = OnClothingItemContentsChanged;
		containerWear.onItemAddedRemoved = OnClothingChanged;
		containerWear.canAcceptItem = CanWearItem;
		containerBelt.canAcceptItem = CanEquipItem;
		containerMain.canAcceptItem = CanStoreInInventory;
		containerMain.onPreItemRemove = OnItemRemoved;
		containerWear.onPreItemRemove = OnItemRemoved;
		containerBelt.onPreItemRemove = OnItemRemoved;
		containerMain.onDirty += OnContentsDirty;
		containerBelt.onDirty += OnContentsDirty;
		containerWear.onDirty += OnContentsDirty;
		containerBelt.onItemAddedRemoved = OnItemAddedOrRemoved;
		containerMain.onItemAddedRemoved = OnItemAddedOrRemoved;
		ItemContainer itemContainer = containerWear;
		itemContainer.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(itemContainer.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedOrRemoved));
		containerWear.onItemRadiationChanged = OnItemRadiationChanged;
		containerBelt.onItemRadiationChanged = OnItemRadiationChanged;
		containerMain.onItemRadiationChanged = OnItemRadiationChanged;
		onRadioactivityChanged += owner.PlayerInventoryRadioactivityChange;
		CalculateInventoryRadioactivity();
	}

	public void OnItemAddedOrRemoved(Item item, bool bAdded)
	{
		if (item != null && (item.radioactivity > 0f || item.contents != null))
		{
			CalculateInventoryRadioactivity();
		}
		if (item.info.isHoldable)
		{
			((FacepunchBehaviour)this).Invoke((Action)UpdatedVisibleHolsteredItems, 0.1f);
		}
		if (item.parent == containerBelt)
		{
			OnBeltItemAddedOrRemoved(item, bAdded);
		}
		if (bAdded)
		{
			BasePlayer basePlayer = base.baseEntity;
			if (!basePlayer.HasPlayerFlag(BasePlayer.PlayerFlags.DisplaySash) && basePlayer.IsHostileItem(item))
			{
				base.baseEntity.SetPlayerFlag(BasePlayer.PlayerFlags.DisplaySash, b: true);
			}
			if (bAdded)
			{
				basePlayer.ProcessMissionEvent(BaseMission.MissionEventType.ACQUIRE_ITEM, item.info.itemid, item.amount);
			}
		}
	}

	private void OnBeltItemAddedOrRemoved(Item item, bool added)
	{
		if (!added)
		{
			return;
		}
		ItemModForceWearFromBelt component = ((Component)item.info).GetComponent<ItemModForceWearFromBelt>();
		if (!((Object)(object)component == (Object)null) && (!component.IfPlayerRestrained || base.baseEntity.IsRestrained))
		{
			bool num = containerWear.IsLocked();
			if (num)
			{
				containerWear.SetLocked(isLocked: false);
			}
			if (!item.MoveToContainer(containerWear))
			{
				item.MoveToContainer(containerWear, 0, allowStack: false);
			}
			if (num)
			{
				containerWear.SetLocked(isLocked: true);
			}
		}
	}

	private static int CompareHostility(HeldEntity a, HeldEntity b)
	{
		if ((Object)(object)a == (Object)null || (Object)(object)b == (Object)null)
		{
			return 0;
		}
		if (a.hostileScore < b.hostileScore)
		{
			return 1;
		}
		if (a.hostileScore > b.hostileScore)
		{
			return -1;
		}
		return 0;
	}

	public void UpdatedVisibleHolsteredItems()
	{
		List<HeldEntity> list = Pool.Get<List<HeldEntity>>();
		List<Item> list2 = Pool.Get<List<Item>>();
		GetAllItems(list2);
		AddBackpackContentsToList(list2);
		foreach (Item item in list2)
		{
			if (item.info.isHoldable && !((Object)(object)item.GetHeldEntity() == (Object)null))
			{
				HeldEntity component = ((Component)item.GetHeldEntity()).GetComponent<HeldEntity>();
				if (!((Object)(object)component == (Object)null) && (!component.IsShield || containerWear.itemList.Contains(item)))
				{
					list.Add(component);
				}
			}
		}
		Pool.Free<Item>(ref list2, false);
		TimeWarning val = TimeWarning.New("Sort", 0);
		try
		{
			if (hostileComparer == null)
			{
				hostileComparer = CompareHostility;
			}
			list.Sort(hostileComparer);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		bool flag = true;
		bool flag2 = true;
		bool flag3 = true;
		bool flag4 = true;
		foreach (HeldEntity item2 in list)
		{
			if (!((Object)(object)item2 == (Object)null) && item2.holsterInfo.displayWhenHolstered)
			{
				if (flag4 && !item2.IsDeployed() && item2.holsterInfo.slot == HeldEntity.HolsterInfo.HolsterSlot.BACK_SHIELD)
				{
					item2.SetVisibleWhileHolstered(visible: true);
					flag4 = false;
				}
				else if (flag3 && !item2.IsDeployed() && item2.holsterInfo.slot == HeldEntity.HolsterInfo.HolsterSlot.BACK)
				{
					item2.SetVisibleWhileHolstered(visible: true);
					flag3 = false;
				}
				else if (flag2 && !item2.IsDeployed() && item2.holsterInfo.slot == HeldEntity.HolsterInfo.HolsterSlot.RIGHT_THIGH)
				{
					item2.SetVisibleWhileHolstered(visible: true);
					flag2 = false;
				}
				else if (flag && !item2.IsDeployed() && item2.holsterInfo.slot == HeldEntity.HolsterInfo.HolsterSlot.LEFT_THIGH)
				{
					item2.SetVisibleWhileHolstered(visible: true);
					flag = false;
				}
				else
				{
					item2.SetVisibleWhileHolstered(visible: false);
				}
			}
		}
		Pool.FreeUnmanaged<HeldEntity>(ref list);
	}

	public void AddBackpackContentsToList(List<Item> items)
	{
		Item backpackWithInventory = GetBackpackWithInventory();
		if (backpackWithInventory != null && backpackWithInventory.contents != null)
		{
			items.AddRange(backpackWithInventory.contents.itemList);
		}
	}

	public void OnContentsDirty()
	{
		if ((Object)(object)base.baseEntity != (Object)null)
		{
			base.baseEntity.InvalidateNetworkCache();
		}
	}

	public CanMoveFromResponse CanMoveItemsFrom(BaseEntity entity, Item item)
	{
		if (entity is ICanMoveFrom canMoveFrom)
		{
			CanMoveFromResponse result = canMoveFrom.CanMoveFrom(base.baseEntity, item);
			if (!result.allowed)
			{
				return result;
			}
		}
		if (Object.op_Implicit((Object)(object)BaseGameMode.GetActiveGameMode(serverside: true)))
		{
			return BaseGameMode.GetActiveGameMode(serverside: true).CanMoveItemsFrom(this, entity, item);
		}
		return CanMoveFromResponse.Success();
	}

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.FromOwner(false)]
	private void ItemCmd(BaseEntity.RPCMessage msg)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		if (((Object)(object)msg.player != (Object)null && msg.player.IsWounded()) || base.baseEntity.IsTransferring())
		{
			return;
		}
		ItemId id = msg.read.ItemID();
		string text = msg.read.String(256, false);
		Item item = FindItemByUID(id);
		if (item == null || Interface.CallHook("OnItemAction", (object)item, (object)text, (object)msg.player) != null)
		{
			return;
		}
		BaseEntity entityOwner = item.GetEntityOwner();
		if (((Object)(object)entityOwner != (Object)null && (Object)(object)entityOwner == (Object)(object)msg.player && msg.player.IsRestrainedOrSurrendering) || item.IsLocked() || (item.parent != null && item.parent.IsLocked()) || !CanMoveItemsFrom(item.GetEntityOwner(), item).allowed)
		{
			return;
		}
		if (text == "drop")
		{
			int num = item.amount;
			if (msg.read.Unread >= 4)
			{
				num = msg.read.Int32();
			}
			if (!msg.player.isMounted && !msg.player.HasParent() && !GamePhysics.LineOfSight(((Component)msg.player).transform.position, msg.player.eyes.position, 1218519041))
			{
				return;
			}
			base.baseEntity.stats.Add("item_drop", 1, (Stats)5);
			if (num < item.amount)
			{
				Item item2 = item.SplitItem(num);
				ItemContainer parent = item.parent;
				if (item2 != null)
				{
					Vector3 dropVelocity = GetDropVelocity(msg);
					DroppedItem droppedItem = item2.Drop(base.baseEntity.GetDropPosition(), dropVelocity) as DroppedItem;
					if ((Object)(object)droppedItem != (Object)null)
					{
						droppedItem.DropReason = DroppedItem.DropReasonEnum.Player;
						droppedItem.DroppedBy = base.baseEntity.userID;
						droppedItem.DroppedTime = DateTime.UtcNow;
						Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem, DroppedItem.DropReasonEnum.Player);
					}
				}
				parent?.onItemRemovedFromStack?.Invoke(item, num);
			}
			else
			{
				Vector3 dropVelocity2 = GetDropVelocity(msg);
				ItemContainer parent2 = item.parent;
				DroppedItem droppedItem2 = item.Drop(base.baseEntity.GetDropPosition(), dropVelocity2) as DroppedItem;
				if ((Object)(object)droppedItem2 != (Object)null)
				{
					droppedItem2.DropReason = DroppedItem.DropReasonEnum.Player;
					droppedItem2.DroppedBy = base.baseEntity.userID;
					droppedItem2.DroppedTime = DateTime.UtcNow;
					Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem2, DroppedItem.DropReasonEnum.Player);
				}
				parent2?.onItemAddedRemoved?.Invoke(item, arg2: false);
			}
			base.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, "drop_item");
		}
		else
		{
			item.ServerCommand(text, base.baseEntity);
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
	}

	private Vector3 GetDropVelocity(BaseEntity.RPCMessage msg)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		if (msg.read.Unread >= 4)
		{
			num = msg.read.Float();
		}
		if (!directionalDropEnabled)
		{
			num = 0f;
		}
		Vector3 inheritedDropVelocity = base.baseEntity.GetInheritedDropVelocity();
		Vector3 val = base.baseEntity.eyes.BodyForward();
		Vector3 val2 = Quaternion.AngleAxis(num, Vector3.up) * new Vector3(val.x, 0f, val.z);
		val2.y = val.y;
		return inheritedDropVelocity + val2 * 4f + Vector3Ex.Range(-0.5f, 0.5f);
	}

	[BaseEntity.RPC_Server.FromOwner(false)]
	[BaseEntity.RPC_Server]
	public void MoveItem(BaseEntity.RPCMessage msg)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		if (base.baseEntity.IsTransferring())
		{
			return;
		}
		ItemId id = msg.read.ItemID();
		ItemContainerId val = msg.read.ItemContainerID();
		int num = msg.read.Int8();
		int num2 = (int)msg.read.UInt32();
		ItemMoveModifier val2 = (ItemMoveModifier)msg.read.Int32();
		Item item = FindItemByUID(id);
		if (item == null)
		{
			msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidItem, false);
			ConstructionErrors.Log(msg.player, ((object)(ItemId)(ref id)/*cast due to .constrained prefix*/).ToString());
		}
		else
		{
			if (Interface.CallHook("CanMoveItem", (object)item, (object)this, (object)val, (object)num, (object)num2, (object)val2) != null)
			{
				return;
			}
			BaseEntity entityOwner = item.GetEntityOwner();
			if ((Object)(object)entityOwner != (Object)null && (Object)(object)entityOwner == (Object)(object)msg.player && msg.player.IsRestrainedOrSurrendering)
			{
				return;
			}
			CanMoveFromResponse canMoveFromResponse = CanMoveItemsFrom(entityOwner, item);
			if (!canMoveFromResponse.allowed)
			{
				msg.player.ShowToast(GameTip.Styles.Error, canMoveFromResponse.reasonForFailure ?? PlayerInventoryErrors.CannotMoveItem, canMoveFromResponse.reasonForFailure != null);
				return;
			}
			if (num2 <= 0)
			{
				num2 = item.amount;
			}
			num2 = Mathf.Clamp(num2, 1, item.MaxStackable());
			if (msg.player.GetActiveItem() == item)
			{
				msg.player.UpdateActiveItem(default(ItemId));
			}
			if (!((ItemContainerId)(ref val)).IsValid)
			{
				BaseEntity baseEntity = entityOwner;
				if (loot.containers.Count > 0)
				{
					if ((Object)(object)entityOwner == (Object)(object)base.baseEntity)
					{
						if (!((Enum)val2).HasFlag((Enum)(object)(ItemMoveModifier)2))
						{
							baseEntity = loot.entitySource;
						}
					}
					else
					{
						baseEntity = base.baseEntity;
					}
				}
				if (baseEntity is IIdealSlotEntity idealSlotEntity)
				{
					val = idealSlotEntity.GetIdealContainer(base.baseEntity, item, val2);
					if (val == ItemContainerId.Invalid)
					{
						return;
					}
				}
				ItemContainer parent = item.parent;
				if (parent != null && parent.IsLocked())
				{
					msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
					return;
				}
				if (!((ItemContainerId)(ref val)).IsValid)
				{
					if ((Object)(object)baseEntity == (Object)(object)loot.entitySource)
					{
						foreach (ItemContainer container in loot.containers)
						{
							if (!container.PlayerItemInputBlocked() && !container.IsLocked() && item.MoveToContainer(container, -1, allowStack: true, ignoreStackLimit: false, base.baseEntity))
							{
								break;
							}
						}
						return;
					}
					if (!GiveItem(item, val2))
					{
						msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.GiveItemFailedError, true);
					}
					return;
				}
			}
			ItemContainer itemContainer = FindContainer(val);
			if (itemContainer == null)
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidContainer, false);
				ConstructionErrors.Log(msg.player, ((object)(ItemContainerId)(ref val)/*cast due to .constrained prefix*/).ToString());
				return;
			}
			if (itemContainer.IsLocked())
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
				return;
			}
			if (itemContainer.PlayerItemInputBlocked())
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.DoesntAcceptPlayerItems, false);
				return;
			}
			if (itemContainer.maxStackSize > 0)
			{
				num2 = Mathf.Clamp(num2, 1, itemContainer.maxStackSize);
			}
			bool allowSwap = !itemContainer.PlayerItemInputBlocked() && item.parent != null && !item.parent.PlayerItemInputBlocked();
			TimeWarning val3 = TimeWarning.New("Split", 0);
			try
			{
				if (item.amount > num2)
				{
					int split_Amount = num2;
					Item item2 = item.SplitItem(split_Amount);
					Item slot = itemContainer.GetSlot(num);
					if (slot != null && !item.CanStack(slot) && item.parent != null && !item2.MoveToContainer(item.parent, -1, allowStack: false, ignoreStackLimit: false, base.baseEntity, allowSwap: false))
					{
						item.amount += item2.amount;
						item2.Remove();
						ItemManager.DoRemoves();
						ServerUpdate(0f);
						return;
					}
					if (!item2.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity, allowSwap))
					{
						item.amount += item2.amount;
						item2.Remove();
					}
					else
					{
						item.parent.onItemRemovedFromStack?.Invoke(item, num2);
					}
					ItemManager.DoRemoves();
					ServerUpdate(0f);
					return;
				}
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
			if (item.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity, allowSwap))
			{
				ItemManager.DoRemoves();
				ServerUpdate(0f);
			}
		}
	}

	private void OnClothingItemContentsChanged(Item item, bool bAdded)
	{
		OnClothingChanged(item, bAdded);
	}

	public void OnClothingChanged(Item item, bool bAdded)
	{
		base.baseEntity.SV_ClothingChanged();
		if (ItemManager.EnablePooling)
		{
			if (!((FacepunchBehaviour)this).IsInvoking(DeferredServerUpdateAction))
			{
				((FacepunchBehaviour)this).Invoke(DeferredServerUpdateAction, 0f);
			}
		}
		else
		{
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
		if (item.position == 7)
		{
			item.RecalulateParentEntity(children: true);
			((FacepunchBehaviour)this).Invoke((Action)UpdatedVisibleHolsteredItems, 0.1f);
			if ((Object)(object)base.baseEntity.GetHeldEntity() != (Object)null)
			{
				base.baseEntity.GetHeldEntity().UpdateShieldState(bHeld: true);
			}
			item?.contents?.onItemAddedRemoved?.Invoke(item, bAdded);
		}
		base.baseEntity.ProcessMissionEvent(BaseMission.MissionEventType.CLOTHINGCHANGED, 0, 0f);
		Interface.CallHook("OnClothingItemChanged", (object)this, (object)item, (object)bAdded);
	}

	private void DeferredServerUpdate()
	{
		ServerUpdate(0f);
	}

	public void OnItemRemoved(Item item)
	{
		base.baseEntity.InvalidateNetworkCache();
	}

	public bool CanStoreInInventory(Item item, int targetSlot)
	{
		return true;
	}

	public bool CanEquipItem(Item item, int targetSlot)
	{
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanEquipItem", (object)this, (object)item, (object)targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((item.info.flags & ItemDefinition.Flag.NotAllowedInBelt) != 0)
		{
			return false;
		}
		if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity.IsRestrained)
		{
			Handcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();
			if ((Object)(object)restraintItem != (Object)null && restraintItem.GetItem().position == targetSlot)
			{
				return false;
			}
		}
		ItemModContainerRestriction component = ((Component)item.info).GetComponent<ItemModContainerRestriction>();
		if ((Object)(object)component == (Object)null)
		{
			return true;
		}
		BufferList<Item> val = Pool.Get<BufferList<Item>>();
		val.CopyFrom(containerBelt.itemList);
		Enumerator<Item> enumerator = val.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Item current = enumerator.Current;
				if (current != item)
				{
					ItemModContainerRestriction component2 = ((Component)current.info).GetComponent<ItemModContainerRestriction>();
					if (!((Object)(object)component2 == (Object)null) && !component.CanExistWith(component2) && !current.MoveToContainer(containerMain))
					{
						current.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
					}
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Pool.Free<Item>(ref val, false);
		return true;
	}

	public bool CanWearItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanWearItem", (object)this, (object)item, (object)targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return CanWearItem(item, canAdjustClothing: true, targetSlot);
	}

	public bool CanWearItem(Item item, bool canAdjustClothing, int targetSlot)
	{
		return WearItemCheck(item, canAdjustClothing, targetSlot).Result;
	}

	public bool CanReplaceBackpack(Item itemToWear)
	{
		Item slot = containerWear.GetSlot(7);
		if (slot == null)
		{
			return true;
		}
		ItemContainer contents = slot.contents;
		if (contents != null && contents.itemList?.Count > 0)
		{
			if (base.baseEntity.InSafeZone())
			{
				return false;
			}
			if (!itemToWear.IsDroppedInWorld(serverside: true))
			{
				return false;
			}
		}
		return true;
	}

	public void ServerUpdate(float delta)
	{
		loot.Check();
		if (delta > 0f && !base.baseEntity.IsSleeping() && !base.baseEntity.IsTransferring())
		{
			crafting.ServerUpdate(delta);
		}
		float currentTemperature = base.baseEntity.currentTemperature;
		UpdateContainer(delta, Type.Main, containerMain, bSendInventoryToEveryone: false, currentTemperature);
		UpdateContainer(delta, Type.Belt, containerBelt, bSendInventoryToEveryone: true, currentTemperature);
		UpdateContainer(delta, Type.Wear, containerWear, bSendInventoryToEveryone: true, currentTemperature);
	}

	public void UpdateContainer(float delta, Type type, ItemContainer container, bool bSendInventoryToEveryone, float temperature)
	{
		if (container != null)
		{
			container.temperature = temperature;
			if (delta > 0f)
			{
				container.OnCycle(delta);
			}
			if (container.dirty)
			{
				SendUpdatedInventory(type, container, bSendInventoryToEveryone);
				base.baseEntity.InvalidateNetworkCache();
			}
		}
	}

	public void SendSnapshot()
	{
		TimeWarning val = TimeWarning.New("PlayerInventory.SendSnapshot", 0);
		try
		{
			SendUpdatedInventory(Type.Main, containerMain);
			SendUpdatedInventory(Type.Belt, containerBelt, bSendInventoryToEveryone: true);
			SendUpdatedInventory(Type.Wear, containerWear, bSendInventoryToEveryone: true);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void SendUpdatedInventory(Type type, ItemContainer container, bool bSendInventoryToEveryone = false)
	{
		if (type == Type.Wear)
		{
			if (bSendInventoryToEveryone)
			{
				SendUpdatedInventoryInternal(type, container, NetworkInventoryMode.LocalPlayer);
				SendUpdatedInventoryInternal(type, container, NetworkInventoryMode.EveryoneButLocal);
			}
			else
			{
				SendUpdatedInventoryInternal(type, container, NetworkInventoryMode.LocalPlayer);
			}
		}
		else
		{
			SendUpdatedInventoryInternal(type, container, bSendInventoryToEveryone ? NetworkInventoryMode.Everyone : NetworkInventoryMode.LocalPlayer);
		}
	}

	public void SendUpdatedInventoryInternal(Type type, ItemContainer container, NetworkInventoryMode mode)
	{
		UpdateItemContainer val = Pool.Get<UpdateItemContainer>();
		try
		{
			val.type = (int)type;
			if (base.baseEntity.IsSpectating())
			{
				mode = NetworkInventoryMode.LocalPlayer;
			}
			if (container != null)
			{
				container.dirty = false;
				val.container = Pool.Get<List<ItemContainer>>();
				bool bIncludeContainer = type != Type.Wear || mode == NetworkInventoryMode.LocalPlayer;
				val.container.Add(container.Save(bIncludeContainer));
			}
			if (Interface.CallHook("OnInventoryNetworkUpdate", (object)this, (object)container, (object)val, (object)type, (object)mode) != null)
			{
				return;
			}
			switch (mode)
			{
			case NetworkInventoryMode.Everyone:
				base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("UpdatedItemContainer"), val);
				break;
			case NetworkInventoryMode.LocalPlayer:
				base.baseEntity.ClientRPC(RpcTarget.Player("UpdatedItemContainer", base.baseEntity), val);
				break;
			case NetworkInventoryMode.EveryoneButLocal:
				if (base.baseEntity.net?.group?.subscribers == null)
				{
					break;
				}
				{
					foreach (Connection subscriber in base.baseEntity.net.group.subscribers)
					{
						if (subscriber.player is BasePlayer basePlayer && (Object)(object)basePlayer != (Object)(object)base.baseEntity)
						{
							base.baseEntity.ClientRPC(RpcTarget.Player("UpdatedItemContainer", basePlayer), val);
						}
					}
					break;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private WearCheckResult WearItemCheck(Item item, bool canAdjustClothing, int targetSlot, bool dontMove = false)
	{
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		ItemModWearable component = ((Component)item.info).GetComponent<ItemModWearable>();
		if ((Object)(object)component == (Object)null)
		{
			WearCheckResult result = default(WearCheckResult);
			result.Result = false;
			result.ChangedItem = null;
			return result;
		}
		if (component.npcOnly && !Inventory.disableAttireLimitations)
		{
			BasePlayer basePlayer = base.baseEntity;
			if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsNpc)
			{
				WearCheckResult result = default(WearCheckResult);
				result.Result = false;
				result.ChangedItem = null;
				return result;
			}
		}
		bool flag = item.IsBackpack();
		if (flag)
		{
			if (targetSlot != 7)
			{
				WearCheckResult result = default(WearCheckResult);
				result.Result = false;
				result.ChangedItem = null;
				return result;
			}
			if (!CanReplaceBackpack(item))
			{
				WearCheckResult result = default(WearCheckResult);
				result.Result = false;
				result.ChangedItem = null;
				return result;
			}
		}
		else if (!flag && targetSlot == 7)
		{
			WearCheckResult result = default(WearCheckResult);
			result.Result = false;
			result.ChangedItem = null;
			return result;
		}
		if ((Object)(object)((Component)item.info).GetComponent<ItemModParachute>() != (Object)null && !CanEquipParachute())
		{
			base.baseEntity.ShowToast(GameTip.Styles.Red_Normal, BackpackGroundedError, false);
			WearCheckResult result = default(WearCheckResult);
			result.Result = false;
			result.ChangedItem = null;
			return result;
		}
		if (component.preventsMounting && base.baseEntity.isMounted)
		{
			WearCheckResult result = default(WearCheckResult);
			result.Result = false;
			result.ChangedItem = null;
			return result;
		}
		BufferList<Item> val = Pool.Get<BufferList<Item>>();
		val.CopyFrom(containerWear.itemList);
		Enumerator<Item> enumerator = val.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Item clothingItem = enumerator.Current;
				if (clothingItem == item)
				{
					continue;
				}
				ItemModWearable component2 = ((Component)clothingItem.info).GetComponent<ItemModWearable>();
				if (!((Object)(object)component2 == (Object)null) && !Inventory.disableAttireLimitations && !component.CanExistWith(component2))
				{
					if (!canAdjustClothing)
					{
						Pool.Free<Item>(ref val, false);
						WearCheckResult result = default(WearCheckResult);
						result.Result = false;
						result.ChangedItem = null;
						return result;
					}
					if (!dontMove && (targetSlot != clothingItem.position || targetSlot == 7) && !DirectSwap(containerMain) && !DirectSwap(containerBelt) && !clothingItem.MoveToContainer(containerMain) && !clothingItem.MoveToContainer(containerBelt))
					{
						clothingItem.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
					}
				}
				bool DirectSwap(ItemContainer container)
				{
					if (container.itemList.Count == container.capacity && container.itemList.Contains(item))
					{
						if (!clothingItem.MoveToContainer(container))
						{
							return false;
						}
						item.RemoveFromContainer();
						return true;
					}
					return false;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Pool.Free<Item>(ref val, false);
		WearCheckResult result2 = default(WearCheckResult);
		result2.Result = true;
		result2.ChangedItem = returnItems;
		return result2;
	}

	public Item FindItemByUID(ItemId id)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (!((ItemId)(ref id)).IsValid)
		{
			return null;
		}
		if (containerMain != null)
		{
			Item item = containerMain.FindItemByUID(id);
			if (item != null && item.IsValid())
			{
				return item;
			}
		}
		if (containerBelt != null)
		{
			Item item2 = containerBelt.FindItemByUID(id);
			if (item2 != null && item2.IsValid())
			{
				return item2;
			}
		}
		if (containerWear != null)
		{
			Item item3 = containerWear.FindItemByUID(id);
			if (item3 != null && item3.IsValid())
			{
				return item3;
			}
		}
		return loot.FindItem(id);
	}

	public Item FindItemByItemID(string itemName)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemName);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		return FindItemByItemID(itemDefinition.itemid);
	}

	public Item FindItemByItemID(int id)
	{
		object obj = Interface.CallHook("OnInventoryItemFind", (object)this, (object)id);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (containerMain != null)
		{
			Item item = containerMain.FindItemByItemID(id);
			if (item != null && item.IsValid())
			{
				return item;
			}
		}
		if (containerBelt != null)
		{
			Item item2 = containerBelt.FindItemByItemID(id);
			if (item2 != null && item2.IsValid())
			{
				return item2;
			}
		}
		if (containerWear != null)
		{
			Item item3 = containerWear.FindItemByItemID(id);
			if (item3 != null && item3.IsValid())
			{
				return item3;
			}
		}
		return null;
	}

	public Item FindItemByItemName(string name)
	{
		if (containerMain != null)
		{
			Item item = containerMain.FindItemByItemName(name);
			if (item != null && item.IsValid())
			{
				return item;
			}
		}
		if (containerBelt != null)
		{
			Item item2 = containerBelt.FindItemByItemName(name);
			if (item2 != null && item2.IsValid())
			{
				return item2;
			}
		}
		if (containerWear != null)
		{
			Item item3 = containerWear.FindItemByItemName(name);
			if (item3 != null && item3.IsValid())
			{
				return item3;
			}
		}
		return null;
	}

	public Item FindBySubEntityID(NetworkableId subEntityID)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (containerMain != null)
		{
			Item item = containerMain.FindBySubEntityID(subEntityID);
			if (item != null && item.IsValid())
			{
				return item;
			}
		}
		if (containerBelt != null)
		{
			Item item2 = containerBelt.FindBySubEntityID(subEntityID);
			if (item2 != null && item2.IsValid())
			{
				return item2;
			}
		}
		if (containerWear != null)
		{
			Item item3 = containerWear.FindBySubEntityID(subEntityID);
			if (item3 != null && item3.IsValid())
			{
				return item3;
			}
		}
		return null;
	}

	public void FindItemsByItemID(List<Item> list, int id)
	{
		if (Interface.CallHook("OnInventoryItemsFind", (object)this, (object)id, (object)list) == null)
		{
			if (containerMain != null)
			{
				containerMain.FindItemsByItemID(list, id);
			}
			if (containerBelt != null)
			{
				containerBelt.FindItemsByItemID(list, id);
			}
			if (containerWear != null)
			{
				containerWear.FindItemsByItemID(list, id);
			}
		}
	}

	public ItemContainer FindContainer(ItemContainerId id)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FindContainer", 0);
		try
		{
			ItemContainer itemContainer = containerMain.FindContainer(id);
			if (itemContainer != null)
			{
				return itemContainer;
			}
			itemContainer = containerBelt.FindContainer(id);
			if (itemContainer != null)
			{
				return itemContainer;
			}
			itemContainer = containerWear.FindContainer(id);
			if (itemContainer != null)
			{
				return itemContainer;
			}
			return loot.FindContainer(id);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public ItemContainer GetContainer(Type id)
	{
		if (id == Type.Main)
		{
			return containerMain;
		}
		if (Type.Belt == id)
		{
			return containerBelt;
		}
		if (Type.Wear == id)
		{
			return containerWear;
		}
		if (Type.BackpackContents == id)
		{
			return GetBackpackWithInventory()?.contents;
		}
		return null;
	}

	public Item GetAnyBackpack()
	{
		return containerWear?.GetSlot(7);
	}

	public bool HasBackpackItem()
	{
		return GetAnyBackpack() != null;
	}

	public Item GetBackpackWithInventory()
	{
		Item anyBackpack = GetAnyBackpack();
		if (anyBackpack == null || anyBackpack.contents == null)
		{
			return null;
		}
		return anyBackpack;
	}

	public void DropBackpackOnDeath(bool wounded)
	{
		if (base.baseEntity.InSafeZone())
		{
			return;
		}
		if (wounded)
		{
			if (!Player.dropbackpackondowned)
			{
				return;
			}
		}
		else if (!Player.dropbackpackondeath)
		{
			return;
		}
		Item anyBackpack = GetAnyBackpack();
		if (anyBackpack != null)
		{
			ItemModBackpack component = ((Component)anyBackpack.info).GetComponent<ItemModBackpack>();
			if (!((Object)(object)component == (Object)null) && component.DropWhenDowned)
			{
				TryDropBackpack();
			}
		}
	}

	public Item GetEquippedPrisonerHoodItem()
	{
		return containerWear.FindItemByItemID(Handcuffs.PrisonerHoodItemID);
	}

	public Item GetUsableHoodItem()
	{
		return FindItemByItemID(Handcuffs.PrisonerHoodItemID);
	}

	public bool GiveItem(Item item, ItemContainer container = null, GiveItemOptions options = GiveItemOptions.None)
	{
		return GiveItem(item, (ItemMoveModifier)0, container, options);
	}

	public bool GiveItem(Item item, ItemMoveModifier modifiers, ItemContainer container = null, GiveItemOptions options = GiveItemOptions.None)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		bool tryWearClothing = ((Enum)modifiers).HasFlag((Enum)(object)(ItemMoveModifier)2);
		bool flag = ((Enum)modifiers).HasFlag((Enum)(object)(ItemMoveModifier)16);
		if (item == null)
		{
			return false;
		}
		if (container == null)
		{
			container = GetIdealPickupContainer(item, tryWearClothing);
		}
		if (container != null && item.MoveToContainer(container))
		{
			return true;
		}
		if (item.MoveToContainer(containerMain))
		{
			return true;
		}
		if (flag || options.HasFlag(GiveItemOptions.BackpackOverflow))
		{
			Item backpackWithInventory = GetBackpackWithInventory();
			if (backpackWithInventory != null && item.MoveToContainer(backpackWithInventory.contents))
			{
				return true;
			}
		}
		if (item.MoveToContainer(containerBelt))
		{
			return true;
		}
		return false;
	}

	public ItemContainer GetIdealPickupContainer(Item item, bool tryWearClothing)
	{
		if (item.MaxStackable() > 1)
		{
			if (containerBelt != null && containerBelt.FindItemByItemID(item.info.itemid) != null)
			{
				return containerBelt;
			}
			if (containerMain != null && containerMain.FindItemByItemID(item.info.itemid) != null)
			{
				return containerMain;
			}
		}
		if (item.info.isWearable && item.info.ItemModWearable.equipOnPickup && item.IsDroppedInWorld(serverside: true))
		{
			Item anyBackpack = GetAnyBackpack();
			if ((Object)(object)((Component)item.info).GetComponent<ItemModShield>() != (Object)null && anyBackpack != null && (Object)(object)((Component)anyBackpack.info).GetComponent<ItemModShield>() != (Object)null)
			{
				if (!containerMain.IsFull())
				{
					return containerMain;
				}
				return containerBelt;
			}
			if (anyBackpack != null && anyBackpack.GetItemVolume() > containerMain.containerVolume && item.GetItemVolume() <= containerMain.containerVolume)
			{
				if (!containerMain.IsFull())
				{
					return containerMain;
				}
				return containerBelt;
			}
			return containerWear;
		}
		if (tryWearClothing && item.info.isWearable && CanWearItem(item, canAdjustClothing: false, item.IsBackpack() ? 7 : (-1)))
		{
			return containerWear;
		}
		if (item.info.isUsable && !item.info.HasFlag(ItemDefinition.Flag.NotStraightToBelt))
		{
			return containerBelt;
		}
		return null;
	}

	public void Strip()
	{
		containerMain.Clear();
		containerBelt.Clear();
		containerWear.Clear();
		ItemManager.DoRemoves();
	}

	public static bool IsBirthday()
	{
		if (forceBirthday)
		{
			return true;
		}
		if (Time.time < nextCheckTime)
		{
			return wasBirthday;
		}
		nextCheckTime = Time.time + 60f;
		DateTime now = DateTime.Now;
		wasBirthday = now.Month == 12 && now.Day >= 7 && now.Day <= 16;
		return wasBirthday;
	}

	public static bool IsChristmas()
	{
		return XMas.enabled;
	}

	public void GiveDefaultItems()
	{
		if (Interface.CallHook("OnDefaultItemsReceive", (object)this) != null)
		{
			return;
		}
		Strip();
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null && activeGameMode.HasLoadouts())
		{
			BaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);
			return;
		}
		GiveDefaultItemWithSkin("client.rockskin", "rock");
		GiveDefaultItemWithSkin("client.torchskin", "torch");
		if (IsBirthday() && !base.baseEntity.IsInTutorial)
		{
			TryGiveItem("cakefiveyear", 0uL, containerBelt);
			TryGiveItem("partyhat", 0uL, containerWear);
		}
		if (IsChristmas() && !base.baseEntity.IsInTutorial)
		{
			TryGiveItem("snowball", 0uL, containerBelt);
			TryGiveItem("snowball", 0uL, containerBelt);
			TryGiveItem("snowball", 0uL, containerBelt);
		}
		Interface.CallHook("OnDefaultItemsReceived", (object)this);
		void GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)
		{
			ulong num = 0uL;
			int infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);
			bool flag = false;
			if (infoInt > 0 && !base.baseEntity.AllSkinsLocked && (base.baseEntity.AllSkinsUnlocked || base.baseEntity.blueprints.CheckSkinOwnership(infoInt, base.baseEntity.userID)))
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);
				if ((Object)(object)itemDefinition != (Object)null && ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)
				{
					IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);
					if (itemDefinition2 != null)
					{
						num = itemDefinition2.WorkshopDownload;
					}
					if (num == 0L && itemDefinition.skins != null)
					{
						ItemSkinDirectory.Skin[] skins = itemDefinition.skins;
						for (int i = 0; i < skins.Length; i++)
						{
							ItemSkinDirectory.Skin skin2 = skins[i];
							if (skin2.id == infoInt && (Object)(object)skin2.invItem != (Object)null && skin2.invItem is ItemSkin itemSkin && (Object)(object)itemSkin.Redirect != (Object)null)
							{
								TryGiveItem(itemSkin.Redirect.shortname, 0uL, containerBelt);
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (!flag)
			{
				TryGiveItem(itemShortName, num, containerBelt);
			}
		}
		bool TryGiveItem(string itemShortName, ulong skin, ItemContainer container)
		{
			Item item = ItemManager.CreateByName(itemShortName, 1, skin);
			if (item != null)
			{
				item.SetItemOwnership(base.baseEntity, ItemOwnershipPhrases.BornPhrase);
				GiveItem(item, container);
				return true;
			}
			Debug.LogError((object)$"Failed to spawn {itemShortName} with {skin}!");
			return false;
		}
	}

	public bool CanEquipParachute()
	{
		if (ConVar.Server.canEquipBackpacksInAir || Parachute.BypassRepack)
		{
			return true;
		}
		if (base.baseEntity.WaterFactor() > 0.5f)
		{
			return true;
		}
		if (!base.baseEntity.IsOnGround())
		{
			return false;
		}
		if (base.baseEntity.isMounted && Object.op_Implicit((Object)(object)base.baseEntity.GetMounted()) && base.baseEntity.GetMounted().VehicleParent() is Parachute)
		{
			return false;
		}
		return true;
	}

	public PlayerInventory Save(bool bForDisk)
	{
		PlayerInventory val = Pool.Get<PlayerInventory>();
		if (bForDisk)
		{
			val.invMain = containerMain.Save();
		}
		val.invBelt = containerBelt.Save();
		val.invWear = containerWear.Save();
		return val;
	}

	public void Load(PlayerInventory msg)
	{
		if (msg.invMain != null)
		{
			containerMain.Load(msg.invMain);
		}
		if (msg.invBelt != null)
		{
			containerBelt.Load(msg.invBelt);
		}
		if (msg.invWear != null)
		{
			containerWear.Load(msg.invWear);
		}
		if (Object.op_Implicit((Object)(object)base.baseEntity) && base.baseEntity.isServer && containerWear.capacity == 7)
		{
			containerWear.capacity = 8;
		}
	}

	public void TryDropBackpack()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		Item anyBackpack = GetAnyBackpack();
		if (anyBackpack != null && base.baseEntity.isServer && Interface.CallHook("OnBackpackDrop", (object)anyBackpack, (object)this) == null)
		{
			anyBackpack.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
		}
	}

	public int Take(List<Item> collect, int itemid, int amount)
	{
		object obj = Interface.CallHook("OnInventoryItemsTake", (object)this, (object)collect, (object)itemid, (object)amount);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (containerMain != null)
		{
			int num2 = containerMain.Take(collect, itemid, amount);
			num += num2;
			amount -= num2;
		}
		if (amount <= 0)
		{
			return num;
		}
		if (containerBelt != null)
		{
			int num3 = containerBelt.Take(collect, itemid, amount);
			num += num3;
			amount -= num3;
		}
		if (amount <= 0)
		{
			return num;
		}
		if (containerWear != null)
		{
			int num4 = containerWear.Take(collect, itemid, amount);
			num += num4;
			amount -= num4;
		}
		return num;
	}

	public bool HasEmptySlotInBeltOrMain()
	{
		if (containerMain != null && containerMain.capacity > containerMain.itemList.Count)
		{
			return true;
		}
		if (containerBelt != null && containerBelt.capacity > containerBelt.itemList.Count)
		{
			return true;
		}
		return false;
	}

	public bool HasEmptySlots(int requiredSlots)
	{
		int num = 0;
		if (containerMain != null)
		{
			num += containerMain.capacity - containerMain.itemList.Count;
		}
		if (containerBelt != null)
		{
			num += containerBelt.capacity - containerBelt.itemList.Count;
		}
		return num >= requiredSlots;
	}

	public int GetAmount(ItemDefinition definition)
	{
		if (!((Object)(object)definition != (Object)null))
		{
			return 0;
		}
		return GetAmount(definition.itemid);
	}

	public int GetAmount(int itemid, bool includeBackpack = false)
	{
		if (itemid == 0)
		{
			return 0;
		}
		object obj = Interface.CallHook("OnInventoryItemsCount", (object)this, (object)itemid, (object)includeBackpack);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (containerMain != null)
		{
			num += containerMain.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerBelt != null)
		{
			num += containerBelt.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerWear != null)
		{
			num += containerWear.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (includeBackpack)
		{
			Item backpackWithInventory = GetBackpackWithInventory();
			if (backpackWithInventory != null && backpackWithInventory.contents != null)
			{
				num += backpackWithInventory.contents.GetAmount(itemid, onlyUsableAmounts: true);
			}
		}
		return num;
	}

	public int GetOkConditionAmount(int itemid)
	{
		if (itemid == 0)
		{
			return 0;
		}
		int num = 0;
		if (containerMain != null)
		{
			num += containerMain.GetOkConditionAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerBelt != null)
		{
			num += containerBelt.GetOkConditionAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerWear != null)
		{
			num += containerWear.GetOkConditionAmount(itemid, onlyUsableAmounts: true);
		}
		return num;
	}

	public bool Contains(Item item)
	{
		bool flag = containerMain?.itemList.Contains(item) ?? false;
		if (!flag)
		{
			flag = containerBelt?.itemList.Contains(item) ?? false;
		}
		if (!flag)
		{
			flag = containerWear?.itemList.Contains(item) ?? false;
		}
		return flag;
	}

	public int GetAllItems(List<Item> items)
	{
		items.Clear();
		if (containerMain != null)
		{
			items.AddRange(containerMain.itemList);
		}
		if (containerBelt != null)
		{
			items.AddRange(containerBelt.itemList);
		}
		if (containerWear != null)
		{
			items.AddRange(containerWear.itemList);
		}
		return items.Count;
	}

	public Item FindAmmo(AmmoTypes ammoType)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnInventoryAmmoItemFind", (object)this, (object)ammoType);
		if (obj is Item)
		{
			return (Item)obj;
		}
		Item item = containerMain?.FindAmmo(ammoType);
		if (item == null)
		{
			item = containerBelt?.FindAmmo(ammoType);
		}
		return item;
	}

	public void FindAmmo(List<Item> list, AmmoTypes ammoType)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnInventoryAmmoFind", (object)this, (object)list, (object)ammoType) == null)
		{
			containerMain?.FindAmmo(list, ammoType);
			containerBelt?.FindAmmo(list, ammoType);
		}
	}

	public bool HasAmmo(AmmoTypes ammoType)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!containerMain.HasAmmo(ammoType))
		{
			return containerBelt.HasAmmo(ammoType);
		}
		return true;
	}

	private void OnItemRadiationChanged(Item item, float rads)
	{
		CalculateInventoryRadioactivity();
	}

	private void CalculateInventoryRadioactivity()
	{
		float num = 0f;
		if (containerMain != null)
		{
			num += containerMain.GetRadioactiveMaterialInContainer();
		}
		if (containerBelt != null)
		{
			num += containerBelt.GetRadioactiveMaterialInContainer();
		}
		if (containerWear != null)
		{
			num += containerWear.GetRadioactiveMaterialInContainer();
		}
		inventoryRadioactivity = num;
		bool arg = (containsRadioactiveItems = num > 0f);
		this.onRadioactivityChanged?.Invoke(num, arg);
	}

	private void CalculateInventoryRadioactivityCheckFast()
	{
		if (containsRadioactiveItems)
		{
			CalculateInventoryRadioactivity();
		}
	}
}


public enum Type
{
	Main,
	Belt,
	Wear,
	BackpackContents
}


public readonly struct CanMoveFromResponse
{
	public readonly bool allowed;

	public readonly Phrase reasonForFailure;

	public static CanMoveFromResponse Success()
	{
		return new CanMoveFromResponse(allowed: true, null);
	}

	public static CanMoveFromResponse Failure(Phrase reasonForFailure)
	{
		return new CanMoveFromResponse(allowed: false, reasonForFailure);
	}

	public CanMoveFromResponse(bool allowed, Phrase reasonForFailure)
	{
		this.allowed = allowed;
		this.reasonForFailure = reasonForFailure;
	}
}


public interface ICanMoveFrom
{
	CanMoveFromResponse CanMoveFrom(BasePlayer player, Item item);
}


public enum NetworkInventoryMode
{
	LocalPlayer,
	Everyone,
	EveryoneButLocal
}


using System.Collections.Generic;

private struct WearCheckResult
{
	public bool Result;

	public List<Item> ChangedItem;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class PlayerLoot : EntityComponent<BasePlayer>
{
	public BaseEntity entitySource;

	public Item itemSource;

	public List<ItemContainer> containers = new List<ItemContainer>();

	public bool PositionChecks = true;

	private bool isInvokingSendUpdate;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlayerLoot.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsLooting()
	{
		return containers.Count > 0;
	}

	public float GetRadsInPlayerLoot()
	{
		float num = 0f;
		foreach (ItemContainer container in containers)
		{
			num += container.GetRadioactiveMaterialInContainer();
		}
		return num;
	}

	public void Clear()
	{
		if (!IsLooting())
		{
			return;
		}
		Interface.CallHook("OnPlayerLootEnd", (object)this);
		base.baseEntity.HasClosedLoot();
		MarkDirty();
		if (Object.op_Implicit((Object)(object)entitySource))
		{
			((Component)entitySource).SendMessage("PlayerStoppedLooting", (object)base.baseEntity, (SendMessageOptions)1);
		}
		foreach (ItemContainer container in containers)
		{
			if (container != null)
			{
				container.onDirty -= MarkDirty;
			}
		}
		ClearContainers();
		entitySource = null;
		itemSource = null;
	}

	public ItemContainer FindContainer(ItemContainerId id)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		Check();
		if (!IsLooting())
		{
			return null;
		}
		foreach (ItemContainer container in containers)
		{
			ItemContainer itemContainer = container.FindContainer(id);
			if (itemContainer != null)
			{
				return itemContainer;
			}
		}
		return null;
	}

	public Item FindItem(ItemId id)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		Check();
		if (!IsLooting())
		{
			return null;
		}
		foreach (ItemContainer container in containers)
		{
			Item item = container.FindItemByUID(id);
			if (item != null && item.IsValid())
			{
				return item;
			}
		}
		return null;
	}

	public void Check()
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (!IsLooting() || !base.baseEntity.isServer)
		{
			return;
		}
		if ((Object)(object)entitySource == (Object)null)
		{
			base.baseEntity.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.LootableDoesntExist, false);
			Clear();
		}
		else if (!entitySource.CanBeLooted(base.baseEntity) || entitySource.IsTransferring())
		{
			Clear();
		}
		else
		{
			if (!PositionChecks)
			{
				return;
			}
			float num = entitySource.Distance(base.baseEntity.eyes.position);
			if (num > 3f)
			{
				LootDistanceOverride component = ((Component)entitySource).GetComponent<LootDistanceOverride>();
				if ((Object)(object)component == (Object)null || num > component.amount)
				{
					Clear();
				}
			}
		}
	}

	public void MarkDirty()
	{
		if (!isInvokingSendUpdate)
		{
			isInvokingSendUpdate = true;
			((FacepunchBehaviour)this).Invoke((Action)SendUpdate, 0.1f);
		}
	}

	public void SendImmediate()
	{
		if (isInvokingSendUpdate)
		{
			isInvokingSendUpdate = false;
			((FacepunchBehaviour)this).CancelInvoke((Action)SendUpdate);
		}
		SendUpdate();
	}

	private void SendUpdate()
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		isInvokingSendUpdate = false;
		if (!base.baseEntity.IsValid() || Interface.CallHook("OnLootNetworkUpdate", (object)this) != null)
		{
			return;
		}
		PlayerUpdateLoot val = Pool.Get<PlayerUpdateLoot>();
		try
		{
			if (Object.op_Implicit((Object)(object)entitySource) && entitySource.net != null)
			{
				val.entityID = entitySource.net.ID;
			}
			if (itemSource != null)
			{
				val.itemID = itemSource.uid;
			}
			if (containers.Count > 0)
			{
				val.containers = Pool.Get<List<ItemContainer>>();
				foreach (ItemContainer container in containers)
				{
					val.containers.Add(container.Save());
				}
			}
			base.baseEntity.ClientRPC(RpcTarget.Player("UpdateLoot", base.baseEntity), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)
	{
		Clear();
		if (!Object.op_Implicit((Object)(object)targetEntity))
		{
			return false;
		}
		if (!targetEntity.OnStartBeingLooted(base.baseEntity))
		{
			return false;
		}
		Assert.IsTrue(targetEntity.isServer, "Assure is server");
		PositionChecks = doPositionChecks;
		entitySource = targetEntity;
		itemSource = null;
		Interface.CallHook("OnLootEntity", (object)((Component)this).GetComponent<BasePlayer>(), (object)targetEntity);
		MarkDirty();
		if (targetEntity is ILootableEntity lootableEntity)
		{
			lootableEntity.LastLootedBy = base.baseEntity.userID;
			lootableEntity.LastLootedByPlayer = base.baseEntity;
		}
		return true;
	}

	public void AddContainer(ItemContainer container)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		if (container != null)
		{
			containers.Add(container);
			container.onDirty += MarkDirty;
			if ((Object)(object)container.entityOwner != (Object)null)
			{
				base.baseEntity.ProcessMissionEvent(BaseMission.MissionEventType.OPEN_STORAGE, new BaseMission.MissionEventPayload
				{
					UintIdentifier = container.entityOwner.prefabID,
					NetworkIdentifier = container.entityOwner.net.ID,
					WorldPosition = ((Component)container.entityOwner).transform.position
				}, 0f);
			}
		}
	}

	public void RemoveContainer(ItemContainer container)
	{
		if (container != null)
		{
			container.onDirty -= MarkDirty;
			containers.Remove(container);
		}
	}

	public bool RemoveContainerAt(int index)
	{
		if (index < 0 || index >= containers.Count)
		{
			return false;
		}
		if (containers[index] != null)
		{
			containers[index].onDirty -= MarkDirty;
		}
		containers.RemoveAt(index);
		return true;
	}

	public void StartLootingItem(Item item)
	{
		Clear();
		if (item != null && item.contents != null)
		{
			PositionChecks = true;
			containers.Add(item.contents);
			item.contents.onDirty += MarkDirty;
			itemSource = item;
			entitySource = item.GetWorldEntity();
			Interface.CallHook("OnLootItem", (object)((Component)this).GetComponent<BasePlayer>(), (object)item);
			MarkDirty();
		}
	}

	private void ClearContainers()
	{
		containers.Clear();
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class PlayerMetabolism : BaseMetabolism<BasePlayer>
{
	public const float HotThreshold = 40f;

	public const float ColdThreshold = 5f;

	public const float OxygenHurtThreshold = 0.5f;

	public const float OxygenDepleteTime = 10f;

	public const float OxygenRefillTime = 1f;

	public MetabolismAttribute temperature = new MetabolismAttribute();

	public MetabolismAttribute poison = new MetabolismAttribute();

	public MetabolismAttribute radiation_level = new MetabolismAttribute();

	public MetabolismAttribute radiation_poison = new MetabolismAttribute();

	public MetabolismAttribute wetness = new MetabolismAttribute();

	public MetabolismAttribute dirtyness = new MetabolismAttribute();

	public MetabolismAttribute oxygen = new MetabolismAttribute();

	public MetabolismAttribute bleeding = new MetabolismAttribute();

	public MetabolismAttribute comfort = new MetabolismAttribute();

	public MetabolismAttribute pending_health = new MetabolismAttribute();

	public bool isDirty;

	private float lastConsumeTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlayerMetabolism.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Reset()
	{
		base.Reset();
		poison.Reset();
		radiation_level.Reset();
		radiation_poison.Reset();
		temperature.Reset();
		oxygen.Reset();
		bleeding.Reset();
		wetness.Reset();
		dirtyness.Reset();
		comfort.Reset();
		pending_health.Reset();
		lastConsumeTime = float.NegativeInfinity;
		isDirty = true;
	}

	public override void ServerUpdate(BaseCombatEntity ownerEntity, float delta)
	{
		base.ServerUpdate(ownerEntity, delta);
		Interface.CallHook("OnPlayerMetabolize", (object)this, (object)ownerEntity, (object)delta);
		if (owner.IsConnected)
		{
			SendChangesToClient();
		}
	}

	internal bool HasChanged()
	{
		bool flag = isDirty;
		flag = calories.HasChanged() || flag;
		flag = hydration.HasChanged() || flag;
		flag = heartrate.HasChanged() || flag;
		flag = poison.HasChanged() || flag;
		flag = radiation_level.HasChanged() || flag;
		flag = radiation_poison.HasChanged() || flag;
		flag = temperature.HasChanged() || flag;
		flag = wetness.HasChanged() || flag;
		flag = dirtyness.HasChanged() || flag;
		flag = comfort.HasChanged() || flag;
		return pending_health.HasChanged() || flag;
	}

	protected override void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta)
	{
		if (owner.IsConnected)
		{
			base.DoMetabolismDamage(ownerEntity, delta);
			if (temperature.value < -20f)
			{
				owner.Hurt(Mathf.InverseLerp(1f, -50f, temperature.value) * delta * 1f, DamageType.Cold);
			}
			else if (temperature.value < -10f)
			{
				owner.Hurt(Mathf.InverseLerp(1f, -50f, temperature.value) * delta * 0.3f, DamageType.Cold);
			}
			else if (temperature.value < 1f)
			{
				owner.Hurt(Mathf.InverseLerp(1f, -50f, temperature.value) * delta * 0.1f, DamageType.Cold);
			}
			if (temperature.value > 60f)
			{
				owner.Hurt(Mathf.InverseLerp(60f, 200f, temperature.value) * delta * 5f, DamageType.Heat);
			}
			if (!owner.IsGod() && bleeding.value > 0f)
			{
				float num = delta * (1f / 3f);
				owner.Hurt(num, DamageType.Bleeding);
				bleeding.Subtract(num);
			}
			if (!owner.IsGod() && poison.value > 0f)
			{
				owner.Hurt(poison.value * delta * 0.1f, DamageType.Poison);
			}
			if (ConVar.Server.radiation && radiation_poison.value > 0f)
			{
				float num2 = (1f + Mathf.Clamp01(radiation_poison.value / 25f) * 5f) * (delta / 5f);
				owner.Hurt(num2, DamageType.Radiation);
				radiation_poison.Subtract(num2);
			}
		}
		if (oxygen.value < 0.5f)
		{
			float num3 = (owner.IsConnected ? 1f : 0.01f);
			owner.Hurt(Mathf.InverseLerp(0.5f, 0f, oxygen.value) * delta * 20f * num3, DamageType.Drowned, null, useProtection: false);
		}
	}

	public bool SignificantBleeding()
	{
		return bleeding.value > 0f;
	}

	public void ForceUpdateWorkbenchFlags()
	{
		owner.InvalidateWorkbenchCache();
		UpdateWorkbenchFlags();
	}

	private void UpdateWorkbenchFlags()
	{
		float currentCraftLevel = owner.currentCraftLevel;
		owner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, currentCraftLevel == 1f);
		owner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, currentCraftLevel == 2f);
		owner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, currentCraftLevel == 3f);
	}

	protected override void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
	{
		//IL_04ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fe: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnRunPlayerMetabolism", (object)this, (object)ownerEntity, (object)delta) != null)
		{
			return;
		}
		if (owner.IsConnected)
		{
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
			float num = owner.currentTemperature;
			float fTarget = owner.currentComfort;
			UpdateWorkbenchFlags();
			owner.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, owner.InSafeZone());
			owner.SetPlayerFlag(BasePlayer.PlayerFlags.NoRespawnZone, owner.InNoRespawnZone());
			owner.SetPlayerFlag(BasePlayer.PlayerFlags.ModifyClan, Clan.editsRequireClanTable && owner.CanModifyClan());
			bool num2 = (Object)(object)activeGameMode == (Object)null || activeGameMode.allowTemperature;
			if (owner.IsInTutorial)
			{
				num = 25f;
			}
			if (num2)
			{
				float num3 = num + GetCoreTempAdjustment() - DeltaWet() * 34f;
				float num4 = Mathf.Clamp(owner.baseProtection.amounts[18] * 1.5f, -1f, 1f);
				float num5 = Mathf.InverseLerp(20f, -50f, num);
				float num6 = Mathf.InverseLerp(20f, 30f, num);
				float fTarget2 = Mathf.Clamp(num3 + num5 * 70f * num4 + num6 * 10f * Mathf.Abs(num4) + heartrate.value * 5f, GetCoreTempMin(), GetCoreTempMax());
				temperature.MoveTowards(fTarget2, delta * 5f);
			}
			else
			{
				temperature.value = 25f;
			}
			if (temperature.value >= 40f)
			{
				fTarget = 0f;
			}
			comfort.MoveTowards(fTarget, delta / 5f);
			float num7 = 0.6f + 0.4f * comfort.value;
			if (calories.value > 100f && owner.healthFraction < num7 && radiation_poison.Fraction() < 0.25f && owner.SecondsSinceAttacked > 10f && !SignificantBleeding() && temperature.value >= 10f && hydration.value > 40f)
			{
				float num8 = Mathf.InverseLerp(calories.min, calories.max, calories.value);
				float num9 = 5f;
				float num10 = num9 * owner.MaxHealth() * 0.8f / 600f;
				num10 += num10 * num8 * 0.5f;
				float num11 = num10 / num9;
				num11 += num11 * comfort.value * 6f;
				ownerEntity.Heal(num11 * delta);
				calories.Subtract(num10 * delta);
				hydration.Subtract(num10 * delta * 0.2f);
			}
			float num12 = owner.estimatedSpeed2D / owner.GetMaxSpeed() * 0.75f;
			float fTarget3 = Mathf.Clamp(0.05f + num12, 0f, 1f);
			heartrate.MoveTowards(fTarget3, delta * 0.1f);
			if (!owner.IsGod())
			{
				float num13 = heartrate.Fraction() * 0.375f;
				calories.MoveTowards(0f, delta * num13);
				float num14 = 1f / 120f;
				num14 += Mathf.InverseLerp(40f, 60f, temperature.value) * (1f / 12f);
				num14 += heartrate.value * (1f / 15f);
				hydration.MoveTowards(0f, delta * num14);
			}
			bool b = hydration.Fraction() <= 0f || radiation_poison.value >= 100f;
			owner.SetPlayerFlag(BasePlayer.PlayerFlags.NoSprint, b);
			if (temperature.value > 40f)
			{
				hydration.Add(Mathf.InverseLerp(40f, 200f, temperature.value) * delta * -1f);
			}
			if (temperature.value < 10f)
			{
				float num15 = Mathf.InverseLerp(20f, -100f, temperature.value);
				heartrate.MoveTowards(Mathf.Lerp(0.2f, 1f, num15), delta * 2f * num15);
			}
			float num16 = 0f;
			float num17 = 0f;
			if (owner.IsOutside(owner.eyes.position))
			{
				num16 = Climate.GetRain(owner.eyes.position) * Weather.wetness_rain;
				num17 = Climate.GetSnow(owner.eyes.position) * Weather.wetness_snow;
			}
			bool flag = owner.baseProtection.amounts[4] > 0f;
			float currentEnvironmentalWetness = owner.currentEnvironmentalWetness;
			currentEnvironmentalWetness = Mathf.Clamp(currentEnvironmentalWetness, 0f, 0.8f);
			float num18 = owner.WaterFactor();
			if (!flag && num18 > 0f)
			{
				wetness.value = Mathf.Max(wetness.value, Mathf.Clamp(num18, wetness.min, wetness.max));
			}
			float num19 = Mathx.Max(wetness.value, num16, num17, currentEnvironmentalWetness);
			num19 = Mathf.Min(num19, flag ? 0f : num19);
			wetness.MoveTowards(num19, delta * 0.05f);
			if (num18 < wetness.value && currentEnvironmentalWetness <= 0f)
			{
				wetness.MoveTowards(0f, delta * 0.2f * Mathf.InverseLerp(0f, 100f, num));
			}
			poison.MoveTowards(0f, delta * (5f / 9f));
			if (wetness.Fraction() > 0.4f && owner.estimatedSpeed > 0.25f && radiation_level.Fraction() == 0f)
			{
				radiation_poison.Subtract(radiation_poison.value * 0.2f * wetness.Fraction() * delta * 0.2f);
			}
			if (ConVar.Server.radiation)
			{
				if (!owner.IsGod())
				{
					float radiationAfterProtection = Radiation.GetRadiationAfterProtection(owner.modifiers.GetValue(Modifier.ModifierType.Radiation), ownerEntity.RadiationProtection());
					radiation_level.value = owner.radiationLevel + radiationAfterProtection;
					if (radiation_level.value > 0f)
					{
						radiation_poison.Add(radiation_level.value * delta);
					}
				}
				else if (radiation_level.value > 0f)
				{
					radiation_level.value = 0f;
					radiation_poison.value = 0f;
				}
			}
			if (pending_health.value > 0f)
			{
				float num20 = 1f + owner.modifiers.GetValue(Modifier.ModifierType.MetabolismBooster);
				float num21 = Mathf.Min(1f * delta * num20, pending_health.value);
				ownerEntity.Heal(num21);
				if (ownerEntity.healthFraction == 1f)
				{
					pending_health.value = 0f;
				}
				else
				{
					pending_health.Subtract(num21);
				}
			}
		}
		float num22 = owner.AirFactor();
		float num23 = ((num22 > oxygen.value) ? 1f : 0.1f);
		oxygen.MoveTowards(num22, delta * num23);
	}

	private float GetCoreTempAdjustment()
	{
		if ((Object)(object)owner == (Object)null)
		{
			return 0f;
		}
		PlayerModifiers modifiers = owner.modifiers;
		if ((Object)(object)modifiers == (Object)null)
		{
			return 0f;
		}
		return 0f + modifiers.GetValue(Modifier.ModifierType.Warming) + modifiers.GetValue(Modifier.ModifierType.Cooling);
	}

	private float GetCoreTempMin()
	{
		if ((Object)(object)owner == (Object)null)
		{
			return temperature.min;
		}
		PlayerModifiers modifiers = owner.modifiers;
		if ((Object)(object)modifiers == (Object)null)
		{
			return temperature.min;
		}
		return modifiers.GetValue(Modifier.ModifierType.CoreTemperatureMinAdjustment, temperature.min);
	}

	private float GetCoreTempMax()
	{
		if ((Object)(object)owner == (Object)null)
		{
			return temperature.max;
		}
		PlayerModifiers modifiers = owner.modifiers;
		if ((Object)(object)modifiers == (Object)null)
		{
			return temperature.max;
		}
		return modifiers.GetValue(Modifier.ModifierType.CoreTemperatureMaxAdjustment, temperature.max);
	}

	private float DeltaHot()
	{
		return Mathf.InverseLerp(20f, 100f, temperature.value);
	}

	private float DeltaCold()
	{
		return Mathf.InverseLerp(20f, -50f, temperature.value);
	}

	private float DeltaWet()
	{
		return wetness.value;
	}

	public void UseHeart(float frate)
	{
		if (heartrate.value > frate)
		{
			heartrate.Add(frate);
		}
		else
		{
			heartrate.value = frate;
		}
	}

	public void SendChangesToClient()
	{
		if (!HasChanged())
		{
			return;
		}
		isDirty = false;
		PlayerMetabolism val = Save();
		try
		{
			base.baseEntity.ClientRPC(RpcTarget.PlayerAndSpectators("UpdateMetabolism", base.baseEntity), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void ApplyChange(MetabolismAttribute.Type type, float amount, float time)
	{
		FindAttribute(type)?.Add(amount);
	}

	public bool CanConsume()
	{
		if (Object.op_Implicit((Object)(object)owner) && owner.IsHeadUnderwater())
		{
			return false;
		}
		return Time.time - lastConsumeTime > 1f;
	}

	public void MarkConsumption()
	{
		lastConsumeTime = Time.time;
	}

	public PlayerMetabolism Save()
	{
		PlayerMetabolism val = Pool.Get<PlayerMetabolism>();
		val.calories = calories.value;
		val.hydration = hydration.value;
		val.heartrate = heartrate.value;
		val.temperature = temperature.value;
		val.radiation_level = radiation_level.value;
		val.radiation_poisoning = radiation_poison.value;
		val.wetness = wetness.value;
		val.dirtyness = dirtyness.value;
		val.oxygen = oxygen.value;
		val.bleeding = bleeding.value;
		val.comfort = comfort.value;
		val.poison = poison.value;
		val.pending_health = pending_health.value;
		if (Object.op_Implicit((Object)(object)owner))
		{
			val.health = owner.Health();
		}
		return val;
	}

	public void Load(PlayerMetabolism s)
	{
		calories.SetValue(s.calories);
		hydration.SetValue(s.hydration);
		comfort.SetValue(s.comfort);
		heartrate.value = s.heartrate;
		temperature.value = s.temperature;
		radiation_level.value = s.radiation_level;
		radiation_poison.value = s.radiation_poisoning;
		wetness.value = s.wetness;
		dirtyness.value = s.dirtyness;
		oxygen.value = s.oxygen;
		bleeding.value = s.bleeding;
		poison.value = s.poison;
		pending_health.value = s.pending_health;
		if (Object.op_Implicit((Object)(object)owner))
		{
			owner.health = s.health;
		}
	}

	public void SetAttribute(MetabolismAttribute.Type type, float amount)
	{
		MetabolismAttribute metabolismAttribute = FindAttribute(type);
		if (metabolismAttribute != null)
		{
			float num = metabolismAttribute.value - amount;
			metabolismAttribute.Add(0f - num);
		}
	}

	public override MetabolismAttribute FindAttribute(MetabolismAttribute.Type type)
	{
		return type switch
		{
			MetabolismAttribute.Type.Poison => poison, 
			MetabolismAttribute.Type.Bleeding => bleeding, 
			MetabolismAttribute.Type.Radiation => radiation_poison, 
			MetabolismAttribute.Type.HealthOverTime => pending_health, 
			_ => base.FindAttribute(type), 
		};
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class PlayerModifiers : BaseModifiers<BasePlayer>
{
	public List<ModifierLimits> Limits;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PlayerModifiers.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static void AddToPlayer(BasePlayer player, List<ModifierDefintion> modifiers, float effectScale = 1f, float durationScale = 1f)
	{
		if (!((Object)(object)player == (Object)null) && !((Object)(object)player.modifiers == (Object)null) && modifiers != null)
		{
			player.modifiers.Add(modifiers, effectScale, durationScale);
		}
	}

	protected override bool IsCompatible(Modifier.ModifierType modType)
	{
		if ((uint)(modType - 20) <= 1u)
		{
			return false;
		}
		return true;
	}

	public override void ServerUpdate(BaseCombatEntity ownerEntity)
	{
		base.ServerUpdate(ownerEntity);
		SendChangesToClient();
	}

	public PlayerModifiers Save(bool forDisk)
	{
		PlayerModifiers val = Pool.Get<PlayerModifiers>();
		val.modifiers = Pool.Get<List<Modifier>>();
		float value = GetValue(Modifier.ModifierType.DigestionBoost, 1f);
		foreach (Modifier item in All)
		{
			if (item != null && (!forDisk || item.Source != Modifier.ModifierSource.Interaction))
			{
				Modifier val2 = item.Save();
				if (!forDisk && value > 1f && IsModifierCompatibleWithDigestionBoost(item.Type))
				{
					val2.duration *= value - 1f;
					val2.timeRemaining *= (double)(value - 1f);
					val2.value *= value;
				}
				val.modifiers.Add(val2);
			}
		}
		return val;
	}

	public void Load(PlayerModifiers m, bool fromDisk)
	{
		RemoveAll();
		if (m == null || m.modifiers == null)
		{
			return;
		}
		foreach (Modifier modifier2 in m.modifiers)
		{
			if (modifier2 != null && (!fromDisk || modifier2.source != 2))
			{
				Modifier modifier = new Modifier();
				modifier.Init((Modifier.ModifierType)modifier2.type, (Modifier.ModifierSource)modifier2.source, modifier2.value, modifier2.duration, modifier2.timeRemaining);
				Add(modifier);
			}
		}
	}

	protected override int GetMaxModifierCount(Modifier modifier)
	{
		return GetModifierLimitForSourceAndType(modifier)?.MaxApplications ?? base.GetMaxModifierCount(modifier);
	}

	protected override float GetClampedValue(Modifier modifier, float value)
	{
		ModifierLimits modifierLimitsForType = GetModifierLimitsForType(modifier);
		if (modifierLimitsForType != null)
		{
			return Mathf.Clamp(value, modifierLimitsForType.minValue, modifierLimitsForType.maxValue);
		}
		return value;
	}

	protected ModifierLimit GetModifierLimitForSourceAndType(Modifier modifier)
	{
		if (Limits != null)
		{
			foreach (ModifierLimits limit in Limits)
			{
				if (limit == null || limit.type != modifier.Type)
				{
					continue;
				}
				foreach (ModifierLimit limit2 in limit.limits)
				{
					if (limit2 != null && limit2.source == modifier.Source)
					{
						return limit2;
					}
				}
			}
		}
		return null;
	}

	protected ModifierLimits GetModifierLimitsForType(Modifier modifier)
	{
		if (Limits != null)
		{
			foreach (ModifierLimits limit in Limits)
			{
				if (limit != null && limit.type == modifier.Type)
				{
					return limit;
				}
			}
		}
		return null;
	}

	public void SendChangesToClient()
	{
		if (!dirty)
		{
			return;
		}
		SetDirty(flag: false);
		PlayerModifiers val = Save(forDisk: false);
		try
		{
			base.baseEntity.ClientRPC(RpcTarget.Player("UpdateModifiers", base.baseEntity), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UI;

public class PowerCounter : IOEntity
{
	public int counterNumber;

	public int targetCounterNumber = 10;

	public Canvas canvas;

	public CanvasGroup screenAlpha;

	public Text screenText;

	public const Flags Flag_ShowPassthrough = Flags.Reserved2;

	public GameObjectRef counterConfigPanel;

	public Color passthroughColor;

	public Color counterColor;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PowerCounter.OnRpcMessage", 0);
		try
		{
			if (rpc == 3554226761u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_SetTarget "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_SetTarget", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3554226761u, "SERVER_SetTarget", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_SetTarget(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_SetTarget");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3222475159u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ToggleDisplayMode "));
				}
				TimeWarning val2 = TimeWarning.New("ToggleDisplayMode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3222475159u, "ToggleDisplayMode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ToggleDisplayMode(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ToggleDisplayMode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool DisplayPassthrough()
	{
		return HasFlag(Flags.Reserved2);
	}

	public bool DisplayCounter()
	{
		return !DisplayPassthrough();
	}

	public bool CanPlayerAdmin(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			return player.CanBuild();
		}
		return false;
	}

	public int GetTarget()
	{
		return targetCounterNumber;
	}

	public override void ResetState()
	{
		base.ResetState();
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_SetTarget(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (Interface.CallHook("OnCounterTargetChange", (object)this, (object)msg.player, (object)num) == null && CanPlayerAdmin(msg.player))
		{
			targetCounterNumber = num;
			MarkDirty();
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ToggleDisplayMode(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnCounterModeToggle", (object)this, (object)msg.player, (object)flag) == null && msg.player.CanBuild())
		{
			SetFlag(Flags.Reserved2, flag, recursive: false, networkupdate: false);
			MarkDirty();
			SendNetworkUpdate();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (DisplayPassthrough())
		{
			return GetCurrentEnergy();
		}
		if (counterNumber >= targetCounterNumber)
		{
			return base.GetPassthroughAmount(outputSlot);
		}
		return 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		if (inputIndex != 0)
		{
			return false;
		}
		if (DisplayPassthrough())
		{
			return true;
		}
		return counterNumber >= targetCounterNumber;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.ioEntity == null)
		{
			info.msg.ioEntity = Pool.Get<IOEntity>();
		}
		info.msg.ioEntity.genericInt1 = counterNumber;
		info.msg.ioEntity.genericInt2 = GetPassthroughAmount();
		info.msg.ioEntity.genericInt3 = GetTarget();
	}

	public void SetCounterNumber(int newNumber)
	{
		counterNumber = newNumber;
	}

	public override void SendIONetworkUpdate()
	{
		SendNetworkUpdate();
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (DisplayCounter() && inputAmount > 0 && inputSlot != 0)
		{
			int num = counterNumber;
			switch (inputSlot)
			{
			case 1:
				counterNumber++;
				break;
			case 2:
				counterNumber--;
				if (counterNumber < 0)
				{
					counterNumber = 0;
				}
				break;
			case 3:
				counterNumber = 0;
				break;
			}
			counterNumber = Mathf.Clamp(counterNumber, 0, 999);
			if (num != counterNumber)
			{
				MarkDirty();
				SendNetworkUpdate();
			}
		}
		if (inputSlot == 0)
		{
			base.UpdateFromInput(inputAmount, inputSlot);
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			if (base.isServer)
			{
				counterNumber = info.msg.ioEntity.genericInt1;
			}
			targetCounterNumber = info.msg.ioEntity.genericInt3;
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class PoweredRemoteControlEntity : IOEntity, IRemoteControllable, IAdminUpdatableIdentifier
{
	public string rcIdentifier = "";

	public Transform viewEyes;

	public GameObjectRef IDPanelPrefab;

	public RemoteControllableControls rcControls;

	public bool isStatic;

	public bool appendEntityIDToIdentifier;

	public virtual bool RequiresMouse => false;

	public virtual float MaxRange => 10000f;

	public RemoteControllableControls RequiredControls => rcControls;

	public bool CanPing => EntityCanPing;

	protected virtual bool EntityCanPing => false;

	public virtual bool CanAcceptInput => false;

	public int ViewerCount { get; set; }

	public CameraViewerId? ControllingViewerId { get; set; }

	public bool IsBeingControlled
	{
		get
		{
			if (ViewerCount > 0)
			{
				return ControllingViewerId.HasValue;
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PoweredRemoteControlEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 2025588587 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AdminUpdateIdentifier "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AdminUpdateIdentifier", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2025588587u, "Server_AdminUpdateIdentifier", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_AdminUpdateIdentifier(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_AdminUpdateIdentifier");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1677685895 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestOpenRCPanel "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestOpenRCPanel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_RequestOpenRCPanel(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_RequestOpenRCPanel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1053317251 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetID "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetID", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1053317251u, "Server_SetID", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							Server_SetID(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in Server_SetID");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsStatic()
	{
		return isStatic;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		UpdateRCAccess(IsPowered());
	}

	public void UpdateRCAccess(bool isOnline)
	{
		if (isOnline)
		{
			RemoteControlEntity.InstallControllable(this);
		}
		else
		{
			RemoteControlEntity.RemoveControllable(this);
		}
	}

	public override void Spawn()
	{
		base.Spawn();
		string text = "#ID";
		if (IsStatic() && rcIdentifier.Contains(text))
		{
			int length = rcIdentifier.IndexOf(text);
			_ = text.Length;
			string text2 = rcIdentifier.Substring(0, length);
			text2 += ((object)(NetworkableId)(ref net.ID)/*cast due to .constrained prefix*/).ToString();
			UpdateIdentifier(text2);
		}
	}

	public virtual bool InitializeControl(CameraViewerId viewerID)
	{
		ViewerCount++;
		if (CanAcceptInput && !ControllingViewerId.HasValue)
		{
			ControllingViewerId = viewerID;
			return true;
		}
		return !CanAcceptInput;
	}

	public virtual void StopControl(CameraViewerId viewerID)
	{
		ViewerCount--;
		if (ControllingViewerId == viewerID)
		{
			ControllingViewerId = null;
		}
	}

	public virtual void UserInput(InputState inputState, CameraViewerId viewerID)
	{
	}

	public Transform GetEyes()
	{
		return viewEyes;
	}

	public virtual float GetFovScale()
	{
		return 1f;
	}

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", (object)this, (object)playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsPowered())
		{
			return IsStatic();
		}
		return true;
	}

	public BaseEntity GetEnt()
	{
		return this;
	}

	public virtual void RCSetup()
	{
	}

	public virtual void RCShutdown()
	{
		if (base.isServer)
		{
			RemoteControlEntity.RemoveControllable(this);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void Server_SetID(RPCMessage msg)
	{
		string oldID = msg.read.String(256, false);
		string newID = msg.read.String(256, false);
		SetID(msg.player, oldID, newID);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void Server_AdminUpdateIdentifier(RPCMessage msg)
	{
		if (!((Object)(object)msg.player == (Object)null) && (msg.player.IsAdmin || msg.player.IsDeveloper))
		{
			string oldID = msg.read.String(256, false);
			string newID = msg.read.String(256, false);
			SetID(msg.player, oldID, newID, bypassChecks: true);
		}
	}

	public void SetID(BasePlayer player, string oldID, string newID, bool bypassChecks = false)
	{
		if ((!IsStatic() || bypassChecks) && (CanChangeID(player) || bypassChecks) && (string.IsNullOrEmpty(oldID) || ComputerStation.IsValidIdentifier(oldID)) && ComputerStation.IsValidIdentifier(newID) && oldID == GetIdentifier())
		{
			UpdateIdentifier(newID);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SERVER_RequestOpenRCPanel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanChangeID(player))
		{
			ClientRPC(RpcTarget.Player("CLIENT_OpenRCPanel", player), GetIdentifier());
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk || IsStatic())
		{
			info.msg.rcEntity = Pool.Get<RCEntity>();
			info.msg.rcEntity.identifier = GetIdentifier();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.rcEntity != null && ComputerStation.IsValidIdentifier(info.msg.rcEntity.identifier))
		{
			UpdateIdentifier(info.msg.rcEntity.identifier);
		}
	}

	public void UpdateIdentifier(string newID, bool clientSend = false)
	{
		if (Interface.CallHook("OnRemoteIdentifierUpdate", (object)this, (object)newID) != null)
		{
			return;
		}
		_ = rcIdentifier;
		if (base.isServer)
		{
			if (!RemoteControlEntity.IDInUse(newID))
			{
				rcIdentifier = newID;
			}
			if (!Application.isLoadingSave)
			{
				SendNetworkUpdate();
			}
		}
	}

	public string GetIdentifier()
	{
		return rcIdentifier;
	}

	public override void InitShared()
	{
		base.InitShared();
		RCSetup();
	}

	public override void DestroyShared()
	{
		RCShutdown();
		base.DestroyShared();
	}

	public bool CanChangeID(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			if (player.CanBuild())
			{
				return player.IsBuildingAuthed();
			}
			return false;
		}
		return false;
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class PressButton : IOEntity
{
	public float pressDuration = 5f;

	public float pressPowerTime = 0.5f;

	public int pressPowerAmount = 2;

	public const Flags Flag_EmittingPower = Flags.Reserved3;

	public bool smallBurst;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("PressButton.OnRpcMessage", 0);
		try
		{
			if (rpc == 4188121069u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Press "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Press", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4188121069u, "RPC_Press", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Press(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Press");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void ResetIOState()
	{
		base.ResetIOState();
		SetFlag(Flags.On, b: false);
		SetFlag(Flags.Reserved3, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)Unpress);
		((FacepunchBehaviour)this).CancelInvoke((Action)UnpowerTime);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (IsOn())
		{
			if ((Object)(object)sourceItem != (Object)null || smallBurst)
			{
				if (HasFlag(Flags.Reserved3))
				{
					return Mathf.Max(pressPowerAmount, base.GetPassthroughAmount());
				}
				return 0;
			}
			return base.GetPassthroughAmount();
		}
		return 0;
	}

	public void UnpowerTime()
	{
		SetFlag(Flags.Reserved3, b: false);
		MarkDirty();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.On, b: false);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Press(RPCMessage msg)
	{
		if (Interface.CallHook("OnButtonPress", (object)this, (object)msg.player) == null)
		{
			Press();
		}
	}

	public void Press()
	{
		if (!IsOn())
		{
			SetFlag(Flags.On, b: true);
			((FacepunchBehaviour)this).Invoke((Action)UnpowerTime, pressPowerTime);
			SetFlag(Flags.Reserved3, b: true);
			SendNetworkUpdateImmediate();
			MarkDirty();
			((FacepunchBehaviour)this).Invoke((Action)Unpress, pressDuration);
		}
	}

	public void Unpress()
	{
		SetFlag(Flags.On, b: false);
		MarkDirty();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity.genericFloat1 = pressDuration;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			pressDuration = info.msg.ioEntity.genericFloat1;
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class ProceduralLift : BaseEntity
{
	public float movementSpeed = 1f;

	public float resetDelay = 5f;

	public ProceduralLiftCabin cabin;

	public ProceduralLiftStop[] stops;

	public GameObjectRef triggerPrefab;

	public string triggerBone;

	private int floorIndex = -1;

	public SoundDefinition startSoundDef;

	public SoundDefinition stopSoundDef;

	public SoundDefinition movementLoopSoundDef;

	private Sound movementLoopSound;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ProceduralLift.OnRpcMessage", 0);
		try
		{
			if (rpc == 2657791441u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_UseLift "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_UseLift", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2657791441u, "RPC_UseLift", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_UseLift(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_UseLift");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Spawn()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(triggerPrefab.resourcePath, Vector3.zero, Quaternion.identity);
			baseEntity.Spawn();
			baseEntity.SetParent(this, triggerBone);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_UseLift(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && Interface.CallHook("OnLiftUse", (object)this, (object)rpc.player) == null && !IsBusy())
		{
			MoveToFloor((floorIndex + 1) % stops.Length);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SnapToFloor(0);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.lift = Pool.Get<Lift>();
		info.msg.lift.floor = floorIndex;
	}

	public override void Load(LoadInfo info)
	{
		if (info.msg.lift != null)
		{
			if (floorIndex == -1)
			{
				SnapToFloor(info.msg.lift.floor);
			}
			else
			{
				MoveToFloor(info.msg.lift.floor);
			}
		}
		base.Load(info);
	}

	private void ResetLift()
	{
		MoveToFloor(0);
	}

	private void MoveToFloor(int floor)
	{
		floorIndex = Mathf.Clamp(floor, 0, stops.Length - 1);
		if (base.isServer)
		{
			SetFlag(Flags.Busy, b: true);
			SendNetworkUpdateImmediate();
			((FacepunchBehaviour)this).CancelInvoke((Action)ResetLift);
		}
	}

	private void SnapToFloor(int floor)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		floorIndex = Mathf.Clamp(floor, 0, stops.Length - 1);
		ProceduralLiftStop proceduralLiftStop = stops[floorIndex];
		((Component)cabin).transform.position = ((Component)proceduralLiftStop).transform.position;
		if (base.isServer)
		{
			SetFlag(Flags.Busy, b: false);
			SendNetworkUpdateImmediate();
			((FacepunchBehaviour)this).CancelInvoke((Action)ResetLift);
		}
	}

	private void OnFinishedMoving()
	{
		if (base.isServer)
		{
			SetFlag(Flags.Busy, b: false);
			SendNetworkUpdateImmediate();
			if (floorIndex != 0)
			{
				((FacepunchBehaviour)this).Invoke((Action)ResetLift, resetDelay);
			}
		}
	}

	protected void Update()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (floorIndex < 0 || floorIndex > stops.Length - 1)
		{
			return;
		}
		ProceduralLiftStop proceduralLiftStop = stops[floorIndex];
		if (!(((Component)cabin).transform.position == ((Component)proceduralLiftStop).transform.position))
		{
			((Component)cabin).transform.position = Vector3.MoveTowards(((Component)cabin).transform.position, ((Component)proceduralLiftStop).transform.position, movementSpeed * Time.deltaTime);
			if (((Component)cabin).transform.position == ((Component)proceduralLiftStop).transform.position)
			{
				OnFinishedMoving();
			}
		}
	}

	public void StartMovementSounds()
	{
	}

	public void StopMovementSounds()
	{
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ProjectileWeaponMod : BaseEntity
{
	public enum SilencerType
	{
		Military,
		OilFilter,
		SodaCan
	}

	[Serializable]
	public struct Modifier
	{
		public bool enabled;

		[Tooltip("1 means no change. 0.5 is half.")]
		public float scalar;

		[Tooltip("Added after the scalar is applied.")]
		public float offset;
	}

	public float ConditionLossMultiplier = 1f;

	[Header("AttackEffectAdditive")]
	public GameObjectRef additiveEffect;

	[Header("Silencer")]
	public GameObjectRef defaultSilencerEffect;

	public bool isSilencer;

	public SilencerType silencerType;

	private static TimeSince lastADSTime;

	private static TimeSince lastToastTime;

	public static Phrase ToggleZoomToastPhrase = new Phrase("toast.toggle_zoom", "Press [PageUp] and [PageDown] to toggle scope zoom level");

	[Header("Weapon Basics")]
	public Modifier repeatDelay;

	public Modifier projectileVelocity;

	public Modifier projectileDamage;

	public Modifier projectileDistance;

	[Header("Recoil")]
	public Modifier aimsway;

	public Modifier aimswaySpeed;

	public Modifier recoil;

	[Header("Aim Cone")]
	public Modifier sightAimCone;

	public Modifier hipAimCone;

	[Header("Light Effects")]
	public bool isLight;

	[Header("MuzzleBrake")]
	public bool isMuzzleBrake;

	[Header("MuzzleBoost")]
	public bool isMuzzleBoost;

	[Header("Scope")]
	public bool isScope;

	public float zoomAmountDisplayOnly;

	[Header("Magazine")]
	public Modifier magazineCapacity;

	[Header("Toggling")]
	public bool needsOnForEffects;

	[Header("Burst")]
	public int burstCount = -1;

	public float timeBetweenBursts;

	[Header("Zoom")]
	public float[] zoomLevels;

	public GameObjectRef fovChangeEffect;

	[Header("Targeting")]
	public bool allowPings;

	private int serverZoomLevel;

	private bool hasZoomBeenInit;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ProjectileWeaponMod.OnRpcMessage", 0);
		try
		{
			if (rpc == 3713130066u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetZoomLevel "));
				}
				TimeWarning val2 = TimeWarning.New("SetZoomLevel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(3713130066u, "SetZoomLevel", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							int zoomLevel = msg.read.Int32();
							SetZoomLevel(zoomLevel);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetZoomLevel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		SetFlag(Flags.Disabled, b: true);
		base.ServerInit();
	}

	public override void PostServerLoad()
	{
		base.limitNetworking = HasFlag(Flags.Disabled);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.projectileWeaponMod = Pool.Get<GunWeaponMod>();
		info.msg.projectileWeaponMod.zoomLevel = serverZoomLevel;
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void SetZoomLevel(int zoomLevel)
	{
		serverZoomLevel = zoomLevel;
		SendNetworkUpdate();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.projectileWeaponMod != null)
		{
			serverZoomLevel = info.msg.projectileWeaponMod.zoomLevel;
		}
	}

	public static float Mult(BaseEntity parentEnt, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (parentEnt.children == null)
		{
			return def;
		}
		return Mult(parentEnt.children.Cast<ProjectileWeaponMod>(), selector_modifier, selector_value, def, bypassModToggles);
	}

	public static float Mult(IEnumerable<ProjectileWeaponMod> mods, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (mods == null)
		{
			return def;
		}
		return Multiply(GetMods(mods, selector_modifier, selector_value, bypassModToggles));
	}

	private static float Multiply(IEnumerable<float> scalars)
	{
		float num = 1f;
		foreach (float scalar in scalars)
		{
			num *= scalar;
		}
		return num;
	}

	public static float Sum(BaseEntity parentEnt, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (parentEnt.children == null)
		{
			return def;
		}
		return Sum(parentEnt.children.Cast<ProjectileWeaponMod>(), selector_modifier, selector_value, def);
	}

	public static float Sum(IEnumerable<ProjectileWeaponMod> mods, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (mods == null)
		{
			return def;
		}
		IEnumerable<float> mods2 = GetMods(mods, selector_modifier, selector_value, bypassModToggles);
		if (mods2.Count() != 0)
		{
			return mods2.Sum();
		}
		return def;
	}

	public static float Average(BaseEntity parentEnt, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (parentEnt.children == null)
		{
			return def;
		}
		return Average(parentEnt.children.Cast<ProjectileWeaponMod>(), selector_modifier, selector_value, def);
	}

	public static float Average(IEnumerable<ProjectileWeaponMod> mods, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (mods == null)
		{
			return def;
		}
		IEnumerable<float> mods2 = GetMods(mods, selector_modifier, selector_value, bypassModToggles);
		if (mods2.Count() != 0)
		{
			return mods2.Average();
		}
		return def;
	}

	public static float Max(BaseEntity parentEnt, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (parentEnt.children == null)
		{
			return def;
		}
		return Max(parentEnt.children.Cast<ProjectileWeaponMod>(), selector_modifier, selector_value, def);
	}

	public static float Max(IEnumerable<ProjectileWeaponMod> mods, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (mods == null)
		{
			return def;
		}
		IEnumerable<float> mods2 = GetMods(mods, selector_modifier, selector_value, bypassModToggles);
		if (mods2.Count() != 0)
		{
			return mods2.Max();
		}
		return def;
	}

	public static float Min(BaseEntity parentEnt, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (parentEnt.children == null)
		{
			return def;
		}
		return Min(parentEnt.children.Cast<ProjectileWeaponMod>(), selector_modifier, selector_value, def);
	}

	public static float Min(IEnumerable<ProjectileWeaponMod> mods, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, float def, bool bypassModToggles = false)
	{
		if (mods == null)
		{
			return def;
		}
		IEnumerable<float> mods2 = GetMods(mods, selector_modifier, selector_value, bypassModToggles);
		if (mods2.Count() != 0)
		{
			return mods2.Min();
		}
		return def;
	}

	public static IEnumerable<float> GetMods(BaseEntity parentEnt, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value)
	{
		return GetMods(parentEnt.children.Cast<ProjectileWeaponMod>(), selector_modifier, selector_value);
	}

	public static IEnumerable<float> GetMods(IEnumerable<ProjectileWeaponMod> mods, Func<ProjectileWeaponMod, Modifier> selector_modifier, Func<Modifier, float> selector_value, bool bypassModToggles = false)
	{
		return (from x in mods.Where((ProjectileWeaponMod x) => (Object)(object)x != (Object)null && (!x.needsOnForEffects || bypassModToggles || x.HasFlag(Flags.On))).Select(selector_modifier)
			where x.enabled
			select x).Select(selector_value);
	}

	public static bool HasBrokenWeaponMod(BaseEntity parentEnt)
	{
		if (parentEnt.children == null)
		{
			return false;
		}
		foreach (BaseEntity child in parentEnt.children)
		{
			if (((Object)(object)child).Is<ProjectileWeaponMod>(out ProjectileWeaponMod castedUnityObject) && castedUnityObject.IsBroken())
			{
				return true;
			}
		}
		return false;
	}
}


public enum SilencerType
{
	Military,
	OilFilter,
	SodaCan
}


using System;
using UnityEngine;

[Serializable]
public struct Modifier
{
	public bool enabled;

	[Tooltip("1 means no change. 0.5 is half.")]
	public float scalar;

	[Tooltip("Added after the scalar is applied.")]
	public float offset;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Utility;
using Network;
using ProtoBuf;
using UnityEngine;

public class Ragdoll : EntityComponent<BaseEntity>, IPrefabPreProcess
{
	[Tooltip("If true, ragdoll physics are simulated on the server instead of the client")]
	[Header("Ragdoll")]
	public bool simOnServer;

	public float lerpToServerSimTime = 0.5f;

	public Transform eyeTransform;

	public Rigidbody primaryBody;

	[ReadOnly]
	public SpringJoint corpseJoint;

	[SerializeField]
	private PhysicMaterial physicMaterial;

	[SerializeField]
	private Skeleton skeleton;

	[SerializeField]
	private Model model;

	[ReadOnly]
	public List<Rigidbody> rigidbodies = new List<Rigidbody>();

	[SerializeField]
	[ReadOnly]
	private List<Transform> rbTransforms = new List<Transform>();

	[ReadOnly]
	[SerializeField]
	private List<Joint> joints = new List<Joint>();

	[SerializeField]
	[ReadOnly]
	private List<CharacterJoint> characterJoints = new List<CharacterJoint>();

	[ReadOnly]
	[SerializeField]
	private List<ConfigurableJoint> configurableJoints = new List<ConfigurableJoint>();

	[ReadOnly]
	[SerializeField]
	private List<Collider> colliders = new List<Collider>();

	[ReadOnly]
	[SerializeField]
	private int[] boneIndex;

	[ReadOnly]
	[SerializeField]
	private Vector3[] genericBonePos;

	[SerializeField]
	[ReadOnly]
	private Quaternion[] genericBoneRot;

	[SerializeField]
	private GameObject GibEffect;

	protected bool isSetUp;

	private const float MAX_JOINT_DIST = 2f;

	private bool wasSyncingJoints = true;

	protected bool IsClient => false;

	protected bool isServer => !IsClient;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public bool IsSleeping => !rigidbodies[0].IsSleeping();

	public bool IsKinematic => rigidbodies[0].isKinematic;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Ragdoll.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private void SetUpPhysics(bool isServer)
	{
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		if (isSetUp)
		{
			return;
		}
		isSetUp = true;
		if (isServer != simOnServer)
		{
			return;
		}
		foreach (Joint joint in joints)
		{
			joint.enablePreprocessing = false;
		}
		foreach (CharacterJoint characterJoint in characterJoints)
		{
			characterJoint.enableProjection = true;
		}
		foreach (ConfigurableJoint configurableJoint in configurableJoints)
		{
			configurableJoint.projectionMode = (JointProjectionMode)1;
		}
		SetInterpolationMode(((Component)this).transform.parent, isServer);
		foreach (Rigidbody rigidbody in rigidbodies)
		{
			SetCollisionMode(rigidbody, isServer);
			rigidbody.excludeLayers = LayerMask.op_Implicit(LayerMask.op_Implicit(rigidbody.excludeLayers) | 0x1200);
			rigidbody.angularDrag = 1f;
			rigidbody.drag = 1f;
			rigidbody.detectCollisions = true;
			if (isServer)
			{
				rigidbody.solverIterations = 40;
			}
			else
			{
				rigidbody.solverIterations = 20;
			}
			rigidbody.solverVelocityIterations = 10;
			rigidbody.maxDepenetrationVelocity = 2f;
			rigidbody.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
			if (rigidbody.mass < 1f)
			{
				rigidbody.mass = 1f;
			}
			Vector3 val = rigidbody.velocity;
			if (((Vector3)(ref val)).sqrMagnitude < 0.25f)
			{
				rigidbody.velocity += Random.onUnitSphere * 2.5f;
			}
			val = rigidbody.angularVelocity;
			if (((Vector3)(ref val)).sqrMagnitude < 0.25f)
			{
				rigidbody.angularVelocity += Random.onUnitSphere * 2.5f;
			}
		}
	}

	public void ParentChanging(BaseCorpse corpse, Transform newParent)
	{
		SetInterpolationMode(newParent, corpse.isServer);
	}

	private void SetInterpolationMode(Transform parent, bool isServer)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (isServer != simOnServer)
		{
			return;
		}
		RigidbodyInterpolation interpolation = (simOnServer ? ((RigidbodyInterpolation)0) : (((Object)(object)parent == (Object)null) ? ((RigidbodyInterpolation)1) : ((!AnyParentMoves(parent)) ? ((RigidbodyInterpolation)1) : ((RigidbodyInterpolation)0))));
		foreach (Rigidbody rigidbody in rigidbodies)
		{
			rigidbody.interpolation = interpolation;
		}
	}

	private bool AnyParentMoves(Transform parent)
	{
		while ((Object)(object)parent != (Object)null)
		{
			BaseEntity component = ((Component)parent).GetComponent<BaseEntity>();
			if ((Object)(object)component != (Object)null && component.syncPosition)
			{
				return true;
			}
			parent = parent.parent;
		}
		return false;
	}

	private static void SetCollisionMode(Rigidbody rigidBody, bool isServer)
	{
		int serverragdollmode = Physics.serverragdollmode;
		if (serverragdollmode <= 0)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)0;
		}
		if (serverragdollmode == 1)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)1;
		}
		if (serverragdollmode == 2)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)2;
		}
		if (serverragdollmode >= 3)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)3;
		}
	}

	public void MoveRigidbodiesToRoot()
	{
		foreach (Transform rbTransform in rbTransforms)
		{
			rbTransform.SetParent(((Component)this).transform, true);
		}
	}

	public override void LoadComponent(BaseNetworkable.LoadInfo info)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		if (simOnServer && info.msg.ragdoll != null && isServer)
		{
			for (int i = 0; i < rbTransforms.Count; i++)
			{
				rbTransforms[i].localPosition = Compression.UnpackVector3FromInt(info.msg.ragdoll.positions[i], -2f, 2f);
				rbTransforms[i].localEulerAngles = Compression.UnpackVector3FromInt(info.msg.ragdoll.rotations[i], -360f, 360f);
			}
		}
	}

	public void CopyTo(Skeleton to)
	{
		skeleton.CopyTo(to);
	}

	public void GetCurrentBoneState(GameObject[] bones, ref Vector3[] bonePos, ref Quaternion[] boneRot)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		int num = bones.Length;
		bonePos = (Vector3[])(object)new Vector3[num];
		boneRot = (Quaternion[])(object)new Quaternion[num];
		for (int i = 0; i < num; i++)
		{
			if ((Object)(object)bones[i] != (Object)null)
			{
				Transform transform = bones[i].transform;
				bonePos[i] = transform.localPosition;
				boneRot[i] = transform.localRotation;
			}
		}
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		joints.Clear();
		rbTransforms.Clear();
		characterJoints.Clear();
		configurableJoints.Clear();
		rigidbodies.Clear();
		colliders.Clear();
		((Component)this).GetComponentsInChildren<Rigidbody>(true, rigidbodies);
		for (int i = 0; i < rigidbodies.Count; i++)
		{
			if (!((Object)(object)((Component)rigidbodies[i]).transform == (Object)(object)((Component)this).transform))
			{
				rbTransforms.Add(((Component)rigidbodies[i]).transform);
			}
		}
		((Component)this).GetComponentsInChildren<Joint>(true, joints);
		((Component)this).GetComponentsInChildren<CharacterJoint>(true, characterJoints);
		((Component)this).GetComponentsInChildren<ConfigurableJoint>(true, configurableJoints);
		((Component)this).GetComponentsInChildren<Collider>(true, colliders);
		rbTransforms.Sort((Transform t1, Transform t2) => TransformEx.GetDepth(t1).CompareTo(TransformEx.GetDepth(t2)));
		if (skeleton.Bones != null && skeleton.Bones.Length != 0)
		{
			GetCurrentBoneState(skeleton.Bones, ref genericBonePos, ref genericBoneRot);
			int num = skeleton.Bones.Length;
			boneIndex = new int[num];
			for (int j = 0; j < num; j++)
			{
				boneIndex[j] = -1;
				GameObject val = skeleton.Bones[j];
				for (int k = 0; k < rbTransforms.Count; k++)
				{
					if ((Object)(object)((Component)rbTransforms[k]).gameObject == (Object)(object)val)
					{
						boneIndex[j] = k;
						break;
					}
				}
			}
		}
		if (!clientside || !simOnServer)
		{
			return;
		}
		foreach (Joint joint in joints)
		{
			Object.DestroyImmediate((Object)(object)joint, true);
		}
		foreach (Rigidbody rigidbody in rigidbodies)
		{
			Object.DestroyImmediate((Object)(object)rigidbody, true);
		}
	}

	private void RemoveRootBoneOffset()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (simOnServer)
		{
			Transform rootBone = model.rootBone;
			if ((Object)(object)rootBone != (Object)null && !((Component)(object)rootBone).HasComponent<Rigidbody>())
			{
				((Component)this).transform.position = rootBone.position;
				((Component)this).transform.rotation = rootBone.rotation;
				rootBone.localPosition = Vector3.zero;
				rootBone.localRotation = Quaternion.identity;
			}
		}
	}

	public virtual void ServerInit()
	{
		if (simOnServer)
		{
			RemoveRootBoneOffset();
			((FacepunchBehaviour)this).InvokeRepeating((Action)SyncJointsToClients, 0f, 0.1f);
		}
		else
		{
			MoveRigidbodiesToRoot();
		}
		SetUpPhysics(isServer: true);
	}

	public override void SaveComponent(BaseNetworkable.SaveInfo info)
	{
		if (simOnServer)
		{
			info.msg.ragdoll = Pool.Get<Ragdoll>();
			SetRagdollMessageVals(info.msg.ragdoll);
		}
	}

	public bool IsFullySleeping()
	{
		foreach (Rigidbody rigidbody in rigidbodies)
		{
			if (!rigidbody.IsSleeping())
			{
				return false;
			}
		}
		return true;
	}

	private void SyncJointsToClients()
	{
		if (!ShouldSyncJoints())
		{
			return;
		}
		Ragdoll val = Pool.Get<Ragdoll>();
		try
		{
			SetRagdollMessageVals(val);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("RPCSyncJoints"), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool ShouldSyncJoints()
	{
		bool result = false;
		if (wasSyncingJoints)
		{
			if (!IsFullySleeping())
			{
				result = true;
			}
		}
		else
		{
			result = !primaryBody.IsSleeping();
		}
		wasSyncingJoints = result;
		return result;
	}

	private void SetRagdollMessageVals(Ragdoll ragdollMsg)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		List<int> list = Pool.Get<List<int>>();
		List<int> list2 = Pool.Get<List<int>>();
		foreach (Transform rbTransform in rbTransforms)
		{
			int item = Compression.PackVector3ToInt(rbTransform.localPosition, -2f, 2f);
			int item2 = Compression.PackVector3ToInt(rbTransform.localEulerAngles, -360f, 360f);
			list.Add(item);
			list2.Add(item2);
		}
		ragdollMsg.time = base.baseEntity.GetNetworkTime();
		ragdollMsg.positions = list;
		ragdollMsg.rotations = list2;
	}

	public void BecomeActive()
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		if (!IsKinematic)
		{
			return;
		}
		foreach (Rigidbody rigidbody in rigidbodies)
		{
			rigidbody.isKinematic = false;
			SetCollisionMode(rigidbody, isServer);
			rigidbody.WakeUp();
			if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity.HasParent())
			{
				Rigidbody component = ((Component)base.baseEntity.GetParentEntity()).GetComponent<Rigidbody>();
				if ((Object)(object)component != (Object)null)
				{
					rigidbody.velocity = component.velocity;
					rigidbody.angularVelocity = component.angularVelocity;
				}
			}
			foreach (Collider collider in colliders)
			{
				((Component)collider).gameObject.layer = 9;
			}
		}
	}

	public void BecomeInactive()
	{
		if (IsKinematic)
		{
			return;
		}
		foreach (Rigidbody rigidbody in rigidbodies)
		{
			rigidbody.collisionDetectionMode = (CollisionDetectionMode)0;
			rigidbody.isKinematic = true;
		}
		foreach (Collider collider in colliders)
		{
			((Component)collider).gameObject.layer = 19;
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class ReactiveTarget : Signage
{
	[Header("Reactive Target")]
	public Animator myAnimator;

	public GameObjectRef bullseyeEffect;

	public GameObjectRef knockdownEffect;

	public float activationPowerTime = 0.5f;

	public int activationPowerAmount = 1;

	public string mainBoneCollider = "target_collider";

	public string bullseyeBoneCollider = "target_collider_bullseye";

	public bool isPaintableTarget;

	public Transform movableColliderRoot;

	public Vector3 movableColliderKnockedDownAngle = new Vector3(-55f, 0f, 0f);

	public GameObject movablePlayerForceTrigger;

	private float lastToggleTime = float.NegativeInfinity;

	public const Flags Flag_KnockedDown = Flags.Reserved1;

	public float knockdownHealth = 100f;

	private int inputAmountReset;

	private int inputAmountLower;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ReactiveTarget.OnRpcMessage", 0);
		try
		{
			if (rpc == 1798082523 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Lower "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Lower", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_Lower(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_Lower");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2169477377u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Reset "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Reset", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						RPC_Reset(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in RPC_Reset");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool CanUpdateSign(BasePlayer player)
	{
		if (!isPaintableTarget)
		{
			return false;
		}
		return base.CanUpdateSign(player);
	}

	public void SetCollidersUpright()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		movableColliderRoot.localEulerAngles = Vector3.zero;
		if ((Object)(object)movablePlayerForceTrigger != (Object)null)
		{
			movablePlayerForceTrigger.SetActive(false);
		}
	}

	public void SetCollidersKnockedDown()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		movableColliderRoot.localEulerAngles = movableColliderKnockedDownAngle;
		if ((Object)(object)movablePlayerForceTrigger != (Object)null)
		{
			movablePlayerForceTrigger.SetActive(true);
		}
	}

	public void OnHitShared(HitInfo info)
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		if (IsKnockedDown() || IsLowered())
		{
			return;
		}
		bool num = info.HitBone == StringPool.Get(mainBoneCollider);
		bool flag = info.HitBone == StringPool.Get(bullseyeBoneCollider);
		if ((num || flag) && base.isServer)
		{
			float num2 = info.damageTypes.Total();
			if (flag)
			{
				num2 *= 2f;
				Effect.server.Run(bullseyeEffect.resourcePath, this, StringPool.Get(bullseyeBoneCollider), Vector3.zero, Vector3.zero);
			}
			knockdownHealth -= num2;
			if (knockdownHealth <= 0f)
			{
				Effect.server.Run(knockdownEffect.resourcePath, this, StringPool.Get(bullseyeBoneCollider), Vector3.zero, Vector3.zero);
				SetFlag(Flags.On, b: false);
				SetFlag(Flags.Reserved1, b: true);
				QueueReset();
				SendPowerBurst();
				SendNetworkUpdate();
			}
			else
			{
				ClientRPC(RpcTarget.NetworkGroup("HitEffect"), info.Initiator.net.ID);
			}
			Hurt(1f, DamageType.Suicide, info.Initiator, useProtection: false);
		}
	}

	public bool IsKnockedDown()
	{
		if (IsLowered())
		{
			return HasFlag(Flags.Reserved1);
		}
		return false;
	}

	public bool IsLowered()
	{
		return !HasFlag(Flags.On);
	}

	public override void OnAttacked(HitInfo info)
	{
		OnHitShared(info);
		base.OnAttacked(info);
	}

	public bool CanToggle()
	{
		float num = 1f;
		num = ((inputAmountReset > 0) ? 0.25f : 1f);
		return Time.time > lastToggleTime + num;
	}

	public bool CanLower()
	{
		if (inputAmountLower <= inputAmountReset)
		{
			return inputAmountReset == 0;
		}
		return true;
	}

	public bool CanReset()
	{
		if (inputAmountReset <= inputAmountLower)
		{
			return inputAmountLower == 0;
		}
		return true;
	}

	public void QueueReset()
	{
		float num = ((inputAmountReset > 0) ? 0.25f : 6f);
		((FacepunchBehaviour)this).Invoke((Action)ResetTarget, num);
	}

	public void ResetTarget()
	{
		if (IsLowered() && CanToggle() && CanReset())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ResetTarget);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved1, b: false);
			knockdownHealth = 100f;
			SendPowerBurst();
			Interface.CallHook("OnReactiveTargetReset", (object)this);
		}
	}

	private void LowerTarget()
	{
		if (!IsKnockedDown() && CanToggle() && CanLower())
		{
			SetFlag(Flags.On, b: false);
			SendPowerBurst();
		}
	}

	private void SendPowerBurst()
	{
		lastToggleTime = Time.time;
		MarkDirtyForceUpdateOutputs();
		((FacepunchBehaviour)this).Invoke((Action)base.MarkDirtyForceUpdateOutputs, activationPowerTime * 1.01f);
	}

	public override int ConsumptionAmount()
	{
		return 1;
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		switch (inputSlot)
		{
		case 0:
			base.UpdateFromInput(inputAmount, inputSlot);
			break;
		case 1:
			inputAmountReset = inputAmount;
			if (inputAmount > 0)
			{
				ResetTarget();
			}
			break;
		case 2:
			inputAmountLower = inputAmount;
			if (inputAmount > 0)
			{
				LowerTarget();
			}
			break;
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (IsLowered())
		{
			if (IsPowered())
			{
				return base.GetPassthroughAmount();
			}
			if (IsKnockedDown() && Time.time < lastToggleTime + activationPowerTime)
			{
				return activationPowerAmount;
			}
		}
		return 0;
	}

	[RPC_Server]
	public void RPC_Reset(RPCMessage msg)
	{
		ResetTarget();
	}

	[RPC_Server]
	public void RPC_Lower(RPCMessage msg)
	{
		LowerTarget();
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!next.HasFlag(Flags.On))
		{
			SetCollidersKnockedDown();
		}
		else
		{
			SetCollidersUpright();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ReclaimTerminal : StorageContainer
{
	public int itemCount;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ReclaimTerminal.OnRpcMessage", 0);
		try
		{
			if (rpc == 2609933020u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReloadLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReloadLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2609933020u, "RPC_ReloadLoot", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2609933020u, "RPC_ReloadLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_ReloadLoot(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_ReloadLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_ReloadLoot(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !((Object)(object)ReclaimManager.instance == (Object)null) && !((Object)(object)player.inventory.loot.entitySource != (Object)(object)this))
		{
			LoadReclaimLoot(player);
		}
	}

	public void LoadReclaimLoot(BasePlayer player)
	{
		if ((Object)(object)ReclaimManager.instance == (Object)null)
		{
			return;
		}
		List<ReclaimManager.PlayerReclaimEntry> list = Pool.Get<List<ReclaimManager.PlayerReclaimEntry>>();
		ReclaimManager.instance.GetReclaim(player.userID);
		itemCount = 0;
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			if (base.inventory.GetSlot(i) != null)
			{
				itemCount++;
			}
		}
		foreach (ReclaimManager.PlayerReclaimEntry item2 in list)
		{
			for (int num = item2.mainInventory.itemList.Count - 1; num >= 0; num--)
			{
				Item item = item2.mainInventory.itemList[num];
				itemCount++;
				item.MoveToContainer(base.inventory);
			}
		}
		Pool.Free<ReclaimManager.PlayerReclaimEntry>(ref list, false);
		SendNetworkUpdate();
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if ((Object)(object)ReclaimManager.instance == (Object)null)
		{
			return false;
		}
		LoadReclaimLoot(player);
		return base.PlayerOpenLoot(player, panelToOpen, doPositionChecks);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		if (!((Object)(object)ReclaimManager.instance == (Object)null))
		{
			if (base.inventory.itemList.Count > 0)
			{
				ReclaimManager.instance.AddPlayerReclaim(player.userID, null, null, base.inventory.itemList, null);
			}
			base.PlayerStoppedLooting(player);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.reclaimTerminal = Pool.Get<ReclaimTerminal>();
			info.msg.reclaimTerminal.itemCount = itemCount;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!info.fromDisk && info.msg.reclaimTerminal != null)
		{
			itemCount = info.msg.reclaimTerminal.itemCount;
		}
	}
}


using System;
using System.IO;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class RecorderTool : ThrownWeapon, ICassettePlayer
{
	[ClientVar(Saved = true)]
	public static bool debugRecording;

	public AudioSource RecorderAudioSource;

	public SoundDefinition RecordStartSfx;

	public SoundDefinition RewindSfx;

	public SoundDefinition RecordFinishedSfx;

	public SoundDefinition PlayTapeSfx;

	public SoundDefinition StopTapeSfx;

	public float ThrowScale = 3f;

	public Cassette cachedCassette { get; set; }

	public Sprite LoadedCassetteIcon
	{
		get
		{
			if (!((Object)(object)cachedCassette != (Object)null))
			{
				return null;
			}
			return cachedCassette.HudSprite;
		}
	}

	public BaseEntity ToBaseEntity => this;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RecorderTool.OnRpcMessage", 0);
		try
		{
			if (rpc == 4278517885u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - OnCassetteRecordingEnded "));
				}
				TimeWarning val2 = TimeWarning.New("OnCassetteRecordingEnded", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4278517885u, "OnCassetteRecordingEnded", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(4278517885u, "OnCassetteRecordingEnded", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							OnCassetteRecordingEnded(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in OnCassetteRecordingEnded");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3075830603u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_TogglePlaying "));
				}
				TimeWarning val2 = TimeWarning.New("Server_TogglePlaying", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3075830603u, "Server_TogglePlaying", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(3075830603u, "Server_TogglePlaying", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_TogglePlaying(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_TogglePlaying");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private bool HasCassette()
	{
		return (Object)(object)cachedCassette != (Object)null;
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	public void Server_TogglePlaying(RPCMessage msg)
	{
		bool b = ((Stream)(object)msg.read).ReadByte() == 1;
		SetFlag(Flags.On, b);
	}

	public void OnCassetteInserted(Cassette c)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		cachedCassette = c;
		ClientRPC(RpcTarget.NetworkGroup("Client_OnCassetteInserted"), c.net.ID);
	}

	public void OnCassetteRemoved(Cassette c)
	{
		cachedCassette = null;
		ClientRPC(RpcTarget.NetworkGroup("Client_OnCassetteRemoved"));
	}

	protected override void SetUpThrownWeapon(BaseEntity ent, Item ownerItem)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			ent.OwnerID = ownerPlayer.userID;
		}
		if (ent is DeployedRecorder deployedRecorder)
		{
			if ((Object)(object)cachedCassette != (Object)null)
			{
				ownerItem.contents.itemList[0].SetParent(deployedRecorder.inventory);
			}
			deployedRecorder.ItemOwnership = ownerItem.TakeOwnershipShare();
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	public void OnCassetteRecordingEnded(RPCMessage rpc)
	{
		if (GetItem() != null)
		{
			GetItem().contents.itemList[0].SetItemOwnership(rpc.player, ItemOwnershipPhrases.Recorded);
		}
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		if (IsDisabled())
		{
			SetFlag(Flags.On, b: false);
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Recycler : StorageContainer
{
	private static readonly int Param_On = Animator.StringToHash("on");

	public Animator Animator;

	[Tooltip("Depreciated")]
	public float recycleEfficiency = 0.6f;

	public float safezoneRecycleEfficiency = 0.4f;

	public float radtownRecycleEfficiency = 0.6f;

	public SoundDefinition grindingLoopDef;

	public SoundDefinition grindingLoopDef_Slow;

	public GameObjectRef startSound;

	public GameObjectRef stopSound;

	public const Flags SafeZone = Flags.Reserved9;

	public float scrapRemainder;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Recycler.OnRpcMessage", 0);
		try
		{
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SVSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4167839872u, "SVSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SVSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SVSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
	}

	private bool CanBeRecycled(Item item)
	{
		object obj = Interface.CallHook("CanBeRecycled", (object)item, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item != null)
		{
			return (Object)(object)item.info.Blueprint != (Object)null;
		}
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(RecyclerItemFilter));
		UpdateInSafeZone();
	}

	public bool RecyclerItemFilter(Item item, int targetSlot)
	{
		int num = Mathf.CeilToInt((float)base.inventory.capacity * 0.5f);
		if (targetSlot == -1)
		{
			bool flag = false;
			for (int i = 0; i < num; i++)
			{
				if (!base.inventory.SlotTaken(item, i))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return false;
			}
		}
		if (targetSlot < num)
		{
			return CanBeRecycled(item);
		}
		return true;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag == IsOn() || (Object)(object)msg.player == (Object)null || Interface.CallHook("OnRecyclerToggle", (object)this, (object)msg.player) != null || (!flag && onlyOneUser && (Object)(object)msg.player.inventory.loot.entitySource != (Object)(object)this) || (flag && !HasRecyclable()))
		{
			return;
		}
		if (flag)
		{
			foreach (Item item in base.inventory.itemList)
			{
				item.CollectedForCrafting(msg.player);
			}
			StartRecycling();
		}
		else
		{
			StopRecycling();
		}
	}

	public bool MoveItemToOutput(Item newItem)
	{
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		for (int i = 6; i < 12; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot == null)
			{
				num = i;
				break;
			}
			if (slot.CanStack(newItem))
			{
				if (slot.amount + newItem.amount <= slot.MaxStackable())
				{
					num = i;
					break;
				}
				int num2 = Mathf.Min(slot.MaxStackable() - slot.amount, newItem.amount);
				newItem.UseItem(num2);
				slot.amount += num2;
				slot.MarkDirty();
				newItem.MarkDirty();
			}
			if (newItem.amount <= 0)
			{
				return true;
			}
		}
		if (num != -1 && newItem.MoveToContainer(base.inventory, num))
		{
			return true;
		}
		newItem.Drop(((Component)this).transform.position + new Vector3(0f, 2f, 0f), GetInheritedDropVelocity() + ((Component)this).transform.forward * 2f);
		return false;
	}

	public bool HasRecyclable()
	{
		for (int i = 0; i < 6; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				object obj = Interface.CallHook("CanRecycle", (object)this, (object)slot);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if ((Object)(object)slot.info.Blueprint != (Object)null)
				{
					return true;
				}
			}
		}
		return false;
	}

	public void RecycleThink()
	{
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		float num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);
		int num2 = 0;
		while (true)
		{
			if (num2 < 6)
			{
				Item slot = base.inventory.GetSlot(num2);
				if (!CanBeRecycled(slot))
				{
					num2++;
					continue;
				}
				if (Interface.CallHook("OnItemRecycle", (object)slot, (object)this) != null)
				{
					if (!HasRecyclable())
					{
						StopRecycling();
					}
					break;
				}
				if (slot.hasCondition)
				{
					num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
				}
				int num3 = 1;
				if (slot.amount > 1)
				{
					num3 = Mathf.CeilToInt(Mathf.Min((float)slot.amount, (float)slot.MaxStackable() * 0.1f));
				}
				object obj = Interface.CallHook("OnItemRecycleAmount", (object)slot, (object)num3, (object)this);
				if (obj is int)
				{
					num3 = (int)obj;
				}
				if (slot.info.Blueprint.scrapFromRecycle > 0)
				{
					float num4 = slot.info.Blueprint.scrapFromRecycle * num3;
					if (slot.MaxStackable() == 1 && slot.hasCondition)
					{
						num4 *= slot.conditionNormalized;
					}
					float num5 = num / 0.5f;
					num4 *= num5;
					int num6 = Mathf.FloorToInt(num4);
					float num7 = num4 - (float)num6;
					scrapRemainder += num7;
					if (scrapRemainder >= 1f)
					{
						int num8 = Mathf.FloorToInt(scrapRemainder);
						scrapRemainder -= num8;
						num6 += num8;
					}
					if (num6 >= 1)
					{
						Item item = ItemManager.CreateByName("scrap", num6, 0uL);
						if ((Object)(object)base.LastLootedByPlayer != (Object)null)
						{
							item.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);
						}
						Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);
						MoveItemToOutput(item);
					}
				}
				if (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))
				{
					List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
					Vis.Entities(((Component)this).transform.position, 3f, list, 131072, (QueryTriggerInteraction)2);
					foreach (BasePlayer item3 in list)
					{
						if (item3.IsAlive() && !item3.IsSleeping() && (Object)(object)item3.inventory.loot.entitySource == (Object)(object)this)
						{
							item3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);
							item3.stats.Save();
						}
					}
					Pool.FreeUnmanaged<BasePlayer>(ref list);
				}
				Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);
				slot.UseItem(num3);
				foreach (ItemAmount ingredient in slot.info.Blueprint.GetIngredients())
				{
					if (ingredient.itemDef.shortname == "scrap")
					{
						continue;
					}
					float num9 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num3;
					int num10 = Mathf.FloorToInt(num9);
					float num11 = num9 - (float)num10;
					if (num11 > float.Epsilon && Random.Range(0f, 1f) <= num11)
					{
						num10++;
					}
					if (num10 <= 0)
					{
						continue;
					}
					int num12 = Mathf.CeilToInt((float)num10 / (float)ingredient.itemDef.stackable);
					for (int i = 0; i < num12; i++)
					{
						if (ingredient.itemDef.IsAllowed((EraRestriction)16))
						{
							int num13 = ((num10 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num10);
							Item item2 = ItemManager.Create(ingredient.itemDef, num13, 0uL);
							if ((Object)(object)base.LastLootedByPlayer != (Object)null)
							{
								item2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.Recycler);
							}
							Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);
							if (!MoveItemToOutput(item2))
							{
								flag = true;
							}
							num10 -= num13;
							if (num10 <= 0)
							{
								break;
							}
						}
					}
				}
			}
			if (flag || !HasRecyclable())
			{
				StopRecycling();
			}
			break;
		}
	}

	public float GetRecycleThinkDuration()
	{
		if (IsSafezoneRecycler())
		{
			return 8f;
		}
		return 5f;
	}

	public void StartRecycling()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		if (!IsOn())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)RecycleThink, GetRecycleThinkDuration(), GetRecycleThinkDuration());
			Effect.server.Run(startSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdateImmediate();
		}
	}

	public void StopRecycling()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		((FacepunchBehaviour)this).CancelInvoke((Action)RecycleThink);
		if (IsOn())
		{
			Effect.server.Run(stopSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetFlag(Flags.On, b: false);
			SendNetworkUpdateImmediate();
		}
	}

	public void UpdateInSafeZone()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(base.isServer);
		if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.safeZone)
		{
			SetFlag(Flags.Reserved9, b: false);
			return;
		}
		bool b = false;
		List<TriggerBase> list = Pool.Get<List<TriggerBase>>();
		GamePhysics.OverlapSphere<TriggerBase>(((Component)this).transform.position, 1f, list, 262144, (QueryTriggerInteraction)2);
		foreach (TriggerBase item in list)
		{
			if ((Object)(object)item != (Object)null && Object.op_Implicit((Object)(object)((Component)item).GetComponent<TriggerSafeZone>()))
			{
				b = true;
				break;
			}
		}
		if (base.isServer)
		{
			SetFlag(Flags.Reserved9, b);
		}
		Pool.FreeUnmanaged<TriggerBase>(ref list);
	}

	public bool IsSafezoneRecycler()
	{
		return HasFlag(Flags.Reserved9);
	}

	public void PlayAnim()
	{
	}

	public void StopAnim()
	{
	}

	private void ToggleAnim(bool toggle)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Facepunch.Sqlite;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class RelationshipManager : BaseEntity
{
	public enum RelationshipType
	{
		NONE,
		Acquaintance,
		Friend,
		Enemy
	}

	public class PlayerRelationshipInfo : IPooled, IServerFileReceiver, IPlayerInfo
	{
		public string displayName;

		public ulong player;

		public RelationshipType type;

		public int weight;

		public uint mugshotCrc;

		public string notes;

		public float lastSeenTime;

		[NonSerialized]
		public float lastMugshotTime;

		public ulong UserId => player;

		public string UserName => displayName;

		public bool IsOnline => false;

		public bool IsMe => false;

		public bool IsFriend => false;

		public bool IsPlayingThisGame => true;

		public string ServerEndpoint => string.Empty;

		public void EnterPool()
		{
			Reset();
		}

		public void LeavePool()
		{
			Reset();
		}

		private void Reset()
		{
			displayName = null;
			player = 0uL;
			type = RelationshipType.NONE;
			weight = 0;
			mugshotCrc = 0u;
			notes = "";
			lastMugshotTime = 0f;
		}

		public PlayerRelationshipInfo ToProto()
		{
			PlayerRelationshipInfo obj = Pool.Get<PlayerRelationshipInfo>();
			obj.playerID = player;
			obj.type = (int)type;
			obj.weight = weight;
			obj.mugshotCrc = mugshotCrc;
			obj.displayName = displayName;
			obj.notes = notes;
			obj.timeSinceSeen = Time.realtimeSinceStartup - lastSeenTime;
			return obj;
		}

		public static PlayerRelationshipInfo FromProto(PlayerRelationshipInfo proto)
		{
			return new PlayerRelationshipInfo
			{
				type = (RelationshipType)proto.type,
				weight = proto.weight,
				displayName = proto.displayName,
				mugshotCrc = proto.mugshotCrc,
				notes = proto.notes,
				player = proto.playerID,
				lastSeenTime = Time.realtimeSinceStartup - proto.timeSinceSeen
			};
		}
	}

	public class PlayerRelationships : IPooled
	{
		public bool dirty;

		public ulong ownerPlayer;

		public Dictionary<ulong, PlayerRelationshipInfo> relations;

		public bool Forget(ulong player)
		{
			if (relations.TryGetValue(player, out var value))
			{
				relations.Remove(player);
				if (value.mugshotCrc != 0)
				{
					ServerInstance.DeleteMugshot(ownerPlayer, player, value.mugshotCrc);
				}
				Pool.Free<PlayerRelationshipInfo>(ref value);
				return true;
			}
			return false;
		}

		public PlayerRelationshipInfo GetRelations(ulong player)
		{
			BasePlayer basePlayer = FindByID(player);
			if (relations.TryGetValue(player, out var value))
			{
				if ((Object)(object)basePlayer != (Object)null)
				{
					value.displayName = basePlayer.displayName;
				}
				return value;
			}
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			if ((Object)(object)basePlayer != (Object)null)
			{
				playerRelationshipInfo.displayName = basePlayer.displayName;
			}
			playerRelationshipInfo.player = player;
			relations.Add(player, playerRelationshipInfo);
			return playerRelationshipInfo;
		}

		public PlayerRelationships()
		{
			LeavePool();
		}

		public void EnterPool()
		{
			ownerPlayer = 0uL;
			if (relations != null)
			{
				Pool.Free<ulong, PlayerRelationshipInfo>(ref relations, true);
			}
		}

		public void LeavePool()
		{
			ownerPlayer = 0uL;
			relations = Pool.Get<Dictionary<ulong, PlayerRelationshipInfo>>();
		}

		public void ClearRelations()
		{
			foreach (KeyValuePair<ulong, PlayerRelationshipInfo> relation in relations)
			{
				var (_, playerRelationshipInfo2) = (KeyValuePair<ulong, PlayerRelationshipInfo>)(ref relation);
				Pool.Free<PlayerRelationshipInfo>(ref playerRelationshipInfo2);
			}
			relations.Clear();
		}
	}

	public class PlayerTeam : IPooled
	{
		public ulong teamID;

		public string joinKey;

		public string teamName;

		public ulong teamLeader;

		public Vector3 firstSpawnLocation;

		public bool usePartySpawn;

		public List<ulong> members = new List<ulong>();

		public List<ulong> invites = new List<ulong>();

		public float teamStartTime;

		public List<Connection> onlineMemberConnections = new List<Connection>();

		public float teamLifetime => Time.realtimeSinceStartup - teamStartTime;

		public BasePlayer GetLeader()
		{
			return FindByID(teamLeader);
		}

		public void SendInvite(BasePlayer player)
		{
			if (invites.Count > 8)
			{
				invites.RemoveRange(0, 1);
			}
			BasePlayer basePlayer = FindByID(teamLeader);
			if (!((Object)(object)basePlayer == (Object)null))
			{
				ulong item = player.userID.Get();
				if (!invites.Contains(item))
				{
					invites.Add(item);
				}
				player.ClientRPC(RpcTarget.Player("CLIENT_PendingInvite", player), basePlayer.displayName, teamLeader, teamID);
			}
		}

		public void SendInvite(BasePlayer player, ulong id)
		{
			if (invites.Count > 8)
			{
				invites.RemoveRange(0, 1);
			}
			BasePlayer basePlayer = FindByID(teamLeader);
			if (!((Object)(object)basePlayer == (Object)null))
			{
				if (!invites.Contains(id))
				{
					invites.Add(id);
				}
				if ((Object)(object)player != (Object)null)
				{
					player.ClientRPC(RpcTarget.Player("CLIENT_PendingInvite", player), basePlayer.displayName, teamLeader, teamID);
				}
			}
		}

		public void AcceptInvite(BasePlayer player)
		{
			if (invites.Contains(player.userID))
			{
				invites.Remove(player.userID);
				AddPlayer(player);
				player.ClearPendingInvite();
			}
		}

		public void RejectInvite(BasePlayer player)
		{
			player.ClearPendingInvite();
			invites.Remove(player.userID);
		}

		public bool AddPlayer(BasePlayer player, bool skipDirtyUpdate = false)
		{
			if (player.currentTeam != 0L)
			{
				return false;
			}
			if (!AddPlayer(player.userID, skipDirtyUpdate))
			{
				return false;
			}
			player.currentTeam = teamID;
			player.SendNetworkUpdate();
			if (SleepingBag.UseTeamLabels)
			{
				TimeWarning val = TimeWarning.New("RelationshipManager.AddPLayer.TeamLabels", 0);
				try
				{
					SleepingBag.UpdateTeamsBags(members);
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			return true;
		}

		public bool AddPlayer(ulong playerId, bool skipDirtyUpdate = false)
		{
			if (members.Contains(playerId))
			{
				return false;
			}
			if (members.Count >= maxTeamSize)
			{
				return false;
			}
			bool num = members.Count == 0;
			members.Add(playerId);
			ServerInstance.playerToTeam.Add(playerId, this);
			if (!skipDirtyUpdate)
			{
				MarkDirty();
			}
			if (!num)
			{
				Analytics.Azure.OnTeamChanged("added", teamID, teamLeader, playerId, members);
			}
			return true;
		}

		public bool RemovePlayer(ulong playerID)
		{
			if (members.Contains(playerID))
			{
				members.Remove(playerID);
				ServerInstance.playerToTeam.Remove(playerID);
				BasePlayer basePlayer = FindByID(playerID);
				if ((Object)(object)basePlayer != (Object)null)
				{
					basePlayer.ClearTeam();
					basePlayer.BroadcastAppTeamRemoval();
					basePlayer.SendNetworkUpdate();
					if (SleepingBag.UseTeamLabels)
					{
						TimeWarning val = TimeWarning.New("RelationshipManager.RemovePlayer.TeamLabels", 0);
						try
						{
							SleepingBag.UpdateMyBags(basePlayer.userID.Get());
							SleepingBag.UpdateTeamsBags(members);
						}
						finally
						{
							((IDisposable)val)?.Dispose();
						}
					}
				}
				if (teamLeader == playerID)
				{
					if (members.Count > 0)
					{
						SetTeamLeader(members[0]);
						Analytics.Azure.OnTeamChanged("removed", teamID, teamLeader, playerID, members);
					}
					else
					{
						Analytics.Azure.OnTeamChanged("disband", teamID, teamLeader, playerID, members);
						Disband();
					}
				}
				else
				{
					Analytics.Azure.OnTeamChanged("left", teamID, teamLeader, playerID, members);
				}
				MarkDirty();
				return true;
			}
			return false;
		}

		public void SetTeamLeader(ulong newTeamLeader)
		{
			if (Interface.CallHook("OnTeamMemberPromote", (object)this, (object)newTeamLeader) == null)
			{
				Analytics.Azure.OnTeamChanged("promoted", teamID, teamLeader, newTeamLeader, members);
				teamLeader = newTeamLeader;
				MarkDirty();
			}
		}

		public void Disband()
		{
			ServerInstance.DisbandTeam(this);
			CompanionServer.Server.TeamChat.Remove(teamID);
		}

		public void MarkDirty()
		{
			foreach (ulong member in members)
			{
				BasePlayer basePlayer = FindByID(member);
				if ((Object)(object)basePlayer != (Object)null)
				{
					basePlayer.UpdateTeam(teamID);
				}
			}
			this.BroadcastAppTeamUpdate();
		}

		public List<Connection> GetOnlineMemberConnections()
		{
			if (members.Count == 0)
			{
				return null;
			}
			onlineMemberConnections.Clear();
			foreach (ulong member in members)
			{
				BasePlayer basePlayer = FindByID(member);
				if (!((Object)(object)basePlayer == (Object)null) && basePlayer.Connection != null)
				{
					onlineMemberConnections.Add(basePlayer.Connection);
				}
			}
			return onlineMemberConnections;
		}

		void IPooled.EnterPool()
		{
			teamID = 0uL;
			teamName = string.Empty;
			teamLeader = 0uL;
			teamStartTime = 0f;
			joinKey = null;
			members.Clear();
			invites.Clear();
			onlineMemberConnections.Clear();
		}

		void IPooled.LeavePool()
		{
		}
	}

	[ReplicatedVar(Default = "true")]
	public static bool contacts = true;

	public const FileStorage.Type MugshotFileFormat = FileStorage.Type.jpg;

	private const int MugshotResolution = 256;

	private const int MugshotMaxFileSize = 65536;

	private const float MugshotMaxDistance = 50f;

	public Dictionary<ulong, PlayerRelationships> relationships = new Dictionary<ulong, PlayerRelationships>();

	private int lastReputationUpdateIndex;

	private const int seenReputationSeconds = 60;

	private int startingReputation;

	[ServerVar]
	public static int forgetafterminutes = 960;

	[ServerVar]
	public static int maxplayerrelationships = 128;

	[ServerVar]
	public static float seendistance = 10f;

	[ServerVar]
	public static float mugshotUpdateInterval = 300f;

	private static List<BasePlayer> _dirtyRelationshipPlayers = new List<BasePlayer>();

	private static Phrase RemoteInvitesBlocked = new Phrase("remote.invites.blocked", "That player has remote invites turned off");

	public static int maxTeamSize_Internal = 8;

	public Dictionary<ulong, BasePlayer> cachedPlayers = new Dictionary<ulong, BasePlayer>();

	public Dictionary<ulong, PlayerTeam> playerToTeam = new Dictionary<ulong, PlayerTeam>();

	public Dictionary<ulong, PlayerTeam> teams = new Dictionary<ulong, PlayerTeam>();

	[ServerVar]
	public static int maxTeamSize
	{
		get
		{
			return maxTeamSize_Internal;
		}
		set
		{
			maxTeamSize_Internal = value;
			if (Object.op_Implicit((Object)(object)ServerInstance))
			{
				ServerInstance.SendNetworkUpdate();
			}
		}
	}

	public static RelationshipManager ServerInstance { get; private set; }

	public RelationshipManagerDB Database { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RelationshipManager.OnRpcMessage", 0);
		try
		{
			if (rpc == 1684577101 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_ChangeRelationship "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_ChangeRelationship", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1684577101u, "SERVER_ChangeRelationship", this, player, 2uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_ChangeRelationship(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_ChangeRelationship");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1239936737 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_ReceiveMugshot "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_ReceiveMugshot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1239936737u, "SERVER_ReceiveMugshot", this, player, 10uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_ReceiveMugshot(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_ReceiveMugshot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2178173141u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_SendFreshContacts "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_SendFreshContacts", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2178173141u, "SERVER_SendFreshContacts", this, player, 1uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SERVER_SendFreshContacts(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SERVER_SendFreshContacts");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 290196604 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_UpdatePlayerNote "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_UpdatePlayerNote", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(290196604u, "SERVER_UpdatePlayerNote", this, player, 10uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							SERVER_UpdatePlayerNote(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in SERVER_UpdatePlayerNote");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2865758366u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - TryCreateTeam "));
				}
				TimeWarning val2 = TimeWarning.New("TryCreateTeam", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2865758366u, "TryCreateTeam", this, player, 1uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							TryCreateTeam(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in TryCreateTeam");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (contacts)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateReputations, 0f, 0.05f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)SendRelationships, 0f, 5f);
		}
	}

	public void UpdateReputations()
	{
		if (!contacts || BasePlayer.activePlayerList.Count == 0)
		{
			return;
		}
		if (lastReputationUpdateIndex >= BasePlayer.activePlayerList.Count)
		{
			lastReputationUpdateIndex = 0;
		}
		BasePlayer basePlayer = BasePlayer.activePlayerList[lastReputationUpdateIndex];
		if (basePlayer.requestingReputationUpdate)
		{
			if (basePlayer.reputation != (basePlayer.reputation = GetReputationFor(basePlayer.userID)))
			{
				basePlayer.SendNetworkUpdate();
			}
			basePlayer.requestingReputationUpdate = false;
		}
		lastReputationUpdateIndex++;
	}

	public int GetReputationFor(ulong playerID)
	{
		int num = startingReputation;
		foreach (PlayerRelationships value2 in relationships.Values)
		{
			if (!value2.relations.TryGetValue(playerID, out var value))
			{
				continue;
			}
			if (value.type == RelationshipType.Friend)
			{
				num++;
			}
			else if (value.type == RelationshipType.Acquaintance)
			{
				if (value.weight > 60)
				{
					num++;
				}
			}
			else if (value.type == RelationshipType.Enemy)
			{
				num--;
			}
		}
		return num;
	}

	[ServerVar]
	public static void wipecontacts(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && !((Object)(object)ServerInstance == (Object)null))
		{
			ulong num = basePlayer.userID.Get();
			if (ServerInstance.relationships.ContainsKey(num))
			{
				Debug.Log((object)("Wiped contacts for :" + num));
				ServerInstance.relationships.Remove(num);
				ServerInstance.MarkRelationshipsDirtyFor(num);
			}
			else
			{
				Debug.Log((object)("No contacts for :" + num));
			}
		}
	}

	[ServerVar]
	public static void wipe_all_contacts(Arg arg)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)arg.Player() == (Object)null || (Object)(object)ServerInstance == (Object)null)
		{
			return;
		}
		if (!arg.HasArgs(1) || arg.Args[0] != "confirm")
		{
			Debug.Log((object)"Please append the word 'confirm' at the end of the console command to execute");
			return;
		}
		ServerInstance.relationships.Clear();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				ServerInstance.MarkRelationshipsDirtyFor(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Debug.Log((object)"Wiped all contacts.");
	}

	public float GetAcquaintanceMaxDist()
	{
		return seendistance;
	}

	public void UpdateAcquaintancesFor(BasePlayer player, float deltaSeconds)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		PlayerRelationships playerRelationships = GetRelationships(player.userID);
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		BaseNetworkable.GetCloseConnections(((Component)player).transform.position, GetAcquaintanceMaxDist(), list);
		foreach (BasePlayer item in list)
		{
			if ((Object)(object)item == (Object)(object)player || item.isClient || !item.IsAlive() || item.IsSleeping() || item.limitNetworking)
			{
				continue;
			}
			PlayerRelationshipInfo relations = playerRelationships.GetRelations(item.userID);
			if (!(Vector3.Distance(((Component)player).transform.position, ((Component)item).transform.position) <= GetAcquaintanceMaxDist()))
			{
				continue;
			}
			relations.lastSeenTime = Time.realtimeSinceStartup;
			if ((relations.type == RelationshipType.NONE || relations.type == RelationshipType.Acquaintance) && ((BasePlayer.allowRelationshipServerOcclusion && player.SupportsServerOcclusion() && player.OcclusionLineOfSight(item)) || player.IsPlayerVisibleToUs(item, Vector3.zero, 1218519041)))
			{
				int num = Mathf.CeilToInt(deltaSeconds);
				if (player.InSafeZone() || item.InSafeZone())
				{
					num = 0;
				}
				if (relations.type != RelationshipType.Acquaintance || (relations.weight < 60 && num > 0))
				{
					SetRelationship(player, item, RelationshipType.Acquaintance, num);
				}
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	public void SetSeen(BasePlayer player, BasePlayer otherPlayer)
	{
		ulong player2 = player.userID.Get();
		ulong player3 = otherPlayer.userID.Get();
		PlayerRelationshipInfo relations = GetRelationships(player2).GetRelations(player3);
		if (relations.type != 0)
		{
			relations.lastSeenTime = Time.realtimeSinceStartup;
		}
	}

	public bool CleanupOldContacts(PlayerRelationships ownerRelationships, ulong playerID, RelationshipType relationshipType = RelationshipType.Acquaintance)
	{
		int numberRelationships = GetNumberRelationships(playerID);
		if (numberRelationships < maxplayerrelationships)
		{
			return true;
		}
		List<ulong> list = Pool.Get<List<ulong>>();
		foreach (KeyValuePair<ulong, PlayerRelationshipInfo> relation in ownerRelationships.relations)
		{
			if (relation.Value.type == relationshipType && Time.realtimeSinceStartup - relation.Value.lastSeenTime > (float)forgetafterminutes * 60f)
			{
				list.Add(relation.Key);
				BasePlayer basePlayer = BasePlayer.FindByID(relation.Key);
				if (Object.op_Implicit((Object)(object)basePlayer))
				{
					basePlayer.requestingReputationUpdate = true;
				}
			}
		}
		int count = list.Count;
		foreach (ulong item in list)
		{
			ownerRelationships.Forget(item);
		}
		Pool.FreeUnmanaged<ulong>(ref list);
		return numberRelationships - count < maxplayerrelationships;
	}

	public void ForceRelationshipByID(BasePlayer player, ulong otherPlayerID, RelationshipType newType, int weight, bool sendImmediate = false)
	{
		if (!contacts || (Object)(object)player == (Object)null || (ulong)player.userID == otherPlayerID || player.IsNpc)
		{
			return;
		}
		ulong player2 = player.userID.Get();
		if (HasRelations(player2, otherPlayerID))
		{
			PlayerRelationshipInfo relations = GetRelationships(player2).GetRelations(otherPlayerID);
			if (relations.type != newType)
			{
				relations.weight = 0;
			}
			relations.type = newType;
			relations.weight += weight;
			if (sendImmediate)
			{
				SendRelationshipsFor(player);
			}
			else
			{
				MarkRelationshipsDirtyFor(player);
			}
			BasePlayer basePlayer = BasePlayer.FindByID(otherPlayerID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.requestingReputationUpdate = true;
			}
		}
	}

	public void SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipType type, int weight = 1, bool sendImmediate = false)
	{
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		if (!contacts)
		{
			return;
		}
		ulong num = player.userID.Get();
		ulong num2 = otherPlayer.userID.Get();
		if ((Object)(object)player == (Object)null || (Object)(object)player == (Object)(object)otherPlayer || player.IsNpc || ((Object)(object)otherPlayer != (Object)null && otherPlayer.IsNpc) || Interface.CallHook("CanSetRelationship", (object)player, (object)otherPlayer, (object)type, (object)weight) != null)
		{
			return;
		}
		PlayerRelationships playerRelationships = GetRelationships(num);
		otherPlayer.requestingReputationUpdate = true;
		if (!CleanupOldContacts(playerRelationships, num))
		{
			CleanupOldContacts(playerRelationships, num, RelationshipType.Enemy);
		}
		PlayerRelationshipInfo relations = playerRelationships.GetRelations(num2);
		bool flag = false;
		if (relations.type != type)
		{
			flag = true;
			relations.weight = 0;
		}
		relations.type = type;
		relations.weight += weight;
		float num3 = Time.realtimeSinceStartup - relations.lastMugshotTime;
		if (flag || relations.mugshotCrc == 0 || num3 >= mugshotUpdateInterval)
		{
			bool flag2 = otherPlayer.IsAlive();
			bool num4 = player.SecondsSinceAttacked > 10f && !player.IsAiming;
			float num5 = 100f;
			if (num4)
			{
				Vector3 val = otherPlayer.eyes.position - player.eyes.position;
				Vector3 normalized = ((Vector3)(ref val)).normalized;
				bool flag3 = Vector3.Dot(player.eyes.HeadForward(), normalized) >= 0.6f;
				float num6 = Vector3Ex.Distance2D(((Component)player).transform.position, ((Component)otherPlayer).transform.position);
				if (flag2 && num6 < num5 && flag3)
				{
					ClientRPC(RpcTarget.Player("CLIENT_DoMugshot", player), num2);
					relations.lastMugshotTime = Time.realtimeSinceStartup;
				}
			}
		}
		if (sendImmediate)
		{
			SendRelationshipsFor(player);
		}
		else
		{
			MarkRelationshipsDirtyFor(player);
		}
	}

	public PlayerRelationships GetRelationshipSaveByID(ulong playerID)
	{
		PlayerRelationships val = Pool.Get<PlayerRelationships>();
		PlayerRelationships playerRelationships = GetRelationships(playerID);
		if (playerRelationships != null)
		{
			val.playerID = playerID;
			val.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			{
				foreach (KeyValuePair<ulong, PlayerRelationshipInfo> relation in playerRelationships.relations)
				{
					val.relations.Add(relation.Value.ToProto());
				}
				return val;
			}
		}
		return null;
	}

	public void MarkRelationshipsDirtyFor(ulong playerID)
	{
		BasePlayer basePlayer = FindByID(playerID);
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			MarkRelationshipsDirtyFor(basePlayer);
		}
	}

	public static void ForceSendRelationships(BasePlayer player)
	{
		if (Object.op_Implicit((Object)(object)ServerInstance))
		{
			ServerInstance.MarkRelationshipsDirtyFor(player);
		}
	}

	public void MarkRelationshipsDirtyFor(BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) && !_dirtyRelationshipPlayers.Contains(player))
		{
			_dirtyRelationshipPlayers.Add(player);
		}
	}

	public void SendRelationshipsFor(BasePlayer player)
	{
		if (!contacts)
		{
			return;
		}
		ulong playerID = player.userID.Get();
		PlayerRelationships relationshipSaveByID = GetRelationshipSaveByID(playerID);
		try
		{
			ClientRPC(RpcTarget.Player("CLIENT_RecieveLocalRelationships", player), relationshipSaveByID);
		}
		finally
		{
			((IDisposable)relationshipSaveByID)?.Dispose();
		}
	}

	public void SendRelationships()
	{
		if (!contacts)
		{
			return;
		}
		foreach (BasePlayer dirtyRelationshipPlayer in _dirtyRelationshipPlayers)
		{
			if (!((Object)(object)dirtyRelationshipPlayer == (Object)null) && dirtyRelationshipPlayer.IsConnected && !dirtyRelationshipPlayer.IsSleeping())
			{
				SendRelationshipsFor(dirtyRelationshipPlayer);
			}
		}
		_dirtyRelationshipPlayers.Clear();
	}

	public int GetNumberRelationships(ulong player)
	{
		if (relationships.TryGetValue(player, out var value))
		{
			return value.relations.Count;
		}
		return 0;
	}

	public bool HasRelations(ulong player, ulong otherPlayer)
	{
		if (relationships.TryGetValue(player, out var value) && value.relations.ContainsKey(otherPlayer))
		{
			return true;
		}
		return false;
	}

	public PlayerRelationships GetRelationships(ulong player)
	{
		if (relationships.TryGetValue(player, out var value))
		{
			return value;
		}
		PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
		playerRelationships.ownerPlayer = player;
		relationships.Add(player, playerRelationships);
		return playerRelationships;
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void SERVER_SendFreshContacts(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (Object.op_Implicit((Object)(object)player))
		{
			SendRelationshipsFor(player);
		}
	}

	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	public void SERVER_ChangeRelationship(RPCMessage msg)
	{
		EncryptedValue<ulong> userID = msg.player.userID;
		ulong num = msg.read.UInt64();
		int num2 = Mathf.Clamp(msg.read.Int32(), 0, 3);
		PlayerRelationships playerRelationships = GetRelationships(userID);
		playerRelationships.GetRelations(num);
		BasePlayer player = msg.player;
		RelationshipType relationshipType = (RelationshipType)num2;
		if (num2 == 0)
		{
			if (playerRelationships.Forget(num))
			{
				SendRelationshipsFor(player);
			}
			return;
		}
		BasePlayer basePlayer = FindByID(num);
		if ((Object)(object)basePlayer == (Object)null)
		{
			ForceRelationshipByID(player, num, relationshipType, 0, sendImmediate: true);
		}
		else
		{
			SetRelationship(player, basePlayer, relationshipType, 1, sendImmediate: true);
		}
	}

	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server]
	public void SERVER_UpdatePlayerNote(RPCMessage msg)
	{
		EncryptedValue<ulong> userID = msg.player.userID;
		ulong player = msg.read.UInt64();
		string notes = msg.read.String(256, false);
		GetRelationships(userID).GetRelations(player).notes = notes;
		MarkRelationshipsDirtyFor(userID);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(10uL)]
	public void SERVER_ReceiveMugshot(RPCMessage msg)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		EncryptedValue<ulong> userID = msg.player.userID;
		ulong num = msg.read.UInt64();
		uint num2 = msg.read.UInt32();
		byte[] array = msg.read.BytesWithSize(65536u, false);
		if (array != null && ImageProcessing.IsValidJPG(array, 256, 512) && relationships.TryGetValue(userID, out var value) && value.relations.TryGetValue(num, out var value2))
		{
			uint steamIdHash = GetSteamIdHash(userID, num);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.jpg, net.ID, steamIdHash);
			if (num3 != num2)
			{
				Debug.LogWarning((object)"Client/Server FileStorage CRC differs");
			}
			if (num3 != value2.mugshotCrc)
			{
				FileStorage.server.RemoveExact(value2.mugshotCrc, FileStorage.Type.jpg, net.ID, steamIdHash);
			}
			value2.mugshotCrc = num3;
			MarkRelationshipsDirtyFor(userID);
		}
	}

	private void DeleteMugshot(ulong steamId, ulong targetSteamId, uint crc)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (crc != 0)
		{
			uint steamIdHash = GetSteamIdHash(steamId, targetSteamId);
			FileStorage.server.RemoveExact(crc, FileStorage.Type.jpg, net.ID, steamIdHash);
		}
	}

	public static uint GetSteamIdHash(ulong requesterSteamId, ulong targetSteamId)
	{
		return (uint)(((requesterSteamId & 0xFFFF) << 16) | (targetSteamId & 0xFFFF));
	}

	public int GetMaxTeamSize()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode))
		{
			return activeGameMode.GetMaxRelationshipTeamSize();
		}
		return maxTeamSize;
	}

	public void OnEnable()
	{
		if (base.isServer)
		{
			if ((Object)(object)ServerInstance != (Object)null)
			{
				Debug.LogError((object)"Major fuckup! RelationshipManager spawned twice, Contact Developers!");
				Object.Destroy((Object)(object)((Component)this).gameObject);
			}
			else
			{
				ServerInstance = this;
			}
		}
	}

	public void OnDestroy()
	{
		if (base.isServer)
		{
			ServerInstance = null;
		}
		RelationshipManagerDB database = Database;
		if (database != null)
		{
			((Database)database).Close();
		}
		Database = null;
	}

	public override void InitShared()
	{
		base.InitShared();
		if (!base.isServer)
		{
			return;
		}
		try
		{
			RelationshipManagerDB database = Database;
			if (database != null)
			{
				((Database)database).Close();
			}
			Database = null;
			Database = new RelationshipManagerDB();
			((Database)Database).Open($"{ConVar.Server.rootFolder}/relationship.{281}.db", true);
			Database.Initialize();
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.relationshipManager = Pool.Get<RelationshipManager>();
		info.msg.relationshipManager.maxTeamSize = maxTeamSize;
		if (!info.forDisk)
		{
			return;
		}
		info.msg.relationshipManager.teamList = Pool.Get<List<PlayerTeam>>();
		foreach (KeyValuePair<ulong, PlayerTeam> team in teams)
		{
			PlayerTeam value = team.Value;
			if (value == null)
			{
				continue;
			}
			PlayerTeam val = Pool.Get<PlayerTeam>();
			val.teamLeader = value.teamLeader;
			val.teamID = value.teamID;
			val.teamName = value.teamName;
			val.joinKey = value.joinKey;
			val.members = Pool.Get<List<TeamMember>>();
			val.invites = Pool.Get<List<ulong>>();
			foreach (ulong invite in value.invites)
			{
				val.invites.Add(invite);
			}
			foreach (ulong member in value.members)
			{
				TeamMember val2 = Pool.Get<TeamMember>();
				BasePlayer basePlayer = FindByID(member);
				val2.displayName = (((Object)(object)basePlayer != (Object)null) ? basePlayer.displayName : (SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(member) ?? "DEAD"));
				val2.userID = member;
				val.members.Add(val2);
			}
			info.msg.relationshipManager.teamList.Add(val);
		}
		info.msg.relationshipManager.relationships = Pool.Get<List<PlayerRelationships>>();
		foreach (ulong key in relationships.Keys)
		{
			_ = relationships[key];
			PlayerRelationships relationshipSaveByID = GetRelationshipSaveByID(key);
			info.msg.relationshipManager.relationships.Add(relationshipSaveByID);
		}
	}

	public void DisbandTeam(PlayerTeam teamToDisband)
	{
		if (Interface.CallHook("OnTeamDisband", (object)teamToDisband) == null)
		{
			teams.Remove(teamToDisband.teamID);
			Interface.CallHook("OnTeamDisbanded", (object)teamToDisband);
			Pool.Free<PlayerTeam>(ref teamToDisband);
		}
	}

	public static BasePlayer FindByID(ulong userID)
	{
		BasePlayer value = null;
		if (ServerInstance.cachedPlayers.TryGetValue(userID, out value))
		{
			if ((Object)(object)value != (Object)null)
			{
				return value;
			}
			ServerInstance.cachedPlayers.Remove(userID);
		}
		BasePlayer basePlayer = BasePlayer.FindByID(userID);
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer = BasePlayer.FindSleeping(userID);
		}
		if ((Object)(object)basePlayer != (Object)null)
		{
			ServerInstance.cachedPlayers.Add(userID, basePlayer);
		}
		return basePlayer;
	}

	public PlayerTeam FindTeam(ulong TeamID)
	{
		if (teams.ContainsKey(TeamID))
		{
			return teams[TeamID];
		}
		return null;
	}

	public PlayerTeam FindPlayersTeam(ulong userID)
	{
		if (playerToTeam.TryGetValue(userID, out var value))
		{
			return value;
		}
		return null;
	}

	public bool IsPlayerInTeam(ulong userId)
	{
		return playerToTeam.ContainsKey(userId);
	}

	public PlayerTeam FindByJoinKey(string key)
	{
		if (string.IsNullOrEmpty(key))
		{
			return null;
		}
		return teams.Values.FirstOrDefault((PlayerTeam x) => x.joinKey == key);
	}

	public PlayerTeam CreatePartyTeam(string joinKey)
	{
		PlayerTeam playerTeam = CreateTeam();
		playerTeam.usePartySpawn = true;
		playerTeam.joinKey = joinKey;
		return playerTeam;
	}

	public PlayerTeam CreateTeam()
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		playerTeam.teamID = Database.IncrementLastTeamIndex();
		playerTeam.teamStartTime = Time.realtimeSinceStartup;
		teams.Add(playerTeam.teamID, playerTeam);
		return playerTeam;
	}

	private PlayerTeam CreateTeam(ulong customId)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		playerTeam.teamID = customId;
		playerTeam.teamStartTime = Time.realtimeSinceStartup;
		teams.Add(playerTeam.teamID, playerTeam);
		return playerTeam;
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	private void TryCreateTeam(RPCMessage rpc)
	{
		if (maxTeamSize != 0)
		{
			TryCreateTeam(rpc.player);
		}
	}

	[ServerVar]
	public static void trycreateteam(Arg arg)
	{
		if (maxTeamSize == 0)
		{
			arg.ReplyWith("Teams are disabled on this server");
		}
		else
		{
			TryCreateTeam(arg.Player());
		}
	}

	private static void TryCreateTeam(BasePlayer player)
	{
		if (player.currentTeam == 0L && Interface.CallHook("OnTeamCreate", (object)player) == null)
		{
			PlayerTeam playerTeam = ServerInstance.CreateTeam();
			playerTeam.teamLeader = player.userID;
			playerTeam.AddPlayer(player);
			Analytics.Azure.OnTeamChanged("created", playerTeam.teamID, player.userID, player.userID, playerTeam.members);
			Interface.CallHook("OnTeamCreated", (object)player, (object)playerTeam);
		}
	}

	[ServerUserVar]
	public static void promote(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.currentTeam == 0L)
		{
			return;
		}
		BasePlayer lookingAtPlayer = GetLookingAtPlayer(basePlayer);
		if (!((Object)(object)lookingAtPlayer == (Object)null) && !lookingAtPlayer.IsDead() && !((Object)(object)lookingAtPlayer == (Object)(object)basePlayer) && lookingAtPlayer.currentTeam == basePlayer.currentTeam)
		{
			PlayerTeam playerTeam = ServerInstance.teams[basePlayer.currentTeam];
			if (playerTeam != null && playerTeam.teamLeader == (ulong)basePlayer.userID)
			{
				playerTeam.SetTeamLeader(lookingAtPlayer.userID);
			}
		}
	}

	[ServerUserVar]
	public static void promote_id(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.currentTeam == 0L)
		{
			return;
		}
		BasePlayer playerOrSleeperOrBot = arg.GetPlayerOrSleeperOrBot(0);
		if (!((Object)(object)playerOrSleeperOrBot == (Object)null) && !playerOrSleeperOrBot.IsDead() && !((Object)(object)playerOrSleeperOrBot == (Object)(object)basePlayer) && playerOrSleeperOrBot.currentTeam == basePlayer.currentTeam)
		{
			PlayerTeam playerTeam = ServerInstance.teams[basePlayer.currentTeam];
			if (playerTeam != null && playerTeam.teamLeader == (ulong)basePlayer.userID)
			{
				playerTeam.SetTeamLeader(playerOrSleeperOrBot.userID);
			}
		}
	}

	[ServerUserVar]
	public static void leaveteam(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && basePlayer.currentTeam != 0L)
		{
			PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
			if (playerTeam != null && Interface.CallHook("OnTeamLeave", (object)playerTeam, (object)basePlayer) == null)
			{
				playerTeam.RemovePlayer(basePlayer.userID);
				basePlayer.ClearTeam();
			}
		}
	}

	[ServerUserVar]
	public static void acceptinvite(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamAcceptInvite", (object)playerTeam, (object)basePlayer) == null)
			{
				playerTeam.AcceptInvite(basePlayer);
			}
		}
	}

	[ServerUserVar]
	public static void rejectinvite(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamRejectInvite", (object)basePlayer, (object)playerTeam) == null)
			{
				playerTeam.RejectInvite(basePlayer);
			}
		}
	}

	public static BasePlayer GetLookingAtPlayer(BasePlayer source)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit hit = default(RaycastHit);
		if (Physics.Raycast(source.eyes.position, source.eyes.HeadForward(), ref hit, 5f, 1218652417, (QueryTriggerInteraction)1))
		{
			BaseEntity entity = hit.GetEntity();
			if (Object.op_Implicit((Object)(object)entity))
			{
				return ((Component)entity).GetComponent<BasePlayer>();
			}
		}
		return null;
	}

	[ServerVar]
	public static void sleeptoggle(Arg arg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		RaycastHit hit = default(RaycastHit);
		if ((Object)(object)basePlayer == (Object)null || !Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), ref hit, 5f, 1218652417, (QueryTriggerInteraction)1))
		{
			return;
		}
		BaseEntity entity = hit.GetEntity();
		if (!Object.op_Implicit((Object)(object)entity))
		{
			return;
		}
		BasePlayer component = ((Component)entity).GetComponent<BasePlayer>();
		if (Object.op_Implicit((Object)(object)component) && (Object)(object)component != (Object)(object)basePlayer && !component.IsNpc)
		{
			if (component.IsSleeping())
			{
				component.EndSleeping();
			}
			else
			{
				component.StartSleeping();
			}
		}
	}

	[ServerUserVar]
	public static void kickmember(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam != null && !((Object)(object)playerTeam.GetLeader() != (Object)(object)basePlayer))
		{
			ulong uLong = arg.GetULong(0, 0uL);
			if ((ulong)basePlayer.userID != uLong && Interface.CallHook("OnTeamKick", (object)playerTeam, (object)basePlayer, (object)uLong) == null)
			{
				playerTeam.RemovePlayer(uLong);
			}
		}
	}

	[ServerUserVar]
	public static void sendinvite(Arg arg)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam == null || (Object)(object)playerTeam.GetLeader() == (Object)null || (Object)(object)playerTeam.GetLeader() != (Object)(object)basePlayer)
		{
			return;
		}
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			return;
		}
		BasePlayer basePlayer2 = BaseNetworkable.serverEntities.Find(new NetworkableId(uLong)) as BasePlayer;
		if (Object.op_Implicit((Object)(object)basePlayer2) && (Object)(object)basePlayer2 != (Object)(object)basePlayer && !basePlayer2.IsNpc && basePlayer2.currentTeam == 0L)
		{
			float num = 7f;
			if (!(Vector3.Distance(((Component)basePlayer2).transform.position, ((Component)basePlayer).transform.position) > num) && Interface.CallHook("IOnTeamInvite", (object)basePlayer, (object)basePlayer2) == null && Interface.CallHook("OnTeamMemberInvite", (object)playerTeam, (object)basePlayer, (object)basePlayer2.userID.Get(), (object)false) == null)
			{
				playerTeam.SendInvite(basePlayer2);
			}
		}
	}

	public bool HasPendingInvite(ulong forPlayer, out ulong foundTeamID)
	{
		foundTeamID = 0uL;
		foreach (KeyValuePair<ulong, PlayerTeam> team in teams)
		{
			if (team.Value.invites.Contains(forPlayer))
			{
				foundTeamID = team.Key;
				return true;
			}
		}
		return false;
	}

	public bool GetTeamLeaderInfo(ulong teamID, out string leaderDisplayName, out ulong leaderID)
	{
		leaderDisplayName = string.Empty;
		leaderID = 0uL;
		if (teams.TryGetValue(teamID, out var value))
		{
			BasePlayer basePlayer = BasePlayer.FindAwakeOrSleepingByID(value.teamLeader);
			if ((Object)(object)basePlayer != (Object)null)
			{
				leaderDisplayName = basePlayer.displayName;
				leaderID = basePlayer.userID;
				return true;
			}
		}
		return false;
	}

	[ServerUserVar]
	public static void sendofflineinvite(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam == null || (Object)(object)playerTeam.GetLeader() == (Object)null || (Object)(object)playerTeam.GetLeader() != (Object)(object)basePlayer)
		{
			return;
		}
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong != 0L)
		{
			BasePlayer basePlayer2 = BasePlayer.FindAwakeOrSleepingByID(uLong);
			if ((Object)(object)basePlayer2 != (Object)null && !basePlayer2.GetInfoBool("client.allowteaminvitesremoteplayers", defaultVal: true))
			{
				basePlayer.ShowToast(GameTip.Styles.Error, RemoteInvitesBlocked, false);
			}
			else if (((Object)(object)basePlayer2 == (Object)null || (!basePlayer2.IsNpc && basePlayer2.currentTeam == 0L)) && Interface.CallHook("OnTeamMemberInvite", (object)playerTeam, (object)basePlayer, (object)uLong, (object)true) == null)
			{
				playerTeam.SendInvite(basePlayer2, uLong);
			}
		}
	}

	[ServerVar]
	public static void fakeinvite(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		ulong uLong = arg.GetULong(0, 0uL);
		PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
		if (playerTeam != null)
		{
			if (basePlayer.currentTeam != 0L)
			{
				Debug.Log((object)"already in team");
			}
			playerTeam.SendInvite(basePlayer);
			Debug.Log((object)"sent bot invite");
		}
	}

	[ServerVar]
	public static void addtoteam(Arg arg)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		RaycastHit hit = default(RaycastHit);
		if (playerTeam == null || (Object)(object)playerTeam.GetLeader() == (Object)null || (Object)(object)playerTeam.GetLeader() != (Object)(object)basePlayer || !Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), ref hit, 5f, 1218652417, (QueryTriggerInteraction)1))
		{
			return;
		}
		BaseEntity entity = hit.GetEntity();
		if (Object.op_Implicit((Object)(object)entity))
		{
			BasePlayer component = ((Component)entity).GetComponent<BasePlayer>();
			if (Object.op_Implicit((Object)(object)component) && (Object)(object)component != (Object)(object)basePlayer && !component.IsNpc)
			{
				playerTeam.AddPlayer(component);
			}
		}
	}

	[ServerVar]
	public static string createAndAddToTeam(Arg arg)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		uint uInt = arg.GetUInt(0, 0u);
		RaycastHit hit = default(RaycastHit);
		if (Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), ref hit, 5f, 1218652417, (QueryTriggerInteraction)1))
		{
			BaseEntity entity = hit.GetEntity();
			if (Object.op_Implicit((Object)(object)entity))
			{
				BasePlayer component = ((Component)entity).GetComponent<BasePlayer>();
				if (Object.op_Implicit((Object)(object)component) && (Object)(object)component != (Object)(object)basePlayer && !component.IsNpc)
				{
					if (component.currentTeam != 0L)
					{
						return component.displayName + " is already in a team";
					}
					if (ServerInstance.FindTeam(uInt) != null)
					{
						ServerInstance.FindTeam(uInt).AddPlayer(component);
						return $"Added {component.displayName} to existing team {uInt}";
					}
					PlayerTeam playerTeam = ServerInstance.CreateTeam(uInt);
					playerTeam.teamLeader = component.userID;
					playerTeam.AddPlayer(component);
					return $"Added {component.displayName} to team {uInt}";
				}
			}
		}
		return "Unable to find valid player in front";
	}

	public static bool TeamsEnabled()
	{
		return maxTeamSize > 0;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!info.fromDisk || info.msg.relationshipManager == null)
		{
			return;
		}
		foreach (PlayerTeam team in info.msg.relationshipManager.teamList)
		{
			PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
			playerTeam.teamLeader = team.teamLeader;
			playerTeam.teamID = team.teamID;
			playerTeam.teamName = team.teamName;
			playerTeam.joinKey = team.joinKey;
			playerTeam.members = new List<ulong>();
			playerTeam.invites = new List<ulong>();
			foreach (ulong invite in team.invites)
			{
				playerTeam.invites.Add(invite);
			}
			foreach (TeamMember member in team.members)
			{
				playerTeam.members.Add(member.userID);
			}
			teams[playerTeam.teamID] = playerTeam;
		}
		foreach (PlayerTeam value2 in teams.Values)
		{
			foreach (ulong member2 in value2.members)
			{
				playerToTeam[member2] = value2;
				BasePlayer basePlayer = FindByID(member2);
				if ((Object)(object)basePlayer != (Object)null && basePlayer.currentTeam != value2.teamID)
				{
					Debug.LogWarning((object)$"Player {member2} has the wrong teamID: got {basePlayer.currentTeam}, expected {value2.teamID}. Fixing automatically.");
					basePlayer.currentTeam = value2.teamID;
				}
			}
		}
		foreach (PlayerRelationships relationship in info.msg.relationshipManager.relationships)
		{
			ulong playerID = relationship.playerID;
			PlayerRelationships playerRelationships = GetRelationships(playerID);
			playerRelationships.ClearRelations();
			foreach (PlayerRelationshipInfo relation in relationship.relations)
			{
				PlayerRelationshipInfo value = PlayerRelationshipInfo.FromProto(relation);
				playerRelationships.relations.Add(relation.playerID, value);
			}
		}
	}
}


public enum RelationshipType
{
	NONE,
	Acquaintance,
	Friend,
	Enemy
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class PlayerRelationshipInfo : IPooled, IServerFileReceiver, IPlayerInfo
{
	public string displayName;

	public ulong player;

	public RelationshipType type;

	public int weight;

	public uint mugshotCrc;

	public string notes;

	public float lastSeenTime;

	[NonSerialized]
	public float lastMugshotTime;

	public ulong UserId => player;

	public string UserName => displayName;

	public bool IsOnline => false;

	public bool IsMe => false;

	public bool IsFriend => false;

	public bool IsPlayingThisGame => true;

	public string ServerEndpoint => string.Empty;

	public void EnterPool()
	{
		Reset();
	}

	public void LeavePool()
	{
		Reset();
	}

	private void Reset()
	{
		displayName = null;
		player = 0uL;
		type = RelationshipType.NONE;
		weight = 0;
		mugshotCrc = 0u;
		notes = "";
		lastMugshotTime = 0f;
	}

	public PlayerRelationshipInfo ToProto()
	{
		PlayerRelationshipInfo obj = Pool.Get<PlayerRelationshipInfo>();
		obj.playerID = player;
		obj.type = (int)type;
		obj.weight = weight;
		obj.mugshotCrc = mugshotCrc;
		obj.displayName = displayName;
		obj.notes = notes;
		obj.timeSinceSeen = Time.realtimeSinceStartup - lastSeenTime;
		return obj;
	}

	public static PlayerRelationshipInfo FromProto(PlayerRelationshipInfo proto)
	{
		return new PlayerRelationshipInfo
		{
			type = (RelationshipType)proto.type,
			weight = proto.weight,
			displayName = proto.displayName,
			mugshotCrc = proto.mugshotCrc,
			notes = proto.notes,
			player = proto.playerID,
			lastSeenTime = Time.realtimeSinceStartup - proto.timeSinceSeen
		};
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class PlayerRelationships : IPooled
{
	public bool dirty;

	public ulong ownerPlayer;

	public Dictionary<ulong, PlayerRelationshipInfo> relations;

	public bool Forget(ulong player)
	{
		if (relations.TryGetValue(player, out var value))
		{
			relations.Remove(player);
			if (value.mugshotCrc != 0)
			{
				ServerInstance.DeleteMugshot(ownerPlayer, player, value.mugshotCrc);
			}
			Pool.Free<PlayerRelationshipInfo>(ref value);
			return true;
		}
		return false;
	}

	public PlayerRelationshipInfo GetRelations(ulong player)
	{
		BasePlayer basePlayer = FindByID(player);
		if (relations.TryGetValue(player, out var value))
		{
			if ((Object)(object)basePlayer != (Object)null)
			{
				value.displayName = basePlayer.displayName;
			}
			return value;
		}
		PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
		if ((Object)(object)basePlayer != (Object)null)
		{
			playerRelationshipInfo.displayName = basePlayer.displayName;
		}
		playerRelationshipInfo.player = player;
		relations.Add(player, playerRelationshipInfo);
		return playerRelationshipInfo;
	}

	public PlayerRelationships()
	{
		LeavePool();
	}

	public void EnterPool()
	{
		ownerPlayer = 0uL;
		if (relations != null)
		{
			Pool.Free<ulong, PlayerRelationshipInfo>(ref relations, true);
		}
	}

	public void LeavePool()
	{
		ownerPlayer = 0uL;
		relations = Pool.Get<Dictionary<ulong, PlayerRelationshipInfo>>();
	}

	public void ClearRelations()
	{
		foreach (KeyValuePair<ulong, PlayerRelationshipInfo> relation in relations)
		{
			var (_, playerRelationshipInfo2) = (KeyValuePair<ulong, PlayerRelationshipInfo>)(ref relation);
			Pool.Free<PlayerRelationshipInfo>(ref playerRelationshipInfo2);
		}
		relations.Clear();
	}
}


using System;
using System.Collections.Generic;
using CompanionServer;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;

public class PlayerTeam : IPooled
{
	public ulong teamID;

	public string joinKey;

	public string teamName;

	public ulong teamLeader;

	public Vector3 firstSpawnLocation;

	public bool usePartySpawn;

	public List<ulong> members = new List<ulong>();

	public List<ulong> invites = new List<ulong>();

	public float teamStartTime;

	public List<Connection> onlineMemberConnections = new List<Connection>();

	public float teamLifetime => Time.realtimeSinceStartup - teamStartTime;

	public BasePlayer GetLeader()
	{
		return FindByID(teamLeader);
	}

	public void SendInvite(BasePlayer player)
	{
		if (invites.Count > 8)
		{
			invites.RemoveRange(0, 1);
		}
		BasePlayer basePlayer = FindByID(teamLeader);
		if (!((Object)(object)basePlayer == (Object)null))
		{
			ulong item = player.userID.Get();
			if (!invites.Contains(item))
			{
				invites.Add(item);
			}
			player.ClientRPC(RpcTarget.Player("CLIENT_PendingInvite", player), basePlayer.displayName, teamLeader, teamID);
		}
	}

	public void SendInvite(BasePlayer player, ulong id)
	{
		if (invites.Count > 8)
		{
			invites.RemoveRange(0, 1);
		}
		BasePlayer basePlayer = FindByID(teamLeader);
		if (!((Object)(object)basePlayer == (Object)null))
		{
			if (!invites.Contains(id))
			{
				invites.Add(id);
			}
			if ((Object)(object)player != (Object)null)
			{
				player.ClientRPC(RpcTarget.Player("CLIENT_PendingInvite", player), basePlayer.displayName, teamLeader, teamID);
			}
		}
	}

	public void AcceptInvite(BasePlayer player)
	{
		if (invites.Contains(player.userID))
		{
			invites.Remove(player.userID);
			AddPlayer(player);
			player.ClearPendingInvite();
		}
	}

	public void RejectInvite(BasePlayer player)
	{
		player.ClearPendingInvite();
		invites.Remove(player.userID);
	}

	public bool AddPlayer(BasePlayer player, bool skipDirtyUpdate = false)
	{
		if (player.currentTeam != 0L)
		{
			return false;
		}
		if (!AddPlayer(player.userID, skipDirtyUpdate))
		{
			return false;
		}
		player.currentTeam = teamID;
		player.SendNetworkUpdate();
		if (SleepingBag.UseTeamLabels)
		{
			TimeWarning val = TimeWarning.New("RelationshipManager.AddPLayer.TeamLabels", 0);
			try
			{
				SleepingBag.UpdateTeamsBags(members);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		return true;
	}

	public bool AddPlayer(ulong playerId, bool skipDirtyUpdate = false)
	{
		if (members.Contains(playerId))
		{
			return false;
		}
		if (members.Count >= maxTeamSize)
		{
			return false;
		}
		bool num = members.Count == 0;
		members.Add(playerId);
		ServerInstance.playerToTeam.Add(playerId, this);
		if (!skipDirtyUpdate)
		{
			MarkDirty();
		}
		if (!num)
		{
			Analytics.Azure.OnTeamChanged("added", teamID, teamLeader, playerId, members);
		}
		return true;
	}

	public bool RemovePlayer(ulong playerID)
	{
		if (members.Contains(playerID))
		{
			members.Remove(playerID);
			ServerInstance.playerToTeam.Remove(playerID);
			BasePlayer basePlayer = FindByID(playerID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.ClearTeam();
				basePlayer.BroadcastAppTeamRemoval();
				basePlayer.SendNetworkUpdate();
				if (SleepingBag.UseTeamLabels)
				{
					TimeWarning val = TimeWarning.New("RelationshipManager.RemovePlayer.TeamLabels", 0);
					try
					{
						SleepingBag.UpdateMyBags(basePlayer.userID.Get());
						SleepingBag.UpdateTeamsBags(members);
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
				}
			}
			if (teamLeader == playerID)
			{
				if (members.Count > 0)
				{
					SetTeamLeader(members[0]);
					Analytics.Azure.OnTeamChanged("removed", teamID, teamLeader, playerID, members);
				}
				else
				{
					Analytics.Azure.OnTeamChanged("disband", teamID, teamLeader, playerID, members);
					Disband();
				}
			}
			else
			{
				Analytics.Azure.OnTeamChanged("left", teamID, teamLeader, playerID, members);
			}
			MarkDirty();
			return true;
		}
		return false;
	}

	public void SetTeamLeader(ulong newTeamLeader)
	{
		if (Interface.CallHook("OnTeamMemberPromote", (object)this, (object)newTeamLeader) == null)
		{
			Analytics.Azure.OnTeamChanged("promoted", teamID, teamLeader, newTeamLeader, members);
			teamLeader = newTeamLeader;
			MarkDirty();
		}
	}

	public void Disband()
	{
		ServerInstance.DisbandTeam(this);
		Server.TeamChat.Remove(teamID);
	}

	public void MarkDirty()
	{
		foreach (ulong member in members)
		{
			BasePlayer basePlayer = FindByID(member);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.UpdateTeam(teamID);
			}
		}
		this.BroadcastAppTeamUpdate();
	}

	public List<Connection> GetOnlineMemberConnections()
	{
		if (members.Count == 0)
		{
			return null;
		}
		onlineMemberConnections.Clear();
		foreach (ulong member in members)
		{
			BasePlayer basePlayer = FindByID(member);
			if (!((Object)(object)basePlayer == (Object)null) && basePlayer.Connection != null)
			{
				onlineMemberConnections.Add(basePlayer.Connection);
			}
		}
		return onlineMemberConnections;
	}

	void IPooled.EnterPool()
	{
		teamID = 0uL;
		teamName = string.Empty;
		teamLeader = 0uL;
		teamStartTime = 0f;
		joinKey = null;
		members.Clear();
		invites.Clear();
		onlineMemberConnections.Clear();
	}

	void IPooled.LeavePool()
	{
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class RemoteControlEntity : BaseCombatEntity, IRemoteControllable, IAdminUpdatableIdentifier
{
	public static List<IRemoteControllable> allControllables = new List<IRemoteControllable>();

	[Header("RC Entity")]
	public string rcIdentifier = "";

	public Transform viewEyes;

	public GameObjectRef IDPanelPrefab;

	public RemoteControllableControls rcControls;

	public bool CanPing => true;

	public virtual bool CanAcceptInput => false;

	public int ViewerCount { get; set; }

	public CameraViewerId? ControllingViewerId { get; set; }

	public bool IsBeingControlled
	{
		get
		{
			if (ViewerCount > 0)
			{
				return ControllingViewerId.HasValue;
			}
			return false;
		}
	}

	public virtual bool RequiresMouse => false;

	public virtual float MaxRange => 10000f;

	public RemoteControllableControls RequiredControls => rcControls;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RemoteControlEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 2025588587 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AdminUpdateIdentifier "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AdminUpdateIdentifier", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2025588587u, "Server_AdminUpdateIdentifier", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_AdminUpdateIdentifier(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_AdminUpdateIdentifier");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1677685895 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestOpenRCPanel "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestOpenRCPanel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_RequestOpenRCPanel(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_RequestOpenRCPanel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1053317251 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetID "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetID", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1053317251u, "Server_SetID", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							Server_SetID(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in Server_SetID");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public Transform GetEyes()
	{
		return viewEyes;
	}

	public float GetFovScale()
	{
		return 1f;
	}

	public BaseEntity GetEnt()
	{
		return this;
	}

	public string GetIdentifier()
	{
		return rcIdentifier;
	}

	public virtual bool InitializeControl(CameraViewerId viewerID)
	{
		ViewerCount++;
		if (CanAcceptInput && !ControllingViewerId.HasValue)
		{
			ControllingViewerId = viewerID;
			return true;
		}
		return !CanAcceptInput;
	}

	public virtual void StopControl(CameraViewerId viewerID)
	{
		ViewerCount--;
		if (ControllingViewerId == viewerID)
		{
			ControllingViewerId = null;
		}
	}

	public virtual void UserInput(InputState inputState, CameraViewerId viewerID)
	{
	}

	public void UpdateIdentifier(string newID, bool clientSend = false)
	{
		_ = rcIdentifier;
		if (base.isServer)
		{
			if (!IDInUse(newID))
			{
				rcIdentifier = newID;
			}
			SendNetworkUpdate();
		}
	}

	public virtual void RCSetup()
	{
		if (base.isServer)
		{
			InstallControllable(this);
		}
	}

	public virtual void RCShutdown()
	{
		if (base.isServer)
		{
			RemoveControllable(this);
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		RCSetup();
	}

	public override void DestroyShared()
	{
		RCShutdown();
		base.DestroyShared();
	}

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", (object)this, (object)playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_SetID(RPCMessage msg)
	{
		string oldID = msg.read.String(256, false);
		string newID = msg.read.String(256, false);
		SetID(msg.player, oldID, newID);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_AdminUpdateIdentifier(RPCMessage msg)
	{
		if (!((Object)(object)msg.player == (Object)null) && (msg.player.IsAdmin || msg.player.IsDeveloper))
		{
			string oldID = msg.read.String(256, false);
			string newID = msg.read.String(256, false);
			SetID(msg.player, oldID, newID, bypassChecks: true);
		}
	}

	public void SetID(BasePlayer player, string oldID, string newID, bool bypassChecks = false)
	{
		if (CanChangeID(player) && CanControl(player.userID) && (string.IsNullOrEmpty(oldID) || ComputerStation.IsValidIdentifier(oldID)) && ComputerStation.IsValidIdentifier(newID) && oldID == GetIdentifier())
		{
			Debug.Log((object)"SetID success!");
			UpdateIdentifier(newID);
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_RequestOpenRCPanel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanChangeID(player))
		{
			ClientRPC(RpcTarget.Player("CLIENT_OpenRCPanel", player), GetIdentifier());
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.rcEntity = Pool.Get<RCEntity>();
			info.msg.rcEntity.identifier = GetIdentifier();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.rcEntity != null && ComputerStation.IsValidIdentifier(info.msg.rcEntity.identifier))
		{
			UpdateIdentifier(info.msg.rcEntity.identifier);
		}
	}

	public virtual bool CanChangeID(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			if ((!player.CanBuild() || !player.IsBuildingAuthed() || !player.IsHoldingEntity<Hammer>()) && !player.IsAdmin)
			{
				return player.IsDeveloper;
			}
			return true;
		}
		return false;
	}

	public static bool IDInUse(string id)
	{
		return FindByID(id) != null;
	}

	public static IRemoteControllable FindByID(string id)
	{
		foreach (IRemoteControllable allControllable in allControllables)
		{
			if (allControllable != null && allControllable.GetIdentifier() == id)
			{
				return allControllable;
			}
		}
		return null;
	}

	public static bool InstallControllable(IRemoteControllable newControllable)
	{
		if (allControllables.Contains(newControllable))
		{
			return false;
		}
		allControllables.Add(newControllable);
		return true;
	}

	public static bool RemoveControllable(IRemoteControllable newControllable)
	{
		if (!allControllables.Contains(newControllable))
		{
			return false;
		}
		allControllables.Remove(newControllable);
		return true;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class RepairBench : StorageContainer
{
	public float maxConditionLostOnRepair = 0.2f;

	public GameObjectRef skinchangeEffect;

	public const float REPAIR_COST_FRACTION = 0.2f;

	private float nextSkinChangeAudioTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RepairBench.OnRpcMessage", 0);
		try
		{
			if (rpc == 1942825351 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ChangeSkin "));
				}
				TimeWarning val2 = TimeWarning.New("ChangeSkin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1942825351u, "ChangeSkin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ChangeSkin(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ChangeSkin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1178348163 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RepairItem "));
				}
				TimeWarning val2 = TimeWarning.New("RepairItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1178348163u, "RepairItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RepairItem(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RepairItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static float GetRepairFraction(Item itemToRepair)
	{
		return GetRepairFraction(itemToRepair.condition, itemToRepair.maxCondition);
	}

	public static float GetRepairFraction(float condition, float maxCondition)
	{
		return 1f - condition / maxCondition;
	}

	public static float RepairCostFraction(Item itemToRepair)
	{
		return GetRepairFraction(itemToRepair) * 0.2f;
	}

	public static float RepairCostFraction(float condition, float maxCondition)
	{
		return GetRepairFraction(condition, maxCondition) * 0.2f;
	}

	public static void GetRepairCostList(ItemBlueprint bp, List<ItemAmount> allIngredients)
	{
		ItemDefinition targetItem = bp.targetItem;
		ItemModRepair itemModRepair = ((targetItem != null) ? ((Component)targetItem).GetComponent<ItemModRepair>() : null);
		if ((Object)(object)itemModRepair != (Object)null && itemModRepair.canUseRepairBench)
		{
			return;
		}
		foreach (ItemAmount ingredient in bp.GetIngredients())
		{
			allIngredients.Add(new ItemAmount(ingredient.itemDef, ingredient.amount));
		}
		StripComponentRepairCost(allIngredients);
	}

	public static void StripComponentRepairCost(List<ItemAmount> allIngredients, float repairCostMultiplier = 1f)
	{
		if (allIngredients == null)
		{
			return;
		}
		for (int i = 0; i < allIngredients.Count; i++)
		{
			ItemAmount itemAmount = allIngredients[i];
			if (itemAmount.itemDef.category != ItemCategory.Component && !itemAmount.itemDef.treatAsComponentForRepairs)
			{
				continue;
			}
			if ((Object)(object)itemAmount.itemDef.Blueprint != (Object)null)
			{
				bool flag = false;
				ItemAmount itemAmount2 = itemAmount.itemDef.Blueprint.GetIngredients()[0];
				foreach (ItemAmount allIngredient in allIngredients)
				{
					if ((Object)(object)allIngredient.itemDef == (Object)(object)itemAmount2.itemDef)
					{
						allIngredient.amount += Mathf.Max(itemAmount2.amount * itemAmount.amount * repairCostMultiplier, 1f);
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					allIngredients.Add(new ItemAmount(itemAmount2.itemDef, Mathf.Max(itemAmount2.amount * itemAmount.amount * repairCostMultiplier, 1f)));
				}
			}
			allIngredients.RemoveAt(i);
			i--;
		}
	}

	public void debugprint(string toPrint)
	{
		if (Global.developer > 0)
		{
			Debug.LogWarning((object)toPrint);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void ChangeSkin(RPCMessage msg)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0717: Unknown result type (might be due to invalid IL or missing references)
		//IL_071c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		int inventoryId = msg.read.Int32();
		ItemId val = ((msg.read.Unread > 0) ? new ItemId(msg.read.UInt64()) : default(ItemId));
		bool isValid = ((ItemId)(ref val)).IsValid;
		bool flag = !isValid || Time.realtimeSinceStartup > nextSkinChangeAudioTime;
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || Interface.CallHook("OnItemSkinChange", (object)inventoryId, (object)slot, (object)this, (object)player) != null || (isValid && slot.uid != val))
		{
			return;
		}
		bool allSkinsUnlocked = player.AllSkinsUnlocked;
		bool allSkinsLocked = player.AllSkinsLocked;
		if (inventoryId != 0 && !allSkinsUnlocked && (allSkinsLocked || !player.blueprints.CheckSkinOwnership(inventoryId, player.userID)))
		{
			debugprint("RepairBench.ChangeSkin player does not have item :" + inventoryId + ":");
			return;
		}
		ulong Skin = ItemDefinition.FindSkin(slot.info.itemid, inventoryId);
		if (Skin == slot.skin && (Object)(object)slot.info.isRedirectOf == (Object)null)
		{
			debugprint("RepairBench.ChangeSkin cannot apply same skin twice : " + Skin + ": " + slot.skin);
			return;
		}
		ItemSkinDirectory.Skin skin = slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
		ItemDefinition itemDefinition = slot.info;
		int num = 0;
		if ((Object)(object)slot.info.isRedirectOf != (Object)null)
		{
			Skin = ItemDefinition.FindSkin(slot.info.isRedirectOf.itemid, inventoryId);
			skin = slot.info.isRedirectOf.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
			if ((Object)(object)skin.invItem == (Object)null)
			{
				if (((IEnumerable<IPlayerItemDefinition>)slot.info.isRedirectOf.skins2).FirstOrDefault((Func<IPlayerItemDefinition, bool>)((IPlayerItemDefinition x) => x.DefinitionId == inventoryId)) != null)
				{
					itemDefinition = slot.info.isRedirectOf;
					num = inventoryId;
				}
				else
				{
					itemDefinition = slot.info.isRedirectOf;
					num = 0;
				}
			}
			else
			{
				num = skin.invItem.id;
				if (skin.invItem is ItemSkin itemSkin)
				{
					if ((Object)(object)itemSkin.Redirect != (Object)null)
					{
						itemDefinition = itemSkin.Redirect;
						num = 0;
					}
					else if ((Object)(object)itemSkin.Redirect == (Object)null && (Object)(object)slot.info.isRedirectOf != (Object)null)
					{
						itemDefinition = slot.info.isRedirectOf;
					}
				}
			}
		}
		else if (slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin).invItem is ItemSkin itemSkin2 && (Object)(object)itemSkin2.Redirect != (Object)null)
		{
			itemDefinition = itemSkin2.Redirect;
		}
		if ((Object)(object)itemDefinition == (Object)(object)slot.info && (Object)(object)itemDefinition.isRedirectOf != (Object)null && num == 0)
		{
			return;
		}
		if (flag)
		{
			nextSkinChangeAudioTime = Time.realtimeSinceStartup + 0.75f;
		}
		if ((Object)(object)itemDefinition != (Object)(object)slot.info)
		{
			bool flag2 = false;
			flag2 = num != 0;
			float condition = slot.condition;
			float maxCondition = slot.maxCondition;
			int amount = slot.amount;
			int num2 = 0;
			int num3 = 0;
			ItemModContainerArmorSlot component = ((Component)slot.info).GetComponent<ItemModContainerArmorSlot>();
			if ((Object)(object)component != (Object)null && slot.contents != null)
			{
				num3 = slot.contents.capacity;
			}
			ItemDefinition ammoType = null;
			if ((Object)(object)slot.GetHeldEntity() != (Object)null && slot.GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)
			{
				num2 = baseProjectile.primaryMagazine.contents;
				ammoType = baseProjectile.primaryMagazine.ammoType;
			}
			if ((Object)(object)slot.GetHeldEntity() != (Object)null && slot.GetHeldEntity() is Chainsaw chainsaw)
			{
				num2 = chainsaw.ammo;
			}
			List<Item> list = Pool.Get<List<Item>>();
			if (slot.contents != null && slot.contents.itemList != null && slot.contents.itemList.Count > 0)
			{
				if (slot.contents.itemList.Count > list.Capacity)
				{
					list.Capacity = slot.contents.itemList.Count;
				}
				foreach (Item item2 in slot.contents.itemList)
				{
					list.Add(item2);
				}
				foreach (Item item3 in list)
				{
					item3.RemoveFromContainer();
				}
			}
			Item item = ItemManager.Create(itemDefinition, 1, 0uL);
			item.ownershipShares = slot.ownershipShares;
			slot.ownershipShares = null;
			slot.Remove();
			ItemManager.DoRemoves();
			item.MoveToContainer(base.inventory, 0, allowStack: false);
			item.maxCondition = maxCondition;
			item.condition = condition;
			item.amount = amount;
			if ((Object)(object)item.GetHeldEntity() != (Object)null && item.GetHeldEntity() is BaseProjectile baseProjectile2)
			{
				if (baseProjectile2.primaryMagazine != null)
				{
					baseProjectile2.SetAmmoCount(num2);
					baseProjectile2.primaryMagazine.ammoType = ammoType;
				}
				baseProjectile2.ForceModsChanged();
			}
			if ((Object)(object)item.GetHeldEntity() != (Object)null && item.GetHeldEntity() is Chainsaw chainsaw2)
			{
				chainsaw2.ammo = num2;
			}
			if (num3 > 0)
			{
				component = ((Component)item.info).GetComponent<ItemModContainerArmorSlot>();
				component.CreateAtCapacity(num3, item);
			}
			if (list.Count > 0 && item.contents != null)
			{
				if ((Object)(object)component != (Object)null)
				{
					for (int i = 0; i < list.Count; i++)
					{
						list[i]?.MoveToContainer(item.contents, i, allowStack: false);
					}
				}
				else
				{
					foreach (Item item4 in list)
					{
						item4.MoveToContainer(item.contents);
					}
				}
			}
			Pool.Free<Item>(ref list, false);
			if (flag2)
			{
				ApplySkinToItem(item, Skin);
			}
			Analytics.Azure.OnSkinChanged(player, this, item, Skin);
		}
		else
		{
			ApplySkinToItem(slot, Skin);
			Analytics.Azure.OnSkinChanged(player, this, slot, Skin);
		}
		if (flag && skinchangeEffect.isValid)
		{
			Effect.server.Run(skinchangeEffect.resourcePath, this, 0u, new Vector3(0f, 1.5f, 0f), Vector3.zero);
		}
	}

	private void ApplySkinToItem(Item item, ulong Skin)
	{
		item.skin = Skin;
		item.MarkDirty();
		BaseEntity heldEntity = item.GetHeldEntity();
		if ((Object)(object)heldEntity != (Object)null)
		{
			heldEntity.skinID = Skin;
			heldEntity.SendNetworkUpdate();
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RepairItem(RPCMessage msg)
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot != null)
		{
			BasePlayer player = msg.player;
			float conditionLost = maxConditionLostOnRepair;
			ItemModRepair component = ((Component)slot.info).GetComponent<ItemModRepair>();
			if ((Object)(object)component != (Object)null)
			{
				conditionLost = component.conditionLost;
			}
			RepairAnItem(slot, player, this, conditionLost, mustKnowBlueprint: true);
		}
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return 0;
	}

	public static void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)
	{
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		if (itemToRepair == null)
		{
			return;
		}
		ItemDefinition info = itemToRepair.info;
		ItemBlueprint blueprint = info.Blueprint;
		if (!Object.op_Implicit((Object)(object)blueprint))
		{
			return;
		}
		ItemModRepair component = ((Component)itemToRepair.info).GetComponent<ItemModRepair>();
		if (!info.condition.repairable || itemToRepair.condition == itemToRepair.maxCondition)
		{
			return;
		}
		if (mustKnowBlueprint)
		{
			ItemDefinition itemDefinition = (((Object)(object)info.isRedirectOf != (Object)null) ? info.isRedirectOf : info);
			bool flag = player.blueprints.HasUnlocked(itemDefinition) || ((Object)(object)itemDefinition.Blueprint != (Object)null && !itemDefinition.Blueprint.isResearchable);
			if (!flag && (Object)(object)BaseGameMode.svActiveGameMode != (Object)null && BaseGameMode.svActiveGameMode.canRepairIfCraftingBanned && !itemDefinition.IsAllowed((EraRestriction)4))
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
		}
		if (Interface.CallHook("OnItemRepair", (object)player, (object)itemToRepair) != null)
		{
			return;
		}
		float num = RepairCostFraction(itemToRepair);
		bool flag2 = false;
		List<ItemAmount> list = Pool.Get<List<ItemAmount>>();
		GetRepairCostList(blueprint, list);
		foreach (ItemAmount item in list)
		{
			if (item.itemDef.category != ItemCategory.Component)
			{
				int amount = player.inventory.GetAmount(item.itemDef.itemid);
				if (Mathf.CeilToInt(item.amount * num) > amount)
				{
					flag2 = true;
					break;
				}
			}
		}
		if (flag2)
		{
			Pool.FreeUnmanaged<ItemAmount>(ref list);
			return;
		}
		foreach (ItemAmount item2 in list)
		{
			if (item2.itemDef.category != ItemCategory.Component)
			{
				int amount2 = Mathf.CeilToInt(item2.amount * num);
				player.inventory.Take(null, item2.itemid, amount2);
				Analytics.Azure.LogResource(Analytics.Azure.ResourceMode.Consumed, "repair", item2.itemDef.shortname, amount2, repairBenchEntity, null, safezone: false, null, 0uL, null, itemToRepair, null, 0uL);
			}
		}
		Pool.FreeUnmanaged<ItemAmount>(ref list);
		float conditionNormalized = itemToRepair.conditionNormalized;
		float maxConditionNormalized = itemToRepair.maxConditionNormalized;
		itemToRepair.DoRepair(maxConditionLostOnRepair);
		Analytics.Azure.OnItemRepaired(player, repairBenchEntity, itemToRepair, conditionNormalized, maxConditionNormalized);
		if (Global.developer > 0)
		{
			Debug.Log((object)("Item repaired! condition : " + itemToRepair.condition + "/" + itemToRepair.maxCondition));
		}
		string strName = "assets/bundled/prefabs/fx/repairbench/itemrepair.prefab";
		if ((Object)(object)component != (Object)null && (Object)(object)component.successEffect?.Get() != (Object)null)
		{
			strName = component.successEffect.resourcePath;
		}
		Effect.server.Run(strName, repairBenchEntity, 0u, Vector3.zero, Vector3.zero);
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class ResearchTable : StorageContainer
{
	public enum ResearchType
	{
		ResearchTable,
		TechTree
	}

	[NonSerialized]
	public float researchFinishedTime;

	public float researchCostFraction = 1f;

	public float researchDuration = 10f;

	public int requiredPaper = 10;

	public GameObjectRef researchStartEffect;

	public GameObjectRef researchFailEffect;

	public GameObjectRef researchSuccessEffect;

	public ItemDefinition researchResource;

	public BasePlayer user;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ResearchTable.OnRpcMessage", 0);
		try
		{
			if (rpc == 3177710095u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoResearch "));
				}
				TimeWarning val2 = TimeWarning.New("DoResearch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3177710095u, "DoResearch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoResearch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoResearch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		researchFinishedTime = 0f;
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		if (item.info.shortname == "scrap")
		{
			Item slot = base.inventory.GetSlot(1);
			if (slot == null)
			{
				return 1;
			}
			if (slot.amount < item.MaxStackable())
			{
				return 1;
			}
		}
		return base.GetIdealSlot(player, container, item);
	}

	public bool IsResearching()
	{
		return HasFlag(Flags.On);
	}

	public int RarityMultiplier(Rarity rarity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Invalid comparison between Unknown and I4
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Invalid comparison between Unknown and I4
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Invalid comparison between Unknown and I4
		if ((int)rarity == 1)
		{
			return 20;
		}
		if ((int)rarity == 2)
		{
			return 15;
		}
		if ((int)rarity == 3)
		{
			return 10;
		}
		return 5;
	}

	public int GetBlueprintStacksize(Item sourceItem)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		int result = RarityMultiplier(sourceItem.info.rarity);
		if (sourceItem.info.category == ItemCategory.Ammunition)
		{
			result = Mathf.FloorToInt((float)sourceItem.MaxStackable() / (float)sourceItem.info.Blueprint.amountToCreate) * 2;
		}
		return result;
	}

	public static int ScrapForResearch(Item item)
	{
		object obj = Interface.CallHook("OnResearchCostDetermine", (object)item);
		if (obj is int)
		{
			return (int)obj;
		}
		return ScrapForResearch(item.info);
	}

	public static int ScrapForResearch(ItemDefinition info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Invalid comparison between Unknown and I4
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Invalid comparison between Unknown and I4
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Invalid comparison between Unknown and I4
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Invalid comparison between Unknown and I4
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnResearchCostDetermine", (object)info);
		if (obj is int)
		{
			return (int)obj;
		}
		if ((Object)(object)info.isRedirectOf != (Object)null)
		{
			return ScrapForResearch(info.isRedirectOf);
		}
		int result = 0;
		if ((int)info.rarity == 1)
		{
			result = 15;
		}
		if ((int)info.rarity == 2)
		{
			result = 30;
		}
		if ((int)info.rarity == 3)
		{
			result = 60;
		}
		if ((int)info.rarity == 4 || (int)info.rarity == 0)
		{
			result = 120;
		}
		ItemBlueprint itemBlueprint = ItemManager.FindBlueprint(info);
		if ((Object)(object)itemBlueprint != (Object)null && itemBlueprint.defaultBlueprint)
		{
			return ConVar.Server.defaultBlueprintResearchCost;
		}
		return result;
	}

	public bool IsItemResearchable(Item item)
	{
		ItemDefinition itemDefinition = (((Object)(object)item.info.isRedirectOf != (Object)null) ? item.info.isRedirectOf : item.info);
		if (!itemDefinition.IsAllowed((EraRestriction)4))
		{
			return false;
		}
		ItemBlueprint itemBlueprint = ItemManager.FindBlueprint(itemDefinition);
		if ((Object)(object)itemBlueprint != (Object)null && itemBlueprint.defaultBlueprint)
		{
			return true;
		}
		if ((Object)(object)itemBlueprint == (Object)null || !itemBlueprint.isResearchable)
		{
			return false;
		}
		return true;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.canAcceptItem = ItemFilter;
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (targetSlot == 1 && (Object)(object)item.info != (Object)(object)researchResource)
		{
			return false;
		}
		return base.ItemFilter(item, targetSlot);
	}

	public Item GetTargetItem()
	{
		return base.inventory.GetSlot(0);
	}

	public Item GetScrapItem()
	{
		Item slot = base.inventory.GetSlot(1);
		if (slot == null || (Object)(object)slot.info != (Object)(object)researchResource)
		{
			return null;
		}
		return slot;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (HasFlag(Flags.On))
		{
			((FacepunchBehaviour)this).Invoke((Action)ResearchAttemptFinished, researchDuration);
		}
		base.inventory.SetLocked(isLocked: false);
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		user = player;
		return base.PlayerOpenLoot(player);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		user = null;
		base.PlayerStoppedLooting(player);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void DoResearch(RPCMessage msg)
	{
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", (object)player, (object)targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", (object)this, (object)targetItem, (object)player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = Time.realtimeSinceStartup + researchDuration;
			((FacepunchBehaviour)this).Invoke((Action)ResearchAttemptFinished, researchDuration);
			base.inventory.SetLocked(isLocked: true);
			int scrapCost = ScrapForResearch(targetItem);
			Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

	public void ResearchAttemptFinished()
	{
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		Item targetItem = GetTargetItem();
		Item scrapItem = GetScrapItem();
		if (targetItem != null && scrapItem != null)
		{
			int num = ScrapForResearch(targetItem);
			object obj = Interface.CallHook("OnItemResearched", (object)this, (object)num);
			if (obj is int)
			{
				num = (int)obj;
			}
			if (scrapItem.amount >= num)
			{
				if (scrapItem.amount == num)
				{
					base.inventory.Remove(scrapItem);
					scrapItem.RemoveFromContainer();
					scrapItem.Remove();
				}
				else
				{
					scrapItem.UseItem(num);
				}
				base.inventory.Remove(targetItem);
				targetItem.Remove();
				Item item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);
				if ((Object)(object)base.LastLootedByPlayer != (Object)null)
				{
					item.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.ResearchTable);
				}
				item.blueprintTarget = (((Object)(object)targetItem.info.isRedirectOf != (Object)null) ? targetItem.info.isRedirectOf.itemid : targetItem.info.itemid);
				if (!item.MoveToContainer(base.inventory, 0))
				{
					item.Drop(GetDropPosition(), GetDropVelocity());
				}
				if (researchSuccessEffect.isValid)
				{
					Effect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		SendNetworkUpdateImmediate();
		if ((Object)(object)user != (Object)null)
		{
			user.inventory.loot.SendImmediate();
		}
		EndResearch();
	}

	public void CancelResearch()
	{
	}

	public void EndResearch()
	{
		base.inventory.SetLocked(isLocked: false);
		SetFlag(Flags.On, b: false);
		researchFinishedTime = 0f;
		SendNetworkUpdate();
		if ((Object)(object)user != (Object)null)
		{
			user.inventory.loot.SendImmediate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.researchTable = Pool.Get<ResearchTable>();
		info.msg.researchTable.researchTimeLeft = researchFinishedTime - Time.realtimeSinceStartup;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.researchTable != null)
		{
			researchFinishedTime = Time.realtimeSinceStartup + info.msg.researchTable.researchTimeLeft;
		}
	}
}


public enum ResearchType
{
	ResearchTable,
	TechTree
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class ResourceContainer : EntityComponent<BaseEntity>
{
	public bool lootable = true;

	[NonSerialized]
	public ItemContainer container;

	[NonSerialized]
	public float lastAccessTime;

	public int accessedSecondsAgo => (int)(Time.realtimeSinceStartup - lastAccessTime);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ResourceContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 548378753 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartLootingContainer "));
				}
				TimeWarning val2 = TimeWarning.New("StartLootingContainer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!BaseEntity.RPC_Server.IsVisible.Test(548378753u, "StartLootingContainer", GetBaseEntity(), player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							BaseEntity.RPCMessage rPCMessage = default(BaseEntity.RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							BaseEntity.RPCMessage msg2 = rPCMessage;
							StartLootingContainer(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in StartLootingContainer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[BaseEntity.RPC_Server.IsVisible(3f)]
	[BaseEntity.RPC_Server]
	private void StartLootingContainer(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (Object.op_Implicit((Object)(object)player) && player.CanInteract() && lootable && Interface.CallHook("CanLootEntity", (object)player, (object)this) == null && player.inventory.loot.StartLootingEntity(base.baseEntity))
		{
			lastAccessTime = Time.realtimeSinceStartup;
			player.inventory.loot.AddContainer(container);
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class RFBroadcaster : IOEntity, IRFObject
{
	public int frequency;

	public GameObjectRef frequencyPanelPrefab;

	public const Flags Flag_Broadcasting = Flags.Reserved3;

	public bool playerUsable = true;

	private float nextChangeTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RFBroadcaster.OnRpcMessage", 0);
		try
		{
			if (rpc == 1052196345 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestOpenPanel "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestOpenPanel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_RequestOpenPanel(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_RequestOpenPanel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2778616053u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSetFrequency "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSetFrequency", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2778616053u, "ServerSetFrequency", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2778616053u, "ServerSetFrequency", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ServerSetFrequency(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ServerSetFrequency");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public int GetFrequency()
	{
		return frequency;
	}

	public override bool WantsPower(int inputIndex)
	{
		return true;
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public float GetMaxRange()
	{
		return float.PositiveInfinity;
	}

	public void RFSignalUpdate(bool on)
	{
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public void ServerSetFrequency(RPCMessage msg)
	{
		if (!CanChangeFrequency(msg.player) || Time.time < nextChangeTime)
		{
			return;
		}
		nextChangeTime = Time.time + 2f;
		int freq = msg.read.Int32();
		freq = RFManager.ClampFrequency(freq);
		if (RFManager.IsReserved(freq))
		{
			RFManager.ReserveErrorPrint(msg.player);
			return;
		}
		RFManager.ChangeFrequency(frequency, freq, this, isListener: false, IsPowered());
		if (Interface.CallHook("OnRfFrequencyChange", (object)this, (object)freq, (object)msg.player) == null)
		{
			frequency = freq;
			MarkDirty();
			SendNetworkUpdate();
			Hurt(MaxHealth() * 0.01f, DamageType.Decay, this);
			Interface.CallHook("OnRfFrequencyChanged", (object)this, (object)freq, (object)msg.player);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.ioEntity.genericInt1 = frequency;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			frequency = info.msg.ioEntity.genericInt1;
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		base.UpdateFromInput(inputAmount, inputSlot);
		if (inputAmount > 0)
		{
			RFManager.AddBroadcaster(frequency, this);
			SetFlag(Flags.Reserved3, b: true, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
		else
		{
			StopBroadcasting();
		}
	}

	public void StopBroadcasting()
	{
		SetFlag(Flags.Reserved3, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		RFManager.RemoveBroadcaster(frequency, this);
	}

	internal override void DoServerDestroy()
	{
		RFManager.RemoveBroadcaster(frequency, this);
		base.DoServerDestroy();
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public void SERVER_RequestOpenPanel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanChangeFrequency(player))
		{
			ClientRPC(RpcTarget.Player("CLIENT_OpenPanel", player), frequency);
		}
	}

	private bool CanChangeFrequency(BasePlayer player)
	{
		if (playerUsable && (Object)(object)player != (Object)null)
		{
			return player.CanBuild();
		}
		return false;
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class RFReceiver : IOEntity, IRFObject
{
	public int frequency;

	public GameObjectRef frequencyPanelPrefab;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RFReceiver.OnRpcMessage", 0);
		try
		{
			if (rpc == 1052196345 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestOpenPanel "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestOpenPanel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1052196345u, "SERVER_RequestOpenPanel", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_RequestOpenPanel(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_RequestOpenPanel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2778616053u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSetFrequency "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSetFrequency", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2778616053u, "ServerSetFrequency", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2778616053u, "ServerSetFrequency", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ServerSetFrequency(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ServerSetFrequency");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public int GetFrequency()
	{
		return frequency;
	}

	public override bool WantsPower(int inputIndex)
	{
		return IsOn();
	}

	public override void ResetIOState()
	{
		SetFlag(Flags.On, b: false);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsOn())
		{
			return 0;
		}
		return GetCurrentEnergy();
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public float GetMaxRange()
	{
		return 100000f;
	}

	internal override void DoServerDestroy()
	{
		RFManager.RemoveListener(frequency, this);
		base.DoServerDestroy();
	}

	public void RFSignalUpdate(bool on)
	{
		if (!base.IsDestroyed && IsOn() != on && !(!IsPowered() && on))
		{
			SetFlag(Flags.On, on, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
			MarkDirty();
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		base.UpdateFromInput(inputAmount, inputSlot);
		if (inputAmount > 0 && !IsOn())
		{
			RFManager.AddListener(frequency, this);
		}
		else if (inputAmount == 0)
		{
			RFManager.RemoveListener(frequency, this);
			SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	public void ServerSetFrequency(RPCMessage msg)
	{
		if (!((Object)(object)msg.player == (Object)null) && msg.player.CanBuild())
		{
			int num = msg.read.Int32();
			if (Interface.CallHook("OnRfFrequencyChange", (object)this, (object)num, (object)msg.player) == null)
			{
				num = RFManager.ClampFrequency(num);
				RFManager.ChangeFrequency(frequency, num, this, isListener: true);
				frequency = num;
				MarkDirty();
				SendNetworkUpdate();
				Interface.CallHook("OnRfFrequencyChanged", (object)this, (object)num, (object)msg.player);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	public void SERVER_RequestOpenPanel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanChangeFrequency(player))
		{
			ClientRPC(RpcTarget.Player("CLIENT_OpenPanel", player), frequency);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.ioEntity.genericInt1 = frequency;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			frequency = info.msg.ioEntity.genericInt1;
			if (info.fromDisk && base.isServer)
			{
				RFSignalUpdate(on: false);
			}
		}
	}

	private bool CanChangeFrequency(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			return player.CanBuild();
		}
		return false;
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class RFTimedExplosive : TimedExplosive, IRFObject
{
	private const float pickupTime = 5f;

	public SoundPlayer beepLoop;

	private ulong creatorPlayerID;

	public ItemDefinition pickupDefinition;

	public float minutesUntilDecayed = 1440f;

	private float startPickupTime;

	private int RFFrequency = -1;

	private float decayTickDuration = 3600f;

	private float minutesDecayed;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RFTimedExplosive.OnRpcMessage", 0);
		try
		{
			if (rpc == 2778075470u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Pickup "));
				}
				TimeWarning val2 = TimeWarning.New("Pickup", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2778075470u, "Pickup", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Pickup(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Pickup");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2145528377 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - PickupTimer "));
				}
				TimeWarning val2 = TimeWarning.New("PickupTimer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2145528377u, "PickupTimer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							PickupTimer(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in PickupTimer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public float GetMaxRange()
	{
		return float.PositiveInfinity;
	}

	public void RFSignalUpdate(bool on)
	{
		if (IsArmed() && on && !((FacepunchBehaviour)this).IsInvoking((Action)Explode))
		{
			((FacepunchBehaviour)this).Invoke((Action)Explode, Random.Range(0f, 0.2f));
		}
	}

	public void SetFrequency(int newFreq)
	{
		RFManager.RemoveListener(RFFrequency, this);
		RFFrequency = newFreq;
		if (RFFrequency > 0)
		{
			RFManager.AddListener(RFFrequency, this);
		}
	}

	public int GetFrequency()
	{
		return RFFrequency;
	}

	public override void SetFuse(float fuseLength)
	{
		if (!base.isServer)
		{
			return;
		}
		if (GetFrequency() > 0)
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)Explode))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Explode);
			}
			((FacepunchBehaviour)this).Invoke((Action)ArmRF, fuseLength);
			SetFlag(Flags.Reserved1, b: true, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, b: true);
		}
		else
		{
			base.SetFuse(fuseLength);
		}
	}

	public void ArmRF()
	{
		SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, b: false);
		SendNetworkUpdate();
	}

	public void DisarmRF()
	{
		SetFlag(Flags.On, b: false);
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.explosive == null)
		{
			info.msg.explosive = Pool.Get<TimedExplosive>();
		}
		if (info.forDisk)
		{
			info.msg.explosive.freq = GetFrequency();
		}
		info.msg.explosive.creatorID = creatorPlayerID;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFrequency(RFFrequency);
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayCheck, decayTickDuration, decayTickDuration, 10f);
	}

	public void DecayCheck()
	{
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
		BasePlayer basePlayer = BasePlayer.FindByID(creatorPlayerID);
		if ((Object)(object)basePlayer != (Object)null && ((Object)(object)buildingPrivilege == (Object)null || !buildingPrivilege.IsAuthed(basePlayer)))
		{
			minutesDecayed += decayTickDuration / 60f;
		}
		if (minutesDecayed >= minutesUntilDecayed)
		{
			Kill();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (RFFrequency > 0)
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)Explode))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Explode);
			}
			SetFrequency(RFFrequency);
			ArmRF();
		}
	}

	internal override void DoServerDestroy()
	{
		if (RFFrequency > 0)
		{
			RFManager.RemoveListener(RFFrequency, this);
		}
		base.DoServerDestroy();
	}

	public void ChangeFrequency(int newFreq)
	{
		RFManager.ChangeFrequency(RFFrequency, newFreq, this, isListener: true);
		RFFrequency = newFreq;
	}

	public override void SetCreatorEntity(BaseEntity newCreatorEntity)
	{
		base.SetCreatorEntity(newCreatorEntity);
		BasePlayer component = ((Component)newCreatorEntity).GetComponent<BasePlayer>();
		if (Object.op_Implicit((Object)(object)component))
		{
			creatorPlayerID = component.userID;
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Pickup(RPCMessage msg)
	{
		if (Interface.CallHook("ICanPickupEntity", (object)msg.player, (object)this) != null || !msg.player.CanInteract() || !IsArmed())
		{
			return;
		}
		Item item = ItemManager.Create(pickupDefinition, 1, 0uL);
		if (item != null)
		{
			if (ItemOwnership.IsValid())
			{
				item.SetItemOwnership(ItemOwnership);
			}
			if (!(Mathf.Abs(startPickupTime + 5f - Time.realtimeSinceStartup) > ConVar.AntiHack.rpc_timer_forgiveness))
			{
				item.instanceData.dataInt = GetFrequency();
				item.SetFlag(Item.Flag.IsOn, IsArmed());
				msg.player.GiveItem(item, GiveItemReason.PickedUp);
				Kill();
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void PickupTimer(RPCMessage msg)
	{
		if (msg.player.CanInteract() && IsArmed())
		{
			startPickupTime = Time.realtimeSinceStartup;
		}
	}

	public bool IsArmed()
	{
		return HasFlag(Flags.On);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.explosive == null)
		{
			return;
		}
		creatorPlayerID = info.msg.explosive.creatorID;
		if (base.isServer)
		{
			if (info.fromDisk)
			{
				RFFrequency = info.msg.explosive.freq;
			}
			creatorEntity = BasePlayer.FindByID(creatorPlayerID);
		}
	}

	public bool CanPickup(BasePlayer player)
	{
		return IsArmed();
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class RHIB : MotorRowboat
{
	[Header("IK")]
	public bool useLeftHand = true;

	public Transform handLerpTarget;

	public Transform steeringWheelLeftHandTarget;

	public Transform steeringWheelRightHandTarget;

	public Transform throttleHandTarget;

	[Header("Throttle Animation")]
	public Transform throttleTransform;

	public bool usePositionAnimation = true;

	[Header("Throttle Animation - Position")]
	public Vector3 maxThrottle;

	public Vector3 noThrottle;

	public Vector3 minThrottle;

	[Header("Throttle Animation - Rotation")]
	public Vector3 maxThrottleRotation;

	public Vector3 noThrottleRotation;

	public Vector3 minThrottleRotation;

	[Header("Multi Propeller Animation")]
	public Transform[] multiPropellerRotate;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float rhibpopulation;

	private float targetGasPedal;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RHIB.OnRpcMessage", 0);
		try
		{
			if (rpc == 1382282393 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_Release "));
				}
				TimeWarning val2 = TimeWarning.New("Server_Release", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1382282393u, "Server_Release", this, player, 6f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_Release(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_Release");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(6f)]
	public void Server_Release(RPCMessage msg)
	{
		if (!((Object)(object)GetParentEntity() == (Object)null))
		{
			SetParent(null, worldPositionStays: true, sendImmediate: true);
			SetToNonKinematic();
		}
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("RHIB.VehicleFixedUpdate", 0);
		try
		{
			gasPedal = Mathf.MoveTowards(gasPedal, targetGasPedal, Time.fixedDeltaTime * 1f);
			base.VehicleFixedUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override bool EngineOn()
	{
		return base.EngineOn();
	}

	public override void LightToggle(BasePlayer player)
	{
		base.LightToggle(player);
		BasePlayer driver = GetDriver();
		if (!((Object)(object)driver == (Object)null) && driver.userID.Get() == player.userID.Get())
		{
			SetFlag(Flags.Reserved5, !HasFlag(Flags.Reserved5));
		}
	}

	public override void DriverInput(InputState inputState, BasePlayer player)
	{
		base.DriverInput(inputState, player);
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			targetGasPedal = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			targetGasPedal = -0.5f;
		}
		else
		{
			targetGasPedal = 0f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			steering = 1f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			steering = -1f;
		}
		else
		{
			steering = 0f;
		}
	}

	public void AddFuel(int amount)
	{
		fuelSystem.AddFuel(amount);
	}

	public void AdminKillNoLoot(bool killMountedNPCs = true)
	{
		StorageContainer storageContainer = storageUnitInstance.Get(base.isServer);
		if ((Object)(object)storageContainer != (Object)null)
		{
			storageContainer.dropsLoot = false;
		}
		if (killMountedNPCs)
		{
			for (int i = 0; i < mountPoints.Count; i++)
			{
				BaseMountable mountable = mountPoints[i].mountable;
				if (!((Object)(object)mountable == (Object)null))
				{
					BasePlayer mounted = mountable.GetMounted();
					if ((Object)(object)mounted != (Object)null && mounted is HumanNPC humanNPC && (Object)(object)humanNPC != (Object)null)
					{
						humanNPC.AdminKill();
					}
				}
			}
		}
		AdminKill();
	}

	public void KillMountedNPCs()
	{
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using FIMSpace.FProceduralAnimation;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class RidableHorse : BaseVehicle, IInventoryProvider, IMedicalToolTarget, IDetector, HitchTrough.IHitchable, TriggerHurtNotChild.IHurtTriggerUser, IAnimalRagdollCollisionReceiver, ITowing
{
	public enum GaitType : byte
	{
		Walk,
		Trot,
		Canter,
		Gallop
	}

	[Serializable]
	public struct Gait
	{
		public GaitType gaitType;

		public float minSpeed;

		public float maxSpeed;

		public float accelerationForce;

		public float brakingForce;

		public float turnSpeed;

		public float staminaReplenishRatio;

		public bool equipmentScalesMaxSpeed;

		public bool breedScalesMaxSpeed;
	}

	[Serializable]
	public struct PurchaseOption
	{
		public ItemDefinition tokenItem;

		public Phrase title;

		public Phrase description;

		public Sprite icon;

		public int order;
	}

	public enum HorseAvoidanceState
	{
		Normal,
		AvoidingObstacle
	}

	[Header("Breed")]
	public HorseBreed[] breeds;

	public SkinnedMeshRenderer[] bodyRenderers;

	public SkinnedMeshRenderer[] hairRenderers;

	private int currentBreedIndex = -1;

	public HorseBreed currentBreed;

	public FakePhysicsRope leadingRope;

	public FakePhysicsRope leadingRope2;

	[Header("Container")]
	public ItemDefinition onlyAllowedItem;

	public ItemContainer.ContentsType allowedContents = ItemContainer.ContentsType.Generic;

	[Space]
	public int maxStackSize;

	public int numStorageSlots;

	public int equipmentSlots = 4;

	public string lootPanelName = "animal";

	public string storagePanelName = "animal-storage";

	public bool needsBuildingPrivilegeToUse;

	public bool isLootable = true;

	public ItemContainer storageInventory;

	public ItemContainer equipmentInventory;

	public ProtectionProperties riderProtection;

	public ProtectionProperties baseHorseProtection;

	public float equipmentSpeedMod;

	[SerializeField]
	[Header("Horse")]
	private Animator animator;

	[SerializeField]
	private Transform centreOfMassTransform;

	[SerializeField]
	private RidableHorseAudio horseAudio;

	[SerializeField]
	private RidableHorseAnimation horseAnimation;

	[SerializeField]
	private LegsAnimator serverLegsAnimator;

	[SerializeField]
	private ScaleBySpeed scaleBySpeedWater;

	public WheelCollider wheelCollider;

	public GameObjectRef corpsePrefab;

	[Space]
	public Collider playerServerCollider;

	public Collider playerServerColliderRear;

	public CapsuleCollider clippingMountCheckCollider;

	public Gait[] gaits;

	public GaitType currentGait;

	public float gaitProgressionInterval = 1f;

	public float gravity = 10f;

	public float waterGravity = 1f;

	public float groundAlignmentSpeed = 50f;

	public float roadSpeedBonus = 1f;

	[Space]
	public float reverseSpeedFactor = 0.5f;

	public float reverseAccelerationForce = 4000f;

	[Space]
	public float rotationResponsiveness = 1f;

	[Tooltip("The factor applied to rotationResponsiveness, based on the current speed ratio (0 = stopped, 1 = full speed)")]
	public AnimationCurve rotationResponsivenessCurve;

	public Transform[] groundSampleOffsets;

	public Vector2 minMaxSlopeAngle = new Vector2(10f, 60f);

	public AnimationCurve slopeAngleSpeedFactor;

	[SerializeField]
	[Header("Collision Damage")]
	[Space]
	private GameObjectRef collisionEffect;

	[SerializeField]
	[Tooltip("Ignore low magnitude so e.g. Players running into stationary vehicles doesn't trigger damage or FX")]
	private float minCollisionDamageForce = 20000f;

	[SerializeField]
	[Tooltip("Cap max magnitude so unusual events can't cause mega damage")]
	private float maxCollisionDamageForce = 2500000f;

	[SerializeField]
	[Tooltip("Adjust this away from 1.0 if collision damage to this vehicle seems too high or low")]
	private float collisionDamageMultiplier = 1f;

	[SerializeField]
	private float playerDamageThreshold = 40f;

	[SerializeField]
	private float playerRagdollThreshold = 75f;

	[SerializeField]
	private float maxAirTimeBeforeRagdoll = 1.5f;

	[Header("Towing")]
	public TriggerTowing towingTrigger;

	public Transform towingPoint;

	public TowingVisuals towingVisuals;

	private NetworkableId towingEntityId;

	public GameObjectRef towingAttachEffect;

	public GameObjectRef towingDetachEffect;

	[SerializeField]
	private float towingAccelerationBoost = 2f;

	[SerializeField]
	private float towingMaxSpeedBoost = 1f;

	[SerializeField]
	private GaitType maxTowingGait = GaitType.Trot;

	[Header("Stamina")]
	public float currentStamina = 10f;

	public float currentMaxStamina = 10f;

	public float maxStamina = 20f;

	public float staminaCoreLossRatio = 0.1f;

	public float staminaCoreSpeedBonus = 3f;

	public float calorieToStaminaRatio = 0.1f;

	public float hydrationToStaminaRatio = 0.5f;

	public float maxStaminaCoreFromWater = 0.5f;

	[Header("Purchase")]
	public List<PurchaseOption> PurchaseOptions;

	[Header("Saddle")]
	public Phrase SwapToSingleTitle;

	public Phrase SwapToSingleDescription;

	public Sprite SwapToSingleIcon;

	public Phrase SwapToDoubleTitle;

	public Phrase SwapToDoubleDescription;

	public Sprite SwapToDoubleIcon;

	[HideInInspector]
	[SerializeField]
	protected bool[] hasItemTokenCache;

	[Space]
	public SoundPlayer standSound;

	public SoundPlayer slidingSound;

	private TimeSince timeSinceSlidingSoundPlayed;

	public ParticleSystemContainer skidDust;

	public GameObjectRef ragdollPrefab;

	[SerializeField]
	[Header("Pulling")]
	private List<ModifierDefintion> pullingPlayerModifiers;

	[Header("Avoidance")]
	public float avoidanceSphereRadius = 0.5f;

	public Vector2 avoidanceDetectionDistance = new Vector2(3f, 8f);

	public LayerMask avoidanceObstacleMask;

	[Header("Sliding")]
	public float groundAngleSlideThresholdForced = 50f;

	public float groundAngleSlideThreshold = 37f;

	public float groundAngleToRecoverFromSlide = 24f;

	public float normalVariationSlideThreshold = 2.5f;

	[HideInInspector]
	public float normalVariation;

	[Min(0f)]
	[Header("Healing")]
	public float healingMultiplier = 4f;

	[Tooltip("How much stamina to replenish when healing. Value is not final - scaled further if we have a high stamina core.")]
	[Min(0f)]
	public float staminaReplenishAmount = 1f;

	public ItemDefinition[] prohibitedMedicalItems = Array.Empty<ItemDefinition>();

	public const Flags Flag_ForSale = Flags.Reserved2;

	public const Flags Flag_Hitched = Flags.Reserved3;

	public const Flags Flag_HideHair = Flags.Reserved4;

	public const Flags Flag_WoodArmor = Flags.Reserved5;

	public const Flags Flag_RoadsignArmor = Flags.Reserved6;

	public const Flags Flag_LNYArmor = Flags.Unused23;

	public const Flags Flag_Lead = Flags.Reserved16;

	public const Flags Flag_HasSingleSaddle = Flags.Reserved9;

	public const Flags Flag_HasDoubleSaddle = Flags.Reserved10;

	public const Flags Flag_IsRagdolling = Flags.Reserved12;

	public const Flags Flag_IsSwimming = Flags.Reserved13;

	public const Flags Flag_IsSliding = Flags.Reserved18;

	public const Flags Flag_IsInWater = Flags.Reserved19;

	private static readonly Phrase TowAngleErrorPhrase = new Phrase("horse_tow_error", "Straighten up to tow");

	private NetworkableId playerLeadingId;

	[ServerVar(Saved = true, ClientAdmin = true)]
	public static bool debug = false;

	[ServerVar(Saved = true, ClientAdmin = true)]
	public static bool autoAvoidance = true;

	[ServerVar(Saved = true, ClientAdmin = true, Default = "1")]
	public static bool throttledGroundAngleUpdate = true;

	[ServerVar(Saved = true, ClientAdmin = true, Default = "0.05")]
	public static float groundAngleUpdateRate = 0.05f;

	[ServerVar(Help = "How long before a horse dies unattended")]
	public static float decayMinutes = 180f;

	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 2f;

	[Header("Bones")]
	public Transform rootBone;

	public Transform[] allBones;

	private static Vector3[] bonesInitialLocalPos;

	[Header("Dung")]
	public TriggerBase foodTrigger;

	public ItemDefinition dungItem;

	public Transform dungSpawnPoint;

	public float caloriesToDigestPerHour = 100f;

	public float dungProducedPerCalorie = 0.1f;

	[NonSerialized]
	public HorseModifiers modifiers;

	[Help("Scale all rideable animal dung production rates by this value. 0 will disable dung production.")]
	[ServerVar]
	public static float dungTimeScale = 1f;

	private float nextEatTime;

	private float lastEatTime = float.NegativeInfinity;

	private float pendingDungCalories;

	private float dungProduction;

	public HitchTrough currentHitch;

	private VehicleTerrainHandler terrainHandler;

	private readonly Dictionary<BaseEntity, float> damageSinceLastTick = new Dictionary<BaseEntity, float>();

	private float nextCollisionDamageTime;

	private float steerInput;

	private float steerInputDownTime;

	private float throttleInput;

	private bool forwardInputDown;

	private bool backwardInputDown;

	private bool duckInputDown;

	private float doubleTapTime = 0.25f;

	private float lastDuckTapTime = -1f;

	private bool duckDoubleTapped;

	private float sprintInputHoldTime;

	private bool sprintInputJustPressed;

	private Vector3 targetUp = Vector3.up;

	private Vector3 averagedUp = Vector3.up;

	private float groundAngle;

	protected bool onIdealTerrain;

	protected bool onWaterTopology;

	private float nextTerrainCheckTime;

	private float nextAutoAvoidanceCheckTime;

	private float nextGroundNormalCheckTime;

	private TimeSince timeSinceWaterCheck;

	private TimeSince timeSinceDrowningDamage;

	private bool wasSleeping;

	private float lastMovingTime;

	private const float SLEEP_DELAY = 5f;

	private const float SLEEP_SPEED = 0.5f;

	private WaterLevel.WaterInfo lastWaterInfo;

	private float currentWaterFactor;

	private float airTime;

	private float slidingTime;

	private float lastCrashDamage;

	private Vector3 lastPullerPosition;

	private float lastYVelocity;

	public float kmDistance;

	public float tempDistanceTravelled;

	private float lastRoughTerrainTime;

	private bool wasGrounded;

	private bool isSubmerged;

	[SerializeField]
	[HideInInspector]
	private float baseDrag;

	[HideInInspector]
	[SerializeField]
	private float baseAngularDrag;

	private HorseAvoidanceState currentAvoidanceState;

	private int avoidanceSteeringInput;

	private Vector3 avoidanceScanDirection;

	private float nextStandTime;

	private IHorseInputProvider inputProvider;

	private TowingAttachment<RidableHorse> towingAttachment;

	private ITowing towableEntity;

	private float lastRiddenTime;

	private float nextDecayTime;

	public bool HasSingleSaddle => HasFlag(Flags.Reserved9);

	public bool HasDoubleSaddle => HasFlag(Flags.Reserved10);

	public bool HasSaddle
	{
		get
		{
			if (!HasSingleSaddle)
			{
				return HasDoubleSaddle;
			}
			return true;
		}
	}

	public bool IsForSale => HasFlag(Flags.Reserved2);

	public bool IsTowing => HasFlag(Flags.Reserved14);

	public bool IsLeading => HasFlag(Flags.Reserved16);

	public bool IsSwimming => HasFlag(Flags.Reserved13);

	public bool IsSliding => HasFlag(Flags.Reserved18);

	public BasePlayer leadingPlayer { get; private set; }

	public override bool IsNpc => true;

	public bool isGrounded { get; private set; }

	public bool isStanding { get; private set; }

	public bool isSkidding { get; private set; }

	private VehicleTerrainHandler.Surface OnSurface
	{
		get
		{
			if (terrainHandler == null)
			{
				return VehicleTerrainHandler.Surface.Default;
			}
			return terrainHandler.OnSurface;
		}
	}

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public BaseEntity TowEntity => this;

	public Transform TowAnchor => towingPoint;

	public Rigidbody TowBody => rigidBody;

	public bool IsTowingAllowed => !IsTowing;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RidableHorse.OnRpcMessage", 0);
		try
		{
			if (rpc == 2663053610u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_Claim "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_Claim", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2663053610u, "SERVER_Claim", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_Claim(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_Claim");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 299778156 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_Lead "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_Lead", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(299778156u, "SERVER_Lead", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(299778156u, "SERVER_Lead", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_Lead(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_Lead");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3442949235u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3442949235u, "SERVER_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							SERVER_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SERVER_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3395302925u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestDetach "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestDetach", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3395302925u, "SERVER_RequestDetach", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3395302925u, "SERVER_RequestDetach", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3395302925u, "SERVER_RequestDetach", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SERVER_RequestDetach(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in SERVER_RequestDetach");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 294213070 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestSaddleSwap "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestSaddleSwap", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(294213070u, "SERVER_RequestSaddleSwap", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							SERVER_RequestSaddleSwap(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in SERVER_RequestSaddleSwap");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3979037781u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestTow "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestTow", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3979037781u, "SERVER_RequestTow", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3979037781u, "SERVER_RequestTow", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3979037781u, "SERVER_RequestTow", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							SERVER_RequestTow(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in SERVER_RequestTow");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void ApplyBreed(int index)
	{
		if (currentBreedIndex != index)
		{
			if (index >= breeds.Length || index < 0)
			{
				Debug.LogError((object)("ApplyBreed issue! index is " + index + " breed length is : " + breeds.Length));
				return;
			}
			ApplyBreedInternal(breeds[index]);
			currentBreed = breeds[index];
			currentBreedIndex = index;
		}
	}

	protected void ApplyBreedInternal(HorseBreed breed)
	{
		if (base.isServer)
		{
			SetMaxHealth(StartHealth() * breed.maxHealth);
			base.health = MaxHealth();
		}
	}

	public HorseBreed GetBreed()
	{
		if (currentBreedIndex == -1 || currentBreedIndex >= breeds.Length)
		{
			return null;
		}
		return breeds[currentBreedIndex];
	}

	public void SetBreed(int index)
	{
		ApplyBreed(index);
		SendNetworkUpdate();
	}

	private bool ItemIsSaddle(Item item)
	{
		if (item == null)
		{
			return false;
		}
		ItemModAnimalEquipment component = ((Component)item.info).GetComponent<ItemModAnimalEquipment>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		ItemModAnimalEquipment.SlotType slot = component.slot;
		return slot == ItemModAnimalEquipment.SlotType.Saddle || slot == ItemModAnimalEquipment.SlotType.SaddleDouble;
	}

	private bool CanOpenStorage(BasePlayer player)
	{
		if (!AnyMounted() || PlayerIsMounted(player))
		{
			return true;
		}
		return false;
	}

	public int GetStorageSlotCount()
	{
		return numStorageSlots;
	}

	public void InitContainers()
	{
		if (storageInventory == null)
		{
			CreateStorageInventory(giveUID: true);
		}
		if (equipmentInventory == null)
		{
			CreateEquipmentInventory(giveUID: true);
		}
	}

	private void CreateInventories(bool giveUID)
	{
		CreateStorageInventory(giveUID);
		CreateEquipmentInventory(giveUID);
	}

	private void CreateStorageInventory(bool giveUID)
	{
		Debug.Assert(storageInventory == null, "Double init of inventory!");
		storageInventory = CreateInventory(giveUID, 48);
		storageInventory.canAcceptItem = StorageItemFilter;
	}

	private void CreateEquipmentInventory(bool giveUID)
	{
		Debug.Assert(equipmentInventory == null, "Double init of inventory!");
		equipmentInventory = CreateInventory(giveUID, equipmentSlots);
		equipmentInventory.canAcceptItem = EquipmentItemFilter;
	}

	private ItemContainer CreateInventory(bool giveUID, int slots)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.entityOwner = this;
		itemContainer.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
		itemContainer.SetOnlyAllowedItem(onlyAllowedItem);
		itemContainer.maxStackSize = maxStackSize;
		itemContainer.ServerInitialize(null, slots);
		if (giveUID)
		{
			itemContainer.GiveUID();
		}
		itemContainer.onItemAddedRemoved = OnItemAddedOrRemoved;
		itemContainer.onDirty += OnInventoryDirty;
		return itemContainer;
	}

	public bool StorageItemFilter(Item item, int targetSlot)
	{
		return true;
	}

	public bool EquipmentItemFilter(Item item, int targetSlot)
	{
		if (IsForSale && ItemIsSaddle(item))
		{
			return false;
		}
		ItemModAnimalEquipment component = ((Component)item.info).GetComponent<ItemModAnimalEquipment>();
		if (!Object.op_Implicit((Object)(object)component))
		{
			return false;
		}
		if (ItemIsSaddle(item) && HasSaddle)
		{
			return false;
		}
		if (component.slot == ItemModAnimalEquipment.SlotType.Basic)
		{
			return true;
		}
		for (int i = 0; i < equipmentInventory.capacity; i++)
		{
			Item slot = equipmentInventory.GetSlot(i);
			if (slot != null)
			{
				ItemModAnimalEquipment component2 = ((Component)slot.info).GetComponent<ItemModAnimalEquipment>();
				if (!((Object)(object)component2 == (Object)null) && component2.slot == component.slot)
				{
					int slot2 = (int)component2.slot;
					string text = slot2.ToString();
					slot2 = (int)component.slot;
					Debug.Log((object)("Rejecting because slot same, found : " + text + " new : " + slot2));
					return false;
				}
			}
		}
		return true;
	}

	private void OnInventoryDirty()
	{
		EquipmentUpdate();
	}

	private void OnItemAddedOrRemoved(Item arg1, bool arg2)
	{
	}

	private void ReleaseInventories()
	{
		Pool.Free<ItemContainer>(ref equipmentInventory);
		Pool.Free<ItemContainer>(ref storageInventory);
	}

	public void EquipmentUpdate()
	{
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Reserved4, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved5, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Unused23, b: false, recursive: false, networkupdate: false);
		riderProtection.Clear();
		baseProtection.Clear();
		equipmentSpeedMod = 0f;
		numStorageSlots = 0;
		for (int i = 0; i < equipmentInventory.capacity; i++)
		{
			Item slot = equipmentInventory.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			ItemModAnimalEquipment component = ((Component)slot.info).GetComponent<ItemModAnimalEquipment>();
			if ((Object)(object)component != (Object)null)
			{
				SetFlag(component.WearableFlag, b: true, recursive: false, networkupdate: false);
				if (component.hideHair)
				{
					SetFlag(Flags.Reserved4, b: true);
				}
				if (Object.op_Implicit((Object)(object)component.riderProtection))
				{
					riderProtection.Add(component.riderProtection, 1f);
				}
				if (Object.op_Implicit((Object)(object)component.animalProtection))
				{
					baseProtection.Add(component.animalProtection, 1f);
				}
				equipmentSpeedMod += component.speedModifier;
				numStorageSlots += component.additionalInventorySlots;
			}
		}
		for (int j = 0; j < storageInventory.capacity; j++)
		{
			if (j >= numStorageSlots)
			{
				Item slot2 = storageInventory.GetSlot(j);
				if (slot2 != null)
				{
					slot2.RemoveFromContainer();
					slot2.Drop(((Component)this).transform.position + Vector3.up + Random.insideUnitSphere * 0.25f, Vector3.zero);
				}
			}
		}
		storageInventory.capacity = numStorageSlots;
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void SERVER_OpenLoot(RPCMessage rpc)
	{
		if (storageInventory == null)
		{
			return;
		}
		BasePlayer player = rpc.player;
		string text = rpc.read.String(256, false);
		if (!((Object)(object)player == (Object)null) && player.CanInteract() && CanOpenStorage(player) && (!needsBuildingPrivilegeToUse || player.CanBuild()) && Interface.CallHook("CanLootEntity", (object)player, (object)this) == null && player.inventory.loot.StartLootingEntity(this))
		{
			ItemContainer container = equipmentInventory;
			string arg = lootPanelName;
			if (text == "storage")
			{
				arg = storagePanelName;
				container = storageInventory;
			}
			player.inventory.loot.AddContainer(container);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), arg);
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_RequestSaddleSwap(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !IsForSale && HasSaddle && !AnyMounted())
		{
			int tokenItemID = msg.read.Int32();
			Item purchaseToken = GetPurchaseToken(player, tokenItemID);
			if (purchaseToken != null && ItemIsSaddle(purchaseToken))
			{
				ItemDefinition template = (HasSingleSaddle ? PurchaseOptions[0].tokenItem : PurchaseOptions[1].tokenItem);
				OnClaimedWithToken(purchaseToken);
				purchaseToken.UseItem();
				Item item = ItemManager.Create(template, 1, 0uL);
				player.GiveItem(item);
				SendNetworkUpdateImmediate();
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && IsForSale)
		{
			int tokenItemID = msg.read.Int32();
			Item purchaseToken = GetPurchaseToken(player, tokenItemID);
			if (purchaseToken != null && Interface.CallHook("OnRidableAnimalClaim", (object)this, (object)player, (object)purchaseToken) == null && ItemIsSaddle(purchaseToken))
			{
				SetFlag(Flags.Reserved2, b: false);
				OnClaimedWithToken(purchaseToken);
				purchaseToken.UseItem();
				Analytics.Azure.OnVehiclePurchased(msg.player, this);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", (object)this, (object)player);
			}
		}
	}

	public void OnClaimedWithToken(Item tokenItem)
	{
		int saddleItemSeatCount = GetSaddleItemSeatCount(tokenItem);
		SetSeatCount(saddleItemSeatCount);
	}

	public int GetSaddleItemSeatCount(Item item)
	{
		if (!ItemIsSaddle(item))
		{
			return 0;
		}
		ItemModAnimalEquipment component = ((Component)item.info).GetComponent<ItemModAnimalEquipment>();
		if ((Object)(object)component != (Object)null)
		{
			if (component.slot == ItemModAnimalEquipment.SlotType.Saddle)
			{
				return 1;
			}
			if (component.slot == ItemModAnimalEquipment.SlotType.SaddleDouble)
			{
				return 2;
			}
		}
		return 0;
	}

	public void GetAllInventories(List<ItemContainer> list)
	{
		list.Add(storageInventory);
		list.Add(equipmentInventory);
	}

	public Item GetPurchaseToken(BasePlayer player, int tokenItemID)
	{
		return player.inventory.FindItemByItemID(tokenItemID);
	}

	public bool PlayerHasToken(BasePlayer player, int tokenItemID)
	{
		return GetPurchaseToken(player, tokenItemID) != null;
	}

	public void SaveContainer(SaveInfo info, Horse msgHorse)
	{
		if (info.forDisk)
		{
			if (storageInventory != null)
			{
				msgHorse.storageContainer = storageInventory.Save();
			}
			if (equipmentInventory != null)
			{
				msgHorse.equipmentContainer = equipmentInventory.Save();
			}
		}
	}

	public void LoadContainer(LoadInfo info)
	{
		if (info.fromDisk && info.msg.horse != null)
		{
			if (equipmentInventory != null && info.msg.horse.equipmentContainer != null)
			{
				equipmentInventory.Load(info.msg.horse.equipmentContainer);
				equipmentInventory.capacity = equipmentSlots;
			}
			else
			{
				Debug.LogWarning((object)("Horse didn't have saved equipment inventory: " + ((object)this).ToString()));
			}
			if (storageInventory != null && info.msg.horse.storageContainer != null)
			{
				storageInventory.Load(info.msg.horse.storageContainer);
				storageInventory.capacity = numStorageSlots;
			}
			else
			{
				Debug.LogWarning((object)("Horse didn't have savevd storage inventorry: " + ((object)this).ToString()));
			}
		}
	}

	public override void PreInitShared()
	{
		base.PreInitShared();
		modifiers = ((Component)this).GetComponent<HorseModifiers>();
	}

	public bool HasSeatAvailable()
	{
		if (HasSaddle)
		{
			return !HasFlag(Flags.Reserved11);
		}
		return false;
	}

	public bool IsPlayerTooHeavy(BasePlayer player)
	{
		return player.Weight >= 10f;
	}

	public static float UnitsToKPH(float unitsPerSecond)
	{
		return unitsPerSecond * 60f * 60f / 1000f;
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		hasItemTokenCache = new bool[PurchaseOptions.Count];
		if (serverside || bundling)
		{
			baseDrag = rigidBody.drag;
			baseAngularDrag = rigidBody.angularDrag;
		}
		bonesInitialLocalPos = (Vector3[])(object)new Vector3[allBones.Length];
		for (int i = 0; i < allBones.Length; i++)
		{
			bonesInitialLocalPos[i] = allBones[i].localPosition;
		}
	}

	public void ResetBonesPositions()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < allBones.Length; i++)
		{
			allBones[i].localPosition = bonesInitialLocalPos[i];
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next && base.isServer)
		{
			ServerFlagsChanged(old, next);
		}
	}

	public override bool AnyMounted()
	{
		return base.AnyMounted();
	}

	private bool CanPlayerSeeSaddlePoint(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (!GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position, 0.25f, 2162688, (QueryTriggerInteraction)0))
		{
			return !GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position + Vector3.up * 0.5f, 0.25f, 2162688, (QueryTriggerInteraction)0);
		}
		return false;
	}

	bool IMedicalToolTarget.IsValidMedicalToolItem(ItemDefinition itemDef)
	{
		for (int i = 0; i < prohibitedMedicalItems.Length; i++)
		{
			if ((Object)(object)prohibitedMedicalItems[i] == (Object)(object)itemDef)
			{
				return false;
			}
		}
		return true;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.horse = Pool.Get<Horse>();
		SaveContainer(info, info.msg.horse);
		info.msg.horse.stamina = currentStamina;
		info.msg.horse.maxStamina = currentMaxStamina;
		info.msg.horse.towEntityId = towingEntityId;
		info.msg.horse.breedIndex = currentBreedIndex;
		info.msg.horse.numStorageSlots = numStorageSlots;
		if (!info.forDisk)
		{
			info.msg.horse.gait = (int)currentGait;
			info.msg.horse.equipmentSpeedMod = equipmentSpeedMod;
			info.msg.horse.playerLeadingId = playerLeadingId;
		}
		info.msg.horse.modifiers = null;
		if ((Object)(object)modifiers != (Object)null)
		{
			info.msg.horse.modifiers = modifiers.Save(info.forDisk);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.horse != null)
		{
			LoadContainer(info);
			currentStamina = info.msg.horse.stamina;
			currentMaxStamina = info.msg.horse.maxStamina;
			if (info.fromDisk)
			{
				towingEntityId = info.msg.horse.towEntityId;
				ValidateTowableEntity();
				TowAttach();
			}
			if ((Object)(object)modifiers != (Object)null)
			{
				modifiers.Load(info.msg.horse.modifiers, info.fromDisk);
			}
			ApplyBreed(info.msg.horse.breedIndex);
		}
	}

	public bool ShouldTrigger()
	{
		if (IsStopped() && isGrounded && !IsSwimming)
		{
			return !HasFlag(Flags.Reserved19);
		}
		return false;
	}

	public void OnObjects()
	{
	}

	public void OnObjectAdded(GameObject obj, Collider col)
	{
		if (ShouldTrigger() && !base.isClient)
		{
			BaseEntity baseEntity = obj.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !baseEntity.isClient && baseEntity is DroppedItem { item: not null } droppedItem && droppedItem.item.info.category == ItemCategory.Food)
			{
				OnFoodDetected(droppedItem);
			}
		}
	}

	public void OnEmpty()
	{
	}

	private void OnFoodDetected(DroppedItem droppedItem)
	{
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			EatDroppedFood(droppedItem);
		}, Random.Range(1f, 2f));
	}

	private void EatDroppedFood(DroppedItem droppedItem)
	{
		if ((Object)(object)droppedItem == (Object)null || !foodTrigger.HasAnyEntityContents || (GetMaxStaminaFraction() >= 1f && base.healthFraction >= 1f))
		{
			return;
		}
		if (Time.time < nextEatTime)
		{
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				OnFoodDetected(droppedItem);
			}, nextEatTime - Time.time);
		}
		else
		{
			if (!foodTrigger.entityContents.Contains(droppedItem))
			{
				return;
			}
			ItemModConsumable component = ((Component)droppedItem.item.info).GetComponent<ItemModConsumable>();
			if ((Object)(object)component == (Object)null)
			{
				return;
			}
			droppedItem.item.UseItem();
			if (droppedItem.item.amount <= 0)
			{
				droppedItem.Kill();
			}
			else
			{
				((FacepunchBehaviour)this).Invoke((Action)delegate
				{
					EatDroppedFood(droppedItem);
				}, nextEatTime - Time.time);
			}
			nextEatTime = Time.time + Random.Range(2f, 3f) + Mathf.InverseLerp(0.5f, 1f, GetMaxStaminaFraction()) * 4f;
			ReplenishFromFood(component);
		}
	}

	public void ReplenishFromFood(ItemModConsumable consumable)
	{
		if (!((Object)(object)consumable == (Object)null))
		{
			HorseModifiers.AddToHorse(this, consumable.modifiers);
			lastEatTime = Time.time;
			float ifType = consumable.GetIfType(MetabolismAttribute.Type.Calories);
			float ifType2 = consumable.GetIfType(MetabolismAttribute.Type.Hydration);
			float num = consumable.GetIfType(MetabolismAttribute.Type.Health) + consumable.GetIfType(MetabolismAttribute.Type.HealthOverTime);
			ApplyDungCalories(ifType);
			ReplenishStaminaCore(ifType, ifType2);
			Heal(num * 4f);
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_HorseEat"));
		}
	}

	private void UpdateDung(float deltaTime)
	{
		if (pendingDungCalories < 0.01f || (Object)(object)dungItem == (Object)null)
		{
			return;
		}
		deltaTime *= dungTimeScale;
		float num = (((Object)(object)modifiers != (Object)null) ? modifiers.GetValue(Modifier.ModifierType.HorseDungProductionBoost, 1f) : 1f);
		deltaTime *= num;
		if (!(deltaTime < 0.01f))
		{
			float num2 = Mathf.Min(pendingDungCalories * deltaTime, caloriesToDigestPerHour / 3600f * deltaTime) * dungProducedPerCalorie;
			dungProduction += num2;
			pendingDungCalories -= num2;
			if (dungProduction >= 1f)
			{
				DoDung();
			}
		}
	}

	public void ApplyDungCalories(float calories)
	{
		pendingDungCalories += calories;
	}

	private void DoDung()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		dungProduction -= 1f;
		if (Interface.CallHook("OnAnimalDungProduce", (object)this) == null)
		{
			Quaternion rotation = Quaternion.Euler(Random.Range(-180f, 180f), Random.Range(-180f, 180f), Random.Range(-180f, 180f));
			Vector3 vVelocity = default(Vector3);
			((Vector3)(ref vVelocity))..ctor(Random.Range(-0.5f, 0.5f), Random.Range(-1f, -3f), Random.Range(-0.5f, 0.5f));
			Item item = ItemManager.Create(dungItem, 1, 0uL);
			item.SetItemOwnership(currentBreed.breedName.english, ItemOwnershipPhrases.Pooped);
			item.Drop(dungSpawnPoint.position + Random.insideUnitSphere * 0.1f, vVelocity, rotation);
			Interface.CallHook("OnAnimalDungProduced", (object)this, (object)item);
		}
	}

	public bool IsHitched()
	{
		return (Object)(object)currentHitch != (Object)null;
	}

	public void TryToHitch()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		List<HitchTrough> list = Pool.Get<List<HitchTrough>>();
		Vis.Entities(((Component)this).transform.position, 2.5f, list, 256, (QueryTriggerInteraction)1);
		foreach (HitchTrough item in list)
		{
			if (!item.isClient && !(Vector3.Dot(Vector3Ex.Direction2D(((Component)item).transform.position, ((Component)this).transform.position), ((Component)this).transform.forward) < 0.4f) && item.HasSpace() && item.IsValidHitchPosition(((Component)this).transform.position) && item.AttemptToHitch(this))
			{
				break;
			}
		}
		Pool.FreeUnmanaged<HitchTrough>(ref list);
	}

	public void SetHitch(HitchTrough hitch, HitchTrough.HitchSpot spot)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		currentHitch = hitch;
		SetFlag(Flags.Reserved3, (Object)(object)currentHitch != (Object)null);
		if ((Object)(object)hitch != (Object)null)
		{
			((Component)this).transform.SetPositionAndRotation(spot.tr.position, spot.tr.rotation);
			DismountAllPlayers();
		}
	}

	private void EatFromHitch()
	{
		if (!IsHitched())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)EatFromHitch);
		}
		else
		{
			if (Time.time < nextEatTime || (GetMaxStaminaFraction() >= 1f && base.healthFraction >= 1f))
			{
				return;
			}
			Item foodItem = currentHitch.GetFoodItem();
			if (foodItem != null && foodItem.amount > 0)
			{
				ItemModConsumable component = ((Component)foodItem.info).GetComponent<ItemModConsumable>();
				if (Object.op_Implicit((Object)(object)component))
				{
					float time = component.GetIfType(MetabolismAttribute.Type.Calories) * currentHitch.caloriesToDecaySeconds;
					AddDecayDelay(time);
					ReplenishFromFood(component);
					foodItem.UseItem();
					nextEatTime = Time.time + Random.Range(2f, 3f) + Mathf.InverseLerp(0.5f, 1f, GetMaxStaminaFraction()) * 4f;
				}
			}
		}
	}

	public void TryLeaveHitch()
	{
		if ((Object)(object)currentHitch != (Object)null)
		{
			currentHitch.UnHitch(this);
		}
	}

	public bool IsReversing()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		if (base.isServer)
		{
			val = rigidBody.velocity;
		}
		return Vector3.Dot(val, ((Component)this).transform.forward) < -0.1f;
	}

	private float GetCurrentSpeed()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			Vector3 velocity = rigidBody.velocity;
			return ((Vector3)(ref velocity)).magnitude;
		}
		return 0f;
	}

	public float GetCurrentGaitSpeedFraction()
	{
		return Mathf.Clamp01(GetCurrentSpeed() / GetCurrentMaxSpeed());
	}

	public float GetSpeedFraction()
	{
		return Mathf.Clamp01(GetCurrentSpeed() / GetTopSpeed());
	}

	private float GetTurnSpeed()
	{
		float turnSpeed = GetCurrentGait().turnSpeed;
		if (IsSwimming)
		{
			return turnSpeed * 0.8f;
		}
		if (IsReversing())
		{
			return turnSpeed * 0.7f;
		}
		return turnSpeed;
	}

	private float GetCurrentAcceleration()
	{
		float num = GetCurrentGait().accelerationForce;
		if (IsTowing)
		{
			num *= towingAccelerationBoost;
		}
		return num;
	}

	private float GetCurrentMaxSpeed()
	{
		Gait gait = GetCurrentGait();
		float num = gait.maxSpeed;
		if (onIdealTerrain && gait.gaitType == GaitType.Gallop)
		{
			num += roadSpeedBonus;
		}
		if (gait.equipmentScalesMaxSpeed)
		{
			num += equipmentSpeedMod;
			float num2 = (((Object)(object)modifiers != (Object)null) ? modifiers.GetValue(Modifier.ModifierType.HorseGallopSpeed) : 0f);
			num += num2;
		}
		if (gait.breedScalesMaxSpeed)
		{
			num *= currentBreed.maxSpeed;
		}
		if (IsTowing)
		{
			num *= towingMaxSpeedBoost;
		}
		return num;
	}

	public float GetTopSpeed()
	{
		float num = (gaits[gaits.Length - 1].maxSpeed + equipmentSpeedMod) * currentBreed.maxSpeed;
		float num2 = (((Object)(object)modifiers != (Object)null) ? modifiers.GetValue(Modifier.ModifierType.HorseGallopSpeed) : 0f);
		return num + num2;
	}

	private Gait GetCurrentGait()
	{
		return gaits[(uint)currentGait];
	}

	private bool IsStopped()
	{
		if (!IsSliding)
		{
			return GetSpeedFraction() < 0.05f;
		}
		return false;
	}

	public float GetMaxStaminaFraction()
	{
		return Mathf.InverseLerp(0f, maxStamina, currentMaxStamina);
	}

	public float GetStaminaFraction()
	{
		return Mathf.InverseLerp(0f, maxStamina, currentStamina);
	}

	public bool IsDrowning()
	{
		if (IsSwimming)
		{
			return GetStaminaFraction() < 0.02f;
		}
		return false;
	}

	public bool CanLead(BasePlayer player)
	{
		if (!AnyMounted() && NearMountPoint(player) && DirectlyMountable() && !HasFlag(Flags.Reserved12) && !player.isMounted && !IsLeading && !IsTowing)
		{
			return !IsForSale;
		}
		return false;
	}

	public bool CanStopLead(BasePlayer player)
	{
		if (IsLeading && (Object)(object)leadingPlayer == (Object)(object)player)
		{
			return NearMountPoint(player);
		}
		return false;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (!IsDriver(player))
		{
			return;
		}
		if (inputProvider != null)
		{
			throttleInput = inputProvider.GetMoveInput();
			steerInput = inputProvider.GetSteerInput();
		}
		float num = steerInput;
		if (num == 1f || num == -1f)
		{
			if (steerInputDownTime == 0f)
			{
				steerInputDownTime = Time.time;
			}
		}
		else
		{
			steerInputDownTime = 0f;
		}
		forwardInputDown = throttleInput == 1f;
		backwardInputDown = throttleInput == -1f;
		sprintInputJustPressed = inputState.WasJustPressed(BUTTON.SPRINT);
		bool flag = inputState.IsDown(BUTTON.SPRINT);
		if (sprintInputJustPressed)
		{
			IncrementGait(flag);
		}
		if (inputState.WasJustReleased(BUTTON.SPRINT) && currentGait == GaitType.Gallop)
		{
			RetrogradeGait();
		}
		if (flag)
		{
			if (sprintInputHoldTime == 0f)
			{
				sprintInputHoldTime = Time.time;
			}
			if (Time.time - sprintInputHoldTime >= gaitProgressionInterval && (int)currentGait < 3)
			{
				sprintInputHoldTime = Time.time;
				IncrementGait(sprintHeld: true);
			}
		}
		else
		{
			sprintInputHoldTime = 0f;
		}
		duckInputDown = inputState.IsDown(BUTTON.DUCK);
		if (inputState.WasJustReleased(BUTTON.DUCK))
		{
			float time = Time.time;
			if (time - lastDuckTapTime <= doubleTapTime)
			{
				duckDoubleTapped = true;
			}
			else
			{
				duckDoubleTapped = false;
			}
			lastDuckTapTime = time;
		}
		else if (duckDoubleTapped)
		{
			duckDoubleTapped = false;
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		if (HasFlag(Flags.Reserved12))
		{
			return;
		}
		base.VehicleFixedUpdate();
		TimeWarning val = TimeWarning.New("RidableHorse.VehicleFixedUpdate", 0);
		try
		{
			if ((Object)(object)modifiers != (Object)null)
			{
				modifiers.ServerUpdate(this);
				modifiers.SendNetworkUpdateIfDirty(this);
			}
			float fixedDeltaTime = Time.fixedDeltaTime;
			UpdateStamina(fixedDeltaTime);
			UpdateDung(fixedDeltaTime);
			if (IsDrowning() && TimeSince.op_Implicit(timeSinceDrowningDamage) > 2f)
			{
				timeSinceDrowningDamage = TimeSince.op_Implicit(0f);
				Hurt(75f, DamageType.Drowned, null, useProtection: false);
			}
			if (Time.time >= nextCollisionDamageTime)
			{
				nextCollisionDamageTime = Time.time + 0.33f;
				foreach (KeyValuePair<BaseEntity, float> item in damageSinceLastTick)
				{
					DoCollisionDamage(item.Key, item.Value);
				}
				damageSinceLastTick.Clear();
			}
			bool flag = AnyMounted();
			if ((!IsLeading && !HasDoubleSaddle && !flag) || (HasDoubleSaddle && !HasDriver()))
			{
				throttleInput = 0f;
				steerInput = 0f;
			}
			if (IsLeading)
			{
				if ((Object)(object)leadingPlayer == (Object)null || leadingPlayer.IsDead() || leadingPlayer.IsSleeping() || leadingPlayer.IsDestroyed)
				{
					SetLeading(null);
				}
				else
				{
					throttleInput = inputProvider.GetMoveInput();
					steerInput = inputProvider.GetSteerInput();
				}
			}
			if ((flag || IsLeading) && rigidBody.IsSleeping())
			{
				((Collider)wheelCollider).enabled = true;
				rigidBody.WakeUp();
			}
			if (rigidBody.IsSleeping())
			{
				wasSleeping = true;
				((Behaviour)serverLegsAnimator).enabled = false;
				((Collider)wheelCollider).enabled = false;
				return;
			}
			((Collider)wheelCollider).enabled = true;
			((Behaviour)serverLegsAnimator).enabled = true;
			serverLegsAnimator.HipsHeightStepSpeed = Mathf.Lerp(0.7f, 0.05f, Mathf.InverseLerp(0f, 10f, normalVariation));
			if (IsTowing)
			{
				towingAttachment.FixedUpdate();
			}
			if (!wasSleeping && !(GetCurrentSpeed() > 0.5f))
			{
				Vector3 angularVelocity = rigidBody.angularVelocity;
				if (!(Mathf.Abs(((Vector3)(ref angularVelocity)).magnitude) > 0.5f))
				{
					goto IL_02a2;
				}
			}
			lastMovingTime = Time.time;
			goto IL_02a2;
			IL_02a2:
			float num = GetCurrentSpeed() * Time.fixedDeltaTime;
			if (!flag && !IsLeading && !IsTowing && Time.time > lastMovingTime + 5f)
			{
				airTime = 0f;
				wheelCollider.motorTorque = 0f;
				((Behaviour)serverLegsAnimator).enabled = false;
				((Collider)wheelCollider).enabled = false;
				rigidBody.Sleep();
			}
			else
			{
				if (autoAvoidance)
				{
					AutoAvoidObstacles();
				}
				MovementsUpdate();
			}
			wasSleeping = false;
			tempDistanceTravelled += num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override float AntiHackVelocity()
	{
		return GetTopSpeed() * 1.3f;
	}

	private void MovementsUpdate()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ad9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0adf: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b09: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b1c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b21: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b29: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b52: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b57: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b35: Unknown result type (might be due to invalid IL or missing references)
		//IL_0403: Unknown result type (might be due to invalid IL or missing references)
		//IL_0405: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b94: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b9f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b6f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b74: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b78: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b7e: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0be5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bf3: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0438: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c4f: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c23: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c28: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0868: Unknown result type (might be due to invalid IL or missing references)
		//IL_086d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0816: Unknown result type (might be due to invalid IL or missing references)
		//IL_075b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0760: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08df: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0900: Unknown result type (might be due to invalid IL or missing references)
		//IL_0905: Unknown result type (might be due to invalid IL or missing references)
		//IL_0784: Unknown result type (might be due to invalid IL or missing references)
		//IL_0789: Unknown result type (might be due to invalid IL or missing references)
		//IL_0776: Unknown result type (might be due to invalid IL or missing references)
		//IL_0925: Unknown result type (might be due to invalid IL or missing references)
		//IL_092a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0937: Unknown result type (might be due to invalid IL or missing references)
		//IL_093d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0942: Unknown result type (might be due to invalid IL or missing references)
		//IL_0947: Unknown result type (might be due to invalid IL or missing references)
		//IL_0955: Unknown result type (might be due to invalid IL or missing references)
		//IL_095a: Unknown result type (might be due to invalid IL or missing references)
		//IL_095f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0967: Unknown result type (might be due to invalid IL or missing references)
		//IL_096c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0971: Unknown result type (might be due to invalid IL or missing references)
		//IL_0975: Unknown result type (might be due to invalid IL or missing references)
		//IL_097c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0981: Unknown result type (might be due to invalid IL or missing references)
		//IL_0983: Unknown result type (might be due to invalid IL or missing references)
		//IL_0600: Unknown result type (might be due to invalid IL or missing references)
		//IL_0602: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0635: Unknown result type (might be due to invalid IL or missing references)
		//IL_0637: Unknown result type (might be due to invalid IL or missing references)
		//IL_0648: Unknown result type (might be due to invalid IL or missing references)
		//IL_064d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0655: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_09de: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_09ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_09f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_09fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0716: Unknown result type (might be due to invalid IL or missing references)
		//IL_071a: Unknown result type (might be due to invalid IL or missing references)
		//IL_071f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0721: Unknown result type (might be due to invalid IL or missing references)
		//IL_0726: Unknown result type (might be due to invalid IL or missing references)
		//IL_072a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0737: Unknown result type (might be due to invalid IL or missing references)
		//IL_073c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0744: Unknown result type (might be due to invalid IL or missing references)
		//IL_069d: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0701: Unknown result type (might be due to invalid IL or missing references)
		//IL_0709: Unknown result type (might be due to invalid IL or missing references)
		if (currentGait == GaitType.Canter && !CanCanter())
		{
			RetrogradeGait();
		}
		else if (currentGait == GaitType.Gallop && !CanGallop())
		{
			RetrogradeGait();
		}
		CheckSpeedForRetrograde();
		UpdateOnTerrain();
		bool isSwimming = IsSwimming;
		if (onWaterTopology)
		{
			if (TimeSince.op_Implicit(timeSinceWaterCheck) > (isSwimming ? 0.05f : 0.25f))
			{
				OBB val = WorldSpaceBounds();
				Bounds val2 = ((OBB)(ref val)).ToBounds();
				lastWaterInfo = WaterLevel.GetWaterInfo(val2, waves: true, volumes: true, this);
				currentWaterFactor = (lastWaterInfo.isValid ? Mathf.InverseLerp(((Bounds)(ref val2)).min.y, ((Bounds)(ref val2)).max.y, lastWaterInfo.surfaceLevel) : 0f);
				isSubmerged = currentWaterFactor > 0.65f;
				bool flag = (currentWaterFactor > 0.5f && !isGrounded) || isSubmerged;
				if (isSwimming != flag)
				{
					SetFlag(Flags.Reserved13, flag);
				}
				bool flag2 = currentWaterFactor > 0.32f;
				if (HasFlag(Flags.Reserved19) != flag2)
				{
					SetFlag(Flags.Reserved19, flag2);
				}
				rigidBody.drag = Mathf.Max(baseDrag, currentWaterFactor * 3f);
				rigidBody.angularDrag = Mathf.Max(baseAngularDrag, currentWaterFactor * 2f);
				timeSinceWaterCheck = TimeSince.op_Implicit(0f);
			}
		}
		else
		{
			if (HasFlag(Flags.Reserved19))
			{
				SetFlag(Flags.Reserved19, b: false);
			}
			currentWaterFactor = 0f;
		}
		wasGrounded = isGrounded;
		if (throttledGroundAngleUpdate)
		{
			if (Time.time > nextGroundNormalCheckTime)
			{
				UpdateGroundNormal();
				nextGroundNormalCheckTime = Time.time + Random.Range(groundAngleUpdateRate, groundAngleUpdateRate + 0.1f);
			}
		}
		else
		{
			UpdateGroundNormal();
		}
		bool flag3;
		Vector3 force;
		if (isGrounded || isSwimming)
		{
			if (!wasGrounded)
			{
				OnLanded(Mathf.Abs(lastYVelocity));
			}
			airTime = 0f;
			flag3 = IsStopped();
			force = rigidBody.velocity;
			if (((Vector3)(ref force)).magnitude > 0.5f && !isSwimming)
			{
				Vector3 val3 = -((Component)this).transform.up;
				force = rigidBody.velocity;
				Vector3 val4 = val3 * ((Vector3)(ref force)).magnitude * 20f;
				rigidBody.AddForce(val4, (ForceMode)0);
			}
			AlignWithNormal(averagedUp);
			Vector3 forward = ((Component)this).transform.forward;
			Vector3 velocity = rigidBody.velocity;
			if (ShouldSlide())
			{
				SetWheelStiffness(0.1f, 0f);
				SetFlag(Flags.Reserved18, b: true);
			}
			float currentSpeed = GetCurrentSpeed();
			if (IsSliding)
			{
				if ((groundAngle < groundAngleToRecoverFromSlide && currentSpeed < 7f) || (currentSpeed < 1f && slidingTime > Time.fixedDeltaTime * 10f))
				{
					SetWheelStiffness(1f, 1f);
					SetFlag(Flags.Reserved18, b: false);
					slidingTime = 0f;
				}
				slidingTime += Time.fixedDeltaTime;
				float num = Vector3.Dot(rigidBody.velocity, -((Component)this).transform.forward);
				if (slidingTime > Time.fixedDeltaTime * 5f && num > 7f)
				{
					if (groundAngle > groundAngleToRecoverFromSlide + 5f)
					{
						force = default(Vector3);
						RagdollAllRiders(force);
					}
					RagdollHorse();
				}
			}
			Vector3 val5 = Vector3.Project(velocity, forward);
			Vector3 val6 = velocity - val5;
			if (((Vector3)(ref val6)).magnitude > 1f)
			{
				Vector3 val7 = -val6 * (isSkidding ? 1f : 3f);
				rigidBody.AddForce(val7 * rigidBody.mass, (ForceMode)0);
			}
			float num2 = Mathf.Clamp01(currentSpeed / GetTopSpeed());
			if (num2 > 0.9f && duckInputDown && !isSkidding && currentWaterFactor < 0.1f && groundAngle < 10f)
			{
				isSkidding = true;
				SetWheelStiffness(0.1f, 0.3f);
				ClientRPC(RpcTarget.NetworkGroup("CLIENT_Skid"));
			}
			if (isSkidding)
			{
				SetWheelStiffness(0f, 0f);
				Brake(1.25f);
				if (num2 <= 0.01f || Vector3.Dot(forward, ((Vector3)(ref velocity)).normalized) < 0.2f)
				{
					isSkidding = false;
				}
			}
			else if (!IsSliding)
			{
				SetWheelStiffness(1f, 1f);
			}
			if (Mathf.Abs(steerInput) > 0f && num2 < 0.3f && !IsReversing() && !backwardInputDown && !forwardInputDown && !isSkidding && !duckInputDown && Time.time - steerInputDownTime > 1f)
			{
				throttleInput = 1f;
			}
			if (!isStanding && !IsSliding && !isSkidding)
			{
				if (duckInputDown && !flag3)
				{
					float multiplier = (((int)currentGait <= 1) ? 0.15f : 1f);
					Brake(multiplier);
				}
				if (throttleInput != 0f && !duckInputDown)
				{
					wheelCollider.motorTorque = 1E-05f * Mathf.Sign(throttleInput);
					if (throttleInput < 0f)
					{
						if (Vector3.Dot(velocity, forward) < -0.1f || flag3)
						{
							float num3 = GetCurrentMaxSpeed() * reverseSpeedFactor;
							float num4 = Mathf.Max(num3 - currentSpeed, 0f);
							Vector3 val8 = -forward * (reverseAccelerationForce * (num4 / num3));
							rigidBody.AddForce(val8, (ForceMode)0);
						}
						else
						{
							Brake();
						}
					}
					else if (throttleInput > 0f)
					{
						float currentMaxSpeed = GetCurrentMaxSpeed();
						float currentAcceleration = GetCurrentAcceleration();
						if (((Vector3)(ref velocity)).magnitude < currentMaxSpeed)
						{
							Vector3 val9 = forward * currentAcceleration;
							if (currentGait != 0 || IsTowing)
							{
								float num5 = slopeAngleSpeedFactor.Evaluate(Mathf.InverseLerp(minMaxSlopeAngle.x, minMaxSlopeAngle.y, groundAngle));
								if (IsTowing)
								{
									num5 += 1f;
								}
								val9 *= num5;
							}
							rigidBody.AddForce(val9, (ForceMode)0);
						}
						else
						{
							Vector3 val10 = forward * currentMaxSpeed - velocity;
							Vector3 val11 = ((Vector3)(ref val10)).normalized * (currentAcceleration * 0.2f);
							rigidBody.AddForce(val11, (ForceMode)0);
						}
					}
				}
				else
				{
					float num6 = 0.1f;
					force = rigidBody.velocity;
					if (((Vector3)(ref force)).sqrMagnitude < num6 * num6)
					{
						rigidBody.velocity = Vector3.zero;
					}
					else
					{
						Vector3 val12 = -((Vector3)(ref velocity)).normalized * (rigidBody.mass * (AnyMounted() ? 1.1f : 3f));
						rigidBody.AddForce(val12, (ForceMode)0);
					}
				}
			}
			if (!isStanding && !IsSliding)
			{
				float num7 = GetTurnSpeed();
				if (duckInputDown && (int)currentGait < 2)
				{
					num7 *= 1.5f;
				}
				float num8 = ((steerInput + (float)avoidanceSteeringInput) * num7 * (MathF.PI / 180f) - rigidBody.angularVelocity.y) * rotationResponsiveness * rotationResponsivenessCurve.Evaluate(num2);
				rigidBody.AddRelativeTorque(0f, num8, 0f, (ForceMode)5);
			}
			if (Mathf.Abs(throttleInput) <= 0f)
			{
				force = rigidBody.velocity;
				if (((Vector3)(ref force)).magnitude < 2.5f && groundAngle < minMaxSlopeAngle.y && !isSwimming && !IsSliding)
				{
					goto IL_08ac;
				}
			}
			if (IsLeading && currentSpeed > 6f)
			{
				goto IL_08ac;
			}
			wheelCollider.brakeTorque = 0f;
			goto IL_08c4;
		}
		airTime += Time.fixedDeltaTime;
		if (airTime > maxAirTimeBeforeRagdoll)
		{
			force = default(Vector3);
			RagdollAllRiders(force);
			RagdollHorse();
		}
		float num9 = ((currentWaterFactor != 0f) ? waterGravity : gravity);
		Vector3 val13 = Vector3.down * (rigidBody.mass * num9);
		rigidBody.AddForce(val13, (ForceMode)0);
		goto IL_0b31;
		IL_0b31:
		if (isSwimming)
		{
			AlignWithNormal(Vector3.up);
			ApplyBuoyancy();
		}
		float num10 = 10000f;
		force = rigidBody.velocity;
		if (((Vector3)(ref force)).magnitude > num10)
		{
			Rigidbody obj = rigidBody;
			force = rigidBody.velocity;
			obj.velocity = ((Vector3)(ref force)).normalized * num10;
		}
		float num11 = -1.3f;
		float num12 = Vector3.Dot(rigidBody.velocity, ((Component)this).transform.forward);
		if (num12 <= num11)
		{
			float num13 = num11 - num12;
			float num14 = Mathf.Lerp(1f, 0.2f, Mathf.InverseLerp(10f, 40f, groundAngle));
			rigidBody.AddForce(((Component)this).transform.forward * num13 * num14, (ForceMode)5);
		}
		if (Mathf.Abs(steerInput) == 0f && !rigidBody.isKinematic)
		{
			force = rigidBody.angularVelocity;
			if (((Vector3)(ref force)).magnitude < 0.2f)
			{
				rigidBody.angularVelocity = Vector3.zero;
			}
		}
		lastYVelocity = rigidBody.velocity.y;
		return;
		IL_08c4:
		if (IsLeading)
		{
			Vector3 val14 = ((Component)this).transform.TransformPoint(Vector3.up * 1.8f + Vector3.forward);
			float num15 = Vector3.Distance(((Component)leadingPlayer).transform.position, val14);
			if (num15 > 3.5f)
			{
				Vector3 position = ((Component)leadingPlayer).transform.position;
				Vector3 val15 = ((Component)leadingPlayer).transform.position - lastPullerPosition;
				lastPullerPosition = ((Component)leadingPlayer).transform.position;
				force = position - ((Component)this).transform.position;
				Vector3 normalized = ((Vector3)(ref force)).normalized;
				Vector3 normalized2 = ((Vector3)(ref val15)).normalized;
				if (Vector3.Dot(normalized, normalized2) > 0.5f)
				{
					float value = Mathf.Lerp(0f, -0.9f, Mathf.Clamp01(Mathf.InverseLerp(3.5f, 7f, num15)));
					leadingPlayer.modifiers.SetValue(Modifier.ModifierSource.Interaction, Modifier.ModifierType.MoveSpeed, value);
					if (num15 > 5f)
					{
						force = position - val14;
						Vector3 normalized3 = ((Vector3)(ref force)).normalized;
						rigidBody.AddForceAtPosition(normalized3 * 5000f, val14, (ForceMode)0);
					}
				}
				else
				{
					leadingPlayer.modifiers.SetValue(Modifier.ModifierSource.Interaction, Modifier.ModifierType.MoveSpeed, 0f);
				}
			}
			else
			{
				leadingPlayer.modifiers.SetValue(Modifier.ModifierSource.Interaction, Modifier.ModifierType.MoveSpeed, 0f);
			}
			if (num15 > 7f)
			{
				leadingPlayer.modifiers.RemoveFromSource(Modifier.ModifierSource.Interaction);
				SetLeading(null);
			}
		}
		if (flag3 && duckDoubleTapped && CanStand())
		{
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_Stand"));
			nextStandTime = Time.time + 4f;
			isStanding = true;
		}
		if (isStanding && nextStandTime < Time.time)
		{
			isStanding = false;
		}
		goto IL_0b31;
		IL_08ac:
		ApplyHandBrake();
		goto IL_08c4;
	}

	private void Brake(float multiplier = 1f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero - rigidBody.velocity;
		Vector3 val2 = ((Vector3)(ref val)).normalized * GetCurrentGait().brakingForce * multiplier;
		rigidBody.AddForce(val2, (ForceMode)0);
	}

	private bool ShouldSlide()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if ((IsSliding || !(groundAngle > groundAngleSlideThreshold) || !(normalVariation < normalVariationSlideThreshold)) && !(groundAngle > groundAngleSlideThresholdForced))
		{
			return Vector3.Dot(rigidBody.velocity, -((Component)this).transform.forward) > 4f;
		}
		return true;
	}

	private void ApplyBuoyancy()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		float num = lastWaterInfo.surfaceLevel - (IsDrowning() ? (centreOfMassTransform.position.y + 3f) : (centreOfMassTransform.position.y - 0.5f));
		num = Mathf.Clamp(num, 0f, 5f);
		if (num > 0f)
		{
			float num2 = Mathf.Sin(Time.time * 2f) * 0.3f;
			float num3 = 1f + num2;
			Vector3 val = Vector3.up * (10f * num * num3);
			rigidBody.AddForce(val, (ForceMode)5);
			Vector3 val2 = Vector3.ProjectOnPlane(rigidBody.velocity, Vector3.up);
			Vector3 val3 = Vector3.Project(rigidBody.velocity, Vector3.up);
			val3 *= 1f - Time.fixedDeltaTime * 6f;
			rigidBody.velocity = val2 + val3;
		}
	}

	private void CheckSpeedForRetrograde()
	{
		float currentSpeed = GetCurrentSpeed();
		Gait gait = GetCurrentGait();
		if ((int)currentGait > 0 && currentSpeed < gait.minSpeed)
		{
			RetrogradeGait();
		}
		if (IsSwimming && currentGait != 0)
		{
			RetrogradeGait();
		}
	}

	public void IncrementGait(bool sprintHeld)
	{
		if (!IsTowing || currentGait != maxTowingGait)
		{
			GaitType gaitType = currentGait + 1;
			if ((gaitType != GaitType.Gallop || (sprintHeld && CanStartGalloping())) && (gaitType != GaitType.Trot || !IsSwimming) && (int)currentGait < 3)
			{
				currentGait++;
			}
		}
	}

	private bool CanGallop()
	{
		if (GetStaminaFraction() > 0f)
		{
			return Time.time - lastRoughTerrainTime > 2.5f;
		}
		return false;
	}

	private bool CanCanter()
	{
		return Time.time - lastRoughTerrainTime > 1.5f;
	}

	private bool CanStartGalloping()
	{
		return GetStaminaFraction() > 0.04f;
	}

	public void RetrogradeGait()
	{
		if ((int)currentGait > 0)
		{
			currentGait--;
		}
	}

	private void ApplyHandBrake()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.ProjectOnPlane(Vector3.down, averagedUp);
		rigidBody.AddForce(-val * rigidBody.mass * 10f, (ForceMode)0);
		wheelCollider.brakeTorque = 10000f;
		wheelCollider.motorTorque = 0f;
	}

	private void AlignWithNormal(Vector3 normal, bool force = false)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normalized = ((Vector3)(ref normal)).normalized;
		Vector3 val = Vector3.ProjectOnPlane(((Component)this).transform.forward, normalized);
		Vector3 val2 = ((Vector3)(ref val)).normalized;
		if (val2 == Vector3.zero)
		{
			val2 = ((Component)this).transform.forward;
		}
		Quaternion val3 = Quaternion.LookRotation(val2, Vector3.up);
		Quaternion val4 = (force ? val3 : Quaternion.Slerp(rigidBody.rotation, val3, 5f * Time.fixedDeltaTime));
		rigidBody.MoveRotation(val4);
	}

	public void UpdateGroundNormal()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("RidableHorse.UpdateGroundNormal", 0);
		try
		{
			int num = 0;
			bool flag = false;
			List<Vector3> list = Pool.Get<List<Vector3>>();
			Vector3 val2 = Vector3.zero;
			Vector3 val3 = averagedUp;
			for (int i = 0; i < groundSampleOffsets.Length; i++)
			{
				Vector3 val4 = groundSampleOffsets[i].position + Vector3.up;
				if (GamePhysics.Trace(new Ray(val4, Vector3.down), 0f, out var hitInfo, 1.2f, 1503731969, (QueryTriggerInteraction)1, this))
				{
					Vector3 normal = ((RaycastHit)(ref hitInfo)).normal;
					num++;
					if (i == groundSampleOffsets.Length - 1)
					{
						flag = true;
					}
					val3 += normal;
					list.Add(normal);
					val2 += normal;
				}
				else
				{
					val3 += Vector3.up;
					list.Add(Vector3.up);
					val2 += Vector3.up;
				}
			}
			isGrounded = num >= 2;
			if (!IsSwimming && !flag && throttleInput == 0f)
			{
				throttleInput = 1f;
			}
			Vector3 val5 = val2 / (float)list.Count;
			Vector3 normalized = ((Vector3)(ref val5)).normalized;
			float num2 = 0f;
			for (int j = 0; j < list.Count; j++)
			{
				float num3 = Vector3.Angle(list[j], normalized);
				num2 += num3;
			}
			normalVariation = num2 / (float)list.Count;
			if (normalVariation > 25f && !onIdealTerrain)
			{
				lastRoughTerrainTime = Time.time;
			}
			val3 += Vector3.up;
			val3 /= (float)(groundSampleOffsets.Length + 1);
			((Vector3)(ref val3)).Normalize();
			if (normalVariation < 10f || Vector3.Dot(targetUp, val3) < 0.99f)
			{
				targetUp = val3;
			}
			averagedUp = Vector3.Lerp(averagedUp, targetUp, Time.fixedDeltaTime * groundAlignmentSpeed);
			groundAngle = Vector3.Angle(normalized, Vector3.up);
			Pool.FreeUnmanaged<Vector3>(ref list);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SetWheelStiffness(float forward, float sideways)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		WheelFrictionCurve forwardFriction = wheelCollider.forwardFriction;
		WheelFrictionCurve sidewaysFriction = wheelCollider.sidewaysFriction;
		((WheelFrictionCurve)(ref forwardFriction)).stiffness = forward;
		((WheelFrictionCurve)(ref sidewaysFriction)).stiffness = sideways;
		wheelCollider.forwardFriction = forwardFriction;
		wheelCollider.sidewaysFriction = sidewaysFriction;
	}

	private void AutoAvoidObstacles()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		if (currentAvoidanceState == HorseAvoidanceState.Normal && GetSpeedFraction() < 0.1f)
		{
			avoidanceSteeringInput = 0;
			return;
		}
		float num = Mathf.Lerp(avoidanceDetectionDistance.x, avoidanceDetectionDistance.y, GetSpeedFraction());
		Vector3 val = rigidBody.velocity;
		Vector3 val2;
		if (!(((Vector3)(ref val)).sqrMagnitude > 0.01f))
		{
			val2 = ((Component)this).transform.forward;
		}
		else
		{
			val = rigidBody.velocity;
			val2 = ((Vector3)(ref val)).normalized;
		}
		Vector3 val3 = ((Component)this).transform.right * steerInput * 0.4f;
		val = val2 + val3 * 0.4f;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = Vector3.Lerp(avoidanceScanDirection, normalized, Time.deltaTime * 5f);
		avoidanceScanDirection = ((Vector3)(ref val)).normalized;
		if (currentAvoidanceState == HorseAvoidanceState.Normal && Time.time < nextAutoAvoidanceCheckTime)
		{
			return;
		}
		nextAutoAvoidanceCheckTime = Time.time + Random.Range(0.1f, 0.2f);
		switch (currentAvoidanceState)
		{
		case HorseAvoidanceState.Normal:
		{
			if (DetectObstacleAhead(num, avoidanceScanDirection, out var _))
			{
				currentAvoidanceState = HorseAvoidanceState.AvoidingObstacle;
			}
			avoidanceSteeringInput = 0;
			break;
		}
		case HorseAvoidanceState.AvoidingObstacle:
		{
			int num2 = DetermineAvoidanceDirection(num);
			avoidanceSteeringInput = num2;
			if (!DetectObstacleAhead(num, ((Component)this).transform.forward, out var _))
			{
				if (steerInput != 0f && steerInput != (float)avoidanceSteeringInput)
				{
					currentAvoidanceState = HorseAvoidanceState.Normal;
					avoidanceSteeringInput = 0;
				}
				else
				{
					currentAvoidanceState = HorseAvoidanceState.Normal;
					avoidanceSteeringInput = 0;
				}
			}
			break;
		}
		}
	}

	private bool DetectObstacleAhead(float distance, Vector3 direction, out BaseEntity avoidedEnt)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		avoidedEnt = null;
		RaycastHit val = default(RaycastHit);
		if (Physics.SphereCast(((Component)this).transform.position + ((Component)this).transform.forward + Vector3.up * 1f, avoidanceSphereRadius, direction, ref val, distance, LayerMask.op_Implicit(avoidanceObstacleMask)))
		{
			BaseEntity baseEntity = ((RaycastHit)(ref val)).collider.ToBaseEntity();
			if (baseEntity is TreeEntity)
			{
				avoidedEnt = baseEntity;
				return true;
			}
			if (baseEntity is ResourceEntity)
			{
				Physics.IgnoreCollision((Collider)(object)wheelCollider, ((RaycastHit)(ref val)).collider);
			}
		}
		return false;
	}

	private int DetermineAvoidanceDirection(float detectDistance)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.forward + ((Component)this).transform.right * 0.5f;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = ((Component)this).transform.forward - ((Component)this).transform.right * 0.5f;
		Vector3 normalized2 = ((Vector3)(ref val)).normalized;
		float num = CheckSideClearance(normalized, detectDistance);
		float num2 = CheckSideClearance(normalized2, detectDistance);
		if (!(num > num2))
		{
			return -1;
		}
		return 1;
	}

	private float CheckSideClearance(Vector3 direction, float distance)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.SphereCast(((Component)this).transform.position + Vector3.up * 1f, avoidanceSphereRadius, direction, ref val, distance, LayerMask.op_Implicit(avoidanceObstacleMask)))
		{
			if (((RaycastHit)(ref val)).collider.ToBaseEntity() is TreeEntity)
			{
				return ((RaycastHit)(ref val)).distance;
			}
			return distance;
		}
		return distance;
	}

	public void OnRagdollCollisionEnter(Collision collision)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		OnLanded(Mathf.Abs(collision.relativeVelocity.y));
	}

	protected void OnCollisionEnter(Collision collision)
	{
		if (base.isServer)
		{
			ProcessCollision(collision, rigidBody);
		}
	}

	protected void ProcessCollision(Collision collision, Rigidbody ourRigidbody)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && collision != null && !((Object)(object)collision.gameObject == (Object)null) && !((Object)(object)collision.gameObject == (Object)null))
		{
			Vector3 relativeVelocity = collision.relativeVelocity;
			float num = ((Vector3)(ref relativeVelocity)).magnitude * rigidBody.mass;
			float num2 = Vector3.Dot(-((ContactPoint)(ref collision.contacts[0])).normal, ((Component)this).transform.forward);
			float num3 = Mathf.Lerp(0.2f, 1f, Mathf.Clamp01(num2));
			num *= num3;
			if (QueueCollisionDamage(this, num) > 0f)
			{
				TryShowCollisionFX(collision);
			}
		}
	}

	private float QueueCollisionDamage(BaseEntity hitEntity, float forceMagnitude)
	{
		float num = Mathf.InverseLerp(minCollisionDamageForce, maxCollisionDamageForce, forceMagnitude);
		if (num > 0f)
		{
			float num2 = Mathf.Lerp(1f, 200f, num) * collisionDamageMultiplier;
			if (damageSinceLastTick.TryGetValue(hitEntity, out var value))
			{
				if (value < num2)
				{
					damageSinceLastTick[hitEntity] = num2;
				}
			}
			else
			{
				damageSinceLastTick[hitEntity] = num2;
			}
		}
		return num;
	}

	protected virtual void DoCollisionDamage(BaseEntity hitEntity, float damage)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		lastCrashDamage = damage;
		if (damage > playerDamageThreshold)
		{
			float damage2 = (damage - playerDamageThreshold) / 4f;
			DamageAllRiders(damage2);
		}
		if (damage > playerRagdollThreshold)
		{
			Vector3 mountRagdollVelocity = GetMountRagdollVelocity(GetDriver());
			RagdollAllRiders(mountRagdollVelocity);
		}
		Hurt(damage, DamageType.Collision, this, useProtection: false);
		if (damage > playerRagdollThreshold && !IsDead() && !HasFlag(Flags.Reserved12))
		{
			RagdollHorse();
		}
	}

	private void OnLanded(float impactSpeed)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		float num = DamageFromFalling(impactSpeed, checkAirtime: true);
		if (num != 0f)
		{
			Hurt(num, DamageType.Fall, this, useProtection: false);
			TryShowCollisionFX(((Component)this).transform.position);
			if (num > playerDamageThreshold)
			{
				float damage = (num - playerDamageThreshold) / 4f;
				DamageAllRiders(damage);
			}
			if (num > 100f)
			{
				RagdollAllRiders();
			}
		}
	}

	private float DamageFromFalling(float impactSpeed, bool checkAirtime)
	{
		float result = 0f;
		if (impactSpeed > 5f && (!checkAirtime || airTime > 0.4f))
		{
			result = (impactSpeed - 5f) * 10f;
		}
		return result;
	}

	private void DamageAllRiders(float damage)
	{
		BasePlayer driver = GetDriver();
		if ((Object)(object)driver != (Object)null && !driver.IsDead())
		{
			driver.Hurt(damage, DamageType.Collision, this, useProtection: false);
		}
		BasePlayer passenger = GetPassenger();
		if ((Object)(object)passenger != (Object)null && !passenger.IsDead())
		{
			passenger.Hurt(damage, DamageType.Collision, this, useProtection: false);
		}
	}

	private void RagdollAllRiders(Vector3 force = default(Vector3))
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer driver = GetDriver();
		if ((Object)(object)driver != (Object)null && !driver.IsDead())
		{
			driver.Ragdoll(force);
		}
		BasePlayer passenger = GetPassenger();
		if ((Object)(object)passenger != (Object)null && !passenger.IsDead())
		{
			passenger.Ragdoll(force);
		}
	}

	public override GameObjectRef GetCollisionFX()
	{
		return collisionEffect;
	}

	public override Vector3 GetMountRagdollVelocity(BasePlayer player)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Clamp(lastCrashDamage, 0f, 75f);
		return ((Component)this).transform.forward * num * 0.25f;
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return Mathf.Abs(GetSpeed()) * 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	[ServerVar]
	public static void Ragdoll(Arg arg)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		List<RidableHorse> list = Pool.Get<List<RidableHorse>>();
		Vis.Entities(basePlayer.eyes.position, basePlayer.eyes.position + basePlayer.eyes.HeadForward() * 5f, 0f, list, -1, (QueryTriggerInteraction)2);
		foreach (RidableHorse item in list)
		{
			item.RagdollHorse();
		}
		Pool.FreeUnmanaged<RidableHorse>(ref list);
	}

	public void RagdollHorse()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (!Physics.allowhorsetempragdoll)
		{
			DismountAllPlayers();
		}
		else if (!HasFlag(Flags.Reserved12))
		{
			DismountAllPlayers();
			CreateRagdoll(((Component)this).transform.position, ((Component)this).transform.rotation);
			SetFlag(Flags.Reserved12, b: true);
			SendNetworkUpdateImmediate();
		}
	}

	private void CreateRagdoll(Vector3 position, Quaternion rotation)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		BaseAnimalRagdoll baseAnimalRagdoll = GameManager.server.CreateEntity(ragdollPrefab.resourcePath) as BaseAnimalRagdoll;
		if (baseAnimalRagdoll != null)
		{
			((Component)baseAnimalRagdoll).transform.SetPositionAndRotation(position, rotation);
		}
		Ragdoll ragdoll = ((baseAnimalRagdoll != null) ? ((Component)baseAnimalRagdoll).GetComponent<Ragdoll>() : null);
		if ((Object)(object)ragdoll != (Object)null)
		{
			ragdoll.simOnServer = true;
		}
		baseAnimalRagdoll?.InitFromEnt(this);
		baseAnimalRagdoll?.Spawn();
		GameObjectExtensions.SetIgnoreCollisions(((Component)this).gameObject, ((Component)baseAnimalRagdoll).gameObject, true);
	}

	private void OnRagdollStartServer()
	{
		TowDetach();
		SetLeading(null);
		rigidBody.isKinematic = true;
		((Collider)wheelCollider).enabled = false;
		SetWorldColliders(enabled: false);
		((Behaviour)serverLegsAnimator).enabled = false;
	}

	private void OnRagdollEndServer()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		rigidBody.isKinematic = false;
		((Collider)wheelCollider).enabled = true;
		currentGait = GaitType.Walk;
		UpdateGroundNormal();
		averagedUp = targetUp;
		AlignWithNormal(targetUp, force: true);
		isGrounded = true;
		airTime = 0f;
		lastMovingTime = Time.time;
		SetWorldColliders(enabled: true);
		ResetBonesPositions();
		((Behaviour)serverLegsAnimator).enabled = true;
		damageSinceLastTick.Clear();
		rigidBody.WakeUp();
	}

	private void SetWorldColliders(bool enabled)
	{
		List<Collider> list = Pool.Get<List<Collider>>();
		((Component)this).GetComponentsInChildren<Collider>(list);
		foreach (Collider item in list)
		{
			if (item.IsOnLayer((Layer)15))
			{
				item.enabled = enabled;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	private void UpdateOnTerrain()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		if (Time.time < nextTerrainCheckTime)
		{
			return;
		}
		nextTerrainCheckTime = Time.time + Random.Range(0.5f, 1f);
		onIdealTerrain = false;
		onWaterTopology = false;
		if ((Object)(object)TerrainMeta.TopologyMap != (Object)null)
		{
			int topology = TerrainMeta.TopologyMap.GetTopology(((Component)this).transform.position);
			if ((topology & 0x80800) != 0)
			{
				onIdealTerrain = true;
			}
			if ((topology & 0x14080) != 0)
			{
				onWaterTopology = true;
			}
		}
	}

	public void UpdateStamina(float delta)
	{
		if (currentGait == GaitType.Gallop)
		{
			UseStamina(delta);
		}
		else if (IsSwimming)
		{
			UseStamina(delta * 0.5f);
		}
		else if (currentStamina != currentMaxStamina)
		{
			ReplenishStamina(GetStaminaReplenishRatio() * delta);
		}
	}

	public void UseStamina(float amount)
	{
		if (onIdealTerrain)
		{
			amount *= 0.5f;
		}
		currentStamina -= amount;
		if (currentStamina <= 0f)
		{
			currentStamina = 0f;
		}
	}

	private float GetStaminaReplenishRatio()
	{
		return GetCurrentGait().staminaReplenishRatio;
	}

	public void ReplenishStamina(float amount)
	{
		float num = 1f + Mathf.InverseLerp(maxStamina * 0.5f, maxStamina, currentMaxStamina);
		amount *= num;
		amount = Mathf.Min(currentMaxStamina - currentStamina, amount);
		float num2 = Mathf.Min(currentMaxStamina - staminaCoreLossRatio * amount, amount * staminaCoreLossRatio);
		currentMaxStamina = Mathf.Clamp(currentMaxStamina - num2, 0f, maxStamina);
		currentStamina = Mathf.Clamp(currentStamina + num2 / staminaCoreLossRatio, 0f, currentMaxStamina);
		if (currentStamina == currentMaxStamina)
		{
			OnStaminaReplenished();
		}
	}

	private void OnStaminaReplenished()
	{
		UpdateClients(force: true);
	}

	public void ReplenishStaminaCore(float calories, float hydration)
	{
		float num = calories * calorieToStaminaRatio;
		float num2 = hydration * hydrationToStaminaRatio;
		num2 = Mathf.Min(maxStaminaCoreFromWater - currentMaxStamina, num2);
		if (num2 < 0f)
		{
			num2 = 0f;
		}
		float num3 = num + num2;
		currentMaxStamina = Mathf.Clamp(currentMaxStamina + num3, 0f, maxStamina);
		currentStamina = Mathf.Clamp(currentStamina + num3, 0f, currentMaxStamina);
	}

	public void SetLeading(BasePlayer target)
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Reserved16, (Object)(object)target != (Object)null);
		if (!((Object)(object)target == (Object)(object)leadingPlayer))
		{
			if ((Object)(object)target != (Object)null)
			{
				playerLeadingId = target.net.ID;
				inputProvider = new AIHorseInputProvider(this, ((Component)target).transform, 3f);
				PlayerModifiers.AddToPlayer(target, pullingPlayerModifiers);
			}
			else
			{
				leadingPlayer.modifiers.RemoveFromSource(Modifier.ModifierSource.Interaction);
				playerLeadingId = default(NetworkableId);
			}
			leadingPlayer = target;
			SendNetworkUpdateImmediate();
			LeadingChanged();
			if ((Object)(object)leadingPlayer == (Object)null)
			{
				ClientRPC(RpcTarget.NetworkGroup("CLIENT_StopLeading"));
			}
			else
			{
				ClientRPC(RpcTarget.NetworkGroup("CLIENT_StartLeading"));
			}
		}
	}

	public void LeadingChanged()
	{
		if (!IsLeading)
		{
			TryToHitch();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	public void SERVER_Lead(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		bool flag = msg.read.Bool();
		if (flag)
		{
			if (!CanLead(player))
			{
				return;
			}
		}
		else if (!CanStopLead(player))
		{
			return;
		}
		if (Interface.CallHook("OnHorseLead", (object)this, (object)player) == null)
		{
			SetLeading(flag ? player : null);
		}
	}

	public bool CanStand()
	{
		if (nextStandTime > Time.time)
		{
			return false;
		}
		if ((Object)(object)mountPoints[0].mountable == (Object)null)
		{
			return false;
		}
		return IsStandCollisionClear();
	}

	public virtual bool IsStandCollisionClear()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(((Component)mountPoints[0].mountable.eyePositionOverride).transform.position - ((Component)this).transform.forward * 1f, 2f, list, 2162689, (QueryTriggerInteraction)2);
		bool num = list.Count > 0;
		Pool.FreeUnmanaged<Collider>(ref list);
		return !num;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		InitContainers();
		SetBreed(Random.Range(0, breeds.Length));
		SetFlag(Flags.Reserved16, b: false);
		baseHorseProtection = baseProtection;
		riderProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
		baseProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
		baseProtection.Add(baseHorseProtection, 1f);
		rigidBody.centerOfMass = centreOfMassTransform.localPosition;
		terrainHandler = new VehicleTerrainHandler(this);
		towingTrigger.OnEntityEnterTrigger = HandleTowTrigger;
		towingTrigger.OnEntityLeaveTrigger = HandleTowTriggerLeave;
		towingAttachment = new TowingAttachment<RidableHorse>(this);
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.333f, 0.1f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)HorseDecay, Random.Range(30f, 60f), 60f, 6f);
		SpawnWildSaddle();
		EquipmentUpdate();
		if ((Object)(object)modifiers != (Object)null)
		{
			modifiers.ServerInit(this);
		}
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		CreateInventories(giveUID: false);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		ReleaseInventories();
	}

	private void ServerFlagsChanged(Flags old, Flags next)
	{
		if ((old & Flags.Reserved3) != 0 && (next & Flags.Reserved3) != 0)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)EatFromHitch, Random.Range(1f, 2f), 2f);
		}
		if ((next & Flags.Reserved13) != 0 && (next & Flags.Reserved14) != 0)
		{
			TowDetach();
		}
		bool flag = (old & Flags.Reserved12) != 0;
		bool flag2 = (next & Flags.Reserved12) != 0;
		if (!flag && flag2)
		{
			OnRagdollStartServer();
		}
		else if (flag && !flag2)
		{
			OnRagdollEndServer();
		}
	}

	private void SpawnWildSaddle()
	{
		SetSeatCount(1);
	}

	public void SetForSale()
	{
		SetFlag(Flags.Reserved2, b: true);
		SetSeatCount(0);
	}

	protected override bool IsSeatClipping(BaseMountable mountable, Vector3 startPos, float radius, int mask, Vector3 seatPos, Vector3 direction)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		radius *= 0.5f;
		return base.IsSeatClipping(mountable, startPos, radius, mask, seatPos, direction);
	}

	protected override int GetClipCheckMask()
	{
		return base.GetClipCheckMask() & -1073741825;
	}

	private bool IsHorseClipping()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 localToWorldMatrix = ((Component)clippingMountCheckCollider).transform.localToWorldMatrix;
		Vector3 val = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(clippingMountCheckCollider.center);
		Vector3 val2 = Vector3.zero;
		((Vector3)(ref val2))[clippingMountCheckCollider.direction] = 1f;
		val2 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyVector(val2);
		float num = clippingMountCheckCollider.radius * 0.9f;
		float num2 = 0.5f * clippingMountCheckCollider.height * 0.9f - num;
		Vector3 point = val + val2 * num2;
		Vector3 point2 = val - val2 * num2;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapCapsule(point, point2, num, list, 1235583233, (QueryTriggerInteraction)1);
		for (int i = 0; i < list.Count; i++)
		{
			BaseEntity baseEntity = list[i].ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)null && (baseEntity.isClient != base.isClient || (Object)(object)baseEntity == (Object)(object)this))
			{
				ListEx.RemoveUnordered<Collider>(list, i);
				i--;
			}
		}
		bool result = list.Count > 0;
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (IsForSale || !MountEligable(player) || HasFlag(Flags.Reserved12) || IsPlayerTooHeavy(player) || !CanPlayerSeeSaddlePoint(player) || IsHorseClipping())
		{
			return;
		}
		BaseMountable baseMountable = null;
		if (HasSingleSaddle && !player.IsRestrained)
		{
			baseMountable = mountPoints[0].mountable;
		}
		else
		{
			if (!HasDoubleSaddle)
			{
				return;
			}
			baseMountable = ((HasDriver() || player.IsRestrained) ? mountPoints[2].mountable : mountPoints[1].mountable);
		}
		if ((Object)(object)baseMountable != (Object)null)
		{
			baseMountable.AttemptMount(player, doMountChecks);
		}
	}

	public override void PlayerMounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerMounted(player, seat);
		UpdateClients();
		TryLeaveHitch();
		if (IsLeading)
		{
			SetLeading(null);
		}
		if (IsDriver(player))
		{
			((Component)playerServerCollider).gameObject.SetActive(true);
			inputProvider = new PlayerHorseInputProvider(player);
		}
		if (IsPassenger(player))
		{
			((Component)playerServerColliderRear).gameObject.SetActive(true);
		}
		((FacepunchBehaviour)this).InvokeRepeating((Action)SaveTraveledDistance, 10f, 10f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)PostPlayerLateUpdate, 0f, 0f);
	}

	public override void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerDismounted(player, seat);
		UpdateClients(force: true);
		if (NumMounted() == 0)
		{
			TryToHitch();
		}
		if ((Object)(object)GetDriver() == (Object)null)
		{
			((Component)playerServerCollider).gameObject.SetActive(false);
			inputProvider = null;
		}
		if ((Object)(object)GetPassenger() == (Object)null)
		{
			((Component)playerServerColliderRear).gameObject.SetActive(false);
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)SaveTraveledDistance);
		((FacepunchBehaviour)this).CancelInvoke((Action)PostPlayerLateUpdate);
		lastRiddenTime = Time.time;
	}

	private void PostPlayerLateUpdate()
	{
		if (!AnyMounted())
		{
			return;
		}
		foreach (MountPointInfo allMountPoint in base.allMountPoints)
		{
			if (!((Object)(object)allMountPoint.mountable == (Object)null) && !((Object)(object)allMountPoint.mountable.GetMounted() == (Object)null))
			{
				allMountPoint.mountable.MountedPlayerSync();
			}
		}
	}

	private void SetSeatCount(int count)
	{
		SetFlag(Flags.Reserved9, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved10, b: false, recursive: false, networkupdate: false);
		switch (count)
		{
		case 1:
			SetFlag(Flags.Reserved9, b: true, recursive: false, networkupdate: false);
			break;
		case 2:
			SetFlag(Flags.Reserved10, b: true, recursive: false, networkupdate: false);
			break;
		}
		UpdateMountFlags();
	}

	public override bool IsPlayerSeatSwapValid(BasePlayer player, int fromIndex, int toIndex, bool ignoreRestraint)
	{
		if (!base.IsPlayerSeatSwapValid(player, fromIndex, toIndex, ignoreRestraint))
		{
			return false;
		}
		if (!HasSaddle)
		{
			return false;
		}
		if (HasSingleSaddle)
		{
			return false;
		}
		if (HasDoubleSaddle && toIndex == 0)
		{
			return false;
		}
		return true;
	}

	public override int MaxMounted()
	{
		return GetSeatCapacity();
	}

	public int GetSeatCapacity()
	{
		if (HasDoubleSaddle)
		{
			return 2;
		}
		if (HasSingleSaddle)
		{
			return 1;
		}
		return 0;
	}

	public override int NumSwappableSeats()
	{
		return mountPoints.Count;
	}

	public override void OnDied(HitInfo hitInfo)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		BaseCorpse baseCorpse = DropCorpse(corpsePrefab.resourcePath);
		if (Object.op_Implicit((Object)(object)baseCorpse))
		{
			SetupCorpse(baseCorpse);
			baseCorpse.Spawn();
			baseCorpse.TakeChildren(this);
		}
		SaveTraveledDistance();
		TryLeaveHitch();
		TowDetach();
		RagdollAllRiders();
		((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.5f);
		base.OnDied(hitInfo);
	}

	public override void AdminKill()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		SaveTraveledDistance();
		TryLeaveHitch();
		TowDetach();
		RagdollAllRiders();
		((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.5f);
		base.AdminKill();
	}

	public virtual void SetupCorpse(BaseCorpse corpse)
	{
		corpse.flags = flags;
		LootableCorpse component = ((Component)corpse).GetComponent<LootableCorpse>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.TakeFrom(this, storageInventory);
		}
		HorseCorpse component2 = ((Component)corpse).GetComponent<HorseCorpse>();
		if (Object.op_Implicit((Object)(object)component2))
		{
			component2.breedIndex = currentBreedIndex;
		}
	}

	private void UpdateClients()
	{
		UpdateClients(force: true);
	}

	private void UpdateClients(bool force = false)
	{
		if (force || AnyMounted() || IsLeading)
		{
			byte num = (byte)((duckInputDown ? (-1f) : throttleInput) + 1f);
			byte b = (byte)(steerInput + 1f);
			byte b2 = (byte)(avoidanceSteeringInput + 1);
			byte arg = (byte)(num | (b << 2) | (b2 << 4));
			byte arg2 = (byte)Mathf.Clamp(normalVariation / 100f * 255f, 0f, 255f);
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_HorseUpdate"), currentStamina, currentMaxStamina, (byte)currentGait, arg, arg2);
		}
	}

	public override void OnMountedPlayerWeightChanged(BasePlayer player)
	{
		base.OnMountedPlayerWeightChanged(player);
		if (IsPlayerTooHeavy(player))
		{
			player.EnsureDismounted();
		}
	}

	private void SaveTraveledDistance()
	{
		BasePlayer driver = GetDriver();
		if ((Object)(object)driver == (Object)null)
		{
			tempDistanceTravelled = 0f;
			return;
		}
		kmDistance += tempDistanceTravelled / 1000f;
		if (kmDistance >= 1f)
		{
			driver.stats.Add("horse_distance_ridden_km", 1, (Stats)5);
			kmDistance -= 1f;
		}
		driver.stats.Add("horse_distance_ridden", Mathf.FloorToInt(tempDistanceTravelled));
		driver.stats.Save();
		tempDistanceTravelled = 0f;
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		riderProtection.Scale(info.damageTypes);
	}

	public void OnTowAttach()
	{
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			ComponentExtensions.SetActive<TriggerTowing>(towingTrigger, false);
		}, 0f);
	}

	public void OnTowDetach()
	{
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			ComponentExtensions.SetActive<TriggerTowing>(towingTrigger, true);
		}, 1f);
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_RequestTow(RPCMessage msg)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (towableEntity != null && !IsTowing && !HasFlag(Flags.Reserved12))
		{
			TowAttach(msg.player);
			Effect.server.Run(towingAttachEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	public void SERVER_RequestDetach(RPCMessage msg)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (IsTowing)
		{
			BasePlayer player = msg.player;
			if (!((Object)(object)player == (Object)null) && (!AnyMounted() || !((Object)(object)player.GetMounted().VehicleParent() != (Object)(object)this)))
			{
				TowDetach();
				Effect.server.Run(towingDetachEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

	private void TowAttach(BasePlayer requester = null)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		if (towableEntity == null || !towableEntity.IsTowingAllowed)
		{
			return;
		}
		if (Vector3.Dot(TowAnchor.forward, ((Component)towableEntity.TowAnchor).transform.forward) <= 0.5f)
		{
			if ((Object)(object)requester != (Object)null)
			{
				requester.ShowToast(GameTip.Styles.Error, TowAngleErrorPhrase, false);
			}
			return;
		}
		towingEntityId = towableEntity.TowEntity.net.ID;
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_SetTowId"), towableEntity.TowEntity.net.ID);
		towingAttachment.AttachTo(towableEntity);
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			ComponentExtensions.SetActive<TriggerTowing>(towingTrigger, false);
		}, 0f);
	}

	private void TowDetach()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (IsTowing)
		{
			towingEntityId = default(NetworkableId);
			((BaseEntity)this).ClientRPC(RpcTarget.NetworkGroup("CLIENT_SetTowId"), default(NetworkableId));
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_CanTow"), arg1: false);
			towableEntity = null;
			towingAttachment.Detach();
		}
	}

	private void ValidateTowableEntity()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (towableEntity != null)
		{
			towingEntityId = towableEntity.TowEntity.net.ID;
		}
		else
		{
			towableEntity = BaseNetworkable.serverEntities.Find(towingEntityId) as ITowing;
		}
	}

	private void HandleTowTrigger(BaseNetworkable networkable)
	{
		if (networkable is ITowing { IsTowing: false } towing)
		{
			towableEntity = towing;
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_CanTow"), arg1: true);
		}
		else
		{
			towableEntity = null;
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_CanTow"), arg1: false);
		}
	}

	private void HandleTowTriggerLeave(BaseNetworkable networkable)
	{
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_CanTow"), arg1: false);
		towableEntity = null;
	}

	public void OnJointBreak(float breakForce)
	{
		TowDetach();
	}

	private void HorseDecay()
	{
		if (base.healthFraction != 0f && !base.IsDestroyed && !(Time.time < lastRiddenTime + 600f) && !(Time.time < lastEatTime + 600f) && !IsForSale && !(Time.time < nextDecayTime))
		{
			float num = 1f / decayMinutes;
			float num2 = ((!IsOutside()) ? 1f : 0.5f);
			Hurt(MaxHealth() * num * num2, DamageType.Decay, this, useProtection: false);
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (!IsForSale)
		{
			base.Hurt(info);
		}
	}

	private void AddDecayDelay(float time)
	{
		if (nextDecayTime < Time.time)
		{
			nextDecayTime = Time.time + 5f;
		}
		nextDecayTime += time;
	}

	[ServerVar]
	public static void SetHorseBreed(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		int @int = arg.GetInt(0, 0);
		List<RidableHorse> list = Pool.Get<List<RidableHorse>>();
		Vis.Entities(basePlayer.eyes.position, basePlayer.eyes.position + basePlayer.eyes.HeadForward() * 5f, 0f, list, -1, (QueryTriggerInteraction)2);
		foreach (RidableHorse item in list)
		{
			item.SetBreed(@int);
		}
		Pool.FreeUnmanaged<RidableHorse>(ref list);
	}

	[ServerVar]
	public static void SetForSale(Arg arg)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		List<RidableHorse> list = Pool.Get<List<RidableHorse>>();
		Vis.Entities(basePlayer.eyes.position, basePlayer.eyes.position + basePlayer.eyes.HeadForward() * 5f, 0f, list, -1, (QueryTriggerInteraction)2);
		foreach (RidableHorse item in list)
		{
			item.SetForSale();
		}
		Pool.FreeUnmanaged<RidableHorse>(ref list);
	}

	public override bool AdminFixUp(int tier)
	{
		if (IsDead())
		{
			return false;
		}
		ReplenishStamina(1000f);
		ReplenishStaminaCore(10000f, 10000f);
		return base.AdminFixUp(tier);
	}

	void IMedicalToolTarget.OnMedicalToolApplied(BasePlayer fromPlayer, ItemDefinition itemDef, ItemModConsumable consumable, MedicalTool medicalToolEntity, bool canRevive)
	{
		foreach (ItemModConsumable.ConsumableEffect effect in consumable.effects)
		{
			if (effect.type == MetabolismAttribute.Type.Health)
			{
				Heal(effect.amount * healingMultiplier);
				ReplenishStamina(staminaReplenishAmount);
			}
		}
		modifiers.Add(consumable.modifiers);
	}
}


public enum GaitType : byte
{
	Walk,
	Trot,
	Canter,
	Gallop
}


using System;

[Serializable]
public struct Gait
{
	public GaitType gaitType;

	public float minSpeed;

	public float maxSpeed;

	public float accelerationForce;

	public float brakingForce;

	public float turnSpeed;

	public float staminaReplenishRatio;

	public bool equipmentScalesMaxSpeed;

	public bool breedScalesMaxSpeed;
}


using System;
using UnityEngine;

[Serializable]
public struct PurchaseOption
{
	public ItemDefinition tokenItem;

	public Phrase title;

	public Phrase description;

	public Sprite icon;

	public int order;
}


public enum HorseAvoidanceState
{
	Normal,
	AvoidingObstacle
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class RustigeEgg : BaseCombatEntity
{
	public const Flags Flag_Spin = Flags.Reserved1;

	public Transform eggRotationTransform;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RustigeEgg.OnRpcMessage", 0);
		try
		{
			if (rpc == 4254195175u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4254195175u, "RPC_Open", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Open(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Open");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1455840454 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Spin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Spin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1455840454u, "RPC_Spin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_Spin(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Spin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsSpinning()
	{
		return HasFlag(Flags.Reserved1);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Spin(RPCMessage msg)
	{
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Open(RPCMessage msg)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null)
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag != IsOpen())
		{
			if (flag)
			{
				ClientRPC(RpcTarget.NetworkGroup("FaceEggPosition"), msg.player.eyes.position);
				((FacepunchBehaviour)this).Invoke((Action)CloseEgg, 60f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)CloseEgg);
			}
			SetFlag(Flags.Open, flag, recursive: false, networkupdate: false);
			if (IsSpinning() && flag)
			{
				SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
			}
			SendNetworkUpdateImmediate();
		}
	}

	public void CloseEgg()
	{
		SetFlag(Flags.Open, b: false);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class Sail : DecayEntity, IBoatBuildingPiece, IBoatPropulsion
{
	[Header("Sail")]
	public float MaxThrust = 1000f;

	public float RaiseDuration = 1.5f;

	public float LowerDuration = 1.5f;

	public GameObject LoweredCollider;

	public GameObject RaisedCollider;

	public List<Transform> WindBlockedCheckPoints;

	public float WindBlockedCheckRadius = 0.5f;

	public float WindBlockedCheckDistance = 1.5f;

	[Header("Visuals")]
	public Transform SailVisualRoot;

	public Animator Animator;

	public GameObjectRef sailRotateEffect;

	public const Flags Flag_Lowered = Flags.Reserved3;

	public const Flags Flag_Lowering = Flags.Reserved12;

	public const Flags Flag_Raising = Flags.Reserved13;

	public const Flags Flag_WindBlocked = Flags.Reserved14;

	private TimeUntil timeUntilLoweredRaised;

	public bool Lowering => HasFlag(Flags.Reserved12);

	public bool Raising => HasFlag(Flags.Reserved13);

	public bool Lowered => HasFlag(Flags.Reserved3);

	public bool Blowing
	{
		get
		{
			if (Lowered || Lowering || Raising)
			{
				return !WindBlocked;
			}
			return false;
		}
	}

	public bool WindBlocked => HasFlag(Flags.Reserved14);

	public Vector3 ThrustPosition => ((Component)this).transform.position + ((Component)this).transform.up * 1f;

	public Vector3 Direction => ((Component)this).transform.forward;

	float IBoatPropulsion.MaxThrust => MaxThrust;

	public float CurrentThrust
	{
		get
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			if (Blowing)
			{
				if (Lowering)
				{
					return (LowerDuration - TimeUntil.op_Implicit(timeUntilLoweredRaised)) / LowerDuration * MaxThrust;
				}
				if (Raising)
				{
					return TimeUntil.op_Implicit(timeUntilLoweredRaised) / RaiseDuration * MaxThrust;
				}
				return MaxThrust;
			}
			return 0f;
		}
	}

	public float ThrustRatio => CurrentThrust / MaxThrust;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Sail.OnRpcMessage", 0);
		try
		{
			if (rpc == 842631481 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - LowerSail "));
				}
				TimeWarning val2 = TimeWarning.New("LowerSail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(842631481u, "LowerSail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(842631481u, "LowerSail", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							LowerSail(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in LowerSail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1744516204 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RaiseSail "));
				}
				TimeWarning val2 = TimeWarning.New("RaiseSail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1744516204u, "RaiseSail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1744516204u, "RaiseSail", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RaiseSail(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RaiseSail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2730316685u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RotateSail "));
				}
				TimeWarning val2 = TimeWarning.New("RotateSail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2730316685u, "RotateSail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2730316685u, "RotateSail", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RotateSail(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RotateSail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ResetFlags();
		CacheIsWindBlocked();
	}

	private void ResetFlags()
	{
		SetFlag(Flags.Reserved14, b: false);
		SetFlag(Flags.Reserved3, b: false);
		SetFlag(Flags.Reserved13, b: false);
		SetFlag(Flags.Reserved12, b: false);
		SetFlag(Flags.Busy, b: false);
	}

	public override void Hurt(HitInfo info)
	{
		PlayerBoat parentPlayerBoat = PlayerBoat.GetParentPlayerBoat(this);
		if ((Object)(object)parentPlayerBoat != (Object)null)
		{
			parentPlayerBoat.OnBoatDeployableHurt(this, info);
		}
		else
		{
			base.Hurt(info);
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		((FacepunchBehaviour)this).CancelInvoke((Action)CacheIsWindBlocked);
		((FacepunchBehaviour)this).InvokeRandomized((Action)CacheIsWindBlocked, 0f, 5f, 2f);
	}

	private void CacheIsWindBlocked()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (Lowered)
		{
			if (!IsOutside())
			{
				SetFlag(Flags.Reserved14, b: true);
			}
			else
			{
				SetFlag(Flags.Reserved14, IsLocationWindBlocked(WindBlockedCheckPoints, ((Component)this).transform.position, ((Component)this).transform.rotation, WindBlockedCheckRadius, WindBlockedCheckDistance, this));
			}
		}
	}

	public static bool IsLocationWindBlocked(List<Transform> checkPoints, Vector3 worldPosition, Quaternion worldRotation, float radius, float distance, BaseEntity toIgnore, bool ignoreClient = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		int layerMask = 136323328;
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		Matrix4x4 val = Matrix4x4.TRS(worldPosition, worldRotation, Vector3.one);
		foreach (Transform checkPoint in checkPoints)
		{
			list.Clear();
			GamePhysics.TraceAllUnordered(new Ray(((Matrix4x4)(ref val)).MultiplyPoint3x4(checkPoint.localPosition), worldRotation * checkPoint.localRotation * Vector3.forward), radius, list, distance, layerMask, (QueryTriggerInteraction)0, toIgnore);
			for (int i = 0; i < list.Count; i++)
			{
				BaseEntity entity = list[i].GetEntity();
				if (!(Object.op_Implicit((Object)(object)entity) && entity.isClient && ignoreClient))
				{
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return true;
				}
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return false;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer && info.fromDisk)
		{
			Raise(null, instant: true);
		}
		ToggleColliders();
	}

	private void ToggleColliders()
	{
		RaisedCollider.SetActive(!Lowered);
		LoweredCollider.SetActive(Lowered);
	}

	public bool CanBeRaised(BasePlayer player)
	{
		object obj = Interface.CallHook("CanRaiseSail", (object)this, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)player != (Object)null && !PlayerBoat.IsPlayerAuthedOnChildEntity(this, player, authedIfNoPrivOrLock: true))
		{
			return false;
		}
		if (!PlayerBoat.IsChildOfInteractablePlayerBoat(this))
		{
			return false;
		}
		if (IsBusy())
		{
			return false;
		}
		if (!Lowered)
		{
			return false;
		}
		return true;
	}

	public bool CanBeLowered(BasePlayer player)
	{
		object obj = Interface.CallHook("CanLowerSail", (object)this, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)player != (Object)null && !PlayerBoat.IsPlayerAuthedOnChildEntity(this, player, authedIfNoPrivOrLock: true))
		{
			return false;
		}
		if (!PlayerBoat.IsChildOfInteractablePlayerBoat(this))
		{
			return false;
		}
		if (IsBusy())
		{
			return false;
		}
		if (Lowered)
		{
			return false;
		}
		return true;
	}

	public bool CanRotate(BasePlayer player)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanRotateSail", (object)this, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (IsBusy())
		{
			return false;
		}
		if (Lowered || Lowering)
		{
			return false;
		}
		if (!PlayerBoat.IsPlayerAuthedOnChildEntity(this, player, authedIfNoPrivOrLock: true))
		{
			return false;
		}
		DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(prefabID);
		return DeployVolume.Check(((Component)this).transform.position, ((Component)this).transform.rotation * Quaternion.AngleAxis(180f, Vector3.up), volumes, ~(1 << ((Component)this).gameObject.layer));
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void LowerSail(RPCMessage msg)
	{
		Lower(msg.player);
	}

	public void Lower(BasePlayer player)
	{
		if (CanBeLowered(player))
		{
			SetFlag(Flags.Busy, b: true);
			SetFlag(Flags.Reserved12, b: true);
			WaitForLower();
		}
	}

	private void WaitForLower()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		((FacepunchBehaviour)this).CancelInvoke((Action)OnFullyLowered);
		timeUntilLoweredRaised = TimeUntil.op_Implicit(LowerDuration);
		((FacepunchBehaviour)this).Invoke((Action)OnFullyLowered, LowerDuration);
	}

	private void OnFullyLowered()
	{
		SetFlag(Flags.Busy, b: false);
		SetFlag(Flags.Reserved12, b: false);
		SetFlag(Flags.Reserved13, b: false);
		SetFlag(Flags.Reserved3, b: true);
		OnRaisedOrLowered();
	}

	private void OnRaisedOrLowered()
	{
		CacheIsWindBlocked();
		ToggleColliders();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void RaiseSail(RPCMessage msg)
	{
		Raise(msg.player);
	}

	public void Raise(BasePlayer player, bool instant = false)
	{
		if (instant)
		{
			OnFullyRaised();
		}
		else if (CanBeRaised(player))
		{
			SetFlag(Flags.Busy, b: true);
			SetFlag(Flags.Reserved13, b: true);
			WaitForRaise();
		}
	}

	private void WaitForRaise()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		((FacepunchBehaviour)this).CancelInvoke((Action)OnFullyRaised);
		timeUntilLoweredRaised = TimeUntil.op_Implicit(RaiseDuration);
		((FacepunchBehaviour)this).Invoke((Action)OnFullyRaised, RaiseDuration);
	}

	private void OnFullyRaised()
	{
		SetFlag(Flags.Busy, b: false);
		SetFlag(Flags.Reserved13, b: false);
		SetFlag(Flags.Reserved12, b: false);
		SetFlag(Flags.Reserved3, b: false);
		OnRaisedOrLowered();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void RotateSail(RPCMessage msg)
	{
		RotateSail(msg.player);
	}

	private void RotateSail(BasePlayer player)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if (CanRotate(player))
		{
			Transform transform = ((Component)this).transform;
			transform.localRotation *= Quaternion.AngleAxis(180f, Vector3.up);
			CacheIsWindBlocked();
			SendNetworkUpdateImmediate();
			if (sailRotateEffect.isValid)
			{
				Effect.server.Run(sailRotateEffect.resourcePath, this, 0u, default(Vector3), default(Vector3), null, broadcast: false, null, 0, Effect.Type.Generic);
			}
		}
	}

	void IBoatBuildingPiece.OnAddedToBoat(PlayerBoat boat)
	{
		Raise(null);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old.HasFlag(Flags.Reserved3) != next.HasFlag(Flags.Reserved3))
		{
			ToggleColliders();
		}
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (base.ShouldDisplayPickupOption(player))
		{
			return !PlayerBoat.IsChildOfFinishedPlayerBoat(this);
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SamSite : ContainerIOEntity
{
	public interface ISamSiteTarget
	{
		static List<ISamSiteTarget> serverList;

		SamTargetType SAMTargetType { get; }

		bool isClient { get; }

		bool IsValidSAMTarget(bool staticRespawn);

		Vector3 CenterPoint();

		Vector3 GetWorldVelocity();

		bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity);

		static ISamSiteTarget()
		{
			serverList = new List<ISamSiteTarget>();
		}
	}

	public class SamTargetType
	{
		public readonly float scanRadius;

		public readonly float speedMultiplier;

		public readonly float timeBetweenBursts;

		public SamTargetType(float scanRadius, float speedMultiplier, float timeBetweenBursts)
		{
			this.scanRadius = scanRadius;
			this.speedMultiplier = speedMultiplier;
			this.timeBetweenBursts = timeBetweenBursts;
		}
	}

	[Header("SAM Site")]
	public Animator pitchAnimator;

	public GameObject yaw;

	public GameObject pitch;

	public GameObject gear;

	public Transform eyePoint;

	public float gearEpislonDegrees = 20f;

	public float turnSpeed = 1f;

	public float clientLerpSpeed = 1f;

	public Vector3 currentAimDir = Vector3.forward;

	public Vector3 targetAimDir = Vector3.forward;

	public float vehicleScanRadius = 350f;

	public float missileScanRadius = 500f;

	public GameObjectRef projectileTest;

	public GameObjectRef muzzleFlashTest;

	public bool staticRespawn;

	public ItemDefinition ammoType;

	public Transform[] tubes;

	[ServerVar(Help = "how long until static sam sites auto repair")]
	public static float staticrepairseconds = 1200f;

	[ServerVar(Help = "Delay before SAM sites that haven't shot a target will auto-reload")]
	public static float autoreloaddelay = 45f;

	public SoundDefinition yawMovementLoopDef;

	public float yawGainLerp = 8f;

	public float yawGainMovementSpeedMult = 0.1f;

	public SoundDefinition pitchMovementLoopDef;

	public float pitchGainLerp = 10f;

	public float pitchGainMovementSpeedMult = 0.5f;

	public int lowAmmoThreshold = 5;

	public Flags Flag_TargetMode = Flags.Reserved9;

	public Flags Flag_ManuallySetMode = Flags.Reserved10;

	public static SamTargetType targetTypeUnknown;

	public static SamTargetType targetTypeVehicle;

	public static SamTargetType targetTypeMissile;

	public ISamSiteTarget currentTarget;

	public SamTargetType mostRecentTargetType;

	public Item ammoItem;

	public float lockOnTime;

	public float lastTargetVisibleTime;

	public int lastAmmoCount;

	public int currentTubeIndex;

	public int firedCount;

	private float reloadVolleyFinishTime;

	private TimeSince sinceLastRocketFired;

	private int input1Amount;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SamSite.OnRpcMessage", 0);
		try
		{
			if (rpc == 3160662357u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ToggleDefenderMode "));
				}
				TimeWarning val2 = TimeWarning.New("ToggleDefenderMode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3160662357u, "ToggleDefenderMode", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3160662357u, "ToggleDefenderMode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ToggleDefenderMode(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ToggleDefenderMode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool IsPowered()
	{
		if (!staticRespawn)
		{
			return HasFlag(Flags.Reserved8);
		}
		return true;
	}

	public override int ConsumptionAmount()
	{
		return 25;
	}

	public bool IsInDefenderMode()
	{
		return HasFlag(Flag_TargetMode);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	public void SetTarget(ISamSiteTarget target)
	{
		bool num = currentTarget != target;
		currentTarget = target;
		if (!target.IsUnityNull())
		{
			mostRecentTargetType = target.SAMTargetType;
		}
		if (num)
		{
			MarkIODirty();
		}
	}

	public void MarkIODirty()
	{
		if (!staticRespawn)
		{
			lastPassthroughEnergy = -1;
			MarkDirtyForceUpdateOutputs();
		}
	}

	public void ClearTarget()
	{
		SetTarget(null);
	}

	public override void ServerInit()
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		targetTypeUnknown = new SamTargetType(vehicleScanRadius, 1f, 5f);
		targetTypeVehicle = new SamTargetType(vehicleScanRadius, 1f, 5f);
		targetTypeMissile = new SamTargetType(missileScanRadius, 2.25f, 3.5f);
		mostRecentTargetType = targetTypeUnknown;
		ClearTarget();
		((FacepunchBehaviour)this).InvokeRandomized((Action)TargetScan, 1f, 3f, 0.2f);
		currentAimDir = ((Component)this).transform.forward;
		if (base.inventory != null && !staticRespawn)
		{
			base.inventory.onItemAddedRemoved = OnItemAddedRemoved;
		}
	}

	public void OnItemAddedRemoved(Item arg1, bool arg2)
	{
		EnsureAmmoLoaded();
		if (IsPowered())
		{
			MarkIODirty();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.samSite = Pool.Get<SAMSite>();
		info.msg.samSite.aimDir = GetAimDir();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (staticRespawn && HasFlag(Flags.Reserved1))
		{
			((FacepunchBehaviour)this).Invoke((Action)SelfHeal, staticrepairseconds);
		}
	}

	public void SelfHeal()
	{
		lifestate = LifeState.Alive;
		base.health = startHealth;
		SetFlag(Flags.Reserved1, b: false);
	}

	public override void Die(HitInfo info = null)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (staticRespawn)
		{
			ClearTarget();
			Quaternion val = Quaternion.LookRotation(currentAimDir, Vector3.up);
			val = Quaternion.Euler(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f);
			currentAimDir = val * Vector3.forward;
			((FacepunchBehaviour)this).Invoke((Action)SelfHeal, staticrepairseconds);
			lifestate = LifeState.Dead;
			base.health = 0f;
			SetFlag(Flags.Reserved1, b: true);
		}
		else
		{
			base.Die(info);
		}
	}

	public void FixedUpdate()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = currentAimDir;
		if (!currentTarget.IsUnityNull() && IsPowered())
		{
			float num = projectileTest.Get().GetComponent<ServerProjectile>().speed * currentTarget.SAMTargetType.speedMultiplier;
			Vector3 val2 = currentTarget.CenterPoint();
			float num2 = Vector3.Distance(val2, ((Component)eyePoint).transform.position);
			float num3 = num2 / num;
			Vector3 val3 = val2 + currentTarget.GetWorldVelocity() * num3;
			num3 = Vector3.Distance(val3, ((Component)eyePoint).transform.position) / num;
			val3 = val2 + currentTarget.GetWorldVelocity() * num3;
			Vector3 val4 = currentTarget.GetWorldVelocity();
			if (((Vector3)(ref val4)).magnitude > 0.1f)
			{
				float num4 = Mathf.Sin(Time.time * 3f) * (1f + num3 * 0.5f);
				Vector3 val5 = val3;
				val4 = currentTarget.GetWorldVelocity();
				val3 = val5 + ((Vector3)(ref val4)).normalized * num4;
			}
			val4 = val3 - ((Component)eyePoint).transform.position;
			currentAimDir = ((Vector3)(ref val4)).normalized;
			if (num2 > currentTarget.SAMTargetType.scanRadius)
			{
				ClearTarget();
			}
		}
		Quaternion val6 = Quaternion.LookRotation(currentAimDir, ((Component)this).transform.up);
		Vector3 eulerAngles = ((Quaternion)(ref val6)).eulerAngles;
		eulerAngles = BaseMountable.ConvertVector(eulerAngles);
		float num5 = Mathf.InverseLerp(0f, 90f, 0f - eulerAngles.x);
		float num6 = Mathf.Lerp(15f, -75f, num5);
		Quaternion localRotation = Quaternion.Euler(0f, eulerAngles.y, 0f);
		yaw.transform.localRotation = localRotation;
		Quaternion localRotation2 = pitch.transform.localRotation;
		float x = ((Quaternion)(ref localRotation2)).eulerAngles.x;
		localRotation2 = pitch.transform.localRotation;
		Quaternion localRotation3 = Quaternion.Euler(x, ((Quaternion)(ref localRotation2)).eulerAngles.y, num6);
		pitch.transform.localRotation = localRotation3;
		if (currentAimDir != val)
		{
			SendNetworkUpdate();
		}
	}

	public Vector3 GetAimDir()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return currentAimDir;
	}

	public bool HasValidTarget()
	{
		return !currentTarget.IsUnityNull();
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (HasAmmo())
		{
			pickupErrorToFormat = (format: PickupErrors.ItemInventoryMustBeEmpty, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	private void AddTargetSet(List<ISamSiteTarget> allTargets, float scanRadius)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		foreach (ISamSiteTarget server in ISamSiteTarget.serverList)
		{
			if (!(server is MLRSRocket) && Vector3.Distance(server.CenterPoint(), ((Component)eyePoint).transform.position) < scanRadius)
			{
				allTargets.Add(server);
			}
		}
	}

	private void AddMLRSRockets(List<ISamSiteTarget> allTargets, float scanRadius)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (MLRSRocket.serverList.Count == 0)
		{
			return;
		}
		foreach (MLRSRocket server in MLRSRocket.serverList)
		{
			if (Vector3.Distance(((Component)server).transform.position, ((Component)this).transform.position) < scanRadius)
			{
				allTargets.Add(server);
			}
		}
	}

	public void TargetScan()
	{
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		if (!IsPowered())
		{
			lastTargetVisibleTime = 0f;
			return;
		}
		if (Time.time > lastTargetVisibleTime + 3f)
		{
			ClearTarget();
		}
		if (!staticRespawn)
		{
			int num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);
			bool flag = lastAmmoCount < lowAmmoThreshold;
			bool flag2 = num < lowAmmoThreshold;
			if (num != lastAmmoCount && flag != flag2)
			{
				MarkIODirty();
			}
			lastAmmoCount = num;
		}
		if (HasValidTarget() || IsDead())
		{
			return;
		}
		List<ISamSiteTarget> list = Pool.Get<List<ISamSiteTarget>>();
		if (Interface.CallHook("OnSamSiteTargetScan", (object)this, (object)list) == null)
		{
			if (!IsInDefenderMode())
			{
				AddTargetSet(list, targetTypeVehicle.scanRadius);
			}
			AddMLRSRockets(list, targetTypeMissile.scanRadius);
		}
		ISamSiteTarget samSiteTarget = null;
		foreach (ISamSiteTarget item in list)
		{
			if (!item.isClient && !(item.CenterPoint().y < ((Component)eyePoint).transform.position.y) && item.IsVisible(((Component)eyePoint).transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn) && Interface.CallHook("OnSamSiteTarget", (object)this, (object)item) == null)
			{
				samSiteTarget = item;
				break;
			}
		}
		if (!samSiteTarget.IsUnityNull() && currentTarget != samSiteTarget)
		{
			lockOnTime = Time.time + 0.5f;
		}
		SetTarget(samSiteTarget);
		if (!currentTarget.IsUnityNull())
		{
			lastTargetVisibleTime = Time.time;
		}
		Pool.FreeUnmanaged<ISamSiteTarget>(ref list);
		if (currentTarget.IsUnityNull())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)WeaponTick);
		}
		else
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)WeaponTick, 0f, 0.5f, 0.2f);
		}
	}

	public virtual bool HasAmmo()
	{
		if (!staticRespawn)
		{
			if (ammoItem != null && ammoItem.amount > 0)
			{
				return ammoItem.parent == base.inventory;
			}
			return false;
		}
		return true;
	}

	public void LoadAmmo()
	{
		if (staticRespawn)
		{
			return;
		}
		for (int i = 0; i < base.inventory.itemList.Count; i++)
		{
			Item item = base.inventory.itemList[i];
			if (item != null && item.info.itemid == ammoType.itemid && item.amount > 0)
			{
				ammoItem = item;
				return;
			}
		}
		ammoItem = null;
	}

	public void EnsureAmmoLoaded()
	{
		if (!HasAmmo())
		{
			LoadAmmo();
		}
	}

	public bool IsLoadingAmmo()
	{
		return ((FacepunchBehaviour)this).IsInvoking((Action)LoadAmmo);
	}

	private void ReloadVolley()
	{
		if (mostRecentTargetType == null)
		{
			mostRecentTargetType = targetTypeUnknown;
		}
		float timeBetweenBursts = mostRecentTargetType.timeBetweenBursts;
		reloadVolleyFinishTime = Time.time + timeBetweenBursts;
		firedCount = 0;
	}

	public void WeaponTick()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if (IsDead() || Time.time < reloadVolleyFinishTime)
		{
			return;
		}
		if ((firedCount > 0 && TimeSince.op_Implicit(sinceLastRocketFired) > autoreloaddelay) || firedCount >= 6)
		{
			ReloadVolley();
		}
		else
		{
			if (Time.time < lockOnTime)
			{
				return;
			}
			if (!IsPowered())
			{
				firedCount = 0;
				return;
			}
			EnsureAmmoLoaded();
			if (Interface.CallHook("CanSamSiteShoot", (object)this) == null && HasAmmo())
			{
				bool num = ammoItem != null && ammoItem.amount == lowAmmoThreshold;
				if (!staticRespawn && ammoItem != null)
				{
					ammoItem.UseItem();
				}
				firedCount++;
				sinceLastRocketFired = TimeSince.op_Implicit(0f);
				float speedMultiplier = 1f;
				if (!currentTarget.IsUnityNull())
				{
					speedMultiplier = currentTarget.SAMTargetType.speedMultiplier;
				}
				FireProjectile(tubes[currentTubeIndex].position, currentAimDir, speedMultiplier);
				Effect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get("Tube " + (currentTubeIndex + 1)), Vector3.zero, Vector3.up);
				currentTubeIndex++;
				if (currentTubeIndex >= tubes.Length)
				{
					currentTubeIndex = 0;
				}
				if (num)
				{
					MarkIODirty();
				}
			}
		}
	}

	public void FireProjectile(Vector3 origin, Vector3 direction, float speedMultiplier)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(projectileTest.resourcePath, origin, Quaternion.LookRotation(direction, Vector3.up));
		if (!((Object)(object)baseEntity == (Object)null))
		{
			baseEntity.creatorEntity = this;
			ServerProjectile component = ((Component)baseEntity).GetComponent<ServerProjectile>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.InitializeVelocity(GetInheritedProjectileVelocity(direction) + direction * component.speed * speedMultiplier);
			}
			baseEntity.Spawn();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int result = Mathf.Min(1, GetCurrentEnergy());
		switch (outputSlot)
		{
		case 0:
			if (currentTarget.IsUnityNull())
			{
				return 0;
			}
			return result;
		case 1:
			if (ammoItem == null || ammoItem.amount >= lowAmmoThreshold || ammoItem.parent != base.inventory)
			{
				return 0;
			}
			return result;
		case 2:
			if (HasAmmo())
			{
				return 0;
			}
			return result;
		default:
			return GetCurrentEnergy();
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.IsVisible(3f)]
	private void ToggleDefenderMode(RPCMessage msg)
	{
		if (staticRespawn)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && player.CanBuild())
		{
			bool flag = msg.read.Bit();
			if (flag != IsInDefenderMode() && Interface.CallHook("OnSamSiteModeToggle", (object)this, (object)player, (object)flag) == null)
			{
				SetFlag(Flag_ManuallySetMode, flag);
				SetFlag(Flag_TargetMode, flag);
			}
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		switch (inputSlot)
		{
		case 0:
			base.UpdateFromInput(inputAmount, inputSlot);
			break;
		case 1:
			if (input1Amount != inputAmount)
			{
				bool flag = HasFlag(Flag_ManuallySetMode);
				SetFlag(Flag_TargetMode, (inputAmount == 0) ? flag : (!flag));
			}
			input1Amount = inputAmount;
			break;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public interface ISamSiteTarget
{
	static List<ISamSiteTarget> serverList;

	SamTargetType SAMTargetType { get; }

	bool isClient { get; }

	bool IsValidSAMTarget(bool staticRespawn);

	Vector3 CenterPoint();

	Vector3 GetWorldVelocity();

	bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity);

	static ISamSiteTarget()
	{
		serverList = new List<ISamSiteTarget>();
	}
}


public class SamTargetType
{
	public readonly float scanRadius;

	public readonly float speedMultiplier;

	public readonly float timeBetweenBursts;

	public SamTargetType(float scanRadius, float speedMultiplier, float timeBetweenBursts)
	{
		this.scanRadius = scanRadius;
		this.speedMultiplier = speedMultiplier;
		this.timeBetweenBursts = timeBetweenBursts;
	}
}


using System;
using Network;
using UnityEngine;

public class SantaSleigh : BaseEntity
{
	public GameObjectRef prefabDrop;

	public SpawnFilter filter;

	public Transform dropOrigin;

	[ServerVar]
	public static float altitudeAboveTerrain = 50f;

	[ServerVar]
	public static float desiredAltitude = 60f;

	public Light bigLight;

	public SoundPlayer hohoho;

	public float hohohospacing = 4f;

	public float hohoho_additional_spacing = 2f;

	public Vector3 swimScale;

	public Vector3 swimSpeed;

	public float appliedSwimScale = 1f;

	public float appliedSwimRotation = 20f;

	private Vector3 startPos;

	private Vector3 endPos;

	private float secondsToTake;

	private float secondsTaken;

	private bool dropped;

	public Vector3 dropPosition = Vector3.zero;

	private float swimRandom;

	private const string path = "assets/prefabs/misc/xmas/sleigh/santasleigh.prefab";

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SantaSleigh.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public void InitDropPosition(Vector3 newDropPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		dropPosition = newDropPosition;
		dropPosition.y = 0f;
	}

	public override void ServerInit()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (dropPosition == Vector3.zero)
		{
			dropPosition = RandomDropPosition();
		}
		UpdateDropPosition(dropPosition);
		((FacepunchBehaviour)this).Invoke((Action)SendHoHoHo, 0f);
	}

	public void SendHoHoHo()
	{
		((FacepunchBehaviour)this).Invoke((Action)SendHoHoHo, hohohospacing + Random.Range(0f, hohoho_additional_spacing));
		ClientRPC(RpcTarget.NetworkGroup("ClientPlayHoHoHo"));
	}

	public Vector3 RandomDropPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		float num = 100f;
		float x = TerrainMeta.Size.x;
		do
		{
			zero = Vector3Ex.Range(0f - x / 3f, x / 3f);
		}
		while (filter.GetFactor(zero) == 0f && (num -= 1f) > 0f);
		zero.y = 0f;
		return zero;
	}

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float y = altitudeAboveTerrain;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		((Vector3)(ref startPos)).Normalize();
		startPos *= x * 1.25f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 25f;
		secondsToTake *= Random.Range(0.95f, 1.05f);
		((Component)this).transform.SetPositionAndRotation(startPos, Quaternion.LookRotation(endPos - startPos));
		dropPosition = newDropPosition;
	}

	private void FixedUpdate()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		Quaternion rotation = ((Component)this).transform.rotation;
		secondsTaken += Time.deltaTime;
		float num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
		if (!dropped && num >= 0.5f)
		{
			dropped = true;
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, ((Component)dropOrigin).transform.position);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.globalBroadcast = true;
				baseEntity.Spawn();
			}
		}
		position = Vector3.Lerp(startPos, endPos, num);
		Vector3 val = endPos - startPos;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Vector3.zero;
		if (swimScale != Vector3.zero)
		{
			if (swimRandom == 0f)
			{
				swimRandom = Random.Range(0f, 20f);
			}
			float num2 = Time.time + swimRandom;
			((Vector3)(ref val2))..ctor(Mathf.Sin(num2 * swimSpeed.x) * swimScale.x, Mathf.Cos(num2 * swimSpeed.y) * swimScale.y, Mathf.Sin(num2 * swimSpeed.z) * swimScale.z);
			val2 = ((Component)this).transform.InverseTransformDirection(val2);
			position += val2 * appliedSwimScale;
		}
		rotation = Quaternion.LookRotation(normalized) * Quaternion.Euler(Mathf.Cos(Time.time * swimSpeed.y) * appliedSwimRotation, 0f, Mathf.Sin(Time.time * swimSpeed.x) * appliedSwimRotation);
		Vector3 val3 = position;
		float height = TerrainMeta.HeightMap.GetHeight(val3 + ((Component)this).transform.forward * 30f);
		float height2 = TerrainMeta.HeightMap.GetHeight(val3);
		float num3 = Mathf.Max(height, height2);
		float num4 = Mathf.Max(desiredAltitude, num3 + altitudeAboveTerrain);
		val3.y = Mathf.Lerp(((Component)this).transform.position.y, num4, Time.fixedDeltaTime * 0.5f);
		position = val3;
		((Component)this).transform.hasChanged = true;
		if (num >= 1f)
		{
			Kill();
		}
		((Component)this).transform.SetPositionAndRotation(position, rotation);
	}

	[ServerVar]
	public static void drop(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Debug.Log((object)"Santa Inbound");
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/misc/xmas/sleigh/santasleigh.prefab");
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).GetComponent<SantaSleigh>().InitDropPosition(((Component)basePlayer).transform.position + new Vector3(0f, 10f, 0f));
				baseEntity.Spawn();
			}
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using VLB;

public class SearchLight : IOEntity
{
	public static class SearchLightFlags
	{
		public const Flags PlayerUsing = Flags.Reserved5;
	}

	public GameObject pitchObject;

	public GameObject yawObject;

	public GameObject eyePoint;

	public SoundPlayer turnLoop;

	public bool needsBuildingPrivilegeToUse = true;

	[SerializeField]
	private GameObject lightParent;

	[SerializeField]
	private Light[] lights;

	[SerializeField]
	private float[] initialLightIntensity;

	[SerializeField]
	private VolumetricLightBeam vlb;

	[SerializeField]
	private GameObject flare;

	[SerializeField]
	private SoundPlayer humLoopSound;

	[SerializeField]
	private SoundPlayer turnOffSound;

	[SerializeField]
	private SoundPlayer turnOnSound;

	[SerializeField]
	private AnimationCurve lightLerpCurve;

	public Vector3 aimDir = Vector3.zero;

	public BasePlayer mountedPlayer;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SearchLight.OnRpcMessage", 0);
		try
		{
			if (rpc == 3611615802u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_UseLight "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_UseLight", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3611615802u, "RPC_UseLight", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_UseLight(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_UseLight");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		aimDir = Vector3.zero;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && !old.HasFlag(Flags.Reserved8) && next.HasFlag(Flags.Reserved8) && IsFlickering())
		{
			Hurt(25f);
		}
	}

	public override int ConsumptionAmount()
	{
		return 10;
	}

	public void Update()
	{
		if (base.isServer && IsMounted())
		{
			MountedUpdate();
		}
	}

	public void PlayerEnter(BasePlayer player)
	{
		if (!IsMounted() || !((Object)(object)player != (Object)(object)mountedPlayer))
		{
			PlayerExit();
			if ((Object)(object)player != (Object)null)
			{
				mountedPlayer = player;
				SetFlag(Flags.Reserved5, b: true);
			}
		}
	}

	public void PlayerExit()
	{
		if (Object.op_Implicit((Object)(object)mountedPlayer))
		{
			mountedPlayer = null;
		}
		SetFlag(Flags.Reserved5, b: false);
	}

	public void MountedUpdate()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)mountedPlayer == (Object)null || mountedPlayer.IsSleeping() || !mountedPlayer.IsAlive() || mountedPlayer.IsWounded() || Vector3.Distance(((Component)mountedPlayer).transform.position, ((Component)this).transform.position) > 2f)
		{
			PlayerExit();
			return;
		}
		Vector3 targetAimpoint = eyePoint.transform.position + mountedPlayer.eyes.BodyForward() * 100f;
		SetTargetAimpoint(targetAimpoint);
		SendNetworkUpdate();
	}

	public void SetTargetAimpoint(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = worldPos - eyePoint.transform.position;
		aimDir = ((Vector3)(ref val)).normalized;
	}

	public bool IsMounted()
	{
		return (Object)(object)mountedPlayer != (Object)null;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_UseLight(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool flag = msg.read.Bit();
		if ((!flag || !IsMounted()) && (!needsBuildingPrivilegeToUse || msg.player.CanBuild()))
		{
			if (flag)
			{
				PlayerEnter(player);
			}
			else
			{
				PlayerExit();
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		SetFlag(Flags.On, b: false);
		base.OnDied(info);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.autoturret = Pool.Get<AutoTurret>();
		info.msg.autoturret.aimDir = aimDir;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.autoturret != null)
		{
			aimDir = info.msg.autoturret.aimDir;
		}
	}
}


public static class SearchLightFlags
{
	public const Flags PlayerUsing = Flags.Reserved5;
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SeismicSensor : IOEntity
{
	public static int MinRange = 1;

	public static int MaxRange = 30;

	public int range = 30;

	public GameObjectRef sensorPanelPrefab;

	private int vibrationLevel;

	private const int holdTime = 3;

	private static readonly BaseEntity[] resultBuffer = new BaseEntity[128];

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SeismicSensor.OnRpcMessage", 0);
		try
		{
			if (rpc == 128851379 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SetRange "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SetRange", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(128851379u, "RPC_SetRange", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(128851379u, "RPC_SetRange", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_SetRange(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_SetRange");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void SetVibrationLevel(int value)
	{
		float num = value;
		if (num <= 0f)
		{
			SetOff();
			return;
		}
		if (num > (float)vibrationLevel)
		{
			vibrationLevel = Mathf.RoundToInt(num);
			SetFlag(Flags.On, b: true);
			MarkDirty();
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)SetOff))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SetOff);
		}
		((FacepunchBehaviour)this).Invoke((Action)SetOff, 3f);
	}

	public int GetVibrationLevel()
	{
		return vibrationLevel;
	}

	private void SetOff()
	{
		vibrationLevel = 0;
		SetFlag(Flags.On, b: false);
		MarkDirty();
	}

	public void SetRange(int value)
	{
		value = Mathf.Clamp(value, MinRange, MaxRange);
		range = value;
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void RPC_SetRange(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && player.CanBuild())
		{
			int num = msg.read.Int32();
			SetRange(num);
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputAmount == 0)
		{
			ResetIOState();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsPowered())
		{
			return 0;
		}
		return vibrationLevel;
	}

	public override void ResetIOState()
	{
		vibrationLevel = 0;
		SetFlag(Flags.On, b: false);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity.genericInt1 = range;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			range = info.msg.ioEntity.genericInt1;
			if (info.fromDisk && base.isServer)
			{
				SetVibrationLevel(0);
			}
		}
	}

	public static void Notify(Vector3 position, int value)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (value == 0)
		{
			return;
		}
		int inSphereFast = Query.Server.GetInSphereFast(position, MaxRange, resultBuffer, FilterOutSensors);
		for (int i = 0; i < inSphereFast; i++)
		{
			SeismicSensor seismicSensor = resultBuffer[i] as SeismicSensor;
			Vector3 position2 = ((Component)seismicSensor).transform.position;
			Vector3 val = position - position2;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			float num = (float)seismicSensor.range + 0.5f;
			if (sqrMagnitude < num * num)
			{
				seismicSensor.SetVibrationLevel(value);
			}
		}
	}

	private static bool FilterOutSensors(BaseEntity entity)
	{
		SeismicSensor seismicSensor = entity as SeismicSensor;
		if ((Object)(object)seismicSensor != (Object)null && seismicSensor.IsValidEntityReference())
		{
			return seismicSensor.HasFlag(Flags.Reserved8);
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class Shield : HeldEntity
{
	public const Flags Blocking = Flags.Reserved6;

	public float DeployDelay = 1f;

	public ProtectionProperties Protection;

	[Range(0f, 1f)]
	public float DamageMitigationFactor;

	public Collider ShieldCollider;

	[Tooltip("This is the collider for the shield when not actively in use")]
	public Collider sideShieldCollider;

	public float MaxBlockTime = 4f;

	public float MinBlockTime = 1f;

	public float damageToLoseOneSecond = 50f;

	[Tooltip("How long after we stop blocking before we begin charging our block")]
	public float chargeDelay = 1f;

	public GameObjectRef MeleeLocalPlayerImpactFxPrefab;

	public GameObjectRef RangedLocalPlayerImpactFxPrefab;

	private float lastBlockTime;

	[ReplicatedVar]
	public static bool InfiniteShieldBlock = false;

	private Action shieldBlockTick;

	private bool serverWantsBlock;

	private static Vector3 MaximumLocalPosition = new Vector3(0.39f, 1.62f, 0.41f);

	private static Vector3 MinimumLocalPosition = new Vector3(-0.66f, 0.66f, -0.44f);

	private static Vector3 MaximumLocalRotation = new Vector3(360f, 360f, 360f);

	private static Vector3 MinimumLocalRotation = new Vector3(2.5f, 2.14f, 0.04f);

	private TimeSince serverSideShieldBlockStarted;

	private float serverSideBlockPower;

	private TimeSince lastLocalPlayerUpdateTick;

	private HeldEntity tickingHeldEntity;

	public override bool IsShield => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Shield.OnRpcMessage", 0);
		try
		{
			if (rpc == 2238556937u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerToggleBlock "));
				}
				TimeWarning val2 = TimeWarning.New("ServerToggleBlock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2238556937u, "ServerToggleBlock", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2238556937u, "ServerToggleBlock", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerToggleBlock(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerToggleBlock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsBlocking()
	{
		return HasFlag(Flags.Reserved6);
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer)
		{
			ServerSideAttack(info);
		}
	}

	public bool RaycastAgainstColliders(Ray r, float maxDistance)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if ((Object)(object)ShieldCollider != (Object)null)
		{
			return ShieldCollider.Raycast(r, ref val, maxDistance);
		}
		return false;
	}

	public bool SphereCastAgainstColliders(Vector3 center, float radius)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Distance(ClosestPoint(center), center) <= radius;
	}

	public string GetHitMaterialString()
	{
		return ShieldCollider.sharedMaterial.GetName();
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(10uL)]
	private void ServerToggleBlock(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		serverWantsBlock = flag;
		if (shieldBlockTick == null)
		{
			shieldBlockTick = ShieldBlockTick;
		}
		if (!((FacepunchBehaviour)this).IsInvoking(shieldBlockTick))
		{
			((FacepunchBehaviour)this).InvokeRepeating(shieldBlockTick, 0f, 0f);
		}
	}

	private void ServerSideAttack(HitInfo info)
	{
		Item item = GetItem();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (IsBlocking() && (Object)(object)ownerPlayer != (Object)null)
		{
			float num = info.damageTypes.Total();
			serverSideBlockPower = Mathf.Clamp(serverSideBlockPower + num / damageToLoseOneSecond, 0f, MaxBlockTime);
			ClientRPC(RpcTarget.Player("ClientUpdateShieldPowerTime", ownerPlayer), serverSideBlockPower / MaxBlockTime);
		}
		if (item != null)
		{
			Protection.Scale(info.damageTypes);
			info.HitBone = 0u;
			float num2 = info.damageTypes.Total();
			info.damageTypes.ScaleAll(Mathf.Clamp01(1f - DamageMitigationFactor));
			float amount = num2 - info.damageTypes.Total();
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				ownerPlayer.OnAttacked(info);
			}
			item.LoseCondition(amount);
		}
		bool arg = (Object)(object)info.Weapon != (Object)null && info.Weapon is BaseMelee;
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			ClientRPC(RpcTarget.NetworkGroup("ClientShieldHit", ownerPlayer), arg, ((Object)(object)info.InitiatorPlayer != (Object)null) ? info.InitiatorPlayer.userID.Get() : 0);
		}
	}

	private void DestroyShield()
	{
		List<BaseEntity> list = Pool.GetList<BaseEntity>();
		foreach (BaseEntity child in children)
		{
			list.Add(child);
		}
		foreach (BaseEntity item in list)
		{
			item.SetParent(null, worldPositionStays: true);
		}
		Pool.FreeList<BaseEntity>(ref list);
	}

	public override float AntiHackPadding()
	{
		if ((Object)(object)GetOwnerPlayer() != (Object)null && GetOwnerPlayer().IsBot)
		{
			return 3f;
		}
		return 0.75f;
	}

	public override void SetHeld(bool bHeld)
	{
		base.SetHeld(bHeld);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			ownerPlayer.modelState.blocking = false;
		}
	}

	private void ShieldBlockTick()
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (IsDisabled() || (Object)(object)ownerPlayer == (Object)null)
		{
			return;
		}
		HeldEntity heldEntity = ownerPlayer.GetHeldEntity();
		if ((Object)(object)heldEntity != (Object)(object)tickingHeldEntity)
		{
			tickingHeldEntity = heldEntity;
			serverSideBlockPower = 0f;
		}
		if (serverWantsBlock)
		{
			if (!IsBlocking() && serverSideBlockPower < MaxBlockTime - MinBlockTime)
			{
				serverSideShieldBlockStarted = TimeSince.op_Implicit(0f);
				SetFlag(Flags.Reserved6, b: true);
			}
		}
		else if (IsBlocking() && TimeSince.op_Implicit(serverSideShieldBlockStarted) > MinBlockTime)
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		ownerPlayer.modelState.blocking = IsBlocking();
		if (IsBlocking())
		{
			lastBlockTime = Time.realtimeSinceStartup;
		}
		bool flag = Time.realtimeSinceStartup >= lastBlockTime + chargeDelay;
		serverSideBlockPower = Mathf.MoveTowards(serverSideBlockPower, IsBlocking() ? MaxBlockTime : (flag ? 0f : serverSideBlockPower), Time.deltaTime);
		if (TimeSince.op_Implicit(lastLocalPlayerUpdateTick) > 0.5f)
		{
			ClientRPC(RpcTarget.Player("ClientUpdateShieldPowerTime", ownerPlayer), serverSideBlockPower / MaxBlockTime);
			lastLocalPlayerUpdateTick = TimeSince.op_Implicit(0f);
		}
		if (HasFlag(Flags.Reserved6) && serverSideBlockPower >= MaxBlockTime && !InfiniteShieldBlock)
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		if (!IsBlocking() && serverSideBlockPower <= 0f)
		{
			((FacepunchBehaviour)this).CancelInvoke(shieldBlockTick);
		}
	}

	public override void ServerTick(BasePlayer byPlayer)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerTick(byPlayer);
		if (!IsDisabled() && byPlayer.modelState != null)
		{
			Vector3 val = byPlayer.modelState.localShieldPos;
			if (Vector3Ex.IsNaNOrInfinity(val))
			{
				val = Vector3.Lerp(MinimumLocalPosition, MaximumLocalPosition, 0.5f);
			}
			Vector3 val2 = byPlayer.modelState.localShieldRot;
			if (Vector3Ex.IsNaNOrInfinity(val2))
			{
				val2 = Vector3.Lerp(MinimumLocalRotation, MaximumLocalRotation, 0.5f);
			}
			val.x = Mathf.Clamp(val.x, MinimumLocalPosition.x, MaximumLocalPosition.x);
			val.y = Mathf.Clamp(val.y, MinimumLocalPosition.y, MaximumLocalPosition.y);
			val.z = Mathf.Clamp(val.z, MinimumLocalPosition.z, MaximumLocalPosition.z);
			val2.x = Mathf.Clamp(val2.x, MinimumLocalRotation.x, MaximumLocalRotation.x);
			val2.y = Mathf.Clamp(val2.y, MinimumLocalRotation.y, MaximumLocalRotation.y);
			val2.z = Mathf.Clamp(val2.z, MinimumLocalRotation.z, MaximumLocalRotation.z);
			((Component)this).transform.SetLocalPositionAndRotation(val, Quaternion.Euler(val2));
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!base.isServer)
		{
			return;
		}
		if (old.HasFlag(Flags.Broken) != next.HasFlag(Flags.Broken))
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				HeldEntity heldEntity = ownerPlayer.GetHeldEntity();
				if ((Object)(object)heldEntity != (Object)null)
				{
					heldEntity.UpdateShieldState(bHeld: true);
				}
				if (next.HasFlag(Flags.Broken))
				{
					DestroyShield();
					if ((Object)(object)heldEntity != (Object)null)
					{
						heldEntity.UpdateShieldState(bHeld: false);
					}
				}
			}
		}
		else if (old.HasFlag(Flags.Reserved4) && !next.HasFlag(Flags.Reserved4))
		{
			SetFlag(Flags.Reserved6, b: false);
			serverWantsBlock = false;
		}
		if (old.HasFlag(Flags.Reserved6) != next.HasFlag(Flags.Reserved6))
		{
			SetColliderState(next.HasFlag(Flags.Reserved6));
		}
	}

	public void SetColliderState(bool isBlocking)
	{
		if (Object.op_Implicit((Object)(object)sideShieldCollider))
		{
			sideShieldCollider.enabled = !isBlocking;
			ShieldCollider.enabled = isBlocking;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class ShopFront : StorageContainer
{
	public static class ShopFrontFlags
	{
		public const Flags VendorAccepted = Flags.Reserved1;

		public const Flags CustomerAccepted = Flags.Reserved2;

		public const Flags Exchanging = Flags.Reserved3;
	}

	public float maxUseAngle = 27f;

	public BasePlayer vendorPlayer;

	public BasePlayer customerPlayer;

	public GameObjectRef transactionCompleteEffect;

	[NonSerialized]
	public ItemContainer customerInventory;

	private bool swappingItems;

	private static readonly Phrase TradeLockedError = new Phrase("error.tradelocked", "Trade Locked!");

	private static readonly Phrase TradeUnsuccessfulError = new Phrase("error.tradeunsuccessful", "Trade Unsuccessful!");

	private float AngleDotProduct => 1f - maxUseAngle / 90f;

	public ItemContainer vendorInventory => base.inventory;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ShopFront.OnRpcMessage", 0);
		try
		{
			if (rpc == 1159607245 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AcceptClicked "));
				}
				TimeWarning val2 = TimeWarning.New("AcceptClicked", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1159607245u, "AcceptClicked", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AcceptClicked(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AcceptClicked");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3168107540u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CancelClicked "));
				}
				TimeWarning val2 = TimeWarning.New("CancelClicked", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3168107540u, "CancelClicked", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							CancelClicked(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in CancelClicked");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool TradeLocked()
	{
		return false;
	}

	public bool IsTradingPlayer(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			if (!IsPlayerCustomer(player))
			{
				return IsPlayerVendor(player);
			}
			return true;
		}
		return false;
	}

	public bool IsPlayerCustomer(BasePlayer player)
	{
		return (Object)(object)player == (Object)(object)customerPlayer;
	}

	public bool IsPlayerVendor(BasePlayer player)
	{
		return (Object)(object)player == (Object)(object)vendorPlayer;
	}

	public bool PlayerInVendorPos(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 right = ((Component)this).transform.right;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(right, ((Vector3)(ref val)).normalized) <= 0f - AngleDotProduct;
	}

	public bool PlayerInCustomerPos(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 right = ((Component)this).transform.right;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(right, ((Vector3)(ref val)).normalized) >= AngleDotProduct;
	}

	public bool LootEligable(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (PlayerInVendorPos(player) && (Object)(object)vendorPlayer == (Object)null)
		{
			return true;
		}
		if (PlayerInCustomerPos(player) && (Object)(object)customerPlayer == (Object)null)
		{
			return true;
		}
		return false;
	}

	public void ResetTrade()
	{
		SetFlag(Flags.Reserved1, b: false);
		SetFlag(Flags.Reserved2, b: false);
		SetFlag(Flags.Reserved3, b: false);
		vendorInventory.SetLocked(isLocked: false);
		customerInventory.SetLocked(isLocked: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)CompleteTrade);
	}

	public void CompleteTrade()
	{
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)vendorPlayer != (Object)null && (Object)(object)customerPlayer != (Object)null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", (object)this) != null)
			{
				return;
			}
			try
			{
				swappingItems = true;
				for (int num = vendorInventory.capacity - 1; num >= 0; num--)
				{
					Item slot = vendorInventory.GetSlot(num);
					Item slot2 = customerInventory.GetSlot(num);
					if (Object.op_Implicit((Object)(object)customerPlayer) && slot != null)
					{
						customerPlayer.GiveItem(slot);
					}
					if (Object.op_Implicit((Object)(object)vendorPlayer) && slot2 != null)
					{
						vendorPlayer.GiveItem(slot2);
					}
				}
			}
			finally
			{
				swappingItems = false;
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AcceptClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && !((Object)(object)vendorPlayer == (Object)null) && !((Object)(object)customerPlayer == (Object)null) && Interface.CallHook("OnShopAcceptClick", (object)this, (object)msg.player) == null)
		{
			if (IsPlayerVendor(msg.player))
			{
				SetFlag(Flags.Reserved1, b: true);
				vendorInventory.SetLocked(isLocked: true);
			}
			else if (IsPlayerCustomer(msg.player))
			{
				SetFlag(Flags.Reserved2, b: true);
				customerInventory.SetLocked(isLocked: true);
			}
			if (HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
			{
				SetFlag(Flags.Reserved3, b: true);
				((FacepunchBehaviour)this).Invoke((Action)CompleteTrade, 2f);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void CancelClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && Interface.CallHook("OnShopCancelClick", (object)this, (object)msg.player) == null)
		{
			Object.op_Implicit((Object)(object)vendorPlayer);
			Object.op_Implicit((Object)(object)customerPlayer);
			ResetTrade();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = vendorInventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptVendorItem));
		if (customerInventory == null)
		{
			customerInventory = Pool.Get<ItemContainer>();
			customerInventory.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
			customerInventory.SetOnlyAllowedItem(allowedItem);
			customerInventory.entityOwner = this;
			customerInventory.maxStackSize = maxStackSize;
			customerInventory.ServerInitialize(null, inventorySlots);
			customerInventory.GiveUID();
			customerInventory.onDirty += OnInventoryDirty;
			customerInventory.onItemAddedRemoved = OnItemAddedOrRemoved;
			customerInventory.onItemAddedToStack = OnItemAddedToStack;
			customerInventory.onItemRemovedFromStack = OnItemRemovedFromStack;
			ItemContainer itemContainer2 = customerInventory;
			itemContainer2.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer2.canAcceptItem, new Func<Item, int, bool>(CanAcceptCustomerItem));
			OnInventoryFirstCreated(customerInventory);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Pool.Free<ItemContainer>(ref customerInventory);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		ResetTrade();
	}

	public override void OnItemAddedToStack(Item item, int amount)
	{
		base.OnItemAddedToStack(item, amount);
		ResetTrade();
	}

	public override void OnItemRemovedFromStack(Item item, int amount)
	{
		base.OnItemRemovedFromStack(item, amount);
		ResetTrade();
	}

	private bool CanAcceptVendorItem(Item item, int targetSlot)
	{
		if (swappingItems || ((Object)(object)vendorPlayer != (Object)null && (Object)(object)item.GetOwnerPlayer() == (Object)(object)vendorPlayer) || vendorInventory.itemList.Contains(item))
		{
			return true;
		}
		return false;
	}

	private bool CanAcceptCustomerItem(Item item, int targetSlot)
	{
		if (swappingItems || ((Object)(object)customerPlayer != (Object)null && (Object)(object)item.GetOwnerPlayer() == (Object)(object)customerPlayer) || customerInventory.itemList.Contains(item))
		{
			return true;
		}
		return false;
	}

	public override PlayerInventory.CanMoveFromResponse CanMoveFrom(BasePlayer player, Item item)
	{
		if (TradeLocked())
		{
			return PlayerInventory.CanMoveFromResponse.Failure(TradeLockedError);
		}
		if (IsTradingPlayer(player))
		{
			if (IsPlayerCustomer(player) && customerInventory.itemList.Contains(item) && !customerInventory.IsLocked())
			{
				return PlayerInventory.CanMoveFromResponse.Success();
			}
			if (IsPlayerVendor(player) && vendorInventory.itemList.Contains(item) && !vendorInventory.IsLocked())
			{
				return PlayerInventory.CanMoveFromResponse.Success();
			}
		}
		return PlayerInventory.CanMoveFromResponse.Failure(TradeUnsuccessfulError);
	}

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		if (base.CanOpenLootPanel(player, panelName))
		{
			return LootEligable(player);
		}
		return false;
	}

	public void ReturnPlayerItems(BasePlayer player)
	{
		if (!IsTradingPlayer(player))
		{
			return;
		}
		ItemContainer itemContainer = null;
		if (IsPlayerVendor(player))
		{
			itemContainer = vendorInventory;
		}
		else if (IsPlayerCustomer(player))
		{
			itemContainer = customerInventory;
		}
		if (itemContainer != null)
		{
			for (int num = itemContainer.itemList.Count - 1; num >= 0; num--)
			{
				Item item = itemContainer.itemList[num];
				player.GiveItem(item);
			}
		}
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		if (IsTradingPlayer(player))
		{
			ReturnPlayerItems(player);
			if ((Object)(object)player == (Object)(object)vendorPlayer)
			{
				vendorPlayer = null;
			}
			if ((Object)(object)player == (Object)(object)customerPlayer)
			{
				customerPlayer = null;
			}
			UpdatePlayers();
			ResetTrade();
			base.PlayerStoppedLooting(player);
		}
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		bool flag = base.PlayerOpenLoot(player, panelToOpen);
		if (flag)
		{
			player.inventory.loot.AddContainer(customerInventory);
			player.inventory.loot.SendImmediate();
		}
		if (PlayerInVendorPos(player) && (Object)(object)vendorPlayer == (Object)null)
		{
			vendorPlayer = player;
		}
		else
		{
			if (!PlayerInCustomerPos(player) || !((Object)(object)customerPlayer == (Object)null))
			{
				return false;
			}
			customerPlayer = player;
		}
		ResetTrade();
		UpdatePlayers();
		return flag;
	}

	public void UpdatePlayers()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_ReceivePlayers"), (NetworkableId)(((Object)(object)vendorPlayer == (Object)null) ? default(NetworkableId) : vendorPlayer.net.ID), (NetworkableId)(((Object)(object)customerPlayer == (Object)null) ? default(NetworkableId) : customerPlayer.net.ID));
	}

	public override void GetAllInventories(List<ItemContainer> list)
	{
		base.GetAllInventories(list);
		list.Add(customerInventory);
	}
}


public static class ShopFrontFlags
{
	public const Flags VendorAccepted = Flags.Reserved1;

	public const Flags CustomerAccepted = Flags.Reserved2;

	public const Flags Exchanging = Flags.Reserved3;
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class ShutterFrame : PhotoFrame, IFlagNotify
{
	[Header("Shutter Frame")]
	[Tooltip("Tiling for the shutter material UVs, needs to be set because it will be overwritten during animation if not")]
	public Vector2 shutterDefaultTiling = new Vector2(1.15f, 1f);

	[Tooltip("Offsets for the shutter material UVs, needs to be set because it will be overwritten during animation if not")]
	public Vector2 shutterDefaultOffset = new Vector2(-0.07f, -0.2f);

	[Tooltip("UV -> V Offsets for the shutter when open and closed respectively")]
	public Vector2 shutterUVOffsets = new Vector2(0f, -0.48f);

	public List<Renderer> shutterRenderers;

	public float shutterMoveSpeed = 1f;

	public AnimationCurve shutterMovementCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public GameObjectRef IoEntity;

	public Transform IoEntityAnchor;

	[Header("Sound")]
	public SoundDefinition moveStartSoundDef;

	public SoundDefinition moveStopSoundDef;

	public SoundDefinition moveLoopSoundDef;

	private EntityRef<IOEntity> spawnedIo;

	private bool __sync_IsShutterOpen;

	[Sync(Autosave = true)]
	public bool IsShutterOpen
	{
		[CompilerGenerated]
		get
		{
			return __sync_IsShutterOpen;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_IsShutterOpen, value))
			{
				__sync_IsShutterOpen = value;
				byte nameID = __GetWeaverID("IsShutterOpen");
				QueueSyncVar(nameID);
			}
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ShutterFrame.OnRpcMessage", 0);
		try
		{
			if (rpc == 3472018092u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ToggleShutter "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ToggleShutter", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3472018092u, "RPC_ToggleShutter", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3472018092u, "RPC_ToggleShutter", this, player, 6f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_ToggleShutter(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_ToggleShutter");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.simpleUID != null)
		{
			spawnedIo.uid = info.msg.simpleUID.uid;
		}
	}

	public virtual bool CanUpdateFrame(BasePlayer player)
	{
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SpawnIOEnt();
		}
	}

	private void SpawnIOEnt()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (IoEntity.isValid && (Object)(object)IoEntityAnchor != (Object)null)
		{
			IOEntity iOEntity = GameManager.server.CreateEntity(IoEntity.resourcePath, IoEntityAnchor.position, IoEntityAnchor.rotation) as IOEntity;
			iOEntity.SetParent(this, worldPositionStays: true);
			spawnedIo.Set(iOEntity);
			iOEntity.Spawn();
		}
	}

	public void OnFlagToggled(bool state)
	{
		if (base.isServer && IsShutterOpen != !state)
		{
			IsShutterOpen = !state;
		}
	}

	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server.IsVisible(6f)]
	[RPC_Server]
	public void RPC_ToggleShutter(RPCMessage msg)
	{
		IsShutterOpen = !IsShutterOpen;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.simpleUID == null)
		{
			info.msg.simpleUID = Pool.Get<SimpleUID>();
		}
		info.msg.simpleUID.uid = spawnedIo.uid;
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (id == 1)
		{
			if (Global.developer > 2)
			{
				NetworkableId iD = net.ID;
				Debug.Log((object)("SyncVar Writing: IsShutterOpen for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_IsShutterOpen);
			return true;
		}
		return base.WriteSyncVar(id, writer);
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		if (id == 1)
		{
			try
			{
				_ = __sync_IsShutterOpen;
				bool _sync_IsShutterOpen = reader.Bool();
				__sync_IsShutterOpen = _sync_IsShutterOpen;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			return true;
		}
		return base.OnSyncVar(id, reader, fromAutoSave);
	}

	private byte __GetWeaverID(string propertyName)
	{
		if (propertyName == "IsShutterOpen")
		{
			return 1;
		}
		return byte.MaxValue;
	}

	protected override void WriteAutoSaveSyncVars(NetWrite writer)
	{
		base.WriteAutoSaveSyncVars(writer);
		WriteSyncVar(1, writer);
	}

	protected override void ReadAutoSaveSyncVars(NetRead reader)
	{
		base.ReadAutoSaveSyncVars(reader);
		OnSyncVar(1, reader, fromAutoSave: true);
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		base.AutoSaveSyncVars(save);
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteAutoSaveSyncVars(val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		base.AutoLoadSyncVars(load);
		if (load.msg.baseEntity != null && load.msg.baseEntity.syncVars != null)
		{
			NetRead val = Pool.Get<NetRead>();
			val.Init(load.msg.baseEntity.syncVars.AsSpan());
			ReadAutoSaveSyncVars(val);
			Pool.Free<NetRead>(ref val);
		}
		return true;
	}

	protected override void ResetSyncVars()
	{
		base.ResetSyncVars();
		__sync_IsShutterOpen = false;
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		if (id == 1)
		{
			return true;
		}
		return base.ShouldInvalidateCache(id);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class SiegeTower : BaseSiegeWeapon
{
	[SerializeField]
	[Header("Siege Tower")]
	private SiegeTowerDoor drawBridgePrefab;

	[SerializeField]
	private SiegeTowerDoor drawBridge2Prefab;

	[SerializeField]
	private SiegeTowerDoor drawBridge3Prefab;

	private EntityRef<SiegeTowerDoor> drawBridgeRef;

	private EntityRef<SiegeTowerDoor> drawBridge2Ref;

	private EntityRef<SiegeTowerDoor> drawBridge3Ref;

	private const Flags Flag_IsTipping = Flags.Reserved18;

	private const Flags Flag_IsTipped = Flags.Reserved16;

	[Header("Raise Command")]
	public float torqueForce = 10f;

	public float uprightAngle = 10f;

	private bool shouldRaise;

	private float raiseTimer;

	public override float DriveWheelVelocity { get; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SiegeTower.OnRpcMessage", 0);
		try
		{
			if (rpc == 886085783 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_RequestRaise "));
				}
				TimeWarning val2 = TimeWarning.New("SV_RequestRaise", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(886085783u, "SV_RequestRaise", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_RequestRaise(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_RequestRaise");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.siegeTower != null && base.isServer)
		{
			drawBridgeRef.uid = info.msg.siegeTower.drawBridgeID;
			drawBridge2Ref.uid = info.msg.siegeTower.drawBridge2ID;
			drawBridge3Ref.uid = info.msg.siegeTower.drawBridge3ID;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.siegeTower = Pool.Get<SiegeTower>();
		info.msg.siegeTower.drawBridgeID = drawBridgeRef.uid;
		info.msg.siegeTower.drawBridge2ID = drawBridge2Ref.uid;
		info.msg.siegeTower.drawBridge3ID = drawBridge3Ref.uid;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && !Application.isLoadingSave)
		{
			if (child.prefabID == drawBridgePrefab.GetEntity().prefabID)
			{
				SiegeTowerDoor siegeTowerDoor = (SiegeTowerDoor)child;
				drawBridgeRef.Set(siegeTowerDoor);
				SetupDoor(siegeTowerDoor);
			}
			if (child.prefabID == drawBridge2Prefab.GetEntity().prefabID)
			{
				SiegeTowerDoor siegeTowerDoor2 = (SiegeTowerDoor)child;
				drawBridge2Ref.Set(siegeTowerDoor2);
				SetupDoor(siegeTowerDoor2);
			}
			if (child.prefabID == drawBridge3Prefab.GetEntity().prefabID)
			{
				SiegeTowerDoor siegeTowerDoor3 = (SiegeTowerDoor)child;
				drawBridge3Ref.Set(siegeTowerDoor3);
				SetupDoor(siegeTowerDoor3);
			}
			UpdateDoorHp();
		}
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (HasFlag(Flags.Reserved16))
		{
			return false;
		}
		if (base.isServer)
		{
			BaseEntity baseEntity = pusher.parentEntity.Get(serverside: true);
			if (baseEntity.IsValid())
			{
				BaseEntity baseEntity2 = baseEntity.parentEntity.Get(serverside: true);
				if (baseEntity2.IsValid() && (Object)(object)baseEntity2 == (Object)(object)this)
				{
					return false;
				}
			}
			if (!IsYValid(pusher))
			{
				return false;
			}
		}
		return true;
	}

	private bool IsYValid(BasePlayer pusher)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return !(Mathf.Abs(((Component)this).transform.position.y - ((Component)pusher).transform.position.y) > 2f);
	}

	protected override void CreateEngineController()
	{
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool ForceDeployableSetParent()
	{
		return true;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		DisablePhysics();
		((FacepunchBehaviour)this).Invoke((Action)base.EnablePhysics, 1f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckIfTipped, 0f, 2f);
	}

	public void GetDoors(List<SiegeTowerDoor> doors)
	{
		SiegeTowerDoor siegeTowerDoor = drawBridgeRef.Get(base.isServer);
		if (siegeTowerDoor.IsValid())
		{
			doors.Add(siegeTowerDoor);
		}
		siegeTowerDoor = drawBridge2Ref.Get(base.isServer);
		if (siegeTowerDoor.IsValid())
		{
			doors.Add(siegeTowerDoor);
		}
		siegeTowerDoor = drawBridge3Ref.Get(base.isServer);
		if (siegeTowerDoor.IsValid())
		{
			doors.Add(siegeTowerDoor);
		}
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		List<SiegeTowerDoor> list = Pool.Get<List<SiegeTowerDoor>>();
		GetDoors(list);
		foreach (SiegeTowerDoor item in list)
		{
			if ((Object)(object)item != (Object)null)
			{
				item.ProtectedHurt(info);
			}
		}
		Pool.FreeUnmanaged<SiegeTowerDoor>(ref list);
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		List<SiegeTowerDoor> list = Pool.Get<List<SiegeTowerDoor>>();
		GetDoors(list);
		foreach (SiegeTowerDoor item in list)
		{
			if (!item.IsDead())
			{
				item.Die();
			}
		}
		Pool.FreeUnmanaged<SiegeTowerDoor>(ref list);
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateDoorHp();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateDoorHp();
	}

	private void UpdateDoorHp()
	{
		List<SiegeTowerDoor> list = Pool.Get<List<SiegeTowerDoor>>();
		GetDoors(list);
		foreach (SiegeTowerDoor item in list)
		{
			item.SetMaxHealth(MaxHealth());
			item.SetHealth(base.health);
		}
		Pool.FreeUnmanaged<SiegeTowerDoor>(ref list);
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	public void ProtectedSetHealth(float health)
	{
		SetHealth(health);
		UpdateDoorHp();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		List<SiegeTowerDoor> list = Pool.Get<List<SiegeTowerDoor>>();
		GetDoors(list);
		foreach (SiegeTowerDoor item in list)
		{
			SetupDoor(item);
		}
		Pool.FreeUnmanaged<SiegeTowerDoor>(ref list);
		UpdateDoorHp();
	}

	private void SetupDoor(SiegeTowerDoor door)
	{
		door.SetupDoor(this);
		door.SetMaxHealth(MaxHealth());
		door.SetHealth(MaxHealth());
		door.OwnerID = base.OwnerID;
		door.startHealth = MaxHealth();
	}

	private void CheckIfTipped()
	{
		bool flag = IsFlipping();
		if (HasFlag(Flags.Reserved18) != flag)
		{
			SetFlag(Flags.Reserved18, flag);
		}
		bool flag2 = IsFlipped();
		if (HasFlag(Flags.Reserved16) != flag2)
		{
			SetFlag(Flags.Reserved16, flag2);
		}
	}

	public override bool CheckTowingAllowed()
	{
		if (!base.CheckTowingAllowed())
		{
			return false;
		}
		if (HasFlag(Flags.Reserved18) || HasFlag(Flags.Reserved16))
		{
			return false;
		}
		return true;
	}

	private void FixedUpdate()
	{
		if (!base.isClient && !rigidBody.isKinematic)
		{
			UprightIfRaise();
		}
	}

	private void UprightIfRaise()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (shouldRaise)
		{
			if (Mathf.Abs(((Component)this).transform.up.y) > uprightAngle || raiseTimer > 5f)
			{
				rigidBody.angularDrag = 0.95f;
			}
			else if (Mathf.Abs(((Component)this).transform.up.y) > 1f || raiseTimer > 15f)
			{
				shouldRaise = false;
				rigidBody.angularDrag = 0.05f;
			}
			Vector3 angularVelocity = rigidBody.angularVelocity;
			Vector3 val = Quaternion.AngleAxis(((Vector3)(ref angularVelocity)).magnitude * 57.29578f * 100f / 350f, rigidBody.angularVelocity) * ((Component)this).transform.up;
			Vector3 up = Vector3.up;
			Vector3 val2 = Vector3.Cross(val, up);
			float num = Vector3.Dot(((Vector3)(ref val)).normalized, up);
			num = Mathf.Clamp01((num + 1f) / 2f);
			Vector3 val3 = val2 * (1f - num) * 350f * 350f;
			rigidBody.AddTorque(val3);
			raiseTimer += Time.fixedDeltaTime;
		}
	}

	private void AlignRotationToZero()
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null || !HasFlag(Flags.Reserved16))
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)AlignRotationToZero))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)AlignRotationToZero);
			}
			if ((Object)(object)rigidBody != (Object)null && !HasFlag(Flags.Reserved16))
			{
				rigidBody.angularVelocity = Vector3.zero;
			}
		}
	}

	public override void OnEngineStartFailed()
	{
	}

	public override bool MeetsEngineRequirements()
	{
		return false;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void SV_RequestRaise(RPCMessage msg)
	{
		if (HasFlag(Flags.Reserved16) && !((FacepunchBehaviour)this).IsInvoking((Action)AlignRotationToZero))
		{
			if (rigidBody.IsSleeping())
			{
				rigidBody.WakeUp();
			}
			raiseTimer = 0f;
			shouldRaise = true;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Signage : IOEntity, ILOD, ISignage, IUGCBrowserEntity, IEaselPaintable
{
	[Header("Signage")]
	public ItemDefinition RequiredHeldEntity;

	private EaselDeployable _cachedParentEasel;

	public bool showIODisplayName;

	private List<ulong> editHistory = new List<ulong>();

	private const float TextureRequestTimeout = 15f;

	public GameObjectRef changeTextDialog;

	public MeshPaintableSource[] paintableSources;

	[NonSerialized]
	public uint[] textureIDs;

	private NetworkableId __sync_EaselId;

	[Sync(Autosave = true)]
	public NetworkableId EaselId
	{
		[CompilerGenerated]
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return __sync_EaselId;
		}
		[CompilerGenerated]
		set
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!IsSyncVarEqual<NetworkableId>(__sync_EaselId, value))
			{
				__sync_EaselId = value;
				byte nameID = __GetWeaverID("EaselId");
				QueueSyncVar(nameID);
			}
		}
	}

	public EaselDeployable parentEasel
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			NetworkableId easelId = EaselId;
			if (!((NetworkableId)(ref easelId)).IsValid)
			{
				return null;
			}
			if ((Object)(object)_cachedParentEasel == (Object)null)
			{
				_cachedParentEasel = new EntityRef<EaselDeployable>(EaselId).Get(base.isServer);
			}
			return _cachedParentEasel;
		}
	}

	public GameObject GameObject => ((Component)this).gameObject;

	public NetworkableId NetworkID => net.ID;

	public FileStorage.Type FileType => FileStorage.Type.png;

	public UGCType ContentType => UGCType.ImagePng;

	public List<ulong> EditingHistory => editHistory;

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public uint[] GetContentCRCs => GetTextureCRCs();

	public override bool ShouldTransferAssociatedFiles => true;

	public Vector2i TextureSize
	{
		get
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			if (paintableSources == null || paintableSources.Length == 0)
			{
				return Vector2i.zero;
			}
			MeshPaintableSource meshPaintableSource = paintableSources[0];
			return new Vector2i(meshPaintableSource.texWidth, meshPaintableSource.texHeight);
		}
	}

	public int TextureCount
	{
		get
		{
			MeshPaintableSource[] array = paintableSources;
			if (array == null)
			{
				return 0;
			}
			return array.Length;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Signage.OnRpcMessage", 0);
		try
		{
			if (rpc == 1455609404 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - LockSign "));
				}
				TimeWarning val2 = TimeWarning.New("LockSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1455609404u, "LockSign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							LockSign(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in LockSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4149904254u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UnLockSign "));
				}
				TimeWarning val2 = TimeWarning.New("UnLockSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4149904254u, "UnLockSign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							UnLockSign(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UnLockSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1255380462 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdateSign "));
				}
				TimeWarning val2 = TimeWarning.New("UpdateSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1255380462u, "UpdateSign", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1255380462u, "UpdateSign", this, player, 5f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							UpdateSign(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in UpdateSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool ShowDisplayName()
	{
		return showIODisplayName;
	}

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return true;
	}

	public bool CanUnlockSign(BasePlayer player)
	{
		if (!IsLocked())
		{
			return false;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return CanUpdateSign(player);
	}

	public bool CanLockSign(BasePlayer player)
	{
		if (IsLocked())
		{
			return false;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return CanUpdateSign(player);
	}

	public override void Load(LoadInfo info)
	{
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		EnsureInitialized();
		bool flag = false;
		if (info.msg.sign != null)
		{
			uint num = textureIDs[0];
			if (info.msg.sign.imageIds != null && info.msg.sign.imageIds.Count > 0)
			{
				int num2 = Mathf.Min(info.msg.sign.imageIds.Count, textureIDs.Length);
				for (int i = 0; i < num2; i++)
				{
					uint num3 = info.msg.sign.imageIds[i];
					bool flag2 = num3 != textureIDs[i];
					flag = flag || flag2;
					textureIDs[i] = num3;
				}
			}
			else
			{
				flag = num != info.msg.sign.imageid;
				textureIDs[0] = info.msg.sign.imageid;
			}
		}
		if (!base.isServer)
		{
			return;
		}
		bool flag3 = false;
		for (int j = 0; j < paintableSources.Length; j++)
		{
			uint num4 = textureIDs[j];
			if (num4 != 0)
			{
				byte[] array = FileStorage.server.Get(num4, FileStorage.Type.png, net.ID, (uint)j);
				if (array == null)
				{
					Log($"Frame {j} (id={num4}) doesn't exist, clearing");
					textureIDs[j] = 0u;
				}
				flag3 = flag3 || array != null;
			}
		}
		if (!flag3)
		{
			SetFlag(Flags.Locked, b: false);
		}
		if (info.msg.sign == null)
		{
			return;
		}
		if (info.msg.sign.editHistory != null)
		{
			if (editHistory == null)
			{
				editHistory = Pool.Get<List<ulong>>();
			}
			editHistory.Clear();
			{
				foreach (ulong item in info.msg.sign.editHistory)
				{
					editHistory.Add(item);
				}
				return;
			}
		}
		if (editHistory != null)
		{
			Pool.FreeUnmanaged<ulong>(ref editHistory);
		}
	}

	private bool HeldEntityCheck(BasePlayer player)
	{
		if ((Object)(object)RequiredHeldEntity != (Object)null && (!Object.op_Implicit((Object)(object)player.GetHeldEntity()) || (Object)(object)player.GetHeldEntity().GetItem().info != (Object)(object)RequiredHeldEntity))
		{
			return false;
		}
		return true;
	}

	public uint[] GetTextureCRCs()
	{
		return textureIDs;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", (object)this, (object)msg.player);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void UnLockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUnlockSign(msg.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		EnsureInitialized();
		List<uint> list = Pool.Get<List<uint>>();
		uint[] array = textureIDs;
		foreach (uint item in array)
		{
			list.Add(item);
		}
		info.msg.sign = Pool.Get<Sign>();
		info.msg.sign.imageid = 0u;
		info.msg.sign.imageIds = list;
		if (editHistory == null || editHistory.Count <= 0 || !info.forDisk)
		{
			return;
		}
		info.msg.sign.editHistory = Pool.Get<List<ulong>>();
		foreach (ulong item2 in editHistory)
		{
			info.msg.sign.editHistory.Add(item2);
		}
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (net != null)
		{
			FileStorage.server.RemoveAllByEntity(net.ID);
		}
		if (textureIDs != null)
		{
			Array.Clear(textureIDs, 0, textureIDs.Length);
		}
		RemoveFromEasel();
		base.OnDied(info);
	}

	public override void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
	{
		base.OnPickedUpPreItemMove(createdItem, player);
		RemoveFromEasel();
		SaveSignageToItem(createdItem);
	}

	public void SaveSignageToItem(Item createdItem)
	{
		bool flag = false;
		uint[] array = textureIDs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != 0)
			{
				flag = true;
				break;
			}
		}
		ItemModSign itemModSign = default(ItemModSign);
		if (flag && ((Component)createdItem.info).TryGetComponent<ItemModSign>(ref itemModSign))
		{
			Debug.Log((object)"Saving sign data to item");
			itemModSign.OnSignPickedUp(this, this, createdItem);
		}
	}

	public void RemoveFromEasel()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)parentEasel != (Object)null)
		{
			parentEasel.RemovePainting(this);
		}
		EaselId = default(NetworkableId);
	}

	public void AddToEasel(BaseEntity parent)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)parent != (Object)null && parent is EaselDeployable easelDeployable)
		{
			EaselId = easelDeployable.net.ID;
			easelDeployable.SetPainting(this);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		AddToEasel(parent);
		ItemModSign itemModSign = default(ItemModSign);
		if (((Component)fromItem.info).TryGetComponent<ItemModSign>(ref itemModSign))
		{
			SignContent associatedEntity = ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(fromItem);
			if ((Object)(object)associatedEntity != (Object)null)
			{
				associatedEntity.CopyInfoToSign(this, this);
			}
		}
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public void SetTextureCRCs(uint[] crcs)
	{
		textureIDs = new uint[crcs.Length];
		crcs.CopyTo(textureIDs, 0);
		SendNetworkUpdate();
	}

	public void LogEdit(BasePlayer byPlayer)
	{
		if (!editHistory.Contains(byPlayer.userID))
		{
			editHistory.Insert(0, byPlayer.userID);
			int num = 0;
			while (editHistory.Count > 5 && num < 10)
			{
				editHistory.RemoveAt(5);
				num++;
			}
		}
	}

	public void ClearContent()
	{
		SetTextureCRCs(Array.Empty<uint>());
	}

	public override string Admin_Who()
	{
		if (editHistory == null || editHistory.Count == 0)
		{
			return base.Admin_Who();
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine(base.Admin_Who());
		for (int i = 0; i < editHistory.Count; i++)
		{
			stringBuilder.AppendLine($"Edit {i}: {editHistory[i]}");
		}
		return stringBuilder.ToString();
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override string Categorize()
	{
		return "sign";
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (clientside && paintableSources != null && paintableSources.Length > 1)
		{
			MeshPaintableSource meshPaintableSource = paintableSources[0];
			for (int i = 1; i < paintableSources.Length; i++)
			{
				MeshPaintableSource obj = paintableSources[i];
				obj.texWidth = meshPaintableSource.texWidth;
				obj.texHeight = meshPaintableSource.texHeight;
			}
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(5f)]
	public void UpdateSign(RPCMessage msg)
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null || !CanUpdateSign(msg.player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num < 0 || num >= paintableSources.Length)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)
		{
			Debug.LogWarning((object)$"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring");
			return;
		}
		EnsureInitialized();
		if (array == null)
		{
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				return;
			}
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);
		}
		LogEdit(msg.player);
		SendNetworkUpdate();
		Interface.CallHook("OnSignUpdated", (object)this, (object)msg.player, (object)num);
	}

	public void EnsureInitialized()
	{
		int num = Mathf.Max(paintableSources.Length, 1);
		if (textureIDs == null || textureIDs.Length != num)
		{
			Array.Resize(ref textureIDs, num);
		}
	}

	[Conditional("SIGN_DEBUG")]
	private static void SignDebugLog(string str)
	{
		Debug.Log((object)str);
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (id == 0)
		{
			if (Global.developer > 2)
			{
				NetworkableId iD = net.ID;
				Debug.Log((object)("SyncVar Writing: EaselId for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite<NetworkableId>(writer, __sync_EaselId);
			return true;
		}
		return base.WriteSyncVar(id, writer);
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (id == 0)
		{
			try
			{
				_ = __sync_EaselId;
				NetworkableId _sync_EaselId = reader.EntityID();
				__sync_EaselId = _sync_EaselId;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			return true;
		}
		return base.OnSyncVar(id, reader, fromAutoSave);
	}

	private byte __GetWeaverID(string propertyName)
	{
		if (propertyName == "EaselId")
		{
			return 0;
		}
		return byte.MaxValue;
	}

	protected override void WriteAutoSaveSyncVars(NetWrite writer)
	{
		base.WriteAutoSaveSyncVars(writer);
		WriteSyncVar(0, writer);
	}

	protected override void ReadAutoSaveSyncVars(NetRead reader)
	{
		base.ReadAutoSaveSyncVars(reader);
		OnSyncVar(0, reader, fromAutoSave: true);
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		base.AutoSaveSyncVars(save);
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteAutoSaveSyncVars(val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		base.AutoLoadSyncVars(load);
		if (load.msg.baseEntity != null && load.msg.baseEntity.syncVars != null)
		{
			NetRead val = Pool.Get<NetRead>();
			val.Init(load.msg.baseEntity.syncVars.AsSpan());
			ReadAutoSaveSyncVars(val);
			Pool.Free<NetRead>(ref val);
		}
		return true;
	}

	protected override void ResetSyncVars()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.ResetSyncVars();
		__sync_EaselId = default(NetworkableId);
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		if (id == 0)
		{
			return true;
		}
		return base.ShouldInvalidateCache(id);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SimpleBuildingBlock : StabilityEntity, ISimpleUpgradable, ISprayCallback
{
	public List<ItemDefinition> UpgradeItems;

	public Menu.Option UpgradeMenu;

	private GameObject currentModel;

	private SimpleBuildingBlockModelVariant[] variants;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SimpleBuildingBlock.OnRpcMessage", 0);
		try
		{
			if (rpc == 2824056853u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoSimpleUpgrade "));
				}
				TimeWarning val2 = TimeWarning.New("DoSimpleUpgrade", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2824056853u, "DoSimpleUpgrade", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2824056853u, "DoSimpleUpgrade", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoSimpleUpgrade(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoSimpleUpgrade");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		variants = PrefabAttribute.server.FindAll<SimpleBuildingBlockModelVariant>(prefabID);
	}

	public List<ItemDefinition> GetUpgradeItems()
	{
		return UpgradeItems;
	}

	public bool CanUpgrade(BasePlayer player, ItemDefinition upgradeItem)
	{
		return SimpleUpgrade.CanUpgrade(this, upgradeItem, player);
	}

	public void DoUpgrade(BasePlayer player, ItemDefinition upgradeItem)
	{
		SimpleUpgrade.DoUpgrade(this, player, upgradeItem);
	}

	public Menu.Option GetUpgradeMenuOption()
	{
		return UpgradeMenu;
	}

	public bool UpgradingEnabled()
	{
		if (UpgradeItems != null)
		{
			return UpgradeItems.Count > 0;
		}
		return false;
	}

	public bool CostIsItem()
	{
		return true;
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void DoSimpleUpgrade(RPCMessage msg)
	{
		if (base.SecondsSinceAttacked < 30f)
		{
			msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString("N0"));
			return;
		}
		int num = msg.read.Int32();
		if (num >= 0 && num < UpgradeItems.Count)
		{
			ItemDefinition upgradeItem = UpgradeItems[num];
			if (CanUpgrade(msg.player, upgradeItem))
			{
				DoUpgrade(msg.player, upgradeItem);
			}
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		PopulateVariants();
	}

	private void PopulateVariants()
	{
		if (base.isServer && variants.Any())
		{
			ulong value = net.ID.Value;
			SeedRandom.Wanghash(ref value);
			SeedRandom.Wanghash(ref value);
			SeedRandom.Wanghash(ref value);
			int num = (int)(value % (ulong)variants.Length);
			SetFlag(variants[num].Flag, b: true);
		}
	}

	public void OnReskinned(BasePlayer byPlayer)
	{
		PopulateVariants();
	}

	public void SetVariant(int index)
	{
		int num = index % variants.Length;
		SimpleBuildingBlockModelVariant[] array = variants;
		foreach (SimpleBuildingBlockModelVariant simpleBuildingBlockModelVariant in array)
		{
			SetFlag(simpleBuildingBlockModelVariant.Flag, b: false, recursive: false, networkupdate: false);
		}
		SetFlag(variants[num].Flag, b: true);
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if (!base.isServer)
		{
			return;
		}
		SimpleBuildingBlockModelVariant[] array = variants;
		foreach (SimpleBuildingBlockModelVariant simpleBuildingBlockModelVariant in array)
		{
			if (HasFlag(simpleBuildingBlockModelVariant.Flag))
			{
				SetFlag(simpleBuildingBlockModelVariant.Flag, b: false);
			}
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (variants != null)
		{
			RefreshVariant();
		}
	}

	private void RefreshVariant()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		if (variants == null)
		{
			return;
		}
		base.gameManager.Retire(currentModel);
		SimpleBuildingBlockModelVariant[] array = variants;
		foreach (SimpleBuildingBlockModelVariant simpleBuildingBlockModelVariant in array)
		{
			if (HasFlag(simpleBuildingBlockModelVariant.Flag))
			{
				GameObject val = base.gameManager.CreatePrefab(simpleBuildingBlockModelVariant.prefab.resourcePath, ((Component)this).transform);
				if (Object.op_Implicit((Object)(object)val))
				{
					val.transform.localPosition = simpleBuildingBlockModelVariant.localPosition;
					val.transform.localRotation = simpleBuildingBlockModelVariant.localRotation;
				}
				currentModel = val;
			}
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		base.gameManager.Retire(currentModel);
		currentModel = null;
	}
}


using System;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SingleUseMissionStorageContainer : LootContainer
{
	[Serializable]
	public class MissionEntry
	{
		public BaseMission mission;

		public MissionObjective[] objectives = Array.Empty<MissionObjective>();
	}

	[Header("Mission settings")]
	public MissionEntry[] validMissions = Array.Empty<MissionEntry>();

	[Header("Physics")]
	public Collider mainCollider;

	public TriggerPlayerForce playerForcer;

	private const float TIMEOUT_DURATION = 60f;

	private Action _action_DestroyNoLoot;

	private Action _action_CheckShouldDisablePlayerRepulse;

	private int noOfTicks;

	private const int ticksUntilDisablePlayerRepulse = 10;

	private ulong __sync_permittedUserId;

	[Sync(Autosave = true, Pack = false)]
	private ulong permittedUserId
	{
		[CompilerGenerated]
		get
		{
			return __sync_permittedUserId;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_permittedUserId, value))
			{
				__sync_permittedUserId = value;
				byte nameID = __GetWeaverID("permittedUserId");
				SV_SyncVarSend(nameID);
			}
		}
	}

	private Action action_DestroyNoLoot
	{
		get
		{
			if (_action_DestroyNoLoot == null)
			{
				_action_DestroyNoLoot = Cleanup_NoLoot;
			}
			return _action_DestroyNoLoot;
		}
	}

	private Action action_CheckShouldDisablePlayerRepulse
	{
		get
		{
			_action_CheckShouldDisablePlayerRepulse = CheckShouldDisablePlayerRepulse;
			return _action_CheckShouldDisablePlayerRepulse;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SingleUseMissionStorageContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 2761122970u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_UpdateNoteText "));
				}
				TimeWarning val2 = TimeWarning.New("Server_UpdateNoteText", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_UpdateNoteText(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_UpdateNoteText");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ResetCleanupTimer();
		StartPlayerRepulseCountdown();
	}

	private void ResetCleanupTimer()
	{
		((FacepunchBehaviour)this).CancelInvoke(action_DestroyNoLoot);
		((FacepunchBehaviour)this).Invoke(action_DestroyNoLoot, 60f);
	}

	private void StartPlayerRepulseCountdown()
	{
		mainCollider.enabled = false;
		((Behaviour)playerForcer).enabled = true;
		((FacepunchBehaviour)this).InvokeRepeatingFixedTime(action_CheckShouldDisablePlayerRepulse);
	}

	private void CheckShouldDisablePlayerRepulse()
	{
		if (noOfTicks < 10)
		{
			noOfTicks++;
			return;
		}
		mainCollider.enabled = true;
		((Behaviour)playerForcer).enabled = false;
		((FacepunchBehaviour)this).CancelInvokeFixedTime(action_CheckShouldDisablePlayerRepulse);
	}

	public void PermitUserId(ulong userId)
	{
		if (base.isServer)
		{
			if (permittedUserId != 0L)
			{
				Debug.LogError((object)$"Tried to permit user {userId} to {((Object)this).name} but {permittedUserId} has already been assigned");
			}
			else
			{
				permittedUserId = userId;
			}
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if ((ulong)player.userID == permittedUserId)
		{
			return base.CanBeLooted(player);
		}
		return false;
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		if ((ulong)player.userID == permittedUserId)
		{
			Cleanup_DropItems();
		}
	}

	public override void OnKilled()
	{
		base.OnKilled();
		if (permittedUserId != 0L && BasePlayer.TryFindByID(permittedUserId, out var basePlayer))
		{
			BaseMission.MissionEventPayload missionEventPayload = default(BaseMission.MissionEventPayload);
			missionEventPayload.UintIdentifier = prefabID;
			BaseMission.MissionEventPayload payload = missionEventPayload;
			basePlayer.ProcessMissionEvent(BaseMission.MissionEventType.KILL_ENTITY, payload, 0f);
		}
	}

	private void Cleanup_NoLoot()
	{
		base.inventory.Clear();
		Kill(DestroyMode.Gib);
	}

	private void Cleanup_DropItems()
	{
		DropItems();
		Kill(DestroyMode.Gib);
	}

	[RPC_Server]
	private void Server_UpdateNoteText(RPCMessage msg)
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot != null)
		{
			slot.text = msg.read.String(256, false);
			slot.MarkDirty();
		}
	}

	private bool HasValidMission(BasePlayer player, out BaseMission.MissionInstance activeMissionInstance, out int activeObjectiveIndex)
	{
		activeMissionInstance = null;
		activeObjectiveIndex = -1;
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (!player.TryGetActiveMissionInstance(out activeMissionInstance))
		{
			return false;
		}
		BaseMission mission = activeMissionInstance.GetMission();
		int count = activeMissionInstance.objectiveStatuses.Count;
		int num = mission.objectives.Length;
		if (count != num)
		{
			Debug.LogError((object)$"Mission instance for mission {((Object)mission).name} contains data for {count} objectives but mission has {num} objectives", (Object)(object)mission);
			return false;
		}
		for (int i = 0; i < validMissions.Length; i++)
		{
			MissionEntry missionEntry = validMissions[i];
			if (mission != missionEntry.mission)
			{
				continue;
			}
			for (int j = 0; j < activeMissionInstance.objectiveStatuses.Count; j++)
			{
				BaseMission.MissionInstance.ObjectiveStatus objectiveStatus = activeMissionInstance.objectiveStatuses[j];
				MissionObjective objective = mission.objectives[j].objective;
				if (!objectiveStatus.IsObjectiveActive())
				{
					continue;
				}
				for (int k = 0; k < missionEntry.objectives.Length; k++)
				{
					if ((Object)(object)objective == (Object)(object)missionEntry.objectives[k])
					{
						activeObjectiveIndex = j;
						return true;
					}
				}
			}
		}
		return false;
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (id == 0)
		{
			if (Global.developer > 2)
			{
				NetworkableId iD = net.ID;
				Debug.Log((object)("SyncVar Writing: permittedUserId for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_permittedUserId);
			return true;
		}
		return base.WriteSyncVar(id, writer);
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		if (id == 0)
		{
			try
			{
				_ = __sync_permittedUserId;
				ulong _sync_permittedUserId = reader.UInt64();
				__sync_permittedUserId = _sync_permittedUserId;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			return true;
		}
		return base.OnSyncVar(id, reader, fromAutoSave);
	}

	private byte __GetWeaverID(string propertyName)
	{
		if (propertyName == "permittedUserId")
		{
			return 0;
		}
		return byte.MaxValue;
	}

	protected override void WriteAutoSaveSyncVars(NetWrite writer)
	{
		base.WriteAutoSaveSyncVars(writer);
		WriteSyncVar(0, writer);
	}

	protected override void ReadAutoSaveSyncVars(NetRead reader)
	{
		base.ReadAutoSaveSyncVars(reader);
		OnSyncVar(0, reader, fromAutoSave: true);
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		base.AutoSaveSyncVars(save);
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteAutoSaveSyncVars(val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		base.AutoLoadSyncVars(load);
		if (load.msg.baseEntity != null && load.msg.baseEntity.syncVars != null)
		{
			NetRead val = Pool.Get<NetRead>();
			val.Init(load.msg.baseEntity.syncVars.AsSpan());
			ReadAutoSaveSyncVars(val);
			Pool.Free<NetRead>(ref val);
		}
		return true;
	}

	protected override void ResetSyncVars()
	{
		base.ResetSyncVars();
		__sync_permittedUserId = 0uL;
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		if (id == 0)
		{
			return true;
		}
		return base.ShouldInvalidateCache(id);
	}
}


using System;

[Serializable]
public class MissionEntry
{
	public BaseMission mission;

	public MissionObjective[] objectives = Array.Empty<MissionObjective>();
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Development.Attributes;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Safety;
using UnityEngine;
using UnityEngine.Assertions;

[ResetStaticFields]
public class SleepingBag : DecayEntity
{
	public enum BagAssignMode
	{
		Allowed = 0,
		TeamAndFriendlyContacts = 1,
		None = 2,
		LAST = 2
	}

	public enum BagResultType
	{
		Ok,
		TooManyBags,
		BagBlocked,
		TargetIsPlayingTutorial
	}

	public struct CanAssignBedResult
	{
		public BagResultType Result;

		public int Count;

		public int Max;
	}

	public enum SleepingBagResetReason
	{
		Respawned,
		Placed,
		Death
	}

	[ReplicatedVar]
	public static bool UseTeamLabels = true;

	[NonSerialized]
	public ulong deployerUserID;

	public GameObject renameDialog;

	public GameObject assignDialog;

	public float secondsBetweenReuses = 300f;

	public bool perPlayerRespawnCooldown;

	private Dictionary<ulong, float> playerCooldowns = new Dictionary<ulong, float>();

	public string niceName = "Unnamed Bag";

	public Vector3 spawnOffset = Vector3.zero;

	public RespawnType RespawnType = (RespawnType)1;

	public bool isStatic;

	public bool canBePublic;

	public bool canReassignToFriends = true;

	public const Flags IsPublicFlag = Flags.Reserved3;

	public const Flags DestroyAfterUseFlag = Flags.Reserved14;

	public static Phrase bagLimitPhrase = new Phrase("bag_limit_update", "You are now at {0}/{1} bags");

	public static Phrase bagLimitReachedPhrase = new Phrase("bag_limit_reached", "You have reached your bag limit!");

	public static Phrase teammateBagPhrase = new Phrase("teammate_bag", "{0}'s bag");

	public Phrase assignOtherBagPhrase = new Phrase("assigned_other_bag_limit", "You have assigned {0} a bag, they are now at {0}/{1} bags");

	public Phrase assignedBagPhrase = new Phrase("assigned_bag_limit", "You have been assigned a bag, you are now at {0}/{1} bags");

	public Phrase cannotAssignBedNoPlayerPhrase = new Phrase("cannot_assign_bag_limit_noplayer", "You cannot assign a bag to this player, they have reached their bag limit!");

	public Phrase cannotAssignBedPhrase = new Phrase("cannot_assign_bag_limit", "You cannot assign {0} a bag, they have reached their bag limit!");

	public Phrase cannotMakeBedPhrase = new Phrase("cannot_make_bed_limit", "You cannot take ownership of the bed, you are at your bag limit");

	public Phrase bedAssigningBlocked = new Phrase("bag_assign_blocked", "That player has blocked bag assignment");

	public static Phrase tutorialPhrase = new Phrase("bag_assign_tutorial", "Cannot assign bags to players mid-tutorial");

	public float unlockTime;

	public static List<SleepingBag> sleepingBags = new List<SleepingBag>();

	private bool notifyPlayerOnServerInit;

	private static Dictionary<ulong, List<SleepingBag>> bagsPerPlayer = new Dictionary<ulong, List<SleepingBag>>();

	public virtual float unlockSeconds
	{
		get
		{
			if (unlockTime < Time.realtimeSinceStartup)
			{
				return 0f;
			}
			return unlockTime - Time.realtimeSinceStartup;
		}
	}

	public bool IsTutorialBag
	{
		get
		{
			if (net != null && net.group != null)
			{
				return net.group.restricted;
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SleepingBag.OnRpcMessage", 0);
		try
		{
			if (rpc == 3057055788u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AssignToFriend "));
				}
				TimeWarning val2 = TimeWarning.New("AssignToFriend", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3057055788u, "AssignToFriend", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AssignToFriend(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AssignToFriend");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1335950295 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Rename "));
				}
				TimeWarning val2 = TimeWarning.New("Rename", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1335950295u, "Rename", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Rename(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Rename");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 42669546 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_MakeBed "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_MakeBed", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(42669546u, "RPC_MakeBed", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_MakeBed(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_MakeBed");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 393812086 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_MakePublic "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_MakePublic", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(393812086u, "RPC_MakePublic", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_MakePublic(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_MakePublic");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsPublic()
	{
		return HasFlag(Flags.Reserved3);
	}

	private float EvaluatedSecondsBetweenReuses()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Expected I4, but got Unknown
		float num = 0f;
		RespawnType respawnType = RespawnType;
		switch (respawnType - 1)
		{
		case 0:
		case 2:
			num = ConVar.Server.respawnTimeAdditionBag;
			break;
		case 1:
		case 3:
			num = ConVar.Server.respawnTimeAdditionBed;
			break;
		}
		return secondsBetweenReuses + num;
	}

	public virtual float GetUnlockSeconds(ulong playerID)
	{
		if (playerCooldowns.TryGetValue(playerID, out var value) && value > unlockTime)
		{
			return Mathf.Max(0f, value - Time.realtimeSinceStartup);
		}
		return unlockSeconds;
	}

	public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)
	{
		object obj = Interface.CallHook("OnSleepingBagValidCheck", (object)this, (object)playerID, (object)ignoreTimers);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (deployerUserID == playerID)
		{
			if (!ignoreTimers)
			{
				return unlockTime < Time.realtimeSinceStartup;
			}
			return true;
		}
		return false;
	}

	public static CanAssignBedResult? CanAssignBed(BasePlayer player, SleepingBag newBag, ulong targetPlayer, int countOffset = 1, int maxOffset = 0, SleepingBag ignore = null)
	{
		int num = ConVar.Server.max_sleeping_bags + maxOffset;
		if (player.IsInTutorial)
		{
			return null;
		}
		if (num < 0)
		{
			return null;
		}
		int num2 = countOffset;
		BasePlayer basePlayer = BasePlayer.FindByID(targetPlayer);
		BagAssignMode bagAssignMode = (BagAssignMode)Mathf.Clamp(((Object)(object)basePlayer != (Object)null) ? basePlayer.GetInfoInt("client.bagassignmode", 0) : 0, 0, 2);
		int max = num;
		CanAssignBedResult value;
		if ((Object)(object)player != (Object)(object)basePlayer)
		{
			switch (bagAssignMode)
			{
			case BagAssignMode.Allowed:
				if (ConVar.Server.fogofwar || !ConVar.Server.mapenabled)
				{
					num--;
				}
				break;
			case BagAssignMode.None:
				value = default(CanAssignBedResult);
				value.Result = BagResultType.BagBlocked;
				return value;
			case BagAssignMode.TeamAndFriendlyContacts:
			{
				if (!((Object)(object)basePlayer != (Object)null))
				{
					break;
				}
				bool flag = false;
				if (basePlayer.Team != null && basePlayer.Team.members.Contains(player.userID))
				{
					flag = true;
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo relations = RelationshipManager.ServerInstance.GetRelationships(targetPlayer).GetRelations(player.userID);
					if (relations != null && relations.type == RelationshipManager.RelationshipType.Friend)
					{
						flag = true;
					}
					if (!flag && (Object)(object)ClanManager.ServerInstance != (Object)null && basePlayer.clanId != 0L && basePlayer.clanId == player.clanId)
					{
						flag = true;
					}
				}
				if (!flag)
				{
					value = default(CanAssignBedResult);
					value.Result = BagResultType.BagBlocked;
					return value;
				}
				break;
			}
			}
			if ((Object)(object)basePlayer != (Object)(object)player && (Object)(object)basePlayer != (Object)null && basePlayer.IsInTutorial)
			{
				value = default(CanAssignBedResult);
				value.Result = BagResultType.TargetIsPlayingTutorial;
				return value;
			}
		}
		foreach (SleepingBag sleepingBag in sleepingBags)
		{
			if ((Object)(object)sleepingBag != (Object)(object)ignore && sleepingBag.deployerUserID == targetPlayer)
			{
				num2++;
				if (num2 > num)
				{
					value = default(CanAssignBedResult);
					value.Count = num2;
					value.Max = max;
					value.Result = BagResultType.TooManyBags;
					return value;
				}
			}
		}
		value = default(CanAssignBedResult);
		value.Count = num2;
		value.Max = max;
		value.Result = BagResultType.Ok;
		return value;
	}

	public static Planner.CanBuildResult? CanBuildBed(BasePlayer player, Construction construction)
	{
		GameObject obj = GameManager.server.FindPrefab(construction.prefabID);
		if (((obj != null) ? obj.GetComponent<BaseEntity>() : null) is SleepingBag)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(player, null, player.userID);
			if (canAssignBedResult.HasValue)
			{
				Planner.CanBuildResult value;
				if (canAssignBedResult.Value.Result == BagResultType.Ok)
				{
					value = default(Planner.CanBuildResult);
					value.Result = true;
					value.Phrase = bagLimitPhrase;
					value.Arguments = new string[2]
					{
						canAssignBedResult.Value.Count.ToString(),
						canAssignBedResult.Value.Max.ToString()
					};
					return value;
				}
				value = default(Planner.CanBuildResult);
				value.Result = false;
				value.Phrase = bagLimitReachedPhrase;
				return value;
			}
		}
		return null;
	}

	public static PooledList<SleepingBag> FindForPlayer(ulong playerID, bool ignoreTimers = true)
	{
		PooledList<SleepingBag> val = Pool.Get<PooledList<SleepingBag>>();
		if (bagsPerPlayer.TryGetValue(playerID, out var value))
		{
			if (!ignoreTimers)
			{
				foreach (SleepingBag item in value)
				{
					if (item.ValidForPlayer(playerID, ignoreTimers))
					{
						((List<SleepingBag>)(object)val).Add(item);
					}
				}
			}
			else
			{
				foreach (SleepingBag item2 in value)
				{
					((List<SleepingBag>)(object)val).Add(item2);
				}
			}
		}
		if (!ignoreTimers)
		{
			foreach (StaticRespawnArea staticRespawnArea in StaticRespawnArea.staticRespawnAreas)
			{
				if (staticRespawnArea.ValidForPlayer(playerID, ignoreTimers))
				{
					((List<SleepingBag>)(object)val).Add((SleepingBag)staticRespawnArea);
				}
			}
		}
		else
		{
			foreach (StaticRespawnArea staticRespawnArea2 in StaticRespawnArea.staticRespawnAreas)
			{
				((List<SleepingBag>)(object)val).Add((SleepingBag)staticRespawnArea2);
			}
		}
		return val;
	}

	public static void FindForPlayer(ulong playerID, bool ignoreTimers, List<SleepingBag> result)
	{
		foreach (SleepingBag sleepingBag in sleepingBags)
		{
			if (sleepingBag.ValidForPlayer(playerID, ignoreTimers))
			{
				result.Add(sleepingBag);
			}
		}
	}

	public static void UpdateMyBags(ulong id)
	{
		if (!bagsPerPlayer.TryGetValue(id, out var value))
		{
			return;
		}
		foreach (SleepingBag item in value)
		{
			if (!((Object)(object)item == (Object)null))
			{
				item.SendNetworkUpdate();
			}
		}
	}

	public static void UpdateTeamsBags(List<ulong> ids)
	{
		foreach (ulong id in ids)
		{
			UpdateMyBags(id);
		}
	}

	public static bool SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Invalid comparison between Unknown and I4
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		PooledList<SleepingBag> val = FindForPlayer(player.userID);
		try
		{
			SleepingBag sleepingBag2 = null;
			foreach (SleepingBag item in (List<SleepingBag>)(object)val)
			{
				if (item.ValidForPlayer(player.userID, ignoreTimers: false) && item.net.ID == sleepingBag && item.unlockTime < Time.realtimeSinceStartup)
				{
					sleepingBag2 = item;
					break;
				}
			}
			if ((Object)(object)sleepingBag2 == (Object)null)
			{
				return false;
			}
			object obj = Interface.CallHook("OnPlayerRespawn", (object)player, (object)sleepingBag2);
			if (obj is SleepingBag)
			{
				sleepingBag2 = (SleepingBag)obj;
			}
			if (sleepingBag2 is StaticRespawnArea staticRespawnArea && !staticRespawnArea.IsAuthed(player.userID))
			{
				return false;
			}
			if ((int)sleepingBag2.GetRespawnState(player.userID) != 1)
			{
				return false;
			}
			sleepingBag2.GetSpawnPos(out var pos, out var rot);
			player.RespawnAt(pos, rot, sleepingBag2);
			sleepingBag2.PostPlayerSpawn(player);
			foreach (SleepingBag item2 in (List<SleepingBag>)(object)val)
			{
				SetBagTimer(item2, pos, SleepingBagResetReason.Respawned, player);
			}
			if (sleepingBag2.HasFlag(Flags.Reserved14))
			{
				sleepingBag2.Kill();
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void AddBagForPlayer(SleepingBag bag, ulong user, bool networkUpdate = true)
	{
		if (user == 0L)
		{
			return;
		}
		if (!bagsPerPlayer.TryGetValue(user, out var value))
		{
			value = new List<SleepingBag>();
			bagsPerPlayer[user] = value;
		}
		if (!value.Contains(bag))
		{
			value.Add(bag);
			if (networkUpdate)
			{
				RelationshipManager.FindByID(user)?.SendNetworkUpdate();
			}
		}
	}

	public static void RemoveBagForPlayer(SleepingBag bag, ulong user)
	{
		if (user != 0L && bagsPerPlayer.TryGetValue(user, out var value))
		{
			if (value.Remove(bag))
			{
				RelationshipManager.FindByID(user)?.SendNetworkUpdate();
			}
			if (value.Count == 0)
			{
				bagsPerPlayer.Remove(user);
			}
		}
	}

	public static void OnBagChangedOwnership(SleepingBag bag, ulong oldUser)
	{
		if (bag.deployerUserID != oldUser)
		{
			RemoveBagForPlayer(bag, oldUser);
			AddBagForPlayer(bag, bag.deployerUserID);
		}
	}

	public static void ClearTutorialBagsForPlayer(ulong userId)
	{
		if (userId == 0L || !bagsPerPlayer.TryGetValue(userId, out var _))
		{
			return;
		}
		List<SleepingBag> list = Pool.Get<List<SleepingBag>>();
		foreach (SleepingBag item in bagsPerPlayer[userId])
		{
			if (item.net != null && item.net.group != null && item.net.group.restricted)
			{
				list.Add(item);
			}
		}
		foreach (SleepingBag item2 in list)
		{
			item2.deployerUserID = 0uL;
			RemoveBagForPlayer(item2, userId);
		}
		Pool.FreeUnmanaged<SleepingBag>(ref list);
	}

	public static int GetSleepingBagCount(ulong userId)
	{
		if (userId == 0L)
		{
			return 0;
		}
		if (!bagsPerPlayer.TryGetValue(userId, out var value))
		{
			return 0;
		}
		return value.Count;
	}

	public static bool TrySpawnPlayer(BasePlayer player, NetworkableId sleepingBag, out string errorMessage)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!player.IsDead())
		{
			errorMessage = "Couldn't spawn - player is not dead!";
			return false;
		}
		if (player.CanRespawn())
		{
			if (SpawnPlayer(player, sleepingBag))
			{
				player.MarkRespawn();
				errorMessage = null;
				return true;
			}
			errorMessage = "Couldn't spawn in sleeping bag!";
			return false;
		}
		errorMessage = "You can't respawn again so quickly, wait a while";
		return false;
	}

	public virtual void SetUnlockTime(float newTime)
	{
		unlockTime = newTime;
	}

	public void SetUnlockTimeForPlayer(ulong player, float time)
	{
		playerCooldowns.TryGetValue(player, out var value);
		playerCooldowns[player] = Mathf.Max(value, time);
	}

	public void ResetUnlockTimeForPlayer(ulong player)
	{
		playerCooldowns.Remove(player);
	}

	public static bool DestroyBag(ulong userID, NetworkableId sleepingBag)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		PooledList<SleepingBag> val = FindForPlayer(userID);
		try
		{
			SleepingBag sleepingBag2 = null;
			foreach (SleepingBag item in (List<SleepingBag>)(object)val)
			{
				if (item.net.ID == sleepingBag)
				{
					sleepingBag2 = item;
					break;
				}
			}
			if ((Object)(object)sleepingBag2 == (Object)null)
			{
				return false;
			}
			if (Interface.CallHook("OnSleepingBagDestroy", (object)sleepingBag2, (object)userID) != null)
			{
				return false;
			}
			RemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);
			sleepingBag2.deployerUserID = 0uL;
			if (sleepingBag2.HasFlag(Flags.Reserved14))
			{
				sleepingBag2.Kill();
			}
			else
			{
				sleepingBag2.SendNetworkUpdate();
			}
			BasePlayer basePlayer = BasePlayer.FindByID(userID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.SendRespawnOptions();
				Interface.CallHook("OnSleepingBagDestroyed", (object)sleepingBag2, (object)userID);
				Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void ResetTimersForPlayer(BasePlayer player)
	{
		PooledList<SleepingBag> val = FindForPlayer(player.userID);
		try
		{
			foreach (SleepingBag item in (List<SleepingBag>)(object)val)
			{
				item.unlockTime = 0f;
				item.ResetUnlockTimeForPlayer(player.userID);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void GetSpawnPos(out Vector3 pos, out Quaternion rot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		pos = ((Component)this).transform.position + spawnOffset;
		Quaternion rotation = ((Component)this).transform.rotation;
		rot = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
	}

	public void SetPublic(bool isPublic)
	{
		SetFlag(Flags.Reserved3, isPublic);
	}

	public void SetDeployedBy(BasePlayer player)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)player == (Object)null) && !base.isClient)
		{
			deployerUserID = player.userID;
			SetBagTimer(this, ((Component)this).transform.position, SleepingBagResetReason.Placed, player);
			SendNetworkUpdate();
			notifyPlayerOnServerInit = true;
		}
	}

	public static void OnPlayerDeath(BasePlayer player)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		PooledList<SleepingBag> val = FindForPlayer(player.userID);
		try
		{
			foreach (SleepingBag item in (List<SleepingBag>)(object)val)
			{
				SetBagTimer(item, ((Component)player).transform.position, SleepingBagResetReason.Death, player);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void SetBagTimer(SleepingBag bag, Vector3 position, SleepingBagResetReason reason, BasePlayer forPlayer)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		float? num = null;
		if ((Object)(object)activeGameMode != (Object)null)
		{
			num = activeGameMode.EvaluateSleepingBagReset(bag, position, reason);
		}
		if (num.HasValue)
		{
			bag.SetUnlockTime(Time.realtimeSinceStartup + num.Value);
			return;
		}
		if (reason == SleepingBagResetReason.Respawned && Vector3.Distance(position, ((Component)bag).transform.position) <= ConVar.Server.respawnresetrange)
		{
			if (bag.perPlayerRespawnCooldown)
			{
				bag.SetUnlockTimeForPlayer(forPlayer.userID, Time.realtimeSinceStartup + bag.EvaluatedSecondsBetweenReuses());
			}
			else
			{
				bag.SetUnlockTime(Time.realtimeSinceStartup + bag.EvaluatedSecondsBetweenReuses());
			}
			bag.SendNetworkUpdate();
		}
		if (reason != SleepingBagResetReason.Placed)
		{
			return;
		}
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		SleepingBag[] array = sleepingBags.Where((SleepingBag x) => x.deployerUserID != 0L && x.deployerUserID == bag.deployerUserID && x.unlockTime > Time.realtimeSinceStartup).ToArray();
		foreach (SleepingBag sleepingBag in array)
		{
			if (bag.unlockTime > realtimeSinceStartup && Vector3.Distance(((Component)sleepingBag).transform.position, position) <= ConVar.Server.respawnresetrange)
			{
				realtimeSinceStartup = bag.unlockTime;
			}
		}
		float num2 = Mathf.Max(realtimeSinceStartup, Time.realtimeSinceStartup + bag.EvaluatedSecondsBetweenReuses());
		if ((Object)(object)forPlayer != (Object)null && forPlayer.IsInTutorial)
		{
			num2 = 0f;
		}
		bag.SetUnlockTime(num2);
		bag.SendNetworkUpdate();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!sleepingBags.Contains(this))
		{
			sleepingBags.Add(this);
			if (deployerUserID != 0L)
			{
				AddBagForPlayer(this, deployerUserID, !Application.isLoadingSave);
			}
		}
		if (notifyPlayerOnServerInit)
		{
			notifyPlayerOnServerInit = false;
			NotifyPlayer(deployerUserID);
		}
	}

	public override void OnPlaced(BasePlayer player)
	{
		SetDeployedBy(player);
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		((FacepunchBehaviour)this).Invoke((Action)DelayedPlayerNotify, 0.1f);
	}

	private void DelayedPlayerNotify()
	{
		NotifyPlayer(deployerUserID);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		AddBagForPlayer(this, deployerUserID, !Application.isLoadingSave);
	}

	private void NotifyPlayer(ulong id)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(id);
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsConnected)
		{
			basePlayer.SendRespawnOptions();
		}
	}

	public override void DoServerDestroy()
	{
		base.DoServerDestroy();
		sleepingBags.RemoveAll((SleepingBag x) => (Object)(object)x == (Object)(object)this);
		RemoveBagForPlayer(this, deployerUserID);
		NotifyPlayer(deployerUserID);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		TimeWarning val = TimeWarning.New("SleepingBag.Save", 0);
		try
		{
			info.msg.sleepingBag = Pool.Get<SleepingBag>();
			info.msg.sleepingBag.name = niceName;
			if (info.forDisk)
			{
				info.msg.sleepingBag.deployerID = deployerUserID;
			}
			else
			{
				info.msg.sleepingBag.clientAssigned = deployerUserID == info.forConnection.userid;
				info.msg.sleepingBag.isAssigned = deployerUserID != 0;
			}
			if (!UseTeamLabels)
			{
				return;
			}
			if ((Object)(object)RelationshipManager.ServerInstance != (Object)null && info.forConnection != null)
			{
				try
				{
					RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(deployerUserID);
					BasePlayer basePlayer = BasePlayer.FindAwakeOrSleepingByID(deployerUserID);
					if (playerTeam != null || ((Object)(object)basePlayer != (Object)null && info.forConnection == basePlayer.Connection))
					{
						if (info.forConnection.userid != 0L && (Object)(object)basePlayer != (Object)null)
						{
							string displayName = basePlayer.displayName;
							if (deployerUserID == info.forConnection.userid)
							{
								info.msg.sleepingBag.teamMemberName = displayName;
							}
							else
							{
								List<ulong> members = playerTeam.members;
								if (members.Count > 0 && members.Contains(info.forConnection.userid))
								{
									info.msg.sleepingBag.teamMemberName = displayName;
								}
								else
								{
									info.msg.sleepingBag.teamMemberName = "";
								}
							}
						}
					}
					else
					{
						info.msg.sleepingBag.teamMemberName = "";
					}
					return;
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					return;
				}
			}
			info.msg.sleepingBag.teamMemberName = "";
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override bool CanUseNetworkCache(Connection connection)
	{
		return false;
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Rename(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		string text = msg.read.String(256, false);
		if (Interface.CallHook("CanRenameBed", (object)msg.player, (object)this, (object)text) == null)
		{
			text = WordFilter.Filter(text);
			if (string.IsNullOrEmpty(text))
			{
				text = "Unnamed Sleeping Bag";
			}
			if (text.Length > 24)
			{
				text = text.Substring(0, 22) + "..";
			}
			niceName = text;
			SendNetworkUpdate();
			NotifyPlayer(deployerUserID);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (!msg.player.CanInteract() || deployerUserID != (ulong)msg.player.userID || !canReassignToFriends)
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num == 0L || Interface.CallHook("CanAssignBed", (object)msg.player, (object)this, (object)num) != null)
		{
			return;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, num);
			if (canAssignBedResult.HasValue)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(num);
				if (canAssignBedResult.Value.Result == BagResultType.TooManyBags)
				{
					if ((Object)(object)basePlayer == (Object)null)
					{
						msg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedNoPlayerPhrase, false);
					}
					else
					{
						string playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);
						msg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedPhrase, false, playerNameStreamSafe);
					}
				}
				else if (canAssignBedResult.Value.Result == BagResultType.BagBlocked)
				{
					msg.player.ShowToast(GameTip.Styles.Error, bedAssigningBlocked, false);
				}
				else if (canAssignBedResult.Value.Result == BagResultType.TargetIsPlayingTutorial)
				{
					msg.player.ShowToast(GameTip.Styles.Error, tutorialPhrase, false);
				}
				else
				{
					basePlayer?.ShowToast(GameTip.Styles.Blue_Long, assignedBagPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, (GetSleepingBagCount(msg.player.userID) - 1).ToString(), canAssignBedResult.Value.Max.ToString());
					SendNetworkUpdate();
				}
				if (canAssignBedResult.Value.Result != 0)
				{
					return;
				}
			}
		}
		ulong num2 = deployerUserID;
		deployerUserID = num;
		OnBagChangedOwnership(this, num2);
		NotifyPlayer(num2);
		NotifyPlayer(deployerUserID);
		Analytics.Azure.OnSleepingBagAssigned(msg.player, this, num);
		SendNetworkUpdate();
	}

	[ServerVar]
	public static void AssignToPlayer(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		NetworkableId entityID = arg.GetEntityID(0);
		SleepingBag obj = BaseNetworkable.serverEntities.Find(entityID) as SleepingBag;
		ulong num = obj.deployerUserID;
		obj.deployerUserID = basePlayer.userID.Get();
		OnBagChangedOwnership(obj, num);
		obj.NotifyPlayer(num);
		obj.NotifyPlayer(obj.deployerUserID);
		obj.SendNetworkUpdate();
	}

	[ServerVar]
	public static void ClearFromPlayer(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityID = arg.GetEntityID(0);
		SleepingBag obj = BaseNetworkable.serverEntities.Find(entityID) as SleepingBag;
		ulong num = obj.deployerUserID;
		obj.deployerUserID = 0uL;
		RemoveBagForPlayer(obj, num);
		obj.NotifyPlayer(num);
		obj.SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public virtual void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != (ulong)msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag == IsPublic() || Interface.CallHook("CanSetBedPublic", (object)msg.player, (object)this) != null)
		{
			return;
		}
		SetPublic(flag);
		if (!IsPublic())
		{
			if (ConVar.Server.max_sleeping_bags > 0)
			{
				CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
				if (canAssignBedResult.HasValue)
				{
					if (canAssignBedResult.Value.Result == BagResultType.Ok)
					{
						msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					}
					else
					{
						msg.player.ShowToast(GameTip.Styles.Blue_Long, cannotMakeBedPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					}
					if (canAssignBedResult.Value.Result != 0)
					{
						return;
					}
				}
			}
			ulong num = deployerUserID;
			deployerUserID = msg.player.userID;
			OnBagChangedOwnership(this, num);
			NotifyPlayer(num);
			NotifyPlayer(deployerUserID);
			Analytics.Azure.OnSleepingBagAssigned(msg.player, this, deployerUserID = msg.player.userID);
		}
		else
		{
			Analytics.Azure.OnSleepingBagAssigned(msg.player, this, 0uL);
		}
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_MakeBed(RPCMessage msg)
	{
		if (!canBePublic || !IsPublic() || !msg.player.CanInteract())
		{
			return;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
			if (canAssignBedResult.HasValue)
			{
				if (canAssignBedResult.Value.Result != 0)
				{
					msg.player.ShowToast(GameTip.Styles.Red_Normal, cannotMakeBedPhrase, false);
				}
				else
				{
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
				}
				if (canAssignBedResult.Value.Result != 0)
				{
					return;
				}
			}
		}
		ulong num = deployerUserID;
		deployerUserID = msg.player.userID;
		OnBagChangedOwnership(this, num);
		NotifyPlayer(num);
		NotifyPlayer(deployerUserID);
		Interface.CallHook("OnBedMade", (object)this, (object)msg.player);
		SendNetworkUpdate();
	}

	protected virtual void PostPlayerSpawn(BasePlayer p)
	{
		p.SendRespawnOptions();
		if (Debugging.bag_respawn_parenting && HasParent())
		{
			BaseEntity baseEntity = GetParentEntity();
			if (baseEntity is PlayerBoat)
			{
				p.SetParent(baseEntity, worldPositionStays: true);
			}
		}
	}

	public virtual RespawnState GetRespawnState(ulong userID)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (!WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: false))
		{
			if (!TriggerNoRespawnZone.InAnyNoRespawnZone(((Component)this).transform.position))
			{
				return (RespawnState)1;
			}
			return (RespawnState)4;
		}
		return (RespawnState)3;
	}

	public virtual bool IsMobile()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Invalid comparison between Unknown and I4
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null && (baseEntity is BaseVehicle || baseEntity is BoatBuildingBlock))
		{
			return true;
		}
		return (int)RespawnType == 4;
	}

	public override string Admin_Who()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine(base.Admin_Who());
		stringBuilder.AppendLine($"Assigned bag ID: {deployerUserID}");
		stringBuilder.AppendLine("Assigned player name: " + Admin.GetPlayerName(deployerUserID));
		stringBuilder.AppendLine("Bag Name:" + niceName);
		return stringBuilder.ToString();
	}

	public override void OnDeployableCorpseSpawned(BaseEntity corpse)
	{
		base.OnDeployableCorpseSpawned(corpse);
		if (corpse is SleepingBag sleepingBag)
		{
			sleepingBag.deployerUserID = deployerUserID;
			sleepingBag.niceName = niceName;
			sleepingBag.SetFlag(Flags.Reserved14, b: true);
			AddBagForPlayer(sleepingBag, deployerUserID);
		}
	}

	public override bool ShouldDropDeployableCorpse(HitInfo info)
	{
		if (!base.ShouldDropDeployableCorpse(info))
		{
			return false;
		}
		if (HasFlag(Flags.Reserved14))
		{
			return false;
		}
		return true;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.sleepingBag != null)
		{
			niceName = info.msg.sleepingBag.name;
			if (base.isServer)
			{
				deployerUserID = info.msg.sleepingBag.deployerID;
			}
		}
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (base.ShouldDisplayPickupOption(player) && Check.IsAuthorisedToBuild(player))
		{
			return true;
		}
		if (base.ShouldDisplayPickupOption(player))
		{
			return (ulong)player.userID == deployerUserID;
		}
		return false;
	}
}


public enum BagAssignMode
{
	Allowed = 0,
	TeamAndFriendlyContacts = 1,
	None = 2,
	LAST = 2
}


public enum BagResultType
{
	Ok,
	TooManyBags,
	BagBlocked,
	TargetIsPlayingTutorial
}


public struct CanAssignBedResult
{
	public BagResultType Result;

	public int Count;

	public int Max;
}


public enum SleepingBagResetReason
{
	Respawned,
	Placed,
	Death
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SleepingBagCamper : SleepingBag
{
	public EntityRef<BaseVehicleSeat> AssociatedSeat;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SleepingBagCamper.OnRpcMessage", 0);
		try
		{
			if (rpc == 2177887503u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerClearBed "));
				}
				TimeWarning val2 = TimeWarning.New("ServerClearBed", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2177887503u, "ServerClearBed", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerClearBed(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerClearBed");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Reserved3, b: true);
	}

	protected override void PostPlayerSpawn(BasePlayer p)
	{
		base.PostPlayerSpawn(p);
		BaseVehicleSeat baseVehicleSeat = AssociatedSeat.Get(base.isServer);
		if ((Object)(object)baseVehicleSeat != (Object)null)
		{
			if (p.IsConnected)
			{
				p.EndSleeping();
			}
			baseVehicleSeat.MountPlayer(p);
		}
	}

	public void SetSeat(BaseVehicleSeat seat, bool sendNetworkUpdate = false)
	{
		AssociatedSeat.Set(seat);
		if (sendNetworkUpdate)
		{
			SendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.sleepingBagCamper = Pool.Get<SleepingBagCamper>();
			info.msg.sleepingBagCamper.seatID = AssociatedSeat.uid;
		}
	}

	public override RespawnState GetRespawnState(ulong userID)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Invalid comparison between Unknown and I4
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		RespawnState respawnState = base.GetRespawnState(userID);
		if ((int)respawnState != 1)
		{
			return respawnState;
		}
		if (AssociatedSeat.IsValid(base.isServer))
		{
			BasePlayer mounted = AssociatedSeat.Get(base.isServer).GetMounted();
			if ((Object)(object)mounted != (Object)null && (ulong)mounted.userID != userID)
			{
				return (RespawnState)2;
			}
		}
		return (RespawnState)1;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void ServerClearBed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && AssociatedSeat.IsValid(base.isServer) && !((Object)(object)AssociatedSeat.Get(base.isServer).GetMounted() != (Object)(object)player))
		{
			ulong userID = deployerUserID;
			SleepingBag.RemoveBagForPlayer(this, deployerUserID);
			deployerUserID = 0uL;
			SendNetworkUpdate();
			BasePlayer basePlayer = BasePlayer.FindByID(userID);
			if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsDestroyed)
			{
				basePlayer.SendRespawnOptions();
			}
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class SlotMachine : BaseMountable, INotifyLOD
{
	public enum SlotFaces
	{
		Scrap,
		Rope,
		Apple,
		LowGrade,
		Wood,
		Bandage,
		Charcoal,
		Gunpowder,
		Rust,
		Meat,
		Hammer,
		Sulfur,
		TechScrap,
		Frags,
		Cloth,
		LuckySeven
	}

	[ServerVar]
	public static int ForcePayoutIndex = -1;

	[Header("Slot Machine")]
	public Transform Reel1;

	public Transform Reel2;

	public Transform Reel3;

	public Transform Arm;

	public AnimationCurve Curve;

	public int Reel1Spins = 16;

	public int Reel2Spins = 48;

	public int Reel3Spins = 80;

	public int MaxReelSpins = 96;

	public float SpinDuration = 2f;

	private int SpinResult1;

	private int SpinResult2;

	private int SpinResult3;

	private int SpinResultPrevious1;

	private int SpinResultPrevious2;

	private int SpinResultPrevious3;

	private float SpinTime;

	public GameObjectRef StoragePrefab;

	public EntityRef StorageInstance;

	public SoundDefinition SpinSound;

	public SlotMachinePayoutDisplay PayoutDisplay;

	public SlotMachinePayoutSettings PayoutSettings;

	public Transform HandIkTarget;

	private const Flags HasScrapForSpin = Flags.Reserved1;

	private const Flags IsSpinningFlag = Flags.Reserved2;

	public Material PayoutIconMaterial;

	public bool UseTimeOfDayAdjustedSprite = true;

	public MeshRenderer PulseRenderer;

	public float PulseSpeed = 5f;

	[ColorUsage(true, true)]
	public Color PulseFrom;

	[ColorUsage(true, true)]
	public Color PulseTo;

	private BasePlayer CurrentSpinPlayer;

	private bool IsSpinning => HasFlag(Flags.Reserved2);

	public int CurrentMultiplier { get; private set; } = 1;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SlotMachine.OnRpcMessage", 0);
		try
		{
			if (rpc == 1251063754 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Deposit "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Deposit", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1251063754u, "RPC_Deposit", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_Deposit(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Deposit");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1455840454 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Spin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Spin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1455840454u, "RPC_Spin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_Spin(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Spin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3942337446u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestMultiplierChange "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestMultiplierChange", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3942337446u, "Server_RequestMultiplierChange", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3942337446u, "Server_RequestMultiplierChange", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_RequestMultiplierChange(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in Server_RequestMultiplierChange");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.slotMachine = Pool.Get<SlotMachine>();
		info.msg.slotMachine.oldResult1 = SpinResultPrevious1;
		info.msg.slotMachine.oldResult2 = SpinResultPrevious2;
		info.msg.slotMachine.oldResult3 = SpinResultPrevious3;
		info.msg.slotMachine.newResult1 = SpinResult1;
		info.msg.slotMachine.newResult2 = SpinResult2;
		info.msg.slotMachine.newResult3 = SpinResult3;
		info.msg.slotMachine.isSpinning = IsSpinning;
		info.msg.slotMachine.spinTime = SpinTime;
		info.msg.slotMachine.storageID = StorageInstance.uid;
		info.msg.slotMachine.multiplier = CurrentMultiplier;
	}

	public override void Load(LoadInfo info)
	{
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.slotMachine != null)
		{
			SpinResultPrevious1 = info.msg.slotMachine.oldResult1;
			SpinResultPrevious2 = info.msg.slotMachine.oldResult2;
			SpinResultPrevious3 = info.msg.slotMachine.oldResult3;
			SpinResult1 = info.msg.slotMachine.newResult1;
			SpinResult2 = info.msg.slotMachine.newResult2;
			SpinResult3 = info.msg.slotMachine.newResult3;
			CurrentMultiplier = info.msg.slotMachine.multiplier;
			if (base.isServer)
			{
				SpinTime = info.msg.slotMachine.spinTime;
			}
			StorageInstance.uid = info.msg.slotMachine.storageID;
			if (info.fromDisk && base.isServer)
			{
				SetFlag(Flags.Reserved2, b: false);
			}
		}
	}

	public override BaseVehicle VehicleParent()
	{
		return null;
	}

	public override float GetComfort()
	{
		return 1f;
	}

	public override void Spawn()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(StoragePrefab.resourcePath);
			baseEntity.Spawn();
			baseEntity.SetParent(this);
			StorageInstance.Set(baseEntity);
		}
	}

	internal override void DoServerDestroy()
	{
		SlotMachineStorage slotMachineStorage = StorageInstance.Get(base.isServer) as SlotMachineStorage;
		if (slotMachineStorage.IsValid())
		{
			slotMachineStorage.DropItems();
		}
		base.DoServerDestroy();
	}

	private int GetBettingAmount()
	{
		SlotMachineStorage component = ((Component)StorageInstance.Get(base.isServer)).GetComponent<SlotMachineStorage>();
		if ((Object)(object)component == (Object)null)
		{
			return 0;
		}
		return component.inventory.GetSlot(0)?.amount ?? 0;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Spin(RPCMessage rpc)
	{
		if (IsSpinning || (Object)(object)rpc.player != (Object)(object)GetMounted())
		{
			return;
		}
		SlotMachineStorage component = ((Component)StorageInstance.Get(base.isServer)).GetComponent<SlotMachineStorage>();
		int num = (int)PayoutSettings.SpinCost.amount * CurrentMultiplier;
		if (GetBettingAmount() < num || (Object)(object)rpc.player == (Object)null)
		{
			return;
		}
		(CurrentSpinPlayer = rpc.player).inventory.loot.Clear();
		Item slot = component.inventory.GetSlot(0);
		int amount = 0;
		if (slot != null)
		{
			if (slot.amount > num)
			{
				slot.MarkDirty();
				slot.amount -= num;
				amount = slot.amount;
			}
			else
			{
				slot.amount -= num;
				slot.RemoveFromContainer();
			}
		}
		component.UpdateAmount(amount);
		SetFlag(Flags.Reserved2, b: true);
		SpinResultPrevious1 = SpinResult1;
		SpinResultPrevious2 = SpinResult2;
		SpinResultPrevious3 = SpinResult3;
		CalculateSpinResults();
		SpinTime = Time.time;
		ClientRPC(RpcTarget.NetworkGroup("RPC_OnSpin"), (sbyte)SpinResult1, (sbyte)SpinResult2, (sbyte)SpinResult3);
		((FacepunchBehaviour)this).Invoke((Action)CheckPayout, SpinDuration);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Deposit(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null) && !HasFlag(Flags.Reserved2) && StorageInstance.IsValid(base.isServer))
		{
			((Component)StorageInstance.Get(base.isServer)).GetComponent<StorageContainer>().PlayerOpenLoot(player, "", doPositionChecks: false);
		}
	}

	private void CheckPayout()
	{
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if ((Object)(object)PayoutSettings != (Object)null)
		{
			if (CalculatePayout(out var info, out var bonus))
			{
				int num = ((int)info.Item.amount + bonus) * CurrentMultiplier;
				BaseEntity baseEntity = StorageInstance.Get(serverside: true);
				if ((Object)(object)baseEntity != (Object)null && baseEntity is SlotMachineStorage slotMachineStorage)
				{
					Item slot = slotMachineStorage.inventory.GetSlot(1);
					if (slot != null)
					{
						slot.amount += num;
						slot.MarkDirty();
					}
					else
					{
						ItemManager.Create(info.Item.itemDef, num, 0uL).MoveToContainer(slotMachineStorage.inventory, 1);
					}
				}
				if (CurrentSpinPlayer.IsValid() && (Object)(object)CurrentSpinPlayer == (Object)(object)GetMounted())
				{
					CurrentSpinPlayer.ChatMessage($"You received {num}x {info.Item.itemDef.displayName.english} for slots payout!");
				}
				Analytics.Azure.OnGamblingResult(CurrentSpinPlayer, this, (int)PayoutSettings.SpinCost.amount * CurrentMultiplier, num, null);
				if (info.OverrideWinEffect != null && info.OverrideWinEffect.isValid)
				{
					Effect.server.Run(info.OverrideWinEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
				else if (PayoutSettings.DefaultWinEffect != null && PayoutSettings.DefaultWinEffect.isValid)
				{
					Effect.server.Run(PayoutSettings.DefaultWinEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
				if (info.OverrideWinEffect != null && info.OverrideWinEffect.isValid)
				{
					flag = true;
				}
			}
			else
			{
				Analytics.Azure.OnGamblingResult(CurrentSpinPlayer, this, (int)PayoutSettings.SpinCost.amount * CurrentMultiplier, 0, null);
			}
		}
		else
		{
			Debug.LogError((object)$"Failed to process spin results: PayoutSettings != null {(Object)(object)PayoutSettings != (Object)null} CurrentSpinPlayer.IsValid {CurrentSpinPlayer.IsValid()} CurrentSpinPlayer == mounted {(Object)(object)CurrentSpinPlayer == (Object)(object)GetMounted()}");
		}
		if (!flag)
		{
			SetFlag(Flags.Reserved2, b: false);
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedSpinningReset, 4f);
		}
		CurrentSpinPlayer = null;
	}

	private void DelayedSpinningReset()
	{
		SetFlag(Flags.Reserved2, b: false);
	}

	private void CalculateSpinResults()
	{
		if (ForcePayoutIndex != -1)
		{
			SpinResult1 = PayoutSettings.Payouts[ForcePayoutIndex].Result1;
			SpinResult2 = PayoutSettings.Payouts[ForcePayoutIndex].Result2;
			SpinResult3 = PayoutSettings.Payouts[ForcePayoutIndex].Result3;
		}
		else
		{
			SpinResult1 = RandomSpinResult();
			SpinResult2 = RandomSpinResult();
			SpinResult3 = RandomSpinResult();
		}
	}

	private int RandomSpinResult()
	{
		int num = new Random(Random.Range(0, 1000)).Next(0, PayoutSettings.TotalStops);
		int num2 = 0;
		int num3 = 0;
		int[] virtualFaces = PayoutSettings.VirtualFaces;
		foreach (int num4 in virtualFaces)
		{
			if (num < num4 + num2)
			{
				return num3;
			}
			num2 += num4;
			num3++;
		}
		return 15;
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		BaseEntity baseEntity = StorageInstance.Get(serverside: true);
		if ((Object)(object)baseEntity != (Object)null && baseEntity is SlotMachineStorage slotMachineStorage)
		{
			slotMachineStorage.inventory.GetSlot(1)?.MoveToContainer(player.inventory.containerMain);
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void Server_RequestMultiplierChange(RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)GetMounted()) && !HasFlag(Flags.Reserved2))
		{
			CurrentMultiplier = Mathf.Clamp(msg.read.Int32(), 1, 5);
			OnBettingScrapUpdated(GetBettingAmount());
			SendNetworkUpdate();
		}
	}

	public void OnBettingScrapUpdated(int amount)
	{
		SetFlag(Flags.Reserved1, (float)amount >= PayoutSettings.SpinCost.amount * (float)CurrentMultiplier);
	}

	private bool CalculatePayout(out SlotMachinePayoutSettings.PayoutInfo info, out int bonus)
	{
		info = default(SlotMachinePayoutSettings.PayoutInfo);
		bonus = 0;
		SlotMachinePayoutSettings.IndividualPayouts[] facePayouts = PayoutSettings.FacePayouts;
		for (int i = 0; i < facePayouts.Length; i++)
		{
			SlotMachinePayoutSettings.IndividualPayouts individualPayouts = facePayouts[i];
			if (individualPayouts.Result == SpinResult1)
			{
				bonus += (int)individualPayouts.Item.amount;
			}
			if (individualPayouts.Result == SpinResult2)
			{
				bonus += (int)individualPayouts.Item.amount;
			}
			if (individualPayouts.Result == SpinResult3)
			{
				bonus += (int)individualPayouts.Item.amount;
			}
			if (bonus > 0)
			{
				info.Item = new ItemAmount(individualPayouts.Item.itemDef);
			}
		}
		SlotMachinePayoutSettings.PayoutInfo[] payouts = PayoutSettings.Payouts;
		for (int i = 0; i < payouts.Length; i++)
		{
			SlotMachinePayoutSettings.PayoutInfo payoutInfo = payouts[i];
			if (payoutInfo.Result1 == SpinResult1 && payoutInfo.Result2 == SpinResult2 && payoutInfo.Result3 == SpinResult3)
			{
				info = payoutInfo;
				return true;
			}
		}
		return bonus > 0;
	}
}


public enum SlotFaces
{
	Scrap,
	Rope,
	Apple,
	LowGrade,
	Wood,
	Bandage,
	Charcoal,
	Gunpowder,
	Rust,
	Meat,
	Hammer,
	Sulfur,
	TechScrap,
	Frags,
	Cloth,
	LuckySeven
}


using System;
using Network;
using UnityEngine;

public class SlotMachineStorage : StorageContainer
{
	public int Amount;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SlotMachineStorage.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsPlayerValid(BasePlayer player)
	{
		if (!player.isMounted || (Object)(object)player.GetMounted() != (Object)(object)GetParentEntity())
		{
			return false;
		}
		return true;
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (!IsPlayerValid(player))
		{
			return false;
		}
		return base.PlayerOpenLoot(player, panelToOpen);
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		UpdateAmount(base.inventory.GetSlot(0)?.amount ?? 0);
	}

	public void UpdateAmount(int amount)
	{
		if (Amount != amount)
		{
			Amount = amount;
			(GetParentEntity() as SlotMachine).OnBettingScrapUpdated(amount);
			ClientRPC(RpcTarget.NetworkGroup("RPC_UpdateAmount"), Amount);
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!IsPlayerValid(player))
		{
			return false;
		}
		return base.CanBeLooted(player);
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class SmallEngine : DecayEntity, IBoatBuildingPiece, IBoatPropulsion, IEngineControllerUser, IEntity
{
	[Header("Small Engine")]
	public float MaxThrust = 1000f;

	[SerializeField]
	private float ReverseSpeedRatio = 0.5f;

	[Header("Fuel")]
	public GameObjectRef fuelStoragePrefab;

	public float fuelPerSec;

	[Header("Visuals")]
	public Animator Animator;

	private EntityFuelSystem fuelSystem;

	private const Flags Flag_HasFuel = Flags.Reserved2;

	private const Flags Flag_InReverse = Flags.Reserved3;

	public bool InReverse => HasFlag(Flags.Reserved3);

	public float ReverseMod => 0f - ReverseSpeedRatio;

	public float CurrentThrust
	{
		get
		{
			if (!IsOn())
			{
				return 0f;
			}
			return MaxThrust;
		}
	}

	float IBoatPropulsion.MaxThrust => MaxThrust;

	public Vector3 ThrustPosition => ((Component)this).transform.position + ((Component)this).transform.up * 1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SmallEngine.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1851540757u, "RPC_OpenFuel", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_OpenFuel(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenFuel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4093422150u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_ToggleReverse "));
				}
				TimeWarning val2 = TimeWarning.New("SV_ToggleReverse", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4093422150u, "SV_ToggleReverse", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4093422150u, "SV_ToggleReverse", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SV_ToggleReverse(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SV_ToggleReverse");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2179891358u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - TurnOff "));
				}
				TimeWarning val2 = TimeWarning.New("TurnOff", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2179891358u, "TurnOff", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2179891358u, "TurnOff", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							TurnOff(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in TurnOff");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 6309714 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - TurnOn "));
				}
				TimeWarning val2 = TimeWarning.New("TurnOn", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(6309714u, "TurnOn", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(6309714u, "TurnOn", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							TurnOn(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in TurnOn");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		fuelSystem = new EntityFuelSystem(base.isServer, fuelStoragePrefab, children, editorGiveFreeFuel: true, FuelAddedRemovedCallback);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.smallEngine != null)
		{
			fuelSystem.SetInstanceID(info.msg.smallEngine.fuelStorageID);
		}
	}

	public bool AdminFixUp()
	{
		if (IsDead() || fuelSystem == null)
		{
			return false;
		}
		fuelSystem.FillFuel();
		return true;
	}

	public override void OnPickedUp(Item createdItem, BasePlayer player)
	{
		base.OnPickedUp(createdItem, player);
		if (fuelSystem.GetFuelAmount() > 0)
		{
			player.GiveItem(fuelSystem.GetFuelItem(), GiveItemReason.PickedUp);
		}
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned)
		{
			fuelSystem.CheckNewChild(child);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.smallEngine = Pool.Get<SmallEngine>();
		info.msg.smallEngine.fuelStorageID = fuelSystem.GetInstanceID();
	}

	private void FuelAddedRemovedCallback(bool added)
	{
		SetFlag(Flags.Reserved2, fuelSystem.HasFuel());
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void TurnOn(RPCMessage msg)
	{
		if (Interface.CallHook("OnEngineStart", (object)this, (object)msg.player) == null && fuelSystem.HasFuel() && PlayerBoat.IsPlayerAuthedOnChildEntity(this, msg.player, authedIfNoPrivOrLock: true))
		{
			TurnOn();
		}
	}

	public void TurnOn()
	{
		SetFlag(Flags.On, b: true);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void TurnOff(RPCMessage msg)
	{
		if (Interface.CallHook("OnEngineStop", (object)this, (object)msg.player) == null && PlayerBoat.IsPlayerAuthedOnChildEntity(this, msg.player, authedIfNoPrivOrLock: true))
		{
			TurnOff();
		}
	}

	public void TurnOff()
	{
		SetFlag(Flags.On, b: false);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void SV_ToggleReverse(RPCMessage msg)
	{
		if (Interface.CallHook("OnEngineReverse", (object)this, (object)msg.player) == null && PlayerBoat.IsPlayerAuthedOnChildEntity(this, msg.player, authedIfNoPrivOrLock: true) && PlayerBoat.IsChildOfInteractablePlayerBoat(this))
		{
			SetFlag(Flags.Reserved3, !InReverse);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && PlayerBoat.IsPlayerAuthedOnChildEntity(this, msg.player, authedIfNoPrivOrLock: true))
		{
			fuelSystem.LootFuel(player);
		}
	}

	public override void Hurt(HitInfo info)
	{
		PlayerBoat parentPlayerBoat = PlayerBoat.GetParentPlayerBoat(this);
		if ((Object)(object)parentPlayerBoat != (Object)null)
		{
			parentPlayerBoat.OnBoatDeployableHurt(this, info);
		}
		else
		{
			base.Hurt(info);
		}
	}

	public bool TryUseFuel()
	{
		if (!IsOn())
		{
			return false;
		}
		if (!fuelSystem.HasFuel())
		{
			SetFlag(Flags.Reserved2, b: true);
			if (IsOn())
			{
				TurnOff();
			}
		}
		fuelSystem.TryUseFuel(Time.fixedDeltaTime, fuelPerSec);
		return true;
	}

	public void OnEngineStartFailed()
	{
	}

	public bool MeetsEngineRequirements()
	{
		return true;
	}

	void IBoatBuildingPiece.OnAddedToBoat(PlayerBoat boat)
	{
		TurnOff();
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (base.ShouldDisplayPickupOption(player))
		{
			return !PlayerBoat.IsChildOfInteractablePlayerBoat(this);
		}
		return false;
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


using System;
using CompanionServer;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SmartAlarm : AppIOEntity, ISubscribable
{
	public const Flags Flag_HasCustomMessage = Flags.Reserved6;

	public static readonly Phrase DefaultNotificationTitle = new Phrase("app.alarm.title", "Alarm");

	public static readonly Phrase DefaultNotificationBody = new Phrase("app.alarm.body", "Your base is under attack!");

	[Header("Smart Alarm")]
	public GameObjectRef SetupNotificationDialog;

	public Animator Animator;

	public readonly NotificationList _subscriptions = new NotificationList();

	public string _notificationTitle = "";

	public string _notificationBody = "";

	public float _lastSentTime;

	public override AppEntityType Type => (AppEntityType)2;

	public override bool Value { get; set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SmartAlarm.OnRpcMessage", 0);
		try
		{
			if (rpc == 3292290572u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetNotificationTextImpl "));
				}
				TimeWarning val2 = TimeWarning.New("SetNotificationTextImpl", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3292290572u, "SetNotificationTextImpl", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3292290572u, "SetNotificationTextImpl", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage notificationTextImpl = rPCMessage;
							SetNotificationTextImpl(notificationTextImpl);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetNotificationTextImpl");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4207149767u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartSetupNotification "));
				}
				TimeWarning val2 = TimeWarning.New("StartSetupNotification", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4207149767u, "StartSetupNotification", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4207149767u, "StartSetupNotification", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							StartSetupNotification(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in StartSetupNotification");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool AddSubscription(ulong steamId)
	{
		return _subscriptions.AddSubscription(steamId);
	}

	public bool RemoveSubscription(ulong steamId)
	{
		return _subscriptions.RemoveSubscription(steamId);
	}

	public bool HasSubscription(ulong steamId)
	{
		return _subscriptions.HasSubscription(steamId);
	}

	public override void InitShared()
	{
		base.InitShared();
		_notificationTitle = DefaultNotificationTitle.translated;
		_notificationBody = DefaultNotificationBody.translated;
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		Value = inputAmount > 0;
		if (Value == IsOn())
		{
			return;
		}
		SetFlag(Flags.On, Value);
		BroadcastValueChange();
		float num = Mathf.Max(App.alarmcooldown, 15f);
		if (Value && Time.realtimeSinceStartup - _lastSentTime >= num)
		{
			BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
			if ((Object)(object)buildingPrivilege != (Object)null)
			{
				_subscriptions.IntersectWith(buildingPrivilege.authorizedPlayers);
			}
			_subscriptions.SendNotification(NotificationChannel.SmartAlarm, _notificationTitle, _notificationBody, "alarm");
			_lastSentTime = Time.realtimeSinceStartup;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.smartAlarm = Pool.Get<SmartAlarm>();
			info.msg.smartAlarm.notificationTitle = _notificationTitle;
			info.msg.smartAlarm.notificationBody = _notificationBody;
			info.msg.smartAlarm.subscriptions = _subscriptions.ToList();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && info.msg.smartAlarm != null)
		{
			_notificationTitle = info.msg.smartAlarm.notificationTitle;
			_notificationBody = info.msg.smartAlarm.notificationBody;
			_subscriptions.LoadFrom(info.msg.smartAlarm.subscriptions);
		}
	}

	protected override void OnPairedWithPlayer(BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) && !HasSubscription(player.userID) && !AddSubscription(player.userID))
		{
			player.ClientRPC(RpcTarget.Player("HandleCompanionPairingResult", player), 7);
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void StartSetupNotification(RPCMessage rpc)
	{
		if (rpc.player.CanInteract())
		{
			BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
			if (!((Object)(object)buildingPrivilege != (Object)null) || buildingPrivilege.CanAdministrate(rpc.player))
			{
				ClientRPC(RpcTarget.Player("SetupNotification", rpc.player), _notificationTitle, _notificationBody);
			}
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void SetNotificationTextImpl(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
		if (!((Object)(object)buildingPrivilege != (Object)null) || buildingPrivilege.CanAdministrate(rpc.player))
		{
			string text = rpc.read.String(128, false);
			string text2 = rpc.read.String(512, false);
			if (!string.IsNullOrWhiteSpace(text))
			{
				_notificationTitle = text;
			}
			if (!string.IsNullOrWhiteSpace(text2))
			{
				_notificationBody = text2;
			}
			SetFlag(Flags.Reserved6, b: true);
		}
	}
}


using System;
using ConVar;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SmartSwitch : AppIOEntity
{
	[Header("Smart Switch")]
	public Animator ReceiverAnimator;

	public override AppEntityType Type => (AppEntityType)1;

	public override bool Value
	{
		get
		{
			return IsOn();
		}
		set
		{
			SetSwitch(value);
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SmartSwitch.OnRpcMessage", 0);
		try
		{
			if (rpc == 2810053005u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ToggleSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("ToggleSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2810053005u, "ToggleSwitch", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2810053005u, "ToggleSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ToggleSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ToggleSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool WantsPower(int inputIndex)
	{
		if (inputIndex == 0)
		{
			return IsOn();
		}
		return false;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Busy, b: false);
	}

	public override void ResetIOState()
	{
		SetFlag(Flags.On, b: false);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsOn())
		{
			return 0;
		}
		return GetCurrentEnergy();
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		if (inputSlot != 0)
		{
			return currentEnergy;
		}
		return base.CalculateCurrentEnergy(inputAmount, inputSlot);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 1 && inputAmount > 0)
		{
			SetSwitch(wantsOn: true);
		}
		if (inputSlot == 2 && inputAmount > 0)
		{
			SetSwitch(wantsOn: false);
		}
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public void SetSwitch(bool wantsOn)
	{
		if (wantsOn != IsOn())
		{
			SetFlag(Flags.On, wantsOn);
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)Unbusy, 0.5f);
			SendNetworkUpdateImmediate();
			MarkDirty();
			BroadcastValueChange();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	public void ToggleSwitch(RPCMessage msg)
	{
		if (PlayerCanToggle(msg.player))
		{
			SetSwitch(!IsOn());
		}
	}

	public void Unbusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	private static bool PlayerCanToggle(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			return player.CanBuild();
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Network;
using UnityEngine;

public class SnakeHazard : WildlifeHazard
{
	public static Phrase SnakeHazardFailedTipPhrase = new Phrase("toast.snake_hazard_failed", "Jump immediately when a Snake hisses to avoid its attack.");

	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 5f;

	public List<ModifierDefintion> FailModifierEffects;

	private BasePlayer playerToAttack;

	private float slitherRate = 0.05f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SnakeHazard.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	protected override void OnHazardFailed(BasePlayer player)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		base.OnHazardFailed(player);
		if (!((Object)(object)player == (Object)null))
		{
			ClientRPC(RpcTarget.Player("CL_SnakeHazardFailed", player));
			if (GamePhysics.LineOfSight(((Component)this).transform.position + Vector3.up * 0.25f, ((Component)player).transform.position + Vector3.up * 0.25f, 1075904769))
			{
				playerToAttack = player;
				((FacepunchBehaviour)this).Invoke((Action)ApplyAttackToPlayer, 0.3f);
				ClientRPC(RpcTarget.NetworkGroup("CL_Attack"));
			}
		}
	}

	private void ApplyAttackToPlayer()
	{
		if ((Object)(object)playerToAttack == (Object)null)
		{
			return;
		}
		if (!playerToAttack.OnAttacked(Damage, DamageType, this, ignoreShield: false))
		{
			playerToAttack = null;
			return;
		}
		if (FailModifierEffects != null && (Object)(object)playerToAttack.modifiers != (Object)null)
		{
			playerToAttack.modifiers.Add(FailModifierEffects);
		}
		playerToAttack = null;
	}

	public override void StartReposition()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		base.StartReposition();
		if (!base.IsCorpse)
		{
			if (base.isServer)
			{
				ClientRPC(RpcTarget.NetworkGroup("CL_RepositionDisappear"), repositionTo);
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)SlitherTick, 0.2f, slitherRate);
			((FacepunchBehaviour)this).Invoke((Action)StartDelayedTeleport, SlitherDuration + 0.2f);
		}
	}

	private void SlitherTick()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.MoveTowards(((Component)this).transform.position, repositionTo, SlitherSpeed * slitherRate);
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(val + Vector3.up * 1f, Vector3.down, ref val2, 5f, 8388608))
		{
			val = ((RaycastHit)(ref val2)).point;
		}
		((Component)this).transform.position = val;
		try
		{
			syncPosition = true;
			NetworkPositionTick();
		}
		finally
		{
			syncPosition = false;
		}
	}

	private void StartDelayedTeleport()
	{
		if (!base.IsCorpse)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SlitherTick);
			SetFlag(Flags.Disabled, b: true);
			((FacepunchBehaviour)this).Invoke((Action)EndDelayedTeleport, 2f);
		}
	}

	private void EndDelayedTeleport()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Disabled, b: false);
		ServerPosition = repositionTo;
		SendNetworkUpdate_Position();
		if (base.isServer)
		{
			if (PrefabRepositionEffect != null && PrefabRepositionEffect.isValid)
			{
				Effect.server.Run(PrefabReappearEffect.resourcePath, ServerPosition, Vector3.up);
			}
			ClientRPC(RpcTarget.NetworkGroup("CL_RepositionReappear"), repositionLookAtPos);
		}
	}

	protected override bool ShouldStartHazard(BasePlayer player)
	{
		if (!base.ShouldStartHazard(player))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)SlitherTick))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)StartDelayedTeleport))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)EndDelayedTeleport))
		{
			return false;
		}
		return true;
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		CancelSnakeInvokes();
	}

	public override void OnKilled()
	{
		base.OnKilled();
		CancelSnakeInvokes();
	}

	private void CancelSnakeInvokes()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)SlitherTick);
		((FacepunchBehaviour)this).CancelInvoke((Action)StartDelayedTeleport);
		((FacepunchBehaviour)this).CancelInvoke((Action)EndDelayedTeleport);
		((FacepunchBehaviour)this).CancelInvoke((Action)ApplyAttackToPlayer);
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Snowmobile : GroundVehicle, VehicleChassisVisuals<Snowmobile>.IClientWheelUser, IPrefabPreProcess, CarPhysics<Snowmobile>.ICar, TriggerHurtNotChild.IHurtTriggerUser
{
	[Header("Snowmobile")]
	[SerializeField]
	private Transform centreOfMassTransform;

	[SerializeField]
	private GameObjectRef itemStoragePrefab;

	[SerializeField]
	private VisualCarWheel wheelSkiFL;

	[SerializeField]
	private VisualCarWheel wheelSkiFR;

	[SerializeField]
	private VisualCarWheel wheelTreadFL;

	[SerializeField]
	private VisualCarWheel wheelTreadFR;

	[SerializeField]
	private VisualCarWheel wheelTreadRL;

	[SerializeField]
	private VisualCarWheel wheelTreadRR;

	[SerializeField]
	public CarSettings carSettings;

	[SerializeField]
	public int engineKW = 59;

	[SerializeField]
	public float idleFuelPerSec = 0.03f;

	[SerializeField]
	public float maxFuelPerSec = 0.15f;

	[SerializeField]
	public float airControlStability = 10f;

	[SerializeField]
	public float airControlPower = 40f;

	[SerializeField]
	public float badTerrainDrag = 1f;

	[SerializeField]
	public ProtectionProperties riderProtection;

	[SerializeField]
	public float hurtTriggerMinSpeed = 1f;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerFront;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerRear;

	[Header("Snowmobile Visuals")]
	public float minGroundFXSpeed;

	[SerializeField]
	private SnowmobileChassisVisuals chassisVisuals;

	[SerializeField]
	private VehicleLight[] lights;

	[SerializeField]
	private Transform steeringLeftIK;

	[SerializeField]
	private Transform steeringRightIK;

	[SerializeField]
	private Transform leftFootIK;

	[SerializeField]
	private Transform rightFootIK;

	[SerializeField]
	private Transform starterKey;

	[SerializeField]
	private Vector3 engineOffKeyRot;

	[SerializeField]
	private Vector3 engineOnKeyRot;

	[ServerVar(Help = "How long before a snowmobile loses all its health while outside")]
	public static float outsideDecayMinutes = 1440f;

	[ServerVar(Help = "Allow mounting as a passenger when there's no driver")]
	public static bool allowPassengerOnly = false;

	[ServerVar(Help = "If true, snowmobile goes fast on all terrain types")]
	public static bool allTerrain = false;

	private float _throttle;

	private float _brake;

	private float _mass = -1f;

	public const Flags Flag_Slowmode = Flags.Reserved8;

	private EntityRef<StorageContainer> itemStorageInstance;

	private float cachedFuelFraction;

	private const float FORCE_MULTIPLIER = 10f;

	private float _steer;

	public CarPhysics<Snowmobile> carPhysics;

	public VehicleTerrainHandler serverTerrainHandler;

	private CarWheel[] wheels;

	public TimeSince timeSinceLastUsed;

	private const float DECAY_TICK_TIME = 60f;

	public float prevTerrainModDrag;

	public TimeSince timeSinceTerrainModCheck;

	public float ThrottleInput
	{
		get
		{
			if (!engineController.IsOn)
			{
				return 0f;
			}
			return _throttle;
		}
		protected set
		{
			_throttle = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public float BrakeInput
	{
		get
		{
			return _brake;
		}
		protected set
		{
			_brake = Mathf.Clamp(value, 0f, 1f);
		}
	}

	public bool IsBraking => BrakeInput > 0f;

	public float SteerAngle
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.SteerAngle;
			}
			return 0f;
		}
	}

	public override float DriveWheelVelocity
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.DriveWheelVelocity;
			}
			return 0f;
		}
	}

	public float DriveWheelSlip
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.DriveWheelSlip;
			}
			return 0f;
		}
	}

	public float MaxSteerAngle => carSettings.maxSteerAngle;

	public bool InSlowMode
	{
		get
		{
			return HasFlag(Flags.Reserved8);
		}
		private set
		{
			if (InSlowMode != value)
			{
				SetFlag(Flags.Reserved8, value);
			}
		}
	}

	private float Mass
	{
		get
		{
			if (base.isServer)
			{
				return rigidBody.mass;
			}
			return _mass;
		}
	}

	public float SteerInput
	{
		get
		{
			return _steer;
		}
		protected set
		{
			_steer = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public VehicleTerrainHandler.Surface OnSurface
	{
		get
		{
			if (serverTerrainHandler == null)
			{
				return VehicleTerrainHandler.Surface.Default;
			}
			return serverTerrainHandler.OnSurface;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Snowmobile.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 924237371 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenItemStorage "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenItemStorage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(924237371u, "RPC_OpenItemStorage", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_OpenItemStorage(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_OpenItemStorage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.snowmobile != null)
		{
			itemStorageInstance.uid = info.msg.snowmobile.storageID;
			engineController.FuelSystem.SetInstanceID(info.msg.snowmobile.fuelStorageID);
			cachedFuelFraction = info.msg.snowmobile.fuelFraction;
		}
	}

	public float GetMaxDriveForce()
	{
		return (float)engineKW * 10f * GetPerformanceFraction();
	}

	public override float GetMaxForwardSpeed()
	{
		return GetMaxDriveForce() / Mass * 15f;
	}

	public override float GetThrottleInput()
	{
		return ThrottleInput;
	}

	public override float GetBrakeInput()
	{
		return BrakeInput;
	}

	public bool GetSteerSpeedMod(float speed)
	{
		return false;
	}

	public virtual float GetSteerMaxMult(float speed)
	{
		return 1f;
	}

	public float GetPerformanceFraction()
	{
		float num = Mathf.InverseLerp(0.25f, 0.5f, base.healthFraction);
		return Mathf.Lerp(0.5f, 1f, num);
	}

	public float GetFuelFraction()
	{
		if (base.isServer)
		{
			return engineController.FuelSystem.GetFuelFraction();
		}
		return cachedFuelFraction;
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		if (!PlayerIsMounted(player))
		{
			return !IsOn();
		}
		return true;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && GameInfo.HasAchievements && !old.HasFlag(Flags.On) && next.HasFlag(Flags.On))
		{
			BasePlayer driver = GetDriver();
			if ((Object)(object)driver != (Object)null && (Object)(object)driver.FindTrigger<TriggerSnowmobileAchievement>() != (Object)null)
			{
				driver.GiveAchievement("DRIVE_SNOWMOBILE");
			}
		}
	}

	private bool CanPlayerSeeMountPoint(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (!GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position, 0.25f, 2162688, (QueryTriggerInteraction)0))
		{
			return !GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position + Vector3.up * 0.5f, 0.25f, 2162688, (QueryTriggerInteraction)0);
		}
		return false;
	}

	public float GetSteerInput()
	{
		return SteerInput;
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		rigidBody.centerOfMass = centreOfMassTransform.localPosition;
		rigidBody.inertiaTensor = new Vector3(450f, 200f, 200f);
		carPhysics = new CarPhysics<Snowmobile>(this, ((Component)this).transform, rigidBody, carSettings);
		serverTerrainHandler = new VehicleTerrainHandler(this);
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.15f, 0.02f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)SnowmobileDecay, Random.Range(30f, 60f), 60f, 6f);
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Snowmobile.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			float speed = GetSpeed();
			carPhysics.FixedUpdate(Time.fixedDeltaTime, speed);
			serverTerrainHandler.FixedUpdate();
			if (IsOn())
			{
				float fuelPerSecond = Mathf.Lerp(idleFuelPerSec, maxFuelPerSec, Mathf.Abs(ThrottleInput));
				engineController.TickFuel(fuelPerSecond);
			}
			engineController.CheckEngineState();
			RaycastHit val2 = default(RaycastHit);
			if (!carPhysics.IsGrounded() && Physics.Raycast(((Component)this).transform.position, Vector3.down, ref val2, 10f, 1218511105, (QueryTriggerInteraction)1))
			{
				Vector3 normal = ((RaycastHit)(ref val2)).normal;
				Vector3 right = ((Component)this).transform.right;
				right.y = 0f;
				normal = Vector3.ProjectOnPlane(normal, right);
				float num = Vector3.Angle(normal, Vector3.up);
				Vector3 angularVelocity = rigidBody.angularVelocity;
				float num2 = ((Vector3)(ref angularVelocity)).magnitude * 57.29578f * airControlStability / airControlPower;
				if (num <= 45f)
				{
					Vector3 val3 = Vector3.Cross(Quaternion.AngleAxis(num2, rigidBody.angularVelocity) * ((Component)this).transform.up, normal) * airControlPower * airControlPower;
					rigidBody.AddTorque(val3);
				}
			}
			((Component)hurtTriggerFront).gameObject.SetActive(speed > hurtTriggerMinSpeed);
			((Component)hurtTriggerRear).gameObject.SetActive(speed < 0f - hurtTriggerMinSpeed);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!IsDriver(player))
		{
			return;
		}
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		if (inputState.IsDown(BUTTON.FIRE_THIRD))
		{
			SteerInput += inputState.MouseDelta().x * 0.1f;
		}
		else
		{
			SteerInput = 0f;
			if (inputState.IsDown(BUTTON.LEFT))
			{
				SteerInput = -1f;
			}
			else if (inputState.IsDown(BUTTON.RIGHT))
			{
				SteerInput = 1f;
			}
		}
		float num = 0f;
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			num = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			num = -1f;
		}
		ThrottleInput = 0f;
		BrakeInput = 0f;
		if (GetSpeed() > 3f && num < -0.1f)
		{
			ThrottleInput = 0f;
			BrakeInput = 0f - num;
		}
		else
		{
			ThrottleInput = num;
			BrakeInput = 0f;
		}
		if (engineController.IsOff && ((inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD)) || (inputState.IsDown(BUTTON.BACKWARD) && !inputState.WasDown(BUTTON.BACKWARD))))
		{
			engineController.TryStartEngine(player);
		}
	}

	public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		float maxDriveForce = GetMaxDriveForce();
		float num = Mathf.Lerp(0.3f, 0.75f, GetPerformanceFraction());
		float num2 = MathEx.BiasedLerp(1f - absSpeed / topSpeed, num);
		return maxDriveForce * num2;
	}

	public override float GetModifiedDrag()
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		float num = base.GetModifiedDrag();
		if (!allTerrain)
		{
			VehicleTerrainHandler.Surface onSurface = serverTerrainHandler.OnSurface;
			if (serverTerrainHandler.IsGrounded && onSurface != VehicleTerrainHandler.Surface.Frictionless && onSurface != VehicleTerrainHandler.Surface.Sand && onSurface != VehicleTerrainHandler.Surface.Snow && onSurface != VehicleTerrainHandler.Surface.Ice)
			{
				float num2 = Mathf.Max(num, badTerrainDrag);
				num = (prevTerrainModDrag = ((!(num2 <= prevTerrainModDrag)) ? Mathf.MoveTowards(prevTerrainModDrag, num2, 0.33f * TimeSince.op_Implicit(timeSinceTerrainModCheck)) : prevTerrainModDrag));
			}
			else
			{
				prevTerrainModDrag = 0f;
			}
		}
		timeSinceTerrainModCheck = TimeSince.op_Implicit(0f);
		InSlowMode = num >= badTerrainDrag;
		return num;
	}

	public override float AntiHackVelocity()
	{
		return Mathf.Max(GetMaxForwardSpeed() * 1.3f, 30f);
	}

	public CarWheel[] GetWheels()
	{
		if (wheels == null)
		{
			wheels = new CarWheel[6] { wheelSkiFL, wheelSkiFR, wheelTreadFL, wheelTreadFR, wheelTreadRL, wheelTreadRR };
		}
		return wheels;
	}

	public float GetWheelsMidPos()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		return (((Component)wheelSkiFL.wheelCollider).transform.localPosition.z - ((Component)wheelTreadRL.wheelCollider).transform.localPosition.z) * 0.5f;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.snowmobile = Pool.Get<Snowmobile>();
		info.msg.snowmobile.steerInput = SteerInput;
		info.msg.snowmobile.driveWheelVel = DriveWheelVelocity;
		info.msg.snowmobile.throttleInput = ThrottleInput;
		info.msg.snowmobile.brakeInput = BrakeInput;
		info.msg.snowmobile.storageID = itemStorageInstance.uid;
		info.msg.snowmobile.fuelStorageID = GetFuelSystem().GetInstanceID();
		info.msg.snowmobile.fuelFraction = GetFuelFraction();
	}

	public override int StartingFuelUnits()
	{
		return 0;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned && child.prefabID == itemStoragePrefab.GetEntity().prefabID)
		{
			itemStorageInstance.Set((StorageContainer)child);
		}
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			StorageContainer storageContainer = itemStorageInstance.Get(base.isServer);
			if ((Object)(object)storageContainer != (Object)null && storageContainer.IsValid())
			{
				storageContainer.DropItems();
			}
		}
		base.DoServerDestroy();
	}

	public override bool MeetsEngineRequirements()
	{
		return HasDriver();
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (allowPassengerOnly)
		{
			base.AttemptMount(player, doMountChecks);
		}
		else if (MountEligable(player) && CanPlayerSeeMountPoint(player))
		{
			BaseMountable baseMountable = ((HasDriver() || player.IsRestrained) ? GetIdealMountPointFor(player) : mountPoints[0].mountable);
			if ((Object)(object)baseMountable != (Object)null)
			{
				baseMountable.AttemptMount(player, doMountChecks);
			}
			if (PlayerIsMounted(player))
			{
				PlayerMounted(player, baseMountable);
			}
		}
	}

	public void SnowmobileDecay()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if (!IsDead() && !(TimeSince.op_Implicit(timeSinceLastUsed) < 2700f))
		{
			float num = (IsOutside() ? outsideDecayMinutes : float.PositiveInfinity);
			if (!float.IsPositiveInfinity(num))
			{
				float num2 = 1f / num;
				Hurt(MaxHealth() * num2, DamageType.Decay, this, useProtection: false);
			}
		}
	}

	public StorageContainer GetItemContainer()
	{
		BaseEntity baseEntity = itemStorageInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	private void UpdateClients()
	{
		if (HasDriver())
		{
			byte num = (byte)((ThrottleInput + 1f) * 7f);
			byte b = (byte)(BrakeInput * 15f);
			byte arg = (byte)(num + (b << 4));
			ClientRPC(RpcTarget.NetworkGroup("SnowmobileUpdate"), SteerInput, arg, DriveWheelVelocity, GetFuelFraction());
		}
	}

	public override void OnEngineStartFailed()
	{
		ClientRPC(RpcTarget.NetworkGroup("EngineStartFailed"));
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		riderProtection.Scale(info.damageTypes);
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player) && IsDriver(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_OpenItemStorage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player))
		{
			StorageContainer itemContainer = GetItemContainer();
			if ((Object)(object)itemContainer != (Object)null)
			{
				itemContainer.PlayerOpenLoot(player);
			}
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SpinnerWheel : Signage
{
	public Transform wheel;

	public float velocity;

	public Quaternion targetRotation = Quaternion.identity;

	[Header("Sound")]
	public SoundDefinition spinLoopSoundDef;

	public SoundDefinition spinStartSoundDef;

	public SoundDefinition spinAccentSoundDef;

	public SoundDefinition spinStopSoundDef;

	public float minTimeBetweenSpinAccentSounds = 0.3f;

	public float spinAccentAngleDelta = 180f;

	private Sound spinSound;

	private SoundModulation.Modulator spinSoundGain;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SpinnerWheel.OnRpcMessage", 0);
		try
		{
			if (rpc == 3019675107u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_AnyoneSpin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_AnyoneSpin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3019675107u, "RPC_AnyoneSpin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_AnyoneSpin(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_AnyoneSpin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1455840454 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Spin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Spin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1455840454u, "RPC_Spin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_Spin(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Spin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual bool AllowPlayerSpins()
	{
		return true;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.spinnerWheel = Pool.Get<SpinnerWheel>();
		SpinnerWheel spinnerWheel = info.msg.spinnerWheel;
		Quaternion localRotation = wheel.localRotation;
		spinnerWheel.spin = ((Quaternion)(ref localRotation)).eulerAngles;
	}

	public override void Load(LoadInfo info)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.spinnerWheel != null)
		{
			Quaternion localRotation = Quaternion.Euler(info.msg.spinnerWheel.spin);
			if (base.isServer && info.fromDisk)
			{
				localRotation = Quaternion.identity;
			}
			if (base.isServer)
			{
				((Component)wheel).transform.localRotation = localRotation;
			}
		}
	}

	public virtual float GetMaxSpinSpeed()
	{
		return 720f;
	}

	public virtual void Update_Server()
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (velocity > 0f)
		{
			float num = Mathf.Clamp(GetMaxSpinSpeed() * velocity, 0f, GetMaxSpinSpeed());
			velocity -= Time.deltaTime * Mathf.Clamp(velocity / 2f, 0.1f, 1f);
			if (velocity < 0f)
			{
				velocity = 0f;
				ToggleChildEntityColliders(state: true);
			}
			wheel.Rotate(Vector3.up, num * Time.deltaTime, (Space)1);
			SendNetworkUpdate();
		}
	}

	public void Update_Client()
	{
	}

	public void Update()
	{
		if (base.isClient)
		{
			Update_Client();
		}
		if (base.isServer)
		{
			Update_Server();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Spin(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && AllowPlayerSpins() && (AnyoneSpin() || rpc.player.CanBuild()) && Interface.CallHook("OnSpinWheel", (object)rpc.player, (object)this) == null && !(velocity > 15f))
		{
			velocity += Random.Range(4f, 7f);
			ToggleChildEntityColliders(state: false);
		}
	}

	private void ToggleChildEntityColliders(bool state)
	{
		foreach (BaseEntity child in children)
		{
			if (child is DroppedItem droppedItem && (Object)(object)droppedItem.childCollider != (Object)null)
			{
				droppedItem.childCollider.enabled = state;
			}
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_AnyoneSpin(RPCMessage rpc)
	{
		if (rpc.player.CanInteract())
		{
			SetFlag(Flags.Reserved3, rpc.read.Bit());
		}
	}

	public bool AnyoneSpin()
	{
		return HasFlag(Flags.Reserved3);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SpinUpWeapon : BaseProjectile, ITurretNotify
{
	public float timeBetweenSpinToggle = 1f;

	public float spinUpTime = 1f;

	public GameObjectRef bulletEffect;

	public float projectileThicknessOverride = 0.5f;

	public bool showSpinProgress = true;

	public float spinningMoveSpeedScale = 0.7f;

	public float conditionLossPerSecondSpinning = 1f;

	public ItemModWearable BackpackWearable;

	public const Flags FullySpunFlag = Flags.Reserved10;

	public const Flags SpinningFlag = Flags.Reserved11;

	public const Flags ShootingFlag = Flags.Reserved12;

	private const float bulletSpeed = 375f;

	private float lastSpinToggleTime = float.NegativeInfinity;

	public override ItemModWearable WearableWhileEquipped
	{
		get
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null && ownerPlayer.inventory.HasBackpackItem())
			{
				return null;
			}
			return BackpackWearable;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SpinUpWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 2014484270 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetSpinButton "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetSpinButton", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2014484270u, "Server_SetSpinButton", this, player, 8uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(2014484270u, "Server_SetSpinButton", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_SetSpinButton(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_SetSpinButton");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float GetOverrideProjectileThickness(Projectile projectile)
	{
		return projectileThicknessOverride;
	}

	public bool IsSpinning()
	{
		return HasFlag(Flags.Reserved11);
	}

	public bool IsFullySpun()
	{
		return HasFlag(Flags.Reserved10);
	}

	public override void ServerReload()
	{
		SetFlag(Flags.Reserved12, b: false);
		base.ServerReload();
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		if (!ServerIsReloading())
		{
			SetFlag(Flags.Reserved12, b: true);
			((FacepunchBehaviour)this).Invoke((Action)StopMainTrigger, repeatDelay * 1.1f);
		}
		base.ServerUse(damageModifier, speedModifier, originOverride, useBulletThickness);
	}

	public override void SetGenericVisible(bool visible)
	{
		base.SetGenericVisible(visible);
		SetFlag(Flags.Reserved11, visible);
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null && ownerPlayer.IsNpc)
		{
			SetFlag(Flags.Reserved11, !IsDisabled());
		}
		else
		{
			SetFlag(Flags.Reserved11, b: false);
			SetFlag(Flags.Reserved10, b: false);
			lastSpinToggleTime = float.NegativeInfinity;
		}
		if (IsDisabled())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateConditionLoss);
			((FacepunchBehaviour)this).CancelInvoke((Action)SetFullySpun);
		}
		else
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateConditionLoss, 0f, 1f);
		}
	}

	public void UpdateConditionLoss()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!((Object)(object)ownerPlayer == (Object)null) && !ownerPlayer.IsNpc && IsSpinning())
		{
			GetOwnerItem()?.LoseCondition(conditionLossPerSecondSpinning);
		}
	}

	public void FireFakeBulletServer(float aimconeToUse)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		bool flag = (Object)(object)ownerPlayer != (Object)null;
		Vector3 val = (flag ? ownerPlayer.eyes.BodyForward() : MuzzlePoint.forward);
		Vector3 val2 = (flag ? ownerPlayer.eyes.position : MuzzlePoint.position);
		Vector3 inputVec = val;
		inputVec = AimConeUtil.GetModifiedAimConeDirection(aimconeToUse, inputVec);
		List<Connection> list = Pool.Get<List<Connection>>();
		foreach (Connection subscriber in net.group.subscribers)
		{
			BasePlayer basePlayer = subscriber.player as BasePlayer;
			if (!((Object)(object)basePlayer == (Object)null) && !ShouldNetworkTo(basePlayer))
			{
				list.Add(subscriber);
			}
		}
		if (list.Count > 0)
		{
			CreateProjectileEffectClientside(bulletEffect.resourcePath, val2 + inputVec * 2f, inputVec * 375f, 0, flag ? ownerPlayer.net.connection : null, IsSilenced(), forceClientsideEffects: true, list);
		}
		Pool.FreeUnmanaged<Connection>(ref list);
	}

	public void StopMainTrigger()
	{
		SetFlag(Flags.Reserved12, b: false);
	}

	public override void DidAttackServerside()
	{
		base.DidAttackServerside();
		SetFlag(Flags.Reserved12, b: true);
		((FacepunchBehaviour)this).Invoke((Action)StopMainTrigger, repeatDelay * 1.1f);
		if (ServerOcclusion.OcclusionEnabled)
		{
			DoFakeBullets();
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(8uL)]
	[RPC_Server]
	private void Server_SetSpinButton(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (!(Time.realtimeSinceStartup < lastSpinToggleTime + 1f))
		{
			SetFlag(Flags.Reserved11, flag);
			((FacepunchBehaviour)this).CancelInvoke((Action)SetFullySpun);
			if (flag)
			{
				((FacepunchBehaviour)this).Invoke((Action)SetFullySpun, spinUpTime);
			}
			else
			{
				SetFlag(Flags.Reserved10, b: false);
			}
			lastSpinToggleTime = Time.realtimeSinceStartup;
		}
	}

	public void SetFullySpun()
	{
		SetFlag(Flags.Reserved10, b: true);
	}

	public void WarmupTick(bool wantsShoot)
	{
		if (wantsShoot)
		{
			SetFlag(Flags.Reserved11, b: true);
			if (!((FacepunchBehaviour)this).IsInvoking((Action)SetFullySpun))
			{
				((FacepunchBehaviour)this).Invoke((Action)SetFullySpun, spinUpTime);
			}
			lastSpinToggleTime = Time.realtimeSinceStartup;
		}
		else if (Time.realtimeSinceStartup > lastSpinToggleTime + 10f)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SetFullySpun);
			SetFlag(Flags.Reserved11, b: false);
			SetFlag(Flags.Reserved10, b: false);
		}
	}

	public bool CanShoot()
	{
		return IsFullySpun();
	}

	public void OnAddedRemovedToTurret(bool added)
	{
		SetFlag(Flags.Reserved11, b: false);
		SetFlag(Flags.Reserved10, b: false);
		if (added)
		{
			lastSpinToggleTime = float.NegativeInfinity;
			return;
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)UpdateConditionLoss);
		((FacepunchBehaviour)this).CancelInvoke((Action)SetFullySpun);
	}

	private void DoFakeBullets()
	{
		float num = repeatDelay / 4f;
		if (!((FacepunchBehaviour)this).IsInvoking((Action)FakeBullet1))
		{
			((FacepunchBehaviour)this).Invoke((Action)FakeBullet1, num);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)FakeBullet2))
		{
			((FacepunchBehaviour)this).Invoke((Action)FakeBullet2, num * 2f);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)FakeBullet3))
		{
			((FacepunchBehaviour)this).Invoke((Action)FakeBullet3, num * 3f);
		}
	}

	private void FakeBullet()
	{
		if (base.isServer)
		{
			FireFakeBulletServer(aimCone * 3f);
		}
	}

	private void FakeBullet1()
	{
		FakeBullet();
	}

	private void FakeBullet2()
	{
		FakeBullet();
	}

	private void FakeBullet3()
	{
		FakeBullet();
	}

	private void CancelFakeBullets()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)FakeBullet1);
		((FacepunchBehaviour)this).CancelInvoke((Action)FakeBullet2);
		((FacepunchBehaviour)this).CancelInvoke((Action)FakeBullet3);
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SpookySpeaker : IOEntity
{
	public SoundPlayer soundPlayer;

	public float soundSpacing = 12f;

	public float soundSpacingRand = 5f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SpookySpeaker.OnRpcMessage", 0);
		try
		{
			if (rpc == 2523893445u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetWantsOn "));
				}
				TimeWarning val2 = TimeWarning.New("SetWantsOn", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2523893445u, "SetWantsOn", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage wantsOn = rPCMessage;
							SetWantsOn(wantsOn);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetWantsOn");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		UpdateInvokes();
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputSlot == 1)
		{
			SetTargetState(state: false);
		}
		if (inputSlot == 0)
		{
			SetTargetState(state: true);
		}
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	private void SetTargetState(bool state)
	{
		SetFlag(Flags.On, state);
		UpdateInvokes();
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SetWantsOn(RPCMessage msg)
	{
		bool targetState = msg.read.Bit();
		SetTargetState(targetState);
	}

	public void UpdateInvokes()
	{
		if (IsOn())
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)SendPlaySound, soundSpacing, soundSpacing, soundSpacingRand);
			((FacepunchBehaviour)this).Invoke((Action)DelayedOff, 7200f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SendPlaySound);
			((FacepunchBehaviour)this).CancelInvoke((Action)DelayedOff);
		}
	}

	public void SendPlaySound()
	{
		ClientRPC(RpcTarget.NetworkGroup("PlaySpookySound"));
	}

	public void DelayedOff()
	{
		SetFlag(Flags.On, b: false);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class SprayCan : HeldEntity
{
	private enum SprayFailReason
	{
		None,
		MountedBlocked,
		IOConnection,
		LineOfSight,
		SkinNotOwned,
		InvalidItem
	}

	private struct ContainerSet
	{
		public int ContainerIndex;

		public uint PrefabId;
	}

	public struct IOPreserveInfo
	{
		public IOEntity connectedTo;

		public int connectedToSlot;

		public Vector3[] linePoints;

		public float[] slackLevels;

		public IOEntity.LineAnchor[] lineAnchors;

		public Vector3 worldSpaceLineEndRotation;

		public Vector3 originPosition;

		public Vector3 originRotation;

		public WireTool.WireColour wireColour;
	}

	private struct CodeLockPreserveInfo
	{
		public string code;

		public string guestCode;

		public bool isLocked;

		public List<ulong> whitelistPlayers;

		public List<ulong> guestPlayers;
	}

	private struct OtherEntityPreserveInfo
	{
		public IOPreserveInfo info;

		public IOEntity connectedEntity;

		public int index;

		public bool isOutput;
	}

	public struct ChildPreserveInfo
	{
		public BaseEntity TargetEntity;

		public uint TargetBone;

		public Vector3 LocalPosition;

		public Quaternion LocalRotation;
	}

	public const float MaxFreeSprayDistanceFromStart = 10f;

	public const float MaxFreeSprayStartingDistance = 3f;

	private SprayCanSpray_Freehand paintingLine;

	public const Flags IsFreeSpraying = Flags.Reserved1;

	public SoundDefinition SpraySound;

	public GameObjectRef SkinSelectPanel;

	public float SprayCooldown = 2f;

	public float ConditionLossPerSpray = 10f;

	public float ConditionLossPerReskin = 10f;

	public GameObjectRef LinePrefab;

	public Color[] SprayColours = (Color[])(object)new Color[0];

	public float[] SprayWidths = new float[3] { 0.1f, 0.2f, 0.3f };

	public ParticleSystem worldSpaceSprayFx;

	public GameObjectRef ReskinEffect;

	public ItemDefinition SprayDecalItem;

	public GameObjectRef SprayDecalEntityRef;

	public SteamInventoryItem FreeSprayUnlockItem;

	public MinMaxGradient DecalSprayGradient;

	public SoundDefinition SprayLoopDef;

	public static Phrase FreeSprayNamePhrase = new Phrase("freespray_radial", "Free Spray");

	public static Phrase FreeSprayDescPhrase = new Phrase("freespray_radial_desc", "Spray shapes freely with various colors");

	public static Phrase BuildingSkinColourPhrase = new Phrase("buildingskin_colour", "Set colour");

	public static Phrase BuildingSkinColourDescPhrase = new Phrase("buildingskin_colour_desc", "Set the block to the highlighted colour");

	public static readonly Phrase DoorMustBeClosed = new Phrase("error_doormustbeclosed", "Door must be closed");

	public static readonly Phrase NeedDoorAccess = new Phrase("error_needdooraccess", "Need door access");

	public static readonly Phrase CannotReskinThatDoor = new Phrase("error_cannotreskindoor", "Cannot reskin that door");

	public static readonly Phrase RecentlyDamaged = new Phrase("error_reskin_recentlydamaged", "Cannot reskin an object that was recently damaged");

	public static readonly Phrase ExplosivesActive = new Phrase("error_explosivesactive", "Cannot reskin an object with explosives attached");

	public static readonly Phrase PlayerInAir = new Phrase("error_playerinair", "You must be on the ground");

	public static readonly Phrase BlockedByPlayer = new Phrase("error_blockedbyplayer_reskin", "Blocked by intersecting player");

	public static readonly Phrase BlockedBySomething = new Phrase("error_blockedbysomething", "Blocked by something");

	public static readonly Phrase PlayerIsMounted = new Phrase("error_playerismounted", "Player {0} is mounted");

	[FormerlySerializedAs("ShippingCOntainerColourLookup")]
	public ConstructionSkin_ColourLookup ShippingContainerColourLookup;

	public const string ENEMY_BASE_STAT = "sprayed_enemy_base";

	private Phrase lastSprayError;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0455: Unknown result type (might be due to invalid IL or missing references)
		//IL_046f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0489: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SprayCan.OnRpcMessage", 0);
		try
		{
			if (rpc == 3490735573u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BeginFreehandSpray "));
				}
				TimeWarning val2 = TimeWarning.New("BeginFreehandSpray", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						long position = ((Stream)(object)msg.read).Position;
						if (!RPC_Server.InputValidation.Test(msg.read.Read<Vector3>()))
						{
							return true;
						}
						if (!RPC_Server.InputValidation.Test(msg.read.Read<Vector3>()))
						{
							return true;
						}
						msg.read.Read<int>();
						msg.read.Read<int>();
						((Stream)(object)msg.read).Position = position;
						if (!RPC_Server.IsActiveItem.Test(3490735573u, "BeginFreehandSpray", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							BeginFreehandSpray(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BeginFreehandSpray");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 151738090 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ChangeItemSkin "));
				}
				TimeWarning val2 = TimeWarning.New("ChangeItemSkin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(151738090u, "ChangeItemSkin", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(151738090u, "ChangeItemSkin", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ChangeItemSkin(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ChangeItemSkin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 688080035 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ChangeWallpaper "));
				}
				TimeWarning val2 = TimeWarning.New("ChangeWallpaper", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(688080035u, "ChangeWallpaper", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(688080035u, "ChangeWallpaper", this, player))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(688080035u, "ChangeWallpaper", this, player, 5f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							ChangeWallpaper(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in ChangeWallpaper");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 396000799 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CreateSpray "));
				}
				TimeWarning val2 = TimeWarning.New("CreateSpray", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						long position2 = ((Stream)(object)msg.read).Position;
						if (!RPC_Server.InputValidation.Test(msg.read.Read<Vector3>()))
						{
							return true;
						}
						if (!RPC_Server.InputValidation.Test(msg.read.Read<Vector3>()))
						{
							return true;
						}
						if (!RPC_Server.InputValidation.Test(msg.read.Read<Vector3>()))
						{
							return true;
						}
						msg.read.Read<int>();
						((Stream)(object)msg.read).Position = position2;
						if (!RPC_Server.IsActiveItem.Test(396000799u, "CreateSpray", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							CreateSpray(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in CreateSpray");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 14517645 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetBlockColourId "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetBlockColourId", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(14517645u, "Server_SetBlockColourId", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(14517645u, "Server_SetBlockColourId", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							Server_SetBlockColourId(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in Server_SetBlockColourId");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.InputValidation(new Type[]
	{
		typeof(Vector3),
		typeof(Vector3),
		typeof(int),
		typeof(int)
	})]
	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void BeginFreehandSpray(RPCMessage msg)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		if (!IsBusy() && CanSprayFreehand(msg.player))
		{
			Vector3 val = msg.read.Vector3();
			Vector3 atNormal = msg.read.Vector3();
			int num = msg.read.Int32();
			int num2 = msg.read.Int32();
			if (num >= 0 && num < SprayColours.Length && num2 >= 0 && num2 < SprayWidths.Length && !(Vector3.Distance(val, ((Component)GetOwnerPlayer()).transform.position) > 3f))
			{
				SprayCanSpray_Freehand sprayCanSpray_Freehand = GameManager.server.CreateEntity(LinePrefab.resourcePath, val, Quaternion.identity) as SprayCanSpray_Freehand;
				sprayCanSpray_Freehand.AddInitialPoint(atNormal);
				sprayCanSpray_Freehand.SetColour(SprayColours[num]);
				sprayCanSpray_Freehand.SetWidth(SprayWidths[num2]);
				sprayCanSpray_Freehand.EnableChanges(msg.player);
				sprayCanSpray_Freehand.Spawn();
				paintingLine = sprayCanSpray_Freehand;
				ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), num);
				SetFlag(Flags.Busy, b: true);
				SetFlag(Flags.Reserved1, b: true);
				CheckAchievementPosition(val);
			}
		}
	}

	public void ClearPaintingLine(bool allowNewSprayImmediately)
	{
		paintingLine = null;
		if (!base.UsingInfiniteAmmoCheat)
		{
			LoseCondition(ConditionLossPerSpray);
		}
		if (allowNewSprayImmediately)
		{
			ClearBusy();
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)ClearBusy, 0.1f);
		}
	}

	public bool CanSprayFreehand(BasePlayer player)
	{
		if (!player.DefaultSkinAccess)
		{
			return player.AllSkinsUnlocked;
		}
		if ((Object)(object)FreeSprayUnlockItem != (Object)null)
		{
			if (!player.blueprints.steamInventory.HasItem(FreeSprayUnlockItem.id))
			{
				return FreeSprayUnlockItem.HasUnlocked(player.userID);
			}
			return true;
		}
		return false;
	}

	private bool IsSprayBlockedByTrigger(Vector3 pos)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return true;
		}
		TriggerNoSpray triggerNoSpray = ownerPlayer.FindTrigger<TriggerNoSpray>();
		if ((Object)(object)triggerNoSpray == (Object)null)
		{
			return false;
		}
		return !triggerNoSpray.IsPositionValid(pos);
	}

	private bool ValidateEntityAndSkin(BasePlayer player, BaseNetworkable targetEnt, int targetSkin)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		if (IsBusy())
		{
			return false;
		}
		if ((Object)(object)player == (Object)null || !player.CanBuild())
		{
			return false;
		}
		if (!player.IsOnGround())
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInAir, false);
			return false;
		}
		if (player.AllSkinsLocked)
		{
			return false;
		}
		bool allSkinsUnlocked = player.AllSkinsUnlocked;
		if (targetSkin != 0 && !allSkinsUnlocked && !player.blueprints.CheckSkinOwnership(targetSkin, player.userID))
		{
			SprayFailResponse(SprayFailReason.SkinNotOwned);
			return false;
		}
		if ((Object)(object)targetEnt != (Object)null && targetEnt is BaseEntity baseEntity)
		{
			OBB val = baseEntity.WorldSpaceBounds();
			Vector3 position = ((OBB)(ref val)).ClosestPoint(player.eyes.position);
			if (!player.IsVisible(position, 3f))
			{
				SprayFailResponse(SprayFailReason.LineOfSight);
				return false;
			}
			if (targetEnt is Door door)
			{
				if (!door.GetPlayerLockPermission(player))
				{
					player.ShowToast(GameTip.Styles.Error, NeedDoorAccess, false);
					return false;
				}
				if (door.IsOpen())
				{
					player.ShowToast(GameTip.Styles.Error, DoorMustBeClosed, false);
					return false;
				}
				if ((Object)(object)door.GetParentEntity() != (Object)null && door.GetParentEntity() is HotAirBalloonArmor)
				{
					player.ShowToast(GameTip.Styles.Error, CannotReskinThatDoor, false);
					return false;
				}
			}
			if (targetEnt is BaseCombatEntity { SecondsSinceAttacked: <30f } baseCombatEntity)
			{
				player.ShowToast(GameTip.Styles.Error, RecentlyDamaged, false, (30f - baseCombatEntity.SecondsSinceAttacked).ToString("N0"));
				return false;
			}
			foreach (BaseEntity child in targetEnt.children)
			{
				if (child is TimedExplosive)
				{
					player.ShowToast(GameTip.Styles.Error, ExplosivesActive, false);
					return false;
				}
			}
			if (targetEnt is SimpleBuildingBlock || targetEnt is Gate)
			{
				PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					Vis.Entities(baseEntity.WorldSpaceBounds(), (List<BaseEntity>)(object)val2, -2145386240, (QueryTriggerInteraction)2);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
					{
						if (!((Object)(object)item == (Object)null) && !item.isClient && !((Object)(object)item == (Object)(object)baseEntity) && !(item is BuildingBlock) && !(item is SimpleBuildingBlock) && !(item is Door) && !(item is BaseOven) && !(item is Barricade))
						{
							player.ShowBlockedByEntityToast(item, BlockedBySomething);
							return false;
						}
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
		}
		if ((Object)(object)targetEnt != (Object)null && targetEnt is BaseLock baseLock)
		{
			return baseLock.GetPlayerLockPermission(player);
		}
		return true;
	}

	private bool ValidateWallpaperReskin(BasePlayer player, BuildingBlock block, int side, int targetSkin)
	{
		if ((Object)(object)player == (Object)null || !player.CanBuild())
		{
			return false;
		}
		if (!player.IsOnGround())
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInAir, false);
			return false;
		}
		if (player.AllSkinsLocked)
		{
			return false;
		}
		bool allSkinsUnlocked = player.AllSkinsUnlocked;
		if (targetSkin != 0 && !allSkinsUnlocked && !player.blueprints.CheckSkinOwnership(targetSkin, player.userID))
		{
			SprayFailResponse(SprayFailReason.SkinNotOwned);
			return false;
		}
		if (!block.HasWallpaper(side))
		{
			return false;
		}
		if (!block.CanSeeWallpaperSocket(player, side))
		{
			return false;
		}
		return true;
	}

	private void SprayFailResponse(SprayFailReason reason)
	{
		ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 0, (int)reason);
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	private void ChangeItemSkin(RPCMessage msg)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b70: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_044a: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		//IL_045d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0462: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0696: Unknown result type (might be due to invalid IL or missing references)
		//IL_06bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0abe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ad6: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId uid = msg.read.EntityID();
		int targetSkin = msg.read.Int32();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		if (!ValidateEntityAndSkin(msg.player, baseNetworkable, targetSkin))
		{
			return;
		}
		if ((Object)(object)baseNetworkable != (Object)null)
		{
			BaseEntity baseEntity2 = baseNetworkable as BaseEntity;
			if (baseEntity2 != null)
			{
				if (!GetItemDefinitionForEntity(baseEntity2, out var def, useRedirect: false))
				{
					FailResponse(SprayFailReason.InvalidItem);
					return;
				}
				ItemDefinition itemDefinition = null;
				ulong num = ItemDefinition.FindSkin(((Object)(object)def.isRedirectOf != (Object)null) ? def.isRedirectOf.itemid : def.itemid, targetSkin);
				ItemSkinDirectory.Skin skin = (((Object)(object)def.isRedirectOf != (Object)null) ? def.isRedirectOf : def).skins.FirstOrDefault((ItemSkinDirectory.Skin x) => x.id == targetSkin);
				if (Interface.CallHook("OnEntityReskin", (object)baseEntity2, (object)skin, (object)msg.player) != null)
				{
					return;
				}
				if ((Object)(object)skin.invItem != (Object)null && skin.invItem is ItemSkin itemSkin)
				{
					if ((Object)(object)itemSkin.Redirect != (Object)null)
					{
						itemDefinition = itemSkin.Redirect;
					}
					else if (Object.op_Implicit((Object)(object)def) && (Object)(object)def.isRedirectOf != (Object)null)
					{
						itemDefinition = def.isRedirectOf;
					}
				}
				else if ((Object)(object)def.isRedirectOf != (Object)null || (Object.op_Implicit((Object)(object)def) && (Object)(object)def.isRedirectOf != (Object)null))
				{
					itemDefinition = def.isRedirectOf;
				}
				if ((Object)(object)itemDefinition == (Object)null)
				{
					baseEntity2.skinID = num;
					baseEntity2.SendNetworkUpdate();
					Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);
				}
				else
				{
					if (!CanEntityBeRespawned(baseEntity2, out var reason2, out var culpritPlayer))
					{
						if (reason2 == SprayFailReason.MountedBlocked)
						{
							lastSprayError = Phrase.op_Implicit(string.Format(PlayerIsMounted.translated, NameHelper.GetPlayerNameStreamSafe(msg.player, culpritPlayer)));
							msg.player.ShowToast(GameTip.Styles.Error, lastSprayError, false);
						}
						FailResponse(reason2);
						return;
					}
					if (!GetEntityPrefabPath(itemDefinition, out var resourcePath))
					{
						Debug.LogWarning((object)("Cannot find resource path of redirect entity to spawn! " + ((Object)((Component)itemDefinition).gameObject).name));
						FailResponse(SprayFailReason.InvalidItem);
						return;
					}
					if (SimpleUpgrade.IsUpgradeBlocked(baseEntity2, itemDefinition, msg.player))
					{
						if ((Object)(object)DeployVolume.LastDeployHit != (Object)null)
						{
							BaseEntity baseEntity3 = DeployVolume.LastDeployHit.ToBaseEntity();
							if ((Object)(object)baseEntity3 != (Object)null)
							{
								msg.player.ShowBlockedByEntityToast(baseEntity3, Construction.lastPlacementError);
							}
						}
						else
						{
							msg.player.ShowToast(GameTip.Styles.Error, Construction.lastPlacementError, false);
						}
						return;
					}
					CodeLockPreserveInfo codeLockPreserveInfo = default(CodeLockPreserveInfo);
					if (baseEntity2 is CodeLock codeLock)
					{
						codeLockPreserveInfo.code = codeLock.code;
						codeLockPreserveInfo.guestCode = codeLock.guestCode;
						codeLockPreserveInfo.isLocked = codeLock.IsLocked();
						codeLockPreserveInfo.whitelistPlayers = Pool.Get<List<ulong>>();
						codeLockPreserveInfo.guestPlayers = Pool.Get<List<ulong>>();
						codeLockPreserveInfo.whitelistPlayers.AddRange(codeLock.whitelistPlayers);
						codeLockPreserveInfo.guestPlayers.AddRange(codeLock.guestPlayers);
					}
					Vector3 localPosition = ((Component)baseEntity2).transform.localPosition;
					Quaternion localRotation = ((Component)baseEntity2).transform.localRotation;
					BaseEntity baseEntity4 = baseEntity2.GetParentEntity();
					float health = baseEntity2.Health();
					EntityRef[] slots = baseEntity2.GetSlots();
					ulong ownerID = baseEntity2.OwnerID;
					float lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);
					int soilSaturation = ((baseEntity2 is PlanterBox planterBox) ? planterBox.soilSaturation : 0);
					bool flag = baseEntity2 is DecayEntity decayEntity && decayEntity.HasFlag(Flags.Reserved2);
					HashSet<ulong> hashSet = null;
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge)
					{
						hashSet = new HashSet<ulong>(buildingPrivlidge.authorizedPlayers);
					}
					bool flag2 = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge || baseEntity2 is BoxStorage || baseEntity2 is PlanterBox;
					Dictionary<ContainerSet, List<Item>> dictionary2 = new Dictionary<ContainerSet, List<Item>>();
					SaveEntityStorage(baseEntity2, dictionary2, 0);
					List<ChildPreserveInfo> list = Pool.Get<List<ChildPreserveInfo>>();
					if (flag2)
					{
						foreach (BaseEntity child in baseEntity2.children)
						{
							list.Add(new ChildPreserveInfo
							{
								TargetEntity = child,
								TargetBone = child.parentBone,
								LocalPosition = ((Component)child).transform.localPosition,
								LocalRotation = ((Component)child).transform.localRotation
							});
						}
						foreach (ChildPreserveInfo item in list)
						{
							item.TargetEntity.SetParent(null, worldPositionStays: true);
						}
					}
					else
					{
						for (int i = 0; i < baseEntity2.children.Count; i++)
						{
							SaveEntityStorage(baseEntity2.children[i], dictionary2, -1);
						}
					}
					IOPreserveInfo[] array = null;
					IOPreserveInfo[] array2 = null;
					List<OtherEntityPreserveInfo> list2 = new List<OtherEntityPreserveInfo>();
					if (baseEntity2 is IOEntity iOEntity)
					{
						array = new IOPreserveInfo[iOEntity.outputs.Length];
						for (int j = 0; j < iOEntity.outputs.Length; j++)
						{
							IOEntity.IOSlot iOSlot = iOEntity.outputs[j];
							IOEntity iOEntity2 = iOSlot.connectedTo.Get();
							if ((Object)(object)iOEntity2 != (Object)null)
							{
								iOSlot.Preserve(ref array[j]);
								IOPreserveInfo target = default(IOPreserveInfo);
								iOEntity2.inputs[iOSlot.connectedToSlot].Preserve(ref target);
								list2.Add(new OtherEntityPreserveInfo
								{
									info = target,
									connectedEntity = iOEntity2,
									index = iOSlot.connectedToSlot,
									isOutput = false
								});
							}
						}
						array2 = new IOPreserveInfo[iOEntity.inputs.Length];
						for (int k = 0; k < iOEntity.inputs.Length; k++)
						{
							IOEntity.IOSlot iOSlot2 = iOEntity.inputs[k];
							IOEntity iOEntity3 = iOSlot2.connectedTo.Get();
							if ((Object)(object)iOEntity3 != (Object)null)
							{
								iOSlot2.Preserve(ref array2[k]);
								IOPreserveInfo target2 = default(IOPreserveInfo);
								iOEntity3.outputs[iOSlot2.connectedToSlot].Preserve(ref target2);
								list2.Add(new OtherEntityPreserveInfo
								{
									info = target2,
									connectedEntity = iOEntity3,
									index = iOSlot2.connectedToSlot,
									isOutput = true
								});
							}
						}
					}
					baseEntity2.Kill();
					baseEntity2 = GameManager.server.CreateEntity(resourcePath, ((Object)(object)baseEntity4 != (Object)null) ? ((Component)baseEntity4).transform.TransformPoint(localPosition) : localPosition, ((Object)(object)baseEntity4 != (Object)null) ? (((Component)baseEntity4).transform.rotation * localRotation) : localRotation);
					baseEntity2.SetParent(baseEntity4);
					((Component)baseEntity2).transform.localPosition = localPosition;
					((Component)baseEntity2).transform.localRotation = localRotation;
					baseEntity2.OwnerID = ownerID;
					if (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && (Object)(object)def2.isRedirectOf != (Object)null)
					{
						baseEntity2.skinID = 0uL;
					}
					else
					{
						baseEntity2.skinID = num;
					}
					if (baseEntity2 is DecayEntity decayEntity2)
					{
						decayEntity2.AttachToBuilding(null);
					}
					if (baseEntity2 is PlanterBox planterBox2)
					{
						planterBox2.soilSaturation = soilSaturation;
					}
					baseEntity2.Spawn();
					if (baseEntity2 is IOEntity iOEntity4)
					{
						if (array != null)
						{
							for (int l = 0; l < iOEntity4.outputs.Length; l++)
							{
								iOEntity4.outputs[l].Restore(array[l]);
							}
						}
						if (array2 != null)
						{
							for (int m = 0; m < iOEntity4.inputs.Length; m++)
							{
								if ((Object)(object)array2[m].connectedTo != (Object)null)
								{
									iOEntity4.inputs[m].Restore(array2[m]);
								}
							}
						}
						PooledList<IOEntity> val = Pool.Get<PooledList<IOEntity>>();
						try
						{
							foreach (OtherEntityPreserveInfo item2 in list2)
							{
								IOPreserveInfo info = item2.info;
								info.connectedTo = iOEntity4;
								if ((Object)(object)item2.connectedEntity != (Object)null)
								{
									if (item2.isOutput)
									{
										item2.connectedEntity.outputs[item2.index].Restore(info);
										((List<IOEntity>)(object)val).Add(item2.connectedEntity);
									}
									else
									{
										item2.connectedEntity.inputs[item2.index].Restore(info);
										((List<IOEntity>)(object)val).Add(item2.connectedEntity);
									}
								}
							}
							foreach (IOEntity item3 in (List<IOEntity>)(object)val)
							{
								item3.SendNetworkUpdate();
							}
						}
						finally
						{
							((IDisposable)val)?.Dispose();
						}
					}
					if (baseEntity2 is BaseCombatEntity baseCombatEntity2)
					{
						baseCombatEntity2.SetHealth(health);
						baseCombatEntity2.lastAttackedTime = lastAttackedTime;
					}
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 && hashSet != null)
					{
						buildingPrivlidge2.authorizedPlayers = hashSet;
					}
					if (baseEntity2 is CodeLock codeLock2)
					{
						baseEntity4.SetSlot(Slot.Lock, codeLock2);
						codeLock2.SetParent(baseEntity4, baseEntity4.GetSlotAnchorName(Slot.Lock));
						codeLock2.code = codeLockPreserveInfo.code;
						codeLock2.guestCode = codeLockPreserveInfo.guestCode;
						codeLock2.SetFlag(Flags.Locked, codeLockPreserveInfo.isLocked);
						codeLock2.whitelistPlayers.AddRange(codeLockPreserveInfo.whitelistPlayers);
						codeLock2.guestPlayers.AddRange(codeLockPreserveInfo.guestPlayers);
						Pool.FreeUnmanaged<ulong>(ref codeLockPreserveInfo.whitelistPlayers);
						Pool.FreeUnmanaged<ulong>(ref codeLockPreserveInfo.guestPlayers);
					}
					if (dictionary2.Count > 0)
					{
						RestoreEntityStorage(baseEntity2, 0, dictionary2);
						if (!flag2)
						{
							for (int n = 0; n < baseEntity2.children.Count; n++)
							{
								RestoreEntityStorage(baseEntity2.children[n], -1, dictionary2);
							}
						}
						foreach (KeyValuePair<ContainerSet, List<Item>> item4 in dictionary2)
						{
							foreach (Item item5 in item4.Value)
							{
								Debug.Log((object)$"Deleting {item5} as it has no new container");
								item5.Remove();
							}
						}
						Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);
					}
					if (flag2)
					{
						foreach (ChildPreserveInfo item6 in list)
						{
							item6.TargetEntity.SetParent(baseEntity2, item6.TargetBone, worldPositionStays: true);
							((Component)item6.TargetEntity).transform.localPosition = item6.LocalPosition;
							((Component)item6.TargetEntity).transform.localRotation = item6.LocalRotation;
							item6.TargetEntity.SendNetworkUpdate();
						}
						baseEntity2.SetSlots(slots);
					}
					Pool.FreeUnmanaged<ChildPreserveInfo>(ref list);
					if (baseEntity2 is ISprayCallback sprayCallback)
					{
						sprayCallback.OnReskinned(msg.player);
					}
					if (baseEntity2 is DecayEntity decayEntity3 && !flag)
					{
						decayEntity3.StopBeingDemolishable();
					}
				}
				Interface.CallHook("OnEntityReskinned", (object)baseEntity2, (object)skin, (object)msg.player);
				ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 1, baseEntity2.net.ID);
			}
		}
		if (!base.UsingInfiniteAmmoCheat)
		{
			LoseCondition(ConditionLossPerReskin);
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ClearBusy, SprayCooldown);
		void FailResponse(SprayFailReason reason)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 0, (int)reason);
		}
		static void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary<ContainerSet, List<Item>> copy)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity2)
			{
				ContainerSet containerSet2 = default(ContainerSet);
				containerSet2.ContainerIndex = index;
				containerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key2 = containerSet2;
				if (copy.ContainsKey(key2))
				{
					foreach (Item item7 in copy[key2])
					{
						item7.MoveToContainer(itemContainerEntity2.inventory);
					}
					copy.Remove(key2);
				}
			}
		}
		static void SaveEntityStorage(BaseEntity baseEntity, Dictionary<ContainerSet, List<Item>> dictionary, int index)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity)
			{
				ContainerSet containerSet = default(ContainerSet);
				containerSet.ContainerIndex = index;
				containerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key = containerSet;
				if (!dictionary.ContainsKey(key))
				{
					dictionary.Add(key, new List<Item>());
					foreach (Item item8 in itemContainerEntity.inventory.itemList)
					{
						dictionary[key].Add(item8);
					}
					{
						foreach (Item item9 in dictionary[key])
						{
							item9.RemoveFromContainer();
						}
						return;
					}
				}
				Debug.Log((object)"Multiple containers with the same prefab id being added during vehicle reskin");
			}
		}
	}

	[RPC_Server.MaxDistance(5f)]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void ChangeWallpaper(RPCMessage msg)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId uid = msg.read.EntityID();
		int targetSkin = msg.read.Int32();
		int side = ((!msg.read.Bool()) ? 1 : 0);
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		if (!(baseNetworkable is BuildingBlock buildingBlock) || !buildingBlock.HasWallpaper(side))
		{
			SprayFailResponse(SprayFailReason.InvalidItem);
		}
		else if (ValidateWallpaperReskin(msg.player, baseNetworkable as BuildingBlock, side, targetSkin))
		{
			ulong id = ItemDefinition.FindSkin(WallpaperSettings.GetItemDefForCategory(WallpaperPlanner.Settings.GetCategory(buildingBlock, side)).itemid, targetSkin);
			buildingBlock.SetWallpaper(id, side);
			Analytics.Azure.OnWallpaperPlaced(msg.player, buildingBlock, id, side, reskin: true);
			ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 1, buildingBlock.net.ID);
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearBusy, SprayCooldown);
		}
	}

	private bool GetEntityPrefabPath(ItemDefinition def, out string resourcePath)
	{
		resourcePath = string.Empty;
		ItemModDeployable itemModDeployable = default(ItemModDeployable);
		if (((Component)def).TryGetComponent<ItemModDeployable>(ref itemModDeployable))
		{
			resourcePath = itemModDeployable.entityPrefab.resourcePath;
			return true;
		}
		ItemModEntity itemModEntity = default(ItemModEntity);
		if (((Component)def).TryGetComponent<ItemModEntity>(ref itemModEntity))
		{
			resourcePath = itemModEntity.entityPrefab.resourcePath;
			return true;
		}
		ItemModEntityReference itemModEntityReference = default(ItemModEntityReference);
		if (((Component)def).TryGetComponent<ItemModEntityReference>(ref itemModEntityReference))
		{
			resourcePath = itemModEntityReference.entityPrefab.resourcePath;
			return true;
		}
		return false;
	}

	[RPC_Server.InputValidation(new Type[]
	{
		typeof(Vector3),
		typeof(Vector3),
		typeof(Vector3),
		typeof(int)
	})]
	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void CreateSpray(RPCMessage msg)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		if (IsBusy())
		{
			return;
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ClearBusy, SprayCooldown);
		Vector3 val = msg.read.Vector3();
		Vector3 val2 = msg.read.Vector3();
		Vector3 val3 = msg.read.Vector3();
		int num = msg.read.Int32();
		if (Vector3.Distance(val, ((Component)this).transform.position) > 4.5f)
		{
			return;
		}
		Plane val4 = default(Plane);
		((Plane)(ref val4))..ctor(val2, val);
		Vector3 val5 = ((Plane)(ref val4)).ClosestPointOnPlane(val3) - val;
		Quaternion val6 = Quaternion.LookRotation(((Vector3)(ref val5)).normalized, val2);
		val6 *= Quaternion.Euler(0f, 0f, 90f);
		bool flag = false;
		if (msg.player.IsDeveloper)
		{
			flag = true;
		}
		if (num != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))
		{
			Debug.Log((object)$"SprayCan.ChangeItemSkin player does not have item :{num}:");
		}
		else if (Interface.CallHook("OnSprayCreate", (object)this, (object)val, (object)val6) == null)
		{
			ulong num2 = ItemDefinition.FindSkin(SprayDecalItem.itemid, num);
			BaseEntity baseEntity = GameManager.server.CreateEntity(SprayDecalEntityRef.resourcePath, val, val6);
			baseEntity.skinID = num2;
			baseEntity.OnDeployed(null, GetOwnerPlayer(), GetItem());
			baseEntity.Spawn();
			CheckAchievementPosition(val);
			if (!base.UsingInfiniteAmmoCheat)
			{
				LoseCondition(ConditionLossPerSpray);
			}
		}
	}

	private void CheckAchievementPosition(Vector3 pos)
	{
	}

	private void LoseCondition(float amount)
	{
		GetOwnerItem()?.LoseCondition(amount);
	}

	public void ClearBusy()
	{
		SetFlag(Flags.Busy, b: false);
		SetFlag(Flags.Reserved1, b: false);
	}

	public override void OnHeldChanged()
	{
		if (IsDisabled())
		{
			ClearBusy();
			if ((Object)(object)paintingLine != (Object)null)
			{
				paintingLine.Kill();
			}
			paintingLine = null;
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Server_SetBlockColourId(RPCMessage msg)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId uid = msg.read.EntityID();
		uint num = msg.read.UInt32();
		BasePlayer player = msg.player;
		SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ClearBusy, 0.1f);
		if (!((Object)(object)player == (Object)null) && player.CanBuild())
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			BuildingBlock buildingBlock = BaseNetworkable.serverEntities.Find(uid) as BuildingBlock;
			if ((Object)(object)buildingBlock != (Object)null && !(player.Distance((BaseEntity)buildingBlock) > 4f))
			{
				uint customColour = buildingBlock.customColour;
				buildingBlock.SetCustomColour(num);
				Analytics.Azure.OnBuildingBlockColorChanged(ownerPlayer, buildingBlock, customColour, num);
			}
		}
	}

	private bool CanEntityBeRespawned(BaseEntity targetEntity, out SprayFailReason reason, out BasePlayer culpritPlayer)
	{
		if (targetEntity is BaseMountable baseMountable && baseMountable.AnyMounted())
		{
			reason = SprayFailReason.MountedBlocked;
			culpritPlayer = baseMountable.GetMounted();
			return false;
		}
		if (targetEntity.isServer && targetEntity is BaseVehicle baseVehicle && (baseVehicle.HasDriver() || baseVehicle.AnyMounted()))
		{
			reason = SprayFailReason.MountedBlocked;
			culpritPlayer = baseVehicle.GetMounted();
			return false;
		}
		reason = SprayFailReason.None;
		culpritPlayer = null;
		return true;
	}

	public static bool GetItemDefinitionForEntity(BaseEntity be, out ItemDefinition def, bool useRedirect = true)
	{
		def = null;
		if (be is BaseCombatEntity baseCombatEntity)
		{
			if (baseCombatEntity.pickup.enabled && (Object)(object)baseCombatEntity.pickup.itemTarget != (Object)null)
			{
				def = baseCombatEntity.pickup.itemTarget;
			}
			else if (baseCombatEntity.repair.enabled && (Object)(object)baseCombatEntity.repair.itemTarget != (Object)null)
			{
				def = baseCombatEntity.repair.itemTarget;
			}
		}
		if (be is CodeLock codeLock)
		{
			def = codeLock.itemType;
		}
		if (useRedirect && (Object)(object)def != (Object)null && (Object)(object)def.isRedirectOf != (Object)null)
		{
			def = def.isRedirectOf;
		}
		return (Object)(object)def != (Object)null;
	}
}


private enum SprayFailReason
{
	None,
	MountedBlocked,
	IOConnection,
	LineOfSight,
	SkinNotOwned,
	InvalidItem
}


private struct ContainerSet
{
	public int ContainerIndex;

	public uint PrefabId;
}


using UnityEngine;

public struct IOPreserveInfo
{
	public IOEntity connectedTo;

	public int connectedToSlot;

	public Vector3[] linePoints;

	public float[] slackLevels;

	public IOEntity.LineAnchor[] lineAnchors;

	public Vector3 worldSpaceLineEndRotation;

	public Vector3 originPosition;

	public Vector3 originRotation;

	public WireTool.WireColour wireColour;
}


using System.Collections.Generic;

private struct CodeLockPreserveInfo
{
	public string code;

	public string guestCode;

	public bool isLocked;

	public List<ulong> whitelistPlayers;

	public List<ulong> guestPlayers;
}


private struct OtherEntityPreserveInfo
{
	public IOPreserveInfo info;

	public IOEntity connectedEntity;

	public int index;

	public bool isOutput;
}


using UnityEngine;

public struct ChildPreserveInfo
{
	public BaseEntity TargetEntity;

	public uint TargetBone;

	public Vector3 LocalPosition;

	public Quaternion LocalRotation;
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class SprayCanSpray : DecayEntity, ISplashable
{
	private DateTime sprayTimestamp;

	[NonSerialized]
	public ulong sprayedByPlayer;

	public static ListHashSet<SprayCanSpray> AllSprays = new ListHashSet<SprayCanSpray>();

	[NonSerialized]
	public int splashThreshold;

	public override bool BypassInsideDecayMultiplier => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SprayCanSpray.OnRpcMessage", 0);
		try
		{
			if (rpc == 2774110739u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestWaterClear "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestWaterClear", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_RequestWaterClear(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_RequestWaterClear");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.spray == null)
		{
			info.msg.spray = Pool.Get<Spray>();
		}
		info.msg.spray.sprayedBy = sprayedByPlayer;
		info.msg.spray.timestamp = sprayTimestamp.ToBinary();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.spray != null)
		{
			sprayedByPlayer = info.msg.spray.sprayedBy;
			sprayTimestamp = DateTime.FromBinary(info.msg.spray.timestamp);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		sprayTimestamp = DateTime.Now;
		sprayedByPlayer = deployedBy.userID;
		if (Global.MaxSpraysPerPlayer > 0 && sprayedByPlayer != 0L)
		{
			int num = -1;
			DateTime now = DateTime.Now;
			int num2 = 0;
			for (int i = 0; i < AllSprays.Count; i++)
			{
				if (AllSprays[i].sprayedByPlayer == sprayedByPlayer)
				{
					num2++;
					if (num == -1 || AllSprays[i].sprayTimestamp < now)
					{
						num = i;
						now = AllSprays[i].sprayTimestamp;
					}
				}
			}
			if (num2 >= Global.MaxSpraysPerPlayer && num != -1)
			{
				AllSprays[num].Kill();
			}
		}
		if ((Object)(object)deployedBy == (Object)null || !deployedBy.IsBuildingAuthed())
		{
			((FacepunchBehaviour)this).Invoke((Action)ApplyOutOfAuthConditionPenalty, 1f);
		}
	}

	public void ApplyOutOfAuthConditionPenalty()
	{
		if (!IsFullySpawned())
		{
			((FacepunchBehaviour)this).Invoke((Action)ApplyOutOfAuthConditionPenalty, 1f);
			return;
		}
		float amount = MaxHealth() * (1f - Global.SprayOutOfAuthMultiplier);
		Hurt(amount, DamageType.Decay);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)RainCheck, 60f, 180f, 30f);
		if (!AllSprays.Contains(this))
		{
			AllSprays.Add(this);
		}
		SplashableStaticGrid.RegisterSplashable(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (AllSprays.Contains(this))
		{
			AllSprays.Remove(this);
		}
		SplashableStaticGrid.DeregisterSplashable(this);
	}

	public void RainCheck()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		if (Climate.GetRain(((Component)this).transform.position) > 0f && IsOutside())
		{
			Kill();
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		return amount > splashThreshold;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		if (!base.IsDestroyed)
		{
			Kill();
		}
		return 1;
	}

	[RPC_Server]
	private void Server_RequestWaterClear(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && Menu_WaterClear_ShowIf(player) && Interface.CallHook("OnSprayRemove", (object)this, (object)player) == null)
		{
			Kill();
		}
	}

	public bool Menu_WaterClear_ShowIf(BasePlayer player)
	{
		if ((Object)(object)player.GetHeldEntity() != (Object)null && player.GetHeldEntity() is BaseLiquidVessel baseLiquidVessel)
		{
			return baseLiquidVessel.AmountHeld() > 0;
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SprayCanSpray_Freehand : SprayCanSpray
{
	public AlignedLineDrawer LineDrawer;

	public List<AlignedLineDrawer.LinePoint> LinePoints = new List<AlignedLineDrawer.LinePoint>();

	public Color colour = Color.white;

	public float width;

	public EntityRef<BasePlayer> editingPlayer;

	public GroundWatch groundWatch;

	public MeshCollider meshCollider;

	public const int MaxLinePointLength = 60;

	public const float SimplifyTolerance = 0.008f;

	private bool AcceptingChanges => editingPlayer.IsValid(serverside: true);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SprayCanSpray_Freehand.OnRpcMessage", 0);
		try
		{
			if (rpc == 2020094435 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AddPointMidSpray "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AddPointMidSpray", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						long position = ((Stream)(object)msg.read).Position;
						if (!RPC_Server.InputValidation.Test(msg.read.Read<Vector3>()))
						{
							return true;
						}
						if (!RPC_Server.InputValidation.Test(msg.read.Read<Vector3>()))
						{
							return true;
						}
						((Stream)(object)msg.read).Position = position;
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_AddPointMidSpray(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_AddPointMidSpray");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 117883393 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_FinishEditing "));
				}
				TimeWarning val2 = TimeWarning.New("Server_FinishEditing", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						long position2 = ((Stream)(object)msg.read).Position;
						msg.read.Read<int>();
						SprayList val4 = msg.read.Proto<SprayList>((SprayList)null);
						try
						{
							foreach (LinePoint linePoint in val4.linePoints)
							{
								if (!RPC_Server.InputValidation.Test(linePoint.localPosition))
								{
									return true;
								}
								if (!RPC_Server.InputValidation.Test(linePoint.worldNormal))
								{
									return true;
								}
							}
							((Stream)(object)msg.read).Position = position2;
						}
						finally
						{
							((IDisposable)val4)?.Dispose();
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_FinishEditing(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_FinishEditing");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (LinePoints == null || LinePoints.Count == 0)
		{
			Kill();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.sprayLine == null)
		{
			info.msg.sprayLine = Pool.Get<SprayLine>();
		}
		if (info.msg.sprayLine.linePoints == null)
		{
			info.msg.sprayLine.linePoints = Pool.Get<List<LinePoint>>();
		}
		bool flag = AcceptingChanges && info.forDisk;
		if (LinePoints != null && !flag)
		{
			CopyPoints(LinePoints, info.msg.sprayLine.linePoints);
		}
		info.msg.sprayLine.width = width;
		info.msg.sprayLine.colour = new Vector3(colour.r, colour.g, colour.b);
		if (!info.forDisk)
		{
			info.msg.sprayLine.editingPlayer = editingPlayer.uid;
		}
	}

	public void SetColour(Color newColour)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		colour = newColour;
	}

	public void SetWidth(float lineWidth)
	{
		width = lineWidth;
	}

	[RPC_Server.InputValidation(new Type[]
	{
		typeof(Vector3),
		typeof(Vector3)
	})]
	[RPC_Server]
	private void Server_AddPointMidSpray(RPCMessage msg)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (AcceptingChanges && !((Object)(object)editingPlayer.Get(serverside: true) != (Object)(object)msg.player) && LinePoints.Count + 1 <= 60)
		{
			Vector3 val = msg.read.Vector3();
			Vector3 worldNormal = msg.read.Vector3();
			if (!(Vector3.Distance(val, LinePoints[0].LocalPosition) >= 10f))
			{
				LinePoints.Add(new AlignedLineDrawer.LinePoint
				{
					LocalPosition = val,
					WorldNormal = worldNormal
				});
				UpdateGroundWatch();
				SendNetworkUpdate();
			}
		}
	}

	public void EnableChanges(BasePlayer byPlayer)
	{
		base.OwnerID = byPlayer.userID;
		editingPlayer.Set(byPlayer);
		((FacepunchBehaviour)this).Invoke((Action)TimeoutEditing, 30f);
	}

	public void TimeoutEditing()
	{
		if (editingPlayer.IsSet)
		{
			editingPlayer.Set(null);
			SendNetworkUpdate();
			Kill();
		}
	}

	[RPC_Server.InputValidation(new Type[]
	{
		typeof(int),
		typeof(SprayList)
	})]
	[RPC_Server]
	private void Server_FinishEditing(RPCMessage msg)
	{
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = editingPlayer.Get(serverside: true);
		if ((Object)(object)msg.player != (Object)(object)basePlayer)
		{
			return;
		}
		bool allowNewSprayImmediately = msg.read.Int32() == 1;
		if ((Object)(object)basePlayer != (Object)null && (Object)(object)basePlayer.GetHeldEntity() != (Object)null && basePlayer.GetHeldEntity() is SprayCan sprayCan)
		{
			sprayCan.ClearPaintingLine(allowNewSprayImmediately);
		}
		editingPlayer.Set(null);
		SprayList val = msg.read.Proto<SprayList>((SprayList)null);
		try
		{
			int count = val.linePoints.Count;
			if (count > 70)
			{
				Kill();
				return;
			}
			if (LinePoints.Count <= 1)
			{
				Kill();
				return;
			}
			foreach (AlignedLineDrawer.LinePoint linePoint in LinePoints)
			{
				if (Vector3Ex.IsNaNOrInfinity(linePoint.LocalPosition) || Vector3Ex.IsNaNOrInfinity(linePoint.WorldNormal))
				{
					Kill();
					return;
				}
			}
			((FacepunchBehaviour)this).CancelInvoke((Action)TimeoutEditing);
			LinePoints.Clear();
			for (int i = 0; i < count; i++)
			{
				if (((Vector3)(ref val.linePoints[i].localPosition)).sqrMagnitude < 100f)
				{
					LinePoints.Add(new AlignedLineDrawer.LinePoint
					{
						LocalPosition = val.linePoints[i].localPosition,
						WorldNormal = val.linePoints[i].worldNormal
					});
				}
			}
			OnDeployed(null, basePlayer, null);
			UpdateGroundWatch();
			SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void AddInitialPoint(Vector3 atNormal)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		LinePoints = new List<AlignedLineDrawer.LinePoint>
		{
			new AlignedLineDrawer.LinePoint
			{
				LocalPosition = Vector3.zero,
				WorldNormal = atNormal
			}
		};
	}

	private void UpdateGroundWatch()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && LinePoints.Count > 1)
		{
			Vector3 groundPosition = Vector3.Lerp(LinePoints[0].LocalPosition, LinePoints[LinePoints.Count - 1].LocalPosition, 0.5f);
			if ((Object)(object)groundWatch != (Object)null)
			{
				groundWatch.groundPosition = groundPosition;
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.sprayLine != null)
		{
			if (info.msg.sprayLine.linePoints != null)
			{
				LinePoints.Clear();
				CopyPoints(info.msg.sprayLine.linePoints, LinePoints);
			}
			colour = new Color(info.msg.sprayLine.colour.x, info.msg.sprayLine.colour.y, info.msg.sprayLine.colour.z);
			width = info.msg.sprayLine.width;
			editingPlayer.uid = info.msg.sprayLine.editingPlayer;
			UpdateGroundWatch();
		}
	}

	public void CopyPoints(List<AlignedLineDrawer.LinePoint> from, List<LinePoint> to)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		to.Clear();
		foreach (AlignedLineDrawer.LinePoint item in from)
		{
			LinePoint val = Pool.Get<LinePoint>();
			val.localPosition = item.LocalPosition;
			val.worldNormal = item.WorldNormal;
			to.Add(val);
		}
	}

	public void CopyPoints(List<AlignedLineDrawer.LinePoint> from, List<Vector3> to)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		to.Clear();
		foreach (AlignedLineDrawer.LinePoint item in from)
		{
			to.Add(item.LocalPosition);
			to.Add(item.WorldNormal);
		}
	}

	public void CopyPoints(List<LinePoint> from, List<AlignedLineDrawer.LinePoint> to)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		to.Clear();
		foreach (LinePoint item in from)
		{
			to.Add(new AlignedLineDrawer.LinePoint
			{
				LocalPosition = item.localPosition,
				WorldNormal = item.worldNormal
			});
		}
	}

	public static void CopyPoints(List<AlignedLineDrawer.LinePoint> from, List<AlignedLineDrawer.LinePoint> to)
	{
		to.Clear();
		foreach (AlignedLineDrawer.LinePoint item in from)
		{
			to.Add(item);
		}
	}

	public override void ResetState()
	{
		base.ResetState();
		editingPlayer.Set(null);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class StagedResourceEntity : ResourceEntity
{
	[Serializable]
	public class ResourceStage
	{
		public float health;

		public GameObject instance;
	}

	public List<ResourceStage> stages = new List<ResourceStage>();

	protected int stage;

	public GameObjectRef changeStageEffect;

	public MeshLOD ResourceMeshLod;

	public MeshCollider ResourceMeshCollider;

	public GameObject gibSourceTest;

	private StagedResourceEntityInfo cachedInfo;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StagedResourceEntity.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public int GetStage()
	{
		return stage;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.resource != null)
		{
			int num = info.msg.resource.stage;
			if (info.fromDisk && base.isServer)
			{
				health = startHealth;
				num = 0;
			}
			if (num != stage)
			{
				stage = num;
				UpdateStage();
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.resource == null)
		{
			info.msg.resource = Pool.Get<BaseResource>();
		}
		info.msg.resource.health = Health();
		info.msg.resource.stage = stage;
	}

	protected override void OnHealthChanged()
	{
		((FacepunchBehaviour)this).Invoke((Action)UpdateNetworkStage, 0.1f);
	}

	public virtual void UpdateNetworkStage()
	{
		if (FindBestStage() != stage)
		{
			stage = FindBestStage();
			SendNetworkUpdate();
			UpdateStage();
		}
	}

	private int FindBestStage()
	{
		float num = Mathf.InverseLerp(0f, MaxHealth(), Health());
		StagedResourceEntityInfo.ResourceStage[] array = GetInfo().Stages;
		for (int i = 0; i < array.Length; i++)
		{
			if (num >= array[i].Health)
			{
				return i;
			}
		}
		return array.Length - 1;
	}

	private StagedResourceEntityInfo GetInfo()
	{
		if (cachedInfo != null)
		{
			return cachedInfo;
		}
		if (base.isServer)
		{
			cachedInfo = PrefabAttribute.server.Find<StagedResourceEntityInfo>(prefabID);
		}
		return cachedInfo;
	}

	private void UpdateStage()
	{
		if (GetInfo().Stages.Length != 0)
		{
			ResourceMeshCollider.sharedMesh = cachedInfo.GetCollisionMesh(stage);
			GroundWatch.PhysicsChanged(((Component)this).gameObject);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResourceStage
{
	public float health;

	public GameObject instance;
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

[Factory("stash")]
public class StashContainer : StorageContainer
{
	public static class StashContainerFlags
	{
		public const Flags Hidden = Flags.Reserved5;
	}

	public Transform visuals;

	public float burriedOffset;

	public float raisedOffset;

	public GameObjectRef buryEffect;

	public float uncoverRange = 3f;

	public float uncoverTime = 2f;

	[ServerVar(Name = "reveal_tick_rate")]
	public static float PlayerDetectionTickRate = 0.5f;

	private float lastToggleTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StashContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 4130263076u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_HideStash "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_HideStash", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4130263076u, "RPC_HideStash", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_HideStash(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_HideStash");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool PlayerInRange(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3.Distance(((Component)this).transform.position, ((Component)ply).transform.position) <= uncoverRange)
		{
			Vector3 val = ((Component)this).transform.position - ply.eyes.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			if (Vector3.Dot(ply.eyes.BodyForward(), normalized) > 0.95f)
			{
				return true;
			}
		}
		return false;
	}

	public override void InitShared()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		((Component)visuals).transform.localPosition = Vector3Ex.WithY(((Component)visuals).transform.localPosition, raisedOffset);
	}

	public void DoOccludedCheck()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (Physics.SphereCast(new Ray(((Component)this).transform.position + Vector3.up * 5f, Vector3.down), 0.25f, 5f, 2097152) && Interface.CallHook("OnStashOcclude", (object)this) == null)
		{
			DropItems();
			Kill();
		}
	}

	public void OnPhysicsNeighbourChanged()
	{
		if (!((FacepunchBehaviour)this).IsInvoking((Action)DoOccludedCheck))
		{
			((FacepunchBehaviour)this).Invoke((Action)DoOccludedCheck, Random.Range(5f, 10f));
		}
	}

	private void RemoveFromNetworkRange()
	{
		base.limitNetworking = true;
	}

	private void ReturnToNetworkRange()
	{
		if (base.limitNetworking)
		{
			base.limitNetworking = false;
			SendNetworkUpdateImmediate();
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)RemoveFromNetworkRange);
	}

	public void SetHidden(bool isHidden)
	{
		if (!(Time.realtimeSinceStartup - lastToggleTime < 3f) && isHidden != HasFlag(Flags.Reserved5))
		{
			if (isHidden)
			{
				((FacepunchBehaviour)this).Invoke((Action)RemoveFromNetworkRange, 3f);
			}
			else
			{
				ReturnToNetworkRange();
			}
			lastToggleTime = Time.realtimeSinceStartup;
			((FacepunchBehaviour)this).Invoke((Action)Decay, 259200f);
			if (base.isServer)
			{
				SetFlag(Flags.Reserved5, isHidden);
			}
		}
	}

	public void DisableNetworking()
	{
		base.limitNetworking = true;
		SetFlag(Flags.Disabled, b: true);
	}

	public void Decay()
	{
		Kill();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetHidden(isHidden: false);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (IsHidden())
		{
			RemoveFromNetworkRange();
		}
	}

	public void ToggleHidden()
	{
		SetHidden(!IsHidden());
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", (object)rpc.player, (object)this) == null)
		{
			Analytics.Azure.OnStashHidden(rpc.player, this);
			SetHidden(isHidden: true);
			Interface.CallHook("OnStashHidden", (object)this, (object)rpc.player);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool num = (old & Flags.Reserved5) == Flags.Reserved5;
		bool flag = (next & Flags.Reserved5) == Flags.Reserved5;
		if (num != flag)
		{
			float num2 = (flag ? burriedOffset : raisedOffset);
			LeanTween.cancel(((Component)visuals).gameObject);
			LeanTween.moveLocalY(((Component)visuals).gameObject, num2, 1f);
		}
	}

	public bool IsHidden()
	{
		return HasFlag(Flags.Reserved5);
	}
}


public static class StashContainerFlags
{
	public const Flags Hidden = Flags.Reserved5;
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class StaticInstrument : BaseMountable
{
	public AnimatorOverrideController AnimatorOverride;

	public bool ShowDeployAnimation;

	public InstrumentKeyController KeyController;

	public bool ShouldSuppressHandsAnimationLayer;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StaticInstrument.OnRpcMessage", 0);
		try
		{
			if (rpc == 1625188589 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_PlayNote "));
				}
				TimeWarning val2 = TimeWarning.New("Server_PlayNote", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_PlayNote(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_PlayNote");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 705843933 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_StopNote "));
				}
				TimeWarning val2 = TimeWarning.New("Server_StopNote", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						Server_StopNote(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in Server_StopNote");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	private void Server_PlayNote(RPCMessage msg)
	{
		int arg = msg.read.Int32();
		int arg2 = msg.read.Int32();
		int arg3 = msg.read.Int32();
		float num = msg.read.Float();
		if (!FloatEx.IsNaNOrInfinity(num))
		{
			KeyController.ProcessServerPlayedNote(GetMounted());
			ClientRPC(RpcTarget.NetworkGroup("Client_PlayNote"), arg, arg2, arg3, num);
		}
	}

	[RPC_Server]
	private void Server_StopNote(RPCMessage msg)
	{
		int arg = msg.read.Int32();
		int arg2 = msg.read.Int32();
		int arg3 = msg.read.Int32();
		ClientRPC(RpcTarget.NetworkGroup("Client_StopNote"), arg, arg2, arg3);
	}

	public override bool IsInstrument()
	{
		return true;
	}
}


using System;
using System.Linq;
using System.Threading.Tasks;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class SteamInventory : EntityComponent<BasePlayer>
{
	public IPlayerItem[] Items;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SteamInventory.OnRpcMessage", 0);
		try
		{
			if (rpc == 643458331 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdateSteamInventory "));
				}
				TimeWarning val2 = TimeWarning.New("UpdateSteamInventory", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!BaseEntity.RPC_Server.FromOwner.Test(643458331u, "UpdateSteamInventory", GetBaseEntity(), player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							BaseEntity.RPCMessage rPCMessage = default(BaseEntity.RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							BaseEntity.RPCMessage msg2 = rPCMessage;
							UpdateSteamInventory(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in UpdateSteamInventory");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool HasItem(int itemid)
	{
		if (!base.baseEntity.DefaultSkinAccess)
		{
			return base.baseEntity.AllSkinsUnlocked;
		}
		if (Items == null)
		{
			return false;
		}
		IPlayerItem[] items = Items;
		for (int i = 0; i < items.Length; i++)
		{
			if (items[i].DefinitionId == itemid)
			{
				return true;
			}
		}
		return false;
	}

	[BaseEntity.RPC_Server.FromOwner(false)]
	[BaseEntity.RPC_Server]
	private async Task UpdateSteamInventory(BaseEntity.RPCMessage msg)
	{
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (array == null)
		{
			Debug.LogWarning((object)"UpdateSteamInventory: Data is null");
			return;
		}
		IPlayerInventory val = await PlatformService.Instance.DeserializeInventory(array);
		if (val == null)
		{
			Debug.LogWarning((object)"UpdateSteamInventory: result is null");
		}
		else if ((Object)(object)base.baseEntity == (Object)null)
		{
			Debug.LogWarning((object)"UpdateSteamInventory: player is null");
		}
		else if (!val.BelongsTo((ulong)base.baseEntity.userID))
		{
			Debug.LogWarning((object)$"UpdateSteamPlayer: inventory belongs to someone else (userID={base.baseEntity.userID.Get()})");
		}
		else if (Object.op_Implicit((Object)(object)((Component)this).gameObject))
		{
			Items = val.Items.ToArray();
			Interface.CallHook("OnSteamInventoryUpdated", (object)this);
			((IDisposable)val).Dispose();
		}
	}
}


using System;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class SteeringWheel : BaseMountable, IBoatBuildingPiece
{
	public static Phrase TipPhrase = new Phrase("boat_steeringwheel_tip", "Interact with the steering wheel to code lock your boat.");

	public static Phrase MountedTipPhrase = new Phrase("boat_steeringwheel_tip_mounted", "Look at the center of the wheel for options when mounted.");

	[Header("Steering Wheel")]
	public GameObjectRef PrivPrefab;

	public GameObjectRef KeyEnterDialog;

	public float TurnLerpSpeed = 1f;

	public Transform Wheel;

	public PlayerBoatPrivilege Privilege;

	public SoundDefinition wheelTurnLoopDef;

	public SoundDefinition wheelTurnStartDef;

	public SoundDefinition wheelTurnStopDef;

	public float wheelTurnLoopFadeTime = 0.1f;

	public float stopDelay;

	public GameObjectRef finishBuildingEffect;

	public SoundDefinition wheelCenterDef;

	[Header("Effects")]
	public Transform EffectLocation;

	public GameObjectRef effectUnlocked;

	public GameObjectRef effectLocked;

	public GameObjectRef effectDenied;

	public GameObjectRef effectCodeChanged;

	public GameObjectRef effectShock;

	[NonSerialized]
	public PlayerBoat ParentBoat;

	private Action _mountedPlayerClipCheck;

	private float __sync_ServerSteeringRotation;

	public PlayerBoatLock BoatLock { get; private set; }

	[Sync(Pack = false, Autosave = true)]
	public float ServerSteeringRotation
	{
		[CompilerGenerated]
		get
		{
			return __sync_ServerSteeringRotation;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_ServerSteeringRotation, value))
			{
				__sync_ServerSteeringRotation = value;
				byte nameID = __GetWeaverID("ServerSteeringRotation");
				SV_SyncVarSend(nameID);
			}
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SteeringWheel.OnRpcMessage", 0);
		try
		{
			if (rpc == 3277541392u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReceiveClientRotation "));
				}
				TimeWarning val2 = TimeWarning.New("ReceiveClientRotation", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3277541392u, "ReceiveClientRotation", this, player, 15uL))
						{
							return true;
						}
						long position = ((Stream)(object)msg.read).Position;
						msg.read.Read<float>();
						((Stream)(object)msg.read).Position = position;
						if (!RPC_Server.IsVisible.Test(3277541392u, "ReceiveClientRotation", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ReceiveClientRotation(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ReceiveClientRotation");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1618039250 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestDeployAndEditBoat "));
				}
				TimeWarning val2 = TimeWarning.New("RequestDeployAndEditBoat", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1618039250u, "RequestDeployAndEditBoat", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1618039250u, "RequestDeployAndEditBoat", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RequestDeployAndEditBoat(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RequestDeployAndEditBoat");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3915953376u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestEditBoat "));
				}
				TimeWarning val2 = TimeWarning.New("RequestEditBoat", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3915953376u, "RequestEditBoat", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3915953376u, "RequestEditBoat", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RequestEditBoat(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RequestEditBoat");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3194773350u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestFinishBuilding "));
				}
				TimeWarning val2 = TimeWarning.New("RequestFinishBuilding", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3194773350u, "RequestFinishBuilding", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3194773350u, "RequestFinishBuilding", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RequestFinishBuilding(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RequestFinishBuilding");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3963850389u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestFinishBuildingFromWheel "));
				}
				TimeWarning val2 = TimeWarning.New("RequestFinishBuildingFromWheel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3963850389u, "RequestFinishBuildingFromWheel", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3963850389u, "RequestFinishBuildingFromWheel", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							RequestFinishBuildingFromWheel(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in RequestFinishBuildingFromWheel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3710764312u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestAddLock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestAddLock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3710764312u, "RPC_RequestAddLock", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3710764312u, "RPC_RequestAddLock", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							RPC_RequestAddLock(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in RPC_RequestAddLock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2818660542u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TryMountWithKeycode "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TryMountWithKeycode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2818660542u, "RPC_TryMountWithKeycode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							RPC_TryMountWithKeycode(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in RPC_TryMountWithKeycode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public PlayerBoat GetParentBoat()
	{
		return PlayerBoat.GetParentPlayerBoat(this);
	}

	public override bool DirectlyMountable()
	{
		return true;
	}

	private BoatBuildingStation GetCurrentBoatBuildingStation(BasePlayer player)
	{
		TriggerBoatBuildingArea triggerBoatBuildingArea = player.FindTrigger<TriggerBoatBuildingArea>();
		if ((Object)(object)triggerBoatBuildingArea == (Object)null)
		{
			return null;
		}
		return ((Component)triggerBoatBuildingArea).GetComponentInParent<BoatBuildingStation>();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		BoatLock.Load(info);
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child is PlayerBoatPrivilege privilege)
		{
			Privilege = privilege;
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		if (BoatLock == null)
		{
			BoatLock = new PlayerBoatLock(this, base.isServer);
		}
	}

	public bool IsFlipped()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Dot(Vector3.up, ((Component)this).transform.up) <= 0.175f;
	}

	public bool IsAuthed(BasePlayer player)
	{
		if ((Object)(object)Privilege == (Object)null)
		{
			return false;
		}
		return Privilege.IsAuthed(player);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Locked, BoatLock != null && BoatLock.HasALock);
		ServerSteeringRotation = 0f;
		CreatePrivilege();
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		AuthPlayer(deployedBy);
		ClientRPC(RpcTarget.Player("CLIENT_OnDeployed", deployedBy));
	}

	private void CreatePrivilege()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (!Application.isLoadingSave)
		{
			Privilege = null;
			BaseEntity baseEntity = GameManager.server.CreateEntity(PrivPrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
			if ((Object)(object)baseEntity != (Object)null)
			{
				baseEntity.SetParent(this, worldPositionStays: true);
				baseEntity.Spawn();
			}
			Privilege = baseEntity as PlayerBoatPrivilege;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.steeringWheel = Pool.Get<SteeringWheel>();
		BoatLock.Save(info);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (base.isServer)
		{
			BoatLock.PostServerLoad();
			SetFlag(Flags.Locked, BoatLock.HasALock);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RequestAddLock(RPCMessage msg)
	{
		if (!BoatLock.HasALock)
		{
			BasePlayer player = msg.player;
			if (!((Object)(object)player == (Object)null))
			{
				string code = msg.read.String(256, false);
				BoatLock.TryAddALock(code, player);
				SetFlag(Flags.Locked, BoatLock.HasALock);
			}
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_TryMountWithKeycode(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			string codeEntered = msg.read.String(256, false);
			if (BoatLock.TryOpenWithCode(player, codeEntered))
			{
				AuthPlayer(player);
				WantsMount(player);
			}
		}
	}

	private void AuthPlayer(BasePlayer player)
	{
		if (!((Object)(object)Privilege == (Object)null) && !Privilege.IsAuthed(player))
		{
			Privilege.AddPlayer(player);
			Privilege.SendNetworkUpdate();
		}
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if ((!BoatLock.HasALock || BoatLock.HasLockPermission(player)) && !IsFlipped())
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		if (Object.op_Implicit((Object)(object)ParentBoat))
		{
			ParentBoat.SetFlag(Flags.Reserved17, b: true);
		}
		if (_mountedPlayerClipCheck == null)
		{
			_mountedPlayerClipCheck = CheckSeatClipping;
		}
		((FacepunchBehaviour)this).InvokeRepeatingFixedTime(_mountedPlayerClipCheck);
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		if (Object.op_Implicit((Object)(object)ParentBoat))
		{
			ParentBoat.SetFlag(Flags.Reserved17, b: false);
		}
		if (_mountedPlayerClipCheck == null)
		{
			_mountedPlayerClipCheck = CheckSeatClipping;
		}
		((FacepunchBehaviour)this).CancelInvokeFixedTime(_mountedPlayerClipCheck);
	}

	private void CheckSeatClipping()
	{
		if (_mountedPlayerClipCheck == null)
		{
			_mountedPlayerClipCheck = CheckSeatClipping;
		}
		if (!AnyMounted())
		{
			((FacepunchBehaviour)this).CancelInvokeFixedTime(_mountedPlayerClipCheck);
		}
		else if (IsSeatClipping(this))
		{
			DismountAllPlayers();
			((FacepunchBehaviour)this).CancelInvokeFixedTime(_mountedPlayerClipCheck);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public void RequestFinishBuilding(RPCMessage msg)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			BoatBuildingStation currentBoatBuildingStation = GetCurrentBoatBuildingStation(player);
			if (!((Object)(object)currentBoatBuildingStation == (Object)null))
			{
				BoatBuildingStation.LogBuildingEvent(((Component)this).transform.position, player, null, "SteeringWheel rquesting FinishBuilding");
				currentBoatBuildingStation.FinishBuilding(msg.player);
			}
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RequestFinishBuildingFromWheel(RPCMessage msg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		BoatBuildingStation.LogBuildingEvent(((Component)this).transform.position, msg.player, null, "Finish boat requested via steering wheel.");
		BoatBuildingStation currentBoatBuildingStation = GetCurrentBoatBuildingStation(player);
		if (!((Object)(object)currentBoatBuildingStation != (Object)null) || !currentBoatBuildingStation.FinishBuilding(msg.player))
		{
			return;
		}
		currentBoatBuildingStation.KilledDuringWheelFinish = true;
		currentBoatBuildingStation.Kill();
		if (!((Object)(object)ParentBoat == (Object)null))
		{
			Item item = ItemManager.Create(ParentBoat.BoatBuildingStationItem, 1, 0uL);
			item.SetItemOwnership(player, ItemOwnershipPhrases.PickedUp);
			player.GiveItem(item, GiveItemReason.PickedUp);
			if (finishBuildingEffect.isValid)
			{
				Effect.server.Run(finishBuildingEffect.resourcePath, this, 0u, default(Vector3), default(Vector3), null, broadcast: false, null, 0, Effect.Type.Generic);
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public void RequestEditBoat(RPCMessage msg)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		BoatBuildingStation currentBoatBuildingStation = GetCurrentBoatBuildingStation(player);
		if (!((Object)(object)currentBoatBuildingStation == (Object)null))
		{
			BoatBuildingStation.LogBuildingEvent(((Component)this).transform.position, player, null, "Edit boat requested from steering wheel.");
			if (currentBoatBuildingStation.CanEnterEditMode(player, sendErrorToasts: true))
			{
				currentBoatBuildingStation.EnterEditMode();
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public void RequestDeployAndEditBoat(RPCMessage msg)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			PlayerBoat parentBoat = GetParentBoat();
			if (!((Object)(object)parentBoat == (Object)null))
			{
				BoatBuildingStation.LogBuildingEvent(((Component)this).transform.position, player, parentBoat, "Deploy and Edit requested via steering wheel.");
				parentBoat.DeployAndEdit(msg.player);
			}
		}
	}

	public override void Hurt(HitInfo info)
	{
		PlayerBoat parentPlayerBoat = PlayerBoat.GetParentPlayerBoat(this);
		if ((Object)(object)parentPlayerBoat != (Object)null)
		{
			parentPlayerBoat.OnBoatDeployableHurt(this, info);
		}
		else
		{
			base.Hurt(info);
		}
	}

	[RPC_Server]
	[RPC_Server.InputValidation(new Type[] { typeof(float) })]
	[RPC_Server.CallsPerSecond(15uL)]
	[RPC_Server.IsVisible(3f)]
	public void ReceiveClientRotation(RPCMessage msg)
	{
		if (!((Object)(object)msg.player == (Object)null) && !((Object)(object)GetMounted() != (Object)(object)msg.player) && !((Object)(object)ParentBoat == (Object)null))
		{
			float num2 = (ServerSteeringRotation = msg.read.Float());
			ParentBoat.steering = Mathx.RemapValClamped(num2, -170f, 170f, 1f, -1f);
		}
	}

	public void ResetSteering()
	{
		ServerSteeringRotation = 0f;
		ParentBoat.steering = 0f;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if ((Object)(object)ParentBoat != (Object)null)
		{
			ParentBoat.ResetTimeSinceUsed();
		}
	}

	void IBoatBuildingPiece.OnAddedToBoat(PlayerBoat boat)
	{
		ParentBoat = boat;
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (base.ShouldDisplayPickupOption(player))
		{
			return !PlayerBoat.IsChildOfInteractablePlayerBoat(this);
		}
		return false;
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (id == 0)
		{
			if (Global.developer > 2)
			{
				NetworkableId iD = net.ID;
				Debug.Log((object)("SyncVar Writing: ServerSteeringRotation for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_ServerSteeringRotation);
			return true;
		}
		return base.WriteSyncVar(id, writer);
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		if (id == 0)
		{
			try
			{
				_ = __sync_ServerSteeringRotation;
				float _sync_ServerSteeringRotation = reader.Float();
				__sync_ServerSteeringRotation = _sync_ServerSteeringRotation;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			return true;
		}
		return base.OnSyncVar(id, reader, fromAutoSave);
	}

	private byte __GetWeaverID(string propertyName)
	{
		if (propertyName == "ServerSteeringRotation")
		{
			return 0;
		}
		return byte.MaxValue;
	}

	protected override void WriteAutoSaveSyncVars(NetWrite writer)
	{
		base.WriteAutoSaveSyncVars(writer);
		WriteSyncVar(0, writer);
	}

	protected override void ReadAutoSaveSyncVars(NetRead reader)
	{
		base.ReadAutoSaveSyncVars(reader);
		OnSyncVar(0, reader, fromAutoSave: true);
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		base.AutoSaveSyncVars(save);
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteAutoSaveSyncVars(val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		base.AutoLoadSyncVars(load);
		if (load.msg.baseEntity != null && load.msg.baseEntity.syncVars != null)
		{
			NetRead val = Pool.Get<NetRead>();
			val.Init(load.msg.baseEntity.syncVars.AsSpan());
			ReadAutoSaveSyncVars(val);
			Pool.Free<NetRead>(ref val);
		}
		return true;
	}

	protected override void ResetSyncVars()
	{
		base.ResetSyncVars();
		__sync_ServerSteeringRotation = 0f;
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		if (id == 0)
		{
			return true;
		}
		return base.ShouldInvalidateCache(id);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class StorageContainer : DecayEntity, IItemContainerEntity, IIdealSlotEntity, ILootableEntity, IInventoryProvider, LootPanel.IHasLootPanel, IContainerSounds, IIndustrialStorageCallbackReceiver, PlayerInventory.ICanMoveFrom
{
	[Header("Storage Container")]
	public static readonly Phrase LockedMessage = new Phrase("storage.locked", "Can't loot right now");

	public static readonly Phrase InUseMessage = new Phrase("storage.in_use", "Already in use");

	public int inventorySlots = 6;

	public bool dropsLoot = true;

	public float dropLootDestroyPercent;

	public bool dropFloats;

	public bool isLootable = true;

	public bool isLockable = true;

	public bool isMonitorable;

	public string panelName = "generic";

	public Phrase panelTitle = new Phrase("loot", "Loot");

	public ItemContainer.ContentsType allowedContents;

	public ItemDefinition allowedItem;

	public ItemDefinition allowedItem2;

	public ItemDefinition[] allowedItems;

	public ItemDefinition[] blockedItems;

	public int maxStackSize;

	public bool needsBuildingPrivilegeToUse;

	public bool requireAuthIfNotLocked;

	public bool allowSorting;

	[ServerVar]
	public static bool canRequireAuthIfNoLock = false;

	public bool mustBeMountedToUse;

	public SoundDefinition openSound;

	public SoundDefinition closeSound;

	[Header("Item Dropping")]
	public Vector3 dropPosition;

	public Vector3 dropVelocity = Vector3.forward;

	public ItemCategory onlyAcceptCategory = ItemCategory.All;

	public bool onlyOneUser;

	[ServerVar]
	public static bool dropCorpseOnDeath;

	[ServerVar]
	public static float corpseItemsSavedPercent = 0.5f;

	public ItemContainer _inventory;

	public bool isTransferringIndustrialItem;

	private bool triggerInventoryDirty;

	private IndustrialStorageAdaptor cachedAdaptor;

	public Phrase LootPanelTitle => panelTitle;

	public ItemContainer inventory => _inventory;

	public Transform Transform => ((Component)this).transform;

	public bool DropsLoot => dropsLoot;

	public bool DropFloats => dropFloats;

	public float DestroyLootPercent
	{
		get
		{
			if (!ShouldDropDeployableCorpse(lastAttacker, lastDamage))
			{
				return dropLootDestroyPercent;
			}
			return 0f;
		}
	}

	public ulong LastLootedBy { get; set; }

	public BasePlayer LastLootedByPlayer { get; set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StorageContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.yellow;
		Gizmos.DrawCube(dropPosition, Vector3.one * 0.1f);
		Gizmos.color = Color.white;
		Gizmos.DrawRay(dropPosition, dropVelocity);
	}

	public override bool HasSlot(Slot slot)
	{
		if (isLockable && slot == Slot.Lock)
		{
			return true;
		}
		if (isMonitorable && slot == Slot.StorageMonitor)
		{
			return true;
		}
		return base.HasSlot(slot);
	}

	public bool MoveAllInventoryItems(ItemContainer from)
	{
		return MoveAllInventoryItems(from, _inventory);
	}

	public static bool MoveAllInventoryItems(ItemContainer source, ItemContainer dest)
	{
		bool flag = true;
		for (int i = 0; i < Mathf.Min(source.capacity, dest.capacity); i++)
		{
			Item slot = source.GetSlot(i);
			if (slot != null)
			{
				bool flag2 = slot.MoveToContainer(dest);
				if (flag && !flag2)
				{
					flag = false;
				}
			}
		}
		return flag;
	}

	public virtual void ReceiveInventoryFromItem(Item item)
	{
		if (item.contents != null)
		{
			MoveAllInventoryItems(item.contents, _inventory);
		}
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		bool num = (Object)(object)GetSlot(Slot.Lock) != (Object)null;
		pickupErrorToFormat.arg0 = pickup.itemTarget.displayName;
		if (num)
		{
			pickupErrorToFormat.format = PickupErrors.ItemHasLock;
			return false;
		}
		if (pickup.requireEmptyInv && _inventory != null && !inventory.IsEmpty())
		{
			pickupErrorToFormat.format = PickupErrors.ItemInventoryMustBeEmpty;
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public override void OnPickedUp(Item createdItem, BasePlayer player)
	{
		base.OnPickedUp(createdItem, player);
		if (createdItem != null && createdItem.contents != null)
		{
			MoveAllInventoryItems(_inventory, createdItem.contents);
			return;
		}
		for (int i = 0; i < _inventory.capacity; i++)
		{
			Item slot = _inventory.GetSlot(i);
			if (slot != null)
			{
				slot.RemoveFromContainer();
				player.GiveItem(slot, GiveItemReason.PickedUp);
			}
		}
	}

	public override void ServerInit()
	{
		if (_inventory == null)
		{
			CreateInventory(giveUID: true);
			OnInventoryFirstCreated(_inventory);
		}
		else
		{
			_inventory.SetBlacklist(blockedItems);
		}
		base.ServerInit();
	}

	public virtual void OnInventoryFirstCreated(ItemContainer container)
	{
	}

	public virtual void OnItemAddedOrRemoved(Item item, bool added)
	{
	}

	public virtual void OnItemAddedToStack(Item item, int amount)
	{
	}

	public virtual void OnItemRemovedFromStack(Item item, int amount)
	{
	}

	public virtual void OnItemPositionChanged(Item item, int from, int to)
	{
	}

	public virtual bool ItemFilter(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("OnItemFilter", (object)item, (object)this, (object)targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (onlyAcceptCategory == ItemCategory.All)
		{
			return true;
		}
		return item.info.category == onlyAcceptCategory;
	}

	public void CreateInventory(bool giveUID)
	{
		Debug.Assert(_inventory == null, "Double init of inventory!");
		_inventory = Pool.Get<ItemContainer>();
		_inventory.entityOwner = this;
		_inventory.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
		_inventory.SetOnlyAllowedItems(allowedItems, allowedItem, allowedItem2);
		_inventory.SetBlacklist(blockedItems);
		_inventory.maxStackSize = maxStackSize;
		_inventory.ServerInitialize(null, inventorySlots);
		if (giveUID)
		{
			_inventory.GiveUID();
		}
		_inventory.onDirty += OnInventoryDirty;
		_inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
		_inventory.onItemAddedToStack = OnItemAddedToStack;
		_inventory.onItemRemovedFromStack = OnItemRemovedFromStack;
		_inventory.onItemPositionChanged = OnItemPositionChanged;
		_inventory.canAcceptItem = ItemFilter;
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		CreateInventory(giveUID: false);
	}

	public void OnIndustrialItemTransferBegins()
	{
		isTransferringIndustrialItem = true;
		triggerInventoryDirty = false;
	}

	public void OnIndustrialItemTransferEnd()
	{
		isTransferringIndustrialItem = false;
		if (triggerInventoryDirty)
		{
			OnInventoryDirty();
		}
	}

	protected virtual void OnInventoryDirty()
	{
		if (isTransferringIndustrialItem)
		{
			triggerInventoryDirty = true;
			return;
		}
		if (HasAttachedStorageAdaptor(out var adaptor))
		{
			adaptor.RequestSort();
		}
		InvalidateNetworkCache();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (_inventory != null && !((ItemContainerId)(ref _inventory.uid)).IsValid)
		{
			_inventory.GiveUID();
		}
		SetFlag(Flags.Open, b: false);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (_inventory != null)
		{
			Pool.Free<ItemContainer>(ref _inventory);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (isLootable)
		{
			BasePlayer player = rpc.player;
			if (Object.op_Implicit((Object)(object)player) && player.CanInteract())
			{
				PlayerOpenLoot(player);
			}
		}
	}

	public virtual string GetPanelName()
	{
		return panelName;
	}

	public virtual PlayerInventory.CanMoveFromResponse CanMoveFrom(BasePlayer player, Item item)
	{
		return new PlayerInventory.CanMoveFromResponse(!_inventory.IsLocked(), PlayerInventoryErrors.ContainerLocked);
	}

	public virtual bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		if (!CanBeLooted(player))
		{
			return false;
		}
		BaseLock @lock = GetLock();
		if ((Object)(object)@lock != (Object)null && !@lock.OnTryToOpen(player))
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
			return false;
		}
		return true;
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if ((needsBuildingPrivilegeToUse || ShouldRequireAuthIfNoCodelock(this, requireAuthIfNotLocked)) && !player.CanBuild())
		{
			return false;
		}
		if (mustBeMountedToUse && !player.isMounted)
		{
			return false;
		}
		return base.CanBeLooted(player);
	}

	public virtual void AddContainers(PlayerLoot loot)
	{
		loot.AddContainer(_inventory);
	}

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", (object)player, (object)this) != null)
		{
			return false;
		}
		if (IsLocked() || IsTransferring())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, LockedMessage, false);
			return false;
		}
		if (onlyOneUser && IsOpen())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, InUseMessage, false);
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = panelName;
		}
		if (!CanOpenLootPanel(player, panelToOpen))
		{
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			AddContainers(player.inventory.loot);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), panelToOpen);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", (object)player, (object)this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if (_inventory != null)
			{
				info.msg.storageBox = Pool.Get<StorageBox>();
				info.msg.storageBox.contents = _inventory.Save();
			}
			else
			{
				Debug.LogWarning((object)("Storage container without inventory: " + ((object)this).ToString()));
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		DropItems(info?.Initiator);
		base.OnDied(info);
	}

	public override void OnDeployableCorpseSpawned(BaseEntity corpse)
	{
		base.OnDeployableCorpseSpawned(corpse);
		if (corpse is ContainerCorpse containerCorpse)
		{
			containerCorpse.TakeFrom(new ItemContainer[1] { inventory }, corpseItemsSavedPercent);
		}
	}

	public virtual void DropItems(BaseEntity initiator = null)
	{
		DropItems(this, initiator);
	}

	public static void DropItems(IItemContainerEntity containerEntity, BaseEntity initiator = null)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		ItemContainer itemContainer = containerEntity.inventory;
		if (itemContainer == null || itemContainer.itemList == null || itemContainer.itemList.Count == 0 || !containerEntity.DropsLoot)
		{
			return;
		}
		if (containerEntity.ShouldDropItemsIndividually() || (itemContainer.itemList.Count == 1 && !containerEntity.DropFloats))
		{
			if ((Object)(object)initiator != (Object)null)
			{
				containerEntity.DropBonusItems(initiator, itemContainer);
			}
			DropUtil.DropItems(itemContainer, containerEntity.GetDropPosition());
		}
		else
		{
			string prefab = (containerEntity.DropFloats ? "assets/prefabs/misc/item drop/item_drop_buoyant.prefab" : "assets/prefabs/misc/item drop/item_drop.prefab");
			_ = (Object)(object)itemContainer.Drop(prefab, containerEntity.GetDropPosition(), containerEntity.Transform.rotation, containerEntity.DestroyLootPercent) != (Object)null;
		}
	}

	public virtual void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
	}

	public override Vector3 GetDropPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		return ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint(dropPosition);
	}

	public override Vector3 GetDropVelocity()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 inheritedDropVelocity = GetInheritedDropVelocity();
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		return inheritedDropVelocity + ((Matrix4x4)(ref localToWorldMatrix)).MultiplyVector(dropPosition);
	}

	public virtual bool ShouldDropItemsIndividually()
	{
		return false;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.storageBox != null)
		{
			if (_inventory != null)
			{
				_inventory.Load(info.msg.storageBox.contents);
				_inventory.capacity = inventorySlots;
			}
			else
			{
				Debug.LogWarning((object)("Storage container without inventory: " + ((object)this).ToString()));
			}
		}
	}

	public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return -1;
	}

	public virtual ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return default(ItemContainerId);
	}

	public virtual void GetAllInventories(List<ItemContainer> list)
	{
		list.Add(inventory);
	}

	public static bool ShouldRequireAuthIfNoCodelock(BaseEntity container, bool containerRequiresAuth)
	{
		if (canRequireAuthIfNoLock && containerRequiresAuth)
		{
			return (Object)(object)container.GetLock() == (Object)null;
		}
		return false;
	}

	public bool OccupiedCheck(BasePlayer player = null)
	{
		if ((Object)(object)player != (Object)null && (Object)(object)player.inventory.loot.entitySource == (Object)(object)this)
		{
			return true;
		}
		if (onlyOneUser)
		{
			return !IsOpen();
		}
		return true;
	}

	protected bool HasAttachedStorageAdaptor()
	{
		if (children == null)
		{
			return false;
		}
		foreach (BaseEntity child in children)
		{
			if (child is IndustrialStorageAdaptor)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasAttachedStorageAdaptor(out IndustrialStorageAdaptor adaptor)
	{
		TimeWarning val = TimeWarning.New("HasAttachedStorageAdaptor", 0);
		try
		{
			if ((Object)(object)cachedAdaptor != (Object)null)
			{
				adaptor = cachedAdaptor;
				return true;
			}
			adaptor = null;
			if (children == null)
			{
				return false;
			}
			foreach (BaseEntity child in children)
			{
				if (child is IndustrialStorageAdaptor industrialStorageAdaptor)
				{
					adaptor = industrialStorageAdaptor;
					cachedAdaptor = industrialStorageAdaptor;
					return true;
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected bool HasAttachedStorageMonitor()
	{
		if (children == null)
		{
			return false;
		}
		foreach (BaseEntity child in children)
		{
			if (child is StorageMonitor)
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class StringLights : IOEntity
{
	public struct PointEntry
	{
		public Vector3 point;

		public Vector3 normal;

		public float slack;
	}

	[Serializable]
	public struct BulbSettings
	{
		public GameObjectRef BulbPrefab;

		public float Weight;
	}

	[SerializeField]
	private float lengthPerAmount = 0.5f;

	[SerializeField]
	private float maxPlaceDistance = 5f;

	[SerializeField]
	private ItemDefinition itemToConsume;

	[Header("Line Generation Settings")]
	[SerializeField]
	protected BulbSettings[] bulbSettings;

	[SerializeField]
	private GameObjectRef pointLightPrefab;

	[SerializeField]
	private Transform lightsParent;

	[SerializeField]
	private Transform wireOrigin;

	[SerializeField]
	protected float bulbSpacing = 0.25f;

	[SerializeField]
	protected float wireThickness = 0.02f;

	[SerializeField]
	protected float maxDeviation = 0.25f;

	[SerializeField]
	protected float deviationFactor = 1f;

	[SerializeField]
	protected bool bulbFaceNormal;

	[Space]
	[SerializeField]
	protected LineRenderer lineRenderer;

	[SerializeField]
	protected RendererLOD rendererLod;

	protected readonly List<PointEntry> points = new List<PointEntry>();

	protected readonly List<StringLightsBulb> bulbs = new List<StringLightsBulb>();

	protected readonly List<Light> pointLights = new List<Light>();

	private readonly Dictionary<int, GameObject> prefabLookup = new Dictionary<int, GameObject>();

	public bool useBatching;

	protected List<StringLightsBulb> lastBatchedMeshes = new List<StringLightsBulb>();

	private int lengthUsed;

	private const Flags Flag_Used = Flags.Reserved5;

	private const int PLACEMENT_LAYER = 1084293121;

	private BasePlayer usingPlayer;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StringLights.OnRpcMessage", 0);
		try
		{
			if (rpc == 4045900594u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_AddPoint "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_AddPoint", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4045900594u, "SERVER_AddPoint", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_AddPoint(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_AddPoint");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3733663691u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RemovePoint "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RemovePoint", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3733663691u, "SERVER_RemovePoint", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_RemovePoint(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_RemovePoint");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2400039444u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_StartDeploying "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_StartDeploying", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2400039444u, "SERVER_StartDeploying", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SERVER_StartDeploying(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SERVER_StartDeploying");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2702400742u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_StopDeploying "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_StopDeploying", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2702400742u, "SERVER_StopDeploying", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							SERVER_StopDeploying(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in SERVER_StopDeploying");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsUsed()
	{
		return HasFlag(Flags.Reserved5);
	}

	public void ClearPoints()
	{
		points.Clear();
	}

	public void AddPoint(Vector3 newPoint, Vector3 newNormal, float slackLevel, bool addFirstPoint = true)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (addFirstPoint && base.isServer && points.Count == 0)
		{
			PointEntry item = default(PointEntry);
			item.point = wireOrigin.position;
			item.normal = newNormal;
			item.slack = slackLevel;
			points.Add(item);
		}
		PointEntry item2 = default(PointEntry);
		item2.point = newPoint;
		item2.normal = newNormal;
		item2.slack = slackLevel;
		points.Add(item2);
	}

	public void RemoveLastPoint()
	{
		points.RemoveAt(points.Count - 1);
		if (points.Count == 1)
		{
			points.Clear();
		}
	}

	public override int ConsumptionAmount()
	{
		return 5;
	}

	protected override int GetPickupCount()
	{
		return Mathf.Max(lengthUsed, 1);
	}

	public void AddLengthUsed(int addLength)
	{
		lengthUsed += addLength;
	}

	public static bool CanPlayerUse(BasePlayer player)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (player.CanBuild())
		{
			return !GamePhysics.CheckSphere(player.eyes.position, 0.1f, 536870912, (QueryTriggerInteraction)2);
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.lightString = Pool.Get<LightString>();
		info.msg.lightString.points = Pool.GetList<StringPoint>();
		info.msg.lightString.lengthUsed = lengthUsed;
		foreach (PointEntry point in points)
		{
			StringPoint val = Pool.Get<StringPoint>();
			val.point = point.point;
			val.normal = point.normal;
			val.slack = point.slack;
			info.msg.lightString.points.Add(val);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.lightString == null)
		{
			return;
		}
		ClearPoints();
		foreach (StringPoint point in info.msg.lightString.points)
		{
			AddPoint(point.point, point.normal, point.slack, addFirstPoint: false);
		}
		lengthUsed = info.msg.lightString.lengthUsed;
	}

	protected Item GetOwnerItem()
	{
		BasePlayer basePlayer = null;
		if (base.isServer)
		{
			basePlayer = usingPlayer;
		}
		if ((Object)(object)basePlayer == (Object)null || (Object)(object)basePlayer.inventory == (Object)null)
		{
			return null;
		}
		return basePlayer.inventory.FindItemByItemID(itemToConsume.itemid);
	}

	public override Item GetItem()
	{
		return GetOwnerItem();
	}

	private bool CheckValidPlacement(Vector3 position, float radius, int layerMask)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		bool result = true;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, radius, list, layerMask, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (item is AnimatedBuildingBlock)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		if (base.isServer)
		{
			lengthUsed = 1;
			PlayerStartsDeploying(deployedBy);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SERVER_StartDeploying(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsUsed() && player.CanBuild())
		{
			PlayerStartsDeploying(player);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SERVER_StopDeploying(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.CanBuild())
		{
			PlayerStopsDeploying(player);
		}
	}

	public void PlayerStartsDeploying(BasePlayer player)
	{
		if (!IsUsed() && !((Object)(object)player == (Object)null))
		{
			usingPlayer = player;
			SetFlag(Flags.Reserved5, b: true);
			if (((FacepunchBehaviour)this).IsInvoking((Action)ServerWireDeployingTick))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ServerWireDeployingTick);
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)ServerWireDeployingTick, 0f, 0f);
			ClientRPC(RpcTarget.Player("CLIENT_StartDeploying", player));
		}
	}

	public void PlayerStopsDeploying(BasePlayer player)
	{
		usingPlayer = null;
		SetFlag(Flags.Reserved5, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ServerWireDeployingTick);
		ClientRPC(RpcTarget.Player("CLIENT_StopDeploying", player));
	}

	public void ServerWireDeployingTick()
	{
		if (!usingPlayer.IsValid() || !usingPlayer.IsConnected)
		{
			PlayerStopsDeploying(usingPlayer);
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public void SERVER_AddPoint(RPCMessage msg)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = msg.read.Vector3();
		Vector3 val2 = msg.read.Vector3();
		float num = msg.read.Float();
		BasePlayer player = msg.player;
		if (Vector3Ex.IsNaNOrInfinity(val) || Vector3Ex.IsNaNOrInfinity(val2) || FloatEx.IsNaNOrInfinity(num))
		{
			return;
		}
		Item item = GetItem();
		if (item != null && item.amount >= 1 && CanPlayerUse(player) && !(Vector3.Distance(val, player.eyes.position) > maxPlaceDistance) && CheckValidPlacement(val, 0.1f, 1084293121) && Interface.CallHook("OnPoweredLightsPointAdd", (object)this, (object)player, (object)val, (object)val2) == null)
		{
			int num2 = 1;
			float num3 = 0f;
			Vector3 val3 = ((points.Count > 0) ? points[points.Count - 1].point : wireOrigin.position);
			num3 = Vector3.Distance(val, val3);
			num3 = Mathf.Max(num3, lengthPerAmount);
			float num4 = (float)item.amount * lengthPerAmount;
			if (player.IsInCreativeMode && Creative.unlimitedIo)
			{
				num4 = 200f;
			}
			if (num3 > num4)
			{
				num3 = num4;
				val = val3 + Vector3Ex.Direction(val, val3) * num3;
			}
			num3 = Mathf.Min(num4, num3);
			num2 = Mathf.CeilToInt(num3 / lengthPerAmount);
			if (player.IsInCreativeMode && Creative.unlimitedIo)
			{
				num2 = 0;
			}
			AddPoint(val, val2, num);
			UseItemAmount(num2);
			AddLengthUsed(num2);
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public void SERVER_RemovePoint(RPCMessage msg)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (CanPlayerUse(player) && points.Count != 0)
		{
			Vector3 point = points[points.Count - 1].point;
			Vector3 val = ((Component)this).transform.position;
			if (points.Count > 1)
			{
				val = points[points.Count - 2].point;
			}
			int num = Mathf.CeilToInt(Vector3.Distance(point, val) / lengthPerAmount);
			RemoveLastPoint();
			if (!player.IsInCreativeMode || !Creative.unlimitedIo)
			{
				GiveItemAmount(player, num);
				AddLengthUsed(-num);
			}
			SendNetworkUpdate();
		}
	}

	private void GiveItemAmount(BasePlayer player, int amount)
	{
		if (amount > 0)
		{
			Item ownerItem = GetOwnerItem();
			if (ownerItem == null)
			{
				ownerItem = ItemManager.Create(itemToConsume, amount, 0uL);
				player.GiveItem(ownerItem, GiveItemReason.PickedUp);
			}
			else
			{
				ownerItem.amount += amount;
				ownerItem.MarkDirty();
				ownerItem.ReduceItemOwnership(amount);
			}
		}
	}

	protected void UseItemAmount(int amount)
	{
		if (amount <= 0)
		{
			return;
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			ownerItem.amount -= amount;
			ownerItem.MarkDirty();
			ownerItem.ReduceItemOwnership(amount);
			if (ownerItem.amount <= 0)
			{
				ownerItem.Remove();
			}
		}
	}
}


using UnityEngine;

public struct PointEntry
{
	public Vector3 point;

	public Vector3 normal;

	public float slack;
}


using System;

[Serializable]
public struct BulbSettings
{
	public GameObjectRef BulbPrefab;

	public float Weight;
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class SurveyCrater : BaseCombatEntity
{
	private ResourceDispenser resourceDispenser;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SurveyCrater.OnRpcMessage", 0);
		try
		{
			if (rpc == 3491246334u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AnalysisComplete "));
				}
				TimeWarning val2 = TimeWarning.New("AnalysisComplete", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						AnalysisComplete(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in AnalysisComplete");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 1800f);
	}

	public override void OnAttacked(HitInfo info)
	{
		_ = base.isServer;
		base.OnAttacked(info);
	}

	public void RemoveMe()
	{
		Kill();
	}

	[RPC_Server]
	public void AnalysisComplete(RPCMessage msg)
	{
		Interface.CallHook("OnAnalysisComplete", (object)this, (object)msg.player);
	}

	public override float AntiHackPadding()
	{
		return 2f;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Telephone : ContainerIOEntity, ICassettePlayer
{
	public enum CallState
	{
		Idle,
		Dialing,
		Ringing,
		InProcess
	}

	public enum DialFailReason
	{
		TimedOut,
		Engaged,
		WrongNumber,
		CallSelf,
		RemoteHangUp,
		NetworkBusy,
		TimeOutDuringCall,
		SelfHangUp
	}

	public const int MaxPhoneNameLength = 30;

	public const int MaxSavedNumbers = 10;

	public Transform PhoneHotspot;

	public Transform AnsweringMachineHotspot;

	public Transform[] HandsetRoots;

	public ItemDefinition[] ValidCassettes;

	public Transform ParentedHandsetTransform;

	public LineRenderer CableLineRenderer;

	public Transform CableStartPoint;

	public Transform CableEndPoint;

	public float LineDroopAmount = 0.25f;

	public PhoneController Controller;

	public Cassette cachedCassette { get; private set; }

	public BaseEntity ToBaseEntity => this;

	public uint AnsweringMessageId
	{
		get
		{
			if (!((Object)(object)cachedCassette != (Object)null))
			{
				return 0u;
			}
			return cachedCassette.AudioId;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Telephone.OnRpcMessage", 0);
		try
		{
			if (rpc == 1529322558 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AnswerPhone "));
				}
				TimeWarning val2 = TimeWarning.New("AnswerPhone", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1529322558u, "AnswerPhone", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AnswerPhone(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AnswerPhone");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2754362156u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearCurrentUser "));
				}
				TimeWarning val2 = TimeWarning.New("ClearCurrentUser", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2754362156u, "ClearCurrentUser", this, player, 9f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ClearCurrentUser(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ClearCurrentUser");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1095090232 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - InitiateCall "));
				}
				TimeWarning val2 = TimeWarning.New("InitiateCall", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1095090232u, "InitiateCall", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							InitiateCall(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in InitiateCall");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2606442785u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AddSavedNumber "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AddSavedNumber", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2606442785u, "Server_AddSavedNumber", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2606442785u, "Server_AddSavedNumber", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							Server_AddSavedNumber(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in Server_AddSavedNumber");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1402406333 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RemoveSavedNumber "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RemoveSavedNumber", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1402406333u, "Server_RemoveSavedNumber", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1402406333u, "Server_RemoveSavedNumber", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							Server_RemoveSavedNumber(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in Server_RemoveSavedNumber");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 942544266 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestPhoneDirectory "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestPhoneDirectory", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(942544266u, "Server_RequestPhoneDirectory", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(942544266u, "Server_RequestPhoneDirectory", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							Server_RequestPhoneDirectory(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in Server_RequestPhoneDirectory");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1240133378 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerDeleteVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerDeleteVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1240133378u, "ServerDeleteVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1240133378u, "ServerDeleteVoicemail", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							ServerDeleteVoicemail(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in ServerDeleteVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1221129498 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerHangUp "));
				}
				TimeWarning val2 = TimeWarning.New("ServerHangUp", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg9 = rPCMessage;
						ServerHangUp(msg9);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex8)
				{
					Debug.LogException(ex8);
					player.Kick("RPC Error in ServerHangUp");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 239260010 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerPlayVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerPlayVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(239260010u, "ServerPlayVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(239260010u, "ServerPlayVoicemail", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg10 = rPCMessage;
							ServerPlayVoicemail(msg10);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in ServerPlayVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 189198880 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSendVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSendVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(189198880u, "ServerSendVoicemail", this, player, 5uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg11 = rPCMessage;
							ServerSendVoicemail(msg11);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogException(ex10);
						player.Kick("RPC Error in ServerSendVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2760189029u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerStopVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerStopVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2760189029u, "ServerStopVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2760189029u, "ServerStopVoicemail", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg12 = rPCMessage;
							ServerStopVoicemail(msg12);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogException(ex11);
						player.Kick("RPC Error in ServerStopVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3900772076u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetCurrentUser "));
				}
				TimeWarning val2 = TimeWarning.New("SetCurrentUser", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3900772076u, "SetCurrentUser", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage currentUser = rPCMessage;
							SetCurrentUser(currentUser);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex12)
					{
						Debug.LogException(ex12);
						player.Kick("RPC Error in SetCurrentUser");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2760249627u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdatePhoneName "));
				}
				TimeWarning val2 = TimeWarning.New("UpdatePhoneName", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2760249627u, "UpdatePhoneName", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2760249627u, "UpdatePhoneName", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg13 = rPCMessage;
							UpdatePhoneName(msg13);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex13)
					{
						Debug.LogException(ex13);
						player.Kick("RPC Error in UpdatePhoneName");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg?.telephone == null)
		{
			return;
		}
		Controller.PhoneNumber = info.msg.telephone.phoneNumber;
		Controller.PhoneName = info.msg.telephone.phoneName;
		Controller.lastDialedNumber = info.msg.telephone.lastNumber;
		Controller.savedVoicemail = Pool.Get<List<VoicemailEntry>>();
		foreach (VoicemailEntry item in info.msg.telephone.voicemail)
		{
			Controller.savedVoicemail.Add(item);
			item.ShouldPool = false;
		}
		if (!info.fromDisk)
		{
			Controller.currentPlayerRef.uid = info.msg.telephone.usingPlayer;
		}
		PhoneDirectory savedNumbers = Controller.savedNumbers;
		if (savedNumbers != null)
		{
			savedNumbers.ResetToPool();
		}
		Controller.savedNumbers = info.msg.telephone.savedNumbers;
		if (Controller.savedNumbers != null)
		{
			Controller.savedNumbers.ShouldPool = false;
		}
		if (info.fromDisk)
		{
			SetFlag(Flags.Busy, b: false);
		}
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if ((Object)(object)Controller.currentPlayer != (Object)null)
		{
			pickupErrorToFormat = (format: PickupErrors.ItemIsBeingUsed, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			if (Controller.RequirePower && next.HasFlag(Flags.Busy) && !next.HasFlag(Flags.Reserved8))
			{
				Controller.ServerHangUp();
			}
			if (old.HasFlag(Flags.Busy) != next.HasFlag(Flags.Busy))
			{
				if (next.HasFlag(Flags.Busy))
				{
					if (!((FacepunchBehaviour)this).IsInvoking((Action)Controller.WatchForDisconnects))
					{
						((FacepunchBehaviour)this).InvokeRepeating((Action)Controller.WatchForDisconnects, 0f, 0.1f);
					}
				}
				else
				{
					((FacepunchBehaviour)this).CancelInvoke((Action)Controller.WatchForDisconnects);
				}
			}
		}
		Controller.OnFlagsChanged(old, next);
	}

	public override void Save(SaveInfo info)
	{
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.telephone == null)
		{
			info.msg.telephone = Pool.Get<Telephone>();
		}
		info.msg.telephone.phoneNumber = Controller.PhoneNumber;
		info.msg.telephone.phoneName = Controller.PhoneName;
		info.msg.telephone.lastNumber = Controller.lastDialedNumber;
		info.msg.telephone.savedNumbers = Controller.savedNumbers;
		if (Controller.savedVoicemail != null)
		{
			info.msg.telephone.voicemail = Pool.Get<List<VoicemailEntry>>();
			foreach (VoicemailEntry item in Controller.savedVoicemail)
			{
				info.msg.telephone.voicemail.Add(item);
			}
		}
		if (!info.forDisk)
		{
			info.msg.telephone.usingPlayer = Controller.currentPlayerRef.uid;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Controller.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Controller.PostServerLoad();
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Controller.DoServerDestroy();
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(9f)]
	public void ClearCurrentUser(RPCMessage msg)
	{
		Controller.ClearCurrentUser(msg);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void SetCurrentUser(RPCMessage msg)
	{
		Controller.SetCurrentUser(msg);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void InitiateCall(RPCMessage msg)
	{
		Controller.InitiateCall(msg);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void AnswerPhone(RPCMessage msg)
	{
		Controller.AnswerPhone(msg);
	}

	[RPC_Server]
	private void ServerHangUp(RPCMessage msg)
	{
		Controller.ServerHangUp(msg);
	}

	public void OnCassetteInserted(Cassette c)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		cachedCassette = c;
		ClientRPC(RpcTarget.NetworkGroup("ClientOnCassetteChanged"), c.net.ID);
	}

	public void OnCassetteRemoved(Cassette c)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		cachedCassette = null;
		Controller.DeleteAllVoicemail();
		((BaseEntity)this).ClientRPC(RpcTarget.NetworkGroup("ClientOnCassetteChanged"), default(NetworkableId));
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		ItemDefinition[] validCassettes = ValidCassettes;
		for (int i = 0; i < validCassettes.Length; i++)
		{
			if ((Object)(object)validCassettes[i] == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void UpdatePhoneName(RPCMessage msg)
	{
		Controller.UpdatePhoneName(msg);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void Server_RequestPhoneDirectory(RPCMessage msg)
	{
		Controller.Server_RequestPhoneDirectory(msg);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(3f)]
	public void Server_AddSavedNumber(RPCMessage msg)
	{
		Controller.Server_AddSavedNumber(msg);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void Server_RemoveSavedNumber(RPCMessage msg)
	{
		Controller.Server_RemoveSavedNumber(msg);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void ServerSendVoicemail(RPCMessage msg)
	{
		Controller.ServerSendVoicemail(msg);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void ServerPlayVoicemail(RPCMessage msg)
	{
		Controller.ServerPlayVoicemail(msg);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void ServerStopVoicemail(RPCMessage msg)
	{
		Controller.ServerStopVoicemail(msg);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void ServerDeleteVoicemail(RPCMessage msg)
	{
		Controller.ServerDeleteVoicemail(msg);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (Controller.serverState == CallState.Ringing || Controller.serverState == CallState.InProcess)
		{
			return base.GetPassthroughAmount(outputSlot);
		}
		return 0;
	}
}


public enum CallState
{
	Idle,
	Dialing,
	Ringing,
	InProcess
}


public enum DialFailReason
{
	TimedOut,
	Engaged,
	WrongNumber,
	CallSelf,
	RemoteHangUp,
	NetworkBusy,
	TimeOutDuringCall,
	SelfHangUp
}


using System;
using Network;
using Rust.Demo;
using UnityEngine;

public class ThrownBoomerang : BaseEntity
{
	[Header("References")]
	public ItemDefinition boomerangItem;

	[Header("Settings")]
	public float timeToReturnOnArc = 3f;

	public float secondsUntilStartArc = 0.9f;

	public float lerpSpeed = 20f;

	private const float CATCH_DISTANCE = 1.5f;

	private const float HOMING_TO_PLAYER_DISTANCE = 6f;

	private Vector3 lastMoveDirection;

	private Vector3 gravityVelocity = Vector3.zero;

	private bool calculated;

	private float returnTimer;

	private float timeToReturn;

	private Vector3 startLocation;

	private Vector3 midLocation;

	private Vector3 endLocation;

	private Vector3 spawnLocation = Vector3.zero;

	private ThrownBoomerangServerProjectile projectile;

	private BasePlayer creatorPlayer;

	private Boomerang originEntityItem;

	[NonSerialized]
	public ItemOwnershipShare ItemOwnership;

	[NonSerialized]
	public float Condition;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ThrownBoomerang.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private void DoBoomerangMove()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		if (Reader.IsActive && Reader.Active.IsScrubbing)
		{
			return;
		}
		float deltaTime = Time.deltaTime;
		float num = 15f;
		Vector3 val;
		if (!calculated)
		{
			returnTimer = 0f;
			startLocation = ((Component)this).transform.position;
			endLocation = spawnLocation;
			endLocation += Vector3.up * 1.2f;
			val = endLocation - startLocation;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			Vector3 val2 = Vector3.Cross(Vector3.up, normalized);
			midLocation = (startLocation + endLocation) / 2f;
			midLocation += val2 * num;
			if (base.isServer)
			{
				projectile.ProjectileHandleMovement(state: false);
			}
			calculated = true;
		}
		BasePlayer basePlayer = null;
		if (base.isServer)
		{
			basePlayer = creatorPlayer;
		}
		if ((Object)(object)basePlayer != (Object)null && Vector3.Distance(((Component)basePlayer).transform.position, spawnLocation) <= 6f && IsValidPlayer(basePlayer))
		{
			endLocation = ((Component)basePlayer).transform.position;
			endLocation += Vector3.up * 1.5f;
			val = endLocation - startLocation;
			Vector3 normalized2 = ((Vector3)(ref val)).normalized;
			Vector3 val3 = Vector3.Cross(Vector3.up, normalized2);
			midLocation = (startLocation + endLocation) / 2f;
			midLocation += val3 * num;
		}
		float num2 = returnTimer / timeToReturnOnArc;
		Vector3 val4 = FakePhysicsRope.GetRationalBezierPoint(startLocation, midLocation, endLocation, Mathf.Clamp01(num2));
		if (num2 >= 1f)
		{
			gravityVelocity += Vector3.down * 9.81f * deltaTime;
			lastMoveDirection += gravityVelocity * deltaTime;
			val4 = ((Component)this).transform.position + lastMoveDirection;
		}
		else if (num2 > 0.95f)
		{
			val4 += Vector3.down * 0.03f;
		}
		Vector3 val5 = val4 - ((Component)this).transform.position;
		if (val5 != Vector3.zero && base.isServer)
		{
			projectile.SetVelocity(val5);
			((Component)this).transform.rotation = Quaternion.Slerp(((Component)this).transform.rotation, Quaternion.LookRotation(((Vector3)(ref val5)).normalized), deltaTime * 2f);
		}
		((Component)this).transform.position = Vector3.MoveTowards(((Component)this).transform.position, val4, deltaTime * lerpSpeed);
		if (num2 <= 1f)
		{
			lastMoveDirection = val5;
		}
		returnTimer += deltaTime;
	}

	private bool IsValidPlayer(BasePlayer ply)
	{
		if ((Object)(object)ply == (Object)null)
		{
			return false;
		}
		if (ply.IsDead())
		{
			return false;
		}
		if (ply.IsSleeping())
		{
			return false;
		}
		return true;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (base.isClient)
		{
			return;
		}
		spawnLocation = ((Component)this).transform.position;
		projectile = ((Component)this).GetComponent<ThrownBoomerangServerProjectile>();
		if (Object.op_Implicit((Object)(object)projectile))
		{
			projectile.InitializeVelocity(((Component)this).transform.forward * projectile.speed);
			projectile.ProjectileHandleMovement(state: true);
			projectile.SetStartPosition(spawnLocation);
			((FacepunchBehaviour)this).InvokeRepeating((Action)DoBoomerangMove, secondsUntilStartArc, 0f);
			if (!(creatorEntity is BasePlayer basePlayer))
			{
				return;
			}
			creatorPlayer = basePlayer;
			base.OwnerID = creatorPlayer.userID;
			creatorEntity = creatorPlayer;
			Item activeItem = creatorPlayer.GetActiveItem();
			if (activeItem != null)
			{
				if (activeItem.GetHeldEntity() is Boomerang boomerang)
				{
					originEntityItem = boomerang;
				}
				ItemOwnership = activeItem.TakeOwnershipShare();
			}
			((FacepunchBehaviour)this).Invoke((Action)LateRPC, 0.1f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)CheckReturnToHand, secondsUntilStartArc, 0f);
		}
		else
		{
			KillThrownBoomerang();
		}
	}

	private void LateRPC()
	{
		Item activeItem = creatorPlayer.GetActiveItem();
		if (activeItem != null && activeItem.GetHeldEntity() is Boomerang)
		{
			ClientRPC(RpcTarget.Player("SetClientPlayer", creatorPlayer), activeItem.uid.Value);
		}
	}

	public void CreateWorldModel(HitInfo info, Vector3 attackDir)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Max(projectile.scanRange, projectile.radius);
		num /= 2f;
		Item item = ItemManager.Create(boomerangItem, 1, 0uL);
		BaseEntity baseEntity = null;
		bool flag = false;
		if ((Object)(object)info.HitEntity == (Object)null || !info.HitEntity.IsValid())
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld + -attackDir * num * 0.3f, Quaternion.LookRotation(-attackDir));
			flag = info.HitMaterial != Projectile.WaterMaterialID();
			if (!info.HitEntity.IsValid())
			{
				flag = false;
			}
		}
		else if (info.HitBone == 0)
		{
			Vector3 hitPositionLocal = info.HitPositionLocal;
			baseEntity = item.CreateWorldObject(hitPositionLocal, Quaternion.LookRotation(((Component)info.HitEntity).transform.InverseTransformDirection(((Vector3)(ref attackDir)).normalized)), info.HitEntity);
			flag = false;
		}
		else
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(((Component)info.HitEntity).transform.InverseTransformDirection(((Vector3)(ref attackDir)).normalized)));
			flag = false;
		}
		if (flag)
		{
			DroppedItem droppedItem = baseEntity as DroppedItem;
			if ((Object)(object)droppedItem != (Object)null)
			{
				droppedItem.StickIn();
			}
			else
			{
				((Component)baseEntity).GetComponent<Rigidbody>().isKinematic = true;
			}
		}
		else
		{
			((Component)baseEntity).GetComponent<Rigidbody>().AddTorque(((Vector3)(ref attackDir)).normalized * Random.Range(5f, 10f), (ForceMode)1);
		}
		item.condition = Condition;
		item.SetItemOwnership(ItemOwnership);
		baseEntity.OwnerID = base.OwnerID;
		baseEntity.creatorEntity = creatorEntity;
	}

	public void OnHit()
	{
		if ((Object)(object)originEntityItem != (Object)null)
		{
			Item item = originEntityItem.GetItem();
			if (item != null)
			{
				float num = item.maxCondition * 0.1f;
				Condition -= num;
				item.UseItem();
				item.SetParent(null);
			}
		}
	}

	private void KillThrownBoomerang()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)CheckReturnToHand);
		Kill();
	}

	public void CheckReturnToHand()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)creatorPlayer == (Object)null) && !creatorPlayer.IsDead() && !creatorPlayer.IsSleeping() && Vector3.Distance(((Component)creatorPlayer).transform.position, ((Component)this).transform.position) <= 1.5f)
		{
			Item activeItem = creatorPlayer.GetActiveItem();
			if (activeItem != null && activeItem.GetHeldEntity() is Boomerang { HasThrown: not false } boomerang && !((Object)(object)boomerang != (Object)(object)originEntityItem))
			{
				boomerang.SetHasThrown(thrown: false);
				KillThrownBoomerang();
			}
		}
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class ThrownWeapon : AttackEntity
{
	[Header("Throw Weapon")]
	public GameObjectRef prefabToThrow;

	public float maxThrowVelocity = 10f;

	public float tumbleVelocity;

	public Vector3 overrideAngle = Vector3.zero;

	public bool canStick = true;

	public bool canThrowUnderwater = true;

	public bool canThrowFromHelicopter = true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ThrownWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 1513023343 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoDrop "));
				}
				TimeWarning val2 = TimeWarning.New("DoDrop", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1513023343u, "DoDrop", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoDrop(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoDrop");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1974840882 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoThrow "));
				}
				TimeWarning val2 = TimeWarning.New("DoThrow", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1974840882u, "DoThrow", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							DoThrow(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in DoThrow");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return player.GetInheritedThrowVelocity(direction);
	}

	public void ServerThrow(Vector3 targetPosition)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || !HasItemAmount() || HasAttackCooldown())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null || (!canThrowUnderwater && ownerPlayer.IsHeadUnderwater()) || (!canThrowFromHelicopter && ownerPlayer.IsInAHelicopter()))
		{
			return;
		}
		Vector3 position = ownerPlayer.eyes.position;
		Vector3 val = ownerPlayer.eyes.BodyForward();
		float num = 1f;
		SignalBroadcast(Signal.Throw, string.Empty);
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, position, Quaternion.LookRotation((overrideAngle == Vector3.zero) ? (-val) : overrideAngle));
		if ((Object)(object)baseEntity == (Object)null)
		{
			return;
		}
		baseEntity.SetCreatorEntity(ownerPlayer);
		Vector3 val2 = val + Quaternion.AngleAxis(10f, Vector3.right) * Vector3.up;
		float num2 = GetThrowVelocity(position, targetPosition, val2);
		if (float.IsNaN(num2))
		{
			val2 = val + Quaternion.AngleAxis(20f, Vector3.right) * Vector3.up;
			num2 = GetThrowVelocity(position, targetPosition, val2);
			if (float.IsNaN(num2))
			{
				num2 = 5f;
			}
		}
		baseEntity.SetVelocity(val2 * num2 * num);
		if (tumbleVelocity > 0f)
		{
			baseEntity.SetAngularVelocity(new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f)) * tumbleVelocity);
		}
		baseEntity.Spawn();
		StartAttackCooldown(repeatDelay);
		UseItemAmount(1);
		if ((Object)(object)(baseEntity as TimedExplosive) != (Object)null)
		{
			Analytics.Azure.OnExplosiveLaunched(ownerPlayer, baseEntity);
		}
	}

	public static float GetThrowVelocity(Vector3 throwPos, Vector3 targetPos, Vector3 aimDir)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = targetPos - throwPos;
		Vector2 val2 = new Vector2(val.x, val.z);
		float magnitude = ((Vector2)(ref val2)).magnitude;
		float y = val.y;
		val2 = new Vector2(aimDir.x, aimDir.z);
		float magnitude2 = ((Vector2)(ref val2)).magnitude;
		float y2 = aimDir.y;
		float y3 = Physics.gravity.y;
		return Mathf.Sqrt(0.5f * y3 * magnitude * magnitude / (magnitude2 * (magnitude2 * y - y2 * magnitude)));
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void DoThrow(RPCMessage msg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if (HasItemAmount() && !HasAttackCooldown())
		{
			Vector3 eyePos = msg.read.Vector3();
			Vector3 throwVelocityOverride = msg.read.Vector3();
			Vector3 normalized = ((Vector3)(ref throwVelocityOverride)).normalized;
			float throwScale = Mathf.Clamp01(msg.read.Float());
			if (DoValidationChecks(ref eyePos, normalized, msg.player, throwScale))
			{
				Vector3 eyePos2 = eyePos;
				BasePlayer player = msg.player;
				throwVelocityOverride = default(Vector3);
				DoThrowImpl(eyePos2, normalized, player, out var thrownEntity, throwScale, throwVelocityOverride);
				Interface.CallHook("OnExplosiveThrown", (object)msg.player, (object)thrownEntity, (object)this);
				UseItemAmount(1, reduceItemOwnership: false);
			}
		}
	}

	public bool DoValidationChecks(ref Vector3 eyePos, Vector3 eyeDir, BasePlayer owningPlayer, float throwScale)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(eyeDir))
		{
			return false;
		}
		if (FloatEx.IsNaNOrInfinity(throwScale))
		{
			return false;
		}
		if (owningPlayer.isMounted || owningPlayer.HasParent())
		{
			eyePos = owningPlayer.eyes.position;
		}
		else if (!ValidateEyePos(owningPlayer, eyePos))
		{
			return false;
		}
		if (!canThrowUnderwater && owningPlayer.IsHeadUnderwater())
		{
			return false;
		}
		if (!canThrowFromHelicopter && owningPlayer.IsInAHelicopter())
		{
			return false;
		}
		return true;
	}

	public void DoThrowImpl(Vector3 eyePos, Vector3 eyeDir, BasePlayer owningPlayer, out BaseEntity thrownEntity, float throwScale = 1f, Vector3 throwVelocityOverride = default(Vector3), Item ownerItemOverride = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		thrownEntity = null;
		BaseEntity baseEntity = (thrownEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, eyePos, Quaternion.LookRotation((overrideAngle == Vector3.zero) ? (-eyeDir) : overrideAngle)));
		if (!((Object)(object)baseEntity == (Object)null))
		{
			Item item = ownerItemOverride ?? GetOwnerItem();
			if (item != null && item.instanceData != null && item.HasFlag(Item.Flag.IsOn))
			{
				((Component)baseEntity).gameObject.SendMessage("SetFrequency", (object)item.instanceData.dataInt, (SendMessageOptions)1);
			}
			baseEntity.SetCreatorEntity(owningPlayer);
			baseEntity.skinID = skinID;
			if (throwVelocityOverride != Vector3.zero)
			{
				baseEntity.SetVelocity(throwVelocityOverride);
			}
			else
			{
				baseEntity.SetVelocity(GetInheritedVelocity(owningPlayer, eyeDir) + eyeDir * maxThrowVelocity * throwScale + owningPlayer.estimatedVelocity * 0.5f);
			}
			if (tumbleVelocity > 0f)
			{
				baseEntity.SetAngularVelocity(new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f)) * tumbleVelocity);
			}
			baseEntity.Spawn();
			if (baseEntity is TimedExplosive timedExplosive)
			{
				ItemOwnershipShare itemOwnership = item.TakeOwnershipShare();
				timedExplosive.ItemOwnership = itemOwnership;
				timedExplosive.SetCreator(owningPlayer);
			}
			SetUpThrownWeapon(baseEntity, item);
			StartAttackCooldown(repeatDelay);
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoDrop(RPCMessage msg)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		if (!HasItemAmount() || HasAttackCooldown() || (!canThrowUnderwater && msg.player.IsHeadUnderwater()) || (!canThrowFromHelicopter && msg.player.IsInAHelicopter()))
		{
			return;
		}
		Vector3 val = msg.read.Vector3();
		Vector3 val2 = msg.read.Vector3();
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		if (msg.player.isMounted || msg.player.HasParent())
		{
			val = msg.player.eyes.position;
		}
		else if (!ValidateEyePos(msg.player, val))
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, val, Quaternion.LookRotation(Vector3.up));
		if ((Object)(object)baseEntity == (Object)null)
		{
			return;
		}
		RaycastHit hit = default(RaycastHit);
		if (canStick && Physics.SphereCast(new Ray(val, normalized), 0.05f, ref hit, 1.5f, 1237003025))
		{
			Vector3 point = ((RaycastHit)(ref hit)).point;
			Vector3 normal = ((RaycastHit)(ref hit)).normal;
			BaseEntity entity = hit.GetEntity();
			Collider collider = ((RaycastHit)(ref hit)).collider;
			if (Object.op_Implicit((Object)(object)entity) && entity is StabilityEntity && baseEntity is TimedExplosive)
			{
				entity = entity.ToServer<BaseEntity>();
				TimedExplosive timedExplosive = baseEntity as TimedExplosive;
				timedExplosive.onlyDamageParent = true;
				timedExplosive.DoStick(point, normal, entity, collider);
				Analytics.Azure.OnExplosiveLaunched(msg.player, timedExplosive);
			}
			else
			{
				baseEntity.SetVelocity(normalized);
			}
		}
		else
		{
			baseEntity.SetVelocity(normalized);
		}
		baseEntity.creatorEntity = msg.player;
		baseEntity.skinID = skinID;
		baseEntity.Spawn();
		SetUpThrownWeapon(baseEntity, GetOwnerItem());
		StartAttackCooldown(repeatDelay);
		Interface.CallHook("OnExplosiveDropped", (object)msg.player, (object)baseEntity, (object)this);
		UseItemAmount(1);
	}

	protected virtual void SetUpThrownWeapon(BaseEntity ent, Item ownerItem)
	{
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class TimerSwitch : IOEntity
{
	public float timerLength = 10f;

	public Transform timerDrum;

	private float timePassed;

	private float input1Amount;

	private float serverStartTime = -1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TimerSwitch.OnRpcMessage", 0);
		try
		{
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SVSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4167839872u, "SVSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SVSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SVSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public float GetPassedTime()
	{
		return timePassed;
	}

	public override void ResetIOState()
	{
		base.ResetIOState();
		SetFlag(Flags.On, b: false);
		if (((FacepunchBehaviour)this).IsInvoking((Action)AdvanceTime))
		{
			EndTimer();
		}
	}

	public override bool WantsPassthroughPower()
	{
		if (IsPowered())
		{
			return IsOn();
		}
		return false;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsPowered() || !IsOn())
		{
			return 0;
		}
		return base.GetPassthroughAmount(outputSlot);
	}

	public override bool WantsPower(int inputIndex)
	{
		return inputIndex == 0;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		switch (inputSlot)
		{
		case 0:
			base.UpdateFromInput(inputAmount, inputSlot);
			if (IsPowered())
			{
				if (timePassed != 0f && !((FacepunchBehaviour)this).IsInvoking((Action)AdvanceTime))
				{
					SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
					SwitchPressed();
				}
			}
			else if (((FacepunchBehaviour)this).IsInvoking((Action)AdvanceTime))
			{
				EndTimer();
				SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
				SendNetworkUpdate_Flags();
			}
			break;
		case 1:
			if (input1Amount != (float)inputAmount)
			{
				if (inputAmount > 0)
				{
					SwitchPressed();
				}
				input1Amount = inputAmount;
			}
			break;
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SVSwitch(RPCMessage msg)
	{
		SwitchPressed();
	}

	public void SwitchPressed()
	{
		if (!IsOn() && IsPowered())
		{
			StartTimer();
			SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
			MarkDirty();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (timePassed == 0f)
		{
			if (IsOn())
			{
				SetFlag(Flags.On, b: false);
			}
		}
		else
		{
			SwitchPressed();
		}
	}

	public void AdvanceTime()
	{
		if (timePassed < 0f)
		{
			timePassed = 0f;
		}
		timePassed = Time.realtimeSinceStartup - serverStartTime;
		if (timePassed >= timerLength)
		{
			EndTimer();
		}
	}

	public void StartTimer()
	{
		serverStartTime = Time.realtimeSinceStartup;
		timePassed = 0f;
		((FacepunchBehaviour)this).InvokeRepeating((Action)AdvanceTime, 0f, 0.1f);
	}

	public void EndTimer()
	{
		serverStartTime = 0f;
		timePassed = 0f;
		((FacepunchBehaviour)this).CancelInvoke((Action)AdvanceTime);
		SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
		MarkDirty();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity.genericFloat1 = GetPassedTime();
		info.msg.ioEntity.genericFloat2 = timerLength;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			timePassed = info.msg.ioEntity.genericFloat1;
			timerLength = info.msg.ioEntity.genericFloat2;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TinCanAlarm : DecayEntity, IDetector
{
	[Space]
	public LineRenderer lineRenderer;

	public Transform wireOrigin;

	public Transform wireOriginClient;

	public PlayerDetectionTrigger trigger;

	public Transform wireEndCollider;

	public GroundWatch groundWatch;

	public GroundWatch wireGroundWatch;

	public Animator animator;

	[Space]
	public SoundDefinition alarmSoundDef;

	public SoundDefinition armSoundDef;

	public Vector3 endPoint;

	private const Flags Flag_Used = Flags.Reserved5;

	public BaseEntity lastTriggerEntity;

	public float lastTriggerTime;

	private BasePlayer usingPlayer;

	[Space]
	public float maxWireLength = 10f;

	private const int WIRE_PLACEMENT_LAYER = 1084293377;

	public Transform WireOrigin
	{
		get
		{
			_ = base.isServer;
			return wireOrigin;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TinCanAlarm.OnRpcMessage", 0);
		try
		{
			if (rpc == 3384266798u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SetEndPoint "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SetEndPoint", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_SetEndPoint(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_SetEndPoint");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3516830045u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_StartArming "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_StartArming", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3516830045u, "SERVER_StartArming", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_StartArming(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_StartArming");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3508772935u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_StopArming "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_StopArming", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg4 = rPCMessage;
						SERVER_StopArming(msg4);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex3)
				{
					Debug.LogException(ex3);
					player.Kick("RPC Error in SERVER_StopArming");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsUsed()
	{
		return HasFlag(Flags.Reserved5);
	}

	private bool IsArmed()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return endPoint != Vector3.zero;
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (base.ShouldDisplayPickupOption(player))
		{
			return (Object)(object)player.GetBuildingPrivilege() != (Object)null;
		}
		return false;
	}

	public bool ShouldTrigger()
	{
		return IsArmed();
	}

	public void OnObjects()
	{
	}

	public void OnObjectAdded(GameObject obj, Collider col)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = obj.ToBaseEntity();
		if (!((Object)(object)baseEntity != (Object)null))
		{
			return;
		}
		if (baseEntity is BuildingBlock && IsGoingThroughWalls(endPoint))
		{
			CutWire();
			return;
		}
		if (baseEntity is BasePlayer { isMounted: not false } basePlayer)
		{
			baseEntity = basePlayer.GetMounted();
		}
		else
		{
			BaseEntity baseEntity2 = baseEntity.GetParentEntity();
			if ((Object)(object)baseEntity2 != (Object)null)
			{
				baseEntity = baseEntity2;
			}
		}
		if ((!(Time.realtimeSinceStartup - lastTriggerTime < 1f) || !((Object)(object)baseEntity == (Object)(object)lastTriggerEntity)) && (baseEntity is BasePlayer || baseEntity is Door || baseEntity is BaseNpc || baseEntity is BaseVehicle || baseEntity is Elevator || baseEntity is Lift))
		{
			lastTriggerTime = Time.realtimeSinceStartup;
			lastTriggerEntity = baseEntity;
			TriggerAlarm();
		}
	}

	public void OnEmpty()
	{
	}

	public void TriggerAlarm()
	{
		ClientRPC(RpcTarget.NetworkGroup("RPC_TriggerAlarm"));
	}

	public void ServerOnWireDeploying()
	{
		if (!usingPlayer.IsValid() || !usingPlayer.IsConnected)
		{
			PlayerStopsArming(usingPlayer);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void SERVER_StartArming(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsUsed() && player.CanBuild())
		{
			PlayerStartsArming(player);
		}
	}

	[RPC_Server]
	public void SERVER_StopArming(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.CanBuild())
		{
			PlayerStopsArming(player);
		}
	}

	public void PlayerStartsArming(BasePlayer player)
	{
		if (!IsUsed() && !((Object)(object)player == (Object)null))
		{
			usingPlayer = player;
			SetFlag(Flags.Reserved5, b: true);
			if (((FacepunchBehaviour)this).IsInvoking((Action)ServerOnWireDeploying))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ServerOnWireDeploying);
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)ServerOnWireDeploying, 0f, 0f);
			ClientRPC(RpcTarget.Player("CLIENT_StartArming", player));
		}
	}

	public void PlayerStopsArming(BasePlayer player)
	{
		usingPlayer = null;
		SetFlag(Flags.Reserved5, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ServerOnWireDeploying);
		ClientRPC(RpcTarget.Player("CLIENT_StopArming", player));
	}

	public void CutWire()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TriggerAlarm();
		endPoint = Vector3.zero;
		SendNetworkUpdate();
	}

	private void UpdateWireTip()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			if (!IsArmed())
			{
				ComponentExtensions.SetActive<Transform>(wireEndCollider, false);
				return;
			}
			wireEndCollider.position = endPoint;
			ComponentExtensions.SetActive<Transform>(wireEndCollider, true);
		}
	}

	private void OnGroundMissing()
	{
		if (!base.IsDestroyed && !base.isClient)
		{
			if (!groundWatch.OnGround())
			{
				Kill(DestroyMode.Gib);
			}
			else if (!wireGroundWatch.OnGround())
			{
				CutWire();
			}
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		if (base.isServer)
		{
			PlayerStartsArming(deployedBy);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (info.hasDamage && !info.damageTypes.Has(DamageType.Heat))
		{
			TriggerAlarm();
		}
	}

	private void UpdateTrigger()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		if (!IsArmed())
		{
			ComponentExtensions.SetActive<PlayerDetectionTrigger>(trigger, false);
			return;
		}
		ComponentExtensions.SetActive<PlayerDetectionTrigger>(trigger, true);
		Vector3 position = wireOrigin.position;
		Vector3 val = endPoint;
		Vector3 position2 = (position + val) / 2f;
		Vector3 val2 = val - position;
		float magnitude = ((Vector3)(ref val2)).magnitude;
		((Component)trigger).transform.position = position2;
		Vector3 localScale = ((Component)trigger).transform.localScale;
		localScale.z = magnitude;
		((Component)trigger).transform.rotation = Quaternion.LookRotation(val2);
		((Component)trigger).transform.localScale = new Vector3(0.15f, 0.15f, localScale.z);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.tinCanAlarm = Pool.Get<TinCanAlarm>();
		info.msg.tinCanAlarm.endPoint = endPoint;
		UpdateTrigger();
		UpdateWireTip();
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.tinCanAlarm != null)
		{
			endPoint = info.msg.tinCanAlarm.endPoint;
			UpdateTrigger();
			if (info.fromDisk && !usingPlayer.IsValid())
			{
				PlayerStopsArming(usingPlayer);
			}
		}
	}

	[RPC_Server]
	public void RPC_SetEndPoint(RPCMessage msg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		Vector3 val = msg.read.Vector3();
		if (player.CanBuild() && player.IsVisibleAndCanSee(val) && !IsGoingThroughWalls(val) && IsInValidVolume(val) && IsOnValidEntities(val) && !(Vector3.Distance(wireOrigin.position, val) > maxWireLength))
		{
			endPoint = val;
			SendNetworkUpdate();
			PlayerStopsArming(player);
		}
	}

	private bool IsGoingThroughWalls(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		float maxDistance = Vector3.Distance(wireOrigin.position, position);
		Vector3 val = position - wireOrigin.position;
		RaycastHit hitInfo;
		bool flag = GamePhysics.Trace(new Ray(wireOrigin.position, val), 0f, out hitInfo, maxDistance, 1218519297, (QueryTriggerInteraction)1, this);
		if (!flag)
		{
			flag = GamePhysics.Trace(new Ray(position, -val), 0f, out var _, maxDistance, 1218519297, (QueryTriggerInteraction)1, this);
		}
		return flag;
	}

	private bool IsInValidVolume(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(position, 0.1f, list, 536870912, (QueryTriggerInteraction)2);
		bool result = true;
		foreach (Collider item in list)
		{
			if (((Component)item).gameObject.HasCustomTag(GameObjectTag.BlockPlacement))
			{
				result = false;
				break;
			}
			if (!((Object)(object)item.GetMonument() != (Object)null))
			{
				ColliderInfo component = ((Component)item).GetComponent<ColliderInfo>();
				if (!((Object)(object)component != (Object)null) || !component.HasFlag(ColliderInfo.Flags.Tunnels))
				{
					result = false;
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private bool IsOnValidEntities(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, 0.1f, list, 1084293377, (QueryTriggerInteraction)2);
		bool result = true;
		foreach (BaseEntity item in list)
		{
			if (item is AnimatedBuildingBlock || item is ElevatorLift || item is Elevator)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}
}


using System;
using Network;
using UnityEngine;

public class Toolgun : Hammer
{
	public GameObjectRef attackEffect;

	public GameObjectRef beamEffect;

	public GameObjectRef beamImpactEffect;

	public GameObjectRef errorEffect;

	public GameObjectRef beamEffectClassic;

	public GameObjectRef beamImpactEffectClassic;

	public Transform muzzlePoint;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Toolgun.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void DoAttackShared(HitInfo info)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			ClientRPC(RpcTarget.NetworkGroup("EffectSpawn"), info.HitPositionWorld, info.HitNormalWorld);
		}
		base.DoAttackShared(info);
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class TorchDeployableLightSource : StorageContainer, ISplashable, IIgniteable, IAlwaysOn
{
	public ItemDefinition[] AllowedTorches;

	public Transform TorchRoot;

	public const Flags HasTorch = Flags.Reserved1;

	public const Flags UseBuiltInFx = Flags.Reserved2;

	public const Flags AlwaysOn = Flags.Reserved3;

	public ItemDefinition[] BuiltInFxItems = new ItemDefinition[0];

	private EntityRef<TorchWeapon> spawnedTorch;

	private ItemDefinition spawnedTorchDef;

	private Item CurrentTorch => base.inventory.GetSlot(0);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TorchDeployableLightSource.OnRpcMessage", 0);
		try
		{
			if (rpc == 3305620958u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestTurnOnOff "));
				}
				TimeWarning val2 = TimeWarning.New("RequestTurnOnOff", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3305620958u, "RequestTurnOnOff", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RequestTurnOnOff(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RequestTurnOnOff");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		ItemDefinition[] allowedTorches = AllowedTorches;
		for (int i = 0; i < allowedTorches.Length; i++)
		{
			if ((Object)(object)allowedTorches[i] == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	private bool ShouldUseBuiltInFx(ItemDefinition def)
	{
		if ((Object)(object)def == (Object)null)
		{
			return false;
		}
		ItemDefinition[] builtInFxItems = BuiltInFxItems;
		for (int i = 0; i < builtInFxItems.Length; i++)
		{
			if ((Object)(object)builtInFxItems[i] == (Object)(object)def)
			{
				return true;
			}
		}
		return false;
	}

	private void UpdateTorch()
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		Item item = CurrentTorch;
		if (item != null && item.isBroken)
		{
			item = null;
		}
		ItemDefinition itemDefinition = item?.info;
		if ((Object)(object)itemDefinition != (Object)(object)spawnedTorchDef)
		{
			spawnedTorchDef = itemDefinition;
			SetFlag(Flags.Reserved2, ShouldUseBuiltInFx(itemDefinition), recursive: false, networkupdate: false);
			TorchWeapon torchWeapon = spawnedTorch.Get(serverside: true);
			if ((Object)(object)torchWeapon != (Object)null)
			{
				torchWeapon.Kill();
			}
			spawnedTorch.Set(null);
			if ((Object)(object)itemDefinition != (Object)null)
			{
				TorchWeapon component = ((Component)GameManager.server.CreateEntity(((Component)itemDefinition).GetComponent<ItemModEntity>().entityPrefab.resourcePath, TorchRoot.position, TorchRoot.rotation)).GetComponent<TorchWeapon>();
				component.SetParent(this, worldPositionStays: true);
				component.SetFlag(Flags.Reserved1, b: true);
				component.Spawn();
				spawnedTorch.Set(component);
			}
			else
			{
				SetFlag(Flags.On, b: false);
			}
		}
		SetFlag(Flags.Reserved1, (Object)(object)spawnedTorch.Get(serverside: true) != (Object)null);
		if (!HasFlag(Flags.Reserved1) && ((FacepunchBehaviour)this).IsInvoking((Action)TickTorchDurability))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TickTorchDurability);
		}
	}

	private void TickTorchDurability()
	{
		Item currentTorch = CurrentTorch;
		if (currentTorch != null && !IsAlwaysOn())
		{
			currentTorch.LoseCondition(1f / 12f);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		foreach (BaseEntity child in children)
		{
			if (child is TorchWeapon torchWeapon)
			{
				spawnedTorch.Set(torchWeapon);
				torchWeapon.SetFlag(Flags.On, IsOn());
				break;
			}
		}
		if (HasFlag(Flags.Reserved1) && IsOn())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)TickTorchDurability, 1f, 1f);
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		UpdateTorch();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RequestTurnOnOff(RPCMessage msg)
	{
		bool wantsOn = msg.read.Bit();
		TryToggle(wantsOn);
	}

	private void TryToggle(bool wantsOn)
	{
		if (CurrentTorch == null)
		{
			return;
		}
		TorchWeapon torchWeapon = spawnedTorch.Get(serverside: true);
		if (!((Object)(object)torchWeapon == (Object)null))
		{
			torchWeapon.SetFlag(Flags.On, wantsOn);
			SetFlag(Flags.On, wantsOn);
			if (HasFlag(Flags.Reserved1) && wantsOn)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)TickTorchDurability, 1f, 1f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)TickTorchDurability);
			}
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if (HasFlag(Flags.Reserved1))
		{
			return IsOn();
		}
		return false;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		TryToggle(wantsOn: false);
		return 10;
	}

	public void Ignite(Vector3 fromPos)
	{
		TryToggle(wantsOn: true);
	}

	public bool CanIgnite()
	{
		if (HasFlag(Flags.Reserved1))
		{
			return !IsOn();
		}
		return false;
	}

	public virtual bool IsAlwaysOn()
	{
		if (HasFlag(Flags.Reserved3))
		{
			return Creative.alwaysOnEnabled;
		}
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SplashableStaticGrid.RegisterSplashable(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		SplashableStaticGrid.DeregisterSplashable(this);
	}

	public void SetAlwaysOn(bool flag)
	{
		SetFlag(Flags.Reserved3, flag);
		AlwaysOnToggled(flag);
	}

	public void AlwaysOnToggled(bool flag)
	{
		if (flag)
		{
			if (AllowedTorches == null || AllowedTorches.Length == 0 || base.inventory == null)
			{
				return;
			}
			if (!HasFlag(Flags.Reserved1))
			{
				ItemDefinition itemDefinition = AllowedTorches[0];
				if ((Object)(object)itemDefinition == (Object)null)
				{
					return;
				}
				ItemManager.Create(itemDefinition, 1, 0uL).MoveToContainer(base.inventory, 0, allowStack: false);
			}
		}
		TryToggle(flag);
	}
}


