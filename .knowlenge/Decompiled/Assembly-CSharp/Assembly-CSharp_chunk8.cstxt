using System;
using ConVar;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TorchWeapon : BaseMelee
{
	[NonSerialized]
	public const float FuelTickAmount = 1f / 12f;

	[Header("TorchWeapon")]
	public AnimatorOverrideController LitHoldAnimationOverride;

	public bool ExtinguishUnderwater = true;

	public bool UseTurnOnOffAnimations;

	public GameObjectRef litStrikeFX;

	public const Flags IsInHolder = Flags.Reserved1;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TorchWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 2235491565u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Extinguish "));
				}
				TimeWarning val2 = TimeWarning.New("Extinguish", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(2235491565u, "Extinguish", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Extinguish(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Extinguish");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3010584743u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Ignite "));
				}
				TimeWarning val2 = TimeWarning.New("Ignite", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3010584743u, "Ignite", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Ignite(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Ignite");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void GetAttackStats(HitInfo info)
	{
		base.GetAttackStats(info);
		if (HasFlag(Flags.On))
		{
			info.damageTypes.Add(DamageType.Heat, 1f);
		}
	}

	public override float GetConditionLoss()
	{
		return base.GetConditionLoss() + (HasFlag(Flags.On) ? 6f : 0f);
	}

	public void SetIsOn(bool isOn)
	{
		if (isOn)
		{
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.OnFire, b: true);
			((FacepunchBehaviour)this).InvokeRepeating((Action)UseFuel, 1f, 1f);
		}
		else
		{
			SetFlag(Flags.On, b: false);
			SetFlag(Flags.OnFire, b: false);
			((FacepunchBehaviour)this).CancelInvoke((Action)UseFuel);
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void Ignite(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			SetIsOn(isOn: true);
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Extinguish(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			SetIsOn(isOn: false);
		}
	}

	public void UseFuel()
	{
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			ownerItem.LoseCondition(1f / 12f);
			SingletonComponent<NpcFireManager>.Instance.Move(this);
		}
	}

	public override void OnHeldChanged()
	{
		if (IsDisabled())
		{
			SetIsOn(isOn: false);
		}
	}

	public override string GetStrikeEffectPath(string materialName)
	{
		for (int i = 0; i < materialStrikeFX.Count; i++)
		{
			if (materialStrikeFX[i].materialName == materialName && materialStrikeFX[i].fx.isValid)
			{
				return materialStrikeFX[i].fx.resourcePath;
			}
		}
		if (HasFlag(Flags.On) && litStrikeFX.isValid)
		{
			return litStrikeFX.resourcePath;
		}
		return strikeFX.resourcePath;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class TrainCar : BaseVehicle, ITrainCollidable, IPrefabPreProcess, TriggerHurtNotChild.IHurtTriggerUser, TrainTrackSpline.ITrainTrackUser
{
	public enum TrainCarType
	{
		Wagon,
		Engine,
		Other
	}

	[Header("Train Car")]
	[SerializeField]
	public float corpseSeconds = 60f;

	[SerializeField]
	public TriggerTrainCollisions frontCollisionTrigger;

	[SerializeField]
	public TriggerTrainCollisions rearCollisionTrigger;

	[SerializeField]
	public float collisionDamageDivide = 100000f;

	[SerializeField]
	public float derailCollisionForce = 130000f;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerFront;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerRear;

	[SerializeField]
	private GameObject[] hurtOrRepelTriggersInternal;

	[SerializeField]
	public float hurtTriggerMinSpeed = 1f;

	[SerializeField]
	public Transform centreOfMassTransform;

	[SerializeField]
	public Transform frontBogiePivot;

	[SerializeField]
	public bool frontBogieCanRotate = true;

	[SerializeField]
	public Transform rearBogiePivot;

	[SerializeField]
	public bool rearBogieCanRotate = true;

	[SerializeField]
	private Transform[] wheelVisuals;

	[SerializeField]
	public float wheelRadius = 0.615f;

	[FormerlySerializedAs("fxFinalExplosion")]
	[SerializeField]
	public GameObjectRef fxDestroyed;

	[SerializeField]
	public TriggerParent platformParentTrigger;

	public GameObjectRef collisionEffect;

	public Transform frontCoupling;

	public Transform frontCouplingPivot;

	public Transform rearCoupling;

	public Transform rearCouplingPivot;

	[SerializeField]
	public SoundDefinition coupleSound;

	[SerializeField]
	private SoundDefinition uncoupleSound;

	[SerializeField]
	private TrainCarAudio trainCarAudio;

	[SerializeField]
	[FormerlySerializedAs("frontCoupleFx")]
	public ParticleSystem frontCouplingChangedFx;

	[FormerlySerializedAs("rearCoupleFx")]
	[SerializeField]
	public ParticleSystem rearCouplingChangedFx;

	[SerializeField]
	[FormerlySerializedAs("fxCoupling")]
	public ParticleSystem newCouplingFX;

	[SerializeField]
	private float decayTimeMultiplier = 1f;

	[SerializeField]
	[ReadOnly]
	public Vector3 frontBogieLocalOffset;

	[SerializeField]
	[ReadOnly]
	public Vector3 rearBogieLocalOffset;

	[SerializeField]
	private GameObjectRef itemStoragePrefab;

	private EntityRef<StorageContainer> itemStorageInstance;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population = 2.3f;

	[ServerVar(Help = "Ratio of wagons to train engines that spawn")]
	public static int wagons_per_engine = 2;

	[ServerVar(Help = "How long before a train car despawns")]
	public static float decayminutes = 30f;

	[ServerVar(Help = "Should train cars that are not spawned near train tracks be killed instantly (default = true)")]
	public static bool killofftracktrains = true;

	[ServerVar(Help = "Chance to miss per m/s of velocity for turrets shooting players on moving trains", Name = "trainturretinaccuratepervelocity")]
	public static float TrainTurretInaccuratePerVelocity = 0.1f;

	[ReadOnly]
	public float DistFrontWheelToFrontCoupling;

	[ReadOnly]
	public float DistFrontWheelToBackCoupling;

	public TrainCouplingController coupling;

	[NonSerialized]
	public TrainTrackSpline.TrackSelection localTrackSelection;

	public const Flags Flag_LinedUpToUnload = Flags.Reserved4;

	public static float TRAINCAR_MAX_SPEED = 25f;

	protected bool trainDebug;

	public CompleteTrain completeTrain;

	[NonSerialized]
	public float savedTrackSpeed;

	private bool frontAtEndOfLine;

	private bool rearAtEndOfLine;

	public float frontBogieYRot;

	public float rearBogieYRot;

	public Vector3 spawnOrigin;

	private bool coupledBackwards;

	public TrainTrackSpline _frontTrackSection;

	public float distFrontToBackWheel;

	public float initialSpawnTime;

	public float decayingFor;

	public float decayTickSpacing = 60f;

	public float lastDecayTick;

	public TriggerTrainCollisions FrontCollisionTrigger => frontCollisionTrigger;

	public TriggerTrainCollisions RearCollisionTrigger => rearCollisionTrigger;

	public virtual TrainCarType CarType => TrainCarType.Wagon;

	public bool LinedUpToUnload => HasFlag(Flags.Reserved4);

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	public Vector3 Position => ((Component)this).transform.position;

	public float FrontWheelSplineDist { get; set; }

	public bool FrontAtEndOfLine => frontAtEndOfLine;

	public bool RearAtEndOfLine => rearAtEndOfLine;

	public virtual bool networkUpdateOnCompleteTrainChange => false;

	public TrainTrackSpline FrontTrackSection
	{
		get
		{
			return _frontTrackSection;
		}
		set
		{
			if ((Object)(object)_frontTrackSection != (Object)(object)value)
			{
				if ((Object)(object)_frontTrackSection != (Object)null)
				{
					_frontTrackSection.DeregisterTrackUser(this);
				}
				_frontTrackSection = value;
				if ((Object)(object)_frontTrackSection != (Object)null)
				{
					_frontTrackSection.RegisterTrackUser(this);
				}
			}
		}
	}

	public TrainTrackSpline RearTrackSection { get; set; }

	public bool IsAtAStation
	{
		get
		{
			if ((Object)(object)FrontTrackSection != (Object)null)
			{
				return FrontTrackSection.isStation;
			}
			return false;
		}
	}

	public bool IsOnAboveGroundSpawnRail
	{
		get
		{
			if ((Object)(object)FrontTrackSection != (Object)null)
			{
				return FrontTrackSection.aboveGroundSpawn;
			}
			return false;
		}
	}

	public bool RecentlySpawned => Time.time < initialSpawnTime + 2f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TrainCar.OnRpcMessage", 0);
		try
		{
			if (rpc == 924237371 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenItemStorage "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenItemStorage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(924237371u, "RPC_OpenItemStorage", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_OpenItemStorage(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenItemStorage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3930273067u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_WantsUncouple "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_WantsUncouple", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						RPC_WantsUncouple(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in RPC_WantsUncouple");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(process, rootObj, name, serverside, clientside, bundling);
		if (!((Object)(object)frontBogiePivot == (Object)null) && !((Object)(object)rearBogiePivot == (Object)null))
		{
			frontBogieLocalOffset = ((Component)this).transform.InverseTransformPoint(frontBogiePivot.position);
			float num = ((!((Object)(object)frontCoupling != (Object)null)) ? (((Bounds)(ref bounds)).extents.z + ((Bounds)(ref bounds)).center.z) : ((Component)this).transform.InverseTransformPoint(frontCoupling.position).z);
			float num2 = ((!((Object)(object)rearCoupling != (Object)null)) ? (0f - ((Bounds)(ref bounds)).extents.z + ((Bounds)(ref bounds)).center.z) : ((Component)this).transform.InverseTransformPoint(rearCoupling.position).z);
			DistFrontWheelToFrontCoupling = num - frontBogieLocalOffset.z;
			DistFrontWheelToBackCoupling = 0f - num2 + frontBogieLocalOffset.z;
			rearBogieLocalOffset = ((Component)this).transform.InverseTransformPoint(rearBogiePivot.position);
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		coupling = new TrainCouplingController(this);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.baseTrain != null && base.isServer)
		{
			frontBogieYRot = info.msg.baseTrain.frontBogieYRot;
			rearBogieYRot = info.msg.baseTrain.rearBogieYRot;
			itemStorageInstance.uid = info.msg.baseTrain.itemStorageID;
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next && base.isServer)
		{
			ServerFlagsChanged(old, next);
		}
	}

	public bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger)
	{
		return false;
	}

	public override float InheritedVelocityScale()
	{
		return 0.5f;
	}

	public virtual void SetTrackSelection(TrainTrackSpline.TrackSelection trackSelection)
	{
		if (localTrackSelection != trackSelection)
		{
			localTrackSelection = trackSelection;
			if (base.isServer)
			{
				ClientRPC(RpcTarget.NetworkGroup("SetTrackSelection"), (sbyte)localTrackSelection);
			}
		}
	}

	public bool PlayerIsOnPlatform(BasePlayer player)
	{
		return (Object)(object)player.GetParentEntity() == (Object)(object)this;
	}

	public override void ServerInit()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		spawnOrigin = ((Component)this).transform.position;
		distFrontToBackWheel = Vector3.Distance(GetFrontWheelPos(), GetRearWheelPos());
		rigidBody.centerOfMass = centreOfMassTransform.localPosition;
		UpdateCompleteTrain();
		lastDecayTick = Time.time;
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.15f, 0.02f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayTick, Random.Range(20f, 40f), decayTickSpacing, decayTickSpacing * 0.1f);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (base.health <= 0f)
		{
			ActualDeath();
			return;
		}
		SetFlag(Flags.Reserved2, b: false);
		SetFlag(Flags.Reserved3, b: false);
	}

	public override void Spawn()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		initialSpawnTime = Time.time;
		if (TrainTrackSpline.TryFindTrackNear(GetFrontWheelPos(), 15f, out var splineResult, out var distResult))
		{
			FrontWheelSplineDist = distResult;
			Vector3 tangent;
			Vector3 positionAndTangent = splineResult.GetPositionAndTangent(FrontWheelSplineDist, ((Component)this).transform.forward, out tangent);
			SetTheRestFromFrontWheelData(ref splineResult, positionAndTangent, tangent, localTrackSelection, null, instantMove: true);
			FrontTrackSection = splineResult;
			if (!Application.isLoadingSave && !SpaceIsClear())
			{
				((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0f);
			}
		}
		else if (killofftracktrains)
		{
			((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0f);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.baseTrain = Pool.Get<BaseTrain>();
		info.msg.baseTrain.time = GetNetworkTime();
		info.msg.baseTrain.frontBogieYRot = frontBogieYRot;
		info.msg.baseTrain.rearBogieYRot = rearBogieYRot;
		info.msg.baseTrain.itemStorageID = itemStorageInstance.uid;
		if (coupling.frontCoupling.TryGetCoupledToID(out var id))
		{
			info.msg.baseTrain.frontCouplingID = id;
			info.msg.baseTrain.frontCouplingToFront = coupling.frontCoupling.CoupledTo.isFrontCoupling;
		}
		if (coupling.rearCoupling.TryGetCoupledToID(out id))
		{
			info.msg.baseTrain.rearCouplingID = id;
			info.msg.baseTrain.rearCouplingToFront = coupling.rearCoupling.CoupledTo.isFrontCoupling;
		}
	}

	public virtual void ServerFlagsChanged(Flags old, Flags next)
	{
		if (isSpawned && (next.HasFlag(Flags.Reserved2) != old.HasFlag(Flags.Reserved2) || next.HasFlag(Flags.Reserved3) != old.HasFlag(Flags.Reserved3)))
		{
			UpdateCompleteTrain();
		}
	}

	public void UpdateCompleteTrain()
	{
		List<TrainCar> result = Pool.Get<List<TrainCar>>();
		coupling.GetAll(ref result);
		SetNewCompleteTrain(new CompleteTrain(result));
	}

	public void SetNewCompleteTrain(CompleteTrain ct)
	{
		if (completeTrain != ct)
		{
			RemoveFromCompleteTrain();
			completeTrain = ct;
			coupledBackwards = ct.GetIsCoupledBackwards(this);
			if (networkUpdateOnCompleteTrainChange)
			{
				SendNetworkUpdate();
			}
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (!RecentlySpawned)
		{
			base.Hurt(info);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_OpenItemStorage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player))
		{
			StorageContainer itemContainer = GetItemContainer();
			if ((Object)(object)itemContainer != (Object)null)
			{
				itemContainer.PlayerOpenLoot(player);
			}
		}
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && itemStoragePrefab != null && itemStoragePrefab.isValid)
		{
			BaseEntity entity = itemStoragePrefab.GetEntity();
			if ((Object)(object)entity != (Object)null && child.prefabID == entity.prefabID)
			{
				itemStorageInstance.Set((StorageContainer)child);
			}
		}
	}

	public StorageContainer GetItemContainer()
	{
		BaseEntity baseEntity = itemStorageInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	public override void OnDied(HitInfo info)
	{
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		float num = info?.damageTypes.Get(DamageType.AntiVehicle) ?? 0f;
		float num2 = info?.damageTypes.Get(DamageType.Explosion) ?? 0f;
		float num3 = info?.damageTypes.Total() ?? 0f;
		if ((num + num2) / num3 > 0.5f || vehicle.cinematictrains || corpseSeconds == 0f)
		{
			if (HasDriver())
			{
				GetDriver().Hurt(float.MaxValue);
			}
			base.OnDied(info);
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)ActualDeath, corpseSeconds);
		}
		if (base.IsDestroyed && fxDestroyed.isValid)
		{
			Effect.server.Run(fxDestroyed.resourcePath, GetExplosionPos(), Vector3.up, null, broadcast: true);
		}
	}

	public virtual Vector3 GetExplosionPos()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetCentreOfTrainPos();
	}

	public void ActualDeath()
	{
		Kill(DestroyMode.Gib);
	}

	public override void DoRepair(BasePlayer player)
	{
		base.DoRepair(player);
		if (IsDead() && Health() > 0f)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ActualDeath);
			lifestate = LifeState.Alive;
		}
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return Mathf.Abs(GetTrackSpeed()) * 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	public override void DoServerDestroy()
	{
		if ((Object)(object)FrontTrackSection != (Object)null)
		{
			FrontTrackSection.DeregisterTrackUser(this);
		}
		coupling.Uncouple(front: true);
		coupling.Uncouple(front: false);
		RemoveFromCompleteTrain();
		if (vehicle.vehiclesdroploot)
		{
			StorageContainer storageContainer = itemStorageInstance.Get(base.isServer);
			if ((Object)(object)storageContainer != (Object)null && storageContainer.IsValid())
			{
				storageContainer.DropItems();
			}
		}
		base.DoServerDestroy();
	}

	public void RemoveFromCompleteTrain()
	{
		if (completeTrain != null)
		{
			if (completeTrain.ContainsOnly(this))
			{
				completeTrain.Dispose();
				completeTrain = null;
			}
			else
			{
				completeTrain.RemoveTrainCar(this);
			}
		}
	}

	public override bool MountEligable(BasePlayer player)
	{
		if (IsDead())
		{
			return false;
		}
		return base.MountEligable(player);
	}

	public override float AntiHackVelocity()
	{
		return TRAINCAR_MAX_SPEED;
	}

	public float GetTrackSpeed()
	{
		if (completeTrain == null)
		{
			return 0f;
		}
		return completeTrain.GetTrackSpeedFor(this);
	}

	public bool IsCoupledBackwards()
	{
		if (completeTrain == null)
		{
			return false;
		}
		return coupledBackwards;
	}

	public float GetPrevTrackSpeed()
	{
		if (completeTrain == null)
		{
			return 0f;
		}
		return completeTrain.GetPrevTrackSpeedFor(this);
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.forward * GetTrackSpeed();
	}

	public bool AnyPlayersOnTrainCar()
	{
		if (AnyMounted())
		{
			return true;
		}
		if ((Object)(object)platformParentTrigger != (Object)null && platformParentTrigger.HasAnyEntityContents)
		{
			foreach (BaseEntity entityContent in platformParentTrigger.entityContents)
			{
				if ((Object)(object)entityContent.ToPlayer() != (Object)null)
				{
					return true;
				}
			}
		}
		return false;
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("TrainCar.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (completeTrain != null)
			{
				completeTrain.UpdateTick(Time.fixedDeltaTime);
				float trackSpeed = GetTrackSpeed();
				((Component)hurtTriggerFront).gameObject.SetActive(!coupling.IsFrontCoupled && trackSpeed > hurtTriggerMinSpeed);
				((Component)hurtTriggerRear).gameObject.SetActive(!coupling.IsRearCoupled && trackSpeed < 0f - hurtTriggerMinSpeed);
				GameObject[] array = hurtOrRepelTriggersInternal;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(Mathf.Abs(trackSpeed) > hurtTriggerMinSpeed);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void PostVehicleFixedUpdate()
	{
		base.PostVehicleFixedUpdate();
		if (completeTrain != null)
		{
			completeTrain.ResetUpdateTick();
		}
	}

	public Vector3 GetCentreOfTrainPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * ((Bounds)(ref bounds)).center;
	}

	public Vector3 GetFrontOfTrainPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * (((Bounds)(ref bounds)).center + Vector3.forward * ((Bounds)(ref bounds)).extents.z);
	}

	public Vector3 GetRearOfTrainPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * (((Bounds)(ref bounds)).center - Vector3.forward * ((Bounds)(ref bounds)).extents.z);
	}

	public void FrontTrainCarTick(TrainTrackSpline.TrackSelection trackSelection, float dt)
	{
		float distToMove = GetTrackSpeed() * dt;
		TrainTrackSpline preferredAltTrack = (((Object)(object)RearTrackSection != (Object)(object)FrontTrackSection) ? RearTrackSection : null);
		MoveFrontWheelsAlongTrackSpline(FrontTrackSection, FrontWheelSplineDist, distToMove, preferredAltTrack, trackSelection);
	}

	public void OtherTrainCarTick(TrainTrackSpline theirTrackSpline, float prevSplineDist, float distanceOffset)
	{
		MoveFrontWheelsAlongTrackSpline(theirTrackSpline, prevSplineDist, distanceOffset, FrontTrackSection, TrainTrackSpline.TrackSelection.Default);
	}

	public bool TryGetNextTrainCar(Vector3 forwardDir, out TrainCar result)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return TryGetTrainCar(next: true, forwardDir, out result);
	}

	public bool TryGetPrevTrainCar(Vector3 forwardDir, out TrainCar result)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return TryGetTrainCar(next: false, forwardDir, out result);
	}

	public bool TryGetTrainCar(bool next, Vector3 forwardDir, out TrainCar result)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		result = null;
		if (completeTrain == null)
		{
			return false;
		}
		return completeTrain.TryGetAdjacentTrainCar(this, next, forwardDir, out result);
	}

	public void MoveFrontWheelsAlongTrackSpline(TrainTrackSpline trackSpline, float prevSplineDist, float distToMove, TrainTrackSpline preferredAltTrack, TrainTrackSpline.TrackSelection trackSelection)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		TrainTrackSpline.MoveResult moveResult = trackSpline.MoveAlongSpline(tReq: new TrainTrackSpline.TrackRequest(trackSelection, preferredAltTrack, null), prevSplineDist: prevSplineDist, askerForward: ((Component)this).transform.forward, distMoved: distToMove);
		TrainTrackSpline frontTS = moveResult.spline;
		FrontWheelSplineDist = moveResult.distAlongSpline;
		frontAtEndOfLine = moveResult.atEndOfLine;
		Vector3 tangent;
		Vector3 positionAndTangent = frontTS.GetPositionAndTangent(FrontWheelSplineDist, ((Component)this).transform.forward, out tangent);
		SetTheRestFromFrontWheelData(ref frontTS, positionAndTangent, tangent, trackSelection, trackSpline, instantMove: false);
		FrontTrackSection = frontTS;
	}

	public Vector3 GetFrontWheelPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * frontBogieLocalOffset;
	}

	public Vector3 GetRearWheelPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * rearBogieLocalOffset;
	}

	public void SetTheRestFromFrontWheelData(ref TrainTrackSpline frontTS, Vector3 targetFrontWheelPos, Vector3 targetFrontWheelTangent, TrainTrackSpline.TrackSelection trackSelection, TrainTrackSpline additionalAlt, bool instantMove)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		TrainTrackSpline.TrackRequest tReq = new TrainTrackSpline.TrackRequest(trackSelection, RearTrackSection, additionalAlt);
		TrainTrackSpline.MoveResult moveResult = frontTS.MoveAlongSpline(FrontWheelSplineDist, ((Component)this).transform.forward, 0f - distFrontToBackWheel, tReq);
		TrainTrackSpline spline = moveResult.spline;
		float distAlongSpline = moveResult.distAlongSpline;
		rearAtEndOfLine = moveResult.atEndOfLine;
		Vector3 tangent;
		Vector3 positionAndTangent = spline.GetPositionAndTangent(distAlongSpline, ((Component)this).transform.forward, out tangent);
		if (rearAtEndOfLine)
		{
			moveResult = spline.MoveAlongSpline(tReq: new TrainTrackSpline.TrackRequest(trackSelection, spline, additionalAlt), prevSplineDist: distAlongSpline, askerForward: ((Component)this).transform.forward, distMoved: distFrontToBackWheel);
			frontTS = moveResult.spline;
			FrontWheelSplineDist = moveResult.distAlongSpline;
			frontAtEndOfLine = moveResult.atEndOfLine;
			targetFrontWheelPos = frontTS.GetPositionAndTangent(FrontWheelSplineDist, ((Component)this).transform.forward, out targetFrontWheelTangent);
		}
		RearTrackSection = spline;
		Vector3 val = targetFrontWheelPos - positionAndTangent;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = targetFrontWheelPos - Quaternion.LookRotation(normalized) * frontBogieLocalOffset;
		if (instantMove)
		{
			((Component)this).transform.position = val2;
			if (((Vector3)(ref normalized)).magnitude == 0f)
			{
				((Component)this).transform.rotation = Quaternion.identity;
			}
			else
			{
				((Component)this).transform.rotation = Quaternion.LookRotation(normalized);
			}
		}
		else
		{
			((Component)this).transform.position = val2;
			if (((Vector3)(ref normalized)).magnitude == 0f)
			{
				((Component)this).transform.rotation = Quaternion.identity;
			}
			else
			{
				((Component)this).transform.rotation = Quaternion.LookRotation(normalized);
			}
		}
		frontBogieYRot = Vector3.SignedAngle(((Component)this).transform.forward, targetFrontWheelTangent, ((Component)this).transform.up);
		rearBogieYRot = Vector3.SignedAngle(((Component)this).transform.forward, tangent, ((Component)this).transform.up);
		if (Application.isEditor)
		{
			Debug.DrawLine(targetFrontWheelPos, positionAndTangent, Color.magenta, 0.2f);
			Debug.DrawLine(rigidBody.position, val2, Color.yellow, 0.2f);
			Debug.DrawRay(val2, Vector3.up, Color.yellow, 0.2f);
		}
	}

	public float GetForces()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Component)this).transform.localEulerAngles.x;
		if (num > 180f)
		{
			num -= 360f;
		}
		return 0f + num / 90f * (0f - Physics.gravity.y) * RealisticMass * 0.33f + GetThrottleForce();
	}

	protected virtual float GetThrottleForce()
	{
		return 0f;
	}

	public virtual bool HasThrottleInput()
	{
		return false;
	}

	public float ApplyCollisionDamage(float forceMagnitude)
	{
		float num = ((!(forceMagnitude > derailCollisionForce)) ? (Mathf.Pow(forceMagnitude, 1.3f) / collisionDamageDivide) : float.MaxValue);
		Hurt(num, DamageType.Collision, this, useProtection: false);
		return num;
	}

	public bool SpaceIsClear()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapOBB(WorldSpaceBounds(), list, 32768, (QueryTriggerInteraction)1);
		foreach (Collider item in list)
		{
			if (!ColliderIsPartOfTrain(item))
			{
				Pool.FreeUnmanaged<Collider>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return true;
	}

	public bool ColliderIsPartOfTrain(Collider collider)
	{
		BaseEntity baseEntity = collider.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return false;
		}
		if ((Object)(object)baseEntity == (Object)(object)this)
		{
			return true;
		}
		BaseEntity baseEntity2 = baseEntity.parentEntity.Get(base.isServer);
		if (baseEntity2.IsValid())
		{
			return (Object)(object)baseEntity2 == (Object)(object)this;
		}
		return false;
	}

	public void UpdateClients()
	{
		if (IsMoving())
		{
			ClientRPC(RpcTarget.NetworkGroup("BaseTrainUpdate"), GetNetworkTime(), frontBogieYRot, rearBogieYRot);
		}
	}

	public void DecayTick()
	{
		if (completeTrain == null)
		{
			return;
		}
		bool flag = HasDriver() || completeTrain.AnyPlayersOnTrain();
		if (flag)
		{
			decayingFor = 0f;
		}
		float num = GetDecayMinutes(flag) * 60f;
		float time = Time.time;
		float num2 = time - lastDecayTick;
		lastDecayTick = time;
		if (num != float.PositiveInfinity)
		{
			decayingFor += num2;
			if (decayingFor >= num && CanDieFromDecayNow())
			{
				ActualDeath();
			}
		}
	}

	public virtual float GetDecayMinutes(bool hasPassengers)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		bool flag = IsAtAStation && Vector3.Distance(spawnOrigin, ((Component)this).transform.position) < 50f;
		if (hasPassengers || AnyPlayersNearby(30f) || flag || IsOnAboveGroundSpawnRail)
		{
			return float.PositiveInfinity;
		}
		return decayminutes * decayTimeMultiplier;
	}

	public virtual bool CanDieFromDecayNow()
	{
		if (CarType != TrainCarType.Engine)
		{
			return !completeTrain.IncludesAnEngine();
		}
		return true;
	}

	public bool AnyPlayersNearby(float maxDist)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return BaseNetworkable.HasCloseConnections(((Component)this).transform.position, maxDist);
	}

	[RPC_Server]
	public void RPC_WantsUncouple(RPCMessage msg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !(Vector3.SqrMagnitude(((Component)this).transform.position - ((Component)player).transform.position) > 200f) && Interface.CallHook("OnTrainCarUncouple", (object)this, (object)msg.player) == null)
		{
			bool front = msg.read.Bit();
			coupling.Uncouple(front);
		}
	}
}


public enum TrainCarType
{
	Wagon,
	Engine,
	Other
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TrainCarUnloadable : TrainCar
{
	public enum WagonType
	{
		Ore,
		Lootboxes,
		Fuel
	}

	[Header("Train Car Unloadable")]
	[SerializeField]
	private GameObjectRef storagePrefab;

	[SerializeField]
	private BoxCollider[] unloadingAreas;

	[SerializeField]
	private TrainCarFuelHatches fuelHatches;

	[SerializeField]
	private Transform orePlaneVisuals;

	[SerializeField]
	private Transform orePlaneColliderDetailed;

	[SerializeField]
	private Transform orePlaneColliderWorld;

	[Range(0f, 1f)]
	[SerializeField]
	public float vacuumStretchPercent = 0.5f;

	[SerializeField]
	private ParticleSystemContainer unloadingFXContainer;

	[SerializeField]
	private ParticleSystem unloadingFX;

	public WagonType wagonType;

	private int lootTypeIndex = -1;

	private List<EntityRef<LootContainer>> lootContainers = new List<EntityRef<LootContainer>>();

	private Vector3 _oreScale = Vector3.one;

	private float animPercent;

	private float prevAnimTime;

	[ServerVar(Help = "How long before an unloadable train car despawns afer being unloaded")]
	public static float decayminutesafterunload = 10f;

	private EntityRef<StorageContainer> storageInstance;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TrainCarUnloadable.OnRpcMessage", 0);
		try
		{
			if (rpc == 4254195175u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4254195175u, "RPC_Open", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Open(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Open");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old.HasFlag(Flags.Reserved4) != next.HasFlag(Flags.Reserved4) && (Object)(object)fuelHatches != (Object)null)
		{
			fuelHatches.LinedUpStateChanged(base.LinedUpToUnload);
		}
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		base.OnChildAdded(child);
		if (IsDead() || base.IsDestroyed)
		{
			return;
		}
		LootContainer lootContainer = default(LootContainer);
		if (((Component)child).TryGetComponent<LootContainer>(ref lootContainer))
		{
			if (base.isServer)
			{
				lootContainer.inventory.SetLocked(!IsEmpty());
			}
			lootContainers.Add(new EntityRef<LootContainer>(lootContainer.net.ID));
		}
		if (base.isServer && child.prefabID == storagePrefab.GetEntity().prefabID)
		{
			StorageContainer storageContainer = (StorageContainer)child;
			storageInstance.Set(storageContainer);
			if (!Application.isLoadingSave)
			{
				FillWithLoot(storageContainer);
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.baseTrain != null)
		{
			lootTypeIndex = info.msg.baseTrain.lootTypeIndex;
			if (base.isServer)
			{
				SetVisualOreLevel(info.msg.baseTrain.lootPercent);
			}
		}
	}

	public bool IsEmpty()
	{
		return GetOrePercent() == 0f;
	}

	public bool TryGetLootType(out TrainWagonLootData.LootOption lootOption)
	{
		return TrainWagonLootData.instance.TryGetLootFromIndex(lootTypeIndex, out lootOption);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		return !IsEmpty();
	}

	public int GetFilledLootAmount()
	{
		if (TryGetLootType(out var lootOption))
		{
			return lootOption.maxLootAmount;
		}
		Debug.LogWarning((object)(((object)this).GetType().Name + ": Called GetFilledLootAmount without a lootTypeIndex set."));
		return 0;
	}

	public void SetVisualOreLevel(float percent)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)orePlaneColliderDetailed == (Object)null))
		{
			_oreScale.y = Mathf.Clamp01(percent);
			orePlaneColliderDetailed.localScale = _oreScale;
			if (base.isClient)
			{
				orePlaneVisuals.localScale = _oreScale;
				((Component)orePlaneVisuals).gameObject.SetActive(percent > 0f);
			}
			if (base.isServer)
			{
				orePlaneColliderWorld.localScale = _oreScale;
			}
		}
	}

	private void AnimateUnload(float startPercent)
	{
		prevAnimTime = Time.time;
		animPercent = startPercent;
		if (base.isClient && (Object)(object)unloadingFXContainer != (Object)null)
		{
			unloadingFXContainer.Play();
		}
		((FacepunchBehaviour)this).InvokeRepeating((Action)UnloadAnimTick, 0f, 0f);
	}

	private void UnloadAnimTick()
	{
		animPercent -= (Time.time - prevAnimTime) / 40f;
		SetVisualOreLevel(animPercent);
		prevAnimTime = Time.time;
		if (animPercent <= 0f)
		{
			EndUnloadAnim();
		}
	}

	private void EndUnloadAnim()
	{
		if (base.isClient && (Object)(object)unloadingFXContainer != (Object)null)
		{
			unloadingFXContainer.Stop();
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)UnloadAnimTick);
	}

	public float GetOrePercent()
	{
		if (base.isServer)
		{
			return TrainWagonLootData.GetOrePercent(lootTypeIndex, GetStorageContainer());
		}
		return 0f;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseTrain.lootTypeIndex = lootTypeIndex;
		info.msg.baseTrain.lootPercent = GetOrePercent();
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			foreach (EntityRef<LootContainer> lootContainer2 in lootContainers)
			{
				LootContainer lootContainer = lootContainer2.Get(base.isServer);
				if ((Object)(object)lootContainer != (Object)null && lootContainer.inventory != null && !lootContainer.inventory.IsLocked())
				{
					lootContainer.DropItems();
				}
			}
		}
		base.DoServerDestroy();
	}

	public bool IsLinedUpToUnload(BoxCollider unloaderBounds)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		BoxCollider[] array = unloadingAreas;
		foreach (BoxCollider val in array)
		{
			Bounds val2 = ((Collider)unloaderBounds).bounds;
			if (((Bounds)(ref val2)).Intersects(((Collider)val).bounds))
			{
				return true;
			}
		}
		return false;
	}

	public void FillWithLoot(StorageContainer sc)
	{
		sc.inventory.Clear();
		ItemManager.DoRemoves();
		TrainWagonLootData.LootOption lootOption = TrainWagonLootData.instance.GetLootOption(wagonType, out lootTypeIndex);
		int amount = Random.Range(lootOption.minLootAmount, lootOption.maxLootAmount);
		ItemDefinition itemToCreate = ItemManager.FindItemDefinition(lootOption.lootItem.itemid);
		sc.inventory.AddItem(itemToCreate, amount, 0uL, ItemContainer.LimitStack.All);
		sc.inventory.SetLocked(isLocked: true);
		SetVisualOreLevel(GetOrePercent());
		SendNetworkUpdate();
	}

	public void EmptyOutLoot(StorageContainer sc)
	{
		sc.inventory.Clear();
		ItemManager.DoRemoves();
		SetVisualOreLevel(GetOrePercent());
		SendNetworkUpdate();
	}

	public void BeginUnloadAnimation()
	{
		float orePercent = GetOrePercent();
		AnimateUnload(orePercent);
		ClientRPC(RpcTarget.NetworkGroup("RPC_AnimateUnload"), orePercent);
	}

	public void EndEmptyProcess()
	{
		float orePercent = GetOrePercent();
		if (!(orePercent > 0f))
		{
			lootTypeIndex = -1;
			foreach (EntityRef<LootContainer> lootContainer2 in lootContainers)
			{
				LootContainer lootContainer = lootContainer2.Get(base.isServer);
				if ((Object)(object)lootContainer != (Object)null && lootContainer.inventory != null)
				{
					lootContainer.inventory.SetLocked(isLocked: false);
				}
			}
		}
		SetVisualOreLevel(orePercent);
		ClientRPC(RpcTarget.NetworkGroup("RPC_StopAnimateUnload"), orePercent);
		decayingFor = 0f;
	}

	public StorageContainer GetStorageContainer()
	{
		StorageContainer storageContainer = storageInstance.Get(base.isServer);
		if (storageContainer.IsValid())
		{
			return storageContainer;
		}
		return null;
	}

	protected override float GetDecayMinutes(bool hasPassengers)
	{
		if ((wagonType == WagonType.Ore || wagonType == WagonType.Fuel) && !hasPassengers && IsEmpty())
		{
			return decayminutesafterunload;
		}
		return base.GetDecayMinutes(hasPassengers);
	}

	protected override bool CanDieFromDecayNow()
	{
		if (IsEmpty())
		{
			return true;
		}
		return base.CanDieFromDecayNow();
	}

	public override bool AdminFixUp(int tier)
	{
		if (!base.AdminFixUp(tier))
		{
			return false;
		}
		StorageContainer storageContainer = GetStorageContainer();
		if (storageContainer.IsValid())
		{
			if (tier > 1)
			{
				FillWithLoot(storageContainer);
			}
			else
			{
				EmptyOutLoot(storageContainer);
			}
		}
		return true;
	}

	public float MinDistToUnloadingArea(Vector3 point)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		point.y = 0f;
		BoxCollider[] array = unloadingAreas;
		foreach (BoxCollider val in array)
		{
			Vector3 val2 = ((Component)val).transform.position + ((Component)val).transform.rotation * val.center;
			val2.y = 0f;
			float num2 = Vector3.Distance(point, val2);
			if (num2 < num)
			{
				num = num2;
			}
		}
		return num;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_Open(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			StorageContainer storageContainer = GetStorageContainer();
			if (storageContainer.IsValid())
			{
				storageContainer.PlayerOpenLoot(player);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}

	public void SetLootPercentage(float value)
	{
		TrainWagonLootData.SetOrePercent(lootTypeIndex, GetStorageContainer(), value);
	}
}


public enum WagonType
{
	Ore,
	Lootboxes,
	Fuel
}


using System;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using Rust.UI;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class TrainEngine : TrainCar, IEngineControllerUser, IEntity
{
	private enum LeverStyle
	{
		WorkCart,
		Locomotive
	}

	public enum EngineSpeeds
	{
		Rev_Hi,
		Rev_Med,
		Rev_Lo,
		Zero,
		Fwd_Lo,
		Fwd_Med,
		Fwd_Hi
	}

	[Header("Train Engine")]
	[SerializeField]
	public Transform leftHandLever;

	[SerializeField]
	public Transform rightHandLever;

	[SerializeField]
	public Transform leftHandGrip;

	[SerializeField]
	public Transform rightHandGrip;

	[SerializeField]
	private LeverStyle leverStyle;

	[SerializeField]
	public Canvas monitorCanvas;

	[SerializeField]
	public RustText monitorText;

	[SerializeField]
	private LocomotiveExtraVisuals gauges;

	[SerializeField]
	public float engineForce = 50000f;

	[SerializeField]
	public float maxSpeed = 12f;

	[SerializeField]
	public float engineStartupTime = 1f;

	[SerializeField]
	public GameObjectRef fuelStoragePrefab;

	[SerializeField]
	public float idleFuelPerSec = 0.05f;

	[SerializeField]
	public float maxFuelPerSec = 0.15f;

	[SerializeField]
	public ProtectionProperties driverProtection;

	[SerializeField]
	public bool lootablesAreOnPlatform;

	[SerializeField]
	private bool mustMountFromPlatform = true;

	[SerializeField]
	private VehicleLight[] onLights;

	[SerializeField]
	public VehicleLight[] headlights;

	[SerializeField]
	private VehicleLight[] notMovingLights;

	[SerializeField]
	private VehicleLight[] movingForwardLights;

	[FormerlySerializedAs("movingBackwardsLights")]
	[SerializeField]
	private VehicleLight[] movingBackwardLights;

	[SerializeField]
	public ParticleSystemContainer fxEngineOn;

	[SerializeField]
	public ParticleSystemContainer fxLightDamage;

	[SerializeField]
	public ParticleSystemContainer fxMediumDamage;

	[SerializeField]
	public ParticleSystemContainer fxHeavyDamage;

	[SerializeField]
	public ParticleSystemContainer fxEngineTrouble;

	[SerializeField]
	public BoxCollider engineWorldCol;

	[SerializeField]
	public float engineDamageToSlow = 150f;

	[SerializeField]
	public float engineDamageTimeframe = 10f;

	[SerializeField]
	public float engineSlowedTime = 10f;

	[SerializeField]
	public float engineSlowedMaxVel = 4f;

	[SerializeField]
	private ParticleSystemContainer[] sparks;

	[SerializeField]
	[FormerlySerializedAs("brakeSparkLights")]
	private Light[] sparkLights;

	[SerializeField]
	private TrainEngineAudio trainAudio;

	public const Flags Flag_HazardAhead = Flags.Reserved6;

	public const Flags Flag_Horn = Flags.Reserved8;

	public const Flags Flag_AltColor = Flags.Reserved9;

	public const Flags Flag_EngineSlowed = Flags.Reserved10;

	public VehicleEngineController<TrainEngine> engineController;

	public const float HAZARD_CHECK_EVERY = 1f;

	public const float HAZARD_DIST_MAX = 325f;

	public const float HAZARD_DIST_MIN = 20f;

	public const float HAZARD_SPEED_MIN = 4.5f;

	public float buttonHoldTime;

	public static readonly EngineSpeeds MaxThrottle = EngineSpeeds.Fwd_Hi;

	public static readonly EngineSpeeds MinThrottle = EngineSpeeds.Rev_Hi;

	public EngineDamageOverTime engineDamage;

	public Vector3 engineLocalOffset;

	private int __sync_FuelAmountSync;

	private int __sync_NumConnectedCarsSync;

	private int __sync_LinedUpToUnloadSync;

	public bool LightsAreOn => HasFlag(Flags.Reserved5);

	public bool CloseToHazard => HasFlag(Flags.Reserved6);

	public bool EngineIsSlowed => HasFlag(Flags.Reserved10);

	public EngineSpeeds CurThrottleSetting { get; set; } = EngineSpeeds.Zero;

	public override TrainCarType CarType => TrainCarType.Engine;

	[Sync(Autosave = true)]
	private int FuelAmountSync
	{
		[CompilerGenerated]
		get
		{
			return __sync_FuelAmountSync;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_FuelAmountSync, value))
			{
				__sync_FuelAmountSync = value;
				byte nameID = __GetWeaverID("FuelAmountSync");
				QueueSyncVar(nameID);
			}
		}
	}

	[Sync(Autosave = true)]
	private int NumConnectedCarsSync
	{
		[CompilerGenerated]
		get
		{
			return __sync_NumConnectedCarsSync;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_NumConnectedCarsSync, value))
			{
				__sync_NumConnectedCarsSync = value;
				byte nameID = __GetWeaverID("NumConnectedCarsSync");
				QueueSyncVar(nameID);
			}
		}
	}

	[Sync(Autosave = true, Pack = false)]
	private int LinedUpToUnloadSync
	{
		[CompilerGenerated]
		get
		{
			return __sync_LinedUpToUnloadSync;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_LinedUpToUnloadSync, value))
			{
				__sync_LinedUpToUnloadSync = value;
				byte nameID = __GetWeaverID("LinedUpToUnloadSync");
				SV_SyncVarSend(nameID);
			}
		}
	}

	public override bool networkUpdateOnCompleteTrainChange => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TrainEngine.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		EntityFuelSystem fuelSystem = new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
		engineController = new VehicleEngineController<TrainEngine>(this, fuelSystem, base.isServer, engineStartupTime);
		if (base.isServer)
		{
			bool b = SeedRandom.Range((uint)net.ID.Value, 0, 2) == 0;
			SetFlag(Flags.Reserved9, b);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.trainEngine != null)
		{
			engineController.FuelSystem.SetInstanceID(info.msg.trainEngine.fuelStorageID);
			SetThrottle((EngineSpeeds)info.msg.trainEngine.throttleSetting);
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		if (player.isMounted)
		{
			return false;
		}
		if (lootablesAreOnPlatform)
		{
			return PlayerIsOnPlatform(player);
		}
		Vector3 localVelocity = GetLocalVelocity();
		if (((Vector3)(ref localVelocity)).magnitude < 2f)
		{
			return true;
		}
		return PlayerIsOnPlatform(player);
	}

	public float GetEnginePowerMultiplier(float minPercent)
	{
		if (base.healthFraction > 0.4f)
		{
			return 1f;
		}
		return Mathf.Lerp(minPercent, 1f, base.healthFraction / 0.4f);
	}

	public float GetThrottleFraction()
	{
		return CurThrottleSetting switch
		{
			EngineSpeeds.Rev_Hi => -1f, 
			EngineSpeeds.Rev_Med => -0.5f, 
			EngineSpeeds.Rev_Lo => -0.2f, 
			EngineSpeeds.Zero => 0f, 
			EngineSpeeds.Fwd_Lo => 0.2f, 
			EngineSpeeds.Fwd_Med => 0.5f, 
			EngineSpeeds.Fwd_Hi => 1f, 
			_ => 0f, 
		};
	}

	public bool IsNearDesiredSpeed(float leeway)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Dot(((Component)this).transform.forward, GetLocalVelocity());
		float num2 = maxSpeed * GetThrottleFraction();
		if (num2 < 0f)
		{
			return num - leeway <= num2;
		}
		return num + leeway >= num2;
	}

	public override void SetTrackSelection(TrainTrackSpline.TrackSelection trackSelection)
	{
		base.SetTrackSelection(trackSelection);
	}

	public void SetThrottle(EngineSpeeds throttle)
	{
		if (CurThrottleSetting != throttle)
		{
			CurThrottleSetting = throttle;
			if (base.isServer)
			{
				ClientRPC(RpcTarget.NetworkGroup("SetThrottle"), (sbyte)throttle);
			}
		}
	}

	public bool CanMount(BasePlayer player)
	{
		if (mustMountFromPlatform)
		{
			return PlayerIsOnPlatform(player);
		}
		return true;
	}

	public override void ServerInit()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		engineDamage = new EngineDamageOverTime(engineDamageToSlow, engineDamageTimeframe, OnEngineTookHeavyDamage);
		engineLocalOffset = ((Component)this).transform.InverseTransformPoint(((Component)engineWorldCol).transform.position + ((Component)engineWorldCol).transform.rotation * engineWorldCol.center);
	}

	public override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned)
		{
			GetFuelSystem().CheckNewChild(child);
		}
		if (base.isServer && !enableSaving && child is StorageContainer)
		{
			child.EnableSaving(wants: false);
			child.InvalidateNetworkCache();
		}
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("TrainEngine.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			engineController.CheckEngineState();
			if (engineController.IsOn)
			{
				float fuelPerSecond = Mathf.Lerp(idleFuelPerSec, maxFuelPerSec, Mathf.Abs(GetThrottleFraction()));
				engineController.TickFuel(fuelPerSecond);
				FuelAmountSync = engineController.FuelSystem.GetFuelAmount();
				NumConnectedCarsSync = completeTrain.NumTrainCars;
				LinedUpToUnloadSync = completeTrain.LinedUpToUnload;
			}
			else if (LightsAreOn && !HasDriver())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.trainEngine = Pool.Get<TrainEngine>();
		info.msg.trainEngine.throttleSetting = (int)CurThrottleSetting;
		info.msg.trainEngine.fuelStorageID = GetFuelSystem().GetInstanceID();
	}

	public override IFuelSystem GetFuelSystem()
	{
		return engineController.FuelSystem;
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			SetFlag(Flags.Reserved5, !LightsAreOn);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (!IsDriver(player))
		{
			return;
		}
		if (engineController.IsOff)
		{
			if ((inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD)) || (inputState.IsDown(BUTTON.BACKWARD) && !inputState.WasDown(BUTTON.BACKWARD)))
			{
				engineController.TryStartEngine(player);
			}
			SetFlag(Flags.Reserved8, b: false);
		}
		else
		{
			if (!ProcessThrottleInput(BUTTON.FORWARD, IncreaseThrottle))
			{
				ProcessThrottleInput(BUTTON.BACKWARD, DecreaseThrottle);
			}
			SetFlag(Flags.Reserved8, inputState.IsDown(BUTTON.FIRE_PRIMARY));
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			SetTrackSelection(TrainTrackSpline.TrackSelection.Left);
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			SetTrackSelection(TrainTrackSpline.TrackSelection.Right);
		}
		else
		{
			SetTrackSelection(TrainTrackSpline.TrackSelection.Default);
		}
		bool ProcessThrottleInput(BUTTON button, Action action)
		{
			if (inputState.IsDown(button))
			{
				if (!inputState.WasDown(button))
				{
					action();
					buttonHoldTime = 0f;
				}
				else
				{
					buttonHoldTime += Player.clientTickInterval;
					if (buttonHoldTime > 0.55f)
					{
						action();
						buttonHoldTime = 0.4f;
					}
				}
				return true;
			}
			return false;
		}
	}

	public override void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerDismounted(player, seat);
		SetFlag(Flags.Reserved8, b: false);
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		driverProtection.Scale(info.damageTypes);
	}

	public bool MeetsEngineRequirements()
	{
		if (!HasDriver() && CurThrottleSetting == EngineSpeeds.Zero)
		{
			return false;
		}
		if (!completeTrain.AnyPlayersOnTrain())
		{
			return vehicle.trainskeeprunning;
		}
		return true;
	}

	public void OnEngineStartFailed()
	{
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (CanMount(player))
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

	protected override float GetThrottleForce()
	{
		if (IsDead() || base.IsDestroyed)
		{
			return 0f;
		}
		float num = 0f;
		float num2 = (engineController.IsOn ? GetThrottleFraction() : 0f);
		float num3 = maxSpeed * num2;
		float curTopSpeed = GetCurTopSpeed();
		num3 = Mathf.Clamp(num3, 0f - curTopSpeed, curTopSpeed);
		float trackSpeed = GetTrackSpeed();
		if (num2 > 0f && trackSpeed < num3)
		{
			num += GetCurEngineForce();
		}
		else if (num2 < 0f && trackSpeed > num3)
		{
			num -= GetCurEngineForce();
		}
		return num;
	}

	public override bool HasThrottleInput()
	{
		if (engineController.IsOn)
		{
			return CurThrottleSetting != EngineSpeeds.Zero;
		}
		return false;
	}

	public override void Hurt(HitInfo info)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (engineDamage != null && Vector3.SqrMagnitude(engineLocalOffset - info.HitPositionLocal) < 2f)
		{
			engineDamage.TakeDamage(info.damageTypes.Total());
		}
		base.Hurt(info);
	}

	public void StopEngine()
	{
		engineController.StopEngine();
	}

	public override Vector3 GetExplosionPos()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)engineWorldCol).transform.position + engineWorldCol.center;
	}

	public void IncreaseThrottle()
	{
		if (CurThrottleSetting != MaxThrottle)
		{
			SetThrottle(CurThrottleSetting + 1);
		}
	}

	public void DecreaseThrottle()
	{
		if (CurThrottleSetting != MinThrottle)
		{
			SetThrottle(CurThrottleSetting - 1);
		}
	}

	public void SetZeroThrottle()
	{
		SetThrottle(EngineSpeeds.Zero);
	}

	public override void ServerFlagsChanged(Flags old, Flags next)
	{
		base.ServerFlagsChanged(old, next);
		if (next.HasFlag(Flags.On) && !old.HasFlag(Flags.On))
		{
			SetFlag(Flags.Reserved5, b: true);
			((FacepunchBehaviour)this).InvokeRandomized((Action)CheckForHazards, 0f, 1f, 0.1f);
		}
		else if (!next.HasFlag(Flags.On) && old.HasFlag(Flags.On))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckForHazards);
			SetFlag(Flags.Reserved6, b: false);
		}
	}

	public void CheckForHazards()
	{
		float trackSpeed = GetTrackSpeed();
		if (trackSpeed > 4.5f || trackSpeed < -4.5f)
		{
			float maxHazardDist = Mathf.Lerp(40f, 325f, Mathf.Abs(trackSpeed) * 0.05f);
			SetFlag(Flags.Reserved6, base.FrontTrackSection.HasValidHazardWithin(this, base.FrontWheelSplineDist, 20f, maxHazardDist, localTrackSelection, trackSpeed, base.RearTrackSection, null));
		}
		else
		{
			SetFlag(Flags.Reserved6, b: false);
		}
	}

	public void OnEngineTookHeavyDamage()
	{
		SetFlag(Flags.Reserved10, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ResetEngineToNormal, engineSlowedTime);
	}

	public void ResetEngineToNormal()
	{
		SetFlag(Flags.Reserved10, b: false);
	}

	public float GetCurTopSpeed()
	{
		float num = maxSpeed * GetEnginePowerMultiplier(0.5f);
		if (EngineIsSlowed)
		{
			num = Mathf.Clamp(num, 0f - engineSlowedMaxVel, engineSlowedMaxVel);
		}
		return num;
	}

	public float GetCurEngineForce()
	{
		return engineForce * GetEnginePowerMultiplier(0.75f);
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId iD;
		switch (id)
		{
		case 0:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: FuelAmountSync for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_FuelAmountSync);
			return true;
		case 1:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: NumConnectedCarsSync for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_NumConnectedCarsSync);
			return true;
		case 2:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: LinedUpToUnloadSync for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_LinedUpToUnloadSync);
			return true;
		default:
			return base.WriteSyncVar(id, writer);
		}
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		switch (id)
		{
		case 0:
			try
			{
				_ = __sync_FuelAmountSync;
				int _sync_FuelAmountSync = reader.Int32();
				__sync_FuelAmountSync = _sync_FuelAmountSync;
			}
			catch (Exception ex2)
			{
				Debug.LogException(ex2);
			}
			return true;
		case 1:
			try
			{
				_ = __sync_NumConnectedCarsSync;
				int _sync_NumConnectedCarsSync = reader.Int32();
				__sync_NumConnectedCarsSync = _sync_NumConnectedCarsSync;
			}
			catch (Exception ex3)
			{
				Debug.LogException(ex3);
			}
			return true;
		case 2:
			try
			{
				_ = __sync_LinedUpToUnloadSync;
				int _sync_LinedUpToUnloadSync = reader.Int32();
				__sync_LinedUpToUnloadSync = _sync_LinedUpToUnloadSync;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			return true;
		default:
			return base.OnSyncVar(id, reader, fromAutoSave);
		}
	}

	private byte __GetWeaverID(string propertyName)
	{
		return propertyName switch
		{
			"FuelAmountSync" => 0, 
			"NumConnectedCarsSync" => 1, 
			"LinedUpToUnloadSync" => 2, 
			_ => byte.MaxValue, 
		};
	}

	protected override void WriteAutoSaveSyncVars(NetWrite writer)
	{
		base.WriteAutoSaveSyncVars(writer);
		WriteSyncVar(0, writer);
		WriteSyncVar(1, writer);
		WriteSyncVar(2, writer);
	}

	protected override void ReadAutoSaveSyncVars(NetRead reader)
	{
		base.ReadAutoSaveSyncVars(reader);
		OnSyncVar(0, reader, fromAutoSave: true);
		OnSyncVar(1, reader, fromAutoSave: true);
		OnSyncVar(2, reader, fromAutoSave: true);
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		base.AutoSaveSyncVars(save);
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteAutoSaveSyncVars(val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		base.AutoLoadSyncVars(load);
		if (load.msg.baseEntity != null && load.msg.baseEntity.syncVars != null)
		{
			NetRead val = Pool.Get<NetRead>();
			val.Init(load.msg.baseEntity.syncVars.AsSpan());
			ReadAutoSaveSyncVars(val);
			Pool.Free<NetRead>(ref val);
		}
		return true;
	}

	protected override void ResetSyncVars()
	{
		base.ResetSyncVars();
		__sync_FuelAmountSync = 0;
		__sync_NumConnectedCarsSync = 0;
		__sync_LinedUpToUnloadSync = 0;
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		return id switch
		{
			0 => true, 
			1 => true, 
			2 => true, 
			_ => base.ShouldInvalidateCache(id), 
		};
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


private enum LeverStyle
{
	WorkCart,
	Locomotive
}


public enum EngineSpeeds
{
	Rev_Hi,
	Rev_Med,
	Rev_Lo,
	Zero,
	Fwd_Lo,
	Fwd_Med,
	Fwd_Hi
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TravellingVendor : BaseEntity, VehicleChassisVisuals<TravellingVendor>.IClientWheelUser, IPathListener
{
	private enum TravellingVendorState
	{
		Stopped,
		Travelling,
		Waiting,
		Aligning
	}

	public static class TravellingVendorFlags
	{
		public const Flags Braking = Flags.Reserved1;

		public const Flags IndicateLeft = Flags.Reserved2;

		public const Flags IndicateRight = Flags.Reserved4;

		public const Flags Lights = Flags.Reserved5;

		public const Flags Hazards = Flags.Reserved6;
	}

	[Flags]
	private enum WheelIsGroundedFlags
	{
		RearLeft = 1,
		RearRight = 2,
		FrontLeft = 4,
		FrontRight = 8
	}

	[Serializable]
	private struct VendorTargetInfo
	{
		public float lastSeenTime;

		public float lastBlockingTime;

		public float blockingAccumulator;

		public float ignoredUntil;

		public bool IsIgnored => ignoredUntil > Time.time;
	}

	[Header("Visuals")]
	public TravellingVendorVisuals visuals;

	[Header("Sounds")]
	public TravellingVendorSounds sounds;

	public SoundPlayer BuySound;

	[Header("References")]
	[SerializeField]
	private VisualCarWheel wheelFL;

	[SerializeField]
	private VisualCarWheel wheelFR;

	[SerializeField]
	private VisualCarWheel wheelRL;

	[SerializeField]
	private VisualCarWheel wheelRR;

	public float client_steering_left;

	public float client_steering_right;

	public Vector3 client_velocity = Vector3.zero;

	private WheelIsGroundedFlags client_wheel_flags;

	public TimeSince timeSinceLastUpdate;

	public VehicleLight headlight;

	public VehicleLight rearLights;

	public VehicleLight rearLeftIndicator;

	public VehicleLight rearRightIndicator;

	private static Collider[] spawncheckColliders = (Collider[])(object)new Collider[2];

	public const string PREFAB_PATH = "assets/prefabs/npc/travelling vendor/travellingvendor.prefab";

	[Header("General")]
	public bool DoAI = true;

	public float ObstacleCheckTime = 0.33f;

	public float MarkerUpdateTime = 0.05f;

	public float TimeBetweenPullovers = 120f;

	[Header("Engine Config")]
	public float motorForceConstant = 300f;

	public float brakeForceConstant = 500f;

	public float acceleration = 2f;

	[Header("Steer Config")]
	public float wheelbase = 3.3f;

	public float rearTrack = 1.6f;

	public float steeringSmoothing = 0.1f;

	public float downforceCoefficient = 10f;

	public float maxSteerAngle = 80f;

	[Header("Trade")]
	public GameObjectRef vendingMachineRef;

	public GameObjectRef vendingMachineFrontRef;

	[Header("Pullover")]
	public float maxPulloverAngleDifference = 15f;

	[Header("Other")]
	public static int obstacleMask = 196608;

	[Header("References")]
	public GameObjectRef mapMarkerEntityPrefab;

	public GameObjectRef preventBuildingPrefab;

	public GameObjectRef backfireEffect;

	public Transform backfirePosition;

	private TriggerVehiclePush pusher;

	private TriggerPlayerForce forcer;

	public NPCVendingMachine vendingMachine;

	[Header("Spline")]
	public float splineMovementSpeed = 2f;

	public Vector3 splineOffset;

	[ServerVar]
	public static bool should_spawn = true;

	[ServerVar]
	public static bool attempt_pullovers = true;

	[ServerVar]
	public static float alive_time_seconds = 1800f;

	[ServerVar]
	public static bool should_destroy_buildings = false;

	[ReplicatedVar(Saved = true)]
	public static float max_speed = 5f;

	private float smoothedSteering;

	private float brakes;

	private float throttle;

	private float targetThrottle = 3f;

	private bool handbrake = true;

	private float steeringAngle;

	private float currentMaxSpeed;

	private Rigidbody myRigidbody;

	private List<RaycastHit> obstacleHits;

	private List<RaycastHit> pulloverHits;

	private Vector3 destination;

	private bool instantLeave;

	private float waitTimeAccumulator;

	private float aliveTimer;

	private TimeSince timeSinceBackfire;

	private bool pullingOver;

	private Vector3 pulloverPosition = Vector3.zero;

	private float pullOverTimer;

	private Vector3 pulloverTangent = Vector3.zero;

	private bool overrideSteering;

	private BaseEntity preventBuildingInstance;

	private RaycastHit hit;

	private TravellingVendorState internalState;

	private WheelIsGroundedFlags wheelFlags;

	private SimpleSplineTranslator splineTranslator;

	private MapMarker mapMarkerInstance;

	private bool globaIndicatorLeft;

	private TimeSince timeSincePlayerDetected;

	private float slowdownStartSpeed;

	private List<Vector3> currentPath;

	private int currentPathIndex;

	private float atDestinationDistance = 8f;

	private bool followingSpine;

	private int splineId = -1;

	private WorldSpline spline;

	private ListDictionary<BasePlayer, VendorTargetInfo> playerRecords;

	private List<BasePlayer> localPlayers;

	private int searchRange = 10;

	private float allowedVendorBlockTime = 1f;

	public Vector3 Velocity => client_velocity;

	public float DriveWheelVelocity => ((Vector3)(ref client_velocity)).magnitude;

	public float SteerAngle => (client_steering_left + client_steering_right) / 2f;

	public float MaxSteerAngle => maxSteerAngle;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TravellingVendor.OnRpcMessage", 0);
		try
		{
			if (rpc == 831304742 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_OpenMenu "));
				}
				TimeWarning val2 = TimeWarning.New("SV_OpenMenu", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(831304742u, "SV_OpenMenu", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_OpenMenu(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_OpenMenu");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public float GetThrottleInput()
	{
		return 1f;
	}

	[ServerVar(Name = "spawn")]
	public static string svspawntravellingvendor(Arg args)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)SpawnTravellingVendor(((Component)args.Player()).transform.position) != (Object)null))
		{
			return "Failed to spawn Travelling Vendor. Is there a ring road present?";
		}
		return "Spawned Travelling Vendor.";
	}

	[ServerVar(Name = "startevent")]
	public static string svspawntravellingvendorevent(Arg args)
	{
		if (!((Object)(object)SpawnTravellingVendorForEvent() != (Object)null))
		{
			return "Failed to spawn Travelling Vendor.";
		}
		return "Spawned Travelling Vendor.";
	}

	public static TravellingVendor SpawnTravellingVendor(Vector3 position)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		RuntimePath runtimePath = new RuntimePath();
		PathList pathList = null;
		float num = float.PositiveInfinity;
		foreach (PathList mainRoad in TerrainMeta.Path.MainRoads)
		{
			_ = Vector3.zero;
			float num2 = float.PositiveInfinity;
			Vector3[] points = mainRoad.Path.Points;
			foreach (Vector3 val in points)
			{
				float num3 = Vector3.Distance(val, position);
				if (num3 < num2)
				{
					num2 = num3;
				}
			}
			if (num2 < num)
			{
				pathList = mainRoad;
				num = num2;
			}
		}
		if (pathList == null)
		{
			Debug.Log((object)"Couldn't find road to spawn on.");
			return null;
		}
		Vector3 startPoint = pathList.Path.GetStartPoint();
		pathList.Path.GetEndPoint();
		int num4 = pathList.Path.Points.Length - 1;
		IAIPathNode[] nodes = new RuntimePathNode[num4];
		runtimePath.Nodes = nodes;
		IAIPathNode iAIPathNode = null;
		int num5 = 0;
		int num6 = pathList.Path.MaxIndex - 1;
		for (int j = pathList.Path.MinIndex; j <= num6; j++)
		{
			IAIPathNode iAIPathNode2 = new RuntimePathNode(pathList.Path.Points[j] + Vector3.up * 1f);
			if (iAIPathNode != null)
			{
				iAIPathNode2.AddLink(iAIPathNode);
				iAIPathNode.AddLink(iAIPathNode2);
			}
			runtimePath.Nodes[num5] = iAIPathNode2;
			iAIPathNode = iAIPathNode2;
			num5++;
		}
		runtimePath.Nodes[0].AddLink(runtimePath.Nodes[runtimePath.Nodes.Length - 1]);
		runtimePath.Nodes[runtimePath.Nodes.Length - 1].AddLink(runtimePath.Nodes[0]);
		int num7 = Mathf.CeilToInt(pathList.Path.Length / 500f);
		num7 = Mathf.Clamp(num7, 1, 3);
		num7++;
		for (int k = 0; k < num7; k++)
		{
			int num8 = Random.Range(0, pathList.Path.Points.Length);
			RuntimeInterestNode interestNode = new RuntimeInterestNode(pathList.Path.Points[num8] + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode);
		}
		Vector3 val2 = runtimePath.Nodes[1].Position - startPoint;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/travelling vendor/travellingvendor.prefab", startPoint + Vector3.up * 2f, Quaternion.LookRotation(normalized));
		TravellingVendor travellingVendor = null;
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			travellingVendor = ((Component)baseEntity).GetComponent<TravellingVendor>();
			if (Object.op_Implicit((Object)(object)travellingVendor))
			{
				travellingVendor.Spawn();
				travellingVendor.InstallPath(runtimePath, 1);
			}
			else
			{
				baseEntity.Kill();
			}
		}
		return travellingVendor;
	}

	private static (bool Valid, int Index) GetSpawnPoint(Vector3[] points)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		int num = Random.Range(0, points.Length);
		for (int i = 0; i < 15; i++)
		{
			if (CheckSpawnPosition(points[num]))
			{
				return (Valid: true, Index: num);
			}
			num = Random.Range(0, points.Length);
		}
		Debug.Log((object)("Failed to spawn a travelling vendor after " + 15 + " attempts."));
		return (Valid: false, Index: 0);
	}

	public static TravellingVendor SpawnTravellingVendorForEvent()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		RuntimePath runtimePath = new RuntimePath();
		PathList pathList = null;
		if (TerrainMeta.Path.MainRoads.Count == 0)
		{
			Debug.Log((object)"Can't spawn Travelling Vendor: No roads available to spawn on.");
			return null;
		}
		foreach (PathList mainRoad in TerrainMeta.Path.MainRoads)
		{
			if (mainRoad.Path.GetStartPoint() == mainRoad.Path.GetEndPoint())
			{
				pathList = mainRoad;
				break;
			}
		}
		if (pathList == null)
		{
			Debug.Log((object)"Can't spawn Travelling Vendor: can't find Ring Road.");
			return null;
		}
		if (pathList.Path.Points.Length == 0)
		{
			Debug.Log((object)"Can't spawn Travelling Vendor: Road has no points.");
			return null;
		}
		int num = pathList.Path.Points.Length - 1;
		IAIPathNode[] nodes = new RuntimePathNode[num];
		runtimePath.Nodes = nodes;
		IAIPathNode iAIPathNode = null;
		int num2 = 0;
		int num3 = pathList.Path.MaxIndex - 1;
		for (int i = pathList.Path.MinIndex; i <= num3; i++)
		{
			IAIPathNode iAIPathNode2 = new RuntimePathNode(pathList.Path.Points[i] + Vector3.up * 1f);
			if (iAIPathNode != null)
			{
				iAIPathNode2.AddLink(iAIPathNode);
				iAIPathNode.AddLink(iAIPathNode2);
			}
			runtimePath.Nodes[num2] = iAIPathNode2;
			iAIPathNode = iAIPathNode2;
			num2++;
		}
		runtimePath.Nodes[0].AddLink(runtimePath.Nodes[runtimePath.Nodes.Length - 1]);
		runtimePath.Nodes[runtimePath.Nodes.Length - 1].AddLink(runtimePath.Nodes[0]);
		int num4 = Mathf.CeilToInt(pathList.Path.Length / 500f);
		num4 = Mathf.Clamp(num4, 1, 3);
		num4++;
		for (int j = 0; j < num4; j++)
		{
			int num5 = Random.Range(0, pathList.Path.Points.Length);
			RuntimeInterestNode interestNode = new RuntimeInterestNode(pathList.Path.Points[num5] + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode);
		}
		(bool, int) spawnPoint = GetSpawnPoint(pathList.Path.Points);
		if (spawnPoint.Item1)
		{
			int item = spawnPoint.Item2;
			Vector3 val = pathList.Path.Points[(item + 1) % pathList.Path.Points.Length] - pathList.Path.Points[item];
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/travelling vendor/travellingvendor.prefab", pathList.Path.Points[item] + Vector3.up * 2f, Quaternion.LookRotation(normalized));
			TravellingVendor travellingVendor = null;
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				travellingVendor = ((Component)baseEntity).GetComponent<TravellingVendor>();
				if (Object.op_Implicit((Object)(object)travellingVendor))
				{
					travellingVendor.Spawn();
					travellingVendor.InstallPath(runtimePath, (item + 1) % pathList.Path.Points.Length);
				}
				else
				{
					baseEntity.Kill();
				}
			}
			return travellingVendor;
		}
		return null;
	}

	private static bool CheckSpawnPosition(Vector3 testPosition)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.TopologyMap.GetTopology(testPosition, 1024))
		{
			return false;
		}
		Physics.OverlapSphereNonAlloc(testPosition, 0.3f, spawncheckColliders, obstacleMask | 0x8000000);
		bool flag = false;
		Collider[] array = spawncheckColliders;
		foreach (Collider val in array)
		{
			if (!((Object)(object)val == (Object)null) && !((Component)val).CompareTag("IgnoreCollider"))
			{
				flag = true;
				break;
			}
		}
		return !flag;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child.prefabID == vendingMachineRef.GetEntity().prefabID && !Application.isLoadingSave)
		{
			vendingMachine = child as NPCVendingMachine;
			if (base.isServer && (Object)(object)vendingMachine != (Object)null)
			{
				vendingMachine.SetFlag(Flags.Reserved4, b: false);
				vendingMachine.UpdateMapMarker();
				vendingMachine.ChangeRefillTime(alive_time_seconds * 0.334f);
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SV_OpenMenu(RPCMessage msg)
	{
		if ((Object)(object)vendingMachine == (Object)null)
		{
			vendingMachine = ((Component)this).GetComponentInChildren<NPCVendingMachine>();
		}
		if (Interface.CallHook("OnVendingShopOpen", (object)vendingMachine, (object)msg.player) == null)
		{
			vendingMachine.OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", (object)vendingMachine, (object)msg.player);
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override bool IsDebugging()
	{
		return false;
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		BaseCombatEntity baseCombatEntity = info.Initiator as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity != (Object)null)
		{
			baseCombatEntity.MarkHostileFor();
		}
	}

	public void CreateMapMarker()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)mapMarkerInstance != (Object)null)
		{
			mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		mapMarkerInstance = baseEntity as MapMarker;
	}

	public void CreatePreventBuilding()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)preventBuildingInstance != (Object)null)
		{
			preventBuildingInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(preventBuildingPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		preventBuildingInstance = baseEntity;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		UpdateWheelFlags();
		info.msg.travellingVendor = Pool.Get<TravellingVendor>();
		info.msg.travellingVendor.steeringAngle = wheelFL.wheelCollider.steerAngle;
		info.msg.travellingVendor.velocity = (IsFollowingSpline() ? (((Component)this).transform.forward * splineTranslator.Speed) : myRigidbody.velocity);
		info.msg.travellingVendor.wheelFlags = (int)wheelFlags;
	}

	public override void ServerInit()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (!base.isClient)
		{
			myRigidbody = ((Component)this).GetComponent<Rigidbody>();
			obstacleHits = Pool.Get<List<RaycastHit>>();
			pulloverHits = Pool.Get<List<RaycastHit>>();
			currentMaxSpeed = max_speed;
			timeSinceBackfire = TimeSince.op_Implicit(0f);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved1, b: false);
			SetFlag(Flags.Reserved5, b: false);
			NightCheck();
			pusher = ((Component)this).GetComponentInChildren<TriggerVehiclePush>();
			forcer = ((Component)this).GetComponentInChildren<TriggerPlayerForce>();
			CreateMapMarker();
			CreatePreventBuilding();
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateObstacles, 0f, ObstacleCheckTime);
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateMarker, 0f, MarkerUpdateTime);
			((FacepunchBehaviour)this).InvokeRepeating((Action)BuildingCheck, 1f, 3f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)NightCheck, 0f, 120f);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if ((Object)(object)preventBuildingInstance != (Object)null && preventBuildingInstance.IsValid())
		{
			preventBuildingInstance.Kill();
		}
		if ((Object)(object)mapMarkerInstance != (Object)null && mapMarkerInstance.IsValid())
		{
			mapMarkerInstance.Kill();
		}
		if (localPlayers != null)
		{
			Pool.FreeUnmanaged<BasePlayer>(ref localPlayers);
		}
		if (obstacleHits != null)
		{
			Pool.FreeUnmanaged<RaycastHit>(ref obstacleHits);
		}
		if (pulloverHits != null)
		{
			Pool.FreeUnmanaged<RaycastHit>(ref pulloverHits);
		}
		if (currentPath != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref currentPath);
		}
	}

	private void StartBackfire()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(backfireEffect.resourcePath, this, 0u, backfirePosition.localPosition, Vector3.zero);
	}

	private void StartHorn()
	{
		ClientRPC(RpcTarget.NetworkGroup("CL_PlayerDetected"));
	}

	private void FixedUpdate()
	{
		if (!base.isClient && DoAI && HasPath())
		{
			ProcessLifetime();
			ProcessHandbrake();
			if (!IsFollowingSpline())
			{
				DoSteering();
				ApplyDownforce();
			}
			ProcessState();
			FetchTargets();
			SendNetworkUpdate();
		}
	}

	private void ProcessHandbrake()
	{
		if (handbrake && !(aliveTimer <= 5f) && wheelFL.wheelCollider.isGrounded && wheelFR.wheelCollider.isGrounded)
		{
			handbrake = false;
			wheelFL.wheelCollider.brakeTorque = 0f;
			wheelFR.wheelCollider.brakeTorque = 0f;
			wheelRL.wheelCollider.brakeTorque = 0f;
			wheelRR.wheelCollider.brakeTorque = 0f;
		}
	}

	private void SetGlobalIndicator()
	{
		if (HasFlag(Flags.Reserved6))
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		if (globaIndicatorLeft)
		{
			SetFlag(Flags.Reserved2, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved4, b: true);
		}
	}

	private void TurnOffIndicators()
	{
		if (HasFlag(Flags.Reserved2) || HasFlag(Flags.Reserved4))
		{
			SetFlag(Flags.Reserved2, b: false);
			SetFlag(Flags.Reserved4, b: false);
		}
	}

	private void UpdateMarker()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)mapMarkerInstance == (Object)null))
		{
			((Component)mapMarkerInstance).transform.SetPositionAndRotation(((Component)this).transform.position, ((Component)this).transform.rotation);
			mapMarkerInstance.SendNetworkUpdate();
		}
	}

	private void NightCheck()
	{
		bool flag = (Object)(object)TOD_Sky.Instance != (Object)null && (TOD_Sky.Instance.Cycle.Hour > 19f || TOD_Sky.Instance.Cycle.Hour < 8f);
		if (HasFlag(Flags.Reserved5) != flag)
		{
			SetFlag(Flags.Reserved5, flag);
		}
	}

	private void ProcessLifetime()
	{
		aliveTimer += Time.deltaTime;
		if (!(aliveTimer >= alive_time_seconds))
		{
			return;
		}
		if (localPlayers.Count > 0)
		{
			aliveTimer += 120f;
			return;
		}
		if ((Object)(object)mapMarkerInstance != (Object)null)
		{
			mapMarkerInstance.Kill();
		}
		if ((Object)(object)preventBuildingInstance != (Object)null)
		{
			preventBuildingInstance.Kill();
		}
		TravellingVendorEvent.currentVendor = null;
		Kill();
	}

	private void ProcessState()
	{
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return;
		}
		if (internalState == TravellingVendorState.Stopped)
		{
			targetThrottle = 0f;
			if (HasPath())
			{
				internalState = TravellingVendorState.Travelling;
			}
		}
		if (internalState == TravellingVendorState.Travelling)
		{
			targetThrottle = 2f;
			if (instantLeave)
			{
				instantLeave = false;
			}
			if (overrideSteering)
			{
				overrideSteering = false;
			}
			if (!IsFollowingSpline())
			{
				if (!pullingOver)
				{
					AdvancePath();
					pullOverTimer += Time.deltaTime;
					if (pullOverTimer > TimeBetweenPullovers && attempt_pullovers)
					{
						pullingOver = true;
					}
				}
				else
				{
					HandlePullover();
				}
			}
			if (CheckForObstacle())
			{
				instantLeave = true;
				SetWaiting();
				return;
			}
			if (!IsFollowingSpline())
			{
				ApplyForceAtWheels();
			}
			else
			{
				TravelOnSpline();
			}
			if (IsValidPatrons())
			{
				if (pulloverPosition != Vector3.zero)
				{
					return;
				}
				SetWaiting();
			}
		}
		if (internalState == TravellingVendorState.Aligning)
		{
			targetThrottle = 0.2f;
			Vector3 val = currentPath[GetPathIndexAhead(3)] - currentPath[GetPathIndexAhead(2)];
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float steerAngle = ((Vector3.Dot(((Component)this).transform.right, normalized) <= 0f) ? (0f - MaxSteerAngle) : MaxSteerAngle);
			if (Vector3.Angle(((Component)this).transform.forward, pulloverTangent) > 5f)
			{
				wheelFL.wheelCollider.steerAngle = steerAngle;
				wheelFR.wheelCollider.steerAngle = steerAngle;
				ApplyForceAtWheels();
			}
			else
			{
				overrideSteering = false;
				SetPulloverWaiting();
			}
		}
		if (internalState != TravellingVendorState.Waiting)
		{
			return;
		}
		targetThrottle = 0f;
		if (!IsFollowingSpline())
		{
			ApplyBrakesAtWheels();
		}
		else
		{
			SlowOnSpline();
		}
		if (CheckForObstacle())
		{
			return;
		}
		if (!IsValidPatrons() || instantLeave)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)SetTravelling))
			{
				float num = 0f;
				if (waitTimeAccumulator > 0f)
				{
					num = GetWaitAccumulator();
				}
				float num2 = 10f + num;
				((FacepunchBehaviour)this).Invoke((Action)SetTravelling, instantLeave ? 0f : num2);
				if (!instantLeave)
				{
					((FacepunchBehaviour)this).Invoke((Action)SetGlobalIndicator, num2 - 5f);
				}
			}
		}
		else if (((FacepunchBehaviour)this).IsInvoking((Action)SetTravelling))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SetTravelling);
		}
	}

	private void HandlePullover()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (pulloverPosition == Vector3.zero && !FindPullingOverSpot())
		{
			ResetPullover();
			pulloverPosition = Vector3.zero;
			currentMaxSpeed = 1f;
		}
		else
		{
			if (!AtDestination())
			{
				return;
			}
			if (Vector3.Angle(((Component)this).transform.forward, pulloverTangent) > 5f && pulloverPosition != Vector3.zero)
			{
				Vector3 position = pulloverPosition + pulloverTangent * 2f;
				if (!IsPositionClear(position, 2f))
				{
					SetPulloverWaiting();
					return;
				}
				overrideSteering = true;
				internalState = TravellingVendorState.Aligning;
				SetFlag(Flags.Reserved1, b: false);
			}
			else
			{
				SetPulloverWaiting();
			}
		}
	}

	private void SetPulloverWaiting()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		currentPathIndex = GetPathIndexAhead(4);
		SetDestination(currentPath[currentPathIndex]);
		SetWaiting();
		TurnOffIndicators();
		SetFlag(Flags.Reserved6, b: true);
		waitTimeAccumulator += 60f;
		ResetPullover();
	}

	private bool FindPullingOverSpot()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		pulloverHits.Clear();
		bool flag = Random.value > 0.5f;
		Vector3 val = currentPath[GetPathIndexAhead(3)] - currentPath[GetPathIndexAhead(2)];
		pulloverTangent = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Vector3.Cross(((Component)this).transform.up, pulloverTangent);
		Vector3 val3 = Vector3.Cross(pulloverTangent, ((Component)this).transform.up);
		if (!TryFindClearPulloverPoint(flag, out var testedPosition))
		{
			flag = !flag;
			if (!TryFindClearPulloverPoint(flag, out testedPosition))
			{
				return false;
			}
		}
		globaIndicatorLeft = !flag;
		if (flag)
		{
			SetFlag(Flags.Reserved2, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved4, b: true);
		}
		if ((Object)(object)preventBuildingInstance != (Object)null)
		{
			preventBuildingInstance.SetParent(null);
			((Component)preventBuildingInstance).transform.position = pulloverPosition;
		}
		pulloverPosition = testedPosition;
		SetDestination(pulloverPosition, 2f);
		return true;
	}

	private Vector3 GetAdjustedPulloverPoint(bool onLeft)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		Vector3 side = (onLeft ? Vector3.Cross(pulloverTangent, ((Component)this).transform.up) : Vector3.Cross(((Component)this).transform.up, pulloverTangent));
		Vector3 pulloverPointFromSide = GetPulloverPointFromSide(side);
		float height = TerrainMeta.HeightMap.GetHeight(pulloverPointFromSide);
		pulloverPointFromSide.y = height + 1f;
		return pulloverPointFromSide;
	}

	private bool TryFindClearPulloverPoint(bool onLeft, out Vector3 testedPosition)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 adjustedPulloverPoint = GetAdjustedPulloverPoint(onLeft);
		Vector3 val = adjustedPulloverPoint - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		testedPosition = adjustedPulloverPoint;
		bool num = IsDirectionClear(normalized, adjustedPulloverPoint);
		bool flag = IsPositionClear(adjustedPulloverPoint);
		return num && flag;
	}

	private Vector3 GetPulloverPointFromSide(Vector3 side, bool inFront = true)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (inFront)
		{
			return currentPath[GetPathIndexAhead(2)] + side * 3.2f + pulloverTangent * 3f;
		}
		return currentPath[GetPathIndexAhead(-2)] + side * 3.2f + pulloverTangent * 3f;
	}

	private bool IsPositionClear(Vector3 position, float radiusCheck = 4.5f)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(position, radiusCheck, list, obstacleMask, (QueryTriggerInteraction)2);
		bool result = true;
		if (list == null)
		{
			return false;
		}
		if (list.Count > 0)
		{
			foreach (Collider item in list)
			{
				if (!((Object)(object)item == (Object)null) && !((Object)(object)((Component)item).gameObject == (Object)null) && !((Object)(object)((Component)item).transform == (Object)null) && !((Component)item).transform.IsChildOf(((Component)this).transform) && !((Object)(object)((Component)item).transform == (Object)(object)((Component)this).transform) && !((Component)item).CompareTag("IgnoreCollider"))
				{
					result = false;
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private bool IsDirectionClear(Vector3 direction, Vector3 point)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		UpdateObstacleList(pulloverHits, direction, 3.5f);
		foreach (RaycastHit pulloverHit in pulloverHits)
		{
			RaycastHit current = pulloverHit;
			if (!((Component)((RaycastHit)(ref current)).collider).CompareTag("IgnoreCollider") && !((Component)((RaycastHit)(ref current)).collider).CompareTag("Main Terrain") && !((Component)((RaycastHit)(ref current)).collider).transform.IsChildOf(((Component)this).transform) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).transform == (Object)(object)((Component)this).transform))
			{
				return false;
			}
		}
		float height = TerrainMeta.HeightMap.GetHeight(point);
		Vector3 testPos = point;
		testPos.y = height + 1f;
		if (Vector3Ex.DotDegrees(((Component)this).transform.up, GetTerrainNormal(testPos)) >= maxPulloverAngleDifference)
		{
			return false;
		}
		return true;
	}

	private Vector3 GetTerrainNormal(Vector3 testPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (TransformUtil.GetGroundInfo(testPos, out hit, 100f, LayerMask.op_Implicit(8388608)))
		{
			return ((RaycastHit)(ref hit)).normal;
		}
		return Vector3.zero;
	}

	private void SetWaiting()
	{
		internalState = TravellingVendorState.Waiting;
		((Behaviour)forcer).enabled = false;
		((Behaviour)pusher).enabled = false;
		SetFlag(Flags.Reserved1, b: true);
		targetThrottle = 0f;
		brakes = 1f;
	}

	private void SetTravelling()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)preventBuildingInstance != (Object)null && preventBuildingInstance.parentEntity.uid != net.ID)
		{
			preventBuildingInstance.SetParent(this);
			((Component)preventBuildingInstance).transform.localPosition = Vector3.zero;
		}
		((Behaviour)forcer).enabled = true;
		((Behaviour)pusher).enabled = true;
		if (TimeSince.op_Implicit(timeSinceBackfire) > 30f && Random.value < 0.6f)
		{
			timeSinceBackfire = TimeSince.op_Implicit(0f);
			((FacepunchBehaviour)this).Invoke((Action)StartBackfire, Random.Range(1f, 4f));
		}
		if (HasFlag(Flags.Reserved6))
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)TurnOffIndicators))
		{
			((FacepunchBehaviour)this).Invoke((Action)TurnOffIndicators, 3f, 0f);
		}
		SetFlag(Flags.Reserved1, b: false);
		internalState = TravellingVendorState.Travelling;
		brakes = 0f;
	}

	private void AdvancePath()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (currentPath != null)
		{
			if (PathComplete())
			{
				currentPathIndex = 0;
				flag = true;
			}
			else if (AtDestination())
			{
				currentPathIndex = GetPathIndexAhead(2);
				flag = true;
			}
			if (flag)
			{
				SetDestination(currentPath[currentPathIndex]);
			}
		}
	}

	private int GetPathIndexAhead(int ahead)
	{
		if (currentPath == null)
		{
			return 0;
		}
		return (currentPathIndex + ahead) % currentPath.Count;
	}

	private void ResetPullover()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		pullingOver = false;
		pullOverTimer = 0f;
		pulloverPosition = Vector3.zero;
		pulloverTangent = Vector3.zero;
	}

	private float GetWaitAccumulator()
	{
		float result = waitTimeAccumulator;
		waitTimeAccumulator = 0f;
		return result;
	}

	public void ScaleSidewaysFriction(float scale)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		float stiffness = 0.75f + 0.75f * scale;
		WheelFrictionCurve sidewaysFriction = wheelFL.wheelCollider.sidewaysFriction;
		((WheelFrictionCurve)(ref sidewaysFriction)).stiffness = stiffness;
		wheelFL.wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelFR.wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelRL.wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelRR.wheelCollider.sidewaysFriction = sidewaysFriction;
	}

	private void ApplyDownforce()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		myRigidbody.AddForce(-((Component)this).transform.up * downforceCoefficient);
	}

	private void UpdateWheelFlags()
	{
		if (wheelFL.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.FrontLeft;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.FrontLeft;
		}
		if (wheelFR.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.FrontRight;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.FrontRight;
		}
		if (wheelRL.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.RearLeft;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.RearLeft;
		}
		if (wheelRR.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.RearRight;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.RearRight;
		}
	}

	private void BuildingCheck()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(WorldSpaceBounds(), list, 1075937536, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!(item is Barricade barricade))
			{
				if (!(item is LootContainer lootContainer))
				{
					if (!(item is ConstructableEntity constructableEntity))
					{
						if (!(item is TreeEntity treeEntity))
						{
							if (!(item is DecayEntity decayEntity))
							{
								if (item is TrainCar { isServer: not false } trainCar && trainCar.IsAlive())
								{
									trainCar.Kill(DestroyMode.Gib);
								}
							}
							else if (should_destroy_buildings && (Object)(object)decayEntity.parentEntity.Get(serverside: true) != (Object)(object)this && decayEntity.isServer && decayEntity.IsAlive())
							{
								decayEntity.Kill(DestroyMode.Gib);
							}
						}
						else if (treeEntity.isServer)
						{
							treeEntity.Kill();
						}
					}
					else if (constructableEntity.isServer && constructableEntity.IsAlive())
					{
						constructableEntity.Kill(DestroyMode.Gib);
					}
				}
				else if (lootContainer.isServer && lootContainer.IsAlive())
				{
					lootContainer.Kill(DestroyMode.Gib);
				}
			}
			else if (barricade.isServer && barricade.IsAlive())
			{
				barricade.Kill(DestroyMode.Gib);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private bool CheckForObstacle()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		if (obstacleHits == null)
		{
			return false;
		}
		if (obstacleHits.Count <= 0)
		{
			return false;
		}
		foreach (RaycastHit obstacleHit in obstacleHits)
		{
			RaycastHit current = obstacleHit;
			if ((Object)(object)((RaycastHit)(ref current)).collider == (Object)null)
			{
				continue;
			}
			if (((RaycastHit)(ref current)).collider.ToBaseEntity() is BradleyAPC)
			{
				obstacleHits.Clear();
				return true;
			}
			if (!(((RaycastHit)(ref current)).collider.ToBaseEntity() is BasePlayer basePlayer) || IsPlayerIgnored(basePlayer) || basePlayer.IsFlying || IsInvalidPlayer(basePlayer))
			{
				continue;
			}
			if (TimeSince.op_Implicit(timeSincePlayerDetected) > 10f)
			{
				((FacepunchBehaviour)this).Invoke((Action)StartHorn, (float)Random.Range(1, 4));
				timeSincePlayerDetected = TimeSince.op_Implicit(0f);
			}
			if (playerRecords.ContainsKey(basePlayer))
			{
				VendorTargetInfo vendorTargetInfo = playerRecords[basePlayer];
				if (vendorTargetInfo.lastBlockingTime > Time.time + 60f)
				{
					vendorTargetInfo.blockingAccumulator = 0f;
					vendorTargetInfo.lastBlockingTime = Time.time;
					playerRecords[basePlayer] = vendorTargetInfo;
					continue;
				}
				vendorTargetInfo.lastBlockingTime = Time.time;
				vendorTargetInfo.blockingAccumulator += Time.deltaTime;
				if (vendorTargetInfo.blockingAccumulator > allowedVendorBlockTime)
				{
					IgnorePlayer(basePlayer);
				}
				else
				{
					playerRecords[basePlayer] = vendorTargetInfo;
				}
			}
			else
			{
				playerRecords.Add(basePlayer, new VendorTargetInfo
				{
					blockingAccumulator = Time.deltaTime,
					ignoredUntil = 0f,
					lastBlockingTime = Time.time,
					lastSeenTime = Time.time
				});
			}
			obstacleHits.Clear();
			return true;
		}
		return false;
	}

	private void UpdateObstacles()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		UpdateObstacleList(obstacleHits, ((Component)this).transform.forward);
	}

	private void UpdateObstacleList(List<RaycastHit> hits, Vector3 forward, float checkRadius = 2.5f)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		hits.Clear();
		GamePhysics.TraceAll(new Ray(((Component)this).transform.position + ((Component)this).transform.forward * (((Bounds)(ref bounds)).extents.z / 0.6f - 1f), forward), checkRadius, hits, 15f, obstacleMask | 1 | 0x8000, (QueryTriggerInteraction)1, this);
	}

	private void DoSteering()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 velocity = myRigidbody.velocity;
		float magnitude = ((Vector3)(ref velocity)).magnitude;
		velocity = myRigidbody.velocity;
		float num = Mathf.InverseLerp(5f, 1.5f, magnitude * Mathf.Abs(Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward)));
		ScaleSidewaysFriction(1f - num);
		if (!overrideSteering)
		{
			Vector3 val = ((Component)this).transform.InverseTransformPoint(destination);
			steeringAngle = Mathf.Atan2(val.x, val.z);
			steeringAngle *= 57.29578f;
			float num2 = steeringSmoothing * Time.deltaTime;
			smoothedSteering = Mathf.Lerp(smoothedSteering, steeringAngle, num2);
			wheelFL.wheelCollider.steerAngle = smoothedSteering;
			wheelFR.wheelCollider.steerAngle = smoothedSteering;
		}
	}

	private void ApplyForceAtWheels()
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (handbrake)
		{
			wheelFL.wheelCollider.brakeTorque = 1000f;
			wheelFR.wheelCollider.brakeTorque = 1000f;
			wheelRL.wheelCollider.brakeTorque = 1000f;
			wheelRR.wheelCollider.brakeTorque = 1000f;
			return;
		}
		throttle = Mathf.MoveTowards(throttle, targetThrottle, acceleration * Time.deltaTime);
		float num = throttle * motorForceConstant * 5f;
		Vector3 velocity = myRigidbody.velocity;
		bool flag = ((Vector3)(ref velocity)).magnitude >= max_speed;
		wheelFL.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		wheelFR.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		wheelRL.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		wheelRR.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		if (wheelFL.wheelCollider.isGrounded)
		{
			wheelFL.wheelCollider.motorTorque = num / 4f;
		}
		if (wheelFR.wheelCollider.isGrounded)
		{
			wheelFR.wheelCollider.motorTorque = num / 4f;
		}
		if (wheelRL.wheelCollider.isGrounded)
		{
			wheelRL.wheelCollider.motorTorque = num / 4f;
		}
		if (wheelRR.wheelCollider.isGrounded)
		{
			wheelRR.wheelCollider.motorTorque = num / 4f;
		}
	}

	private void ApplyBrakesAtWheels()
	{
		brakes = Mathf.Clamp(brakes, 0f, 1f);
		wheelFL.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelFR.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelRL.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelRR.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelFR.wheelCollider.motorTorque = 0f;
		wheelFL.wheelCollider.motorTorque = 0f;
		wheelRL.wheelCollider.motorTorque = 0f;
		wheelRR.wheelCollider.motorTorque = 0f;
	}

	private float CalculateSteeringAngle(float radius)
	{
		return Mathf.Atan(wheelbase / radius);
	}

	private void HandleSplineMovement()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		splineTranslator.SetOffset(splineOffset);
		splineTranslator.Update(Time.deltaTime);
		splineTranslator.GetCurrentPositionAndTangent(out var position, out var tangent);
		((Component)this).transform.position = Vector3.Lerp(((Component)this).transform.position, position, Time.deltaTime * splineMovementSpeed * 10f);
		Vector3 val = splineTranslator.PeekNextPositionFollowingDirection();
		tangent = val - position;
		Vector3 normalized = ((Vector3)(ref tangent)).normalized;
		((Component)this).transform.forward = normalized;
		Vector3 val2 = ((Component)this).transform.InverseTransformPoint(val);
		steeringAngle = Mathf.Atan2(val2.x, val2.z);
		steeringAngle *= 57.29578f;
		wheelFL.wheelCollider.steerAngle = steeringAngle;
		wheelFR.wheelCollider.steerAngle = steeringAngle;
	}

	private void TravelOnSpline()
	{
		splineTranslator.SetSpeed(splineMovementSpeed);
		slowdownStartSpeed = splineMovementSpeed;
		HandleSplineMovement();
	}

	private void SlowOnSpline()
	{
		splineTranslator.SetSpeed(slowdownStartSpeed);
		HandleSplineMovement();
		slowdownStartSpeed = Mathf.MoveTowards(slowdownStartSpeed, 0f, Time.deltaTime * 2f);
	}

	private void StopSplineMovement()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		overrideSteering = false;
		myRigidbody.isKinematic = false;
		int num = FindClosestNode() + 2 % currentPath.Count;
		currentPathIndex = num;
		SetDestination(currentPath[currentPathIndex]);
	}

	public void OnSplinePathTrigger(int pathId, WorldSpline spline, int direction)
	{
		if (splineId == -1 && (Object)(object)this.spline != (Object)(object)spline)
		{
			if (splineTranslator == null)
			{
				splineTranslator = new SimpleSplineTranslator();
			}
			myRigidbody.isKinematic = true;
			splineTranslator.SetSpline(spline).SetSpeed(splineMovementSpeed).SetDirection(direction)
				.CalculateStartingDistance();
			splineId = pathId;
			this.spline = spline;
			if (!((FacepunchBehaviour)this).IsInvoking((Action)CheckForSplineStart))
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)CheckForSplineStart, 0f, 1f);
			}
		}
		else if (splineId != pathId)
		{
			StopSplineMovement();
			splineId = -1;
			followingSpine = false;
		}
	}

	public void OnBasePathTrigger(int pathId, BasePath path)
	{
	}

	private void CheckForSplineStart()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float start = splineTranslator.GetStart();
		Vector3 positionAtDistance = splineTranslator.GetPositionAtDistance(start, out var _);
		positionAtDistance += splineOffset;
		Vector3 val = ((Component)spline).transform.TransformPoint(positionAtDistance);
		if (Vector3Ex.Distance2D(((Component)this).transform.position, val) < 1.5f)
		{
			overrideSteering = true;
			followingSpine = true;
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckForSplineStart);
		}
	}

	public void InstallPath(RuntimePath path, int initialDestination)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (currentPath == null)
		{
			currentPath = Pool.Get<List<Vector3>>();
		}
		currentPath.Clear();
		IAIPathNode[] nodes = path.Nodes;
		foreach (IAIPathNode iAIPathNode in nodes)
		{
			currentPath.Add(iAIPathNode.Position);
		}
		currentPathIndex = initialDestination;
		SetDestination(currentPath[currentPathIndex]);
	}

	private bool HasPath()
	{
		if (currentPath != null)
		{
			return currentPath.Count > 0;
		}
		return false;
	}

	private bool IsFollowingSpline()
	{
		return followingSpine;
	}

	private void ClearPath()
	{
		currentPath.Clear();
		currentPathIndex = -1;
	}

	private bool IndexValid(int index)
	{
		if (!HasPath())
		{
			return false;
		}
		if (index >= 0)
		{
			return index < currentPath.Count;
		}
		return false;
	}

	private Vector3 GetCurrentPathDestination()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return ((Component)this).transform.position;
		}
		return currentPath[currentPathIndex];
	}

	private bool PathComplete()
	{
		if (HasPath())
		{
			if (currentPathIndex == currentPath.Count - 1)
			{
				return AtDestination();
			}
			return false;
		}
		return true;
	}

	public void SetDestination(Vector3 dest, float destinationDistance = 8f)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		atDestinationDistance = destinationDistance;
		destination = dest;
	}

	public bool AtDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(((Component)this).transform.position, destination) <= atDestinationDistance;
	}

	private int FindClosestNode()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		int result = 0;
		for (int i = 0; i < currentPath.Count; i++)
		{
			Vector3 val = currentPath[i];
			float num2 = Vector3Ex.Distance2D(((Component)this).transform.position, val);
			if (num2 < num)
			{
				num = num2;
				result = i;
			}
		}
		return result;
	}

	private void FetchTargets()
	{
		if (playerRecords == null)
		{
			playerRecords = new ListDictionary<BasePlayer, VendorTargetInfo>();
		}
		if (localPlayers == null)
		{
			localPlayers = Pool.Get<List<BasePlayer>>();
		}
		List<BaseEntity> foundEntities = Pool.Get<List<BaseEntity>>();
		FetchCycle(foundEntities);
		Pool.FreeUnmanaged<BaseEntity>(ref foundEntities);
	}

	private void FetchCycle(List<BaseEntity> foundEntities)
	{
		TimeWarning val = TimeWarning.New("NetGroup", 0);
		try
		{
			if (net == null || net.group == null || net.group.subscribers == null)
			{
				return;
			}
			foreach (Connection subscriber in net.group.subscribers)
			{
				if (subscriber != null)
				{
					MonoBehaviour player = subscriber.player;
					if (!((Object)(object)player == (Object)null) && player is BasePlayer basePlayer && basePlayer.Distance((BaseEntity)this) <= (float)searchRange)
					{
						foundEntities.Add(basePlayer);
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		localPlayers.Clear();
		foreach (BaseEntity foundEntity in foundEntities)
		{
			if (!(foundEntity is BasePlayer basePlayer2) || basePlayer2 is HumanNPC || basePlayer2 is NPCPlayer || IsInvalidPlayer(basePlayer2))
			{
				continue;
			}
			if (playerRecords.ContainsKey(basePlayer2))
			{
				VendorTargetInfo vendorTargetInfo = playerRecords[basePlayer2];
				vendorTargetInfo.lastSeenTime = Time.time;
				playerRecords[basePlayer2] = vendorTargetInfo;
				if (!IsPlayerIgnored(basePlayer2))
				{
					localPlayers.Add(basePlayer2);
				}
			}
			else
			{
				playerRecords.Add(basePlayer2, new VendorTargetInfo
				{
					blockingAccumulator = 0f,
					ignoredUntil = 0f,
					lastBlockingTime = 0f,
					lastSeenTime = Time.time
				});
				localPlayers.Add(basePlayer2);
			}
		}
	}

	private bool IsInvalidPlayer(BasePlayer player)
	{
		int result = (int)(0u | (player.IsDead() ? 1u : 0u) | (player.IsSleeping() ? 1u : 0u) | (player.IsHostile() ? 1u : 0u)) | (player.isClient ? 1 : 0);
		if (player.IsHostile())
		{
			IgnorePlayer(player);
		}
		return (byte)result != 0;
	}

	private void IgnorePlayer(BasePlayer player)
	{
		if (localPlayers.Contains(player))
		{
			localPlayers.Remove(player);
		}
		float num = 90f;
		if (playerRecords.ContainsKey(player))
		{
			VendorTargetInfo vendorTargetInfo = playerRecords[player];
			vendorTargetInfo.ignoredUntil = Time.time + num;
			playerRecords[player] = vendorTargetInfo;
		}
		else
		{
			playerRecords.Add(player, new VendorTargetInfo
			{
				blockingAccumulator = 0f,
				ignoredUntil = num,
				lastBlockingTime = 0f,
				lastSeenTime = Time.time
			});
		}
	}

	private bool IsValidPatrons()
	{
		List<BasePlayer> list = localPlayers;
		if ((list != null && list.Count == 0) || localPlayers == null)
		{
			return false;
		}
		return localPlayers.Count > 0;
	}

	private bool IsPlayerIgnored(BasePlayer player)
	{
		if (playerRecords.ContainsKey(player))
		{
			return playerRecords[player].IsIgnored;
		}
		return false;
	}
}


private enum TravellingVendorState
{
	Stopped,
	Travelling,
	Waiting,
	Aligning
}


public static class TravellingVendorFlags
{
	public const Flags Braking = Flags.Reserved1;

	public const Flags IndicateLeft = Flags.Reserved2;

	public const Flags IndicateRight = Flags.Reserved4;

	public const Flags Lights = Flags.Reserved5;

	public const Flags Hazards = Flags.Reserved6;
}


using System;

[Flags]
private enum WheelIsGroundedFlags
{
	RearLeft = 1,
	RearRight = 2,
	FrontLeft = 4,
	FrontRight = 8
}


using System;
using UnityEngine;

[Serializable]
private struct VendorTargetInfo
{
	public float lastSeenTime;

	public float lastBlockingTime;

	public float blockingAccumulator;

	public float ignoredUntil;

	public bool IsIgnored => ignoredUntil > Time.time;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;

[ExecuteInEditMode]
public class TreeEntity : ResourceEntity, IPrefabPreProcess
{
	[Header("Falling")]
	public bool fallOnDied = true;

	public float fallDuration = 1.5f;

	public GameObjectRef fallStartSound;

	public GameObjectRef fallImpactSound;

	public GameObjectRef fallImpactParticles;

	public SoundDefinition fallLeavesLoopDef;

	[NonSerialized]
	public bool[] usedHeights = new bool[20];

	public bool impactSoundPlayed;

	private float treeDistanceUponFalling;

	public GameObjectRef prefab;

	public bool hasBonusGame = true;

	public GameObjectRef bonusHitEffect;

	public GameObjectRef bonusHitSound;

	public Collider serverCollider;

	public Collider clientCollider;

	public SoundDefinition smallCrackSoundDef;

	public SoundDefinition medCrackSoundDef;

	private float lastAttackDamage;

	[Header("Tree Addition Settings")]
	public bool spawnTreeAddition;

	public GameObjectRef treeAdditionPrefab;

	public float treeAdditionSpawnChance = 0.1f;

	public Vector3 treeAdditionSpawnPosition;

	public Vector3 treeAdditionSpawnRotation;

	private BaseEntity treeAdditionRef;

	[NonSerialized]
	public BaseEntity xMarker;

	private int currentBonusLevel;

	private float lastDirection = -1f;

	private float lastHitTime;

	private int lastHitMarkerIndex = -1;

	private float nextBirdTime;

	private uint birdCycleIndex;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TreeEntity.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
	}

	public override float AntiHackPadding()
	{
		return 1f;
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0336: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		bool canGather = info.CanGather;
		float num = Time.time - lastHitTime;
		lastHitTime = Time.time;
		DoBirds();
		if (!hasBonusGame || !canGather || (Object)(object)info.Initiator == (Object)null || (BonusActive() && !DidHitMarker(info)))
		{
			base.OnAttacked(info);
			return;
		}
		if ((Object)(object)xMarker != (Object)null && !info.DidGather && info.gatherScale > 0f)
		{
			xMarker.ClientRPC(null, "MarkerHit", currentBonusLevel);
			currentBonusLevel++;
			info.gatherScale = 1f + Mathf.Clamp((float)currentBonusLevel * 0.125f, 0f, 1f);
		}
		Vector3 val = (((Object)(object)xMarker != (Object)null) ? ((Component)xMarker).transform.position : info.HitPositionWorld);
		CleanupMarker();
		TreeMarkerData treeMarkerData = PrefabAttribute.server.Find<TreeMarkerData>(prefabID);
		if (treeMarkerData != null)
		{
			Vector3 nearbyPoint = treeMarkerData.GetNearbyPoint(((Component)this).transform.InverseTransformPoint(val), ref lastHitMarkerIndex, out var normal);
			nearbyPoint = ((Component)this).transform.TransformPoint(nearbyPoint);
			Quaternion rot = QuaternionEx.LookRotationNormal(((Component)this).transform.TransformDirection(normal));
			xMarker = GameManager.server.CreateEntity("assets/content/nature/treesprefabs/trees/effects/tree_marking_nospherecast.prefab", nearbyPoint, rot);
		}
		else
		{
			Vector3 val2 = Vector3Ex.Direction2D(((Component)this).transform.position, val);
			Vector3 val3 = Vector3.Cross(val2, Vector3.up);
			float num2 = lastDirection;
			float num3 = Random.Range(0.5f, 0.5f);
			Vector3 val4 = Vector3.Lerp(-val2, val3 * num2, num3);
			Vector3 val5 = ((Component)this).transform.InverseTransformDirection(((Vector3)(ref val4)).normalized) * 2.5f;
			val5 = ((Component)this).transform.InverseTransformPoint(serverCollider.ClosestPoint(((Component)this).transform.TransformPoint(val5)));
			Vector3 val6 = ((Component)this).transform.TransformPoint(val5);
			Vector3 val7 = ((Component)this).transform.InverseTransformPoint(info.HitPositionWorld);
			val5.y = val7.y;
			Vector3 val8 = ((Component)this).transform.InverseTransformPoint(info.Initiator.CenterPoint());
			float num4 = Mathf.Max(0.75f, val8.y);
			float num5 = val8.y + 0.5f;
			val5.y = Mathf.Clamp(val5.y + Random.Range(0.1f, 0.2f) * ((Random.Range(0, 2) == 0) ? (-1f) : 1f), num4, num5);
			Vector3 val9 = Vector3Ex.Direction2D(((Component)this).transform.position, val6);
			Vector3 val10 = val9;
			val9 = ((Component)this).transform.InverseTransformDirection(val9);
			Quaternion val11 = QuaternionEx.LookRotationNormal(-val9, Vector3.zero);
			val5 = ((Component)this).transform.TransformPoint(val5);
			val11 = QuaternionEx.LookRotationNormal(-val10, Vector3.zero);
			val5 = serverCollider.ClosestPoint(val5);
			Line val12 = default(Line);
			((Line)(ref val12))..ctor(((Component)serverCollider).transform.TransformPoint(new Vector3(0f, 10f, 0f)), ((Component)serverCollider).transform.TransformPoint(new Vector3(0f, -10f, 0f)));
			val11 = QuaternionEx.LookRotationNormal(-Vector3Ex.Direction(((Line)(ref val12)).ClosestPoint(val5), val5));
			xMarker = GameManager.server.CreateEntity("assets/content/nature/treesprefabs/trees/effects/tree_marking.prefab", val5, val11);
		}
		xMarker.Spawn();
		if (num > 5f)
		{
			StartBonusGame();
		}
		base.OnAttacked(info);
		if (health > 0f)
		{
			lastAttackDamage = info.damageTypes.Total();
			int num6 = Mathf.CeilToInt(health / lastAttackDamage);
			if (num6 < 2)
			{
				ClientRPC(null, "CrackSound", 1);
			}
			else if (num6 < 5)
			{
				ClientRPC(null, "CrackSound", 0);
			}
		}
	}

	public override void ServerInit()
	{
		if ((Object)(object)serverCollider == (Object)null)
		{
			serverCollider = clientCollider ?? ((Component)this).GetComponentInChildren<Collider>();
		}
		base.ServerInit();
		lastDirection = ((Random.Range(0, 2) != 0) ? 1 : (-1));
		TryAddTreeAddition();
	}

	public override void ServerInitPostNetworkGroupAssign()
	{
		base.ServerInitPostNetworkGroupAssign();
		TreeManager.OnTreeSpawned(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		CleanupMarker();
		TryKillTreeAddition();
		TreeManager.OnTreeDestroyed(this);
	}

	public bool DidHitMarker(HitInfo info)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)xMarker == (Object)null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnTreeMarkerHit", (object)this, (object)info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PrefabAttribute.server.Find<TreeMarkerData>(prefabID) != null)
		{
			Bounds val = default(Bounds);
			((Bounds)(ref val))..ctor(((Component)xMarker).transform.position, Vector3.one * 0.2f);
			if (((Bounds)(ref val)).Contains(info.HitPositionWorld))
			{
				return true;
			}
		}
		else
		{
			Vector3 val2 = Vector3Ex.Direction2D(((Component)this).transform.position, ((Component)xMarker).transform.position);
			Vector3 attackNormal = info.attackNormal;
			float num = Vector3.Dot(val2, attackNormal);
			float num2 = Vector3.Distance(((Component)xMarker).transform.position, info.HitPositionWorld);
			if (num >= 0.3f && num2 <= 0.2f)
			{
				return true;
			}
		}
		return false;
	}

	public float GetLastHitTime()
	{
		return lastHitTime;
	}

	public void StartBonusGame()
	{
		if (((FacepunchBehaviour)this).IsInvoking((Action)StopBonusGame))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)StopBonusGame);
		}
		((FacepunchBehaviour)this).Invoke((Action)StopBonusGame, 60f);
	}

	public void StopBonusGame()
	{
		CleanupMarker();
		lastHitTime = 0f;
		currentBonusLevel = 0;
	}

	public bool BonusActive()
	{
		return (Object)(object)xMarker != (Object)null;
	}

	private void DoBirds()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && !(Time.realtimeSinceStartup < nextBirdTime) && !(((Bounds)(ref bounds)).extents.y < 6f))
		{
			uint num = (uint)(int)net.ID.Value + birdCycleIndex;
			if (SeedRandom.Range(ref num, 0, 2) == 0)
			{
				Effect.server.Run("assets/prefabs/npc/birds/birdemission.prefab", ((Component)this).transform.position + Vector3.up * Random.Range(((Bounds)(ref bounds)).extents.y * 0.65f, ((Bounds)(ref bounds)).extents.y * 0.9f), Vector3.up);
			}
			birdCycleIndex++;
			nextBirdTime = Time.realtimeSinceStartup + 90f;
		}
	}

	public void CleanupMarker()
	{
		if (Object.op_Implicit((Object)(object)xMarker))
		{
			xMarker.Kill();
		}
		xMarker = null;
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		if (isKilled)
		{
			return;
		}
		isKilled = true;
		CleanupMarker();
		if (base.isServer)
		{
			StabilityEntity.UpdateSurroundingsQueue updateSurroundingsQueue = StabilityEntity.updateSurroundingsQueue;
			OBB val = WorldSpaceBounds();
			((ObjectWorkQueue<Bounds>)updateSurroundingsQueue).Add(((OBB)(ref val)).ToBounds());
			TryKillTreeAddition();
		}
		if (fallOnDied)
		{
			Collider val2 = serverCollider;
			if (Object.op_Implicit((Object)(object)val2))
			{
				val2.enabled = false;
			}
			Vector3 val3 = info.attackNormal;
			if (val3 == Vector3.zero)
			{
				val3 = Vector3Ex.Direction2D(((Component)this).transform.position, info.PointStart);
			}
			PooledList<TimedExplosive> val4 = Pool.Get<PooledList<TimedExplosive>>();
			try
			{
				foreach (BaseEntity child in children)
				{
					if (child is TimedExplosive item)
					{
						((List<TimedExplosive>)(object)val4).Add(item);
					}
				}
				foreach (TimedExplosive item2 in (List<TimedExplosive>)(object)val4)
				{
					item2.UnStick();
				}
				OnFallServer();
				ClientRPC(RpcTarget.NetworkGroup("TreeFall"), val3);
				((FacepunchBehaviour)this).Invoke((Action)DelayedKill, fallDuration + 1f);
				return;
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
		}
		DelayedKill();
	}

	protected virtual void OnFallServer()
	{
	}

	public void DelayedKill()
	{
		Kill();
	}

	private void TryAddTreeAddition()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		if (spawnTreeAddition && treeAdditionPrefab.isValid && Random.value <= treeAdditionSpawnChance && !((Object)(object)treeAdditionRef != (Object)null))
		{
			treeAdditionRef = GameManager.server.CreateEntity(treeAdditionPrefab.resourcePath, Vector3.zero, Quaternion.identity);
			((Component)treeAdditionRef).transform.position = ((Component)this).transform.TransformPoint(treeAdditionSpawnPosition);
			((Component)treeAdditionRef).transform.rotation = ((Component)this).transform.rotation * Quaternion.Euler(treeAdditionSpawnRotation);
			if ((Object)(object)((Component)treeAdditionRef).GetComponent<Poolable>() != (Object)null)
			{
				((Component)treeAdditionRef).gameObject.AwakeFromInstantiate();
			}
			treeAdditionRef.Spawn();
			treeAdditionRef.SendNetworkUpdate();
		}
	}

	private void TryKillTreeAddition()
	{
		if (spawnTreeAddition && (Object)(object)treeAdditionRef != (Object)null)
		{
			if (treeAdditionRef is BaseCombatEntity baseCombatEntity)
			{
				baseCombatEntity.Die();
			}
			else
			{
				treeAdditionRef.Kill(DestroyMode.Gib);
			}
			treeAdditionRef = null;
		}
	}

	public BaseEntity GetBonusGame()
	{
		return xMarker;
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (serverside)
		{
			globalBroadcast = Tree.global_broadcast;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;
using UnityEngine.Assertions;

public class TreeManager : BaseEntity
{
	private struct ToProcess
	{
		public struct Telemetry
		{
			public TimeSpan InitialTime;

			public TimeSpan IterativeTime;

			public int FramesToComplete;

			public void Report(BasePlayer player)
			{
				TimeSpan timeSpan = InitialTime + IterativeTime;
				TimeSpan timeSpan2 = new TimeSpan((long)(PlayerBudgetMS * 10000f * (float)FramesToComplete));
				TimeSpan timeSpan3 = timeSpan - timeSpan2;
				TimeSpan timeSpan4 = timeSpan / FramesToComplete;
				RustLog.Log(RustLog.EntryType.Network, 1, ((Component)player).gameObject, "TreeManager: Initial: {0}ms, Iterative: {1}ms, Total: {2}ms({3}ms/frame), Overspent: {4}ms", InitialTime.TotalMilliseconds, IterativeTime.TotalMilliseconds, timeSpan.TotalMilliseconds, timeSpan4.TotalMilliseconds, timeSpan3.TotalMilliseconds);
			}
		}

		public BasePlayer Player;

		public BitArray SentCells;

		public int Left;

		public int Range;

		public int OldCellIndex;

		public int LastProcessedIndex;

		public Telemetry Stats;
	}

	public struct TreeCell
	{
		public TreeList TreeList;

		public MemoryStream SerializedCell;

		public bool IsDirty;
	}

	public static ListHashSet<BaseEntity> entities = new ListHashSet<BaseEntity>();

	public static TreeManager server;

	[ServerVar]
	public static bool EnableTreeStreaming = true;

	[ServerVar]
	public static float PlayerBudgetMS = 0.01f;

	[ServerVar]
	public static float UpdateBudgetMS = 1f;

	private const string CellSizeHelp = "Define cell size(in m) of a grid for trees  - only has effect on world load and must be > 1. This affects how much data we send per tree cell(bigger the cell - more trees we have to send). The smaller the cell, the more cells we have to process and the more memory we need per player to track what's left to send(gridSize ^ 2 / 8 bytes). We readjust CellSize to ensure gridSize never exceeds 512.";

	[ServerVar(Help = "Define cell size(in m) of a grid for trees  - only has effect on world load and must be > 1. This affects how much data we send per tree cell(bigger the cell - more trees we have to send). The smaller the cell, the more cells we have to process and the more memory we need per player to track what's left to send(gridSize ^ 2 / 8 bytes). We readjust CellSize to ensure gridSize never exceeds 512.")]
	public static int CellSize = 100;

	private const string UseLazySerializationHelp = "Instead of reserializing grid cell on every tree add/removal(which can cost 0.25ms on 4.5k world), defer it to the streaming update. This reduces amount of times we need to serialize the tree list, but causes the player queue to take longer to process, as that's where evaluation happens.";

	[ServerVar(Help = "Instead of reserializing grid cell on every tree add/removal(which can cost 0.25ms on 4.5k world), defer it to the streaming update. This reduces amount of times we need to serialize the tree list, but causes the player queue to take longer to process, as that's where evaluation happens.")]
	public static bool UseLazySerialization = true;

	private List<ToProcess> playersToProcess = new List<ToProcess>(100);

	private int gridSize = 64;

	[NonSerialized]
	public List<TreeCell> treesGrid;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TreeManager.OnRpcMessage", 0);
		try
		{
			if (rpc == 1907121457 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestTrees "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestTrees", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1907121457u, "SERVER_RequestTrees", this, player, 0uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_RequestTrees(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_RequestTrees");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static Vector3 ProtoHalf3ToVec3(Half3 half3)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = default(Vector3);
		result.x = Mathf.HalfToFloat((ushort)half3.x);
		result.y = Mathf.HalfToFloat((ushort)half3.y);
		result.z = Mathf.HalfToFloat((ushort)half3.z);
		return result;
	}

	public static Half3 Vec3ToProtoHalf3(Vector3 vec3)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Half3 result = default(Half3);
		result.x = Mathf.FloatToHalf(vec3.x);
		result.y = Mathf.FloatToHalf(vec3.y);
		result.z = Mathf.FloatToHalf(vec3.z);
		return result;
	}

	public int GetTreeCount()
	{
		if ((Object)(object)server == (Object)(object)this)
		{
			return entities.Count;
		}
		return -1;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		server = this;
		InitTreeGrid();
	}

	private void InitTreeGrid()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Expected O, but got Unknown
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		if (CellSize <= 0)
		{
			CellSize = 100;
		}
		gridSize = (int)Mathf.Ceil((float)World.Size / (float)CellSize);
		gridSize = Math.Clamp(gridSize, 1, 512);
		if (gridSize == 512)
		{
			CellSize = (int)Mathf.Ceil((float)World.Size / (float)gridSize);
		}
		RustLog.Log(RustLog.EntryType.Network, 1, null, "TreeManager: using {0}x{0} grid with cell size {1}", gridSize, CellSize);
		treesGrid = new List<TreeCell>(gridSize * gridSize);
		for (int i = 0; i < gridSize * gridSize; i++)
		{
			TreeCell item = default(TreeCell);
			item.TreeList = new TreeList();
			item.TreeList.trees = new List<Tree>();
			item.SerializedCell = new MemoryStream();
			treesGrid.Add(item);
		}
		Enumerator<BaseEntity> enumerator = entities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseEntity current = enumerator.Current;
				Vector2i val = ToCellIndices(current.ServerWorldPosition);
				Tree val2 = Pool.Get<Tree>();
				ExtractTreeNetworkData(current, val2);
				treesGrid[val.y * gridSize + val.x].TreeList.trees.Add(val2);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (TreeCell item2 in treesGrid)
		{
			ProtoStreamExtensions.WriteToStream((IProto)(object)item2.TreeList, (Stream)item2.SerializedCell, false, 2097152);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		InitTreeGrid();
	}

	public void SendPendingTrees()
	{
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		playersToProcess.RemoveAll((ToProcess record) => (Object)(object)record.Player == (Object)null);
		if (playersToProcess.IsEmpty())
		{
			return;
		}
		playersToProcess.Sort((ToProcess left, ToProcess right) => right.Left - left.Left);
		Stopwatch stopwatch = Pool.Get<Stopwatch>();
		Stopwatch stopwatch2 = Pool.Get<Stopwatch>();
		stopwatch.Start();
		for (int i = 0; i < playersToProcess.Count; i++)
		{
			if (stopwatch.Elapsed.TotalMilliseconds > (double)UpdateBudgetMS)
			{
				break;
			}
			TimeWarning val = TimeWarning.New("Player", 0);
			try
			{
				stopwatch2.Restart();
				ToProcess record2 = playersToProcess[i];
				Vector2i val2 = ToCellIndices(record2.Player.ServerWorldPosition);
				if (record2.OldCellIndex != val2.y * gridSize + val2.x)
				{
					record2.LastProcessedIndex = -1;
					record2.Range = 1;
					record2.OldCellIndex = val2.y * gridSize + val2.x;
				}
				int num = record2.Range;
				while (stopwatch2.Elapsed.TotalMilliseconds < (double)PlayerBudgetMS && record2.Left > 0)
				{
					int num2 = Math.Max(val2.x - num / 2, 0);
					int num3 = Math.Max(val2.y - num / 2, 0);
					int num4 = Math.Min(num2 + num, gridSize - 1);
					int num5 = Math.Min(num3 + num, gridSize - 1);
					for (int j = num2; j <= num4; j++)
					{
						if (SendToPlayer(num3 * gridSize + j, ref record2) && stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
						{
							stopwatch2.Stop();
							break;
						}
					}
					if (stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
					{
						stopwatch2.Stop();
						break;
					}
					if (num5 - num3 > 1)
					{
						for (int k = num3 + 1; k <= num5 - 1; k++)
						{
							if (SendToPlayer(k * gridSize + num2, ref record2) && stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
							{
								stopwatch2.Stop();
								break;
							}
							if (num4 != num2 && SendToPlayer(k * gridSize + num4, ref record2) && stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
							{
								stopwatch2.Stop();
								break;
							}
						}
					}
					if (stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
					{
						stopwatch2.Stop();
						break;
					}
					if (num5 != num3)
					{
						for (int l = num2; l <= num4; l++)
						{
							if (SendToPlayer(num5 * gridSize + l, ref record2) && stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
							{
								stopwatch2.Stop();
								break;
							}
						}
					}
					if (stopwatch2.IsRunning)
					{
						num++;
						record2.LastProcessedIndex = -1;
					}
				}
				record2.Range = num;
				stopwatch2.Stop();
				ToProcess.Telemetry stats = record2.Stats;
				stats.IterativeTime += stopwatch2.Elapsed;
				stats.FramesToComplete++;
				record2.Stats = stats;
				playersToProcess[i] = record2;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		Pool.FreeUnmanaged(ref stopwatch2);
		Pool.FreeUnmanaged(ref stopwatch);
		playersToProcess.RemoveAll(delegate(ToProcess record)
		{
			if (record.Left == 0)
			{
				record.Stats.Report(record.Player);
				return true;
			}
			return false;
		});
		static bool SendToPlayer(int index, ref ToProcess record)
		{
			if (record.LastProcessedIndex >= index || record.SentCells[index])
			{
				return false;
			}
			record.LastProcessedIndex = index;
			record.SentCells[index] = true;
			record.Left--;
			Debug.Assert(record.Left >= 0);
			TreeCell value = server.treesGrid[index];
			if (value.TreeList.trees.IsEmpty())
			{
				return false;
			}
			if (UseLazySerialization && value.IsDirty)
			{
				TimeWarning val3 = TimeWarning.New("LazySerialize", 0);
				try
				{
					value.SerializedCell.SetLength(0L);
					ProtoStreamExtensions.WriteToStream((IProto)(object)value.TreeList, (Stream)value.SerializedCell, false, 2097152);
					value.IsDirty = false;
					server.treesGrid[index] = value;
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			TimeWarning val4 = TimeWarning.New("RPC", 0);
			try
			{
				server.ClientRPC(RpcTarget.Player("CLIENT_ReceiveTrees", record.Player), value.SerializedCell);
				return true;
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
		}
	}

	public static void StartTreesBatch(BasePlayer player)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		Stopwatch stopwatch = Stopwatch.StartNew();
		int num = server.gridSize * server.gridSize;
		BitArray bitArray = new BitArray(num);
		Vector2i val = ToCellIndices(player.ServerWorldPosition);
		int num2 = Math.Max(val.x - 1, 0);
		int num3 = Math.Max(val.y - 1, 0);
		int num4 = Math.Min(num2 + 3, server.gridSize - 1);
		int num5 = Math.Min(num3 + 3, server.gridSize - 1);
		for (int i = num3; i <= num5; i++)
		{
			for (int j = num2; j <= num4; j++)
			{
				int index = i * server.gridSize + j;
				TreeCell value = server.treesGrid[index];
				if (!value.TreeList.trees.IsEmpty())
				{
					if (UseLazySerialization && value.IsDirty)
					{
						TimeWarning val2 = TimeWarning.New("LazySerialize", 0);
						try
						{
							value.SerializedCell.SetLength(0L);
							ProtoStreamExtensions.WriteToStream((IProto)(object)value.TreeList, (Stream)value.SerializedCell, false, 2097152);
							value.IsDirty = false;
							server.treesGrid[index] = value;
						}
						finally
						{
							((IDisposable)val2)?.Dispose();
						}
					}
					server.ClientRPC(RpcTarget.Player("CLIENT_ReceiveTrees", player), value.SerializedCell);
				}
				bitArray[index] = true;
				num--;
			}
		}
		stopwatch.Stop();
		ToProcess toProcess = default(ToProcess);
		toProcess.Player = player;
		toProcess.SentCells = bitArray;
		toProcess.Left = num;
		toProcess.Range = 4;
		toProcess.OldCellIndex = val.y * server.gridSize + val.x;
		toProcess.LastProcessedIndex = -1;
		toProcess.Stats = new ToProcess.Telemetry
		{
			InitialTime = stopwatch.Elapsed,
			FramesToComplete = 1
		};
		ToProcess item = toProcess;
		server.playersToProcess.Add(item);
	}

	private static Vector2i ToCellIndices(Vector3 worldPos)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)World.Size / 2f;
		Vector2 val = Vector3Ex.XZ2D(worldPos) + new Vector2(num, num);
		val.x = Mathf.Clamp(val.x, 0f, (float)(World.Size - 1));
		val.y = Mathf.Clamp(val.y, 0f, (float)(World.Size - 1));
		return new Vector2i((int)(val.x / (float)CellSize), (int)(val.y / (float)CellSize));
	}

	public static void OnTreeDestroyed(BaseEntity billboardEntity)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		entities.Remove(billboardEntity);
		if (Application.isLoading || Application.isQuitting)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TreeManager.OnTreeDestroyed", 0);
		try
		{
			Vector2i val2 = ToCellIndices(billboardEntity.ServerWorldPosition);
			int index = val2.y * server.gridSize + val2.x;
			TreeCell value = server.treesGrid[index];
			List<Tree> trees = value.TreeList.trees;
			for (int i = 0; i < trees.Count; i++)
			{
				if (trees[i].netId == billboardEntity.net.ID)
				{
					Tree val3 = trees[i];
					Pool.Free<Tree>(ref val3);
					trees.RemoveAt(i);
					if (UseLazySerialization)
					{
						value.IsDirty = true;
						server.treesGrid[index] = value;
					}
					else
					{
						value.SerializedCell.SetLength(0L);
						ProtoStreamExtensions.WriteToStream((IProto)(object)value.TreeList, (Stream)value.SerializedCell, false, 2097152);
					}
					break;
				}
			}
			server.ClientRPC(RpcTarget.NetworkGroup("CLIENT_TreeDestroyed"), billboardEntity.net.ID);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void OnTreeSpawned(BaseEntity billboardEntity)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (billboardEntity.net.group != null && billboardEntity.net.group.restricted)
		{
			return;
		}
		entities.Add(billboardEntity);
		if (Application.isLoading || Application.isQuitting)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TreeManager.OnTreeSpawned", 0);
		try
		{
			Vector2i val2 = ToCellIndices(billboardEntity.ServerWorldPosition);
			int index = val2.y * server.gridSize + val2.x;
			Tree val3 = Pool.Get<Tree>();
			ExtractTreeNetworkData(billboardEntity, val3);
			TreeCell value = server.treesGrid[index];
			value.TreeList.trees.Add(val3);
			if (UseLazySerialization)
			{
				value.IsDirty = true;
				server.treesGrid[index] = value;
			}
			else
			{
				value.SerializedCell.SetLength(0L);
				ProtoStreamExtensions.WriteToStream((IProto)(object)value.TreeList, (Stream)value.SerializedCell, false, 2097152);
			}
			List<Connection> list = Pool.Get<List<Connection>>();
			foreach (Connection subscriber in server.net.group.subscribers)
			{
				bool flag = true;
				for (int i = 0; i < server.playersToProcess.Count; i++)
				{
					ToProcess toProcess = server.playersToProcess[i];
					if (toProcess.Player.Connection == subscriber && !toProcess.SentCells[index])
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					list.Add(subscriber);
				}
			}
			if (!list.IsEmpty())
			{
				Tree val4 = Pool.Get<Tree>();
				try
				{
					ExtractTreeNetworkData(billboardEntity, val4);
					server.ClientRPC(RpcTarget.Players("CLIENT_TreeSpawned", list), val4);
				}
				finally
				{
					((IDisposable)val4)?.Dispose();
				}
			}
			Pool.FreeUnmanaged<Connection>(ref list);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void ExtractTreeNetworkData(BaseEntity billboardEntity, Tree tree)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		tree.netId = billboardEntity.net.ID;
		tree.prefabId = billboardEntity.prefabID;
		tree.position = Vec3ToProtoHalf3(((Component)billboardEntity).transform.position);
		tree.scale = ((Component)billboardEntity).transform.lossyScale.y;
	}

	public static void SendSnapshot(BasePlayer player)
	{
		Stopwatch stopwatch = Stopwatch.StartNew();
		BufferList<BaseEntity> values = entities.Values;
		TreeList val = null;
		for (int i = 0; i < values.Count; i++)
		{
			BaseEntity billboardEntity = values[i];
			Tree val2 = Pool.Get<Tree>();
			ExtractTreeNetworkData(billboardEntity, val2);
			if (val == null)
			{
				val = Pool.Get<TreeList>();
				val.trees = Pool.Get<List<Tree>>();
			}
			val.trees.Add(val2);
			if (val.trees.Count >= ConVar.Server.maxpacketsize_globaltrees)
			{
				server.ClientRPC(RpcTarget.Player("CLIENT_ReceiveTrees", player), val);
				val.Dispose();
				val = null;
			}
		}
		if (val != null)
		{
			server.ClientRPC(RpcTarget.Player("CLIENT_ReceiveTrees", player), val);
			val.Dispose();
			val = null;
		}
		stopwatch.Stop();
		RustLog.Log(RustLog.EntryType.Network, 1, ((Component)player).gameObject, "Took {0}ms to send {1} global trees to {2}", stopwatch.Elapsed.TotalMilliseconds, values.Count, player);
	}

	[RPC_Server.CallsPerSecond(0uL)]
	[RPC_Server]
	private void SERVER_RequestTrees(RPCMessage msg)
	{
		if (EnableTreeStreaming)
		{
			StartTreesBatch(msg.player);
		}
		else
		{
			SendSnapshot(msg.player);
		}
	}
}


using System;
using System.Collections;
using UnityEngine;

private struct ToProcess
{
	public struct Telemetry
	{
		public TimeSpan InitialTime;

		public TimeSpan IterativeTime;

		public int FramesToComplete;

		public void Report(BasePlayer player)
		{
			TimeSpan timeSpan = InitialTime + IterativeTime;
			TimeSpan timeSpan2 = new TimeSpan((long)(PlayerBudgetMS * 10000f * (float)FramesToComplete));
			TimeSpan timeSpan3 = timeSpan - timeSpan2;
			TimeSpan timeSpan4 = timeSpan / FramesToComplete;
			RustLog.Log(RustLog.EntryType.Network, 1, ((Component)player).gameObject, "TreeManager: Initial: {0}ms, Iterative: {1}ms, Total: {2}ms({3}ms/frame), Overspent: {4}ms", InitialTime.TotalMilliseconds, IterativeTime.TotalMilliseconds, timeSpan.TotalMilliseconds, timeSpan4.TotalMilliseconds, timeSpan3.TotalMilliseconds);
		}
	}

	public BasePlayer Player;

	public BitArray SentCells;

	public int Left;

	public int Range;

	public int OldCellIndex;

	public int LastProcessedIndex;

	public Telemetry Stats;
}


using System;
using UnityEngine;

public struct Telemetry
{
	public TimeSpan InitialTime;

	public TimeSpan IterativeTime;

	public int FramesToComplete;

	public void Report(BasePlayer player)
	{
		TimeSpan timeSpan = InitialTime + IterativeTime;
		TimeSpan timeSpan2 = new TimeSpan((long)(PlayerBudgetMS * 10000f * (float)FramesToComplete));
		TimeSpan timeSpan3 = timeSpan - timeSpan2;
		TimeSpan timeSpan4 = timeSpan / FramesToComplete;
		RustLog.Log(RustLog.EntryType.Network, 1, ((Component)player).gameObject, "TreeManager: Initial: {0}ms, Iterative: {1}ms, Total: {2}ms({3}ms/frame), Overspent: {4}ms", InitialTime.TotalMilliseconds, IterativeTime.TotalMilliseconds, timeSpan.TotalMilliseconds, timeSpan4.TotalMilliseconds, timeSpan3.TotalMilliseconds);
	}
}


using System.IO;
using ProtoBuf;

public struct TreeCell
{
	public TreeList TreeList;

	public MemoryStream SerializedCell;

	public bool IsDirty;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using Rust.UI;
using Sonar;
using UnityEngine;

public class Tugboat : MotorRowboat, IPlannerReparentChildrenToMe, ILargeVehicleForProjectiles
{
	private const Flags Flag_Horn = Flags.Reserved18;

	[SerializeField]
	[Header("Tugboat")]
	private Canvas monitorCanvas;

	[SerializeField]
	private RustText fuelText;

	[SerializeField]
	private RustText speedText;

	[SerializeField]
	private ParticleSystemContainer exhaustEffect;

	[SerializeField]
	private SoundDefinition lightsToggleSound;

	[SerializeField]
	private Transform steeringWheelLeftHandTarget;

	[SerializeField]
	private Transform steeringWheelRightHandTarget;

	[SerializeField]
	private SonarSystem sonar;

	[SerializeField]
	private TugboatSounds tugboatSounds;

	[SerializeField]
	private CanvasGroup canvasGroup;

	[SerializeField]
	private EmissionToggle emissionToggle;

	[SerializeField]
	private AnimationCurve emissionCurve;

	[SerializeField]
	private ParticleSystemContainer fxLightDamage;

	[SerializeField]
	private ParticleSystemContainer fxMediumDamage;

	[SerializeField]
	private ParticleSystemContainer fxHeavyDamage;

	[SerializeField]
	private GameObject heavyDamageLights;

	[SerializeField]
	private TriggerParent parentTrigger;

	[Help("how long until boat corpses despawn (excluding tugboat)")]
	[ServerVar]
	public static float tugcorpseseconds = 7200f;

	[ServerVar(Help = "How long before a tugboat loses all its health while outside")]
	public static float tugdecayminutes = 2160f;

	[ServerVar(Help = "How long until decay begins after the tugboat was last used")]
	public static float tugdecaystartdelayminutes = 1440f;

	public bool LightsAreOn => HasFlag(Flags.Reserved5);

	protected override bool AllowKinematicDrift => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Tugboat.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	public override float AntiHackVelocity()
	{
		return 15f;
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("Tugboat.VehicleFixedUpdate", 0);
		try
		{
			int fuelAmount = fuelSystem.GetFuelAmount();
			base.VehicleFixedUpdate();
			int fuelAmount2 = fuelSystem.GetFuelAmount();
			if (fuelAmount2 != fuelAmount)
			{
				ClientRPC(RpcTarget.NetworkGroup("SetFuelAmount"), fuelAmount2);
			}
			if (LightsAreOn && !IsOn())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.simpleUint = Pool.Get<SimpleUInt>();
		info.msg.simpleUint.value = (uint)fuelSystem.GetFuelAmount();
	}

	public override void BoatDecay()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!base.IsDying)
		{
			BaseBoat.WaterVehicleDecay(this, 60f, TimeSince.op_Implicit(timeSinceLastUsedFuel), tugdecayminutes, tugdecayminutes, tugdecaystartdelayminutes, preventDecayIndoors);
		}
	}

	public override int StartingFuelUnits()
	{
		return 0;
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			if (!IsOn())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
			else
			{
				SetFlag(Flags.Reserved5, !LightsAreOn);
			}
		}
	}

	protected override void EnterCorpseState()
	{
		((FacepunchBehaviour)this).Invoke((Action)base.ActualDeath, tugcorpseseconds);
	}

	public override bool AnyPlayersOnBoat()
	{
		if (base.AnyPlayersOnBoat())
		{
			return true;
		}
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		GetPlayersOnBoat(list);
		bool num = list.Count > 0;
		Pool.FreeUnmanaged<BasePlayer>(ref list);
		if (!num)
		{
			return base.AnyPlayersOnBoat();
		}
		return true;
	}

	public override void GetPlayersOnBoat(List<BasePlayer> players)
	{
		if (players == null)
		{
			return;
		}
		players.Clear();
		base.GetPlayersOnBoat(players);
		if (!((Object)(object)parentTrigger != (Object)null) || !parentTrigger.HasAnyEntityContents)
		{
			return;
		}
		foreach (BaseEntity entityContent in parentTrigger.entityContents)
		{
			BasePlayer basePlayer = entityContent.ToPlayer();
			if ((Object)(object)basePlayer != (Object)null)
			{
				players.Add(basePlayer);
			}
		}
	}

	public override bool BuoyancySleep(bool inWater)
	{
		SetToKinematic();
		return true;
	}

	public override bool BuoyancyWake()
	{
		SetToNonKinematic();
		return true;
	}

	public override void DriverInput(InputState inputState, BasePlayer player)
	{
		base.DriverInput(inputState, player);
		bool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);
		if (flag != HasFlag(Flags.Reserved18))
		{
			SetFlag(Flags.Reserved18, flag);
		}
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool ForceDeployableSetParent()
	{
		return true;
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (IsOn())
		{
			return false;
		}
		if (!IsStationary() || (!(pusher.WaterFactor() <= 0.6f) && !IsFlipped()))
		{
			return false;
		}
		if (!IsFlipped() && pusher.IsStandingOnEntity(this, 1218652417))
		{
			return false;
		}
		if (pusher.IsBuildingBlockedByVehicle())
		{
			return false;
		}
		Vector3 val = ((Component)this).transform.TransformPoint(-Vector3.up);
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(val, waves: true, volumes: false, this);
		if (val.y - waterInfo.surfaceLevel > 2f)
		{
			return false;
		}
		if (base.IsDying)
		{
			return false;
		}
		if (!pusher.isMounted && pusher.IsOnGround())
		{
			return base.healthFraction > 0f;
		}
		return false;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Network.Visibility;
using ProtoBuf;
using UnityEngine;

public class TutorialIsland : BaseEntity, IEntityPingSource
{
	public struct IslandBounds
	{
		public OBB WorldBounds;

		public uint Id;

		public bool Contains(Vector3 pos)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return ((OBB)(ref WorldBounds)).Contains(pos);
		}
	}

	public EntityRef<BasePlayer> ForPlayer;

	public Transform InitialSpawnPoint;

	public Transform MidMissionSpawnPoint;

	public int SpawnLocationIndex;

	public TutorialNPC StartTutorialNPC;

	public TutorialContainer TutorialContainer;

	public MonumentNavMesh MonumentNavMesh;

	public MeshTerrainRoot MeshTerrain;

	public Transform KayakPoint;

	public BaseMission FinalMission;

	[Range(0f, 24f)]
	public float TimeOfDay = 18f;

	public ItemDefinition rockDefinition;

	public WeatherPreset Weather;

	[Header("Debugging")]
	public TutorialMission TestMission;

	private TutorialBuildTarget[] buildTargets;

	public static Phrase NoTutorialIslandsAvailablePhrase = new Phrase("no_tutorial_islands_available", "No Tutorial Islands are currently available, please try again later...");

	public static Phrase TutorialIslandStartCooldown = new Phrase("tutorial_island_start_cooldown", "Please wait {0} seconds before starting the tutorial again");

	public static ListHashSet<IslandBounds> BoundsListServer = new ListHashSet<IslandBounds>();

	public static float TutorialBoundsSize = 400f;

	[ServerVar(Saved = true)]
	public static bool SpawnTutorialIslandForNewPlayer = true;

	private static ListHashSet<TutorialIsland> ActiveIslandsServer = new ListHashSet<TutorialIsland>();

	[ServerVar(Saved = true)]
	public static bool EnforceTrespassChecks = true;

	[ServerVar(Help = "Will place the tutorial as close as possible to this pos, only for debugging")]
	public static Vector3 OverrideTutorialLocation = Vector3.zero;

	private const string TutorialIslandAssetPath = "assets/prefabs/missions/tutorialisland/tutorialisland.prefab";

	private static float _tutorialWorldStart = 0f;

	public static Bounds WorldBoundsMinusTutorialIslands;

	private static List<Vector3> islandSpawnLocations;

	private static List<int> freeIslandLocations;

	private float tutorialDuration;

	private float disconnectedDuration;

	private bool readyToStartConversation;

	private float tickRate = 1f;

	private Vector3 kayakAnchorPoint = Vector3.zero;

	private Kayak kayakToAnchor;

	private TimeSince rockCheck;

	public static float TutorialWorldStart
	{
		get
		{
			if (_tutorialWorldStart <= 0f)
			{
				_tutorialWorldStart = ValidBounds.GetMaximumPoint() - TutorialBoundsSize;
			}
			return _tutorialWorldStart;
		}
	}

	public static float TutorialWorldNetworkThreshold => TutorialWorldStart - TutorialBoundsSize;

	public static int MaxTutorialIslandCount => islandSpawnLocations?.Count ?? 0;

	public TimeSpan TutorialDuration => TimeSpan.FromSeconds(tutorialDuration);

	public float DisconnectTimeOutDuration
	{
		get
		{
			if (AvailableIslandCount() > 0)
			{
				return 900f;
			}
			return 300f;
		}
	}

	public static bool HasAvailableTutorialIsland
	{
		get
		{
			if (Server.tutorialEnabled)
			{
				return freeIslandLocations.Count > 0;
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TutorialIsland.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static ListHashSet<TutorialIsland> GetTutorialList(bool isServer)
	{
		if (isServer)
		{
			return ActiveIslandsServer;
		}
		return null;
	}

	public static uint GetTutorialGroupId(int index)
	{
		return (uint)(100 + index);
	}

	public static bool IsTutorialNetworkGroup(uint grp)
	{
		if (grp >= 100)
		{
			return grp < 1000;
		}
		return false;
	}

	public static void GenerateIslandSpawnPoints(bool loadingSave = false)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		if (islandSpawnLocations != null && islandSpawnLocations.Count > 0)
		{
			return;
		}
		Vector3 cellSize = default(Vector3);
		((Vector3)(ref cellSize))..ctor(400f, 0f, 400f);
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(0f - ValidBounds.GetMaximumPointTutorial(), 0f, 0f - ValidBounds.GetMaximumPointTutorial());
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(ValidBounds.GetMaximumPointTutorial(), 0f, ValidBounds.GetMaximumPointTutorial());
		islandSpawnLocations = new List<Vector3>();
		TutorialIslandSpawner.GetEdgeSpawnPoints(islandSpawnLocations, val, val2 - val, cellSize, 1, out WorldBoundsMinusTutorialIslands);
		for (int i = 0; i < islandSpawnLocations.Count; i++)
		{
			OBB val3 = new OBB(islandSpawnLocations[i], Quaternion.identity, new Bounds(new Vector3(0f, 25f, 0f), new Vector3(400f, 80f, 400f)));
			Bounds val4 = ((OBB)(ref val3)).ToBounds();
			if (DeepSeaManager.IsInsideDeepSea(val4))
			{
				islandSpawnLocations.RemoveAt(i);
				i--;
			}
			else if (IsOnDeepSeaPortalSide(val4))
			{
				islandSpawnLocations.RemoveAt(i);
				i--;
			}
			else
			{
				Group tutorialGroup = GetTutorialGroup(i);
				tutorialGroup.bounds = val4;
				tutorialGroup.restricted = true;
			}
		}
		freeIslandLocations = new List<int>();
		for (int j = 0; j < islandSpawnLocations.Count; j++)
		{
			freeIslandLocations.Add(j);
		}
	}

	public static bool IsOnDeepSeaPortalSide(Bounds bounds)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		return DeepSeaManager.GetEntrancePortalDirection() switch
		{
			CardinalDirection.None => false, 
			CardinalDirection.North => ((Bounds)(ref bounds)).center.z >= 0f, 
			CardinalDirection.South => ((Bounds)(ref bounds)).center.z <= 0f, 
			CardinalDirection.East => ((Bounds)(ref bounds)).center.x >= 0f, 
			CardinalDirection.West => ((Bounds)(ref bounds)).center.x <= 0f, 
			_ => false, 
		};
	}

	public static Group GetTutorialGroup(int index)
	{
		return Net.sv.visibility.Get((uint)(100 + index));
	}

	public static int AvailableIslandCount()
	{
		return freeIslandLocations.Count;
	}

	public static bool ShouldPlayerResumeTutorial(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		return player.IsInTutorial;
	}

	public static bool ShouldPlayerBeAskedToStartTutorial(BasePlayer player)
	{
		if (!Server.tutorialEnabled)
		{
			return false;
		}
		if (player.IsNpc || player.IsBot)
		{
			return false;
		}
		if (player.IsInTutorial)
		{
			return false;
		}
		if (!SpawnTutorialIslandForNewPlayer)
		{
			return false;
		}
		if (!HasAvailableTutorialIsland)
		{
			return false;
		}
		bool infoBool = player.GetInfoBool("client.hasdeclinedtutorial", defaultVal: false);
		if (!player.GetInfoBool("client.hascompletedtutorial", defaultVal: false))
		{
			return !infoBool;
		}
		return false;
	}

	public static TutorialIsland RestoreOrCreateIslandForPlayer(BasePlayer player, bool triggerAnalytics)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		if (player.IsNpc || player.IsBot)
		{
			return null;
		}
		bool flag = !player.HasPlayerFlag(BasePlayer.PlayerFlags.IsInTutorial);
		TutorialIsland tutorialIsland = (flag ? CreateIslandForPlayer(player) : player.GetCurrentTutorialIsland());
		if (!flag && (Object)(object)tutorialIsland != (Object)null)
		{
			SetupGroup(tutorialIsland.SpawnLocationIndex, ((Component)tutorialIsland).transform.position, ((Component)tutorialIsland).transform.rotation);
		}
		if ((Object)(object)tutorialIsland == (Object)null)
		{
			return null;
		}
		tutorialIsland.UpdateNetworkGroup();
		player.SetPlayerFlag(BasePlayer.PlayerFlags.IsInTutorial, b: true);
		if (flag)
		{
			player.net.SwitchGroup(tutorialIsland.net.group);
			player.Teleport(tutorialIsland.InitialSpawnPoint.position);
			((Component)player).transform.rotation = tutorialIsland.InitialSpawnPoint.rotation;
			player.OnStartedTutorial();
			player.inventory.GiveDefaultItems();
			if (triggerAnalytics)
			{
				Analytics.Azure.OnTutorialStarted(player);
			}
		}
		else
		{
			player.net.SwitchGroup(BaseNetworkable.LimboNetworkGroup);
			player.UpdateNetworkGroup();
			foreach (BaseEntity child in tutorialIsland.children)
			{
				if (child is TutorialContainer tutorialContainer)
				{
					tutorialIsland.TutorialContainer = tutorialContainer;
				}
			}
		}
		player.UpdateNetworkGroup();
		player.SendNetworkUpdateImmediate();
		player.ClientRPC(RpcTarget.Player("OnTutorialStarted", player), tutorialIsland.TimeOfDay, ((Object)tutorialIsland.Weather).name);
		tutorialIsland.TestMission = null;
		if (flag)
		{
			if (tutorialIsland.TestMission == null)
			{
				((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)tutorialIsland.StartInitialConversation, 1.5f);
			}
			else
			{
				Debug.LogWarning((object)"Starting test mission instead of initial conversation, clear TestMission field to test actual tutorial");
				BaseMission.AssignMission(player, tutorialIsland.StartTutorialNPC, tutorialIsland.TestMission);
			}
		}
		Debug.Log((object)(player.displayName + " is being placed on a tutorial island"));
		return tutorialIsland;
	}

	private static TutorialIsland CreateIslandForPlayer(BasePlayer player)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 worldPos;
		Quaternion worldRot;
		int unusedTutorialIslandLocationRotation = GetUnusedTutorialIslandLocationRotation(out worldPos, out worldRot);
		if (unusedTutorialIslandLocationRotation == -1)
		{
			return null;
		}
		Group val = SetupGroup(unusedTutorialIslandLocationRotation, worldPos, worldRot);
		TutorialIsland tutorialIsland = GameManager.server.CreateEntity("assets/prefabs/missions/tutorialisland/tutorialisland.prefab", worldPos, worldRot) as TutorialIsland;
		tutorialIsland.SpawnLocationIndex = unusedTutorialIslandLocationRotation;
		tutorialIsland.GenerateNavMesh();
		ActiveIslandsServer.Add(tutorialIsland);
		AddIslandBounds(tutorialIsland.WorldSpaceBounds(), val.ID, isServer: true);
		tutorialIsland.ForPlayer.Set(player);
		tutorialIsland.Spawn();
		return tutorialIsland;
	}

	private static Group SetupGroup(int spawnLocationIndex, Vector3 worldPos, Quaternion worldRot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Group tutorialGroup = GetTutorialGroup(spawnLocationIndex);
		OBB val = new OBB(worldPos, worldRot, new Bounds(new Vector3(0f, 25f, 0f), new Vector3(400f, 80f, 400f)));
		tutorialGroup.bounds = ((OBB)(ref val)).ToBounds();
		tutorialGroup.restricted = true;
		return tutorialGroup;
	}

	private static int GetUnusedTutorialIslandLocationRotation(out Vector3 worldPos, out Quaternion worldRot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		worldRot = Quaternion.identity;
		worldPos = Vector3.zero;
		if (AvailableIslandCount() == 0)
		{
			return -1;
		}
		if (OverrideTutorialLocation != Vector3.zero)
		{
			int num = -1;
			float num2 = float.MaxValue;
			for (int i = 0; i < freeIslandLocations.Count; i++)
			{
				float num3 = Vector3.Distance(OverrideTutorialLocation, islandSpawnLocations[freeIslandLocations[i]]);
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
			worldPos = islandSpawnLocations[num];
			freeIslandLocations.RemoveAt(num);
			return num;
		}
		int num4 = freeIslandLocations[0];
		worldPos = islandSpawnLocations[num4];
		freeIslandLocations.RemoveAt(0);
		float height = TerrainMeta.HeightMap.GetHeight(worldPos);
		if (worldPos.y < height)
		{
			worldPos.y = height;
		}
		return num4;
	}

	public static void AddIslandFromSave(TutorialIsland island)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)("Island being added! Location index: " + island.SpawnLocationIndex));
		if (ActiveIslandsServer.Contains(island))
		{
			Debug.Log((object)"Warning, attempting to add duplicate Island!");
			return;
		}
		ActiveIslandsServer.Add(island);
		AddIslandBounds(island.WorldSpaceBounds(), GetTutorialGroupId(island.SpawnLocationIndex), isServer: true);
		freeIslandLocations.Remove(island.SpawnLocationIndex);
		Debug.Log((object)("Free locations remaining: " + freeIslandLocations.Count + ". Next Index: " + freeIslandLocations[0]));
		island.GenerateNavMesh();
	}

	public void GenerateNavMesh()
	{
		if (!((Object)(object)MonumentNavMesh == (Object)null))
		{
			((MonoBehaviour)this).StartCoroutine(UpdateNavMesh());
		}
	}

	public IEnumerator UpdateNavMesh()
	{
		yield return ((MonoBehaviour)this).StartCoroutine(MonumentNavMesh.UpdateNavMeshAndWait());
	}

	private void StartInitialConversation()
	{
		BasePlayer basePlayer = ForPlayer.Get(base.isServer);
		if ((Object)(object)basePlayer != (Object)null && (basePlayer.IsSleeping() || basePlayer.IsDucked()))
		{
			((FacepunchBehaviour)this).Invoke((Action)StartInitialConversation, 0.1f);
		}
		else if (!readyToStartConversation)
		{
			readyToStartConversation = true;
			((FacepunchBehaviour)this).Invoke((Action)StartInitialConversation, 0.5f);
		}
		else
		{
			StartTutorialNPC.Server_BeginTalking(ForPlayer.Get(base.isServer));
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)InitSpawnGroups, 1f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)Tick, tickRate, tickRate, 0.1f);
	}

	private void InitSpawnGroups()
	{
		List<SpawnGroup> list = Pool.Get<List<SpawnGroup>>();
		((Component)this).gameObject.GetComponentsInChildren<SpawnGroup>(list);
		foreach (SpawnGroup item in list)
		{
			if ((Object)(object)item != (Object)null)
			{
				item.Spawn();
			}
		}
		Pool.FreeUnmanaged<SpawnGroup>(ref list);
	}

	public void OnPlayerBuiltConstruction(BasePlayer player)
	{
		ClientRPC(RpcTarget.Player("ClientOnPlayerBuiltConstruction", player));
	}

	public override void Save(SaveInfo info)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.tutorialIsland == null)
		{
			info.msg.tutorialIsland = Pool.Get<TutorialIsland>();
		}
		TutorialIsland tutorialIsland = info.msg.tutorialIsland;
		tutorialIsland.targetPlayer = ForPlayer.uid;
		tutorialIsland.disconnectDuration = disconnectedDuration;
		tutorialIsland.spawnLocationIndex = SpawnLocationIndex;
		if (info.forDisk)
		{
			tutorialIsland.tutorialDuration = tutorialDuration;
		}
	}

	public void GetBuildTargets(List<TutorialBuildTarget> targetList, uint targetPrefab)
	{
		TutorialBuildTarget[] array = buildTargets;
		foreach (TutorialBuildTarget tutorialBuildTarget in array)
		{
			if (tutorialBuildTarget.TargetPrefab.isValid && tutorialBuildTarget.TargetPrefab.Get().prefabID == targetPrefab)
			{
				targetList.Add(tutorialBuildTarget);
			}
		}
	}

	public Vector3 GetWorldPosOfBuildTarget(int index)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (buildTargets.Length != 0)
		{
			return ((Component)buildTargets[index]).transform.position;
		}
		return ((Component)this).transform.position;
	}

	public void StartEndingCinematic(BasePlayer player)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		BaseMountable mounted = player.GetMounted();
		Vector3 pos = Vector3Ex.WithY(((Component)player).transform.position, Env.oceanlevel);
		if ((Object)(object)mounted != (Object)null && (Object)(object)mounted.VehicleParent() != (Object)null)
		{
			kayakToAnchor = mounted.VehicleParent() as Kayak;
			if ((Object)(object)kayakToAnchor != (Object)null)
			{
				kayakToAnchor.PrepareForTutorialCinematic(KayakPoint.rotation);
				kayakAnchorPoint = pos;
				kayakToAnchor.rigidBody.isKinematic = true;
				kayakToAnchor.rigidBody.useGravity = false;
				((FacepunchBehaviour)this).InvokeRepeating((Action)AnchorKayak, 0f, 0f);
			}
		}
		CinematicScenePlaybackEntity obj = GameManager.server.CreateEntity("assets/prefabs/missions/tutorialisland/endtutorialcinematic.prefab", pos, KayakPoint.rotation) as CinematicScenePlaybackEntity;
		obj.AssignPlayer(player);
		obj.Spawn();
	}

	private void AnchorKayak()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)kayakToAnchor != (Object)null)
		{
			((Component)kayakToAnchor).transform.position = kayakAnchorPoint;
		}
	}

	public void OnPlayerCompletedTutorial(BasePlayer player, bool isQuit, bool triggerAnalytics)
	{
		if ((Object)(object)ForPlayer.Get(serverside: true) != (Object)(object)player)
		{
			Debug.LogWarning((object)$"Attempting to complete tutorial for non-matching player {ForPlayer.Get(serverside: true)} != {player}");
			return;
		}
		_ = player.IsInTutorial;
		if (triggerAnalytics)
		{
			if (isQuit)
			{
				BaseMission.MissionInstance activeMissionInstance = player.GetActiveMissionInstance();
				Analytics.Azure.OnTutorialQuit(player, (activeMissionInstance != null && activeMissionInstance.GetMission() != null) ? activeMissionInstance.GetMission().shortname : "NULL");
			}
			else
			{
				Analytics.Azure.OnTutorialCompleted(player, tutorialDuration);
				player.GiveAchievement("COMPLETE_TUTORIAL", allowTutorial: true);
			}
		}
		((FacepunchBehaviour)this).Invoke((Action)KillPlayerAtEndOfTutorial, 0.1f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)DelayedCompleteTutorial, 0.5f, 0.5f);
	}

	private void KillPlayerAtEndOfTutorial()
	{
		Debug.Log((object)"Kill player");
		BasePlayer basePlayer = ForPlayer.Get(serverside: true);
		basePlayer.ClientRPC(RpcTarget.Player("NotifyTutorialCompleted", basePlayer));
		basePlayer.ClearTutorial();
		ServerMgr.SendReplicatedVars(basePlayer.Connection);
		DeathInfo val = Pool.Get<DeathInfo>();
		val.attackerName = "scientistnpc_full_any";
		if (basePlayer.IsGod())
		{
			basePlayer.net.connection.info.Set("global.god", "0");
		}
		basePlayer.SetOverrideDeathBlow(val);
		basePlayer.Hurt(9999f);
		if (basePlayer.IsGod())
		{
			Debug.LogWarning((object)("Attempting to kill player " + basePlayer.displayName + " at end of tutorial but god mode is active!"));
		}
		basePlayer.ClearTutorial_PostDeath();
	}

	private void DelayedCompleteTutorial()
	{
		BasePlayer basePlayer = ForPlayer.Get(serverside: true);
		if (!((Object)(object)basePlayer != (Object)null) || !basePlayer.IsDead())
		{
			ForPlayer.Set(null);
			Return();
		}
	}

	public void Return()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(WorldSpaceBounds(), list, -1, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!(item is BasePlayer) && !(item is TutorialIsland) && !item.isClient && !item.IsDestroyed)
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		BasePlayer basePlayer = ForPlayer.Get(serverside: true);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.AbandonActiveMission();
		}
		ForPlayer.Set(null);
		ReturnIsland(this);
		disconnectedDuration = 0f;
	}

	private static void ReturnIsland(TutorialIsland island)
	{
		freeIslandLocations.Add(island.SpawnLocationIndex);
		island.Kill();
	}

	public void Tick()
	{
		TickPlayerConnectionStatus();
	}

	private void TickPlayerConnectionStatus()
	{
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = ForPlayer.Get(base.isServer);
		tutorialDuration += tickRate;
		if ((Object)(object)basePlayer == (Object)null || basePlayer.IsSleeping())
		{
			disconnectedDuration += tickRate;
			if (disconnectedDuration >= DisconnectTimeOutDuration)
			{
				if ((Object)(object)basePlayer != (Object)null)
				{
					basePlayer.ClearTutorial();
					basePlayer.Hurt(99999f);
					basePlayer.ClearTutorial_PostDeath();
					basePlayer.ClientRPCPlayer(null, basePlayer, "NotifyTutorialCompleted");
				}
				Return();
			}
			return;
		}
		disconnectedDuration = 0f;
		if (!((Object)(object)basePlayer != (Object)null) || !((Object)(object)rockDefinition != (Object)null) || !(TimeSince.op_Implicit(rockCheck) > 10f))
		{
			return;
		}
		rockCheck = TimeSince.op_Implicit(0f);
		if (!SearchPlayerForItem(rockDefinition, basePlayer) && basePlayer.inventory.HasEmptySlotInBeltOrMain())
		{
			Item item = ItemManager.Create(rockDefinition, 1, 0uL);
			if (!basePlayer.inventory.GiveItem(item))
			{
				item.Remove();
			}
		}
	}

	private bool SearchPlayerForItem(ItemDefinition targetItem, BasePlayer player)
	{
		foreach (Item item in player.inventory.containerBelt.itemList)
		{
			if ((Object)(object)item.info == (Object)(object)targetItem || (Object)(object)item.info.isRedirectOf == (Object)(object)targetItem)
			{
				return true;
			}
		}
		foreach (Item item2 in player.inventory.containerMain.itemList)
		{
			if ((Object)(object)item2.info == (Object)(object)targetItem || (Object)(object)item2.info.isRedirectOf == (Object)(object)targetItem)
			{
				return true;
			}
		}
		foreach (Item item3 in player.inventory.containerWear.itemList)
		{
			if ((Object)(object)item3.info == (Object)(object)targetItem || (Object)(object)item3.info.isRedirectOf == (Object)(object)targetItem)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsPingValid(MapNote note)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		TutorialBuildTarget[] array = buildTargets;
		foreach (TutorialBuildTarget tutorialBuildTarget in array)
		{
			if (((Component)tutorialBuildTarget).gameObject.activeSelf && Vector3.Distance(((Component)tutorialBuildTarget).transform.position, note.worldPosition) < 0.1f)
			{
				return true;
			}
		}
		Vector3 val = note.worldPosition - KayakPoint.position;
		if (((Vector3)(ref val)).sqrMagnitude < 10f)
		{
			return true;
		}
		return false;
	}

	public static TutorialIsland GetClosestTutorialIsland(Vector3 position, float maxRange)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		float num2 = float.MaxValue;
		for (int i = 0; i < ActiveIslandsServer.Count; i++)
		{
			TutorialIsland tutorialIsland = ActiveIslandsServer[i];
			if ((Object)(object)tutorialIsland != (Object)null)
			{
				float num3 = tutorialIsland.Distance2D(position);
				if (num3 < maxRange && num3 < num2)
				{
					num2 = num3;
					num = i;
				}
			}
		}
		if (num < 0)
		{
			return null;
		}
		return ActiveIslandsServer[num];
	}

	[ServerVar]
	public static void debugIslandPositions(Arg arg)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		if (islandSpawnLocations == null)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		OBB val = default(OBB);
		foreach (Vector3 islandSpawnLocation in islandSpawnLocations)
		{
			UnityEngine.DDraw.Sphere(basePlayer, islandSpawnLocation, 5f, Color.yellow, 60f);
			((OBB)(ref val))..ctor(islandSpawnLocation, Quaternion.identity, new Bounds(new Vector3(0f, 25f, 0f), new Vector3(400f, 80f, 400f)));
			UnityEngine.DDraw.Bounds(basePlayer, ((OBB)(ref val)).ToBounds(), Color.yellow, 60f);
		}
	}

	public void OnPlayerStartedMission(BasePlayer player)
	{
		TutorialBuildTarget[] array = buildTargets;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateActive(player);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.tutorialIsland != null)
		{
			TutorialIsland tutorialIsland = info.msg.tutorialIsland;
			ForPlayer.uid = tutorialIsland.targetPlayer;
			SpawnLocationIndex = tutorialIsland.spawnLocationIndex;
			disconnectedDuration = tutorialIsland.disconnectDuration;
			tutorialDuration = tutorialIsland.tutorialDuration;
			if (base.isServer && info.fromDisk)
			{
				AddIslandFromSave(this);
			}
		}
	}

	public bool CheckPlacement(Construction toConstruct, Construction.Target target, ref Construction.Placement placement)
	{
		TutorialBuildTarget[] array = buildTargets;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].IsValid(toConstruct, target, ref placement))
			{
				return true;
			}
		}
		return false;
	}

	public bool CheckPlacement(BasePlayer forPlayer, Deployable deployable, Vector3 worldPosition, Quaternion worldRotation)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		TutorialBuildTarget[] array = buildTargets;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].IsValid(forPlayer, deployable, worldPosition, worldRotation))
			{
				return true;
			}
		}
		return false;
	}

	public override void InitShared()
	{
		base.InitShared();
		buildTargets = ((Component)this).GetComponentsInChildren<TutorialBuildTarget>();
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer && ActiveIslandsServer.Contains(this))
		{
			RemoveIslandBounds(GetTutorialGroupId(SpawnLocationIndex), isServer: true);
			ActiveIslandsServer.Remove(this);
		}
	}

	private static void AddIslandBounds(OBB worldBounds, uint netId, bool isServer)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		IslandBounds islandBounds = default(IslandBounds);
		islandBounds.Id = netId;
		islandBounds.WorldBounds = worldBounds;
		IslandBounds islandBounds2 = islandBounds;
		if (isServer)
		{
			BoundsListServer.TryAdd(islandBounds2);
		}
	}

	private static void RemoveIslandBounds(uint netId, bool isServer)
	{
		if (!isServer)
		{
			return;
		}
		for (int i = 0; i < BoundsListServer.Count; i++)
		{
			if (BoundsListServer[i].Id == netId)
			{
				BoundsListServer.RemoveAt(i);
				break;
			}
		}
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool ForceDeployableSetParent()
	{
		return true;
	}
}


using UnityEngine;

public struct IslandBounds
{
	public OBB WorldBounds;

	public uint Id;

	public bool Contains(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref WorldBounds)).Contains(pos);
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using Rust.Modular;
using UnityEngine;
using UnityEngine.Assertions;

public class VehicleModuleCamper : VehicleModuleSeating
{
	public GameObjectRef SleepingBagEntity;

	public Transform[] SleepingBagPoints;

	public GameObjectRef LockerEntity;

	public Transform LockerPoint;

	public GameObjectRef BbqEntity;

	public Transform BbqPoint;

	public GameObjectRef StorageEntity;

	public Transform StoragePoint;

	public EntityRef<BaseOven> activeBbq;

	public EntityRef<Locker> activeLocker;

	public EntityRef<StorageContainer> activeStorage;

	private bool wasLoaded;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehicleModuleCamper.OnRpcMessage", 0);
		try
		{
			if (rpc == 2501069650u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLocker "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLocker", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2501069650u, "RPC_OpenLocker", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_OpenLocker(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenLocker");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4185921214u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenStorage "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenStorage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4185921214u, "RPC_OpenStorage", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_OpenStorage(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_OpenStorage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		activeBbq.Set(null);
		activeLocker.Set(null);
		activeStorage.Set(null);
		wasLoaded = false;
	}

	public override void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.ModuleAdded(vehicle, firstSocketIndex);
		if (!base.isServer)
		{
			return;
		}
		if (!Application.isLoadingSave && !wasLoaded)
		{
			for (int i = 0; i < SleepingBagPoints.Length; i++)
			{
				SleepingBagCamper sleepingBagCamper = base.gameManager.CreateEntity(SleepingBagEntity.resourcePath, SleepingBagPoints[i].localPosition, SleepingBagPoints[i].localRotation) as SleepingBagCamper;
				if ((Object)(object)sleepingBagCamper != (Object)null)
				{
					sleepingBagCamper.SetParent(this);
					sleepingBagCamper.SetSeat(GetSeatAtIndex(i));
					sleepingBagCamper.Spawn();
				}
			}
			PostConditionalRefresh();
			return;
		}
		int num = 0;
		foreach (BaseEntity child in children)
		{
			if (child is SleepingBagCamper sleepingBagCamper2)
			{
				sleepingBagCamper2.SetSeat(GetSeatAtIndex(num++), sendNetworkUpdate: true);
			}
			else if (child is IItemContainerEntity itemContainerEntity)
			{
				ItemContainer inventory = itemContainerEntity.inventory;
				inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			}
		}
	}

	protected override Vector3 ModifySeatPositionLocalSpace(int index, Vector3 desiredPos)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		CamperSeatConfig seatConfig = GetSeatConfig();
		if ((Object)(object)seatConfig != (Object)null && seatConfig.SeatPositions.Length > index)
		{
			return seatConfig.SeatPositions[index].localPosition;
		}
		return base.ModifySeatPositionLocalSpace(index, desiredPos);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		wasLoaded = true;
	}

	public override void Spawn()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			Locker locker = base.gameManager.CreateEntity(LockerEntity.resourcePath, LockerPoint.localPosition, LockerPoint.localRotation) as Locker;
			locker.SetParent(this);
			locker.Spawn();
			ItemContainer inventory = locker.inventory;
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			activeLocker.Set(locker);
			BaseOven baseOven = base.gameManager.CreateEntity(BbqEntity.resourcePath, BbqPoint.localPosition, BbqPoint.localRotation) as BaseOven;
			baseOven.SetParent(this);
			baseOven.Spawn();
			ItemContainer inventory2 = baseOven.inventory;
			inventory2.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory2.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			activeBbq.Set(baseOven);
			StorageContainer storageContainer = base.gameManager.CreateEntity(StorageEntity.resourcePath, StoragePoint.localPosition, StoragePoint.localRotation) as StorageContainer;
			storageContainer.SetParent(this);
			storageContainer.Spawn();
			ItemContainer inventory3 = storageContainer.inventory;
			inventory3.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory3.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			activeStorage.Set(storageContainer);
			PostConditionalRefresh();
		}
	}

	private void OnItemAddedRemoved(Item item, bool add)
	{
		AssociatedItemInstance?.LockUnlock(!CanBeMovedNowOnVehicle());
	}

	protected override bool CanBeMovedNowOnVehicle()
	{
		foreach (BaseEntity child in children)
		{
			if (child is IItemContainerEntity itemContainerEntity && !itemContainerEntity.IsUnityNull() && !itemContainerEntity.inventory.IsEmpty())
			{
				return false;
			}
		}
		return true;
	}

	public override Phrase CannotBeMovedNowReason()
	{
		return VehicleModuleStorage.StorageCantBeMovedError;
	}

	protected override void PostConditionalRefresh()
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		base.PostConditionalRefresh();
		if (base.isClient)
		{
			return;
		}
		CamperSeatConfig seatConfig = GetSeatConfig();
		if ((Object)(object)seatConfig != (Object)null && mountPoints != null)
		{
			for (int i = 0; i < mountPoints.Count; i++)
			{
				if ((Object)(object)mountPoints[i].mountable != (Object)null)
				{
					((Component)mountPoints[i].mountable).transform.position = seatConfig.SeatPositions[i].position;
					mountPoints[i].mountable.SendNetworkUpdate();
				}
			}
		}
		if (activeBbq.IsValid(base.isServer) && (Object)(object)seatConfig != (Object)null)
		{
			BaseOven baseOven = activeBbq.Get(serverside: true);
			((Component)baseOven).transform.position = seatConfig.StovePosition.position;
			((Component)baseOven).transform.rotation = seatConfig.StovePosition.rotation;
			baseOven.SendNetworkUpdate();
		}
		if (activeStorage.IsValid(base.isServer) && (Object)(object)seatConfig != (Object)null)
		{
			StorageContainer storageContainer = activeStorage.Get(base.isServer);
			((Component)storageContainer).transform.position = seatConfig.StoragePosition.position;
			((Component)storageContainer).transform.rotation = seatConfig.StoragePosition.rotation;
			storageContainer.SendNetworkUpdate();
		}
	}

	private CamperSeatConfig GetSeatConfig()
	{
		List<ConditionalObject> list = GetConditionals();
		CamperSeatConfig result = null;
		CamperSeatConfig camperSeatConfig = default(CamperSeatConfig);
		foreach (ConditionalObject item in list)
		{
			if (item.gameObject.activeSelf && item.gameObject.TryGetComponent<CamperSeatConfig>(ref camperSeatConfig))
			{
				result = camperSeatConfig;
			}
		}
		return result;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.camperModule == null)
		{
			info.msg.camperModule = Pool.Get<CamperModule>();
		}
		info.msg.camperModule.bbqId = activeBbq.uid;
		info.msg.camperModule.lockerId = activeLocker.uid;
		info.msg.camperModule.storageID = activeStorage.uid;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_OpenLocker(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			IItemContainerEntity itemContainerEntity = activeLocker.Get(base.isServer);
			if (!itemContainerEntity.IsUnityNull())
			{
				itemContainerEntity.PlayerOpenLoot(player);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_OpenStorage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			IItemContainerEntity itemContainerEntity = activeStorage.Get(base.isServer);
			if (!itemContainerEntity.IsUnityNull())
			{
				itemContainerEntity.PlayerOpenLoot(player);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			if (activeStorage.IsValid(base.isServer))
			{
				activeStorage.Get(base.isServer).DropItems();
			}
			if (activeBbq.IsValid(base.isServer))
			{
				activeBbq.Get(base.isServer).DropItems();
			}
			if (activeLocker.IsValid(base.isServer))
			{
				activeLocker.Get(base.isServer).DropItems();
			}
		}
		base.DoServerDestroy();
	}

	public IItemContainerEntity GetContainer()
	{
		Locker locker = activeLocker.Get(base.isServer);
		if ((Object)(object)locker != (Object)null && locker.IsValid() && !locker.inventory.IsEmpty())
		{
			return locker;
		}
		BaseOven baseOven = activeBbq.Get(base.isServer);
		if ((Object)(object)baseOven != (Object)null && baseOven.IsValid() && !baseOven.inventory.IsEmpty())
		{
			return baseOven;
		}
		StorageContainer storageContainer = activeStorage.Get(base.isServer);
		if ((Object)(object)storageContainer != (Object)null && storageContainer.IsValid() && !storageContainer.inventory.IsEmpty())
		{
			return storageContainer;
		}
		return null;
	}

	public override string Admin_Who()
	{
		StringBuilder stringBuilder = new StringBuilder();
		int num = 0;
		foreach (BaseEntity child in children)
		{
			if (child is SleepingBagCamper sleepingBagCamper)
			{
				stringBuilder.AppendLine($"Bag {num++}:");
				stringBuilder.AppendLine(sleepingBagCamper.Admin_Who());
			}
		}
		return stringBuilder.ToString();
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (base.IsOnAVehicle && base.Vehicle.IsDead())
		{
			return base.CanBeLooted(player);
		}
		if (base.CanBeLooted(player))
		{
			return IsOnThisModule(player);
		}
		return false;
	}

	public override bool IsOnThisModule(BasePlayer player)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (base.IsOnThisModule(player))
		{
			return true;
		}
		if (!player.isMounted)
		{
			return false;
		}
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(((Component)this).transform, bounds);
		return ((OBB)(ref val)).Contains(player.CenterPoint());
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.camperModule != null)
		{
			activeBbq.uid = info.msg.camperModule.bbqId;
			activeLocker.uid = info.msg.camperModule.lockerId;
			activeStorage.uid = info.msg.camperModule.storageID;
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class VehicleModuleSeating : BaseVehicleModule, IPrefabPreProcess
{
	[Serializable]
	public class MountHotSpot
	{
		public Transform transform;

		public Vector2 size;
	}

	[Serializable]
	public class Seating
	{
		[Header("Seating & Controls")]
		public bool doorsAreLockable = true;

		[Obsolete("Use BaseVehicle.mountPoints instead")]
		[HideInInspector]
		public MountPointInfo[] mountPoints;

		public Transform steeringWheel;

		public Transform accelPedal;

		public Transform brakePedal;

		public Transform steeringWheelLeftGrip;

		public Transform steeringWheelRightGrip;

		public Transform accelPedalGrip;

		public Transform brakePedalGrip;

		public MountHotSpot[] mountHotSpots;

		[Header("Dashboard")]
		public Transform speedometer;

		public Transform fuelGauge;

		public Renderer dashboardRenderer;

		[Range(0f, 3f)]
		public int checkEngineLightMatIndex = 2;

		[ColorUsage(true, true)]
		public Color checkEngineLightEmission;

		[Range(0f, 3f)]
		public int fuelLightMatIndex = 3;

		[ColorUsage(true, true)]
		public Color fuelLightEmission;
	}

	[SerializeField]
	private ProtectionProperties passengerProtection;

	[SerializeField]
	private ModularCarCodeLockVisuals codeLockVisuals;

	[SerializeField]
	private Seating seating;

	[HideInInspector]
	[SerializeField]
	private Vector3 steerAngle;

	[SerializeField]
	[HideInInspector]
	private Vector3 accelAngle;

	[SerializeField]
	[HideInInspector]
	private Vector3 brakeAngle;

	[SerializeField]
	[HideInInspector]
	private Vector3 speedometerAngle;

	[HideInInspector]
	[SerializeField]
	private Vector3 fuelAngle;

	[Header("Horn")]
	[SerializeField]
	private SoundDefinition hornLoop;

	[SerializeField]
	private SoundDefinition hornStart;

	private const Flags FLAG_HORN = Flags.Reserved8;

	private float steerPercent;

	private float throttlePercent;

	private float brakePercent;

	private bool? checkEngineLightOn;

	private bool? fuelLightOn;

	protected IVehicleLockUser VehicleLockUser;

	private MaterialPropertyBlock dashboardLightPB;

	private static int emissionColorID = Shader.PropertyToID("_EmissionColor");

	private BasePlayer hornPlayer;

	public override bool HasSeating => mountPoints.Count > 0;

	public ModularCar Car { get; private set; }

	protected bool IsOnACar => (Object)(object)Car != (Object)null;

	protected bool IsOnAVehicleLockUser => VehicleLockUser != null;

	public bool DoorsAreLockable => seating.doorsAreLockable;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehicleModuleSeating.OnRpcMessage", 0);
		try
		{
			if (rpc == 2791546333u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_DestroyLock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_DestroyLock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2791546333u, "RPC_DestroyLock", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_DestroyLock(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_DestroyLock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if ((Object)(object)seating.steeringWheel != (Object)null)
		{
			steerAngle = seating.steeringWheel.localEulerAngles;
		}
		if ((Object)(object)seating.accelPedal != (Object)null)
		{
			accelAngle = seating.accelPedal.localEulerAngles;
		}
		if ((Object)(object)seating.brakePedal != (Object)null)
		{
			brakeAngle = seating.brakePedal.localEulerAngles;
		}
		if ((Object)(object)seating.speedometer != (Object)null)
		{
			speedometerAngle = new Vector3(-160f, 0f, -40f);
		}
		if ((Object)(object)seating.fuelGauge != (Object)null)
		{
			fuelAngle = seating.fuelGauge.localEulerAngles;
		}
	}

	public virtual bool IsOnThisModule(BasePlayer player)
	{
		BaseMountable mounted = player.GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			return (Object)(object)(mounted.GetParentEntity() as VehicleModuleSeating) == (Object)(object)this;
		}
		return false;
	}

	public bool HasADriverSeat()
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (mountPoint.isDriver)
			{
				return true;
			}
		}
		return false;
	}

	public override void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex)
	{
		base.ModuleAdded(vehicle, firstSocketIndex);
		Car = vehicle as ModularCar;
		VehicleLockUser = vehicle as IVehicleLockUser;
		if (!HasSeating || !base.isServer)
		{
			return;
		}
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (mountPoint.mountable is ModularCarSeat modularCarSeat)
			{
				modularCarSeat.associatedSeatingModule = this;
			}
		}
	}

	public override void ModuleRemoved()
	{
		base.ModuleRemoved();
		Car = null;
		VehicleLockUser = null;
	}

	public bool PlayerCanDestroyLock(BasePlayer player)
	{
		if (!IsOnAVehicleLockUser || (Object)(object)player == (Object)null)
		{
			return false;
		}
		if (base.Vehicle.IsDead())
		{
			return false;
		}
		if (!HasADriverSeat())
		{
			return false;
		}
		if (!VehicleLockUser.PlayerCanDestroyLock(player, this))
		{
			return false;
		}
		if (player.isMounted)
		{
			return !VehicleLockUser.PlayerHasUnlockPermission(player);
		}
		return true;
	}

	protected BaseVehicleSeat GetSeatAtIndex(int index)
	{
		return mountPoints[index].mountable as BaseVehicleSeat;
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		if ((Object)(object)passengerProtection != (Object)null)
		{
			passengerProtection.Scale(info.damageTypes);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if ((Object)(object)hornLoop != (Object)null && IsOnThisModule(player))
		{
			bool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);
			if (flag != HasFlag(Flags.Reserved8))
			{
				SetFlag(Flags.Reserved8, flag);
			}
			if (flag)
			{
				Interface.CallHook("OnVehicleHornPressed", (object)this, (object)player);
				hornPlayer = player;
			}
		}
	}

	public override void OnPlayerDismountedVehicle(BasePlayer player)
	{
		base.OnPlayerDismountedVehicle(player);
		if (HasFlag(Flags.Reserved8) && (Object)(object)player == (Object)(object)hornPlayer)
		{
			SetFlag(Flags.Reserved8, b: false);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_DestroyLock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (IsOnAVehicleLockUser && PlayerCanDestroyLock(player))
		{
			VehicleLockUser.RemoveLock();
		}
	}

	protected virtual Vector3 ModifySeatPositionLocalSpace(int index, Vector3 desiredPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return desiredPos;
	}

	public override void OnEngineStateChanged(VehicleEngineController<GroundVehicle>.EngineState oldState, VehicleEngineController<GroundVehicle>.EngineState newState)
	{
		base.OnEngineStateChanged(oldState, newState);
		if (!GameInfo.HasAchievements || base.isClient || newState != VehicleEngineController<GroundVehicle>.EngineState.On || mountPoints == null)
		{
			return;
		}
		bool flag = true;
		foreach (BaseVehicleModule attachedModuleEntity in Car.AttachedModuleEntities)
		{
			if (attachedModuleEntity is VehicleModuleEngine { AtPeakPerformance: false })
			{
				flag = false;
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if ((Object)(object)mountPoint.mountable.GetMounted() != (Object)null)
			{
				mountPoint.mountable.GetMounted().GiveAchievement("BUCKLE_UP");
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class MountHotSpot
{
	public Transform transform;

	public Vector2 size;
}


using System;
using UnityEngine;

[Serializable]
public class Seating
{
	[Header("Seating & Controls")]
	public bool doorsAreLockable = true;

	[Obsolete("Use BaseVehicle.mountPoints instead")]
	[HideInInspector]
	public MountPointInfo[] mountPoints;

	public Transform steeringWheel;

	public Transform accelPedal;

	public Transform brakePedal;

	public Transform steeringWheelLeftGrip;

	public Transform steeringWheelRightGrip;

	public Transform accelPedalGrip;

	public Transform brakePedalGrip;

	public MountHotSpot[] mountHotSpots;

	[Header("Dashboard")]
	public Transform speedometer;

	public Transform fuelGauge;

	public Renderer dashboardRenderer;

	[Range(0f, 3f)]
	public int checkEngineLightMatIndex = 2;

	[ColorUsage(true, true)]
	public Color checkEngineLightEmission;

	[Range(0f, 3f)]
	public int fuelLightMatIndex = 3;

	[ColorUsage(true, true)]
	public Color fuelLightEmission;
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class VehicleModuleStorage : VehicleModuleSeating
{
	[Serializable]
	public class Storage
	{
		public GameObjectRef storageUnitPrefab;

		public Transform storageUnitPoint;
	}

	[SerializeField]
	private Storage storage;

	private EntityRef storageUnitInstance;

	public static readonly Phrase StorageCantBeMovedError = new Phrase("error.itemsinstorage", "Cannot move item: Storage contains items!");

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehicleModuleStorage.OnRpcMessage", 0);
		try
		{
			if (rpc == 4254195175u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4254195175u, "RPC_Open", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Open(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Open");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 425471188 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TryOpenWithKeycode "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TryOpenWithKeycode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(425471188u, "RPC_TryOpenWithKeycode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_TryOpenWithKeycode(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_TryOpenWithKeycode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public IItemContainerEntity GetContainer()
	{
		BaseEntity baseEntity = storageUnitInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as IItemContainerEntity;
		}
		return null;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		storageUnitInstance.uid = info.msg.simpleUID.uid;
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!Application.isLoadingSave && ((Component)storage.storageUnitPoint).gameObject.activeSelf)
		{
			CreateStorageEntity();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		IItemContainerEntity container = GetContainer();
		if (!container.IsUnityNull())
		{
			ItemContainer inventory = container.inventory;
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
		}
	}

	private void OnItemAddedRemoved(Item item, bool add)
	{
		AssociatedItemInstance?.LockUnlock(!CanBeMovedNowOnVehicle());
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			IItemContainerEntity container = GetContainer();
			if (!container.IsUnityNull())
			{
				container.DropItems();
			}
		}
		base.DoServerDestroy();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.simpleUID = Pool.Get<SimpleUID>();
		info.msg.simpleUID.uid = storageUnitInstance.uid;
	}

	public void CreateStorageEntity()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (IsFullySpawned() && base.isServer && !storageUnitInstance.IsValid(base.isServer))
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(storage.storageUnitPrefab.resourcePath, storage.storageUnitPoint.localPosition, storage.storageUnitPoint.localRotation);
			storageUnitInstance.Set(baseEntity);
			baseEntity.SetParent(this);
			baseEntity.Spawn();
			ItemContainer inventory = GetContainer().inventory;
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
		}
	}

	public void DestroyStorageEntity()
	{
		if (!IsFullySpawned() || !base.isServer)
		{
			return;
		}
		BaseEntity baseEntity = storageUnitInstance.Get(base.isServer);
		if (baseEntity.IsValid())
		{
			if (baseEntity is BaseCombatEntity baseCombatEntity)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill();
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_Open(RPCMessage msg)
	{
		TryOpen(msg.player);
	}

	private bool TryOpen(BasePlayer player)
	{
		if (!player.IsValid() || !CanBeLooted(player))
		{
			return false;
		}
		IItemContainerEntity container = GetContainer();
		if (!container.IsUnityNull())
		{
			container.PlayerOpenLoot(player);
		}
		else
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
		}
		return true;
	}

	protected override bool CanBeMovedNowOnVehicle()
	{
		IItemContainerEntity container = GetContainer();
		if (!container.IsUnityNull() && !container.inventory.IsEmpty())
		{
			return false;
		}
		return true;
	}

	public override Phrase CannotBeMovedNowReason()
	{
		return StorageCantBeMovedError;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_TryOpenWithKeycode(RPCMessage msg)
	{
		if (!base.IsOnACar)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			string codeEntered = msg.read.String(256, false);
			if (base.Car.CarLock.TryOpenWithCode(player, codeEntered))
			{
				TryOpen(player);
			}
			else
			{
				base.Car.ClientRPC(RpcTarget.NetworkGroup("CodeEntryFailed"));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class Storage
{
	public GameObjectRef storageUnitPrefab;

	public Transform storageUnitPoint;
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class VehicleModuleTaxi : VehicleModuleStorage
{
	[Header("Taxi")]
	[SerializeField]
	private SoundDefinition kickButtonSound;

	[SerializeField]
	private SphereCollider kickButtonCollider;

	[SerializeField]
	private float maxKickVelocity = 4f;

	private Vector3 KickButtonPos => ((Component)kickButtonCollider).transform.position + ((Component)kickButtonCollider).transform.rotation * kickButtonCollider.center;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehicleModuleTaxi.OnRpcMessage", 0);
		try
		{
			if (rpc == 2714639811u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_KickPassengers "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_KickPassengers", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2714639811u, "RPC_KickPassengers", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_KickPassengers(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_KickPassengers");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private bool CanKickPassengers(BasePlayer player)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (!base.IsOnAVehicle)
		{
			return false;
		}
		if (base.Vehicle.GetSpeed() > maxKickVelocity)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (!base.Vehicle.PlayerIsMounted(player))
		{
			return false;
		}
		Vector3 val = KickButtonPos - ((Component)player).transform.position;
		if (Vector3.Dot(val, ((Component)player).transform.forward) < 0f)
		{
			return ((Vector3)(ref val)).sqrMagnitude < 4f;
		}
		return false;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_KickPassengers(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanKickPassengers(player))
		{
			KickPassengers();
		}
	}

	private void KickPassengers()
	{
		if (!base.IsOnAVehicle)
		{
			return;
		}
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			BaseMountable mountable = mountPoint.mountable;
			BasePlayer mounted = mountable.GetMounted();
			if ((Object)(object)mounted != (Object)null && mountable.HasValidDismountPosition(mounted))
			{
				mountable.AttemptDismount(mounted);
			}
		}
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class VehiclePrivilege : SimplePrivilege
{
	public GameObject assignDialog;

	public bool SupportFriendListAdd;

	public bool OnlyDriverCanModifyAuth = true;

	private BaseVehicle parentVehicle;

	public BaseVehicle ParentVehicle
	{
		get
		{
			if ((Object)(object)parentVehicle == (Object)null)
			{
				parentVehicle = FindParentVehicleRecursive(this, 5);
			}
			return parentVehicle;
		}
		set
		{
			parentVehicle = value;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehiclePrivilege.OnRpcMessage", 0);
		try
		{
			if (rpc == 82205621 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AddAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("AddAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(82205621u, "AddAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							AddAuthorize(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AddAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1092560690 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AddSelfAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("AddSelfAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1092560690u, "AddSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							AddSelfAuthorize(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in AddSelfAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 253307592 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearList "));
				}
				TimeWarning val2 = TimeWarning.New("ClearList", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(253307592u, "ClearList", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							ClearList(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in ClearList");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3617985969u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RemoveSelfAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("RemoveSelfAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3617985969u, "RemoveSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc5 = rPCMessage;
							RemoveSelfAuthorize(rpc5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RemoveSelfAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private static BaseVehicle FindParentVehicleRecursive(BaseEntity startEnt, int maxDepth)
	{
		if ((Object)(object)startEnt == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = startEnt;
		int num = 0;
		while ((Object)(object)baseEntity != (Object)null && num++ < maxDepth)
		{
			BaseEntity baseEntity2 = baseEntity.GetParentEntity();
			if ((Object)(object)baseEntity2 == (Object)null)
			{
				return null;
			}
			BaseVehicle baseVehicle = baseEntity2 as BaseVehicle;
			if ((Object)(object)baseVehicle != (Object)null)
			{
				return baseVehicle;
			}
			baseEntity = baseEntity2;
		}
		return null;
	}

	public bool IsDriver(BasePlayer player)
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return false;
		}
		BaseVehicle baseVehicle = baseEntity as BaseVehicle;
		if ((Object)(object)baseVehicle == (Object)null)
		{
			return false;
		}
		return baseVehicle.IsDriver(player);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void AddSelfAuthorize(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanModifyAuth(rpc.player) && Interface.CallHook("OnCupboardAuthorize", (object)this, (object)rpc.player) == null)
		{
			AddPlayer(rpc.player);
			SendNetworkUpdate();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void AddAuthorize(RPCMessage rpc)
	{
		if (SupportFriendListAdd && rpc.player.CanInteract() && IsAuthed(rpc.player) && CanModifyAuth(rpc.player))
		{
			ulong targetPlayerId = rpc.read.UInt64();
			AddPlayer(rpc.player, targetPlayerId);
			SendNetworkUpdate();
		}
	}

	public void AddPlayer(BasePlayer granter, ulong targetPlayerId)
	{
		if (!AtMaxAuthCapacity())
		{
			authorizedPlayers.Add(targetPlayerId);
			Analytics.Azure.OnEntityAuthChanged(this, granter, authorizedPlayers, "added", targetPlayerId);
			UpdateMaxAuthCapacity();
		}
	}

	public void AddPlayer(BasePlayer player)
	{
		if (!AtMaxAuthCapacity())
		{
			authorizedPlayers.Add(player.userID);
			Analytics.Azure.OnEntityAuthChanged(this, player, authorizedPlayers, "added", player.userID);
			UpdateMaxAuthCapacity();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanModifyAuth(rpc.player) && Interface.CallHook("OnCupboardDeauthorize", (object)this, (object)rpc.player) == null)
		{
			authorizedPlayers.Remove(rpc.player.userID);
			Analytics.Azure.OnEntityAuthChanged(this, rpc.player, authorizedPlayers, "removed", rpc.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void ClearList(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanModifyAuth(rpc.player) && Interface.CallHook("OnCupboardClearList", (object)this, (object)rpc.player) == null)
		{
			authorizedPlayers.Clear();
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

	private bool CanModifyAuth(BasePlayer player)
	{
		if (!OnlyDriverCanModifyAuth)
		{
			return true;
		}
		return IsDriver(player);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class VendingMachine : ContainerIOEntity, IUGCBrowserEntity, IFoodSpoilModifier, IIndustrialStorageCallbackReceiver, PlayerInventory.ICanMoveFrom
{
	public static class VendingMachineFlags
	{
		public const Flags EmptyInv = Flags.Reserved1;

		public const Flags IsVending = Flags.Reserved2;

		public const Flags Broadcasting = Flags.Reserved4;

		public const Flags OutOfStock = Flags.Reserved5;

		public const Flags NoDirectAccess = Flags.Reserved6;
	}

	private enum HistoryCategory
	{
		History,
		BestSold,
		MostRevenue
	}

	[Serializable]
	public class PurchaseDetails
	{
		public int itemId;

		public int amount;

		public int priceId;

		public int price;

		public int timestamp;

		public bool itemIsBp;

		public bool priceIsBp;
	}

	[Header("VendingMachine")]
	public static readonly Phrase WaitForVendingMessage = new Phrase("vendingmachine.wait", "Please wait...");

	public GameObjectRef adminMenuPrefab;

	public string customerPanel = "";

	public SellOrderContainer sellOrders;

	public SoundPlayer buySound;

	public string shopName = "A Shop";

	public int maxCurrencyVolume = 1;

	public Vector3 localDropPosition = Vector3.zero;

	public GameObjectRef mapMarkerPrefab;

	public bool IsLocalized;

	[Range(0f, 1f)]
	public float PoweredFoodSpoilageRateMultiplier = 0.1f;

	public int PowerConsumption = 5;

	public bool IsInDeepSeaCached;

	[Header("Drone Prediction")]
	public DeliveryDroneConfig predictionConfig;

	private Action fullUpdateCached;

	private ulong nameLastEditedBy;

	private bool droneAccessible;

	protected BasePlayer vend_Player;

	private int vend_sellOrderID;

	private int vend_numberOfTransactions;

	public bool transactionActive;

	private VendingMachineMapMarker myMarker;

	private bool industrialItemIncoming;

	private static readonly Phrase NotAdministratingError = new Phrase("error.notadministrating", "Cannot move item: Not administrating!");

	public static readonly Phrase TooManySellOrders = new Phrase("error_toomanysellorders", "Too many sell orders");

	[ServerVar]
	public static int max_returned = 100;

	[ServerVar]
	public static int max_processed = 10000;

	[ServerVar]
	public static int max_history = 10000;

	private List<PurchaseDetails> purchaseHistory = new List<PurchaseDetails>();

	private Dictionary<ulong, int> uniqueCustomers = new Dictionary<ulong, int>();

	public ItemDefinition blueprintBaseDef => ItemManager.blueprintBaseDef;

	public uint[] GetContentCRCs => null;

	public UGCType ContentType => UGCType.VendingMachine;

	public List<ulong> EditingHistory => new List<ulong> { nameLastEditedBy };

	public BaseNetworkable UgcEntity
	{
		get
		{
			if (!(this is NPCVendingMachine))
			{
				return this;
			}
			return null;
		}
	}

	public string ContentString => shopName;

	public virtual EraRestriction CurrentEraRestriction => (EraRestriction)7;

	public virtual bool ShouldRecordStats => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VendingMachine.OnRpcMessage", 0);
		try
		{
			if (rpc == 3011053703u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BuyItem "));
				}
				TimeWarning val2 = TimeWarning.New("BuyItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3011053703u, "BuyItem", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3011053703u, "BuyItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							BuyItem(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BuyItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1626480840 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_AddSellOrder "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_AddSellOrder", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1626480840u, "RPC_AddSellOrder", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_AddSellOrder(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_AddSellOrder");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 169239598 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Broadcast "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Broadcast", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(169239598u, "RPC_Broadcast", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_Broadcast(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_Broadcast");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3680901137u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_DeleteSellOrder "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_DeleteSellOrder", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3680901137u, "RPC_DeleteSellOrder", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_DeleteSellOrder(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_DeleteSellOrder");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2555993359u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenAdmin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenAdmin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2555993359u, "RPC_OpenAdmin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_OpenAdmin(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in RPC_OpenAdmin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 36164441 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenShop "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenShop", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(36164441u, "RPC_OpenShop", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							RPC_OpenShop(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in RPC_OpenShop");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2947824655u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenShopNoLOS "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenShopNoLOS", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2947824655u, "RPC_OpenShopNoLOS", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							RPC_OpenShopNoLOS(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in RPC_OpenShopNoLOS");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3346513099u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RotateVM "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RotateVM", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3346513099u, "RPC_RotateVM", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							RPC_RotateVM(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogException(ex8);
						player.Kick("RPC Error in RPC_RotateVM");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1012779214 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_UpdateShopName "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_UpdateShopName", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1012779214u, "RPC_UpdateShopName", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg9 = rPCMessage;
							RPC_UpdateShopName(msg9);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in RPC_UpdateShopName");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1147600716 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_RequestLongTermData "));
				}
				TimeWarning val2 = TimeWarning.New("SV_RequestLongTermData", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1147600716u, "SV_RequestLongTermData", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1147600716u, "SV_RequestLongTermData", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg10 = rPCMessage;
							SV_RequestLongTermData(msg10);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogException(ex10);
						player.Kick("RPC Error in SV_RequestLongTermData");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3957849636u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_RequestPurchaseData "));
				}
				TimeWarning val2 = TimeWarning.New("SV_RequestPurchaseData", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3957849636u, "SV_RequestPurchaseData", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3957849636u, "SV_RequestPurchaseData", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg11 = rPCMessage;
							SV_RequestPurchaseData(msg11);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogException(ex11);
						player.Kick("RPC Error in SV_RequestPurchaseData");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3559014831u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - TransactionStart "));
				}
				TimeWarning val2 = TimeWarning.New("TransactionStart", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3559014831u, "TransactionStart", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							TransactionStart(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex12)
					{
						Debug.LogException(ex12);
						player.Kick("RPC Error in TransactionStart");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public float GetSpoilMultiplier(Item arg)
	{
		if (IsPowered())
		{
			return PoweredFoodSpoilageRateMultiplier;
		}
		return 1f;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && info.msg.vendingMachineStats != null)
		{
			purchaseHistory = GetListFromProto(info.msg.vendingMachineStats.purchaseHistory);
			for (int i = 0; i < info.msg.vendingMachineStats.customers.Count; i++)
			{
				uniqueCustomers.Add(info.msg.vendingMachineStats.customers[i], info.msg.vendingMachineStats.customersVisits[i]);
			}
		}
		if (info.msg.vendingMachine != null)
		{
			if (!IsLocalized)
			{
				shopName = info.msg.vendingMachine.shopName;
			}
			if (info.msg.vendingMachine.sellOrderContainer != null)
			{
				sellOrders = info.msg.vendingMachine.sellOrderContainer;
				sellOrders.ShouldPool = false;
			}
			if (info.fromDisk && base.isServer)
			{
				nameLastEditedBy = info.msg.vendingMachine.nameLastEditedBy;
				RefreshSellOrderStockLevel();
			}
		}
	}

	public static int GetTotalReceivedMerchandiseForOrder(SellOrder order)
	{
		return GetTotalReceivedMerchandiseForOrder(order.itemToSellAmount, order.receivedQuantityMultiplier);
	}

	public static int GetTotalReceivedMerchandiseForOrder(int merchAmountPerOrder, float multiplier)
	{
		float num = ((multiplier != 0f) ? multiplier : 1f);
		return Mathf.Max(Mathf.RoundToInt((float)merchAmountPerOrder * num), 1);
	}

	public static int GetTotalPriceForOrder(SellOrder order)
	{
		return GetTotalPriceForOrder(order.currencyAmountPerItem, order.priceMultiplier);
	}

	public static int GetTotalPriceForOrder(int currencyAmountPerItem, float multiplier)
	{
		float num = ((multiplier != 0f) ? multiplier : 1f);
		return Mathf.Max(Mathf.RoundToInt((float)currencyAmountPerItem * num), 1);
	}

	private void OnPhysicsNeighbourChanged()
	{
		if (predictionConfig != null)
		{
			UpdateDronePrediction();
		}
	}

	protected void UpdateDronePrediction(bool checkForUpdate = true)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (predictionConfig == null)
		{
			droneAccessible = false;
			return;
		}
		TimeWarning val = TimeWarning.New("VendingMachine.UpdateDronePrediction", 0);
		try
		{
			bool flag = predictionConfig.IsVendingMachineAccessible(this, predictionConfig.vendingMachineOffset, out var hitInfo);
			flag |= predictionConfig.IsVendingMachineAccessible(this, predictionConfig.vendingMachineOffset + Vector3.forward * predictionConfig.maxDistanceFromVendingMachine, out hitInfo);
			bool flag2 = droneAccessible;
			bool flag3 = flag;
			droneAccessible = flag;
			if (checkForUpdate && flag2 != flag3)
			{
				((FacepunchBehaviour)this).CancelInvoke(fullUpdateCached);
				((FacepunchBehaviour)this).Invoke(fullUpdateCached, 0.2f);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	public bool IsDroneAccessible()
	{
		return droneAccessible;
	}

	public override void Save(SaveInfo info)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Expected O, but got Unknown
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Expected O, but got Unknown
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Expected O, but got Unknown
		base.Save(info);
		info.msg.vendingMachine = new VendingMachine();
		info.msg.vendingMachine.ShouldPool = false;
		info.msg.vendingMachine.shopName = shopName;
		if (info.forDisk)
		{
			info.msg.vendingMachine.nameLastEditedBy = nameLastEditedBy;
			if (ShouldRecordStats)
			{
				info.msg.vendingMachineStats = Pool.Get<VendingMachineStats>();
				info.msg.vendingMachineStats.purchaseHistory = GetEntriesProto(purchaseHistory);
				info.msg.vendingMachineStats.customers = uniqueCustomers.Keys.ToList();
				info.msg.vendingMachineStats.customersVisits = uniqueCustomers.Values.ToList();
			}
		}
		if (this is NPCVendingMachine)
		{
			info.msg.vendingMachine.translationToken = GetTranslationToken();
			info.msg.vendingMachine.inDeepSea = IsInDeepSeaCached;
		}
		if (sellOrders == null)
		{
			return;
		}
		info.msg.vendingMachine.sellOrderContainer = new SellOrderContainer();
		info.msg.vendingMachine.sellOrderContainer.ShouldPool = false;
		info.msg.vendingMachine.sellOrderContainer.sellOrders = new List<SellOrder>();
		foreach (SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (CanSellOrBuyItem(sellOrder.itemToSellID, sellOrder.currencyID))
			{
				SellOrder val = new SellOrder();
				val.ShouldPool = false;
				sellOrder.CopyTo(val);
				info.msg.vendingMachine.sellOrderContainer.sellOrders.Add(val);
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (base.isServer)
		{
			fullUpdateCached = FullUpdate;
			UpdateDronePrediction(checkForUpdate: false);
			InstallDefaultSellOrders();
			SetFlag(Flags.Reserved2, b: false);
			base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
			RefreshSellOrderStockLevel();
			ItemContainer itemContainer = base.inventory;
			itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
			UpdateMapMarker();
		}
	}

	public override void DestroyShared()
	{
		if (Object.op_Implicit((Object)(object)myMarker))
		{
			myMarker.Kill();
			myMarker = null;
		}
		base.DestroyShared();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}

	public void FullUpdate()
	{
		RefreshSellOrderStockLevel();
		UpdateMapMarker();
		SendNetworkUpdate();
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		((FacepunchBehaviour)this).CancelInvoke(fullUpdateCached);
		((FacepunchBehaviour)this).Invoke(fullUpdateCached, 0.2f);
	}

	public void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)
	{
		int num = 0;
		foreach (SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (!((Object)(object)itemDef == (Object)null) && itemDef.itemid != sellOrder.itemToSellID)
			{
				continue;
			}
			List<Item> list = Pool.Get<List<Item>>();
			GetItemsToSell(sellOrder, list);
			int num2 = sellOrder.itemToSellAmount;
			if ((Object)(object)ItemManager.FindItemDefinition(sellOrder.itemToSellID) == (Object)(object)NPCVendingMachine.ScrapItem && sellOrder.receivedQuantityMultiplier != 1f)
			{
				num2 = GetTotalPriceForOrder(num2, sellOrder.receivedQuantityMultiplier);
			}
			int inStock;
			if (list.Count < 0)
			{
				inStock = 0;
			}
			else
			{
				List<Item> source = list;
				Func<Item, int> selector = (Item x) => x.amount;
				Interface.CallHook("OnRefreshVendingStock", (object)this, (object)itemDef);
				inStock = source.Sum(selector) / num2;
			}
			sellOrder.inStock = inStock;
			float itemCondition = 0f;
			float itemConditionMax = 0f;
			int instanceData = 0;
			List<int> list2 = Pool.Get<List<int>>();
			int totalAttachmentSlots = 0;
			int ammoType = 0;
			int ammoCount = 0;
			if (list.Count > 0)
			{
				if (list[0].hasCondition)
				{
					itemCondition = list[0].condition;
					itemConditionMax = list[0].maxCondition;
				}
				if ((Object)(object)list[0].info != (Object)null && (list[0].info.amountType == ItemDefinition.AmountType.Genetics || list[0].info.amountType == ItemDefinition.AmountType.NucleusGrades) && list[0].instanceData != null)
				{
					instanceData = list[0].instanceData.dataInt;
					sellOrder.inStock = list[0].amount;
				}
				if (list[0].contents != null && list[0].contents.capacity > 0 && list[0].contents.HasFlag(ItemContainer.Flag.ShowSlotsOnIcon))
				{
					foreach (Item item in list[0].contents.itemList)
					{
						list2.Add(item.info.itemid);
					}
					totalAttachmentSlots = list[0].contents.capacity;
				}
				if (list[0].GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)
				{
					ammoCount = baseProjectile.primaryMagazine.contents;
					if ((Object)(object)baseProjectile.primaryMagazine.ammoType != (Object)null)
					{
						ammoType = baseProjectile.primaryMagazine.ammoType.itemid;
					}
				}
			}
			sellOrder.ammoType = ammoType;
			sellOrder.ammoCount = ammoCount;
			sellOrder.itemCondition = itemCondition;
			sellOrder.itemConditionMax = itemConditionMax;
			sellOrder.instanceData = instanceData;
			if (sellOrder.attachmentsList != null)
			{
				Pool.FreeUnmanaged<int>(ref sellOrder.attachmentsList);
			}
			sellOrder.attachmentsList = list2;
			sellOrder.totalAttachmentSlots = totalAttachmentSlots;
			sellOrder.priceMultiplier = GetDiscountForSlot(num, sellOrder);
			sellOrder.receivedQuantityMultiplier = GetReceivedQuantityMultiplier(num, sellOrder);
			num++;
			Pool.Free<Item>(ref list, false);
		}
	}

	protected virtual float GetDiscountForSlot(int sellOrderSlot, SellOrder forOrder)
	{
		return 1f;
	}

	protected virtual float GetReceivedQuantityMultiplier(int sellOrderSlot, SellOrder forOrder)
	{
		return 1f;
	}

	public bool OutOfStock()
	{
		foreach (SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (sellOrder.inStock > 0)
			{
				return true;
			}
		}
		return false;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Reserved2, b: false);
		RefreshSellOrderStockLevel();
		UpdateMapMarker();
	}

	public void UpdateEmptyFlag()
	{
		SetFlag(Flags.Reserved1, base.inventory.itemList.Count == 0);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		UpdateEmptyFlag();
		if ((Object)(object)vend_Player != (Object)null && (Object)(object)vend_Player == (Object)(object)player)
		{
			ClearPendingOrder();
		}
	}

	public virtual void InstallDefaultSellOrders()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		sellOrders = new SellOrderContainer();
		sellOrders.ShouldPool = false;
		sellOrders.sellOrders = new List<SellOrder>();
	}

	public virtual bool HasVendingSounds()
	{
		return true;
	}

	public virtual float GetBuyDuration()
	{
		return 2.5f;
	}

	public void SetPendingOrder(BasePlayer buyer, int sellOrderId, int numberOfTransactions)
	{
		ClearPendingOrder();
		vend_Player = buyer;
		vend_sellOrderID = sellOrderId;
		vend_numberOfTransactions = numberOfTransactions;
		SetFlag(Flags.Reserved2, b: true);
		if (HasVendingSounds())
		{
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_StartVendingSounds"), sellOrderId);
		}
	}

	public void ClearPendingOrder()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)CompletePendingOrder);
		vend_Player = null;
		vend_sellOrderID = -1;
		vend_numberOfTransactions = -1;
		SetFlag(Flags.Reserved2, b: false);
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_CancelVendingSounds"));
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void BuyItem(RPCMessage rpc)
	{
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		if (!OccupiedCheck(rpc.player))
		{
			return;
		}
		int num = rpc.read.Int32();
		int num2 = rpc.read.Int32();
		if (IsVending())
		{
			rpc.player.ShowToast(GameTip.Styles.Red_Normal, WaitForVendingMessage, false);
		}
		else
		{
			if (Interface.CallHook("OnBuyVendingItem", (object)this, (object)rpc.player, (object)num, (object)num2) != null)
			{
				return;
			}
			int num3 = 0;
			for (int i = 0; i < sellOrders.sellOrders.Count; i++)
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellOrders.sellOrders[i].itemToSellID);
				ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(sellOrders.sellOrders[i].currencyID);
				if (itemDefinition.IsAllowed(CurrentEraRestriction) && itemDefinition2.IsAllowed(CurrentEraRestriction))
				{
					if (num3 == num)
					{
						num = i;
						break;
					}
					num3++;
				}
			}
			SetPendingOrder(rpc.player, num, num2);
			((FacepunchBehaviour)this).Invoke((Action)CompletePendingOrder, GetBuyDuration());
		}
	}

	public virtual void CompletePendingOrder()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		DoTransaction(vend_Player, vend_sellOrderID, vend_numberOfTransactions);
		ClearPendingOrder();
		Decay.RadialDecayTouch(((Component)this).transform.position, 40f, 2097408);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void TransactionStart(RPCMessage rpc)
	{
	}

	private void GetItemsToSell(SellOrder sellOrder, List<Item> items)
	{
		if (sellOrder.itemToSellIsBP)
		{
			foreach (Item item in base.inventory.itemList)
			{
				if (item.info.itemid == blueprintBaseDef.itemid && item.blueprintTarget == sellOrder.itemToSellID)
				{
					items.Add(item);
				}
			}
			return;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if (item2.info.itemid == sellOrder.itemToSellID)
			{
				items.Add(item2);
			}
		}
	}

	public int? GetSlotsRequiredForTransaction(int sellOrderId, int numberOfTransactions)
	{
		SellOrder val = sellOrders.sellOrders[sellOrderId];
		List<Item> items = Pool.Get<List<Item>>();
		GetItemsToSell(val, items);
		int num = val.itemToSellAmount * numberOfTransactions;
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(val.itemToSellID);
		if (!Object.op_Implicit((Object)(object)itemDefinition))
		{
			return null;
		}
		if (itemDefinition.stackable <= 1)
		{
			return num;
		}
		return num / itemDefinition.stackable;
	}

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action<BasePlayer, Item> onCurrencyRemoved = null, Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		if (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (targetContainer == null && Vector3.Distance(((Component)buyer).transform.position, ((Component)this).transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", (object)this, (object)buyer, (object)sellOrderId, (object)numberOfTransactions, (object)targetContainer);
		if (obj is bool)
		{
			return (bool)obj;
		}
		SellOrder val = sellOrders.sellOrders[sellOrderId];
		List<Item> list = Pool.Get<List<Item>>();
		GetItemsToSell(val, list);
		if (list == null || list.Count == 0)
		{
			Pool.FreeUnmanaged<Item>(ref list);
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, list[0].hasCondition ? 1 : 1000000);
		int num = val.itemToSellAmount * numberOfTransactions;
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(val.itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(val.currencyID);
		if (!itemDefinition.IsAllowed(CurrentEraRestriction) || !itemDefinition2.IsAllowed(CurrentEraRestriction))
		{
			return false;
		}
		if ((Object)(object)itemDefinition == (Object)(object)NPCVendingMachine.ScrapItem && val.receivedQuantityMultiplier != 1f)
		{
			num = GetTotalReceivedMerchandiseForOrder(val.itemToSellAmount, val.receivedQuantityMultiplier) * numberOfTransactions;
		}
		int num2 = list.Sum((Item x) => x.amount);
		if (num > num2)
		{
			Pool.FreeUnmanaged<Item>(ref list);
			return false;
		}
		int num3 = 0;
		PooledList<Item> val2 = Pool.Get<PooledList<Item>>();
		try
		{
			PooledList<Item> val3 = Pool.Get<PooledList<Item>>();
			try
			{
				buyer.inventory.FindItemsByItemID((List<Item>)(object)val3, val.currencyIsBP ? blueprintBaseDef.itemid : val.currencyID);
				for (int i = 0; i < ((List<Item>)(object)val3).Count; i++)
				{
					Item item = ((List<Item>)(object)val3)[i];
					if ((!val.currencyIsBP || item.blueprintTarget == val.currencyID) && (!item.hasCondition || (item.conditionNormalized >= 0.5f && item.maxConditionNormalized > 0.5f)) && item.GetItemVolume() <= maxCurrencyVolume)
					{
						((List<Item>)(object)val2).Add(item);
						num3 += item.amount;
					}
				}
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
			if (((List<Item>)(object)val2).Count == 0)
			{
				Pool.FreeUnmanaged<Item>(ref list);
				return false;
			}
			int num4 = GetTotalPriceForOrder(val) * numberOfTransactions;
			if (num3 < num4)
			{
				Pool.FreeUnmanaged<Item>(ref list);
				return false;
			}
			transactionActive = true;
			int num5 = 0;
			for (int j = 0; j < ((List<Item>)(object)val2).Count; j++)
			{
				Item item2 = ((List<Item>)(object)val2)[j];
				int num6 = Mathf.Min(num4 - num5, item2.amount);
				Item item3 = ((item2.amount > num6) ? item2.SplitItem(num6) : item2);
				TakeCurrencyItem(item3);
				onCurrencyRemoved?.Invoke(buyer, item3);
				num5 += num6;
				if (num5 >= num4)
				{
					break;
				}
			}
			int num7 = 0;
			foreach (Item item5 in list)
			{
				int num8 = num - num7;
				Item item4 = ((item5.amount > num8) ? item5.SplitItem(num8) : item5);
				if (item4 == null)
				{
					Debug.LogError((object)"Vending machine error, contact developers!");
				}
				else
				{
					num7 += item4.amount;
					object obj2 = Interface.CallHook("CanPurchaseItem", (object)buyer, (object)item4, (object)onItemPurchased, (object)this, (object)targetContainer);
					if (obj2 != null)
					{
						if (!(obj2 is bool))
						{
							return false;
						}
						return (bool)obj2;
					}
					RecordSaleAnalytics(item4, sellOrderId, val.currencyAmountPerItem);
					if (targetContainer == null)
					{
						GiveSoldItem(item4, buyer);
					}
					else if (!item4.MoveToContainer(targetContainer))
					{
						item4.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
					}
					if (ShouldRecordStats)
					{
						RegisterCustomer(buyer.userID);
					}
					onItemPurchased?.Invoke(buyer, item4);
				}
				if (num7 >= num)
				{
					break;
				}
			}
			Analytics.Azure.OnBuyFromVendingMachine(buyer, this, val.itemToSellID, num, val.itemToSellIsBP, val.currencyID, num5, val.currencyIsBP, numberOfTransactions, val.priceMultiplier, droneMarketTerminal);
			if (ShouldRecordStats)
			{
				AddPurchaseHistory(val.itemToSellID, num, val.currencyID, num5, val.itemToSellIsBP, val.currencyIsBP);
			}
			Pool.FreeUnmanaged<Item>(ref list);
			UpdateEmptyFlag();
			transactionActive = false;
			return true;
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	protected virtual void RecordSaleAnalytics(Item itemSold, int orderId, int currencyUsed)
	{
	}

	public virtual void TakeCurrencyItem(Item takenCurrencyItem)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnTakeCurrencyItem", (object)this, (object)takenCurrencyItem) == null && !takenCurrencyItem.MoveToContainer(base.inventory))
		{
			takenCurrencyItem.Drop(base.inventory.dropPosition, Vector3.zero);
		}
	}

	public virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnGiveSoldItem", (object)this, (object)soldItem, (object)buyer) == null)
		{
			while (soldItem.amount > soldItem.MaxStackable())
			{
				Item item = soldItem.SplitItem(soldItem.MaxStackable());
				buyer.GiveItem(item, GiveItemReason.PickedUp);
			}
			buyer.GiveItem(soldItem, GiveItemReason.PickedUp);
		}
	}

	public void SendSellOrders(BasePlayer player = null)
	{
		if (Object.op_Implicit((Object)(object)player))
		{
			ClientRPC(RpcTarget.Player("CLIENT_ReceiveSellOrders", player), sellOrders);
		}
		else
		{
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_ReceiveSellOrders"), sellOrders);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", (object)this, (object)player);
			UpdateMapMarker();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_UpdateShopName(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		string text = msg.read.String(32, false);
		if (CanPlayerAdmin(player) && Interface.CallHook("OnVendingShopRename", (object)this, (object)text, (object)player) == null)
		{
			shopName = text;
			nameLastEditedBy = player.userID.Get();
			UpdateMapMarker();
		}
	}

	public void UpdateMapMarkerPosition()
	{
		if (!((Object)(object)myMarker == (Object)null))
		{
			myMarker.TryUpdatePosition();
		}
	}

	public void UpdateMapMarker(bool updatePosition = false)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (!mapMarkerPrefab.isValid)
		{
			return;
		}
		if (IsBroadcasting())
		{
			bool flag = false;
			if ((Object)(object)myMarker == (Object)null)
			{
				myMarker = GameManager.server.CreateEntity(mapMarkerPrefab.resourcePath, ((Component)this).transform.position, Quaternion.identity) as VendingMachineMapMarker;
				flag = true;
			}
			myMarker.SetFlag(Flags.Busy, OutOfStock());
			myMarker.SetVendingMachine(this, shopName);
			if (flag)
			{
				myMarker.Spawn();
			}
			else
			{
				myMarker.SendNetworkUpdate();
			}
		}
		else if (Object.op_Implicit((Object)(object)myMarker))
		{
			myMarker.Kill();
			myMarker = null;
		}
	}

	public void OpenShop(BasePlayer ply)
	{
		SendSellOrders(ply);
		PlayerOpenLoot(ply, customerPanel);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_OpenShopNoLOS(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player))
		{
			OpenShop(msg.player);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player) && Interface.CallHook("OnVendingShopOpen", (object)this, (object)msg.player) == null)
		{
			OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", (object)this, (object)msg.player);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenAdmin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			OpenShop(player);
			ClientRPC(RpcTarget.Player("CLIENT_OpenAdminMenu", player));
			Interface.CallHook("OnOpenVendingAdmin", (object)this, (object)player);
		}
	}

	public void OnIndustrialItemTransferBegins()
	{
		industrialItemIncoming = true;
	}

	public void OnIndustrialItemTransferEnd()
	{
		industrialItemIncoming = false;
	}

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanVendingAcceptItem", (object)this, (object)item, (object)targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BasePlayer basePlayer = item.GetRootContainer()?.GetOwnerPlayer();
		if (transactionActive || industrialItemIncoming)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (base.inventory.itemList.Contains(item))
		{
			return true;
		}
		if ((Object)(object)basePlayer == (Object)null)
		{
			return item.GetEntityOwner() is ContainerCorpse;
		}
		return CanPlayerAdmin(basePlayer);
	}

	public PlayerInventory.CanMoveFromResponse CanMoveFrom(BasePlayer player, Item item)
	{
		return new PlayerInventory.CanMoveFromResponse(CanPlayerAdmin(player), NotAdministratingError);
	}

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		object obj = Interface.CallHook("CanUseVending", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		if (base.CanOpenLootPanel(player, panelName))
		{
			return CanPlayerAdmin(player);
		}
		return false;
	}

	public override Vector3 GetDropPosition()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(localDropPosition);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			Interface.CallHook("OnDeleteVendingOffer", (object)this, (object)num);
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				SellOrder val = sellOrders.sellOrders[num];
				Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, val.itemToSellID, val.itemToSellAmount, val.itemToSellIsBP, val.currencyID, val.currencyAmountPerItem, val.currencyIsBP, added: false);
				sellOrders.sellOrders.RemoveAt(num);
			}
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_RotateVM(RPCMessage msg)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnRotateVendingMachine", (object)this, (object)msg.player) == null && CanRotate())
		{
			UpdateEmptyFlag();
			if (msg.player.CanBuild() && IsInventoryEmpty())
			{
				((Component)this).transform.rotation = Quaternion.LookRotation(-((Component)this).transform.forward, ((Component)this).transform.up);
				SendNetworkUpdate();
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_AddSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			if (sellOrders.sellOrders.Count >= 7)
			{
				player.ShowToast(GameTip.Styles.Error, TooManySellOrders, true);
				return;
			}
			int num = msg.read.Int32();
			int num2 = msg.read.Int32();
			int num3 = msg.read.Int32();
			int num4 = msg.read.Int32();
			byte b = msg.read.UInt8();
			AddSellOrder(num, num2, num3, num4, b);
			Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, num, num2, b == 2 || b == 3, num3, num4, b == 1 || b == 3, added: true);
		}
	}

	public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Expected O, but got Unknown
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);
		if (!((Object)(object)itemDefinition == (Object)null) && !((Object)(object)itemDefinition2 == (Object)null))
		{
			currencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);
			itemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);
			SellOrder val = new SellOrder();
			val.ShouldPool = false;
			val.itemToSellID = itemToSellID;
			val.itemToSellAmount = itemToSellAmount;
			val.currencyID = currencyToUseID;
			val.currencyAmountPerItem = currencyAmount;
			val.currencyIsBP = bpState == 3 || bpState == 2;
			val.itemToSellIsBP = bpState == 3 || bpState == 1;
			Interface.CallHook("OnAddVendingOffer", (object)this, (object)val);
			sellOrders.sellOrders.Add(val);
			RefreshSellOrderStockLevel(itemDefinition);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

	public void RefreshAndSendNetworkUpdate()
	{
		RefreshSellOrderStockLevel();
		SendNetworkUpdate();
	}

	public void UpdateOrCreateSalesSheet()
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("note");
		PooledList<Item> val = Pool.Get<PooledList<Item>>();
		try
		{
			base.inventory.FindItemsByItemID((List<Item>)(object)val, itemDefinition.itemid);
			Item item = null;
			foreach (Item item4 in (List<Item>)(object)val)
			{
				if (item4.text.Length == 0)
				{
					item = item4;
					break;
				}
			}
			if (item == null)
			{
				ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition("paper");
				Item item2 = base.inventory.FindItemByItemID(itemDefinition2.itemid);
				if (item2 != null)
				{
					item = ItemManager.CreateByItemID(itemDefinition.itemid, 1, 0uL);
					if (!item.MoveToContainer(base.inventory))
					{
						item.Drop(GetDropPosition(), GetDropVelocity());
					}
					item2.UseItem();
				}
			}
			if (item == null)
			{
				return;
			}
			foreach (SellOrder sellOrder in sellOrders.sellOrders)
			{
				ItemDefinition itemDefinition3 = ItemManager.FindItemDefinition(sellOrder.itemToSellID);
				Item item3 = item;
				item3.text = item3.text + itemDefinition3.displayName.translated + "\n";
			}
			item.MarkDirty();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ClearContent()
	{
		if (!(this is NPCVendingMachine))
		{
			shopName = "A Shop";
			nameLastEditedBy = 0uL;
			SendNetworkUpdate();
			UpdateMapMarker();
		}
	}

	protected virtual bool CanShop(BasePlayer bp)
	{
		return true;
	}

	protected virtual bool CanRotate()
	{
		if (!HasAttachedStorageMonitor())
		{
			return !HasAttachedStorageAdaptor();
		}
		return false;
	}

	public bool IsBroadcasting()
	{
		return HasFlag(Flags.Reserved4);
	}

	public bool IsInventoryEmpty()
	{
		return HasFlag(Flags.Reserved1);
	}

	public bool IsVending()
	{
		return HasFlag(Flags.Reserved2);
	}

	public bool PlayerBehind(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(forward, ((Vector3)(ref val)).normalized) <= -0.7f;
	}

	public bool PlayerInfront(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(forward, ((Vector3)(ref val)).normalized) >= 0.7f;
	}

	public virtual bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerBehind(player))
		{
			return OccupiedCheck(player);
		}
		return false;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public virtual string GetTranslationToken()
	{
		return "";
	}

	public bool CanSellOrBuyItem(int itemToSellID, int currencyID)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		if (ItemManager.FindItemDefinition(currencyID).IsAllowed(CurrentEraRestriction))
		{
			return itemDefinition.IsAllowed(CurrentEraRestriction);
		}
		return false;
	}

	[ServerVar(Help = "Wipe the backend stats data on all vending machines. Slow operation.")]
	public static void ClearAllVendingHistory()
	{
		VendingMachine[] array = Object.FindObjectsByType<VendingMachine>((FindObjectsSortMode)0);
		foreach (VendingMachine vendingMachine in array)
		{
			if (!vendingMachine.isClient)
			{
				vendingMachine.ClearPurchaseHistory();
			}
		}
	}

	[ServerVar(Help = "Wipe the backend customer stats data on all vending machines. Slow operation.")]
	public static void ClearAllVendingCustomerHistory()
	{
		VendingMachine[] array = Object.FindObjectsByType<VendingMachine>((FindObjectsSortMode)0);
		foreach (VendingMachine vendingMachine in array)
		{
			if (!vendingMachine.isClient)
			{
				vendingMachine.ClearCustomerHistory();
			}
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	public void SV_RequestLongTermData(RPCMessage msg)
	{
		int seconds = 86400;
		VendingMachineLongTermStats val = Pool.Get<VendingMachineLongTermStats>();
		val.numberOfPurchases = purchaseHistory.Count;
		val.bestSalesHour = GetPeakSaleHourTimestamp(seconds);
		val.uniqueCustomers = GetUniqueCustomers();
		val.repeatCustomers = GetRepeatCustomers();
		val.bestCustomer = GetBestCustomer();
		ClientRPC(RpcTarget.NetworkGroup("CL_ReceiveLongTermData"), val);
		val.Dispose();
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	public void SV_RequestPurchaseData(RPCMessage msg)
	{
		HistoryCategory historyCategory = (HistoryCategory)msg.read.Int32();
		int minutes = msg.read.Int32();
		VendingMachinePurchaseHistoryMessage proto = GetProto(historyCategory, minutes);
		ClientRPC(RpcTarget.NetworkGroup("CL_ReceivePurchaseData"), (int)historyCategory, proto);
		proto.Dispose();
	}

	public void AddPurchaseHistory(int itemId, int amount, int priceId, int price, bool itemIsBp, bool priceIsBp)
	{
		if (purchaseHistory.Count > max_history)
		{
			purchaseHistory.RemoveAt(0);
		}
		purchaseHistory.Add(new PurchaseDetails
		{
			itemId = itemId,
			amount = amount,
			priceId = priceId,
			price = price,
			timestamp = Epoch.Current,
			itemIsBp = itemIsBp,
			priceIsBp = priceIsBp
		});
	}

	public void RegisterCustomer(ulong userId)
	{
		if (uniqueCustomers.ContainsKey(userId))
		{
			uniqueCustomers[userId]++;
		}
		else
		{
			uniqueCustomers.Add(userId, 1);
		}
	}

	public void RemovePurchaseHistory(int index)
	{
		purchaseHistory.RemoveAt(index);
	}

	public void ClearPurchaseHistory()
	{
		purchaseHistory.Clear();
	}

	public void ClearCustomerHistory()
	{
		uniqueCustomers.Clear();
	}

	private VendingMachinePurchaseHistoryMessage GetProto(HistoryCategory category, int minutes)
	{
		if (minutes == 0)
		{
			minutes = 999999;
		}
		VendingMachinePurchaseHistoryMessage val = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		switch (category)
		{
		case HistoryCategory.History:
			val.transactions = GetEntriesProto(GetRecentPurchases(minutes * 60));
			break;
		case HistoryCategory.BestSold:
			val.smallTransactions = GetEntriesProtoSmall(GetBestSoldItems(minutes * 60));
			break;
		case HistoryCategory.MostRevenue:
			val.smallTransactions = GetEntriesProtoSmall(GetMostRevenueGeneratingItems(minutes * 60));
			break;
		}
		return val;
	}

	private List<VendingMachinePurchaseHistoryEntryMessage> GetEntriesProto(List<PurchaseDetails> details)
	{
		List<VendingMachinePurchaseHistoryEntryMessage> list = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
		foreach (PurchaseDetails detail in details)
		{
			list.Add(GetEntryProto(detail));
		}
		return list;
	}

	private List<PurchaseDetails> GetListFromProto(List<VendingMachinePurchaseHistoryEntryMessage> details)
	{
		List<PurchaseDetails> list = new List<PurchaseDetails>();
		foreach (VendingMachinePurchaseHistoryEntryMessage detail in details)
		{
			list.Add(new PurchaseDetails
			{
				itemId = detail.itemID,
				amount = detail.amount,
				priceId = detail.priceID,
				price = detail.price,
				timestamp = detail.dateTime,
				itemIsBp = detail.itemIsBp,
				priceIsBp = detail.priceIsBp
			});
		}
		return list;
	}

	private List<VendingMachinePurchaseHistoryEntrySmallMessage> GetEntriesProtoSmall(List<PurchaseDetails> details)
	{
		List<VendingMachinePurchaseHistoryEntrySmallMessage> list = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
		foreach (PurchaseDetails detail in details)
		{
			list.Add(GetEntryProtoSmall(detail));
		}
		return list;
	}

	private VendingMachinePurchaseHistoryEntryMessage GetEntryProto(PurchaseDetails details)
	{
		VendingMachinePurchaseHistoryEntryMessage obj = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		obj.itemID = details.itemId;
		obj.amount = details.amount;
		obj.priceID = details.priceId;
		obj.price = details.price;
		obj.dateTime = details.timestamp;
		obj.priceIsBp = details.priceIsBp;
		obj.itemIsBp = details.itemIsBp;
		return obj;
	}

	private VendingMachinePurchaseHistoryEntrySmallMessage GetEntryProtoSmall(PurchaseDetails details)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage obj = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		obj.itemID = details.itemId;
		obj.amount = details.amount;
		obj.priceID = details.priceId;
		obj.price = details.price;
		obj.priceIsBp = details.priceIsBp;
		obj.itemIsBp = details.itemIsBp;
		return obj;
	}

	public List<PurchaseDetails> GetRecentPurchases(int seconds)
	{
		int currentTime = Epoch.Current;
		return (from p in purchaseHistory
			where currentTime - p.timestamp <= seconds
			orderby p.timestamp descending
			select p).Take(max_returned).ToList();
	}

	public List<PurchaseDetails> GetBestSoldItems(int seconds)
	{
		int currentTime = Epoch.Current;
		return (from p in (from p in purchaseHistory
				where currentTime - p.timestamp <= seconds
				orderby p.timestamp descending
				select p).Take(max_processed)
			group p by new { p.itemId, p.itemIsBp, p.priceIsBp } into @group
			select new PurchaseDetails
			{
				itemId = @group.Key.itemId,
				amount = @group.Sum((PurchaseDetails p) => p.amount),
				priceId = 0,
				price = 0,
				timestamp = 0,
				itemIsBp = @group.Key.itemIsBp,
				priceIsBp = @group.Key.priceIsBp
			} into p
			orderby p.amount descending
			select p).Take(max_returned).ToList();
	}

	public List<PurchaseDetails> GetMostRevenueGeneratingItems(int seconds)
	{
		int currentTime = Epoch.Current;
		return (from p in (from p in purchaseHistory
				where currentTime - p.timestamp <= seconds
				orderby p.timestamp descending
				select p).Take(max_processed)
			group p by new { p.itemId, p.priceId, p.itemIsBp, p.priceIsBp } into @group
			select new PurchaseDetails
			{
				itemId = @group.Key.itemId,
				amount = @group.Sum((PurchaseDetails p) => p.amount),
				priceId = @group.Key.priceId,
				price = @group.Sum((PurchaseDetails p) => p.price),
				timestamp = 0,
				itemIsBp = @group.Key.itemIsBp,
				priceIsBp = @group.Key.priceIsBp
			} into p
			orderby p.price descending
			select p).Take(max_returned).ToList();
	}

	public long GetPeakSaleHourTimestamp(int seconds)
	{
		int currentTime = Epoch.Current;
		return (from p in (from p in purchaseHistory
				where currentTime - p.timestamp <= seconds
				orderby p.timestamp descending
				select p).Take(max_processed)
			group p by p.timestamp into @group
			select new
			{
				Timestamp = @group.Key,
				TotalSales = @group.Sum((PurchaseDetails p) => p.amount)
			} into s
			orderby s.TotalSales descending
			select s).FirstOrDefault()?.Timestamp ?? (-1);
	}

	public int GetUniqueCustomers()
	{
		return uniqueCustomers.Count;
	}

	public int GetRepeatCustomers()
	{
		return uniqueCustomers.Count((KeyValuePair<ulong, int> c) => c.Value > 1);
	}

	public int GetBestCustomer()
	{
		if (uniqueCustomers.Count == 0)
		{
			return 0;
		}
		return uniqueCustomers.Values.Max();
	}
}


public static class VendingMachineFlags
{
	public const Flags EmptyInv = Flags.Reserved1;

	public const Flags IsVending = Flags.Reserved2;

	public const Flags Broadcasting = Flags.Reserved4;

	public const Flags OutOfStock = Flags.Reserved5;

	public const Flags NoDirectAccess = Flags.Reserved6;
}


private enum HistoryCategory
{
	History,
	BestSold,
	MostRevenue
}


using System;

[Serializable]
public class PurchaseDetails
{
	public int itemId;

	public int amount;

	public int priceId;

	public int price;

	public int timestamp;

	public bool itemIsBp;

	public bool priceIsBp;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Spatial;
using UnityEngine;
using UnityEngine.Assertions;

public class VineMountable : BaseMountable
{
	public struct VinePoint
	{
		public EntityRef<VineSwingingTree> TreeEntity;

		public int PointIndex;

		public VineLaunchPoint Get(bool isServer)
		{
			VineSwingingTree vineSwingingTree = TreeEntity.Get(isServer);
			if ((Object)(object)vineSwingingTree != (Object)null)
			{
				return vineSwingingTree.LaunchPoints[PointIndex];
			}
			return null;
		}

		public void Set(VineLaunchPoint launchPoint)
		{
			TreeEntity.Set(launchPoint.ParentTree);
			PointIndex = launchPoint.Index();
		}

		public VineDestination Save()
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			VineDestination obj = Pool.Get<VineDestination>();
			obj.index = PointIndex;
			obj.targetTree = TreeEntity.uid;
			return obj;
		}

		public void Load(VineDestination destination)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			PointIndex = destination.index;
			TreeEntity.uid = destination.targetTree;
		}
	}

	public float moveSpeed;

	[Header("Rotation Settings")]
	public float rotationSpeed = 0.5f;

	public float descendSpeed = 5f;

	public Vector3 WorldSpaceAnchorPoint;

	private List<VinePoint> destinations = new List<VinePoint>();

	private VinePoint origin;

	public VinePoint currentLocation;

	public const Flags Away = Flags.Reserved1;

	public const Flags Descending = Flags.Reserved2;

	public const Flags Finished = Flags.Reserved3;

	public ViewModel VineViewModel;

	public float DismountViewmodelHoldTime = 0.2f;

	public GameObjectRef VineWorldModel;

	public Transform[] VineDirectionArrows;

	public CapsuleCollider ThisCollider;

	[ServerVar]
	public static bool allowChaining = true;

	private static readonly int DescendHash = Animator.StringToHash("descend");

	private static readonly int VineDescendingHash = Animator.StringToHash("vineDescending");

	private VineLaunchPoint activeOriginPoint;

	private VineLaunchPoint activeDestinationPoint;

	private float currentTime;

	private Vector3 lastPosition;

	private bool isDescending;

	private bool wantsToSyncPos;

	private VineMountable chainTarget;

	private Vector3 lastValidLocation = Vector3.zero;

	private TimeSince lastValidLocationTime;

	private Action processMovementAction;

	private Action stopReplicatingPosCallback;

	private Action syncVineAtEndAction;

	public int DestinationCount => destinations.Count;

	public static Grid<VineMountable> pointGrid { get; private set; } = new Grid<VineMountable>(32, 8096f);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VineMountable.OnRpcMessage", 0);
		try
		{
			if (rpc == 2800581258u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_Descend "));
				}
				TimeWarning val2 = TimeWarning.New("SV_Descend", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2800581258u, "SV_Descend", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_Descend(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_Descend");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2867502127u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_Swing "));
				}
				TimeWarning val2 = TimeWarning.New("SV_Swing", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2867502127u, "SV_Swing", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SV_Swing(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SV_Swing");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static void NotifyVinesLaunchSiteRemoved(VineLaunchPoint point)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		PooledList<VineMountable> val = Pool.Get<PooledList<VineMountable>>();
		try
		{
			Vector3 position = ((Component)point).transform.position;
			pointGrid.Query(position.x, position.z, 100f, (List<VineMountable>)(object)val);
			foreach (VineMountable item in (List<VineMountable>)(object)val)
			{
				if ((Object)(object)item.origin.Get(isServer: true) == (Object)(object)point)
				{
					item.Kill();
					continue;
				}
				for (int i = 0; i < item.destinations.Count; i++)
				{
					if ((Object)(object)item.destinations[i].Get(isServer: true) == (Object)(object)point)
					{
						item.destinations.RemoveAt(i);
						if (item.HasFlag(Flags.Reserved1) && item.destinations.Count > 0)
						{
							item.Swing(null, shouldMount: false);
						}
						i--;
					}
				}
				if (item.destinations.Count == 0)
				{
					item.Kill();
				}
				else
				{
					item.SendNetworkUpdate();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		pointGrid.Add(this, ((Component)this).transform.position.x, ((Component)this).transform.position.z);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		VineLaunchPoint vineLaunchPoint = origin.Get(isServer: true);
		if ((Object)(object)vineLaunchPoint != (Object)null)
		{
			vineLaunchPoint.OnVineKilled();
		}
		pointGrid.Remove(this);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		chainTarget = null;
		if (!allowChaining || isDescending || !(currentTime > 0.5f) || !((Object)(object)activeDestinationPoint != (Object)null) || !inputState.IsDown(BUTTON.USE))
		{
			return;
		}
		PooledList<VineMountable> val = Pool.Get<PooledList<VineMountable>>();
		try
		{
			Vector3 position = ((Component)activeDestinationPoint).transform.position;
			pointGrid.Query(position.x, position.z, 5f, (List<VineMountable>)(object)val);
			foreach (VineMountable item in (List<VineMountable>)(object)val)
			{
				if (item.isServer && (Object)(object)item != (Object)(object)this && item.Distance(position) < 5f && (Object)(object)item.GetTargetDestination(((Component)this).transform.position, ((Component)this).transform.forward, out var foundAngle) != (Object)null && foundAngle < 90f)
				{
					chainTarget = item;
					break;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool AttackedByPlayer(BasePlayer bp)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (!Server.allowVineSwinging)
		{
			return false;
		}
		float num = 2f;
		if ((Object)(object)bp != (Object)null)
		{
			if (bp.Distance((BaseEntity)this) < 2f)
			{
				return false;
			}
			if (HasFlag(Flags.Reserved1))
			{
				VineLaunchPoint vineLaunchPoint = origin.Get(base.isServer);
				if ((Object)(object)vineLaunchPoint != (Object)null && bp.Distance(((Component)vineLaunchPoint).transform.position) < num)
				{
					Swing(null, shouldMount: false);
					return true;
				}
			}
			else
			{
				foreach (VinePoint destination in destinations)
				{
					VineLaunchPoint vineLaunchPoint2 = destination.Get(isServer: true);
					if ((Object)(object)vineLaunchPoint2 != (Object)null && bp.Distance(((Component)vineLaunchPoint2).transform.position) < num)
					{
						Swing(null, shouldMount: false, vineLaunchPoint2);
						return true;
					}
				}
			}
		}
		return false;
	}

	private void ProcessMovement()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0310: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03db: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		lastPosition = ((Component)this).transform.position;
		VineLaunchPoint vineLaunchPoint = activeDestinationPoint;
		VineLaunchPoint vineLaunchPoint2 = activeOriginPoint;
		if (HasFlag(Flags.Reserved3))
		{
			SetFlag(Flags.Reserved3, b: false);
		}
		currentTime = Mathf.MoveTowards(currentTime, 1f, moveSpeed * Time.deltaTime);
		float time = Mathf.SmoothStep(0f, 1f, currentTime);
		if (isDescending && (Object)(object)vineLaunchPoint2 != (Object)null)
		{
			if (GamePhysics.Trace(new Ray(((Component)this).transform.position, -Vector3.up), 0.2f, out var hitInfo, 50f, 1218519297, (QueryTriggerInteraction)0, this) && ((RaycastHit)(ref hitInfo)).distance < 1.5f && !(hitInfo.GetEntity() is VineMountable))
			{
				if (Vector3.Distance(((Component)this).transform.position, ((Component)vineLaunchPoint2).transform.position) < 2f)
				{
					((Component)this).transform.position = ((Component)vineLaunchPoint2).transform.position;
				}
				isDescending = false;
				SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
				SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
				OnArrived(null);
				if (!HasFlag(Flags.Reserved3))
				{
					SetFlag(Flags.Reserved3, b: true);
				}
				SendNetworkUpdate();
				((Component)this).transform.position = ((Component)vineLaunchPoint2).transform.position;
			}
			else
			{
				((Component)this).transform.Translate(-Vector3.up * descendSpeed * Time.deltaTime);
			}
			return;
		}
		if ((Object)(object)vineLaunchPoint == (Object)null || (Object)(object)vineLaunchPoint2 == (Object)null)
		{
			DismountAllPlayers();
			VineLaunchPoint vineLaunchPoint3 = origin.Get(isServer: true);
			if ((Object)(object)vineLaunchPoint3 != (Object)null)
			{
				OnArrived(vineLaunchPoint3);
			}
			return;
		}
		if (TimeSince.op_Implicit(lastValidLocationTime) > 0.1f)
		{
			lastValidLocation = ((Component)this).transform.position;
			lastValidLocationTime = TimeSince.op_Implicit(0f);
		}
		Vector3 swingPointAtTime = vineLaunchPoint2.GetSwingPointAtTime(time, vineLaunchPoint);
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = swingPointAtTime - position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		PooledList<RaycastHit> val2 = Pool.Get<PooledList<RaycastHit>>();
		try
		{
			float num = ThisCollider.height * 0.5f;
			Vector3 position2 = Vector3Ex.WithY(swingPointAtTime, swingPointAtTime.y - num);
			Vector3 position3 = Vector3Ex.WithY(swingPointAtTime, swingPointAtTime.y + num);
			GamePhysics.CapsuleSweep(position2, position3, ThisCollider.radius, normalized, Vector3.Distance(((Component)this).transform.position, swingPointAtTime) * 2f, (List<RaycastHit>)(object)val2, 2097152, (QueryTriggerInteraction)1);
			if (((List<RaycastHit>)(object)val2).Count > 0)
			{
				if (Vector3.Distance(lastValidLocation, ((Component)vineLaunchPoint2).transform.position) < 2f)
				{
					lastValidLocation = ((Component)vineLaunchPoint2).transform.position;
				}
				((Component)this).transform.position = lastValidLocation;
				DismountAllPlayers();
				return;
			}
			((Component)this).transform.position = swingPointAtTime;
			Vector3 val3 = swingPointAtTime - lastPosition;
			val = ((Vector3)(ref val3)).normalized;
			Quaternion val4 = ((!(((Vector3)(ref val)).sqrMagnitude > Mathf.Epsilon)) ? ((Component)this).transform.rotation : Quaternion.LookRotation(((Vector3)(ref val3)).normalized, Vector3.up));
			float num2 = Mathf.Abs((((Component)this).transform.position.y - lastPosition.y) / Time.deltaTime);
			float num3 = Mathf.Clamp01(Mathf.InverseLerp(0f, 6f, num2));
			Quaternion rotation = ((Component)this).transform.rotation;
			Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
			float num4 = Mathf.Clamp(((Quaternion)(ref val4)).eulerAngles.y, 0f - num3, num3);
			Quaternion val5 = Quaternion.Euler(eulerAngles.x, num4, eulerAngles.z);
			Quaternion rotation2 = Quaternion.Slerp(((Component)this).transform.rotation, val5 * val4, Time.deltaTime * rotationSpeed);
			((Component)this).transform.rotation = rotation2;
			if (currentTime >= 1f)
			{
				((Component)this).transform.position = vineLaunchPoint2.GetSwingPointAtTime(1f, vineLaunchPoint);
				OnArrived(vineLaunchPoint);
				if (!HasFlag(Flags.Reserved3))
				{
					SetFlag(Flags.Reserved3, b: true);
				}
				SendNetworkUpdate();
			}
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	public void Initialise(VineLaunchPoint originPoint, List<VineLaunchPoint> destinationPoints, Vector3 anchor)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		origin.Set(originPoint);
		currentLocation.Set(originPoint);
		destinations.Clear();
		foreach (VineLaunchPoint destinationPoint in destinationPoints)
		{
			VinePoint item = default(VinePoint);
			item.Set(destinationPoint);
			destinations.Add(item);
		}
		WorldSpaceAnchorPoint = anchor;
		Vector3 val = ((Component)destinationPoints[0]).transform.position - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		((Component)this).transform.rotation = Quaternion.LookRotation(normalized, Vector3.up);
		((Component)this).transform.localEulerAngles = Vector3Ex.WithX(((Component)this).transform.localEulerAngles, 0f);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.vineMountable = Pool.Get<VineMountable>();
		info.msg.vineMountable.anchorPoint = WorldSpaceAnchorPoint;
		info.msg.vineMountable.originPoint = origin.Save();
		info.msg.vineMountable.currentLocation = currentLocation.Save();
		info.msg.vineMountable.destinations = Pool.Get<List<VineDestination>>();
		foreach (VinePoint destination in destinations)
		{
			info.msg.vineMountable.destinations.Add(destination.Save());
		}
	}

	public override float AntiHackVelocity()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (activeOriginPoint.IsUnityNull() || activeDestinationPoint.IsUnityNull())
		{
			return 1f;
		}
		float num = Vector3.Distance(((Component)activeOriginPoint).transform.position, ((Component)activeDestinationPoint).transform.position);
		float num2 = ((moveSpeed > 0f) ? (1f / moveSpeed) : 1f);
		return Mathf.Clamp(num / num2, 1f, 50f);
	}

	private float GetMaxVineDistance(Vector3 origin)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		foreach (VinePoint destination in destinations)
		{
			VineLaunchPoint vineLaunchPoint = destination.Get(base.isServer);
			if ((Object)(object)vineLaunchPoint != (Object)null)
			{
				num = Mathf.Max(Vector3.Distance(((Component)vineLaunchPoint).transform.position, origin), num);
			}
		}
		if (num == 0f)
		{
			Debug.Log((object)(" there are " + destinations.Count + " destinations"));
			foreach (VinePoint destination2 in destinations)
			{
				VineLaunchPoint vineLaunchPoint2 = destination2.Get(isServer: false);
				if ((Object)(object)vineLaunchPoint2 != (Object)null)
				{
					float num2 = Vector3.Distance(((Component)vineLaunchPoint2).transform.position, origin);
					Vector3 val = ((Component)vineLaunchPoint2).transform.position;
					string? text = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
					val = origin;
					Debug.LogWarning((object)("Detected broken distance between " + text + " and origin " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString()));
					val = ((Component)this).transform.position;
					Debug.LogWarning((object)("home " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString()));
					Debug.LogWarning((object)("dist is  " + num2));
				}
			}
			return 5f;
		}
		return num;
	}

	public override void PostServerLoad()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		VineLaunchPoint vineLaunchPoint = origin.Get(base.isServer);
		if ((Object)(object)vineLaunchPoint != (Object)null)
		{
			((Component)this).transform.position = ((Component)vineLaunchPoint).transform.position;
			SetFlag(Flags.Reserved1, b: false);
		}
	}

	private void Descend(BasePlayer forPlayer)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)forPlayer == (Object)null) && !forPlayer.isMounted)
		{
			StartReplicatingPos();
			isDescending = true;
			activeOriginPoint = origin.Get(isServer: true);
			((Component)this).transform.forward = Vector3Ex.WithY(forPlayer.eyes.BodyForward(), 0f);
			currentTime = 0f;
			MountPlayer(forPlayer);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved2, b: true);
		}
	}

	private void Swing(BasePlayer forPlayer, bool shouldMount, VineLaunchPoint overridePoint = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = (((Object)(object)forPlayer != (Object)null) ? forPlayer.eyes.BodyForward() : Vector3.forward);
		Vector3 playerPos = (((Object)(object)forPlayer != (Object)null) ? ((Component)forPlayer).transform.position : ((Component)this).transform.position);
		VineLaunchPoint vineLaunchPoint = null;
		vineLaunchPoint = (HasFlag(Flags.Reserved1) ? origin.Get(base.isServer) : ((!((Object)(object)overridePoint != (Object)null)) ? GetTargetDestination(playerPos, forward, out var _) : overridePoint));
		if ((Object)(object)vineLaunchPoint == (Object)null)
		{
			Debug.Log((object)"Could not find valid vine launch destination, should not happen");
			return;
		}
		Vector3 val = ((Component)vineLaunchPoint).transform.position - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		((Component)this).transform.rotation = Quaternion.LookRotation(normalized, Vector3.up);
		activeOriginPoint = currentLocation.Get(base.isServer);
		activeDestinationPoint = vineLaunchPoint;
		if ((Object)(object)forPlayer != (Object)null)
		{
			lastPosition = ((Component)forPlayer).transform.position;
			if (shouldMount)
			{
				MountPlayer(forPlayer);
			}
		}
		lastValidLocation = ((Component)this).transform.position;
		lastValidLocationTime = TimeSince.op_Implicit(0f);
		currentTime = 0f;
		SetFlag(Flags.Reserved1, !HasFlag(Flags.Reserved1));
		currentLocation.Set(vineLaunchPoint);
		SetFlag(Flags.On, b: true);
		SetFlag(Flags.Reserved2, b: false);
		StartReplicatingPos();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void SV_Swing(RPCMessage msg)
	{
		if (!IsMounted() && Server.allowVineSwinging)
		{
			BasePlayer player = msg.player;
			bool flag = msg.read.Bool();
			if (!flag || !((Object)(object)player != (Object)null) || !player.isMounted)
			{
				Swing(player, flag);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void SV_Descend(RPCMessage msg)
	{
		if (!IsMounted() && Server.allowVineSwinging)
		{
			BasePlayer player = msg.player;
			Descend(player);
		}
	}

	private void OnArrived(VineLaunchPoint point)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.forward = -((Component)this).transform.forward;
		((Component)this).transform.localEulerAngles = Vector3Ex.WithX(((Component)this).transform.localEulerAngles, 0f);
		SetFlag(Flags.On, b: false);
		if ((Object)(object)point != (Object)null && point.FindVacantArrivalPoint(this, out var worldPos))
		{
			((Component)this).transform.position = worldPos;
		}
		DeferredStopReplicatingPos();
		BasePlayer mounted = GetMounted();
		DismountAllPlayers();
		if ((Object)(object)chainTarget != (Object)null)
		{
			chainTarget.Swing(mounted, shouldMount: true);
		}
	}

	private void StartReplicatingPos()
	{
		wantsToSyncPos = true;
		if (stopReplicatingPosCallback == null)
		{
			stopReplicatingPosCallback = StopReplcatingPos;
			ToggleNetworkPositionTick(isEnabled: true);
		}
		else if (!((FacepunchBehaviour)this).IsInvoking(stopReplicatingPosCallback))
		{
			ToggleNetworkPositionTick(isEnabled: true);
		}
	}

	private void StopReplcatingPos()
	{
		if (!wantsToSyncPos)
		{
			ToggleNetworkPositionTick(isEnabled: false);
		}
	}

	private void DeferredStopReplicatingPos()
	{
		wantsToSyncPos = false;
		((FacepunchBehaviour)this).Invoke(stopReplicatingPosCallback, 0.5f);
	}

	public void Highlight(BasePlayer forPlayer)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)origin.Get(base.isServer)).transform.position;
		foreach (VinePoint destination in destinations)
		{
			Vector3 position2 = ((Component)destination.Get(base.isServer)).transform.position;
			forPlayer.SendConsoleCommand("ddraw.arrow", "60", Color.red, position, position2, 25, 0, 0);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.vineMountable == null)
		{
			return;
		}
		WorldSpaceAnchorPoint = info.msg.vineMountable.anchorPoint;
		origin.Load(info.msg.vineMountable.originPoint);
		currentLocation.Load(info.msg.vineMountable.currentLocation);
		destinations.Clear();
		foreach (VineDestination destination in info.msg.vineMountable.destinations)
		{
			VinePoint item = default(VinePoint);
			item.Load(destination);
			destinations.Add(item);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!base.isServer)
		{
			return;
		}
		if (processMovementAction == null)
		{
			processMovementAction = ProcessMovement;
		}
		bool flag = IsOn();
		bool flag2 = ((FacepunchBehaviour)this).IsInvoking(processMovementAction);
		if (flag != flag2)
		{
			if (flag)
			{
				((FacepunchBehaviour)this).InvokeRepeating(processMovementAction, 0f, 0f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke(processMovementAction);
			}
		}
	}

	private VineLaunchPoint GetTargetDestination(Vector3 playerPos, Vector3 forward, out float foundAngle)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		VineLaunchPoint result = null;
		forward.y = 0f;
		foreach (VinePoint destination in destinations)
		{
			VineLaunchPoint vineLaunchPoint = destination.Get(base.isServer);
			if ((Object)(object)vineLaunchPoint != (Object)null)
			{
				Vector3 val = forward;
				Vector3 val2 = ((Component)vineLaunchPoint).transform.position - playerPos;
				float num2 = Vector3.Angle(val, Vector3Ex.WithY(((Vector3)(ref val2)).normalized, 0f));
				if (num2 < num)
				{
					result = vineLaunchPoint;
					num = num2;
				}
			}
		}
		foundAngle = num;
		return result;
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public struct VinePoint
{
	public EntityRef<VineSwingingTree> TreeEntity;

	public int PointIndex;

	public VineLaunchPoint Get(bool isServer)
	{
		VineSwingingTree vineSwingingTree = TreeEntity.Get(isServer);
		if ((Object)(object)vineSwingingTree != (Object)null)
		{
			return vineSwingingTree.LaunchPoints[PointIndex];
		}
		return null;
	}

	public void Set(VineLaunchPoint launchPoint)
	{
		TreeEntity.Set(launchPoint.ParentTree);
		PointIndex = launchPoint.Index();
	}

	public VineDestination Save()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		VineDestination obj = Pool.Get<VineDestination>();
		obj.index = PointIndex;
		obj.targetTree = TreeEntity.uid;
		return obj;
	}

	public void Load(VineDestination destination)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		PointIndex = destination.index;
		TreeEntity.uid = destination.targetTree;
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class WallpaperPlanner : Planner
{
	private ulong wallSkinID;

	private ulong flooringSkinID;

	private ulong ceilingSkinID;

	private WallpaperSettings.Category currentMode = WallpaperSettings.Category.Wall;

	private static WallpaperSettings _settings;

	public GameObjectRef SkinSelectPanel;

	public GameObject[] thirdPersonModels;

	public static WallpaperSettings Settings
	{
		get
		{
			if (_settings == null)
			{
				_settings = FileSystem.Load<WallpaperSettings>("Assets/Prefabs/Wallpaper/Wallpaper Settings.asset", true);
			}
			return _settings;
		}
	}

	public ItemAmount placementPrice => Settings.PlacementPrice;

	public override bool isTypeDeployable => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WallpaperPlanner.OnRpcMessage", 0);
		try
		{
			if (rpc == 4026651916u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_ChangeWallpaperToolSkin "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_ChangeWallpaperToolSkin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4026651916u, "SERVER_ChangeWallpaperToolSkin", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(4026651916u, "SERVER_ChangeWallpaperToolSkin", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(4026651916u, "SERVER_ChangeWallpaperToolSkin", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_ChangeWallpaperToolSkin(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_ChangeWallpaperToolSkin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 236604960 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_SwitchMode "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_SwitchMode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(236604960u, "SERVER_SwitchMode", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(236604960u, "SERVER_SwitchMode", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_SwitchMode(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_SwitchMode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override Deployable GetDeployable(NetworkableId entityId)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (((NetworkableId)(ref entityId)).IsValid)
		{
			BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityId) as BaseEntity;
			return Settings.GetDeployable(baseEntity as BuildingBlock);
		}
		return null;
	}

	public ulong GetSkinIDForCategory(WallpaperSettings.Category category)
	{
		return category switch
		{
			WallpaperSettings.Category.Wall => wallSkinID, 
			WallpaperSettings.Category.Floor => flooringSkinID, 
			WallpaperSettings.Category.Ceiling => ceilingSkinID, 
			_ => 0uL, 
		};
	}

	public override BaseEntity DoBuild(Construction.Target target, Construction component)
	{
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return null;
		}
		if (target.entity is BuildingBlock buildingBlock)
		{
			int side = ((!target.socket.socketName.EndsWith("1")) ? 1 : 0);
			if (!buildingBlock.CanSeeWallpaperSocket(GetOwnerPlayer(), side))
			{
				return null;
			}
			bool flag = buildingBlock.HasWallpaper(side);
			if (flag && buildingBlock.GetWallpaperSkin(side) == skinID)
			{
				float y = component.rotationAmount.y;
				int num = Mathf.RoundToInt(target.rotation.y / y) * (int)y % 360;
				int num2 = Mathf.RoundToInt(buildingBlock.GetWallpaperRotation(side) / y) * (int)y % 360;
				if (num == num2 || (num + 180) % 360 == num2)
				{
					return null;
				}
			}
			if (!flag)
			{
				PayForPlacement(ownerPlayer, component);
			}
			WallpaperSettings.Category category = Settings.GetCategory(buildingBlock, side);
			ulong skinIDForCategory = GetSkinIDForCategory(category);
			buildingBlock.SetWallpaper(skinIDForCategory, side, target.rotation.y);
			if (component.deployable.placeEffect.isValid)
			{
				Effect.server.Run(component.deployable.placeEffect.resourcePath, ((Component)buildingBlock).transform.TransformPoint(target.socket.worldPosition), ((Component)buildingBlock).transform.up);
			}
			Analytics.Azure.OnWallpaperPlaced(ownerPlayer, buildingBlock, skinID, side, reskin: false);
		}
		return null;
	}

	public override void PayForPlacement(BasePlayer player, Construction component)
	{
		if (Interface.CallHook("OnPayForPlacement", (object)player, (object)this, (object)component) == null && (!player.IsInCreativeMode || !Creative.freeBuild))
		{
			player.inventory.Take(null, placementPrice.itemid, (int)placementPrice.amount);
			player.Command("note.inv", placementPrice.itemid, (int)placementPrice.amount * -1);
		}
	}

	public override bool CanAffordToPlace(Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return false;
		}
		if (ownerPlayer.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		if ((float)ownerPlayer.inventory.GetAmount(placementPrice.itemid) < placementPrice.amount)
		{
			return false;
		}
		return true;
	}

	protected override void GetConstructionCost(ItemAmountList list, Construction component)
	{
		list.amount.Clear();
		list.itemID.Clear();
		list.itemID.Add(placementPrice.itemid);
		list.amount.Add((int)placementPrice.amount);
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	private void SERVER_ChangeWallpaperToolSkin(RPCMessage msg)
	{
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !((Object)(object)player != (Object)(object)GetOwnerPlayer()) && num2 >= 0 && num2 <= 3 && !player.AllSkinsLocked && (num == 0 || player.AllSkinsUnlocked || player.blueprints.CheckSkinOwnership(num, player.userID)))
		{
			ulong num3 = ItemDefinition.FindSkin(WallpaperSettings.GetItemDefForCategory((WallpaperSettings.Category)num2).itemid, num);
			switch ((WallpaperSettings.Category)num2)
			{
			case WallpaperSettings.Category.Wall:
				wallSkinID = num3;
				break;
			case WallpaperSettings.Category.Floor:
				flooringSkinID = num3;
				break;
			case WallpaperSettings.Category.Ceiling:
				ceilingSkinID = num3;
				break;
			}
			skinID = num3;
			SendNetworkUpdate();
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_ChangeSkin"), skinID, (int)currentMode);
		}
	}

	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void SERVER_SwitchMode(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null || (Object)(object)player != (Object)(object)GetOwnerPlayer())
		{
			return;
		}
		int num = msg.read.Int32();
		if (currentMode != (WallpaperSettings.Category)num && num >= 0 && num <= 3)
		{
			currentMode = (WallpaperSettings.Category)num;
			switch (currentMode)
			{
			case WallpaperSettings.Category.Wall:
				skinID = wallSkinID;
				break;
			case WallpaperSettings.Category.Floor:
				skinID = flooringSkinID;
				break;
			case WallpaperSettings.Category.Ceiling:
				skinID = ceilingSkinID;
				break;
			}
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_SwitchMode"), skinID, (int)currentMode);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.wallpaperTool == null)
		{
			info.msg.wallpaperTool = Pool.Get<WallpaperTool>();
			info.msg.wallpaperTool.wallSkinID = wallSkinID;
			info.msg.wallpaperTool.flooringSkinID = flooringSkinID;
			info.msg.wallpaperTool.ceilingSkinID = ceilingSkinID;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.wallpaperTool != null)
		{
			wallSkinID = info.msg.wallpaperTool.wallSkinID;
			flooringSkinID = info.msg.wallpaperTool.flooringSkinID;
			ceilingSkinID = info.msg.wallpaperTool.ceilingSkinID;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust.UI;
using UnityEngine;
using UnityEngine.Assertions;

public class WantedPoster : DecayEntity, ISignage, IUGCBrowserEntity, ILOD, IServerFileReceiver
{
	public uint imageCrc;

	public ulong playerId;

	public string playerName;

	public MeshRenderer PhotoImage;

	public RustText WantedName;

	public GameObjectRef AssignDialog;

	public const Flags HasTarget = Flags.Reserved1;

	public uiPlayerPreview.EffectMode EffectMode = uiPlayerPreview.EffectMode.Polaroid;

	public uint[] GetContentCRCs
	{
		get
		{
			if (imageCrc == 0)
			{
				return null;
			}
			return new uint[1] { imageCrc };
		}
	}

	public UGCType ContentType => UGCType.ImageJpg;

	public List<ulong> EditingHistory { get; } = new List<ulong>();

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public Vector2i TextureSize => new Vector2i(1024, 1024);

	public int TextureCount => 1;

	public NetworkableId NetworkID => net.ID;

	public FileStorage.Type FileType => FileStorage.Type.jpg;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WantedPoster.OnRpcMessage", 0);
		try
		{
			if (rpc == 2419123501u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearPlayer "));
				}
				TimeWarning val2 = TimeWarning.New("ClearPlayer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2419123501u, "ClearPlayer", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2419123501u, "ClearPlayer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ClearPlayer(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ClearPlayer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 657465493 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdatePoster "));
				}
				TimeWarning val2 = TimeWarning.New("UpdatePoster", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(657465493u, "UpdatePoster", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(657465493u, "UpdatePoster", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							UpdatePoster(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UpdatePoster");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void UpdatePoster(RPCMessage msg)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null || !CanUpdateSign(msg.player))
		{
			return;
		}
		ulong num = msg.read.UInt64();
		string text = msg.read.String(256, false);
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		playerId = num;
		playerName = text;
		SetFlag(Flags.Reserved1, b: true);
		if (array == null)
		{
			if (imageCrc != 0)
			{
				FileStorage.server.RemoveExact(imageCrc, FileType, net.ID, 0u);
			}
			imageCrc = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidJPG(array, 1024, 1024))
			{
				return;
			}
			if (imageCrc != 0)
			{
				FileStorage.server.RemoveExact(imageCrc, FileType, net.ID, 0u);
			}
			imageCrc = FileStorage.server.Store(array, FileType, net.ID);
		}
		SendNetworkUpdate();
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ClearPlayer(RPCMessage msg)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)msg.player == (Object)null) && CanUpdateSign(msg.player))
		{
			playerId = 0uL;
			playerName = string.Empty;
			SetFlag(Flags.Reserved1, b: false);
			if (imageCrc != 0)
			{
				FileStorage.server.RemoveExact(imageCrc, FileType, net.ID, 0u);
				imageCrc = 0u;
			}
			SendNetworkUpdate();
		}
	}

	public void SetTextureCRCs(uint[] crcs)
	{
		imageCrc = crcs[0];
		SendNetworkUpdate();
	}

	public void ClearContent()
	{
		imageCrc = 0u;
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.wantedPoster = Pool.Get<WantedPoster>();
		info.msg.wantedPoster.imageCrc = imageCrc;
		info.msg.wantedPoster.playerId = playerId;
		info.msg.wantedPoster.playerName = playerName;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.wantedPoster != null)
		{
			imageCrc = info.msg.wantedPoster.imageCrc;
			playerName = info.msg.wantedPoster.playerName;
			playerId = info.msg.wantedPoster.playerId;
		}
	}

	public bool CanUpdateSign(BasePlayer player)
	{
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

	public uint[] GetTextureCRCs()
	{
		return new uint[1] { imageCrc };
	}
}


using System;
using Network;
using UnityEngine;

public class WaterInflatable : BaseMountable, IPoolVehicle, INotifyTrigger
{
	private enum PaddleDirection
	{
		Forward,
		Left,
		Right,
		Back
	}

	public Transform centerOfMass;

	public float forwardPushForce = 5f;

	public float rearPushForce = 5f;

	public float rotationForce = 5f;

	public float maxSpeed = 3f;

	public float maxPaddleFrequency = 0.5f;

	public SoundDefinition paddleSfx;

	public SoundDefinition smallPlayerMovementSound;

	public SoundDefinition largePlayerMovementSound;

	public BlendedSoundLoops waterLoops;

	public float waterSoundSpeedDivisor = 1f;

	public float additiveDownhillVelocity;

	public GameObjectRef handSplashForwardEffect;

	public GameObjectRef handSplashBackEffect;

	public GameObjectRef footSplashEffect;

	public float animationLerpSpeed = 1f;

	public Transform smoothedEyePosition;

	public float smoothedEyeSpeed = 1f;

	public Buoyancy buoyancy;

	public bool driftTowardsIsland;

	public GameObjectRef mountEffect;

	[Range(0f, 1f)]
	public float handSplashOffset = 1f;

	public float velocitySplashMultiplier = 4f;

	public Vector3 modifyEyeOffset = Vector3.zero;

	[Range(0f, 1f)]
	public float inheritVelocityMultiplier;

	private TimeSince lastPaddle;

	public ParticleSystem[] movingParticleSystems;

	public float movingParticlesThreshold = 0.0005f;

	public Transform headSpaceCheckPosition;

	public float headSpaceCheckRadius = 0.4f;

	private TimeSince landFacingCheck;

	private bool isFacingLand;

	private float landPushAcceleration;

	private TimeSince inPoolCheck;

	private bool isInPool;

	private Vector3 lastPos = Vector3.zero;

	private Vector3 lastClipCheckPosition;

	private bool forceClippingCheck;

	private bool prevSleeping;

	public override bool IsSummerDlcVehicle => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WaterInflatable.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.centerOfMass = centerOfMass.localPosition;
		prevSleeping = false;
		((FacepunchBehaviour)this).InvokeRandomized((Action)LowPriorityCheck, 0f, 5f, 2.5f);
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		base.OnDeployed(parent, deployedBy, fromItem);
		if ((Object)(object)deployedBy != (Object)null)
		{
			Vector3 estimatedVelocity = deployedBy.estimatedVelocity;
			float num = Vector3.Dot(((Component)this).transform.forward, ((Vector3)(ref estimatedVelocity)).normalized);
			Vector3 val = Vector3.Lerp(Vector3.zero, estimatedVelocity, Mathf.Clamp(num, 0f, 1f));
			val *= inheritVelocityMultiplier;
			rigidBody.AddForce(val, (ForceMode)2);
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterInflatable.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			bool flag = rigidBody.IsSleeping();
			if (prevSleeping && !flag && (Object)(object)buoyancy != (Object)null)
			{
				buoyancy.Wake();
			}
			prevSleeping = flag;
			Vector3 velocity = rigidBody.velocity;
			if (((Vector3)(ref velocity)).magnitude > maxSpeed)
			{
				rigidBody.velocity = Vector3.ClampMagnitude(rigidBody.velocity, maxSpeed);
			}
			if (!AnyMounted() || !((Object)(object)headSpaceCheckPosition != (Object)null))
			{
				return;
			}
			Vector3 position = ((Component)this).transform.position;
			if (!forceClippingCheck && !(Vector3.Distance(position, lastClipCheckPosition) > headSpaceCheckRadius * 0.5f))
			{
				return;
			}
			forceClippingCheck = false;
			if (GamePhysics.CheckSphere(headSpaceCheckPosition.position, headSpaceCheckRadius, 1218511105, (QueryTriggerInteraction)1))
			{
				if (!GetDismountPosition(GetMounted(), out var _))
				{
					((Component)this).transform.position = lastClipCheckPosition;
				}
				DismountAllPlayers();
			}
			lastClipCheckPosition = position;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void LowPriorityCheck()
	{
		buoyancy.LowPriorityCheck(AnyMounted());
	}

	public override void OnPlayerMounted()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.OnPlayerMounted();
		lastPos = ((Component)this).transform.position;
		forceClippingCheck = true;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		if (Vector3.Dot(((Component)this).transform.up, Vector3.up) < 0.1f)
		{
			DismountAllPlayers();
		}
		else
		{
			if (TimeSince.op_Implicit(lastPaddle) < maxPaddleFrequency || ((Object)(object)buoyancy != (Object)null && IsOutOfWaterServer()))
			{
				return;
			}
			if ((Object)(object)player.GetHeldEntity() == (Object)null)
			{
				if (inputState.IsDown(BUTTON.FORWARD))
				{
					Vector3 velocity = rigidBody.velocity;
					if (((Vector3)(ref velocity)).magnitude < maxSpeed)
					{
						rigidBody.AddForce(((Component)this).transform.forward * forwardPushForce, (ForceMode)1);
					}
					rigidBody.angularVelocity = Vector3.Lerp(rigidBody.angularVelocity, ((Component)this).transform.forward, 0.5f);
					lastPaddle = TimeSince.op_Implicit(0f);
					ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), 0);
				}
				if (inputState.IsDown(BUTTON.BACKWARD))
				{
					rigidBody.AddForce(-((Component)this).transform.forward * rearPushForce, (ForceMode)1);
					rigidBody.angularVelocity = Vector3.Lerp(rigidBody.angularVelocity, -((Component)this).transform.forward, 0.5f);
					lastPaddle = TimeSince.op_Implicit(0f);
					ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), 3);
				}
				if (inputState.IsDown(BUTTON.LEFT))
				{
					PaddleTurn(PaddleDirection.Left);
				}
				if (inputState.IsDown(BUTTON.RIGHT))
				{
					PaddleTurn(PaddleDirection.Right);
				}
			}
			if (TimeSince.op_Implicit(inPoolCheck) > 2f)
			{
				isInPool = IsInWaterVolume(((Component)this).transform.position, out var natural) && !natural;
				inPoolCheck = TimeSince.op_Implicit(0f);
			}
			if (additiveDownhillVelocity > 0f && !isInPool)
			{
				Vector3 val = ((Component)this).transform.TransformPoint(Vector3.forward);
				Vector3 position = ((Component)this).transform.position;
				if (val.y + 0.05f < position.y)
				{
					float num = additiveDownhillVelocity * (position.y - val.y);
					rigidBody.AddForce(num * Time.fixedDeltaTime * ((Component)this).transform.forward, (ForceMode)5);
				}
				Vector3 velocity2 = rigidBody.velocity;
				rigidBody.velocity = Vector3.Lerp(velocity2, ((Component)this).transform.forward * ((Vector3)(ref velocity2)).magnitude, 0.4f);
			}
			if (driftTowardsIsland && TimeSince.op_Implicit(landFacingCheck) > 2f && !isInPool)
			{
				isFacingLand = false;
				landFacingCheck = TimeSince.op_Implicit(0f);
				Vector3 position2 = ((Component)this).transform.position;
				if (!WaterResource.IsFreshWater(position2))
				{
					int num2 = 5;
					Vector3 forward = ((Component)this).transform.forward;
					forward.y = 0f;
					for (int i = 1; i <= num2; i++)
					{
						int mask = 128;
						if (!TerrainMeta.TopologyMap.GetTopology(position2 + (float)i * 15f * forward, mask))
						{
							isFacingLand = true;
							break;
						}
					}
				}
			}
			if (driftTowardsIsland && isFacingLand && !isInPool)
			{
				landPushAcceleration = Mathf.Clamp(landPushAcceleration + Time.deltaTime, 0f, 3f);
				rigidBody.AddForce(((Component)this).transform.forward * (Time.deltaTime * landPushAcceleration), (ForceMode)2);
			}
			else
			{
				landPushAcceleration = 0f;
			}
			lastPos = ((Component)this).transform.position;
		}
	}

	private void PaddleTurn(PaddleDirection direction)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (direction != 0 && direction != PaddleDirection.Back)
		{
			rigidBody.AddRelativeTorque(rotationForce * ((direction == PaddleDirection.Left) ? (-Vector3.up) : Vector3.up), (ForceMode)1);
			lastPaddle = TimeSince.op_Implicit(0f);
			ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), (int)direction);
		}
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		info = default(WaterLevel.WaterInfo);
		return 0f;
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (hitEntity is BaseVehicle baseVehicle && (baseVehicle.HasDriver() || baseVehicle.IsMoving() || baseVehicle.HasFlag(Flags.On)))
		{
			Kill(DestroyMode.Gib);
		}
	}

	private bool IsOutOfWaterServer()
	{
		return buoyancy.timeOutOfWater > 0.2f;
	}

	public void OnPoolDestroyed()
	{
		Kill(DestroyMode.Gib);
	}

	public void WakeUp()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
			rigidBody.AddForce(Vector3.up * 0.1f, (ForceMode)1);
		}
		if ((Object)(object)buoyancy != (Object)null)
		{
			buoyancy.Wake();
		}
	}

	public void OnObjects(TriggerNotify trigger)
	{
		if (base.isClient)
		{
			return;
		}
		foreach (BaseEntity entityContent in trigger.entityContents)
		{
			if (entityContent is BaseVehicle baseVehicle && (baseVehicle.HasDriver() || baseVehicle.IsMoving() || baseVehicle.HasFlag(Flags.On)))
			{
				Kill(DestroyMode.Gib);
				break;
			}
		}
	}

	public void OnEmpty()
	{
	}
}


private enum PaddleDirection
{
	Forward,
	Left,
	Right,
	Back
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class WaterWell : LiquidContainer
{
	public Animator animator;

	private const Flags Pumping = Flags.Reserved2;

	private const Flags WaterFlow = Flags.Reserved3;

	public float caloriesPerPump = 5f;

	public float pressurePerPump = 0.2f;

	public float pressureForProduction = 1f;

	public float currentPressure;

	public int waterPerPump = 50;

	public GameObject waterLevelObj;

	public float waterLevelObjFullOffset;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WaterWell.OnRpcMessage", 0);
		try
		{
			if (rpc == 2538739344u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Pump "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Pump", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2538739344u, "RPC_Pump", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Pump(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Pump");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Reserved2, b: false);
		SetFlag(Flags.Reserved3, b: false);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_Pump(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !player.IsDead() && !player.IsSleeping() && !(player.metabolism.calories.value < caloriesPerPump) && !HasFlag(Flags.Reserved2))
		{
			SetFlag(Flags.Reserved2, b: true);
			player.metabolism.calories.value -= caloriesPerPump;
			player.metabolism.SendChangesToClient();
			currentPressure = Mathf.Clamp01(currentPressure + pressurePerPump);
			((FacepunchBehaviour)this).Invoke((Action)StopPump, 1.8f);
			if (currentPressure >= 0f)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Produce);
				((FacepunchBehaviour)this).Invoke((Action)Produce, 1f);
			}
			SendNetworkUpdateImmediate();
		}
	}

	public void StopPump()
	{
		SetFlag(Flags.Reserved2, b: false);
		SendNetworkUpdateImmediate();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		SendNetworkUpdate();
	}

	public void Produce()
	{
		base.inventory.AddItem(defaultLiquid, waterPerPump, 0uL);
		SetFlag(Flags.Reserved3, b: true);
		ScheduleTapOff();
		SendNetworkUpdateImmediate();
	}

	public void ScheduleTapOff()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)TapOff);
		((FacepunchBehaviour)this).Invoke((Action)TapOff, 1f);
	}

	private void TapOff()
	{
		SetFlag(Flags.Reserved3, b: false);
	}

	public void ReducePressure()
	{
		float num = Random.Range(0.1f, 0.2f);
		currentPressure = Mathf.Clamp01(currentPressure - num);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.waterwell = Pool.Get<WaterWell>();
		info.msg.waterwell.pressure = currentPressure;
		info.msg.waterwell.waterLevel = GetWaterAmount();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.waterwell != null)
		{
			currentPressure = info.msg.waterwell.pressure;
		}
	}

	public float GetWaterAmount()
	{
		if (base.isServer)
		{
			Item slot = base.inventory.GetSlot(0);
			if (slot == null)
			{
				return 0f;
			}
			return slot.amount;
		}
		return 0f;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(SenseComponent))]
public class WeaponlessShootingComponent : EntityComponent<BaseEntity>
{
	[SerializeField]
	private float bulletSpeed = 200f;

	public Transform muzzleTransform;

	[SerializeField]
	private bool onlyDamageTargetableEntities = true;

	private const float maxRange = 300f;

	public GameObjectRef gunFireEffect;

	[SerializeField]
	private GameObjectRef bulletEffect;

	public BaseEntity LastDamagedEntity { get; private set; }

	public double? LastDamagedTime { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WeaponlessShootingComponent.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool Shoot(Vector3 origin, Vector3 location, float bulletDamage)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = location - origin;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		PooledList<RaycastHit> val2 = Pool.Get<PooledList<RaycastHit>>();
		try
		{
			GamePhysics.TraceAll(new Ray(origin, normalized), 0f, (List<RaycastHit>)(object)val2, 300f, 1220225809, (QueryTriggerInteraction)0);
			Vector3? val3 = null;
			if (((List<RaycastHit>)(object)val2).Count > 0)
			{
				RaycastHit val4 = ((List<RaycastHit>)(object)val2)[0];
				float distance = ((RaycastHit)(ref val4)).distance;
				val = location - origin;
				if (distance < ((Vector3)(ref val)).magnitude - 1f)
				{
					return false;
				}
			}
			SenseComponent senseComponent = default(SenseComponent);
			for (int i = 0; i < ((List<RaycastHit>)(object)val2).Count; i++)
			{
				RaycastHit hit = ((List<RaycastHit>)(object)val2)[i];
				BaseEntity entity = hit.GetEntity();
				if ((Object)(object)entity == (Object)null)
				{
					break;
				}
				if (!entity.isServer || entity is Shield || (Object)(object)entity == (Object)(object)base.baseEntity || entity.EqualNetID((BaseNetworkable)base.baseEntity))
				{
					continue;
				}
				if (((Object)(object)entity).Is<BaseCombatEntity>(out BaseCombatEntity castedUnityObject))
				{
					if (onlyDamageTargetableEntities && ((Component)base.baseEntity).TryGetComponent<SenseComponent>(ref senseComponent) && !senseComponent.CanTarget(castedUnityObject))
					{
						continue;
					}
					ApplyDamage(castedUnityObject, ((RaycastHit)(ref hit)).point, normalized, bulletDamage);
				}
				val3 = ((RaycastHit)(ref hit)).point;
				if (entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			Vector3 val5 = origin + normalized * 300f;
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_WeaponlessShot"), val3.HasValue ? val3.Value : val5);
			return true;
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	private void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal, float bulletDamage)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		LastDamagedEntity = entity;
		LastDamagedTime = Time.timeAsDouble;
		if (ConVar.Server.pveBulletDamageMultiplier > 0f)
		{
			HitInfo info = new HitInfo(base.baseEntity, entity, DamageType.Bullet, bulletDamage * ConVar.Server.pveBulletDamageMultiplier, point);
			entity.OnAttacked(info, ignoreShield: false);
		}
		if (((Object)(object)entity).Is<BasePlayer>(out BasePlayer _) || ((Object)(object)entity).Is<BaseNpc>(out BaseNpc _) || ((Object)(object)entity).Is<BaseNPC2>(out BaseNPC2 _))
		{
			Effect.server.ImpactEffect(new HitInfo
			{
				HitPositionWorld = point,
				HitNormalWorld = -normal,
				HitMaterial = StringPool.Get("Flesh")
			});
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class WeaponRack : StorageContainer
{
	[Serializable]
	public enum RackType
	{
		Board,
		Stand
	}

	public enum SpecialRackType
	{
		None,
		WesternDLC
	}

	[Header("Text")]
	public Phrase textLoadAmmos;

	public RackType Type;

	public float GridCellSize = 0.15f;

	public bool SetGridCellSizeFromCollision = true;

	public int Capacity = 30;

	public bool UseColliders;

	public int GridCellCountX = 10;

	public int GridCellCountY = 10;

	public BoxCollider Collision;

	public Transform Anchor;

	public Transform SmallPegPrefab;

	public Transform LargePegPrefab;

	[Header("Lights")]
	public GameObjectRef LightPrefab;

	public Transform[] LightPoints;

	public WeaponRackSlot[] gridSlots;

	private WeaponRackSlot[] gridCellSlotReferences;

	public int ForceItemRotation = -1;

	public bool CreatePegs = true;

	[Header("Custom Rack")]
	public SpecialRackType CustomRackType;

	public Transform CustomCenter;

	private static HashSet<int> usedSlots = new HashSet<int>();

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WeaponRack.OnRpcMessage", 0);
		try
		{
			if (rpc == 1682065633 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - LoadWeaponAmmo "));
				}
				TimeWarning val2 = TimeWarning.New("LoadWeaponAmmo", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						LoadWeaponAmmo(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in LoadWeaponAmmo");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 879556270 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqMountBackSlot "));
				}
				TimeWarning val2 = TimeWarning.New("ReqMountBackSlot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(879556270u, "ReqMountBackSlot", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(879556270u, "ReqMountBackSlot", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ReqMountBackSlot(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ReqMountBackSlot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2640584497u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqMountWeapon "));
				}
				TimeWarning val2 = TimeWarning.New("ReqMountWeapon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2640584497u, "ReqMountWeapon", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2640584497u, "ReqMountWeapon", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							ReqMountWeapon(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in ReqMountWeapon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2753286621u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqSwapWeapon "));
				}
				TimeWarning val2 = TimeWarning.New("ReqSwapWeapon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2753286621u, "ReqSwapWeapon", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2753286621u, "ReqSwapWeapon", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							ReqSwapWeapon(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in ReqSwapWeapon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3761066327u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqTakeAll "));
				}
				TimeWarning val2 = TimeWarning.New("ReqTakeAll", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3761066327u, "ReqTakeAll", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3761066327u, "ReqTakeAll", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							ReqTakeAll(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in ReqTakeAll");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1987971716 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqTakeWeapon "));
				}
				TimeWarning val2 = TimeWarning.New("ReqTakeWeapon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1987971716u, "ReqTakeWeapon", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1987971716u, "ReqTakeWeapon", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							ReqTakeWeapon(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in ReqTakeWeapon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3314206579u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqUnloadWeapon "));
				}
				TimeWarning val2 = TimeWarning.New("ReqUnloadWeapon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3314206579u, "ReqUnloadWeapon", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3314206579u, "ReqUnloadWeapon", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							ReqUnloadWeapon(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in ReqUnloadWeapon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		if (SetGridCellSizeFromCollision)
		{
			GridCellSize = Collision.size.x / (float)GridCellCountX;
		}
		gridSlots = new WeaponRackSlot[Capacity];
		for (int i = 0; i < gridSlots.Length; i++)
		{
			gridSlots[i] = new WeaponRackSlot();
		}
		ClearGridCellContentsRefs();
	}

	private void ClearGridCellContentsRefs()
	{
		if (gridCellSlotReferences == null)
		{
			gridCellSlotReferences = new WeaponRackSlot[GridCellCountX * GridCellCountY];
			return;
		}
		for (int i = 0; i < gridCellSlotReferences.Length; i++)
		{
			gridCellSlotReferences[i] = null;
		}
	}

	private void SetupSlot(WeaponRackSlot slot)
	{
		if (slot != null && !((Object)(object)slot.ItemDef == (Object)null))
		{
			SetGridCellContents(slot, clear: false);
		}
	}

	private void ClearSlot(WeaponRackSlot slot)
	{
		if (slot != null && slot.Used)
		{
			SetGridCellContents(slot, clear: true);
		}
	}

	public void SetGridCellContents(WeaponRackSlot slot, bool clear)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (slot == null)
		{
			return;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(slot.ItemDef);
		if ((Object)(object)forItemDef == (Object)null)
		{
			return;
		}
		Vector2Int xYForIndex = GetXYForIndex(slot.GridSlotIndex);
		Vector2Int weaponSize = GetWeaponSize(forItemDef, slot.Rotation);
		Vector2Int weaponStart = GetWeaponStart(xYForIndex, weaponSize, clamp: false);
		if (((Vector2Int)(ref weaponStart)).x < 0 || ((Vector2Int)(ref weaponStart)).y < 0 || ((Vector2Int)(ref weaponStart)).x + ((Vector2Int)(ref weaponSize)).x > GridCellCountX || ((Vector2Int)(ref weaponStart)).y + ((Vector2Int)(ref weaponSize)).y > GridCellCountY)
		{
			return;
		}
		for (int i = ((Vector2Int)(ref weaponStart)).y; i < ((Vector2Int)(ref weaponStart)).y + ((Vector2Int)(ref weaponSize)).y; i++)
		{
			for (int j = ((Vector2Int)(ref weaponStart)).x; j < ((Vector2Int)(ref weaponStart)).x + ((Vector2Int)(ref weaponSize)).x; j++)
			{
				gridCellSlotReferences[GetGridCellIndex(j, i)] = (clear ? null : slot);
			}
		}
		slot.SetUsed(!clear);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		usedSlots.Clear();
		ClearGridCellContentsRefs();
		if (info.msg.weaponRack == null)
		{
			return;
		}
		foreach (WeaponRackItem item in info.msg.weaponRack.items)
		{
			usedSlots.Add(item.inventorySlot);
			gridSlots[item.inventorySlot].InitFromProto(item);
		}
		for (int i = 0; i < Capacity; i++)
		{
			if (usedSlots.Contains(i))
			{
				SetupSlot(gridSlots[i]);
			}
			else
			{
				ClearSlot(gridSlots[i]);
			}
		}
	}

	public WeaponRackSlot GetWeaponAtIndex(int gridIndex)
	{
		if (gridIndex < 0)
		{
			return null;
		}
		if (gridIndex >= gridCellSlotReferences.Length)
		{
			return null;
		}
		return gridCellSlotReferences[gridIndex];
	}

	public Vector2Int GetXYForIndex(int index)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2Int(index % GridCellCountX, index / GridCellCountX);
	}

	private Vector2Int GetWeaponSize(WorldModelRackMountConfig config, int rotation)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		int num = ((Type == RackType.Board) ? config.XSize : config.ZSize);
		int num2 = ((Type == RackType.Board) ? config.YSize : config.XSize);
		if (rotation != 0 && Type == RackType.Board)
		{
			return new Vector2Int(num2, num);
		}
		return new Vector2Int(num, num2);
	}

	private Vector2Int GetWeaponStart(Vector2Int targetXY, Vector2Int size, bool clamp)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (Type == RackType.Board)
		{
			((Vector2Int)(ref targetXY)).x = ((Vector2Int)(ref targetXY)).x - ((Vector2Int)(ref size)).x / 2;
			((Vector2Int)(ref targetXY)).y = ((Vector2Int)(ref targetXY)).y - ((Vector2Int)(ref size)).y / 2;
		}
		if (clamp)
		{
			((Vector2Int)(ref targetXY)).x = Mathf.Max(((Vector2Int)(ref targetXY)).x, 0);
			((Vector2Int)(ref targetXY)).y = Mathf.Max(((Vector2Int)(ref targetXY)).y, 0);
		}
		return targetXY;
	}

	public bool CanAcceptWeaponType(WorldModelRackMountConfig weaponConfig)
	{
		if ((Object)(object)weaponConfig == (Object)null)
		{
			return false;
		}
		if (weaponConfig.ExcludedRackTypes.Contains(Type))
		{
			return false;
		}
		if (CustomRackType != 0 && weaponConfig.FindCustomRackPosition(CustomRackType) == null)
		{
			return false;
		}
		return true;
	}

	public int GetBestPlacementCellIndex(Vector2Int targetXY, WorldModelRackMountConfig config, int rotation, WeaponRackSlot ignoreSlot)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (Type == RackType.Stand)
		{
			((Vector2Int)(ref targetXY)).y = 0;
		}
		int gridCellIndex = GetGridCellIndex(((Vector2Int)(ref targetXY)).x, ((Vector2Int)(ref targetXY)).y);
		if (GridCellsFree(config, gridCellIndex, rotation, ignoreSlot))
		{
			return gridCellIndex;
		}
		float num = float.MaxValue;
		int result = -1;
		Vector2Int weaponSize = GetWeaponSize(config, rotation);
		Vector2Int weaponStart = GetWeaponStart(targetXY, weaponSize, clamp: true);
		Vector2Int val = default(Vector2Int);
		for (int i = ((Vector2Int)(ref weaponStart)).y; i < ((Vector2Int)(ref weaponStart)).y + ((Vector2Int)(ref weaponSize)).y + 1; i++)
		{
			if (Type == RackType.Stand && i != 0)
			{
				continue;
			}
			for (int j = ((Vector2Int)(ref weaponStart)).x; j < ((Vector2Int)(ref weaponStart)).x + ((Vector2Int)(ref weaponSize)).x + 1; j++)
			{
				gridCellIndex = GetGridCellIndex(j, i);
				if (GridCellsFree(config, gridCellIndex, rotation, ignoreSlot))
				{
					((Vector2Int)(ref val)).x = j;
					((Vector2Int)(ref val)).y = i;
					float num2 = Vector2Int.Distance(targetXY, val);
					if (!(num2 >= num))
					{
						result = gridCellIndex;
						num = num2;
					}
				}
			}
		}
		return result;
	}

	public int GetGridIndexAtPosition(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		float num = Collision.size.x - (pos.x + Collision.size.x / 2f);
		float num2 = pos.y + Collision.size.y / 2f;
		int num3 = (int)(num / GridCellSize);
		return (int)(num2 / GridCellSize) * GridCellCountX + num3;
	}

	private bool GridCellsFree(WorldModelRackMountConfig config, int gridIndex, int rotation, WeaponRackSlot ignoreGridSlot)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (gridIndex == -1)
		{
			return false;
		}
		Vector2Int xYForIndex = GetXYForIndex(gridIndex);
		Vector2Int weaponSize = GetWeaponSize(config, rotation);
		Vector2Int weaponStart = GetWeaponStart(xYForIndex, weaponSize, clamp: false);
		if (((Vector2Int)(ref weaponStart)).x < 0 || ((Vector2Int)(ref weaponStart)).y < 0)
		{
			return false;
		}
		for (int i = ((Vector2Int)(ref weaponStart)).y; i < ((Vector2Int)(ref weaponStart)).y + ((Vector2Int)(ref weaponSize)).y; i++)
		{
			for (int j = ((Vector2Int)(ref weaponStart)).x; j < ((Vector2Int)(ref weaponStart)).x + ((Vector2Int)(ref weaponSize)).x; j++)
			{
				int gridCellIndex = GetGridCellIndex(j, i);
				if (gridCellIndex == -1 || !GridCellFree(gridCellIndex, ignoreGridSlot))
				{
					return false;
				}
			}
		}
		return true;
	}

	private int GetGridCellIndex(int x, int y)
	{
		if (x < 0 || x >= GridCellCountX || y < 0 || y >= GridCellCountY)
		{
			return -1;
		}
		return y * GridCellCountX + x;
	}

	private bool GridCellFree(int index, WeaponRackSlot ignoreSlot)
	{
		if (gridCellSlotReferences[index] != null)
		{
			if (ignoreSlot != null)
			{
				return gridCellSlotReferences[index] == ignoreSlot;
			}
			return false;
		}
		return true;
	}

	private static bool ItemIsRackMountable(Item item)
	{
		return (Object)(object)WorldModelRackMountConfig.GetForItemDef(item.info) != (Object)null;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(InventoryItemFilter));
		SpawnLightSubEntities();
	}

	private void SpawnLightSubEntities()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoadingSave || LightPrefab == null || LightPoints == null)
		{
			return;
		}
		Transform[] lightPoints = LightPoints;
		foreach (Transform val in lightPoints)
		{
			SimpleLight simpleLight = GameManager.server.CreateEntity(LightPrefab.resourcePath, val.position, val.rotation) as SimpleLight;
			if (Object.op_Implicit((Object)(object)simpleLight))
			{
				simpleLight.enableSaving = true;
				simpleLight.SetParent(this, worldPositionStays: true);
				simpleLight.Spawn();
			}
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		bool flag = false;
		if (!added)
		{
			WeaponRackSlot[] array = gridSlots;
			foreach (WeaponRackSlot weaponRackSlot in array)
			{
				if (weaponRackSlot != null && weaponRackSlot.Used)
				{
					ItemDefinition itemDef = weaponRackSlot.ItemDef;
					if ((Object)(object)itemDef == (Object)null || !itemDef.IsAllowed((EraRestriction)0))
					{
						ClearSlot(weaponRackSlot);
						flag = true;
					}
				}
			}
		}
		if (flag)
		{
			SendNetworkUpdateImmediate();
		}
	}

	private bool InventoryItemFilter(Item item, int targetSlot)
	{
		if (item == null)
		{
			return false;
		}
		return ItemIsRackMountable(item);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.weaponRack = Pool.Get<WeaponRack>();
		info.msg.weaponRack.items = Pool.Get<List<WeaponRackItem>>();
		WeaponRackSlot[] array = gridSlots;
		foreach (WeaponRackSlot weaponRackSlot in array)
		{
			if (weaponRackSlot.Used)
			{
				Item slot = base.inventory.GetSlot(weaponRackSlot.InventoryIndex);
				WeaponRackItem proto = Pool.Get<WeaponRackItem>();
				info.msg.weaponRack.items.Add(weaponRackSlot.SaveToProto(slot, proto));
			}
		}
	}

	[RPC_Server.MaxDistance(2f)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ReqSwapWeapon(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (num != -1)
		{
			int rotation = msg.read.Int32();
			Item item = msg.player.GetHeldEntity()?.GetItem();
			if (item != null)
			{
				SwapPlayerWeapon(msg.player, num, item.position, rotation);
			}
		}
	}

	private void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Item item = player.GetHeldEntity()?.GetItem();
		if (item == null)
		{
			return;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if ((Object)(object)forItemDef == (Object)null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);
		if (weaponAtIndex != null)
		{
			int mountSlotIndex = gridCellIndex;
			if (CustomRackType != 0)
			{
				gridCellIndex = 0;
			}
			int bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);
			if (bestPlacementCellIndex != -1 && Interface.CallHook("OnRackedWeaponSwap", (object)item, (object)weaponAtIndex, (object)player, (object)this) == null)
			{
				item.RemoveFromContainer();
				GivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);
				MountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);
				ItemManager.DoRemoves();
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnRackedWeaponSwapped", (object)item, (object)weaponAtIndex, (object)player, (object)this);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(2f)]
	private void ReqTakeWeapon(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (num != -1)
		{
			GivePlayerWeapon(msg.player, num);
		}
	}

	private void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)
	{
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null)
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponTake", (object)slot, (object)player, (object)this) != null)
		{
			return;
		}
		ClearSlot(weaponAtIndex);
		bool flag = false;
		bool flag2 = true;
		if (slot.IsBackpack())
		{
			flag2 = false;
			if ((Object)(object)((Component)slot.info).GetComponent<ItemModBackpack>() != (Object)null && player.inventory.GetAnyBackpack() == null)
			{
				flag = slot.MoveToContainer(player.inventory.containerWear);
			}
		}
		if (!flag)
		{
			flag = slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex);
		}
		if (flag)
		{
			if (flag2 && ((tryHold && (Object)(object)player.GetHeldEntity() == (Object)null) || playerBeltIndex != -1))
			{
				ClientRPC(RpcTarget.Player("SetActiveBeltSlot", player), slot.position, slot.uid);
			}
			ClientRPC(RpcTarget.Player("PlayGrabSound", player), slot.info.itemid);
		}
		else if (!slot.MoveToContainer(player.inventory.containerMain))
		{
			slot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponTaken", (object)slot, (object)player, (object)this);
	}

	[RPC_Server.MaxDistance(2f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ReqTakeAll(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (num != -1)
		{
			GivePlayerAllWeapons(msg.player, num);
		}
	}

	private void GivePlayerAllWeapons(BasePlayer player, int mountSlotIndex)
	{
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex != null)
		{
			GivePlayerWeapon(player, weaponAtIndex.GridSlotIndex);
		}
		for (int num = gridSlots.Length - 1; num >= 0; num--)
		{
			WeaponRackSlot weaponRackSlot = gridSlots[num];
			if (weaponRackSlot.Used)
			{
				GivePlayerWeapon(player, weaponRackSlot.GridSlotIndex, -1, tryHold: false);
			}
		}
		ItemManager.DoRemoves();
		SendNetworkUpdateImmediate();
	}

	[RPC_Server.MaxDistance(2f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ReqUnloadWeapon(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (num != -1)
		{
			UnloadWeapon(msg.player, num);
		}
	}

	private void UnloadWeapon(BasePlayer player, int mountSlotIndex)
	{
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponUnload", (object)slot, (object)player, (object)this) != null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
			if (!((Object)(object)component == (Object)null))
			{
				ItemDefinition ammoType = component.primaryMagazine.ammoType;
				component.UnloadAmmo(slot, player);
				SetSlotAmmoDetails(weaponAtIndex, slot);
				SendNetworkUpdateImmediate();
				ClientRPC(RpcTarget.Player("PlayAmmoSound", player), ammoType.itemid, 1);
				Interface.CallHook("OnRackedWeaponUnloaded", (object)slot, (object)player, (object)this);
			}
		}
	}

	[RPC_Server.MaxDistance(2f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ReqMountWeapon(RPCMessage msg)
	{
		if (base.inventory.itemList.Count != base.inventory.capacity)
		{
			int num = msg.read.Int32();
			if (num != -1)
			{
				int rotation = msg.read.Int32();
				MountWeapon(msg.player, num, rotation);
			}
		}
	}

	private void MountWeapon(BasePlayer player, int gridCellIndex, int rotation)
	{
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		HeldEntity heldEntity = player.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			Item item = heldEntity.GetItem();
			if (item != null)
			{
				MountWeapon(item, player, gridCellIndex, rotation);
			}
		}
	}

	[RPC_Server.MaxDistance(2f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ReqMountBackSlot(RPCMessage msg)
	{
		if (base.inventory.itemList.Count != base.inventory.capacity)
		{
			int num = msg.read.Int32();
			if (num != -1)
			{
				int rotation = msg.read.Int32();
				MountBackSlot(msg.player, num, rotation);
			}
		}
	}

	private void MountBackSlot(BasePlayer player, int gridCellIndex, int rotation)
	{
		if (!((Object)(object)player == (Object)null))
		{
			Item anyBackpack = player.inventory.GetAnyBackpack();
			if (anyBackpack != null && (!((Object)(object)((Component)anyBackpack.info).GetComponent<ItemModBackpack>() != (Object)null) || anyBackpack.contents == null || anyBackpack.contents.itemList == null || anyBackpack.contents.itemList.Count <= 0))
			{
				MountWeapon(anyBackpack, player, gridCellIndex, rotation);
			}
		}
	}

	private void SetSlotItem(WeaponRackSlot slot, Item item, int gridCellIndex, int rotation)
	{
		slot.SetItem(item, base.inventory.GetSlot(item.position)?.info, gridCellIndex, rotation);
	}

	private void SetSlotAmmoDetails(WeaponRackSlot slot, Item item)
	{
		slot?.SetAmmoDetails(item);
	}

	private bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate = true)
	{
		if (item == null)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnRackedWeaponMount", (object)item, (object)player, (object)this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		int itemid = item.info.itemid;
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if ((Object)(object)forItemDef == (Object)null)
		{
			Debug.LogWarning((object)"no rackmount config");
			return false;
		}
		if (!CanAcceptWeaponType(forItemDef))
		{
			return false;
		}
		if (!GridCellsFree(forItemDef, gridCellIndex, rotation, null))
		{
			return false;
		}
		if (item.MoveToContainer(base.inventory, -1, allowStack: false) && item.position >= 0 && item.position < gridSlots.Length)
		{
			WeaponRackSlot slot = gridSlots[item.position];
			SetSlotItem(slot, item, gridCellIndex, rotation);
			SetupSlot(slot);
			if ((Object)(object)player != (Object)null)
			{
				ClientRPC(RpcTarget.Player("PlayMountSound", player), itemid);
			}
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponMounted", (object)item, (object)player, (object)this);
		return true;
	}

	private void PlayMountSound(int itemID)
	{
		ClientRPC(RpcTarget.NetworkGroup("PlayMountSound"), itemID);
	}

	[RPC_Server]
	private void LoadWeaponAmmo(RPCMessage msg)
	{
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!Object.op_Implicit((Object)(object)player))
		{
			return;
		}
		int gridIndex = msg.read.Int32();
		int num = msg.read.Int32();
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if ((Object)(object)heldEntity == (Object)null)
		{
			return;
		}
		BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
		if ((Object)(object)component == (Object)null)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if ((Object)(object)itemDefinition == (Object)null || Interface.CallHook("OnRackedWeaponLoad", (object)slot, (object)itemDefinition, (object)player, (object)this) != null)
		{
			return;
		}
		if ((Object)(object)itemDefinition == (Object)(object)SnowballGun.SnowballInventoryItem)
		{
			itemDefinition = SnowballGun.SnowballAmmoItem;
			if (!((Object)(object)itemDefinition != (Object)null))
			{
				return;
			}
			num = itemDefinition.itemid;
		}
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return;
		}
		ItemModProjectile component2 = ((Component)itemDefinition).GetComponent<ItemModProjectile>();
		if (!((Object)(object)component2 == (Object)null) && component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))
		{
			if (num != component.primaryMagazine.ammoType.itemid && component.primaryMagazine.contents > 0)
			{
				player.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));
				component.SetAmmoCount(0);
			}
			component.primaryMagazine.ammoType = itemDefinition;
			component.TryReloadMagazine(player.inventory);
			SetSlotAmmoDetails(weaponAtIndex, slot);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.Player("PlayAmmoSound", player), itemDefinition.itemid, 0);
			Interface.CallHook("OnRackedWeaponLoaded", (object)slot, (object)itemDefinition, (object)player, (object)this);
		}
	}
}


using System;

[Serializable]
public enum RackType
{
	Board,
	Stand
}


public enum SpecialRackType
{
	None,
	WesternDLC
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class WheelSwitch : IOEntity
{
	public Transform wheelObj;

	public float rotateSpeed = 90f;

	public Flags BeingRotated = Flags.Reserved1;

	public Flags RotatingLeft = Flags.Reserved2;

	public Flags RotatingRight = Flags.Reserved3;

	public float rotateProgress;

	public Animator animator;

	public float kineticEnergyPerSec = 1f;

	private BasePlayer rotatorPlayer;

	private float progressTickRate = 0.1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WheelSwitch.OnRpcMessage", 0);
		try
		{
			if (rpc == 2223603322u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BeginRotate "));
				}
				TimeWarning val2 = TimeWarning.New("BeginRotate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2223603322u, "BeginRotate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							BeginRotate(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BeginRotate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 434251040 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CancelRotate "));
				}
				TimeWarning val2 = TimeWarning.New("CancelRotate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(434251040u, "CancelRotate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							CancelRotate(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in CancelRotate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetIOState()
	{
		CancelPlayerRotation();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void BeginRotate(RPCMessage msg)
	{
		if (!IsBeingRotated())
		{
			SetFlag(BeingRotated, b: true);
			rotatorPlayer = msg.player;
			((FacepunchBehaviour)this).InvokeRepeating((Action)RotateProgress, 0f, progressTickRate);
		}
	}

	public void CancelPlayerRotation()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)RotateProgress);
		SetFlag(BeingRotated, b: false);
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOSlot.connectedTo.Get().IOInput(this, ioType, 0f, iOSlot.connectedToSlot);
			}
		}
		rotatorPlayer = null;
	}

	public void RotateProgress()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)rotatorPlayer) || rotatorPlayer.IsDead() || rotatorPlayer.IsSleeping() || Vector3Ex.Distance2D(((Component)rotatorPlayer).transform.position, ((Component)this).transform.position) > 2f)
		{
			CancelPlayerRotation();
			return;
		}
		float num = kineticEnergyPerSec * progressTickRate;
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				num = iOSlot.connectedTo.Get().IOInput(this, ioType, num, iOSlot.connectedToSlot);
			}
		}
		if (num == 0f)
		{
			SetRotateProgress(rotateProgress + 0.1f);
		}
		SendNetworkUpdate();
	}

	public void SetRotateProgress(float newValue)
	{
		float num = rotateProgress;
		rotateProgress = newValue;
		SetFlag(Flags.Reserved4, num != newValue);
		SendNetworkUpdate();
		((FacepunchBehaviour)this).CancelInvoke((Action)StoppedRotatingCheck);
		((FacepunchBehaviour)this).Invoke((Action)StoppedRotatingCheck, 0.25f);
	}

	public void StoppedRotatingCheck()
	{
		SetFlag(Flags.Reserved4, b: false);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void CancelRotate(RPCMessage msg)
	{
		CancelPlayerRotation();
	}

	public void Powered()
	{
		float inputAmount = kineticEnergyPerSec * progressTickRate;
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				inputAmount = iOSlot.connectedTo.Get().IOInput(this, ioType, inputAmount, iOSlot.connectedToSlot);
			}
		}
		SetRotateProgress(rotateProgress + 0.1f);
	}

	public override float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot = 0)
	{
		if (inputAmount < 0f)
		{
			SetRotateProgress(rotateProgress + inputAmount);
			SendNetworkUpdate();
		}
		if (inputType == IOType.Electric && slot == 1)
		{
			if (inputAmount == 0f)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Powered);
			}
			else
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)Powered, 0f, progressTickRate);
			}
		}
		return Mathf.Clamp(inputAmount - 1f, 0f, inputAmount);
	}

	public bool IsBeingRotated()
	{
		return HasFlag(BeingRotated);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.sphereEntity != null)
		{
			rotateProgress = info.msg.sphereEntity.radius;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.sphereEntity = Pool.Get<SphereEntity>();
		info.msg.sphereEntity.radius = rotateProgress;
	}
}


using System;
using System.Linq;
using ConVar;
using Network;
using Rust;
using UnityEngine;

public class WildlifeHazard : BaseCombatEntity, IReceivePlayerTickListener
{
	public const Flags Flag_IsCorpse = Flags.Reserved8;

	[ServerVar]
	public static float ClientTickRate = 0.1f;

	[ServerVar]
	public static float ReactionTimeMultiplier = 1f;

	[ServerVar]
	public static float ChanceToRepositionMultiplier = 1f;

	[ServerVar]
	public static float RepositionRadiusMultiplier = 1f;

	[ServerVar]
	public static float RepositionTimerMultiplier = 1f;

	[ServerVar]
	public static int RepositionAttempts = 5;

	[Header("Wildlife Hazard")]
	public BUTTON ReactionSaveButton;

	public float SavingReactionTime = 2f;

	public float Damage = 20f;

	public float HazardInterval = 10f;

	public DamageType DamageType = DamageType.Bite;

	public float ChanceToReposition = 0.5f;

	public float RepositionDelay = 1.25f;

	public float RepositionTimer = 2f;

	public float RepositionRadiusMin = 2f;

	public float RepositionRadiusMax = 4f;

	public Transform ClientArtRoot;

	public TriggerQTE QTETrigger;

	public TriggerBase ClientTrigger;

	public float LookSpeed = 10f;

	public float MinTurnDegrees = 45f;

	public float MinFastTurnDistance = 2f;

	public float MaxWaterDepth = 0.1f;

	public float SlitherDuration = 1f;

	public float SlitherSpeed = 2f;

	public GameObjectRef CorpsePrefab;

	public GameObjectRef BitFX;

	[Header("Wildlife Hazad Visuals")]
	public Animator Animator;

	public GameObjectRef PrefabRepositionEffect;

	public GameObjectRef PrefabReappearEffect;

	[Header("Wildlife Hazard Audio")]
	public SoundDefinition HazardTriggeredSound;

	public bool PlayAlertSounds = true;

	public SoundDefinition AlertIntervalSound;

	public SoundDefinition AttackSound;

	public float AlertSoundMinInterval = 3f;

	public float AlertSoundMaxInterval = 5f;

	public SoundDefinition RepositionDisappearSound;

	public SoundDefinition RepositionReappearSound;

	[Header("Wildlife Hazard Corpse")]
	public ResourceDispenser DeadResourceDispenser;

	public ProtectionProperties DeadProtectionProperties;

	[Tooltip("If enabled, only triggers for one player at a time")]
	public bool SingularInteraction = true;

	public float AttackRange = 1.5f;

	public float AlertToIdleCooldown = 5f;

	protected const int placementMask = 8388608;

	protected const int blockMask = 1075904769;

	protected Vector3 repositionLookAtPos;

	protected Vector3 repositionTo;

	protected int failedRepositionAttempts;

	public override bool IsNpc => true;

	public bool IsCorpse => HasFlag(Flags.Reserved8);

	public BasePlayer SingularInteractionPlayer { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WildlifeHazard.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Reserved8, b: false);
		((Behaviour)DeadResourceDispenser).enabled = false;
		failedRepositionAttempts = 0;
	}

	public virtual void TriggeredByPlayer(BasePlayer player)
	{
		if (ShouldStartHazard(player))
		{
			StartHazard(player);
		}
	}

	protected virtual bool ShouldStartHazard(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (IsCorpse)
		{
			return false;
		}
		if (!IsAlive())
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)StartReposition))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)ReAttackCheck))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)FailHazardDelayed))
		{
			return false;
		}
		if (SingularInteraction && (Object)(object)SingularInteractionPlayer != (Object)null)
		{
			return false;
		}
		if (!CanSeeTarget(((Component)player).transform))
		{
			return false;
		}
		return true;
	}

	private void StartHazard(BasePlayer player)
	{
		OnHazardStarted(player);
	}

	protected virtual void OnHazardStarted(BasePlayer player)
	{
		player.AddReceiveTickListener(this);
		if (SingularInteraction)
		{
			SingularInteractionPlayer = player;
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
		((FacepunchBehaviour)this).CancelInvoke((Action)FailHazardDelayed);
		float reactionTime = GetReactionTime(player);
		((FacepunchBehaviour)this).Invoke((Action)FailHazardDelayed, reactionTime);
		ClientRPC(RpcTarget.Player("Client_StartHazard", player), reactionTime);
	}

	protected void FailHazardDelayed()
	{
		EndHazard(SingularInteractionPlayer, success: false);
	}

	protected void EndHazard(BasePlayer player, bool success)
	{
		if (success)
		{
			OnHazardCompleted(player);
		}
		else
		{
			OnHazardFailed(player);
		}
		OnHazardEnded(player);
	}

	protected virtual void OnHazardCompleted(BasePlayer player)
	{
	}

	protected virtual void OnHazardFailed(BasePlayer player)
	{
	}

	protected virtual void OnHazardEnded(BasePlayer player)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.Player("Client_EndHazard", player));
		((FacepunchBehaviour)this).CancelInvoke((Action)FailHazardDelayed);
		((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
		if ((Object)(object)player != (Object)null)
		{
			player.RemoveReceiveTickListener(this);
		}
		SingularInteractionPlayer = null;
		if (ShouldReposition())
		{
			if (FindSuitableReposition(out var pos))
			{
				failedRepositionAttempts = 0;
				repositionTo = pos;
				repositionLookAtPos = (((Object)(object)player != (Object)null) ? ((Component)player).transform.position : (((Component)this).transform.position + Vector3.forward));
				((FacepunchBehaviour)this).Invoke((Action)StartReposition, RepositionDelay);
			}
			else
			{
				failedRepositionAttempts++;
				if (failedRepositionAttempts <= 3)
				{
					((FacepunchBehaviour)this).Invoke((Action)ReAttackCheck, HazardInterval);
				}
				else
				{
					Kill();
				}
			}
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)ReAttackCheck, HazardInterval);
		}
	}

	private bool ShouldReposition()
	{
		if (IsCorpse)
		{
			return false;
		}
		float num = ChanceToReposition * ChanceToRepositionMultiplier;
		if (num <= 0f)
		{
			return false;
		}
		if (Random.Range(0f, 1f) > num)
		{
			return false;
		}
		return true;
	}

	public virtual void StartReposition()
	{
	}

	private bool FindSuitableReposition(out Vector3 pos)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		bool flag = true;
		int num = 0;
		Vector3 val = default(Vector3);
		while (flag)
		{
			float num2 = Random.Range(RepositionRadiusMin, RepositionRadiusMax) * RepositionRadiusMultiplier;
			float num3 = Random.value * (MathF.PI * 2f);
			((Vector3)(ref val))..ctor(Mathf.Cos(num3), 0f, Mathf.Sin(num3));
			pos = ((Component)this).transform.position + val * num2;
			bool flag2 = ValidatePosition(ref pos);
			if (flag2)
			{
				return true;
			}
			flag = !flag2 && ++num < RepositionAttempts;
		}
		pos = ((Component)this).transform.position;
		return false;
	}

	private bool ValidatePosition(ref Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(pos + Vector3.up * 3f, Vector3.down, ref val, 6f, 8388608))
		{
			if (WaterLevel.GetOverallWaterDepth(((RaycastHit)(ref val)).point, waves: true, volumes: false) > MaxWaterDepth)
			{
				return false;
			}
			if (!GamePhysics.LineOfSight(((RaycastHit)(ref val)).point, ((RaycastHit)(ref val)).point + Vector3.up * 4f, 1075904769))
			{
				return false;
			}
			if (!GamePhysics.LineOfSight(((Component)this).transform.position + Vector3.up * 0.25f, ((RaycastHit)(ref val)).point + Vector3.up * 0.25f, 1075904769))
			{
				return false;
			}
			pos = ((RaycastHit)(ref val)).point;
			return true;
		}
		return false;
	}

	private void ReAttackCheck()
	{
		if (IsCorpse || QTETrigger.contents == null || QTETrigger.contents.Count == 0)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
			return;
		}
		GameObject val = QTETrigger.contents.Single();
		if (!((Object)(object)val == (Object)null))
		{
			BaseEntity baseEntity = val.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null))
			{
				TriggeredByPlayer(baseEntity as BasePlayer);
			}
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if (base.isServer)
		{
			if (IsCorpse)
			{
				OnCorpseAttacked(info);
			}
			else
			{
				OnAliveAttacked(info);
			}
		}
	}

	private void OnCorpseAttacked(HitInfo info)
	{
		ResetCorpseRemovalTime();
		if (!(info.Weapon is BaseMelee baseMelee) || baseMelee.GetGatherInfoFromIndex(ResourceDispenser.GatherType.Flesh).gatherDamage != 0f)
		{
			DeadResourceDispenser.DoGather(info);
			if (!info.DidGather)
			{
				base.OnAttacked(info);
			}
		}
	}

	private void OnAliveAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer && Object.op_Implicit((Object)(object)info.InitiatorPlayer) && !info.damageTypes.IsMeleeType())
		{
			info.InitiatorPlayer.LifeStoryShotHit(info.Weapon);
		}
	}

	public override void OnKilled()
	{
		base.OnKilled();
		if ((Object)(object)SingularInteractionPlayer != (Object)null)
		{
			SingularInteractionPlayer.RemoveReceiveTickListener(this);
		}
		CancelHazardInvokes();
	}

	public override void OnDied(HitInfo info)
	{
		if (!base.isServer)
		{
			return;
		}
		ClientRPC(RpcTarget.NetworkGroup("CL_Died"));
		((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
		((FacepunchBehaviour)this).CancelInvoke((Action)FailHazardDelayed);
		if ((Object)(object)SingularInteractionPlayer != (Object)null)
		{
			SingularInteractionPlayer.RemoveReceiveTickListener(this);
		}
		if (IsCorpse)
		{
			Kill();
			return;
		}
		if (info != null)
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((Object)(object)initiatorPlayer != (Object)null)
			{
				initiatorPlayer.LifeStoryKill(this);
			}
		}
		TurnIntoCorpse();
	}

	public void TurnIntoCorpse()
	{
		SetFlag(Flags.Reserved8, b: true);
		SetHealth(MaxHealth());
		lifestate = LifeState.Alive;
		((Behaviour)DeadResourceDispenser).enabled = true;
		baseProtection = DeadProtectionProperties;
		sendsHitNotification = false;
		ResetCorpseRemovalTime();
	}

	private void CancelHazardInvokes()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)FailHazardDelayed);
		((FacepunchBehaviour)this).CancelInvoke((Action)StartReposition);
		((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
	}

	public void ResetCorpseRemovalTime()
	{
		ResetCorpseRemovalTime(ConVar.Server.corpsedespawn);
	}

	public void ResetCorpseRemovalTime(float dur)
	{
		TimeWarning val = TimeWarning.New("ResetRemovalTime", 0);
		try
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)RemoveCorpse))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)RemoveCorpse);
			}
			((FacepunchBehaviour)this).Invoke((Action)RemoveCorpse, dur);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void RemoveCorpse()
	{
		Kill();
	}

	bool IReceivePlayerTickListener.ShouldRemoveOnPlayerDeath()
	{
		return true;
	}

	void IReceivePlayerTickListener.OnReceivePlayerTick(BasePlayer player, PlayerTick msg)
	{
		if (!((Object)(object)player == (Object)null) && !((Object)(object)player != (Object)(object)SingularInteractionPlayer) && player.serverInput.WasJustPressed(ReactionSaveButton))
		{
			EndHazard(player, success: true);
		}
	}

	public virtual float GetReactionTime(BasePlayer player)
	{
		float num = (((Object)(object)player == (Object)null || player.net == null || player.net.connection == null) ? 0f : ((float)Net.sv.GetAveragePing(player.net.connection) / 1000f));
		return SavingReactionTime * ReactionTimeMultiplier + num;
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		if (base.isServer)
		{
			ClientRPC(RpcTarget.NetworkGroup("CL_Hurt"));
		}
	}

	protected bool CanSeeTarget(Transform targetTransform)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)targetTransform == (Object)null)
		{
			return false;
		}
		if (!GamePhysics.LineOfSight(((Component)this).transform.position + Vector3.up * 0.25f, targetTransform.position + Vector3.up * 0.25f, 1075904769))
		{
			return false;
		}
		return true;
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UI;

public class WipeLaptopEntity : BaseEntity
{
	public static Phrase Phrase_Armed = new Phrase("laptop_armed", "Warhead Status: Armed");

	public static Phrase Phrase_Disarmed = new Phrase("laptop_disarmed", "Warhead Status: Disarmed");

	public static Flags ArmedFlag = Flags.Reserved1;

	public float ArmTime = 5f;

	public float DisarmTime = 5f;

	public TimeUntil TimeLeft;

	public Text MiddleText;

	private Phrase currentMiddlePhrase;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WipeLaptopEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 2017018603 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ArmLaptop "));
				}
				TimeWarning val2 = TimeWarning.New("ArmLaptop", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2017018603u, "ArmLaptop", this, player, 5f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ArmLaptop(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ArmLaptop");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2423597272u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DefuseLaptop "));
				}
				TimeWarning val2 = TimeWarning.New("DefuseLaptop", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2423597272u, "DefuseLaptop", this, player, 5f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							DefuseLaptop(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in DefuseLaptop");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		info.msg.wipeLaptop = Pool.Get<WipeLaptop>();
		info.msg.wipeLaptop.timeLeft = (int)TimeUntil.op_Implicit(TimeLeft);
		info.msg.wipeLaptop.armTime = ArmTime;
		info.msg.wipeLaptop.disarmTime = DisarmTime;
		base.Save(info);
	}

	public override void Load(LoadInfo info)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (info.msg.wipeLaptop != null)
		{
			TimeLeft = TimeUntil.op_Implicit((float)info.msg.wipeLaptop.timeLeft);
			ArmTime = info.msg.wipeLaptop.armTime;
			DisarmTime = info.msg.wipeLaptop.disarmTime;
		}
		base.Load(info);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(5f)]
	public void ArmLaptop(RPCMessage msg)
	{
		if (msg.read.Int32() == 3 && !IsArmed())
		{
			SetArmed(state: true);
		}
	}

	private void OnArmLaptopStart()
	{
	}

	[RPC_Server.IsVisible(5f)]
	[RPC_Server]
	public void DefuseLaptop(RPCMessage msg)
	{
		if (msg.read.Int32() == 3 && IsArmed())
		{
			SetArmed(state: false);
		}
	}

	private bool IsArmed()
	{
		return HasFlag(ArmedFlag);
	}

	private void SetArmed(bool state)
	{
		SetFlag(ArmedFlag, state);
	}

	public void SetTimeLeft(int seconds)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		TimeLeft = TimeUntil.op_Implicit((float)seconds);
		if (base.isServer)
		{
			SendNetworkUpdate();
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class WireTool : HeldEntity
{
	public enum WireColour
	{
		Gray,
		Red,
		Green,
		Blue,
		Yellow,
		Pink,
		Purple,
		Orange,
		White,
		LightBlue,
		Invisible,
		Count
	}

	public struct PendingPlug
	{
		public IOEntity ent;

		public bool isInput;

		public int index;
	}

	private const int maxLineNodes = 16;

	private const float industrialWallOffset = 0.04f;

	public IOEntity.IOType wireType;

	public WireColour DefaultColor;

	public float radialMenuHoldTime = 0.25f;

	public float disconnectDelay = 0.15f;

	public float clearDelay = 0.65f;

	private bool justCleared;

	public GameObjectRef plugEffect;

	public SoundDefinition clearStartSoundDef;

	public SoundDefinition clearSoundDef;

	public PendingPlug pendingPlug;

	private const float MIN_SLACK = 0f;

	private const float MAX_SLACK = 2f;

	private const float IndustrialThickness = 0.01f;

	private bool CanChangeColours
	{
		get
		{
			IOEntity.IOType iOType = wireType;
			return iOType == IOEntity.IOType.Electric || iOType == IOEntity.IOType.Fluidic || iOType == IOEntity.IOType.Industrial;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WireTool.OnRpcMessage", 0);
		try
		{
			if (rpc == 2571821359u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_MakeConnection "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_MakeConnection", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2571821359u, "RPC_MakeConnection", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2571821359u, "RPC_MakeConnection", this, player, includeMounted: false))
						{
							return true;
						}
						long position = ((Stream)(object)msg.read).Position;
						WireConnectionMessage val4 = msg.read.Proto<WireConnectionMessage>((WireConnectionMessage)null);
						try
						{
							foreach (Vector3 linePoint in val4.linePoints)
							{
								if (!RPC_Server.InputValidation.Test(linePoint))
								{
									return true;
								}
							}
							foreach (WireLineAnchorInfo lineAnchor in val4.lineAnchors)
							{
								if (!RPC_Server.InputValidation.Test(lineAnchor.position))
								{
									return true;
								}
							}
							foreach (float slackLevel in val4.slackLevels)
							{
								if (!RPC_Server.InputValidation.Test(slackLevel))
								{
									return true;
								}
							}
							((Stream)(object)msg.read).Position = position;
							if (!RPC_Server.IsActiveItem.Test(2571821359u, "RPC_MakeConnection", this, player))
							{
								return true;
							}
						}
						finally
						{
							((IDisposable)val4)?.Dispose();
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_MakeConnection(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_MakeConnection");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 986119119 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestChangeColor "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestChangeColor", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(986119119u, "RPC_RequestChangeColor", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(986119119u, "RPC_RequestChangeColor", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(986119119u, "RPC_RequestChangeColor", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_RequestChangeColor(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_RequestChangeColor");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1514179840 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestClear "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestClear", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1514179840u, "RPC_RequestClear", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1514179840u, "RPC_RequestClear", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(1514179840u, "RPC_RequestClear", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_RequestClear(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_RequestClear");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public float GetMaxWireLength(BasePlayer forPlayer)
	{
		if ((Object)(object)forPlayer == (Object)null || !forPlayer.IsInCreativeMode || !Creative.unlimitedIo)
		{
			return 30f;
		}
		return 200f;
	}

	[RPC_Server.InputValidation(new Type[] { typeof(WireConnectionMessage) })]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void RPC_MakeConnection(RPCMessage rpc)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = rpc.player;
		if (!CanPlayerUseWires(player))
		{
			return;
		}
		WireConnectionMessage val = rpc.read.Proto<WireConnectionMessage>((WireConnectionMessage)null);
		List<Vector3> linePoints = val.linePoints;
		int inputIndex = val.inputIndex;
		int outputIndex = val.outputIndex;
		IOEntity iOEntity = new EntityRef<IOEntity>(val.inputID).Get(serverside: true);
		IOEntity iOEntity2 = new EntityRef<IOEntity>(val.outputID).Get(serverside: true);
		if ((Object)(object)iOEntity == (Object)null || (Object)(object)iOEntity2 == (Object)null || !ValidateLine(linePoints, iOEntity, iOEntity2, player, outputIndex) || inputIndex >= iOEntity.inputs.Length || outputIndex >= iOEntity2.outputs.Length || (Object)(object)iOEntity.inputs[inputIndex].connectedTo.Get() != (Object)null || (Object)(object)iOEntity2.outputs[outputIndex].connectedTo.Get() != (Object)null || (iOEntity.inputs[inputIndex].rootConnectionsOnly && !iOEntity2.IsRootEntity()) || !CanModifyEntity(player, iOEntity) || !CanModifyEntity(player, iOEntity2))
		{
			return;
		}
		List<float> slackLevels = val.slackLevels;
		if (slackLevels.Count != linePoints.Count)
		{
			return;
		}
		for (int i = 0; i < slackLevels.Count; i++)
		{
			if (slackLevels[i] < 0f || slackLevels[i] > 2f)
			{
				return;
			}
		}
		IOEntity.LineAnchor[] array = new IOEntity.LineAnchor[val.lineAnchors.Count];
		if (!ValidateLineAnchors(iOEntity, val.lineAnchors, array, linePoints, player))
		{
			return;
		}
		WireColour wireColour = IntToColour(val.wireColor);
		if (Interface.CallHook("OnWireConnect", (object)player, (object)iOEntity, (object)inputIndex, (object)iOEntity2, (object)outputIndex, (object)val.linePoints, (object)slackLevels) == null)
		{
			if (wireColour == WireColour.Invisible && !player.IsInCreativeMode)
			{
				wireColour = DefaultColor;
			}
			iOEntity2.ConnectTo(iOEntity, outputIndex, inputIndex, linePoints, slackLevels, array, wireColour);
			if (wireType == IOEntity.IOType.Industrial)
			{
				iOEntity.NotifyIndustrialNetworkChanged();
				iOEntity2.NotifyIndustrialNetworkChanged();
			}
		}
	}

	private bool ValidateLineAnchors(IOEntity ioEnt, List<WireLineAnchorInfo> lineAnchors, IOEntity.LineAnchor[] receivedAnchors, List<Vector3> linePoints, BasePlayer ply)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < lineAnchors.Count; i++)
		{
			WireLineAnchorInfo val = lineAnchors[i];
			if (val.index < 0 || val.index >= linePoints.Count)
			{
				return false;
			}
			EntityRef<Door> entityRef = new EntityRef<Door>(val.parentID);
			Door door = entityRef.Get(serverside: true);
			if ((Object)(object)door == (Object)null || (Object)(object)door.model == (Object)null)
			{
				return false;
			}
			float num = 35f;
			if (Vector3.Distance(((Component)door).transform.position, ((Component)ioEnt).transform.position) > num)
			{
				return false;
			}
			if (string.IsNullOrEmpty(val.boneName) || !door.model.HasBone(val.boneName, out var bone))
			{
				return false;
			}
			Vector3 val2 = bone.TransformPoint(val.position);
			Vector3 val3 = ((Component)door).transform.InverseTransformPoint(val2);
			Bounds val4 = door.bounds;
			((Bounds)(ref val4)).Expand(0.25f);
			if (!((Bounds)(ref val4)).Contains(val3))
			{
				return false;
			}
			receivedAnchors[i].entityRef = entityRef;
			receivedAnchors[i].boneName = val.boneName;
			receivedAnchors[i].index = (int)val.index;
			receivedAnchors[i].position = val.position;
		}
		return true;
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.IsActiveItem]
	[RPC_Server]
	public void RPC_RequestClear(RPCMessage msg)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_0405: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0411: Unknown result type (might be due to invalid IL or missing references)
		//IL_041c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!CanPlayerUseWires(player))
		{
			return;
		}
		NetworkableId uid = msg.read.EntityID();
		int num = msg.read.Int32();
		bool flag = msg.read.Bit();
		bool flag2 = msg.read.Bit();
		IOEntity iOEntity = BaseNetworkable.serverEntities.Find(uid) as IOEntity;
		if ((Object)(object)iOEntity == (Object)null)
		{
			return;
		}
		WireReconnectMessage val = Pool.Get<WireReconnectMessage>();
		if (flag2)
		{
			IOEntity.IOSlot iOSlot = (flag ? iOEntity.inputs : iOEntity.outputs)[num];
			IOEntity iOEntity2 = iOSlot.connectedTo.Get();
			if ((Object)(object)iOEntity2 == (Object)null)
			{
				return;
			}
			IOEntity.IOSlot iOSlot2 = (flag ? iOEntity2.outputs : iOEntity2.inputs)[iOSlot.connectedToSlot];
			val.isInput = !flag;
			val.slotIndex = iOSlot.connectedToSlot;
			val.entityId = iOSlot.connectedTo.Get().net.ID;
			val.wireColor = (int)iOSlot.wireColour;
			val.linePoints = Pool.Get<List<Vector3>>();
			val.slackLevels = Pool.Get<List<float>>();
			val.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			IOEntity iOEntity3 = iOEntity;
			Vector3[] array = iOSlot.linePoints;
			IOEntity.IOSlot iOSlot3 = iOSlot;
			if (array == null || array.Length == 0)
			{
				iOEntity3 = iOEntity2;
				array = iOSlot2.linePoints;
				iOSlot3 = iOSlot2;
			}
			if (array == null)
			{
				array = Array.Empty<Vector3>();
			}
			bool flag3 = (Object)(object)iOEntity3 != (Object)(object)iOEntity;
			if ((Object)(object)iOEntity == (Object)(object)iOEntity3 && flag)
			{
				flag3 = true;
			}
			val.linePoints.AddRange(array);
			float[] slackLevels = iOSlot.slackLevels;
			if (slackLevels == null || slackLevels.Length == 0)
			{
				slackLevels = iOSlot2.slackLevels;
			}
			float[] array2 = slackLevels;
			foreach (float item in array2)
			{
				val.slackLevels.Add(item);
			}
			IOEntity.LineAnchor[] lineAnchors = iOSlot.lineAnchors;
			if (lineAnchors == null || lineAnchors.Length == 0)
			{
				lineAnchors = iOSlot2.lineAnchors;
			}
			if (lineAnchors != null)
			{
				IOEntity.LineAnchor[] array3 = lineAnchors;
				for (int i = 0; i < array3.Length; i++)
				{
					IOEntity.LineAnchor lineAnchor = array3[i];
					EntityRef<Door> entityRef = lineAnchor.entityRef;
					if (entityRef.Get(serverside: true).IsValid())
					{
						val.lineAnchors.Add(lineAnchor.ToInfo());
					}
				}
			}
			val.slackLevels.RemoveAt(val.slackLevels.Count - 1);
			if (flag3)
			{
				val.linePoints.Reverse();
				val.slackLevels.Reverse();
				int num2 = val.linePoints.Count - 1;
				foreach (WireLineAnchorInfo lineAnchor2 in val.lineAnchors)
				{
					lineAnchor2.index = num2 - lineAnchor2.index;
				}
			}
			if (val.lineAnchors.Count >= 0)
			{
				List<WireLineAnchorInfo> list = Pool.Get<List<WireLineAnchorInfo>>();
				foreach (WireLineAnchorInfo lineAnchor3 in val.lineAnchors)
				{
					if (lineAnchor3.index == 0L || lineAnchor3.index == val.linePoints.Count - 1)
					{
						list.Add(lineAnchor3);
					}
				}
				foreach (WireLineAnchorInfo item2 in list)
				{
					val.lineAnchors.Remove(item2);
				}
				Pool.Free<WireLineAnchorInfo>(ref list, false);
			}
			if (val.linePoints.Count >= 0)
			{
				val.linePoints.RemoveAt(0);
				val.linePoints.RemoveAt(val.linePoints.Count - 1);
			}
			if (val.slackLevels.Count >= 0)
			{
				val.slackLevels.RemoveAt(val.slackLevels.Count - 1);
			}
			for (int j = 0; j < val.linePoints.Count; j++)
			{
				Vector3 val2 = Quaternion.Euler(iOSlot3.originRotation) * val.linePoints[j];
				Vector3 value = iOSlot3.originPosition + val2;
				val.linePoints[j] = value;
			}
		}
		if (AttemptClearSlot(iOEntity, player, num, flag) && flag2)
		{
			ClientRPC(RpcTarget.Player("RPC_OnWireDisconnected", player), val);
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.IsActiveItem]
	public void RPC_RequestChangeColor(RPCMessage msg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		NetworkableId uid = msg.read.EntityID();
		IOEntity iOEntity = BaseNetworkable.serverEntities.Find(uid) as IOEntity;
		if ((Object)(object)iOEntity == (Object)null || Vector3.Distance(((Component)player).transform.position, ((Component)iOEntity).transform.position) > 5f || !CanModifyEntity(player, iOEntity))
		{
			return;
		}
		int index = msg.read.Int32();
		bool flag = msg.read.Bit();
		WireColour wireColour = IntToColour(msg.read.Int32());
		if (wireColour == WireColour.Invisible && !player.IsInCreativeMode)
		{
			return;
		}
		IOEntity.IOSlot iOSlot = (flag ? iOEntity.inputs.ElementAtOrDefault(index) : iOEntity.outputs.ElementAtOrDefault(index));
		if (iOSlot != null)
		{
			IOEntity iOEntity2 = iOSlot.connectedTo.Get();
			if (!((Object)(object)iOEntity2 == (Object)null))
			{
				IOEntity.IOSlot obj = (flag ? iOEntity2.outputs : iOEntity2.inputs)[iOSlot.connectedToSlot];
				iOSlot.wireColour = wireColour;
				iOEntity.SendNetworkUpdate();
				obj.wireColour = wireColour;
				iOEntity2.SendNetworkUpdate();
			}
		}
	}

	public static bool AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)
	{
		IOEntity iOEntity = (((Object)(object)clearEnt != (Object)null) ? ((Component)clearEnt).GetComponent<IOEntity>() : null);
		IOEntity iOEntity2 = (IOEntity)(object)(isInput ? iOEntity.inputs[clearIndex] : iOEntity.outputs[clearIndex]);
		if ((Object)(object)((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get() == (Object)null)
		{
			return false;
		}
		iOEntity2 = ((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get();
		object obj = Interface.CallHook("OnWireClear", (object)ply, (object)iOEntity, (object)clearIndex, (object)iOEntity2, (object)isInput);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)iOEntity == (Object)null)
		{
			return false;
		}
		if ((Object)(object)ply != (Object)null && !CanModifyEntity(ply, iOEntity))
		{
			return false;
		}
		return iOEntity.Disconnect(clearIndex, isInput);
	}

	public WireColour IntToColour(int i)
	{
		i %= 11;
		return (WireColour)i;
	}

	public bool ValidateLine(List<Vector3> lineList, IOEntity inputEntity, IOEntity outputEntity, BasePlayer byPlayer, int outputIndex)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)byPlayer != (Object)null && byPlayer.IsInCreativeMode && Creative.unlimitedIo)
		{
			return true;
		}
		if (lineList.Count < 2 || lineList.Count > 18)
		{
			return false;
		}
		if ((Object)(object)inputEntity == (Object)null || (Object)(object)outputEntity == (Object)null)
		{
			return false;
		}
		Vector3 val = lineList[0];
		float num = 0f;
		int count = lineList.Count;
		float maxWireLength = GetMaxWireLength(byPlayer);
		for (int i = 1; i < count; i++)
		{
			Vector3 val2 = lineList[i];
			num += Vector3.Distance(val, val2);
			if (num > maxWireLength)
			{
				return false;
			}
			val = val2;
		}
		Vector3 val3 = lineList[count - 1];
		Bounds val4 = outputEntity.bounds;
		((Bounds)(ref val4)).Expand(0.5f);
		if (!((Bounds)(ref val4)).Contains(val3))
		{
			return false;
		}
		Vector3 val5 = ((Component)outputEntity).transform.TransformPoint(lineList[0]);
		val3 = ((Component)inputEntity).transform.InverseTransformPoint(val5);
		Bounds val6 = inputEntity.bounds;
		((Bounds)(ref val6)).Expand(0.5f);
		if (!((Bounds)(ref val6)).Contains(val3))
		{
			return false;
		}
		if ((Object)(object)byPlayer == (Object)null)
		{
			return false;
		}
		Vector3 position = ((Component)outputEntity).transform.TransformPoint(lineList[lineList.Count - 1]);
		if (byPlayer.Distance(position) > 5f && byPlayer.Distance(val5) > 5f)
		{
			return false;
		}
		if (outputIndex >= 0 && outputIndex < outputEntity.outputs.Length && outputEntity.outputs[outputIndex].type == IOEntity.IOType.Industrial && !VerifyLineOfSight(lineList, ((Component)outputEntity).transform.localToWorldMatrix))
		{
			return false;
		}
		return true;
	}

	public bool VerifyLineOfSight(List<Vector3> positions, Matrix4x4 localToWorldSpace)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 worldSpaceA = ((Matrix4x4)(ref localToWorldSpace)).MultiplyPoint3x4(positions[0]);
		for (int i = 1; i < positions.Count; i++)
		{
			Vector3 val = ((Matrix4x4)(ref localToWorldSpace)).MultiplyPoint3x4(positions[i]);
			if (!VerifyLineOfSight(worldSpaceA, val))
			{
				return false;
			}
			worldSpaceA = val;
		}
		return true;
	}

	public bool VerifyLineOfSight(Vector3 worldSpaceA, Vector3 worldSpaceB)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		float maxDistance = Vector3.Distance(worldSpaceA, worldSpaceB);
		Vector3 val = worldSpaceA - worldSpaceB;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(worldSpaceB, normalized), 0.01f, list, maxDistance, 2162944, (QueryTriggerInteraction)0);
		bool result = true;
		foreach (RaycastHit item in list)
		{
			BaseEntity entity = item.GetEntity();
			if ((Object)(object)entity != (Object)null && item.IsOnLayer((Layer)8))
			{
				if (entity is VendingMachine)
				{
					result = false;
					break;
				}
			}
			else if (!((Object)(object)entity != (Object)null) || !(entity is Door))
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return result;
	}

	public bool HasPendingPlug()
	{
		if ((Object)(object)pendingPlug.ent != (Object)null)
		{
			return pendingPlug.index != -1;
		}
		return false;
	}

	public bool PendingPlugIsInput()
	{
		if ((Object)(object)pendingPlug.ent != (Object)null && pendingPlug.index != -1)
		{
			return pendingPlug.isInput;
		}
		return false;
	}

	public bool PendingPlugIsType(IOEntity.IOType type)
	{
		if ((Object)(object)pendingPlug.ent == (Object)null || pendingPlug.index == -1)
		{
			return false;
		}
		IOEntity.IOSlot[] array = (pendingPlug.isInput ? pendingPlug.ent.inputs : pendingPlug.ent.outputs);
		if (pendingPlug.index < 0 || pendingPlug.index >= array.Length)
		{
			return false;
		}
		return array[pendingPlug.index].type == type;
	}

	public bool PendingPlugIsOutput()
	{
		if ((Object)(object)pendingPlug.ent != (Object)null && pendingPlug.index != -1)
		{
			return !pendingPlug.isInput;
		}
		return false;
	}

	public bool PendingPlugIsRoot()
	{
		if ((Object)(object)pendingPlug.ent != (Object)null)
		{
			return pendingPlug.ent.IsRootEntity();
		}
		return false;
	}

	private void ResetPendingPlug()
	{
		pendingPlug.ent = null;
		pendingPlug.index = -1;
	}

	public static bool CanPlayerUseWires(BasePlayer player, bool cached = false, float cacheDuration = 1f)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanUseWires", (object)player, (object)cached, (object)cacheDuration);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)player != (Object)null && player.IsInCreativeMode && Creative.unlimitedIo)
		{
			return true;
		}
		if (!player.CanBuild(cached, cacheDuration))
		{
			return false;
		}
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(player.eyes.position, 0.1f, list, 536870912, (QueryTriggerInteraction)2);
		bool result = true;
		foreach (Collider item in list)
		{
			if (!((Component)item).gameObject.CompareTag("IgnoreWireCheck"))
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private static bool CanModifyEntity(BasePlayer player, IOEntity ent)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (ent.AllowWireConnections())
		{
			if (!player.CanBuild(((Component)ent).transform.position, ((Component)ent).transform.rotation, ent.bounds))
			{
				if (player.IsInCreativeMode)
				{
					return Creative.unlimitedIo;
				}
				return false;
			}
			return true;
		}
		return false;
	}
}


public enum WireColour
{
	Gray,
	Red,
	Green,
	Blue,
	Yellow,
	Pink,
	Purple,
	Orange,
	White,
	LightBlue,
	Invisible,
	Count
}


public struct PendingPlug
{
	public IOEntity ent;

	public bool isInput;

	public int index;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Workbench : StorageContainer
{
	public const int blueprintSlot = 0;

	public const int experimentSlot = 1;

	public bool Static;

	public int Workbenchlevel;

	public LootSpawn experimentalItems;

	public GameObjectRef experimentStartEffect;

	public GameObjectRef experimentSuccessEffect;

	public ItemDefinition experimentResource;

	public TechTreeData[] techTrees;

	public static ItemDefinition blueprintBaseDef;

	private ItemDefinition pendingBlueprint;

	private bool creatingBlueprint;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Workbench.OnRpcMessage", 0);
		try
		{
			if (rpc == 2308794761u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_BeginExperiment "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_BeginExperiment", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2308794761u, "RPC_BeginExperiment", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_BeginExperiment(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_BeginExperiment");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4127240744u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TechTreeUnlock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TechTreeUnlock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4127240744u, "RPC_TechTreeUnlock", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_TechTreeUnlock(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_TechTreeUnlock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public IEnumerable<TechTreeData> GetTechTrees()
	{
		TechTreeData[] array = techTrees;
		foreach (TechTreeData techTreeData in array)
		{
			if (techTreeData.IsAllowedInEra(Server.Era) && techTreeData.IsAllowedInGameMode(base.isServer))
			{
				yield return techTreeData;
			}
		}
	}

	public TechTreeData GetTechTreeForLevel(int level)
	{
		foreach (TechTreeData techTree in GetTechTrees())
		{
			if (techTree.techTreeLevel == level)
			{
				return techTree;
			}
		}
		return null;
	}

	public int GetScrapForExperiment()
	{
		if (Workbenchlevel == 1)
		{
			return 75;
		}
		if (Workbenchlevel == 2)
		{
			return 300;
		}
		if (Workbenchlevel == 3)
		{
			return 1000;
		}
		Debug.LogWarning((object)"GetScrapForExperiment fucked up big time.");
		return 0;
	}

	public bool IsWorking()
	{
		return HasFlag(Flags.On);
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (children.Count != 0)
		{
			pickupErrorToFormat = (format: PickupErrors.ItemHasAttachment, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_TechTreeUnlock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int id = msg.read.Int32();
		int level = msg.read.Int32();
		TechTreeData techTreeForLevel = GetTechTreeForLevel(level);
		if ((Object)(object)techTreeForLevel == (Object)null || player.currentCraftLevel <= (float)techTreeForLevel.techTreeLevel)
		{
			return;
		}
		TechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);
		if (byID == null)
		{
			Debug.Log((object)("Node for unlock not found :" + id));
		}
		else
		{
			if (!techTreeForLevel.PlayerCanUnlock(player, byID))
			{
				return;
			}
			if (byID.IsGroup())
			{
				foreach (int output in byID.outputs)
				{
					TechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);
					if (byID2 != null && (Object)(object)byID2.itemDef != (Object)null)
					{
						player.blueprints.Unlock(byID2.itemDef);
						Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, "techtree", 0, this);
					}
				}
				Debug.Log((object)("Player unlocked group :" + byID.groupName));
			}
			else if ((Object)(object)byID.itemDef != (Object)null && Interface.CallHook("OnTechTreeNodeUnlock", (object)this, (object)byID, (object)player) == null)
			{
				int tax;
				int num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);
				int itemid = ItemManager.FindItemDefinition("scrap").itemid;
				if (player.inventory.GetAmount(itemid) >= num + tax)
				{
					player.inventory.Take(null, itemid, num + tax);
					player.blueprints.Unlock(byID.itemDef);
					Interface.CallHook("OnTechTreeNodeUnlocked", (object)this, (object)byID, (object)player);
					Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, "techtree", num + tax, this);
				}
			}
		}
	}

	public static ItemDefinition GetBlueprintTemplate()
	{
		if ((Object)(object)blueprintBaseDef == (Object)null)
		{
			blueprintBaseDef = ItemManager.FindItemDefinition("blueprintbase");
		}
		return blueprintBaseDef;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null || IsWorking())
		{
			return;
		}
		PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;
		int num = Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if (Object.op_Implicit((Object)(object)itemDef.Blueprint) && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if ((Object)(object)pendingBlueprint == (Object)null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", (object)this, (object)player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			((FacepunchBehaviour)this).CancelInvoke((Action)ExperimentComplete);
			((FacepunchBehaviour)this).Invoke((Action)ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", (object)this, (object)player);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		((FacepunchBehaviour)this).CancelInvoke((Action)ExperimentComplete);
	}

	public int GetAvailableExperimentResources()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		if (experimentResourceItem == null || (Object)(object)experimentResourceItem.info != (Object)(object)experimentResource)
		{
			return 0;
		}
		return experimentResourceItem.amount;
	}

	public Item GetExperimentResourceItem()
	{
		return base.inventory.GetSlot(1);
	}

	public void ExperimentComplete()
	{
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if ((Object)(object)pendingBlueprint == (Object)null)
		{
			Debug.LogWarning((object)"Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", (object)this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && (Object)(object)pendingBlueprint != (Object)null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", (object)this);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.On, b: false);
		if (base.inventory != null)
		{
			base.inventory.SetLocked(isLocked: false);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.canAcceptItem = ItemFilter;
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if ((targetSlot == 1 && (Object)(object)item.info == (Object)(object)experimentResource) || (targetSlot == 0 && creatingBlueprint))
		{
			return true;
		}
		return false;
	}

	public static int ScrapForResearch(ItemDefinition info, int workbenchLevel, out int tax)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Invalid comparison between Unknown and I4
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Invalid comparison between Unknown and I4
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Invalid comparison between Unknown and I4
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Invalid comparison between Unknown and I4
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		if ((int)info.rarity == 1)
		{
			num = 15;
		}
		if ((int)info.rarity == 2)
		{
			num = 30;
		}
		if ((int)info.rarity == 3)
		{
			num = 60;
		}
		if ((int)info.rarity == 4 || (int)info.rarity == 0)
		{
			num = 120;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null)
		{
			BaseGameMode.ResearchCostResult scrapCostForResearch = activeGameMode.GetScrapCostForResearch(info, ResearchTable.ResearchType.TechTree);
			if (scrapCostForResearch.Scale.HasValue)
			{
				num = Mathf.RoundToInt((float)num * scrapCostForResearch.Scale.Value);
			}
			else if (scrapCostForResearch.Amount.HasValue)
			{
				num = scrapCostForResearch.Amount.Value;
			}
		}
		float taxRateForWorkbenchUnlock = Server.GetTaxRateForWorkbenchUnlock(workbenchLevel);
		tax = 0;
		if (taxRateForWorkbenchUnlock > 0f)
		{
			tax = Mathf.CeilToInt((float)num * (taxRateForWorkbenchUnlock / 100f));
		}
		return num;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class WorldItem : BaseEntity, PlayerInventory.ICanMoveFrom
{
	public static readonly Phrase OpenLootTitle = new Phrase("open_loot", "Open");

	public static readonly Phrase PickUpTitle = new Phrase("pick_up", "Pick Up");

	public static readonly Phrase HoldToPickupPhrase = new Phrase("hold_use_to_pickup", "Hold [USE] to pickup");

	[Header("WorldItem")]
	public bool allowPickup = true;

	[NonSerialized]
	public Item item;

	private float pickupStartTime;

	private bool _isInvokingSendItemUpdate;

	protected float eatSeconds = 10f;

	protected float caloriesPerSecond = 1f;

	private static readonly Phrase NotYourBackPackError = new Phrase("error.notyourbackpack", "Cannot move item: Not your backpack!");

	public override TraitFlag Traits
	{
		get
		{
			if (item != null)
			{
				return item.Traits;
			}
			return base.Traits;
		}
	}

	protected virtual bool CanBePickedUp => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WorldItem.OnRpcMessage", 0);
		try
		{
			if (rpc == 2778075470u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Pickup "));
				}
				TimeWarning val2 = TimeWarning.New("Pickup", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2778075470u, "Pickup", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Pickup(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Pickup");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2145528377 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - PickupTimer "));
				}
				TimeWarning val2 = TimeWarning.New("PickupTimer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2145528377u, "PickupTimer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							PickupTimer(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in PickupTimer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override Item GetItem()
	{
		return item;
	}

	public void InitializeItem(Item in_item)
	{
		if (item != null)
		{
			RemoveItem();
		}
		item = in_item;
		if (item != null)
		{
			item.OnDirty += OnItemDirty;
			((Object)this).name = item.info.shortname + " (world)";
			item.SetWorldEntity(this);
			OnItemDirty(item);
			if (base.isServer)
			{
				SingletonComponent<NpcFoodManager>.Instance.Add(this);
			}
		}
	}

	public void RemoveItem()
	{
		if (item != null)
		{
			if (base.isServer)
			{
				SingletonComponent<NpcFoodManager>.Instance.Remove(this);
			}
			item.OnDirty -= OnItemDirty;
			item = null;
		}
	}

	public void DestroyItem()
	{
		if (item != null)
		{
			if (base.isServer)
			{
				SingletonComponent<NpcFoodManager>.Instance.Remove(this);
			}
			item.OnDirty -= OnItemDirty;
			item.Remove();
			item = null;
		}
	}

	protected virtual void OnItemDirty(Item in_item)
	{
		Assert.IsTrue(item == in_item, "WorldItem:OnItemDirty - dirty item isn't ours!");
		if (item != null)
		{
			((Component)this).BroadcastMessage("OnItemChanged", (object)item, (SendMessageOptions)1);
		}
		DoItemNetworking();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.worldItem != null && info.msg.worldItem.item != null)
		{
			Item item = ItemManager.Load(info.msg.worldItem.item, this.item, base.isServer);
			if (item != null)
			{
				InitializeItem(item);
			}
		}
	}

	public override string ToString()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (_name == null)
		{
			if (base.isServer)
			{
				_name = string.Format("{1}[{0}] {2}", (object)(NetworkableId)(((??)net?.ID) ?? default(NetworkableId)), base.ShortPrefabName, this.IsUnityNull() ? "NULL" : ((Object)this).name);
			}
			else
			{
				_name = base.ShortPrefabName;
			}
		}
		return _name;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (item != null)
		{
			((Component)this).BroadcastMessage("OnItemChanged", (object)item, (SendMessageOptions)1);
		}
	}

	private void DoItemNetworking()
	{
		if (!_isInvokingSendItemUpdate)
		{
			_isInvokingSendItemUpdate = true;
			((FacepunchBehaviour)this).Invoke((Action)SendItemUpdate, 0.1f);
		}
	}

	private void SendItemUpdate()
	{
		_isInvokingSendItemUpdate = false;
		if (item == null)
		{
			return;
		}
		UpdateItem val = Pool.Get<UpdateItem>();
		try
		{
			val.item = item.Save(bIncludeContainer: false, bIncludeOwners: false);
			ClientRPC(RpcTarget.NetworkGroup("UpdateItem"), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && this.item != null && allowPickup && Interface.CallHook("OnItemPickup", (object)this.item, (object)msg.player, (object)this) == null && CanOpenInSafeZone(msg.player))
		{
			ItemModContainer component = ((Component)this.item.info).GetComponent<ItemModContainer>();
			if (!((Object)(object)component != (Object)null) || !component.canLootInWorld || !(component.pickupInWorldDelay > 0f) || !(Mathf.Abs(pickupStartTime + component.pickupInWorldDelay - Time.realtimeSinceStartup) > ConVar.AntiHack.rpc_timer_forgiveness))
			{
				ClientRPC(RpcTarget.NetworkGroup("PickupSound"));
				Item item = this.item;
				Analytics.Azure.OnItemPickup(msg.player, this);
				RemoveItem();
				TryApplyOwnershipOnPickup(msg.player, item);
				msg.player.GiveItem(item, GiveItemReason.PickedUp, GiveItemOptions.BackpackOverflow);
				msg.player.SignalBroadcast(Signal.Gesture, "pickup_item");
			}
		}
	}

	public virtual void TryApplyOwnershipOnPickup(BasePlayer player, Item item)
	{
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void PickupTimer(RPCMessage msg)
	{
		if (msg.player.CanInteract() && item != null && allowPickup && CanOpenInSafeZone(msg.player))
		{
			pickupStartTime = Time.realtimeSinceStartup;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (item != null)
		{
			bool forDisk = info.forDisk;
			info.msg.worldItem = Pool.Get<WorldItem>();
			info.msg.worldItem.item = item.Save(forDisk, bIncludeOwners: false);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		DestroyItem();
	}

	public override void SwitchParent(BaseEntity ent)
	{
		SetParent(ent, parentBone);
	}

	public override void Eat(BaseNpc baseNpc, float timeSpent)
	{
		if (!(eatSeconds <= 0f))
		{
			eatSeconds -= timeSpent;
			baseNpc.AddCalories(caloriesPerSecond * timeSpent);
			if (eatSeconds < 0f)
			{
				DestroyItem();
				Kill();
			}
		}
	}

	private bool CanOpenInSafeZone(BasePlayer looter)
	{
		if (item == null || !item.info.blockStealingInSafeZone)
		{
			return true;
		}
		if (!(this is DroppedItem droppedItem))
		{
			return true;
		}
		if (looter.InSafeZone() && droppedItem.DroppedBy != (ulong)looter.userID && droppedItem.DroppedBy != 0L)
		{
			return false;
		}
		return true;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (item == null || item.contents == null)
		{
			return;
		}
		ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
		if (!((Object)(object)component == (Object)null) && component.canLootInWorld)
		{
			BasePlayer player = rpc.player;
			if (Object.op_Implicit((Object)(object)player) && player.CanInteract() && CanOpenInSafeZone(player) && Interface.CallHook("CanLootEntity", (object)player, (object)this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(item.contents);
				player.inventory.loot.SendImmediate();
				player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), "generic_resizable");
				SendNetworkUpdate();
			}
		}
	}

	public PlayerInventory.CanMoveFromResponse CanMoveFrom(BasePlayer player, Item item)
	{
		if ((Object)(object)((item != null) ? ((Component)item.info).GetComponent<ItemModBackpack>() : null) == (Object)null)
		{
			return PlayerInventory.CanMoveFromResponse.Success();
		}
		return new PlayerInventory.CanMoveFromResponse(item.parentItem?.parent == player.inventory.containerWear, NotYourBackPackError);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;

public class XMasRefill : BaseEntity
{
	public GameObjectRef[] giftPrefabs;

	public List<BasePlayer> goodKids;

	public List<Stocking> stockings;

	public AudioSource bells;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("XMasRefill.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public float GiftRadius()
	{
		return XMas.spawnRange;
	}

	public int GiftsPerPlayer()
	{
		return XMas.giftsPerPlayer;
	}

	public int GiftSpawnAttempts()
	{
		return XMas.giftsPerPlayer * XMas.spawnAttempts;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!XMas.enabled)
		{
			((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 0.1f);
			return;
		}
		goodKids = ((BasePlayer.activePlayerList != null) ? new List<BasePlayer>((IEnumerable<BasePlayer>)BasePlayer.activePlayerList) : new List<BasePlayer>());
		stockings = ((Stocking.stockings != null) ? new List<Stocking>((IEnumerable<Stocking>)Stocking.stockings.Values) : new List<Stocking>());
		((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 60f);
		if (Interface.CallHook("OnXmasLootDistribute", (object)this) == null)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)DistributeLoot, 3f, 0.02f);
			((FacepunchBehaviour)this).Invoke((Action)SendBells, 0.5f);
		}
	}

	public void SendBells()
	{
		ClientRPC(RpcTarget.NetworkGroup("PlayBells"));
	}

	public void RemoveMe()
	{
		if (goodKids.Count == 0 && stockings.Count == 0)
		{
			Kill();
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 60f);
		}
	}

	public void DistributeLoot()
	{
		if (goodKids.Count > 0)
		{
			BasePlayer basePlayer = null;
			foreach (BasePlayer goodKid in goodKids)
			{
				if (!goodKid.IsSleeping() && !goodKid.IsWounded() && goodKid.IsAlive() && !goodKid.isInvisible)
				{
					basePlayer = goodKid;
					break;
				}
			}
			if (Object.op_Implicit((Object)(object)basePlayer))
			{
				DistributeGiftsForPlayer(basePlayer);
				goodKids.Remove(basePlayer);
			}
		}
		if (stockings.Count > 0)
		{
			Stocking stocking = stockings[0];
			if ((Object)(object)stocking != (Object)null)
			{
				stocking.SpawnLoot();
			}
			stockings.RemoveAt(0);
		}
	}

	protected bool DropToGround(ref Vector3 pos)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		int num = 1235288065;
		int num2 = 8454144;
		if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) && (TerrainMeta.TopologyMap.GetTopology(pos) & 0x14080) != 0)
		{
			return false;
		}
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) && Object.op_Implicit((Object)(object)TerrainMeta.Collision) && !TerrainMeta.Collision.GetIgnore(pos))
		{
			float height = TerrainMeta.HeightMap.GetHeight(pos);
			pos.y = Mathf.Max(pos.y, height);
		}
		if (!TransformUtil.GetGroundInfo(pos, out var hitOut, 80f, LayerMask.op_Implicit(num)))
		{
			return false;
		}
		if (((1 << ((Component)((RaycastHit)(ref hitOut)).transform).gameObject.layer) & num2) == 0)
		{
			return false;
		}
		pos = ((RaycastHit)(ref hitOut)).point;
		return true;
	}

	public bool DistributeGiftsForPlayer(BasePlayer player)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnXmasGiftsDistribute", (object)this, (object)player) != null)
		{
			return false;
		}
		int num = GiftsPerPlayer();
		int num2 = GiftSpawnAttempts();
		for (int i = 0; i < num2; i++)
		{
			if (num <= 0)
			{
				break;
			}
			Vector2 val = Random.insideUnitCircle * GiftRadius();
			Vector3 pos = ((Component)player).transform.position + new Vector3(val.x, 10f, val.y);
			Quaternion rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
			if (DropToGround(ref pos))
			{
				string resourcePath = giftPrefabs[Random.Range(0, giftPrefabs.Length)].resourcePath;
				BaseEntity baseEntity = GameManager.server.CreateEntity(resourcePath, pos, rot);
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					baseEntity.Spawn();
					num--;
				}
			}
		}
		return true;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ZiplineLaunchPoint : BaseEntity
{
	public Transform LineDeparturePoint;

	public LineRenderer ZiplineRenderer;

	public Collider MountCollider;

	public BoxCollider[] BuildingBlocks;

	public BoxCollider[] PointBuildingBlocks;

	public SpawnableBoundsBlocker[] SpawnableBoundsBlockers;

	public GameObjectRef MountableRef;

	public float LineSlackAmount = 2f;

	public bool RegenLine;

	public List<Vector3> ziplineTargets = new List<Vector3>();

	private List<Vector3> linePoints;

	public GameObjectRef ArrivalPointRef;

	private const float MaxZiplineLength = 185f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ZiplineLaunchPoint.OnRpcMessage", 0);
		try
		{
			if (rpc == 2256922575u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - MountPlayer "));
				}
				TimeWarning val2 = TimeWarning.New("MountPlayer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2256922575u, "MountPlayer", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2256922575u, "MountPlayer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							MountPlayer(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in MountPlayer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		ziplineTargets.Clear();
		linePoints = null;
	}

	public override void PostMapEntitySpawn()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		base.PostMapEntitySpawn();
		FindZiplineTarget(ref ziplineTargets);
		CalculateZiplinePoints(ziplineTargets, ref linePoints);
		if (ziplineTargets.Count == 0)
		{
			Kill();
			return;
		}
		Vector3 val = linePoints[0];
		List<Vector3> list = linePoints;
		if (Vector3.Distance(val, list[list.Count - 1]) > 100f && ArrivalPointRef != null && ArrivalPointRef.isValid)
		{
			GameManager obj = base.gameManager;
			string resourcePath = ArrivalPointRef.resourcePath;
			List<Vector3> list2 = linePoints;
			ZiplineArrivalPoint obj2 = obj.CreateEntity(resourcePath, list2[list2.Count - 1]) as ZiplineArrivalPoint;
			obj2.SetPositions(linePoints);
			obj2.Spawn();
		}
		UpdateBuildingBlocks();
		SendNetworkUpdate();
	}

	public void FindZiplineTarget(ref List<Vector3> foundPositions)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		foundPositions.Clear();
		Vector3 position = LineDeparturePoint.position;
		List<ZiplineTarget> list = Pool.Get<List<ZiplineTarget>>();
		GamePhysics.OverlapSphere<ZiplineTarget>(position + ((Component)this).transform.forward * 185f, 185f, list, 1084293377, (QueryTriggerInteraction)1);
		ZiplineTarget ziplineTarget = null;
		float num = float.MinValue;
		float num2 = 3f;
		foreach (ZiplineTarget item in list)
		{
			if (item.IsChainPoint)
			{
				continue;
			}
			Vector3 position2 = ((Component)item).transform.position;
			Vector3 val = Vector3Ex.WithY(position2, position.y) - position;
			float num3 = Vector3.Dot(((Vector3)(ref val)).normalized, ((Component)this).transform.forward);
			val = position - Vector3Ex.WithY(position2, position.y);
			float num4 = Vector3.Dot(((Vector3)(ref val)).normalized, ((Component)item).transform.forward);
			float num5 = Vector3.Distance(position, position2) + (position2.y - position.y);
			float num6 = num5 * num3 * num4;
			if (!(num3 > 0.2f) || !item.IsValidPosition(position) || !(position.y + num2 > position2.y) || !(num5 > 10f) || !(num6 > num))
			{
				continue;
			}
			if (CheckLineOfSight(position, position2))
			{
				num = num6;
				ziplineTarget = item;
				foundPositions.Clear();
				foundPositions.Add(((Component)ziplineTarget).transform.position);
				continue;
			}
			foreach (ZiplineTarget item2 in list)
			{
				if (!item2.IsChainPoint || !item2.IsValidChainPoint(position, position2))
				{
					continue;
				}
				Vector3 position3 = ((Component)item2).transform.position;
				val = Vector3Ex.WithY(position3, position.y) - position;
				num3 = Vector3.Dot(((Vector3)(ref val)).normalized, ((Component)this).transform.forward);
				val = position - Vector3Ex.WithY(position3, position.y);
				num4 = Vector3.Dot(((Vector3)(ref val)).normalized, ((Component)item2).transform.forward);
				num6 = num5 * num3 * num4;
				bool flag = CheckLineOfSight(position, ((Component)item2).transform.position);
				bool flag2 = CheckLineOfSight(((Component)item2).transform.position, position2);
				if (flag && flag2)
				{
					num = num6;
					ziplineTarget = item;
					foundPositions.Clear();
					foundPositions.Add(((Component)item2).transform.position);
					foundPositions.Add(((Component)ziplineTarget).transform.position);
				}
				else
				{
					if (!flag)
					{
						continue;
					}
					foreach (ZiplineTarget item3 in list)
					{
						if (!((Object)(object)item3 == (Object)(object)item2) && item3.IsValidChainPoint(item2.Target.position, item.Target.position))
						{
							bool num7 = CheckLineOfSight(((Component)item2).transform.position, ((Component)item3).transform.position);
							bool flag3 = CheckLineOfSight(((Component)item3).transform.position, ((Component)item).transform.position);
							if (num7 && flag3)
							{
								num = num6;
								ziplineTarget = item;
								foundPositions.Clear();
								foundPositions.Add(((Component)item2).transform.position);
								foundPositions.Add(((Component)item3).transform.position);
								foundPositions.Add(((Component)ziplineTarget).transform.position);
							}
						}
					}
				}
			}
		}
	}

	public bool CheckLineOfSight(Vector3 from, Vector3 to)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = CalculateLineMidPoint(from, to) - Vector3.up * 0.75f;
		if (GamePhysics.LineOfSightRadius(from, to, 1084293377, 0.5f, 2f) && GamePhysics.LineOfSightRadius(from, val, 1084293377, 0.5f, 2f))
		{
			return GamePhysics.LineOfSightRadius(val, to, 1084293377, 0.5f, 2f);
		}
		return false;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	public void MountPlayer(RPCMessage msg)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		if (IsBusy() || (Object)(object)msg.player == (Object)null || !msg.player.CanInteract() || msg.player.Distance(LineDeparturePoint.position) > 3f || !IsPlayerFacingValidDirection(msg.player) || ziplineTargets.Count == 0)
		{
			return;
		}
		Vector3 position = LineDeparturePoint.position;
		Vector3 val = Vector3Ex.WithY(ziplineTargets[0], position.y) - position;
		Quaternion lineStartRot = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
		val = position - Vector3Ex.WithY(((Component)msg.player).transform.position, position.y);
		Quaternion rot = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
		ZiplineMountable ziplineMountable = base.gameManager.CreateEntity(MountableRef.resourcePath, ((Component)msg.player).transform.position + Vector3.up * 2.1f, rot) as ZiplineMountable;
		if ((Object)(object)ziplineMountable != (Object)null)
		{
			CalculateZiplinePoints(ziplineTargets, ref linePoints);
			ziplineMountable.SetDestination(linePoints, position, lineStartRot);
			ziplineMountable.Spawn();
			ziplineMountable.MountPlayer(msg.player);
			if ((Object)(object)msg.player.GetMounted() != (Object)(object)ziplineMountable)
			{
				ziplineMountable.Kill();
			}
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearBusy, 2f);
		}
	}

	public void ClearBusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.zipline == null)
		{
			info.msg.zipline = Pool.Get<Zipline>();
		}
		info.msg.zipline.destinationPoints = Pool.Get<List<VectorData>>();
		foreach (Vector3 ziplineTarget in ziplineTargets)
		{
			info.msg.zipline.destinationPoints.Add(new VectorData(ziplineTarget.x, ziplineTarget.y, ziplineTarget.z));
		}
	}

	[ServerVar(ServerAdmin = true)]
	public static void report(Arg arg)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		int num2 = 0;
		int num3 = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (current is ZiplineLaunchPoint ziplineLaunchPoint)
				{
					float lineLength = ziplineLaunchPoint.GetLineLength();
					num2++;
					num += lineLength;
				}
				else if (current is ZiplineArrivalPoint)
				{
					num3++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"{num2} ziplines, total distance: {num:F2}, avg length: {num / (float)num2:F2}, arrival points: {num3}");
	}

	[ServerVar(ServerAdmin = true)]
	public static void highlight(Arg arg)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is ZiplineLaunchPoint ziplineLaunchPoint)
				{
					BasePlayer basePlayer = arg.Player();
					object[] obj = new object[7]
					{
						"60",
						Color.red,
						((Component)ziplineLaunchPoint).transform.position,
						null,
						null,
						null,
						null
					};
					List<Vector3> list = ziplineLaunchPoint.ziplineTargets;
					obj[3] = list[list.Count - 1];
					obj[4] = 25;
					obj[5] = 0;
					obj[6] = 0;
					basePlayer.SendConsoleCommand("ddraw.arrow", obj);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.zipline == null)
		{
			return;
		}
		ziplineTargets.Clear();
		foreach (VectorData destinationPoint in info.msg.zipline.destinationPoints)
		{
			ziplineTargets.Add(VectorData.op_Implicit(destinationPoint));
		}
	}

	public void CalculateZiplinePoints(List<Vector3> targets, ref List<Vector3> points)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (points == null && targets.Count != 0)
		{
			Vector3[] array = (Vector3[])(object)new Vector3[targets.Count + 1];
			array[0] = LineDeparturePoint.position;
			for (int i = 0; i < targets.Count; i++)
			{
				array[i + 1] = targets[i];
			}
			float[] array2 = new float[array.Length];
			for (int j = 0; j < array2.Length; j++)
			{
				array2[j] = LineSlackAmount;
			}
			points = new List<Vector3>();
			Bezier.ApplyLineSlack(array, array2, ref points, 25);
		}
	}

	public Vector3 CalculateLineMidPoint(Vector3 start, Vector3 endPoint)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = Vector3.Lerp(start, endPoint, 0.5f);
		result.y -= LineSlackAmount;
		return result;
	}

	public void UpdateBuildingBlocks()
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		BoxCollider[] buildingBlocks = BuildingBlocks;
		for (int i = 0; i < buildingBlocks.Length; i++)
		{
			((Component)buildingBlocks[i]).gameObject.SetActive(false);
		}
		buildingBlocks = PointBuildingBlocks;
		for (int i = 0; i < buildingBlocks.Length; i++)
		{
			((Component)buildingBlocks[i]).gameObject.SetActive(false);
		}
		SpawnableBoundsBlocker[] spawnableBoundsBlockers = SpawnableBoundsBlockers;
		for (int i = 0; i < spawnableBoundsBlockers.Length; i++)
		{
			((Component)spawnableBoundsBlockers[i]).gameObject.SetActive(false);
		}
		int num = 0;
		if (ziplineTargets.Count <= 0)
		{
			return;
		}
		Vector3 val = Vector3.zero;
		int startIndex2 = 0;
		for (int j = 0; j < linePoints.Count; j++)
		{
			if (j == 0 || (base.isClient && j == 1))
			{
				continue;
			}
			Vector3 val2 = linePoints[j];
			Vector3 val3 = val2 - Vector3Ex.WithY(linePoints[j - 1], val2.y);
			Vector3 normalized = ((Vector3)(ref val3)).normalized;
			if (val != Vector3.zero && Vector3.Dot(normalized, val) < 0.98f)
			{
				if (num < BuildingBlocks.Length)
				{
					SetUpBuildingBlock(BuildingBlocks[num], PointBuildingBlocks[num], SpawnableBoundsBlockers[num++], startIndex2, j - 1);
				}
				startIndex2 = j - 1;
			}
			val = normalized;
		}
		if (num < BuildingBlocks.Length)
		{
			SetUpBuildingBlock(BuildingBlocks[num], PointBuildingBlocks[num], SpawnableBoundsBlockers[num], startIndex2, linePoints.Count - 1);
		}
		void SetUpBuildingBlock(BoxCollider longCollider, BoxCollider pointCollider, SpawnableBoundsBlocker spawnBlocker, int startIndex, int endIndex)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val4 = linePoints[startIndex];
			Vector3 val5 = linePoints[endIndex];
			Vector3 val6 = Vector3.zero;
			Vector3 center = val4 - val5;
			Quaternion rotation = Quaternion.LookRotation(((Vector3)(ref center)).normalized, Vector3.up);
			Vector3 position = Vector3.Lerp(val4, val5, 0.5f);
			((Component)longCollider).transform.position = position;
			((Component)longCollider).transform.rotation = rotation;
			for (int k = startIndex; k < endIndex; k++)
			{
				Vector3 val7 = ((Component)longCollider).transform.InverseTransformPoint(linePoints[k]);
				if (val7.y < val6.y)
				{
					val6 = val7;
				}
			}
			float num2 = Mathf.Abs(val6.y) + 2f;
			float num3 = Vector3.Distance(val4, val5);
			center = (longCollider.size = (spawnBlocker.BoxCollider.size = new Vector3(0.5f, num2, num3) + Vector3.one));
			BoxCollider boxCollider = spawnBlocker.BoxCollider;
			((Vector3)(ref center))..ctor(0f, 0f - num2 * 0.5f, 0f);
			boxCollider.center = center;
			longCollider.center = center;
			((Component)longCollider).gameObject.SetActive(true);
			((Component)pointCollider).transform.position = linePoints[endIndex];
			((Component)pointCollider).gameObject.SetActive(true);
			((Component)spawnBlocker).gameObject.SetActive(true);
			if (base.isServer)
			{
				spawnBlocker.ClearTrees();
			}
		}
	}

	public bool IsPlayerFacingValidDirection(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Dot(ply.eyes.HeadForward(), ((Component)this).transform.forward) > 0.2f;
	}

	public float GetLineLength()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints == null)
		{
			return 0f;
		}
		float num = 0f;
		for (int i = 0; i < linePoints.Count - 1; i++)
		{
			num += Vector3.Distance(linePoints[i], linePoints[i + 1]);
		}
		return num;
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class LegacyShelter : DecayEntity
{
	public static readonly int FpShelterDefault = 1;

	[ReplicatedVar]
	public static int max_shelters = 1;

	private static Dictionary<ulong, List<LegacyShelter>> sheltersPerPlayer = new Dictionary<ulong, List<LegacyShelter>>();

	public static Phrase shelterLimitPhrase = new Phrase("shelter_limit_update", "You are now at {0}/{1} shelters");

	public static Phrase shelterLimitReachedPhrase = new Phrase("shelter_limit_reached", "You have reached your shelter limit!");

	[Header("Shelter References")]
	public GameObjectRef smallPrivilegePrefab;

	public GameObjectRef includedDoorPrefab;

	public GameObjectRef includedLockPrefab;

	public EntityRef<EntityPrivilege> entityPrivilege;

	private EntityRef<LegacyShelterDoor> childDoorInstance;

	private EntityRef<BaseLock> lockEntityInstance;

	private Decay decayReference;

	private float lastShelterDecayTick;

	public float lastInteractedWithDoor;

	private ulong shelterOwnerID;

	public static Dictionary<ulong, List<LegacyShelter>> SheltersPerPlayer => sheltersPerPlayer;

	public static Planner.CanBuildResult? CanBuildShelter(BasePlayer player, Construction construction)
	{
		GameObject obj = GameManager.server.FindPrefab(construction.prefabID);
		if (((obj != null) ? obj.GetComponent<BaseEntity>() : null) is LegacyShelter)
		{
			int num = 1;
			Planner.CanBuildResult value2;
			if (sheltersPerPlayer.TryGetValue(player.userID, out var value))
			{
				num = value.Count + 1;
				if (value.Count >= max_shelters)
				{
					value2 = default(Planner.CanBuildResult);
					value2.Result = false;
					value2.Phrase = shelterLimitReachedPhrase;
					return value2;
				}
			}
			value2 = default(Planner.CanBuildResult);
			value2.Result = true;
			value2.Phrase = shelterLimitPhrase;
			value2.Arguments = new string[2]
			{
				num.ToString(),
				max_shelters.ToString()
			};
			return value2;
		}
		return null;
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (sheltersPerPlayer.TryGetValue(shelterOwnerID, out var _))
		{
			sheltersPerPlayer[shelterOwnerID].Remove(this);
			BasePlayer basePlayer = BasePlayer.FindByID(shelterOwnerID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.SendRespawnOptions();
			}
		}
	}

	public static int GetShelterCount(ulong userId)
	{
		if (userId == 0L)
		{
			return 0;
		}
		if (!sheltersPerPlayer.TryGetValue(userId, out var value))
		{
			return 0;
		}
		return value.Count;
	}

	private void AddToShelterList(ulong id)
	{
		if (!sheltersPerPlayer.ContainsKey(id))
		{
			sheltersPerPlayer.Add(id, new List<LegacyShelter>());
		}
		if (!IsShelterInList(sheltersPerPlayer[id], out var _))
		{
			sheltersPerPlayer[id].Add(this);
		}
	}

	private bool IsShelterInList(List<LegacyShelter> shelters, out LegacyShelter thisShelter)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		thisShelter = null;
		if (shelters.Count == 0)
		{
			return false;
		}
		if ((Object)(object)thisShelter == (Object)null)
		{
			return false;
		}
		foreach (LegacyShelter shelter in shelters)
		{
			if (shelter.net.ID == net.ID)
			{
				result = true;
				thisShelter = shelter;
				break;
			}
		}
		return result;
	}

	public override EntityPrivilege GetEntityBuildingPrivilege()
	{
		return GetEntityPrivilege();
	}

	public EntityPrivilege GetEntityPrivilege()
	{
		EntityPrivilege entityPrivilege = this.entityPrivilege.Get(base.isServer);
		if (entityPrivilege.IsValid())
		{
			return entityPrivilege;
		}
		return null;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && child.prefabID == includedDoorPrefab.GetEntity().prefabID && !Application.isLoadingSave)
		{
			Setup(child);
		}
		if (child.prefabID == smallPrivilegePrefab.GetEntity().prefabID)
		{
			EntityPrivilege entity = (EntityPrivilege)child;
			entityPrivilege.Set(entity);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.legacyShelter == null || !base.isServer)
		{
			return;
		}
		shelterOwnerID = info.msg.legacyShelter.ownerId;
		childDoorInstance = new EntityRef<LegacyShelterDoor>(info.msg.legacyShelter.doorID);
		lastInteractedWithDoor = info.msg.legacyShelter.timeSinceInteracted;
		AddToShelterList(shelterOwnerID);
		if (max_shelters == FpShelterDefault)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(shelterOwnerID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.SendRespawnOptions();
			}
		}
	}

	public override void DecayTick()
	{
		base.DecayTick();
		float num = Time.time - lastShelterDecayTick;
		lastShelterDecayTick = Time.time;
		float num2 = num * ConVar.Decay.scale;
		lastInteractedWithDoor += num2;
		UpdateDoorHp();
	}

	public void HasInteracted()
	{
		lastInteractedWithDoor = 0f;
	}

	public void SetupDecay()
	{
		decayReference = PrefabAttribute.server.Find<Decay>(prefabID);
	}

	public override float GetEntityDecayDuration()
	{
		if (lastInteractedWithDoor < 64800f)
		{
			return float.MaxValue;
		}
		if (decayReference == null)
		{
			SetupDecay();
		}
		if (decayReference != null)
		{
			return decayReference.GetDecayDuration(this);
		}
		return float.MaxValue;
	}

	public LegacyShelterDoor GetChildDoor()
	{
		LegacyShelterDoor legacyShelterDoor = childDoorInstance.Get(base.isServer);
		if (legacyShelterDoor.IsValid())
		{
			return legacyShelterDoor;
		}
		return null;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.legacyShelter = Pool.Get<LegacyShelter>();
		info.msg.legacyShelter.doorID = childDoorInstance.uid;
		info.msg.legacyShelter.timeSinceInteracted = lastInteractedWithDoor;
		info.msg.legacyShelter.ownerId = shelterOwnerID;
	}

	public override void OnPlaced(BasePlayer player)
	{
		if (sheltersPerPlayer.TryGetValue(player.userID, out var value) && value.Count >= max_shelters)
		{
			value[0].Kill(DestroyMode.Gib);
		}
		shelterOwnerID = player.userID;
		AddToShelterList(shelterOwnerID);
		player.SendRespawnOptions();
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		LegacyShelterDoor childDoor = GetChildDoor();
		if ((Object)(object)childDoor != (Object)null)
		{
			childDoor.ProtectedHurt(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		LegacyShelterDoor childDoor = GetChildDoor();
		if ((Object)(object)childDoor != (Object)null && !childDoor.IsDead())
		{
			childDoor.Die();
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateDoorHp();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateDoorHp();
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		LegacyShelterDoor childDoor = GetChildDoor();
		if (Object.op_Implicit((Object)(object)childDoor))
		{
			childDoor.SetupDoor(this);
			childDoor.SetMaxHealth(MaxHealth());
			UpdateDoorHp();
		}
		SetupDecay();
	}

	private void Setup(BaseEntity child)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		LegacyShelterDoor legacyShelterDoor = (LegacyShelterDoor)child;
		childDoorInstance.Set(legacyShelterDoor);
		BasePlayer basePlayer = BasePlayer.FindByID(shelterOwnerID);
		if ((Object)(object)basePlayer != (Object)null)
		{
			((Component)this).GetComponentInChildren<EntityPrivilege>().AddPlayer(basePlayer);
		}
		legacyShelterDoor.SetupDoor(this);
		legacyShelterDoor.SetMaxHealth(MaxHealth());
		UpdateDoorHp();
		BaseEntity baseEntity = GameManager.server.CreateEntity(includedLockPrefab.resourcePath);
		baseEntity.SetParent(legacyShelterDoor, legacyShelterDoor.GetSlotAnchorName(Slot.Lock));
		baseEntity.OwnerID = shelterOwnerID;
		baseEntity.OnDeployed(legacyShelterDoor, basePlayer, null);
		baseEntity.Spawn();
		BaseLock baseLock = (BaseLock)baseEntity;
		if ((Object)(object)baseLock != (Object)null)
		{
			baseLock.CanRemove = false;
		}
		legacyShelterDoor.SetSlot(Slot.Lock, baseEntity);
	}

	private void UpdateDoorHp()
	{
		LegacyShelterDoor childDoor = GetChildDoor();
		if ((Object)(object)childDoor != (Object)null)
		{
			childDoor.SetHealth(base.health);
		}
	}
}


using Rust;
using UnityEngine;

public class LegacyShelterDoor : Door
{
	public GameObjectRef includedLockPrefab;

	private LegacyShelter shelter;

	public void SetupDoor(LegacyShelter shelter)
	{
		this.shelter = shelter;
	}

	public override void DecayTick()
	{
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (Application.isLoadingSave && child.prefabID == includedLockPrefab.GetEntity().prefabID && child.IsValid())
		{
			BaseLock baseLock = (BaseLock)child;
			if ((Object)(object)baseLock != (Object)null)
			{
				baseLock.CanRemove = false;
			}
		}
	}

	protected override void OnPlayerOpenedDoor(BasePlayer p)
	{
		base.OnPlayerOpenedDoor(p);
		if ((Object)(object)shelter != (Object)null)
		{
			shelter.HasInteracted();
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateShelterHp();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateShelterHp();
	}

	public override void Hurt(HitInfo info)
	{
		if (HasParent() && (Object)(object)shelter != (Object)null)
		{
			shelter.ProtectedHurt(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)shelter != (Object)null && !shelter.IsDead())
		{
			shelter.Die();
		}
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	private void UpdateShelterHp()
	{
		if (HasParent() && (Object)(object)shelter != (Object)null)
		{
			shelter.SetHealth(base.health);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ZiplineArrivalPoint : BaseEntity
{
	public LineRenderer Line;

	private Vector3[] linePositions;

	public override void Save(SaveInfo info)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.ZiplineArrival == null)
		{
			info.msg.ZiplineArrival = Pool.Get<ZiplineArrivalPoint>();
		}
		info.msg.ZiplineArrival.linePoints = Pool.Get<List<VectorData>>();
		Vector3[] array = linePositions;
		foreach (Vector3 val in array)
		{
			info.msg.ZiplineArrival.linePoints.Add(VectorData.op_Implicit(val));
		}
	}

	public void SetPositions(List<Vector3> points)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		linePositions = (Vector3[])(object)new Vector3[points.Count];
		for (int i = 0; i < points.Count; i++)
		{
			linePositions[i] = points[i];
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ZiplineArrival != null && linePositions == null)
		{
			linePositions = (Vector3[])(object)new Vector3[info.msg.ZiplineArrival.linePoints.Count];
			for (int i = 0; i < info.msg.ZiplineArrival.linePoints.Count; i++)
			{
				linePositions[i] = VectorData.op_Implicit(info.msg.ZiplineArrival.linePoints[i]);
			}
		}
	}

	public override void ResetState()
	{
		base.ResetState();
		linePositions = null;
	}
}


using UnityEngine;

public class ZiplineAudio : MonoBehaviour
{
	public ZiplineMountable zipline;

	public SoundDefinition movementLoopDef;

	public SoundDefinition frictionLoopDef;

	public SoundDefinition sparksLoopDef;

	public AnimationCurve movementGainCurve;

	public AnimationCurve movementPitchCurve;

	public AnimationCurve frictionGainCurve;

	public AnimationCurve sparksGainCurve;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ZiplineMountable : BaseMountable
{
	public float MoveSpeed = 4f;

	public float ForwardAdditive = 5f;

	public CapsuleCollider ZipCollider;

	public Transform ZiplineGrabRoot;

	public Transform LeftHandIkPoint;

	public Transform RightHandIkPoint;

	public float SpeedUpTime = 0.6f;

	public bool EditorHoldInPlace;

	private List<Vector3> linePoints;

	public const Flags PushForward = Flags.Reserved1;

	public AnimationCurve MountPositionCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve MountRotationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float MountEaseInTime = 0.5f;

	public const Flags ShowHandle = Flags.Reserved2;

	public float additiveValue;

	public float currentTravelDistance;

	public TimeSince mountTime;

	private bool hasEnded;

	public List<Collider> ignoreColliders = new List<Collider>();

	private Vector3 lastSafePosition;

	public Vector3 startPosition = Vector3.zero;

	public Vector3 endPosition = Vector3.zero;

	public Quaternion startRotation = Quaternion.identity;

	public Quaternion endRotation = Quaternion.identity;

	public float elapsedMoveTime;

	public bool isAnimatingIn;

	public Vector3 ProcessBezierMovement(float distanceToTravel)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints == null)
		{
			return Vector3.zero;
		}
		float num = 0f;
		for (int i = 0; i < linePoints.Count - 1; i++)
		{
			float num2 = Vector3.Distance(linePoints[i], linePoints[i + 1]);
			if (num + num2 > distanceToTravel)
			{
				float num3 = Mathf.Clamp((distanceToTravel - num) / num2, 0f, 1f);
				return Vector3.Lerp(linePoints[i], linePoints[i + 1], num3);
			}
			num += num2;
		}
		return linePoints[linePoints.Count - 1];
	}

	public Vector3 GetLineEndPoint(bool applyDismountOffset = false)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (applyDismountOffset && linePoints != null)
		{
			List<Vector3> list = linePoints;
			Vector3 val = list[list.Count - 2];
			List<Vector3> list2 = linePoints;
			Vector3 val2 = val - list2[list2.Count - 1];
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			List<Vector3> list3 = linePoints;
			return list3[list3.Count - 1] + normalized * 1.5f;
		}
		List<Vector3> list4 = linePoints;
		return list4?[list4.Count - 1] ?? Vector3.zero;
	}

	public Vector3 GetNextLinePoint(Transform forTransform)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = forTransform.position;
		Vector3 forward = forTransform.forward;
		for (int i = 1; i < linePoints.Count - 1; i++)
		{
			Vector3 val = linePoints[i + 1] - position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			val = linePoints[i - 1] - position;
			Vector3 normalized2 = ((Vector3)(ref val)).normalized;
			float num = Vector3.Dot(forward, normalized);
			float num2 = Vector3.Dot(forward, normalized2);
			if (num > 0f && num2 < 0f)
			{
				return linePoints[i + 1];
			}
		}
		return GetLineEndPoint();
	}

	public override void ResetState()
	{
		base.ResetState();
		additiveValue = 0f;
		currentTravelDistance = 0f;
		hasEnded = false;
		linePoints = null;
	}

	public override float AntiHackVelocity()
	{
		return MoveSpeed + ForwardAdditive;
	}

	public void SetDestination(List<Vector3> targetLinePoints, Vector3 lineStartPos, Quaternion lineStartRot)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		linePoints = targetLinePoints;
		currentTravelDistance = 0f;
		mountTime = TimeSince.op_Implicit(0f);
		GamePhysics.OverlapSphere(((Component)this).transform.position, 6f, ignoreColliders, 1084293377, (QueryTriggerInteraction)1);
		startPosition = ((Component)this).transform.position;
		startRotation = ((Component)this).transform.rotation;
		lastSafePosition = startPosition;
		endPosition = lineStartPos;
		endRotation = lineStartRot;
		elapsedMoveTime = 0f;
		isAnimatingIn = true;
		((FacepunchBehaviour)this).InvokeRepeating((Action)MovePlayerToPosition, 0f, 0f);
	}

	private void Update()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints == null || base.isClient || isAnimatingIn || hasEnded)
		{
			return;
		}
		float num = (MoveSpeed + additiveValue * ForwardAdditive) * Mathf.Clamp(TimeSince.op_Implicit(mountTime) / SpeedUpTime, 0f, 1f) * Time.smoothDeltaTime;
		currentTravelDistance += num;
		Vector3 val = ProcessBezierMovement(currentTravelDistance);
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		Vector3 position = Vector3Ex.WithY(val, val.y - ZipCollider.height * 0.6f);
		Vector3 position2 = val;
		GamePhysics.CapsuleSweep(position, position2, 0.5f, ((Component)this).transform.forward, num, list, 1084293377, (QueryTriggerInteraction)1);
		foreach (RaycastHit item in list)
		{
			RaycastHit current = item;
			if (!((Object)(object)((RaycastHit)(ref current)).collider == (Object)(object)ZipCollider) && !ignoreColliders.Contains(((RaycastHit)(ref current)).collider) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).GetComponentInParent<PowerlineNode>() != (Object)null) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).GetComponent<TreeEntity>() != (Object)null) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).GetComponentInParent<TreeEntity>() != (Object)null))
			{
				ZiplineMountable componentInParent = ((Component)((RaycastHit)(ref current)).collider).GetComponentInParent<ZiplineMountable>();
				if ((Object)(object)componentInParent != (Object)null)
				{
					componentInParent.EndZipline();
				}
				if (!GetDismountPosition(GetMounted(), out var _, silent: true))
				{
					((Component)this).transform.position = lastSafePosition;
				}
				EndZipline();
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				return;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		if (Vector3.Distance(val, GetLineEndPoint()) < 0.1f)
		{
			((Component)this).transform.position = GetLineEndPoint(applyDismountOffset: true);
			hasEnded = true;
			return;
		}
		if (Vector3.Distance(lastSafePosition, ((Component)this).transform.position) > 0.5f && GetDismountPosition(GetMounted(), out var _, silent: true))
		{
			lastSafePosition = ((Component)this).transform.position;
		}
		Vector3 val2 = val - Vector3Ex.WithY(((Component)this).transform.position, val.y);
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		((Component)this).transform.position = Vector3.Lerp(((Component)this).transform.position, val, Time.deltaTime * 12f);
		((Component)this).transform.forward = normalized;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		if (linePoints == null)
		{
			return;
		}
		if (hasEnded)
		{
			if (!GetDismountPosition(GetMounted(), out var _, silent: true))
			{
				((Component)this).transform.position = lastSafePosition;
			}
			EndZipline();
		}
		else
		{
			Vector3 position = ((Component)this).transform.position;
			float num = ((GetNextLinePoint(((Component)this).transform).y < position.y + 0.1f && inputState.IsDown(BUTTON.FORWARD)) ? 1f : 0f);
			additiveValue = Mathf.MoveTowards(additiveValue, num, (float)Server.tickrate * ((num > 0f) ? 4f : 2f));
			SetFlag(Flags.Reserved1, additiveValue > 0.5f);
		}
	}

	public void EndZipline()
	{
		DismountAllPlayers();
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public override bool ValidDismountPosition(BasePlayer player, Vector3 disPos)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		((Collider)ZipCollider).enabled = false;
		bool result = base.ValidDismountPosition(player, disPos);
		((Collider)ZipCollider).enabled = true;
		return result;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (linePoints == null)
		{
			return;
		}
		if (info.msg.ziplineMountable == null)
		{
			info.msg.ziplineMountable = Pool.Get<ZiplineMountable>();
		}
		info.msg.ziplineMountable.linePoints = Pool.Get<List<VectorData>>();
		foreach (Vector3 linePoint in linePoints)
		{
			info.msg.ziplineMountable.linePoints.Add(VectorData.op_Implicit(linePoint));
		}
	}

	public void MovePlayerToPosition()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		elapsedMoveTime += Time.deltaTime;
		float num = Mathf.Clamp(elapsedMoveTime / MountEaseInTime, 0f, 1f);
		Vector3 localPosition = Vector3.Lerp(startPosition, endPosition, MountPositionCurve.Evaluate(num));
		Quaternion localRotation = Quaternion.Lerp(startRotation, endRotation, MountRotationCurve.Evaluate(num));
		((Component)this).transform.localPosition = localPosition;
		((Component)this).transform.localRotation = localRotation;
		if (num >= 1f)
		{
			isAnimatingIn = false;
			SetFlag(Flags.Reserved2, b: true);
			mountTime = TimeSince.op_Implicit(0f);
			((FacepunchBehaviour)this).CancelInvoke((Action)MovePlayerToPosition);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && old.HasFlag(Flags.Busy) && !next.HasFlag(Flags.Busy) && !base.IsDestroyed)
		{
			Kill();
		}
	}
}


using UnityEngine;

public class ZiplineTarget : MonoBehaviour
{
	public Transform Target;

	public bool IsChainPoint;

	public float MonumentConnectionDotMin = 0.2f;

	public float MonumentConnectionDotMax = 1f;

	public bool IsValidPosition(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = position - Vector3Ex.WithY(Target.position, position.y);
		float num = Vector3.Dot(((Vector3)(ref val)).normalized, Target.forward);
		if (num >= MonumentConnectionDotMin)
		{
			return num <= MonumentConnectionDotMax;
		}
		return false;
	}

	public bool IsValidChainPoint(Vector3 from, Vector3 to)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = from - Vector3Ex.WithY(Target.position, from.y);
		float num = Vector3.Dot(((Vector3)(ref val)).normalized, Target.forward);
		val = to - Vector3Ex.WithY(Target.position, from.y);
		float num2 = Vector3.Dot(((Vector3)(ref val)).normalized, Target.forward);
		if ((num > 0f && num2 > 0f) || (num < 0f && num2 < 0f))
		{
			return false;
		}
		num2 = Mathf.Abs(num2);
		if (num2 >= MonumentConnectionDotMin)
		{
			return num2 <= MonumentConnectionDotMax;
		}
		return false;
	}
}


public class TriggerVineClimbTip : TriggerBase, IClientComponent
{
}


public class Vine : FacepunchBehaviour
{
	[ClientVar]
	public static bool DRAW_DEBUG;

	[ClientVar]
	public static bool PREVENT_VINE_DRAW;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Spatial;
using UnityEngine;

public class VineLaunchPoint : MonoBehaviour
{
	[Header("References")]
	public GameObjectRef VineMountablePrefab;

	public float MaximumDestinationRange;

	public float MinimumDestinationRange;

	[Header("Arc Settings")]
	public float maxDistanceHeight = -10f;

	public float minDistanceHeight = -4f;

	public int resolution = 30;

	public bool drawArc = true;

	public float angle;

	public float VineSpawnOffset = 0.1f;

	public bool useLevelDirection = true;

	public Transform[] VineArrivalPoints;

	public VineSwingingTree ParentTree;

	private static Grid<VineLaunchPoint> pointGrid = new Grid<VineLaunchPoint>(32, 8096f);

	private bool hasDied;

	private VineMountable spawnedVine
	{
		get
		{
			return ParentTree.GetSpawnedVine(this);
		}
		set
		{
			ParentTree.SetSpawnedVine(this, value);
		}
	}

	public int Index()
	{
		if ((Object)(object)ParentTree != (Object)null)
		{
			for (int i = 0; i < ParentTree.LaunchPoints.Length; i++)
			{
				if ((Object)(object)ParentTree.LaunchPoints[i] == (Object)(object)this)
				{
					return i;
				}
			}
		}
		return -1;
	}

	public Vector3 GetSwingPointAtTime(float time, VineLaunchPoint forPoint)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return GetSwingPointAtTime(time, ((Component)forPoint).transform.position);
	}

	public Vector3 GetSwingPointAtTime(float time, Vector3 forPoint)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = forPoint;
		Vector3 val2 = val - position;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		position += normalized * VineSpawnOffset;
		val += normalized * (0f - VineSpawnOffset);
		float num = Mathx.RemapValClamped(Vector3.Distance(position, val), MinimumDestinationRange, MaximumDestinationRange, 0f, 1f);
		Vector3 point = VineUtils.SampleParabola(position, val, Mathf.Lerp(minDistanceHeight, maxDistanceHeight, num), time, useLevelDirection);
		Vector3 pivot = (position + val) / 2f;
		val2 = position - val;
		return VineUtils.RotateAroundWorldAxis(point, pivot, ((Vector3)(ref val2)).normalized, angle);
	}

	public void ServerInit()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		pointGrid.Add(this, position.x, position.z);
		hasDied = false;
	}

	public void DoServerDestroy()
	{
		if (!hasDied)
		{
			hasDied = true;
			pointGrid.Remove(this);
			VineMountable.NotifyVinesLaunchSiteRemoved(this);
		}
	}

	public void SpawnVineIfPossible(VineSwingingTree fromTree)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		hasDied = false;
		VineMountable vineMountable = spawnedVine;
		PooledList<VineLaunchPoint> val = Pool.Get<PooledList<VineLaunchPoint>>();
		try
		{
			if ((Object)(object)vineMountable != (Object)null)
			{
				if (GetReceivePoints((List<VineLaunchPoint>)(object)val))
				{
					vineMountable.Initialise(this, (List<VineLaunchPoint>)(object)val, vineMountable.WorldSpaceAnchorPoint);
					vineMountable.SendNetworkUpdate();
				}
				return;
			}
			((List<VineLaunchPoint>)(object)val).Clear();
			GetReceivePoints((List<VineLaunchPoint>)(object)val);
			if (((List<VineLaunchPoint>)(object)val).Count <= 0)
			{
				return;
			}
			Vector3 val2 = ((Component)this).transform.TransformPoint(Vector3.forward * VineSpawnOffset);
			PooledList<VineMountable> val3 = Pool.Get<PooledList<VineMountable>>();
			try
			{
				GamePhysics.OverlapSphere<VineMountable>(val2, 5f, (List<VineMountable>)(object)val3, 134217728, (QueryTriggerInteraction)2);
				foreach (VineMountable item in (List<VineMountable>)(object)val3)
				{
					if (!item.HasFlag(BaseEntity.Flags.Reserved1))
					{
						return;
					}
				}
				VineMountable vineMountable2 = GameManager.server.CreateEntity(VineMountablePrefab.resourcePath, val2, Quaternion.identity) as VineMountable;
				if (FindVacantArrivalPoint(vineMountable2, out var worldPos))
				{
					((Component)vineMountable2).transform.position = worldPos;
				}
				spawnedVine = vineMountable2;
				Vector3 vineSpawnPos = fromTree.GetVineSpawnPos((List<VineLaunchPoint>)(object)val);
				vineMountable2.Initialise(this, (List<VineLaunchPoint>)(object)val, vineSpawnPos);
				vineMountable2.Spawn();
				vineMountable2.SendNetworkUpdate();
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnVineKilled()
	{
		spawnedVine = null;
	}

	private bool GetReceivePoints(List<VineLaunchPoint> points)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Vector3 forward = ((Component)this).transform.forward;
		bool result = false;
		PooledList<VineLaunchPoint> val = Pool.Get<PooledList<VineLaunchPoint>>();
		try
		{
			if (!Application.isPlaying)
			{
				((List<VineLaunchPoint>)(object)val).AddRange((IEnumerable<VineLaunchPoint>)Object.FindObjectsByType<VineLaunchPoint>((FindObjectsInactive)0, (FindObjectsSortMode)0));
			}
			else
			{
				pointGrid.Query(position.x, position.z, MaximumDestinationRange, (List<VineLaunchPoint>)(object)val);
			}
			foreach (VineLaunchPoint item in (List<VineLaunchPoint>)(object)val)
			{
				if ((Object)(object)item == (Object)(object)this || points.Contains(item))
				{
					continue;
				}
				Vector3 position2 = ((Component)item).transform.position;
				float num = Vector3.Distance(position, Vector3Ex.WithY(position2, position.y));
				if (num > MaximumDestinationRange || num < MinimumDestinationRange)
				{
					continue;
				}
				Vector3 val2 = Vector3Ex.WithY(position2, position.y) - position;
				if (!(Vector3.Angle(forward, ((Vector3)(ref val2)).normalized) > 45f) && !(Vector3.Angle(forward, -((Component)item).transform.forward) > 90f))
				{
					if (!GamePhysics.LineOfSightRadius(position, position2, 1084293377, 0.25f, ParentTree))
					{
						return false;
					}
					Vector3 swingPointAtTime = GetSwingPointAtTime(0.5f, position2);
					if (!GamePhysics.LineOfSightRadius(position, swingPointAtTime, 1084293377, 0.25f, ParentTree))
					{
						return false;
					}
					if (!GamePhysics.LineOfSightRadius(position2, swingPointAtTime, 1084293377, 0.25f, ParentTree))
					{
						return false;
					}
					points.Add(item);
					result = true;
				}
			}
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool FindVacantArrivalPoint(VineMountable forMountable, out Vector3 worldPos)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		if (!forMountable.HasFlag(BaseEntity.Flags.Reserved1))
		{
			worldPos = ((Component)this).transform.TransformPoint(Vector3.forward * VineSpawnOffset);
			return true;
		}
		worldPos = Vector3.zero;
		PooledList<VineMountable> val = Pool.Get<PooledList<VineMountable>>();
		try
		{
			Vis.Entities(((Component)this).transform.position, 2f, (List<VineMountable>)(object)val, 134217728, (QueryTriggerInteraction)2);
			float num = float.MaxValue;
			Transform val2 = null;
			Transform[] vineArrivalPoints = VineArrivalPoints;
			foreach (Transform val3 in vineArrivalPoints)
			{
				Vector3 position = val3.position;
				bool flag = true;
				foreach (VineMountable item in (List<VineMountable>)(object)val)
				{
					if (!item.isClient && !((Object)(object)item == (Object)(object)forMountable) && Vector3.Distance(position, Vector3Ex.WithY(((Component)item).transform.position, position.y)) < 0.1f)
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					float num2 = Vector3.Distance(Vector3Ex.WithY(((Component)forMountable).transform.position, position.y), position);
					if (num2 < num)
					{
						num = num2;
						val2 = val3;
					}
				}
			}
			bool num3 = (Object)(object)val2 != (Object)null;
			if (num3)
			{
				worldPos = val2.position;
			}
			return num3;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public class VineLOD : RendererLOD
{
	public FakePhysicsRope.RenderMode[] renderModesPerLOD;

	public int MaxLodForShadows;
}


using UnityEngine;

public class VineRenderer : FakePhysicsRope
{
	[Header("Swing Settings")]
	public float swingDamp = 5f;

	public float swingStiffness = 20f;
}


using UnityEngine;

public static class VineUtils
{
	public static Vector3 SampleParabola(Vector3 start, Vector3 end, float height, float t, bool useLevelDirection = false)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		float num = t * 2f - 1f;
		if (Mathf.Abs(start.y - end.y) < 0.1f)
		{
			Vector3 val = end - start;
			Vector3 result = start + t * val;
			result.y += ((0f - num) * num + 1f) * height;
			return result;
		}
		Vector3 val2 = end - start;
		Vector3 val3 = end - new Vector3(start.x, end.y, start.z);
		Vector3 val4 = Vector3.Cross(val2, val3);
		Vector3 val5 = ((!useLevelDirection) ? Vector3.Cross(val4, val2) : Vector3.Cross(val4, val3));
		if (end.y > start.y)
		{
			val5 = -val5;
		}
		return start + t * val2 + ((0f - num) * num + 1f) * height * ((Vector3)(ref val5)).normalized;
	}

	public static float FindT(Vector3 start, Vector3 end, float height, Vector3 targetPosition, bool useLevelDirection = false)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.5f;
		float num2 = 0.01f;
		for (num = 0f; num <= 1f; num += num2)
		{
			if (Vector3.Distance(SampleParabola(start, end, height, num, useLevelDirection), targetPosition) < 0.01f)
			{
				return num;
			}
		}
		return -1f;
	}

	public static Vector3 RotateAroundWorldAxis(Vector3 point, Vector3 pivot, Vector3 axis, float angle)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.AngleAxis(angle, axis);
		Vector3 val2 = point - pivot;
		Vector3 val3 = val * val2;
		return pivot + val3;
	}
}


using UnityEngine;

public class VineViewmodel : BaseViewModel
{
	public Transform VineConnectionPoint;
}


using UnityEngine;
using UnityEngine.UI;

public class ShopFrontLootPanel : LootPanel
{
	public Text playerLabelA;

	public Text playerLabelB;

	public GameObject confirmButton;

	public GameObject confirmHelp;

	public GameObject denyButton;

	public GameObject denyHelp;

	public GameObject waitingText;

	public GameObject exchangeInProgressImage;

	public Phrase acceptedPhrase;

	public Phrase noOnePhrase;
}


using UnityEngine;

public class BurstClothCollider : MonoBehaviour, IClientComponent
{
	public float Height;

	public float Radius;

	public void GetParams(out Vector3 pointA, out Vector3 pointB, out Vector3 up, out float halfHeight)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		halfHeight = Height / 2f;
		up = ((Component)this).transform.rotation * Vector3.up;
		pointA = position + up * halfHeight;
		pointB = position - up * halfHeight;
	}
}


using System.Collections.Generic;
using Facepunch.BurstCloth;
using Unity.Mathematics;
using UnityEngine;

public class BurstClothHitBoxCollision : BurstCloth, IClientComponent, IPrefabPreProcess
{
	[Header("Rust Wearable BurstCloth")]
	public bool UseLocalGravity = true;

	public float GravityStrength = 0.8f;

	public float DefaultLength = 1f;

	public float MountedLengthMultiplier;

	public float DuckedLengthMultiplier = 0.5f;

	public float CorpseLengthMultiplier = 0.2f;

	public Transform UpAxis;

	[Header("Collision")]
	public Transform ColliderRoot;

	[Tooltip("Keywords in bone names which should be ignored for collision")]
	public string[] IgnoreKeywords;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	private static void BreakCapsuleIntoSpheres(Transform transform, Vector3 pointA, Vector3 pointB, Vector3 up, float halfHeight, float radius, List<SphereParams> sphereColliders)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pointA - up * radius;
		Vector3 val2 = pointB + up * radius;
		sphereColliders.Add(new SphereParams
		{
			Transform = transform,
			Point = transform.InverseTransformPoint(val),
			Radius = radius
		});
		sphereColliders.Add(new SphereParams
		{
			Transform = transform,
			Point = transform.InverseTransformPoint(val2),
			Radius = radius
		});
		Vector3 val3 = val - up * radius;
		int num = Mathf.CeilToInt(math.max((2f * halfHeight - 4f * radius) / radius, 1f));
		for (int i = 0; i < num; i++)
		{
			sphereColliders.Add(new SphereParams
			{
				Transform = transform,
				Point = transform.InverseTransformPoint(val3 - up * ((float)i * radius)),
				Radius = radius
			});
		}
	}

	protected override void GatherColliders(List<SphereParams> sphereColliders)
	{
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}
}


using EZhex1991.EZSoftBone;
using UnityEngine;

public class GhostSheetSystemSpaceUpdater : MonoBehaviour, IClientComponent
{
	private EZSoftBone[] ezSoftBones;

	private BasePlayer player;

	public void Awake()
	{
		ezSoftBones = ((Component)this).GetComponents<EZSoftBone>();
		player = ((Component)this).gameObject.ToBaseEntity() as BasePlayer;
	}

	public void Update()
	{
		if (ezSoftBones == null || ezSoftBones.Length == 0 || (Object)(object)player == (Object)null)
		{
			return;
		}
		BaseMountable mounted = player.GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			SetSimulateSpace(((Component)mounted).transform, collisionEnabled: false);
			return;
		}
		BaseEntity parentEntity = player.GetParentEntity();
		if ((Object)(object)parentEntity != (Object)null)
		{
			SetSimulateSpace(((Component)parentEntity).transform, collisionEnabled: true);
		}
		else
		{
			SetSimulateSpace(null, collisionEnabled: true);
		}
	}

	private void SetSimulateSpace(Transform transform, bool collisionEnabled)
	{
		for (int i = 0; i < ezSoftBones.Length; i++)
		{
			EZSoftBone obj = ezSoftBones[i];
			obj.simulateSpace = transform;
			obj.collisionEnabled = collisionEnabled;
		}
	}
}


using UnityEngine;

public class PartyHatMaterialRandomiser : MonoBehaviour, IItemSetup
{
	public Material[] MaterialOptions;

	public Renderer[] TargetRenderers;

	public void OnItemSetup(Item item)
	{
	}

	public void OnSetupSkin(ulong skin, ItemDefinition definition)
	{
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class NVGCamera : FacepunchBehaviour, IClothingChanged
{
	public static NVGCamera instance;

	public PostProcessVolume postProcessVolume;

	public GameObject lights;
}


using UnityStandardAssets.ImageEffects;

public class NVGColorCorrection : ColorCorrectionCurves
{
}


using System;
using UnityEngine;
using UnityStandardAssets.ImageEffects;

[ExecuteInEditMode]
[AddComponentMenu("Image Effects/NVG Effect")]
public class NVGEffect : PostEffectsBase, IImageEffect
{
	[Serializable]
	public struct ColorCorrectionParams
	{
		public float saturation;

		public AnimationCurve redChannel;

		public AnimationCurve greenChannel;

		public AnimationCurve blueChannel;
	}

	[Serializable]
	public struct NoiseAndGrainParams
	{
		public float intensityMultiplier;

		public float generalIntensity;

		public float blackIntensity;

		public float whiteIntensity;

		public float midGrey;

		public bool monochrome;

		public Vector3 intensities;

		public Vector3 tiling;

		public float monochromeTiling;

		public FilterMode filterMode;
	}

	public ColorCorrectionParams ColorCorrection1 = new ColorCorrectionParams
	{
		saturation = 1f,
		redChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		}),
		greenChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		}),
		blueChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		})
	};

	public ColorCorrectionParams ColorCorrection2 = new ColorCorrectionParams
	{
		saturation = 1f,
		redChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		}),
		greenChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		}),
		blueChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		})
	};

	public NoiseAndGrainParams NoiseAndGrain = new NoiseAndGrainParams
	{
		intensityMultiplier = 1.5f,
		generalIntensity = 1f,
		blackIntensity = 1f,
		whiteIntensity = 1f,
		midGrey = 0.182f,
		monochrome = true,
		intensities = new Vector3(1f, 1f, 1f),
		tiling = new Vector3(60f, 70f, 80f),
		monochromeTiling = 55f,
		filterMode = (FilterMode)0
	};

	private Texture2D rgbChannelTex1;

	private Texture2D rgbChannelTex2;

	private bool updateTexturesOnStartup = true;

	public Texture2D NoiseTexture;

	private static float NOISE_TILE_AMOUNT = 64f;

	public Shader Shader;

	private Material material;

	private void Awake()
	{
		updateTexturesOnStartup = true;
	}

	private void OnDestroy()
	{
		if ((Object)(object)rgbChannelTex1 != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)rgbChannelTex1);
			rgbChannelTex1 = null;
		}
		if ((Object)(object)rgbChannelTex2 != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)rgbChannelTex2);
			rgbChannelTex2 = null;
		}
		if ((Object)(object)material != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)material);
			material = null;
		}
	}

	private void UpdateColorCorrectionTexture(ColorCorrectionParams param, ref Texture2D tex)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		if (param.redChannel != null && param.greenChannel != null && param.blueChannel != null)
		{
			for (float num = 0f; num <= 1f; num += 0.003921569f)
			{
				float num2 = Mathf.Clamp(param.redChannel.Evaluate(num), 0f, 1f);
				float num3 = Mathf.Clamp(param.greenChannel.Evaluate(num), 0f, 1f);
				float num4 = Mathf.Clamp(param.blueChannel.Evaluate(num), 0f, 1f);
				tex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
				tex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
				tex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
			}
			tex.Apply();
		}
	}

	public void UpdateTextures()
	{
		((PostEffectsBase)this).CheckResources();
		UpdateColorCorrectionTexture(ColorCorrection1, ref rgbChannelTex1);
		UpdateColorCorrectionTexture(ColorCorrection2, ref rgbChannelTex2);
	}

	public override bool CheckResources()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Expected O, but got Unknown
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Expected O, but got Unknown
		((PostEffectsBase)this).CheckSupport(false);
		material = ((PostEffectsBase)this).CheckShaderAndCreateMaterial(Shader, material);
		if ((Object)(object)rgbChannelTex1 == (Object)null || (Object)(object)rgbChannelTex2 == (Object)null)
		{
			rgbChannelTex1 = new Texture2D(256, 4, (TextureFormat)5, false, true)
			{
				hideFlags = (HideFlags)52,
				wrapMode = (TextureWrapMode)1
			};
			rgbChannelTex2 = new Texture2D(256, 4, (TextureFormat)5, false, true)
			{
				hideFlags = (HideFlags)52,
				wrapMode = (TextureWrapMode)1
			};
		}
		if (!base.isSupported)
		{
			((PostEffectsBase)this).ReportAutoDisable();
		}
		return base.isSupported;
	}

	public bool IsActive()
	{
		if (((Behaviour)this).enabled && ((PostEffectsBase)this).CheckResources())
		{
			return (Object)(object)NoiseTexture != (Object)null;
		}
		return false;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		if (!((PostEffectsBase)this).CheckResources())
		{
			Graphics.Blit((Texture)(object)source, destination);
			if ((Object)(object)NoiseTexture == (Object)null)
			{
				Debug.LogWarning((object)"[NVGEffect] Noise & Grain effect failing as noise texture is not assigned. please assign.", (Object)(object)((Component)this).transform);
			}
			return;
		}
		if (updateTexturesOnStartup)
		{
			UpdateTextures();
			updateTexturesOnStartup = false;
		}
		material.SetTexture("_MainTex", (Texture)(object)source);
		material.SetTexture("_RgbTex1", (Texture)(object)rgbChannelTex1);
		material.SetFloat("_Saturation1", ColorCorrection1.saturation);
		material.SetTexture("_RgbTex2", (Texture)(object)rgbChannelTex2);
		material.SetFloat("_Saturation2", ColorCorrection2.saturation);
		material.SetTexture("_NoiseTex", (Texture)(object)NoiseTexture);
		material.SetVector("_NoisePerChannel", Vector4.op_Implicit(NoiseAndGrain.monochrome ? Vector3.one : NoiseAndGrain.intensities));
		material.SetVector("_NoiseTilingPerChannel", Vector4.op_Implicit(NoiseAndGrain.monochrome ? (Vector3.one * NoiseAndGrain.monochromeTiling) : NoiseAndGrain.tiling));
		material.SetVector("_MidGrey", Vector4.op_Implicit(new Vector3(NoiseAndGrain.midGrey, 1f / (1f - NoiseAndGrain.midGrey), -1f / NoiseAndGrain.midGrey)));
		material.SetVector("_NoiseAmount", Vector4.op_Implicit(new Vector3(NoiseAndGrain.generalIntensity, NoiseAndGrain.blackIntensity, NoiseAndGrain.whiteIntensity) * NoiseAndGrain.intensityMultiplier));
		if (Object.op_Implicit((Object)(object)NoiseTexture))
		{
			((Texture)NoiseTexture).wrapMode = (TextureWrapMode)0;
			((Texture)NoiseTexture).filterMode = NoiseAndGrain.filterMode;
		}
		RenderTexture.active = destination;
		float num = (float)((Texture)NoiseTexture).width * 1f;
		float num2 = 1f * (float)((Texture)source).width / NOISE_TILE_AMOUNT;
		GL.PushMatrix();
		GL.LoadOrtho();
		float num3 = 1f * (float)((Texture)source).width / (1f * (float)((Texture)source).height);
		float num4 = 1f / num2;
		float num5 = num4 * num3;
		float num6 = num / ((float)((Texture)NoiseTexture).width * 1f);
		material.SetPass(0);
		GL.Begin(7);
		for (float num7 = 0f; num7 < 1f; num7 += num4)
		{
			for (float num8 = 0f; num8 < 1f; num8 += num5)
			{
				float num9 = Random.Range(0f, 1f);
				float num10 = Random.Range(0f, 1f);
				num9 = Mathf.Floor(num9 * num) / num;
				num10 = Mathf.Floor(num10 * num) / num;
				float num11 = 1f / num;
				GL.MultiTexCoord2(0, num9, num10);
				GL.MultiTexCoord2(1, 0f, 0f);
				GL.Vertex3(num7, num8, 0.1f);
				GL.MultiTexCoord2(0, num9 + num6 * num11, num10);
				GL.MultiTexCoord2(1, 1f, 0f);
				GL.Vertex3(num7 + num4, num8, 0.1f);
				GL.MultiTexCoord2(0, num9 + num6 * num11, num10 + num6 * num11);
				GL.MultiTexCoord2(1, 1f, 1f);
				GL.Vertex3(num7 + num4, num8 + num5, 0.1f);
				GL.MultiTexCoord2(0, num9, num10 + num6 * num11);
				GL.MultiTexCoord2(1, 0f, 1f);
				GL.Vertex3(num7, num8 + num5, 0.1f);
			}
		}
		GL.End();
		GL.PopMatrix();
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ColorCorrectionParams
{
	public float saturation;

	public AnimationCurve redChannel;

	public AnimationCurve greenChannel;

	public AnimationCurve blueChannel;
}


using System;
using UnityEngine;

[Serializable]
public struct NoiseAndGrainParams
{
	public float intensityMultiplier;

	public float generalIntensity;

	public float blackIntensity;

	public float whiteIntensity;

	public float midGrey;

	public bool monochrome;

	public Vector3 intensities;

	public Vector3 tiling;

	public float monochromeTiling;

	public FilterMode filterMode;
}


public class NVGToggle : ItemEventFlag
{
	public SoundPlayer loopSfx;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class Beehive : StorageContainer, IHeatSourceListener, ISplashable
{
	[Header("Beehive Settings")]
	public ItemDefinition HoneyCombDefinition;

	public ItemDefinition BeeNucleusDefinition;

	public float growthRate = 0.05f;

	public float beeStingTime = 2f;

	[Header("References")]
	public TriggerHurtEx hurtTrigger;

	public GameObjectRef masterSwarm;

	public const Flags HasNucleus = Flags.Reserved12;

	public const Flags HasBees = Flags.Reserved13;

	public const Flags AngryBees = Flags.Reserved14;

	[ServerVar(Help = "How long before a Beehive will update")]
	public static float updateHiveInterval = 120f;

	[ServerVar(Help = "How long before the Beehive will perform temperature and inside checks")]
	public static float updateHiveStatsInterval = 120f;

	[ServerVar(Help = "How much the Nucleus's XP should be increased per honeycomb generated")]
	public static int xpIncreasePerHoneycomb = 2;

	private static Vector3[] outsideLookupDirs;

	private bool hasNucleus;

	private float createNewCombAccumulator;

	private float honeyCombProductionMultiplier = 2f;

	private TimeSince timeSinceAngryBees;

	private TimeCachedValue<float> temperatureExposure;

	private TimeCachedValue<float> humidityExposure;

	private TimeCachedValue<bool> outsideCheck;

	private float serverHumidity;

	private float serverTemperature;

	private bool serverOutside;

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (HasFlag(Flags.Reserved13) || HasFlag(Flags.Reserved12))
		{
			pickupErrorToFormat = (format: PickupErrors.ItemMustBeEmpty, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public bool IsOutsideAccurate()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return SocketMod_Inside.IsOutside(((Component)this).transform.position + Vector3.up * 0.2f, Quaternion.identity, outsideLookupDirs);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer && info.fromDisk && info.msg.beehive != null)
		{
			createNewCombAccumulator = info.msg.beehive.currentProgress;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.beehive = Pool.Get<Beehive>();
		info.msg.beehive.currentProgress = createNewCombAccumulator;
		if (!info.forDisk)
		{
			info.msg.beehive.temperature = serverTemperature;
			info.msg.beehive.inside = serverOutside;
			info.msg.beehive.humidity = serverHumidity;
		}
	}

	public override void OnItemRemovedFromStack(Item item, int amount)
	{
		base.OnItemRemovedFromStack(item, amount);
		OnItemAddedOrRemoved(item, added: false);
	}

	public override void OnItemAddedToStack(Item item, int amount)
	{
		base.OnItemAddedToStack(item, amount);
		OnItemAddedOrRemoved(item, added: true);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		base.OnItemAddedOrRemoved(item, added);
		CheckNucleus();
		float num = base.inventory.GetAmount(HoneyCombDefinition.itemid, onlyUsableAmounts: false);
		SetFlag(Flags.Reserved13, num > 0f && hasNucleus);
		if (!added && (Object)(object)item.info == (Object)(object)HoneyCombDefinition)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(base.LastLootedBy);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsAlive() && !basePlayer.IsNpc && basePlayer.isServer)
			{
				timeSinceAngryBees = TimeSince.op_Implicit(0f);
				SetFlag(Flags.Reserved14, b: true);
			}
		}
		if (base.inventory.IsFull(checkForPartialStacks: true))
		{
			StopHive();
		}
	}

	private void OnPhysicsNeighbourChanged()
	{
		TimeWarning val = TimeWarning.New("Beehive.OnPhysicsNeighbourChanged", 0);
		try
		{
			CalculateQualifiers(force: true);
			SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		if (!base.isClient)
		{
			CheckNucleus();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		CalculateQualifiers(force: true);
		CheckNucleus();
		((FacepunchBehaviour)this).InvokeRepeating((Action)HiveUpdateTick, 0f, 1f);
		SplashableStaticGrid.RegisterSplashable(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		SplashableStaticGrid.DeregisterSplashable(this);
	}

	public void OnHeatSourceChanged()
	{
		CalculateQualifiers(force: true);
		SendNetworkUpdate();
	}

	private void HiveUpdateTick()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(timeSinceAngryBees) > beeStingTime)
		{
			SetFlag(Flags.Reserved14, b: false);
		}
	}

	private void GenerateHoneyComb()
	{
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		float num = base.inventory.GetAmount(HoneyCombDefinition.itemid, onlyUsableAmounts: false);
		SetFlag(Flags.Reserved13, num > 0f && hasNucleus);
		createNewCombAccumulator += growthRate * honeyCombProductionMultiplier;
		if (!(createNewCombAccumulator >= 1f))
		{
			return;
		}
		createNewCombAccumulator = 0f;
		if (hasNucleus)
		{
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				int dataInt = slot.instanceData.dataInt;
				if (NucleusGrading.XpToGrade(dataInt) != NucleusGrading.NucleusGrade.Grade1)
				{
					dataInt += xpIncreasePerHoneycomb;
					SetNucleusData(slot, dataInt);
				}
			}
		}
		Item item = ItemManager.Create(HoneyCombDefinition, 1, 0uL);
		if (!item.MoveToContainer(base.inventory))
		{
			StopHive();
			item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (targetSlot == 0)
		{
			return item.info.shortname.Equals(allowedItem.shortname);
		}
		if (targetSlot > 0)
		{
			return item.info.shortname.Equals(allowedItem2.shortname);
		}
		return base.ItemFilter(item, targetSlot);
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		return (Object)(object)splashType == (Object)(object)WaterTypes.RadioactiveWaterItemDef;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		if ((Object)(object)splashType == (Object)(object)WaterTypes.RadioactiveWaterItemDef)
		{
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				hasNucleus = (Object)(object)((Component)slot.info).GetComponent<ItemModBeehiveNucleus>() != (Object)null;
				if (hasNucleus)
				{
					base.inventory.Remove(slot);
					slot.Remove();
				}
			}
			return amount;
		}
		return amount;
	}

	private void SetNucleusData(Item targetItem, int xp)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		if (targetItem != null)
		{
			targetItem.instanceData = new InstanceData
			{
				ShouldPool = false,
				dataInt = xp
			};
		}
	}

	private void CheckNucleus()
	{
		if (base.inventory == null)
		{
			return;
		}
		Item slot = base.inventory.GetSlot(0);
		if (slot != null)
		{
			hasNucleus = (Object)(object)((Component)slot.info).GetComponent<ItemModBeehiveNucleus>() != (Object)null;
			if (slot == null || slot.instanceData == null || (slot.instanceData.dataInt == 0 && slot.instanceData.dataFloat == 0f))
			{
				SetNucleusData(slot, 0);
			}
			createNewCombAccumulator = 0f;
		}
		else
		{
			hasNucleus = false;
		}
		SetFlag(Flags.Reserved12, hasNucleus);
		if (hasNucleus)
		{
			StartHive();
		}
		else
		{
			StopHive();
		}
	}

	private void StartHive()
	{
		if (!((FacepunchBehaviour)this).IsInvoking((Action)UpdateGrowthRate))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateGrowthRate, 0f, updateHiveInterval);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)GenerateHoneyComb))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)GenerateHoneyComb, updateHiveInterval, updateHiveInterval);
		}
		SetFlag(Flags.On, b: true);
		CalculateQualifiers(force: true);
		SendNetworkUpdate();
	}

	private void StopHive()
	{
		if (((FacepunchBehaviour)this).IsInvoking((Action)UpdateGrowthRate))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateGrowthRate);
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)GenerateHoneyComb))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)GenerateHoneyComb);
		}
		SetFlag(Flags.On, b: false);
		SendNetworkUpdate();
	}

	public float CalculateRain()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			SingletonComponent<NpcFireManager>.Instance.GetFiresAround(((Component)this).transform.position, 2f, (List<BaseEntity>)(object)val);
			if (((List<BaseEntity>)(object)val).Count > 0)
			{
				return 0f;
			}
			if (!IsOutside())
			{
				return 0f;
			}
			return Climate.GetRain(((Component)this).transform.position);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public float CalculateTemperature()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		float temperature = Climate.GetTemperature(((Component)this).transform.position);
		float num = GrowableEntity.CalculateArtificialTemperature(((Component)this).transform);
		bool flag = num >= 10f;
		bool flag2 = temperature < 10f;
		bool flag3 = temperature < 16f && !flag2;
		if (flag)
		{
			if (flag3)
			{
				return 20f;
			}
			if (flag2)
			{
				return 16f;
			}
		}
		return temperature + num;
	}

	private void CalculateQualifiers(bool force = false)
	{
		TimeWarning val = TimeWarning.New("Beehive.CalculateQualifiers", 0);
		try
		{
			if (temperatureExposure == null)
			{
				temperatureExposure = new TimeCachedValue<float>
				{
					refreshCooldown = updateHiveStatsInterval,
					refreshRandomRange = 5f,
					updateValue = CalculateTemperature
				};
			}
			if (outsideCheck == null)
			{
				outsideCheck = new TimeCachedValue<bool>
				{
					refreshCooldown = updateHiveStatsInterval,
					refreshRandomRange = 5f,
					updateValue = IsOutsideAccurate
				};
			}
			if (humidityExposure == null)
			{
				humidityExposure = new TimeCachedValue<float>
				{
					refreshCooldown = updateHiveStatsInterval,
					refreshRandomRange = 5f,
					updateValue = CalculateRain
				};
			}
			serverHumidity = humidityExposure.Get(force);
			serverTemperature = temperatureExposure.Get(force);
			serverOutside = outsideCheck.Get(force);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void UpdateGrowthRate()
	{
		TimeWarning val = TimeWarning.New("Beehive.UpdateGrowthRate", 0);
		try
		{
			CalculateQualifiers();
			float num = serverTemperature;
			float num2 = ((num < 28f) ? ((num < 10f) ? 0.010000001f : ((!(num < 16f)) ? 0.1f : 0.05f)) : ((!(num < 40f)) ? 0.010000001f : 0.05f));
			growthRate = num2;
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				switch (NucleusGrading.XpToGrade(slot.instanceData.dataInt))
				{
				case NucleusGrading.NucleusGrade.Grade2:
					growthRate *= 2f;
					break;
				case NucleusGrading.NucleusGrade.Grade1:
					growthRate *= 3f;
					break;
				}
			}
			if (serverHumidity >= 0.5f)
			{
				growthRate *= 0.5f;
			}
			if (!serverOutside)
			{
				growthRate = 0f;
			}
			SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void DropItems(BaseEntity initiator = null)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		int index = -1;
		for (int i = 0; i < base.inventory.itemList.Count; i++)
		{
			if ((Object)(object)base.inventory.itemList[i].info == (Object)(object)BeeNucleusDefinition)
			{
				flag = true;
				index = i;
			}
		}
		if (flag && base.inventory.Remove(base.inventory.itemList[index]))
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(masterSwarm.resourcePath, ((Component)this).transform.position + Vector3.up * 1.5f, Quaternion.identity);
			if (creatorEntity is BasePlayer basePlayer)
			{
				baseEntity.creatorEntity = basePlayer;
				baseEntity.OwnerID = basePlayer.userID;
			}
			baseEntity.Spawn();
		}
		base.DropItems(initiator);
	}

	static Beehive()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = new Vector3[5];
		Vector3 val = new Vector3(0f, 1f, 0f);
		array[0] = ((Vector3)(ref val)).normalized;
		val = new Vector3(1f, 0f, 0f);
		array[1] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, 1f);
		array[2] = ((Vector3)(ref val)).normalized;
		val = new Vector3(-1f, 0f, 0f);
		array[3] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, -1f);
		array[4] = ((Vector3)(ref val)).normalized;
		outsideLookupDirs = (Vector3[])(object)array;
	}
}


using UnityEngine;

public class BeehiveLootPanel : LootPanel
{
	[Header("Info Bars")]
	public InfoBar Indoors;

	public InfoBar Humidity;

	public InfoBar Temperature;

	public InfoBar Overall;

	[Header("Grids")]
	public LootGrid LootGrid_Input;

	public LootGrid LootGrid_Output;

	[Header("Status")]
	public StatusPanel status;

	public static readonly Phrase YesIndoors = new Phrase("beehive.indoors.yes", "YES");

	public static readonly Phrase NoIndoors = new Phrase("beehive.indoors.no", "NO");
}


public class BoatBuildingNetting : BaseMonoBehaviour
{
}


using UnityEngine;

public class Plank : DecayEntity, IBoatBuildingPiece
{
	[Header("Plank")]
	public TriggerParent ParentTrigger;

	void IBoatBuildingPiece.OnAddedToBoat(PlayerBoat boat)
	{
		if (Object.op_Implicit((Object)(object)ParentTrigger))
		{
			ParentTrigger.associatedMountable = boat;
		}
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (base.ShouldDisplayPickupOption(player))
		{
			return !PlayerBoat.IsChildOfFinishedPlayerBoat(this);
		}
		return false;
	}

	public override void Hurt(HitInfo info)
	{
		PlayerBoat parentPlayerBoat = PlayerBoat.GetParentPlayerBoat(this);
		if ((Object)(object)parentPlayerBoat != (Object)null)
		{
			parentPlayerBoat.OnBoatDeployableHurt(this, info);
		}
		else
		{
			base.Hurt(info);
		}
	}
}


using UnityEngine;

public class Construction_Sail : Construction
{
	public GameObject WindBlockedPrefab;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SmallRamp : Door, IBoatBuildingPiece
{
	[Header("SmallRamp")]
	public TriggerParent ParentTrigger;

	protected override bool IgnoreBlockageDotCheck => true;

	public void OnAddedToBoat(PlayerBoat boat)
	{
		if (Object.op_Implicit((Object)(object)ParentTrigger))
		{
			ParentTrigger.associatedMountable = boat;
		}
	}

	private bool IsBoundsClearOfWorldObstacles()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return !GamePhysics.CheckOBBAndEntity(WorldSpaceBounds(), 65536, (QueryTriggerInteraction)0, this);
	}

	protected override void ReverseDoorAnimation(bool wasOpening, bool reverse)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		AnimatorStateInfo currentAnimatorStateInfo = model.animator.GetCurrentAnimatorStateInfo(0);
		model.animator.Play("small_ramp_raise", 0, 1f - ((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime);
	}

	protected override bool CheckOnClose()
	{
		return false;
	}

	protected override bool OnlyCheckForVehicles()
	{
		return false;
	}

	public override void StabilityCheck()
	{
		GroundWatch groundWatch = default(GroundWatch);
		if (((Component)this).TryGetComponent<GroundWatch>(ref groundWatch))
		{
			groundWatch.DirectCallOnPhysicsNeighbourChanged();
		}
	}

	protected override void OnPlayerClosedDoor(BasePlayer player)
	{
		base.OnPlayerClosedDoor(player);
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		foreach (BaseEntity child in children)
		{
			if (child is BasePlayer basePlayer && basePlayer.IsSleeping())
			{
				list.Add(basePlayer);
			}
		}
		foreach (BasePlayer ply in list)
		{
			ply.SetParent(null, worldPositionStays: true, sendImmediate: true);
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				ply.SetServerFall(wantsOn: true);
			}, 1.5f);
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	protected override bool CanDoorBeOpened()
	{
		if (base.CanDoorBeOpened())
		{
			return IsBoundsClearOfWorldObstacles();
		}
		return false;
	}

	public override void Hurt(HitInfo info)
	{
		PlayerBoat parentPlayerBoat = PlayerBoat.GetParentPlayerBoat(this);
		if ((Object)(object)parentPlayerBoat != (Object)null)
		{
			parentPlayerBoat.OnBoatDeployableHurt(this, info);
		}
		else
		{
			base.Hurt(info);
		}
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (base.ShouldDisplayPickupOption(player))
		{
			return !PlayerBoat.IsChildOfInteractablePlayerBoat(this);
		}
		return false;
	}
}


public interface IAdminUpdatableIdentifier
{
	void Server_AdminUpdateIdentifier(BaseEntity.RPCMessage msg);
}


using UnityEngine;

public class IdentifierConfig : IOConfig<IRemoteControllable>
{
	[HideInInspector]
	public string id;
}


using System;

[Flags]
public enum RemoteControllableControls
{
	None = 0,
	Movement = 1,
	Mouse = 2,
	SprintAndDuck = 4,
	Fire = 8,
	Reload = 0x10,
	Crosshair = 0x20
}


using UnityEngine;

public interface IRemoteControllable
{
	bool RequiresMouse { get; }

	float MaxRange { get; }

	RemoteControllableControls RequiredControls { get; }

	CameraViewerId? ControllingViewerId { get; }

	bool CanPing { get; }

	Transform GetEyes();

	float GetFovScale();

	BaseEntity GetEnt();

	string GetIdentifier();

	float Health();

	float MaxHealth();

	void UpdateIdentifier(string newID, bool clientSend = false);

	void RCSetup();

	void RCShutdown();

	bool CanControl(ulong playerID);

	void UserInput(InputState inputState, CameraViewerId viewerID);

	bool InitializeControl(CameraViewerId viewerID);

	void StopControl(CameraViewerId viewerID);
}


using System;

public struct CameraViewerId : IEquatable<CameraViewerId>
{
	public readonly ulong SteamId;

	public readonly long ConnectionId;

	public CameraViewerId(ulong steamId, long connectionId)
	{
		SteamId = steamId;
		ConnectionId = connectionId;
	}

	public bool Equals(CameraViewerId other)
	{
		if (SteamId == other.SteamId)
		{
			return ConnectionId == other.ConnectionId;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is CameraViewerId other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		ulong steamId = SteamId;
		int num = steamId.GetHashCode() * 397;
		long connectionId = ConnectionId;
		return num ^ connectionId.GetHashCode();
	}

	public static bool operator ==(CameraViewerId left, CameraViewerId right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(CameraViewerId left, CameraViewerId right)
	{
		return !left.Equals(right);
	}
}


public class ClanTable : BaseCombatEntity
{
}


using System;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class Composter : StorageContainer
{
	[Header("Composter")]
	public ItemDefinition FertilizerDef;

	[Tooltip("If enabled, entire item stacks will be composted each tick, instead of a single item of a stack.")]
	public bool CompostEntireStack;

	public float fertilizerProductionProgress;

	protected float UpdateInterval => Server.composterUpdateInterval;

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(InventoryItemFilter));
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateComposting, UpdateInterval, UpdateInterval, UpdateInterval * 0.1f);
	}

	public bool InventoryItemFilter(Item item, int targetSlot)
	{
		if (item == null)
		{
			return false;
		}
		if ((Object)(object)((Component)item.info).GetComponent<ItemModCompostable>() != (Object)null || ItemIsFertilizer(item))
		{
			return true;
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.composter = Pool.Get<Composter>();
		info.msg.composter.fertilizerProductionProgress = fertilizerProductionProgress;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.composter != null)
		{
			fertilizerProductionProgress = info.msg.composter.fertilizerProductionProgress;
		}
	}

	public bool ItemIsFertilizer(Item item)
	{
		return item.info.shortname == "fertilizer";
	}

	public void UpdateComposting()
	{
		if (Interface.CallHook("OnComposterUpdate", (object)this) != null)
		{
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				CompostItem(slot);
			}
		}
	}

	public void CompostItem(Item item)
	{
		if (!ItemIsFertilizer(item))
		{
			ItemModCompostable component = ((Component)item.info).GetComponent<ItemModCompostable>();
			if (!((Object)(object)component == (Object)null))
			{
				int num = ((!CompostEntireStack) ? 1 : item.amount);
				item.UseItem(num);
				fertilizerProductionProgress += (float)num * component.TotalFertilizerProduced;
				ProduceFertilizer(Mathf.FloorToInt(fertilizerProductionProgress));
			}
		}
	}

	public void ProduceFertilizer(int amount)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (amount > 0)
		{
			Item item = ItemManager.Create(FertilizerDef, amount, 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
			fertilizerProductionProgress -= amount;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ComputerMenu : UIDialog
{
	public RectTransform bookmarkContainer;

	public GameObject bookmarkPrefab;

	public List<RCBookmarkEntry> activeEntries = new List<RCBookmarkEntry>();
}


using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class RCBookmarkEntry : MonoBehaviour
{
	private ComputerMenu owner;

	public RectTransform connectButton;

	public RectTransform disconnectButton;

	public RawImage onlineIndicator;

	public RawImage offlineIndicator;

	public GameObject selectedindicator;

	public Image backgroundImage;

	public Color selectedColor;

	public Color activeColor;

	public Color inactiveColor;

	public Text nameLabel;

	public EventTrigger eventTrigger;

	public string identifier { get; private set; }

	public bool isSelected { get; private set; }

	public bool isControlling { get; private set; }
}


public interface IRemoteControllablePromptProvider
{
}


public interface IRemoteControllableHostileProvider
{
}


public interface IRemoteControllableClientCallbacks : IRemoteControllable
{
}


using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

public class RCMenu : ComputerMenu
{
	public Image backgroundOpaque;

	public InputField newBookmarkEntryField;

	public NeedsCursor needsCursor;

	public float hiddenOffset = -256f;

	public RectTransform devicesPanel;

	private Vector3 initialDevicesPosition;

	public static bool isControllingCamera;

	public CanvasGroup overExposure;

	public CanvasGroup interference;

	public float interferenceFadeDuration = 0.2f;

	public float rangeInterferenceScale = 10000f;

	public Text timeText;

	public Text watchedDurationText;

	public Text deviceNameText;

	public Text noSignalText;

	public Text primaryActionPrompt;

	public Text hostileText;

	public Text healthText;

	public GameObject healthBarParent;

	public RectTransform healthBarBackground;

	public RectTransform healthBarFill;

	public SoundDefinition bookmarkPressedSoundDef;

	public GameObject[] hideIfStatic;

	public GameObject readOnlyIndicator;

	[FormerlySerializedAs("crosshair")]
	public GameObject aimCrosshair;

	public GameObject generalCrosshair;

	public float fogOverrideDensity = 0.1f;

	public float autoTurretFogDistance = 30f;

	public float autoTurretDotBaseScale = 2f;

	public float autoTurretDotGrowScale = 4f;

	public PingManager PingManager;

	public ScrollRectSettable scrollRect;

	public Phrase Phrase_NoSignal = new Phrase("no_signal", "No Signal");

	public Phrase Phrase_CameraDisabled = new Phrase("weak_signal", "Weak Signal");
}


using Rust;
using UnityEngine;

public class CookingWorkbench : MixingTable
{
	public GameObjectRef SubOvenPrefab;

	public Transform SubOvenPosition;

	[Tooltip("The recipes that will set the OvenCooking flag (to play the oven effects)")]
	public ItemDefinition[] ovenCookingFlagItems;

	public const Flags OvenCooking = Flags.Reserved9;

	public const Flags MixingTea = Flags.Reserved10;

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!base.isServer || next.HasFlag(Flags.On) == old.HasFlag(Flags.On))
		{
			return;
		}
		string text = (((Object)(object)currentRecipe != (Object)null) ? currentRecipe.ProducedItem.shortname : currentProductionItem?.shortname);
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		bool flag = GetChildBbq().IsOn();
		ItemDefinition[] array = ovenCookingFlagItems;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].shortname == text)
			{
				SetFlag(Flags.Reserved9, next.HasFlag(Flags.On) || flag);
				return;
			}
		}
		SetFlag(Flags.Reserved10, next.HasFlag(Flags.On));
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		SpawnOven();
	}

	private void SpawnOven()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)GetChildBbq() != (Object)null) && SubOvenPrefab.isValid)
		{
			BaseEntity baseEntity = base.gameManager.CreateEntity(SubOvenPrefab.resourcePath, SubOvenPosition.position, SubOvenPosition.rotation);
			baseEntity.SetParent(this, worldPositionStays: true);
			((Component)baseEntity).transform.localPosition = SubOvenPosition.localPosition;
			((Component)baseEntity).transform.localRotation = SubOvenPosition.localRotation;
			baseEntity.Spawn();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SpawnOven();
		}
	}

	private CookingWorkbenchBbq GetChildBbq()
	{
		foreach (BaseEntity child in children)
		{
			if (child is CookingWorkbenchBbq result)
			{
				return result;
			}
		}
		return null;
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		CookingWorkbenchBbq childBbq = GetChildBbq();
		if ((Object)(object)childBbq != (Object)null && childBbq.inventory != null && !childBbq.inventory.IsEmpty())
		{
			pickupErrorToFormat = (format: PickupErrors.ItemInventoryMustBeEmpty, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	internal override void DoServerDestroy()
	{
		CookingWorkbenchBbq childBbq = GetChildBbq();
		if ((Object)(object)childBbq != (Object)null)
		{
			childBbq.DropItems();
			childBbq.Kill();
		}
		base.DoServerDestroy();
	}
}


using UnityEngine;

public class CookingWorkbenchBbq : BaseOven
{
	private CookingWorkbench ParentBench
	{
		get
		{
			if (!parentEntity.IsValid(base.isServer))
			{
				return null;
			}
			return parentEntity.Get(base.isServer) as CookingWorkbench;
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if ((Object)(object)ParentBench != (Object)null && base.isServer)
		{
			ParentBench.Hurt(info);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && next.HasFlag(Flags.On) != old.HasFlag(Flags.On))
		{
			CookingWorkbench parentBench = ParentBench;
			if ((Object)(object)parentBench != (Object)null)
			{
				bool b = (parentBench.IsOn() ? parentBench.IsOn() : next.HasFlag(Flags.On));
				parentBench.SetFlag(Flags.Reserved9, b);
			}
		}
	}

	public override void AdminKill()
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			baseEntity.AdminKill();
		}
	}
}


using System;
using Facepunch;
using UnityEngine;

public class DroneStorage : StorageContainer
{
	[Header("Drone Storage")]
	public Transform AttachPoint;

	public Vector3 ReleaseVelocity;

	public float GrenadeWeaponDelayMod = 3f;

	public float ThrownWeaponDelayMod = 1f;

	private static readonly Phrase FailPhrase = new Phrase("drone_storage.fail", "Drone is stuck, can't access inventory");

	private const float DroneBoxOffset = 0.14f;

	public Drone Drone { get; set; }

	public void UpdateFlags()
	{
		if (Drone.HasFlag(Flags.Reserved5))
		{
			if (!TryGetItem(out var item) || !TryGetHeldEntity(item, out var held) || !(held is ThrownWeapon thrownWeapon))
			{
				Drone.SetFlag(Flags.Reserved5, b: false);
			}
			else
			{
				Drone.SetFlag(Flags.Reserved5, thrownWeapon.HasAttackCooldown());
			}
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (!base.ItemFilter(item, targetSlot))
		{
			return false;
		}
		RaycastHit val = default(RaycastHit);
		if (!Drone.HasFlag(Flags.Reserved3) && Drone.body.SweepTest(((Component)Drone).transform.up, ref val, 0.14f))
		{
			return false;
		}
		return true;
	}

	public override PlayerInventory.CanMoveFromResponse CanMoveFrom(BasePlayer player, Item item)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Drone.body.SweepTest(((Component)Drone).transform.up, ref val, 0.14f))
		{
			return PlayerInventory.CanMoveFromResponse.Failure(FailPhrase);
		}
		return base.CanMoveFrom(player, item);
	}

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanOpenLootPanel(player, panelName))
		{
			return false;
		}
		RaycastHit val = default(RaycastHit);
		if (Drone.body.SweepTest(((Component)Drone).transform.up, ref val, 0.14f))
		{
			player.ShowToast(GameTip.Styles.Error, FailPhrase, false);
			return false;
		}
		return true;
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		base.OnItemAddedOrRemoved(item, added);
		if (added && !Drone.HasFlag(Flags.Reserved2) && !Drone.HasFlag(Flags.Reserved3))
		{
			Rigidbody body = Drone.body;
			body.position += ((Component)Drone).transform.up * 0.14f;
		}
		Drone.body.WakeUp();
		Drone.body.isKinematic = false;
	}

	public bool TryServerDrop()
	{
		if (!TryGetItem(out var item))
		{
			return false;
		}
		bool flag = false;
		if (TryGetHeldEntity(item, out var held) && held is ThrownWeapon weapon)
		{
			return TryServerWeaponDrop(base.inventory.GetSlot(0), weapon);
		}
		return TryServerItemDrop(base.inventory.GetSlot(0));
	}

	private bool TryGetItem(out Item item)
	{
		item = null;
		if (base.inventory.IsEmpty())
		{
			return false;
		}
		item = base.inventory.GetSlot(0);
		if (item == null)
		{
			return false;
		}
		return true;
	}

	private bool TryGetHeldEntity(Item item, out BaseEntity held)
	{
		held = null;
		if (item == null)
		{
			return false;
		}
		held = item.GetHeldEntity();
		if ((Object)(object)held == (Object)null)
		{
			return false;
		}
		return true;
	}

	private bool TryServerWeaponDrop(Item item, ThrownWeapon weapon)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		if (item.amount <= 0 || weapon.HasAttackCooldown())
		{
			return false;
		}
		if ((Object)(object)Drone == (Object)null)
		{
			return false;
		}
		Vector3 eyePos = default(Vector3);
		Quaternion val = default(Quaternion);
		AttachPoint.GetPositionAndRotation(ref eyePos, ref val);
		Vector3 throwVelocityOverride = GetInheritedThrowVelocity(val * Vector3.down) + ReleaseVelocity;
		BasePlayer owningPlayer = Drone.ToPlayer();
		weapon.DoThrowImpl(eyePos, val * Vector3.down, owningPlayer, out var thrownEntity, 1f, throwVelocityOverride, item);
		if (weapon is GrenadeWeapon)
		{
			weapon.StartAttackCooldown(weapon.repeatDelay * GrenadeWeaponDelayMod);
		}
		else
		{
			weapon.StartAttackCooldown(weapon.repeatDelay * ThrownWeaponDelayMod);
		}
		item.UseItem();
		TempIgnoreParent(thrownEntity);
		Drone.MarkHostileFor();
		if (weapon.HasAttackCooldown())
		{
			Drone.SetFlag(Flags.Reserved5, b: true);
		}
		SendNetworkUpdateImmediate();
		return true;
	}

	private bool TryServerItemDrop(Item item)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vPos = default(Vector3);
		Quaternion val = default(Quaternion);
		AttachPoint.GetPositionAndRotation(ref vPos, ref val);
		BaseEntity ent = item.Drop(vPos, GetInheritedProjectileVelocity(val * Vector3.down) + ReleaseVelocity);
		TempIgnoreParent(ent);
		return true;
	}

	private void TempIgnoreParent(BaseEntity ent)
	{
		if ((Object)(object)ent == (Object)null || !parentEntity.IsValid(serverside: true))
		{
			return;
		}
		GameObjectExtensions.SetIgnoreCollisions(((Component)ent).gameObject, ((Component)parentEntity.Get(serverside: true)).gameObject, true);
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			BaseEntity baseEntity = ent;
			if (!((Object)(object)baseEntity == (Object)null))
			{
				BaseEntity baseEntity2 = parentEntity.Get(serverside: true);
				if (!((Object)(object)baseEntity2 == (Object)null))
				{
					GameObjectExtensions.SetIgnoreCollisions(((Component)baseEntity2).gameObject, ((Component)baseEntity).gameObject, false);
				}
			}
		}, 2f);
	}
}


using UnityEngine;

public class DropBox : Mailbox
{
	public Transform EyePoint;

	public override bool PlayerIsOwner(BasePlayer player)
	{
		return PlayerBehind(player);
	}

	public bool PlayerBehind(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		float num = Vector3.Dot(forward, ((Vector3)(ref val)).normalized);
		bool flag = GamePhysics.LineOfSight(player.eyes.position, EyePoint.position, 2162688);
		return num <= 0f && flag;
	}

	public bool PlayerInfront(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(forward, ((Vector3)(ref val)).normalized) >= 0.7f;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}
}


using UnityEngine;

public interface IEaselPaintable
{
	GameObject GameObject { get; }

	NetworkableId EaselId { get; set; }

	EaselDeployable parentEasel { get; }

	void AddToEasel(BaseEntity parent);

	void RemoveFromEasel();

	void SaveSignageToItem(Item createdItem);
}


using System;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class Elevator : IOEntity, IFlagNotify
{
	public enum Direction
	{
		Up,
		Down
	}

	public Transform LiftRoot;

	public GameObjectRef LiftEntityPrefab;

	public Transform IoEntitySpawnPoint;

	public GameObject FloorBlockerVolume;

	public float LiftSpeedPerMetre = 1f;

	public GameObject[] PoweredObjects;

	public MeshRenderer PoweredMesh;

	[ColorUsage(true, true)]
	public Color PoweredLightColour;

	[ColorUsage(true, true)]
	public Color UnpoweredLightColour;

	public float LiftMoveDelay;

	public float LiftEndMoveDelay = 1f;

	protected const Flags TopFloorFlag = Flags.Reserved1;

	public EntityRef<ElevatorLift> liftEntity;

	public int[] previousPowerAmount = new int[3];

	public virtual bool IsStatic => false;

	public int Floor { get; set; }

	public bool IsTop => HasFlag(Flags.Reserved1);

	public virtual float FloorHeight => 3f;

	public override void Load(LoadInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.elevator != null)
		{
			Floor = info.msg.elevator.floor;
			liftEntity.uid = info.msg.elevator.spawnedLift;
		}
		if ((Object)(object)FloorBlockerVolume != (Object)null)
		{
			FloorBlockerVolume.SetActive(Floor > 0);
		}
	}

	public override int ConsumptionAmount()
	{
		return 5;
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		Elevator elevatorInDirection = GetElevatorInDirection(Direction.Down);
		if ((Object)(object)elevatorInDirection != (Object)null)
		{
			elevatorInDirection.SetFlag(Flags.Reserved1, b: false);
			Floor = elevatorInDirection.Floor + 1;
		}
		SetFlag(Flags.Reserved1, b: true);
		UpdateChildEntities(isTop: true);
		SendNetworkUpdate();
		RefreshPowerStatus();
	}

	public virtual void CallElevator()
	{
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			if (elevatorEnt.IsTop && Interface.CallHook("OnElevatorCall", (object)this, (object)elevatorEnt) == null)
			{
				elevatorEnt.RequestMoveLiftTo(Floor, out var _, this);
			}
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
	}

	public void Server_RaiseLowerElevator(Direction dir, bool goTopBottom)
	{
		if (IsBusy())
		{
			return;
		}
		int num = LiftPositionToFloor();
		switch (dir)
		{
		case Direction.Up:
			num++;
			if (goTopBottom)
			{
				num = Floor;
			}
			break;
		case Direction.Down:
			num--;
			if (goTopBottom)
			{
				num = 0;
			}
			break;
		}
		RequestMoveLiftTo(num, out var _, this);
	}

	public bool RequestMoveLiftTo(int targetFloor, out float timeToTravel, Elevator fromElevator)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		timeToTravel = 0f;
		if (Interface.CallHook("OnElevatorMove", (object)this, (object)targetFloor) != null)
		{
			return false;
		}
		if (IsBusy())
		{
			return false;
		}
		if (!IsStatic && !IsPowered())
		{
			return false;
		}
		if (!IsValidFloor(targetFloor))
		{
			return false;
		}
		int num = LiftPositionToFloor();
		if (num == targetFloor)
		{
			OpenDoorsAtFloor(num);
			return false;
		}
		if (!liftEntity.IsValid(base.isServer))
		{
			return false;
		}
		ElevatorLift elevatorLift = liftEntity.Get(base.isServer);
		if (!elevatorLift.CanMove())
		{
			return false;
		}
		Vector3 worldSpaceFloorPosition = GetWorldSpaceFloorPosition(targetFloor);
		if (!GamePhysics.LineOfSight(((Component)elevatorLift).transform.position, worldSpaceFloorPosition, 2097152))
		{
			return false;
		}
		OnMoveBegin();
		timeToTravel = TimeToTravelDistance(Mathf.Abs(((Component)elevatorLift).transform.position.y - worldSpaceFloorPosition.y));
		LeanTween.moveY(((Component)elevatorLift).gameObject, worldSpaceFloorPosition.y, timeToTravel).delay = LiftMoveDelay;
		timeToTravel += LiftMoveDelay;
		SetFlag(Flags.Busy, b: true);
		if (targetFloor < Floor)
		{
			elevatorLift.ToggleHurtTrigger(state: true);
		}
		elevatorLift.SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ClearBusy, timeToTravel + LiftEndMoveDelay);
		elevatorLift.NotifyNewFloor(targetFloor, Floor);
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			elevatorEnt.SetFlag(Flags.Busy, b: true);
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
		return true;
	}

	protected virtual void OpenLiftDoors()
	{
		NotifyLiftEntityDoorsOpen(state: true);
	}

	public virtual void OnMoveBegin()
	{
	}

	public float TimeToTravelDistance(float distance)
	{
		return distance / LiftSpeedPerMetre;
	}

	public virtual Vector3 GetWorldSpaceFloorPosition(int targetFloor)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		int num = Floor - targetFloor;
		Vector3 val = Vector3.up * ((float)num * FloorHeight);
		val.y -= 1f;
		return ((Component)this).transform.position - val;
	}

	public virtual void ClearBusy()
	{
		SetFlag(Flags.Busy, b: false);
		if (liftEntity.IsValid(base.isServer))
		{
			liftEntity.Get(base.isServer).ToggleHurtTrigger(state: false);
			liftEntity.Get(base.isServer).SetFlag(Flags.Busy, b: false);
		}
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			elevatorEnt.SetFlag(Flags.Busy, b: false);
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
	}

	public virtual bool IsValidFloor(int targetFloor)
	{
		if (targetFloor <= Floor)
		{
			return targetFloor >= 0;
		}
		return false;
	}

	public Elevator GetElevatorInDirection(Direction dir)
	{
		EntityLink entityLink = FindLink((dir == Direction.Down) ? "elevator/sockets/elevator-male" : "elevator/sockets/elevator-female");
		if (entityLink != null && !entityLink.IsEmpty())
		{
			BaseEntity owner = entityLink.connections[0].owner;
			if ((Object)(object)owner != (Object)null && owner.isServer && owner is Elevator elevator && (Object)(object)elevator != (Object)(object)this)
			{
				return elevator;
			}
		}
		return null;
	}

	public void UpdateChildEntities(bool isTop)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (isTop)
		{
			if (!liftEntity.IsValid(base.isServer))
			{
				FindExistingLiftChild();
			}
			if (!liftEntity.IsValid(base.isServer))
			{
				ElevatorLift elevatorLift = GameManager.server.CreateEntity(LiftEntityPrefab.resourcePath, GetWorldSpaceFloorPosition(Floor), LiftRoot.rotation) as ElevatorLift;
				elevatorLift.SetOwnerElevator(this);
				elevatorLift.Spawn();
				liftEntity.Set(elevatorLift);
			}
			if (liftEntity.IsValid(base.isServer))
			{
				if ((Object)(object)liftEntity.Get(base.isServer).GetParentEntity() == (Object)(object)this)
				{
					liftEntity.Get(base.isServer).SetParent(null, worldPositionStays: true);
				}
				liftEntity.Get(base.isServer).SetOwnerElevator(this);
				liftEntity.Get(base.isServer).SetFlag(Flags.Reserved5, IsPowered() || IsStatic);
			}
		}
		else if (liftEntity.IsValid(base.isServer))
		{
			liftEntity.Get(base.isServer).Kill();
			liftEntity.Set(null);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.elevator == null)
		{
			info.msg.elevator = Pool.Get<Elevator>();
		}
		info.msg.elevator.floor = Floor;
		info.msg.elevator.spawnedLift = liftEntity.uid;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		return 5;
	}

	public int LiftPositionToFloor()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (!liftEntity.IsValid(base.isServer))
		{
			return 0;
		}
		Vector3 position = ((Component)liftEntity.Get(base.isServer)).transform.position;
		int result = -1;
		float num = float.MaxValue;
		for (int i = 0; i <= Floor; i++)
		{
			float num2 = Vector3.Distance(GetWorldSpaceFloorPosition(i), position);
			if (num2 < num)
			{
				num = num2;
				result = i;
			}
		}
		return result;
	}

	public override void DestroyShared()
	{
		Cleanup();
		base.DestroyShared();
	}

	private void Cleanup()
	{
		Elevator elevatorInDirection = GetElevatorInDirection(Direction.Down);
		if ((Object)(object)elevatorInDirection != (Object)null)
		{
			elevatorInDirection.SetFlag(Flags.Reserved1, b: true);
		}
		Elevator elevatorInDirection2 = GetElevatorInDirection(Direction.Up);
		if ((Object)(object)elevatorInDirection2 != (Object)null)
		{
			elevatorInDirection2.Kill(DestroyMode.Gib);
		}
		previousPowerAmount[2] = 0;
		RefreshPowerStatus();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Busy, b: false);
		UpdateChildEntities(IsTop);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputAmount > 0 && (inputSlot == 0 || inputSlot == 1) && previousPowerAmount[inputSlot] == 0)
		{
			CallElevator();
		}
		if (inputSlot == 2 && previousPowerAmount[inputSlot] != inputAmount)
		{
			previousPowerAmount[inputSlot] = inputAmount;
			SetFlag(Flags.Reserved8, HasPowerInput());
			RefreshPowerStatus();
		}
		previousPowerAmount[inputSlot] = inputAmount;
	}

	private void RefreshPowerStatus()
	{
		bool anyHasPower = false;
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			if (elevatorEnt.HasPowerInput())
			{
				anyHasPower = true;
			}
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			elevatorEnt.SetFlag(Flags.Reserved8, anyHasPower);
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
	}

	private bool HasPowerInput()
	{
		return previousPowerAmount[2] >= ConsumptionAmount();
	}

	private void OnPhysicsNeighbourChanged()
	{
		if (!IsStatic && (Object)(object)GetElevatorInDirection(Direction.Down) == (Object)null && !HasFloorSocketConnection())
		{
			Kill(DestroyMode.Gib);
		}
	}

	public bool HasFloorSocketConnection()
	{
		EntityLink entityLink = FindLink("elevator/sockets/block-male");
		if (entityLink != null && !entityLink.IsEmpty())
		{
			return true;
		}
		return false;
	}

	public void NotifyLiftEntityDoorsOpen(bool state)
	{
		if (!liftEntity.IsValid(base.isServer))
		{
			return;
		}
		foreach (BaseEntity child in liftEntity.Get(base.isServer).children)
		{
			if (child is Door door)
			{
				door.SetOpen(state);
			}
		}
	}

	protected virtual void OpenDoorsAtFloor(int floor)
	{
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if ((Object)(object)liftEntity.Get(base.isServer) != (Object)null)
		{
			liftEntity.Get(base.isServer).Kill();
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)liftEntity.Get(base.isServer) != (Object)null)
		{
			liftEntity.Get(base.isServer).Kill(DestroyMode.Gib);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!Application.isLoading && base.isServer && old.HasFlag(Flags.Reserved1) != next.HasFlag(Flags.Reserved1))
		{
			UpdateChildEntities(next.HasFlag(Flags.Reserved1));
			SendNetworkUpdate();
		}
		if (base.isServer)
		{
			ElevatorLift elevatorLift = liftEntity.Get(base.isServer);
			if ((Object)(object)elevatorLift != (Object)null)
			{
				elevatorLift.SetFlag(Flags.Reserved5, IsPowered() || IsStatic);
			}
		}
		if (old.HasFlag(Flags.Reserved1) != next.HasFlag(Flags.Reserved1) && (Object)(object)FloorBlockerVolume != (Object)null)
		{
			FloorBlockerVolume.SetActive(next.HasFlag(Flags.Reserved1));
		}
		OnFlagToggled(next.HasFlag(Flags.Reserved8));
	}

	public void FindExistingLiftChild()
	{
		foreach (BaseEntity child in children)
		{
			if (child is ElevatorLift entity)
			{
				liftEntity.Set(entity);
				break;
			}
		}
	}

	public void OnFlagToggled(bool state)
	{
	}
}


public enum Direction
{
	Up,
	Down
}


using System;
using UnityEngine;

public class ElevatorButton : MonoBehaviour, IClientComponent
{
	[Flags]
	public enum ElevatorOption
	{
		GoUp = 1,
		GoUpExpress = 2,
		GoDown = 4,
		GoDownExpress = 8
	}

	public ElevatorOption AvailableActions;

	public Collider AttachedCollider;
}


using System;

[Flags]
public enum ElevatorOption
{
	GoUp = 1,
	GoUpExpress = 2,
	GoDown = 4,
	GoDownExpress = 8
}


using UnityEngine;

public class ElevatorLiftPlayer : ElevatorLift
{
	public Transform CableRoot;

	public Transform CableRootTop;

	public float CableRootOffset;

	public float CableRootTopOffset;
}


using Rust;
using UnityEngine;

public class ElevatorLiftStatic : ElevatorLift
{
	public GameObjectRef ElevatorDoorRef;

	public Transform ElevatorDoorLocation;

	public bool BlockPerFloorMovement;

	private const Flags CanGoUp = Flags.Reserved3;

	private const Flags CanGoDown = Flags.Reserved4;

	public override void ServerInit()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (ElevatorDoorRef.isValid && (Object)(object)ElevatorDoorLocation != (Object)null && !Application.isLoadingSave)
		{
			foreach (BaseEntity child in children)
			{
				if (child is Door)
				{
					return;
				}
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(ElevatorDoorRef.resourcePath, ElevatorDoorLocation.localPosition, ElevatorDoorLocation.localRotation);
			baseEntity.SetParent(this);
			baseEntity.Spawn();
		}
		SetFlag(Flags.Reserved3, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, b: true);
	}

	public override void NotifyNewFloor(int newFloor, int totalFloors)
	{
		base.NotifyNewFloor(newFloor, totalFloors);
		SetFlag(Flags.Reserved3, newFloor < totalFloors);
		SetFlag(Flags.Reserved4, newFloor > 0);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class ElevatorStatic : Elevator
{
	public bool StaticTop;

	public const Flags LiftRecentlyArrived = Flags.Reserved3;

	public List<ElevatorStatic> floorPositions = new List<ElevatorStatic>();

	public ElevatorStatic ownerElevator;

	public override bool IsStatic => true;

	public override void Spawn()
	{
		base.Spawn();
		SetFlag(Flags.Reserved8, b: true);
		SetFlag(Flags.Reserved1, StaticTop);
		if (!Application.isLoadingSave)
		{
			UpdateFloorPositions();
		}
	}

	private void UpdateFloorPositions()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!base.IsTop)
		{
			return;
		}
		floorPositions.Clear();
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(((Component)this).transform.position, -Vector3.up), 0f, list, 200f, 262144, (QueryTriggerInteraction)2);
		foreach (RaycastHit item in list)
		{
			RaycastHit current = item;
			if ((Object)(object)((RaycastHit)(ref current)).transform.parent != (Object)null)
			{
				ElevatorStatic component = ((Component)((RaycastHit)(ref current)).transform.parent).GetComponent<ElevatorStatic>();
				if (!((Object)(object)component == (Object)null) && !((Object)(object)component == (Object)(object)this) && !component.isClient && !component.IsDestroyed)
				{
					floorPositions.Add(component);
				}
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		floorPositions.Reverse();
		base.Floor = floorPositions.Count;
		for (int i = 0; i < floorPositions.Count; i++)
		{
			floorPositions[i].SetFloorDetails(i, this);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		((FacepunchBehaviour)this).Invoke((Action)UpdateFloorPositions, 1f);
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		UpdateChildEntities(base.IsTop);
	}

	public override bool IsValidFloor(int targetFloor)
	{
		if (targetFloor >= 0)
		{
			return targetFloor <= base.Floor;
		}
		return false;
	}

	public override Vector3 GetWorldSpaceFloorPosition(int targetFloor)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (targetFloor == base.Floor)
		{
			return ((Component)this).transform.position + Vector3.up * 1f;
		}
		Vector3 position = ((Component)this).transform.position;
		position.y = ((Component)floorPositions[targetFloor]).transform.position.y + 1f;
		return position;
	}

	public void SetFloorDetails(int floor, ElevatorStatic owner)
	{
		ownerElevator = owner;
		base.Floor = floor;
	}

	public override void CallElevator()
	{
		if ((Object)(object)ownerElevator != (Object)null)
		{
			ownerElevator.RequestMoveLiftTo(base.Floor, out var _, this);
		}
		else if (base.IsTop)
		{
			RequestMoveLiftTo(base.Floor, out var _, this);
		}
	}

	public ElevatorStatic ElevatorAtFloor(int floor)
	{
		if (floor == base.Floor)
		{
			return this;
		}
		if (floor >= 0 && floor < floorPositions.Count)
		{
			return floorPositions[floor];
		}
		return null;
	}

	protected override void OpenDoorsAtFloor(int floor)
	{
		base.OpenDoorsAtFloor(floor);
		if (floor == floorPositions.Count)
		{
			OpenLiftDoors();
		}
		else
		{
			floorPositions[floor].OpenLiftDoors();
		}
	}

	public override void OnMoveBegin()
	{
		base.OnMoveBegin();
		ElevatorStatic elevatorStatic = ElevatorAtFloor(LiftPositionToFloor());
		if ((Object)(object)elevatorStatic != (Object)null)
		{
			elevatorStatic.OnLiftLeavingFloor();
		}
		NotifyLiftEntityDoorsOpen(state: false);
	}

	public void OnLiftLeavingFloor()
	{
		ClearPowerOutput();
		if (((FacepunchBehaviour)this).IsInvoking((Action)ClearPowerOutput))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ClearPowerOutput);
		}
	}

	public override void ClearBusy()
	{
		base.ClearBusy();
		ElevatorStatic elevatorStatic = ElevatorAtFloor(LiftPositionToFloor());
		if ((Object)(object)elevatorStatic != (Object)null)
		{
			elevatorStatic.OnLiftArrivedAtFloor();
		}
		NotifyLiftEntityDoorsOpen(state: true);
	}

	protected override void OpenLiftDoors()
	{
		base.OpenLiftDoors();
		OnLiftArrivedAtFloor();
	}

	public void OnLiftArrivedAtFloor()
	{
		SetFlag(Flags.Reserved3, b: true);
		MarkDirty();
		((FacepunchBehaviour)this).Invoke((Action)ClearPowerOutput, 10f);
	}

	public void ClearPowerOutput()
	{
		SetFlag(Flags.Reserved3, b: false);
		MarkDirty();
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!HasFlag(Flags.Reserved3))
		{
			return 0;
		}
		return 1;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			SetFlag(Flags.Reserved3, b: false);
		}
	}
}


using UnityEngine;

public class FrankensteinTableVisuals : MonoBehaviour
{
	public GameObject FXReady;

	public GameObject FXNotReady;

	public GameObject FXWake;

	public Transform HeadVisualAnchor;

	public Transform TorsoVisualAnchor;

	public Transform LegsVisualAnchor;

	public Animator Animator;
}


using System;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class HitchTrough : StorageContainer
{
	[Serializable]
	public class HitchSpot
	{
		public HitchTrough owner;

		public Transform tr;

		public EntityRef hitchableEntRef;

		public IHitchable GetHitchable(bool isServer = true)
		{
			return hitchableEntRef.Get(isServer) as IHitchable;
		}

		public bool IsOccupied(bool isServer = true)
		{
			return hitchableEntRef.IsValid(isServer);
		}

		public void SetOccupiedBy(IHitchable hitchable)
		{
			if (hitchable == null)
			{
				hitchableEntRef.Set(null);
				return;
			}
			BaseEntity baseEntity = hitchable as BaseEntity;
			if ((Object)(object)baseEntity != (Object)null)
			{
				hitchableEntRef.Set(baseEntity);
			}
		}
	}

	public interface IHitchable
	{
		void SetHitch(HitchTrough hitch, HitchSpot spot);
	}

	public HitchSpot[] hitchSpots;

	public float caloriesToDecaySeconds = 36f;

	public override void PostServerLoad()
	{
		HitchSpot[] array = hitchSpots;
		foreach (HitchSpot hitchSpot in array)
		{
			AttemptToHitch(hitchSpot.GetHitchable(), hitchSpot);
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			UnHitchAll();
		}
		base.DestroyShared();
	}

	public Item GetFoodItem()
	{
		foreach (Item item in base.inventory.itemList)
		{
			if (item.info.category == ItemCategory.Food && Object.op_Implicit((Object)(object)((Component)item.info).GetComponent<ItemModConsumable>()))
			{
				return item;
			}
		}
		return null;
	}

	public bool HasSpace()
	{
		HitchSpot[] array = hitchSpots;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].IsOccupied())
			{
				return true;
			}
		}
		return false;
	}

	public bool IsValidHitchPosition(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetClosestSpot(pos, includeOccupied: false, 1f) != null;
	}

	public bool AttemptToHitch(IHitchable hitchable, HitchSpot spot = null)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (hitchable == null)
		{
			return false;
		}
		if (spot == null)
		{
			BaseEntity baseEntity = hitchable as BaseEntity;
			if ((Object)(object)baseEntity != (Object)null)
			{
				spot = GetClosestSpot(((Component)baseEntity).transform.position);
			}
		}
		if (spot != null)
		{
			object obj = Interface.CallHook("OnHorseHitch", (object)hitchable, (object)spot);
			if (obj is bool)
			{
				return (bool)obj;
			}
			spot.SetOccupiedBy(hitchable);
			hitchable.SetHitch(this, spot);
			return true;
		}
		return false;
	}

	public HitchSpot GetClosestSpot(Vector3 testPos, bool includeOccupied = false, float maxRadius = -1f)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		float num = 10000f;
		HitchSpot result = null;
		for (int i = 0; i < hitchSpots.Length; i++)
		{
			float num2 = Vector3.Distance(testPos, hitchSpots[i].tr.position);
			if (num2 < num && (maxRadius == -1f || num2 <= maxRadius) && (includeOccupied || !hitchSpots[i].IsOccupied()))
			{
				num = num2;
				result = hitchSpots[i];
			}
		}
		return result;
	}

	public void UnHitch(IHitchable hitchable)
	{
		HitchSpot[] array = hitchSpots;
		foreach (HitchSpot hitchSpot in array)
		{
			if (hitchSpot.GetHitchable(base.isServer) == hitchable)
			{
				if (Interface.CallHook("OnHorseUnhitch", (object)hitchable, (object)hitchSpot) != null)
				{
					break;
				}
				hitchSpot.SetOccupiedBy(null);
				hitchable.SetHitch(null, null);
			}
		}
	}

	public void UnHitchAll()
	{
		HitchSpot[] array = hitchSpots;
		for (int i = 0; i < array.Length; i++)
		{
			IHitchable hitchable = array[i].GetHitchable();
			if (hitchable != null)
			{
				UnHitch(hitchable);
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.genericEntRef1 = hitchSpots[0].hitchableEntRef.uid;
		info.msg.ioEntity.genericEntRef2 = hitchSpots[1].hitchableEntRef.uid;
	}

	public override void Load(LoadInfo info)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			hitchSpots[0].hitchableEntRef.uid = info.msg.ioEntity.genericEntRef1;
			hitchSpots[1].hitchableEntRef.uid = info.msg.ioEntity.genericEntRef2;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class HitchSpot
{
	public HitchTrough owner;

	public Transform tr;

	public EntityRef hitchableEntRef;

	public IHitchable GetHitchable(bool isServer = true)
	{
		return hitchableEntRef.Get(isServer) as IHitchable;
	}

	public bool IsOccupied(bool isServer = true)
	{
		return hitchableEntRef.IsValid(isServer);
	}

	public void SetOccupiedBy(IHitchable hitchable)
	{
		if (hitchable == null)
		{
			hitchableEntRef.Set(null);
			return;
		}
		BaseEntity baseEntity = hitchable as BaseEntity;
		if ((Object)(object)baseEntity != (Object)null)
		{
			hitchableEntRef.Set(baseEntity);
		}
	}
}


public interface IHitchable
{
	void SetHitch(HitchTrough hitch, HitchSpot spot);
}


public class HotAirBalloonArmor : HotAirBalloonEquipment
{
	public float AdditionalHealth = 100f;

	public override void Added(HotAirBalloon hab, bool fromSave)
	{
		base.Added(hab, fromSave);
		hab.SetMaxHealth(hab.MaxHealth() + AdditionalHealth);
		if (!fromSave)
		{
			hab.health += AdditionalHealth;
		}
		SendNetworkUpdate();
	}

	public override void Removed(HotAirBalloon hab)
	{
		base.Removed(hab);
		hab.DelayNextUpgrade(DelayNextUpgradeOnRemoveDuration);
	}

	public override void Hurt(HitInfo info)
	{
		if (HasParent() && GetParentEntity() is HotAirBalloon { baseProtection: var protectionProperties } hotAirBalloon)
		{
			hotAirBalloon.baseProtection = baseProtection;
			hotAirBalloon.Hurt(info);
			hotAirBalloon.baseProtection = protectionProperties;
		}
	}
}


using UnityEngine;

public class HotAirBalloonEquipment : BaseCombatEntity
{
	[SerializeField]
	private DamageRenderer damageRenderer;

	[HideInInspector]
	public float DelayNextUpgradeOnRemoveDuration;

	private EntityRef<HotAirBalloon> hotAirBalloon;

	public virtual void Added(HotAirBalloon hab, bool fromSave)
	{
		hotAirBalloon.Set(hab);
	}

	public virtual void Removed(HotAirBalloon hab)
	{
		hotAirBalloon.Set(null);
	}

	public override void DoRepair(BasePlayer player)
	{
		HotAirBalloon hotAirBalloon = this.hotAirBalloon.Get(serverside: true);
		if (hotAirBalloon.IsValid())
		{
			hotAirBalloon.DoRepair(player);
		}
	}
}


using UnityEngine;

public class LootPanelMannequin : LootPanel
{
	public GameObject[] controls;
}


using UnityEngine;

[CreateAssetMenu(fileName = "MannequinPose", menuName = "MannequinPose")]
public class MannequinPose : BaseScriptableObject
{
	public Quaternion[] BoneRotations;
}


public class AudioAlarm : IOEntity
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ElectricBattery : IOEntity, IInstanceDataReceiver
{
	public class DischargeWorkQueue : PersistentObjectWorkQueue<ElectricBattery>
	{
		protected override void RunJob(ElectricBattery entity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			if (!(TimeSince.op_Implicit(entity.lastDischargeCheck) < 1f))
			{
				entity.lastDischargeCheck = TimeSince.op_Implicit(0f);
				entity.CheckDischarge();
			}
		}
	}

	public int maxOutput;

	public float maxCapactiySeconds;

	public float rustWattSeconds;

	[Tooltip("How much energy we can request from power sources for charging is this value multiplied by our maxOutput")]
	public float maximumInboundEnergyRatio = 4f;

	public bool rechargable;

	public float chargeRatio = 0.25f;

	private int activeDrain;

	private float lastChargeIn;

	private const float tickRateSeconds = 1f;

	public const Flags Flag_HalfFull = Flags.Reserved5;

	public const Flags Flag_VeryFull = Flags.Reserved6;

	public const Flags Flag_Full = Flags.Reserved9;

	private bool wasLoaded;

	private TimeSince lastDischargeCheck;

	private HashSet<(IOEntity entity, int inputIndex)> connectedList = new HashSet<(IOEntity, int)>();

	private HashSet<(IOEntity entity, int inputIndex)> auxConnectedList = new HashSet<(IOEntity, int)>();

	[ServerVar(Saved = true)]
	public static float DischargeBudgetMs = 0.05f;

	public static DischargeWorkQueue DischargeQueue = new DischargeWorkQueue();

	private Queue<int> inputHistory = new Queue<int>();

	private const int inputHistorySize = 5;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int MaximalPowerOutput()
	{
		return maxOutput;
	}

	public int GetActiveDrain()
	{
		if (!IsOn())
		{
			return 0;
		}
		return activeDrain;
	}

	public void ReceiveInstanceData(InstanceData data)
	{
		rustWattSeconds = data.dataInt;
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		lastDischargeCheck = TimeSince.op_Implicit(0f);
		((PersistentObjectWorkQueue<ElectricBattery>)DischargeQueue).Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		((PersistentObjectWorkQueue<ElectricBattery>)DischargeQueue).Remove(this);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		wasLoaded = true;
	}

	public override void OnPickedUp(Item createdItem, BasePlayer player)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected O, but got Unknown
		base.OnPickedUp(createdItem, player);
		if (createdItem.instanceData == null)
		{
			createdItem.instanceData = new InstanceData();
		}
		createdItem.instanceData.ShouldPool = false;
		createdItem.instanceData.dataInt = Mathf.FloorToInt(rustWattSeconds);
	}

	public override int GetCurrentEnergy()
	{
		return currentEnergy;
	}

	public int GetDrain()
	{
		connectedList.Clear();
		auxConnectedList.Clear();
		IOEntity iOEntity = outputs[0].connectedTo.Get();
		if ((Object)(object)iOEntity != (Object)null)
		{
			int connectedToSlot = outputs[0].connectedToSlot;
			if (iOEntity.WantsPower(connectedToSlot))
			{
				AddConnectedRecursive(iOEntity, connectedToSlot, ref connectedList);
			}
			else
			{
				connectedList.Add((iOEntity, connectedToSlot));
			}
		}
		int num = 0;
		if (HasFlag(Flags.Reserved9))
		{
			IOEntity iOEntity2 = outputs[1].connectedTo.Get();
			if ((Object)(object)iOEntity2 != (Object)null)
			{
				int connectedToSlot2 = outputs[1].connectedToSlot;
				if (iOEntity2.WantsPower(connectedToSlot2))
				{
					AddConnectedRecursive(iOEntity2, connectedToSlot2, ref auxConnectedList);
				}
				else
				{
					auxConnectedList.Add((iOEntity2, connectedToSlot2));
				}
			}
			foreach (var auxConnected in auxConnectedList)
			{
				if (auxConnected.entity.ShouldDrainBattery(this))
				{
					num += auxConnected.entity.DesiredPower(auxConnected.inputIndex);
					if (num >= 1)
					{
						num = 1;
						break;
					}
				}
			}
		}
		int num2 = num;
		foreach (var connected in connectedList)
		{
			if (connected.entity.ShouldDrainBattery(this))
			{
				num2 += connected.entity.DesiredPower(connected.inputIndex);
				if (num2 >= maxOutput)
				{
					num2 = maxOutput;
					break;
				}
			}
		}
		return num2;
	}

	public void AddConnectedRecursive(IOEntity root, int inputIndex, ref HashSet<(IOEntity, int)> listToUse)
	{
		listToUse.Add((root, inputIndex));
		if (!root.WantsPassthroughPower())
		{
			return;
		}
		for (int i = 0; i < root.outputs.Length; i++)
		{
			if (!root.AllowDrainFrom(i))
			{
				continue;
			}
			IOSlot iOSlot = root.outputs[i];
			if (iOSlot.type == IOType.Electric)
			{
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if ((Object)(object)iOEntity != (Object)null && !listToUse.Contains((iOEntity, iOSlot.connectedToSlot)) && iOEntity.WantsPower(iOSlot.connectedToSlot))
				{
					AddConnectedRecursive(iOEntity, iOSlot.connectedToSlot, ref listToUse);
				}
			}
		}
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if (rustWattSeconds >= maxCapactiySeconds)
		{
			return 0;
		}
		if (!IsFlickering())
		{
			return Mathf.Min(currentEnergy, Mathf.FloorToInt((float)maxOutput * maximumInboundEnergyRatio));
		}
		return GetHighestInputFromHistory();
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (IsFlickering())
		{
			if (inputHistory.Count >= 5)
			{
				inputHistory.Dequeue();
			}
			inputHistory.Enqueue(inputAmount);
		}
		if (inputSlot == 0 && rechargable)
		{
			if (!IsPowered() && !IsFlickering())
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)AddCharge);
				lastChargeIn = 0f;
			}
			else if (!((FacepunchBehaviour)this).IsInvoking((Action)AddCharge))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)AddCharge, 1f, 1f, 0.1f);
			}
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		switch (outputSlot)
		{
		case 0:
			if (IsOn())
			{
				return Mathf.FloorToInt((float)maxOutput * ((rustWattSeconds >= 1f) ? 1f : 0f));
			}
			return 0;
		case 1:
			if (!HasFlag(Flags.Reserved9))
			{
				return 0;
			}
			return 1;
		default:
			return 0;
		}
	}

	public override bool WantsPower(int inputIndex)
	{
		return rustWattSeconds < maxCapactiySeconds;
	}

	public override void SendAdditionalData(BasePlayer player, int slot, bool input)
	{
		int passthroughAmountForAnySlot = GetPassthroughAmountForAnySlot(slot, input);
		ClientRPC(RpcTarget.Player("Client_ReceiveAdditionalData", player), currentEnergy, passthroughAmountForAnySlot, rustWattSeconds, (float)activeDrain);
	}

	public override void OnCircuitChanged(bool forceUpdate)
	{
		base.OnCircuitChanged(forceUpdate);
		int drain = GetDrain();
		activeDrain = drain;
	}

	public void CheckDischarge()
	{
		if (rustWattSeconds < 5f)
		{
			SetDischarging(wantsOn: false);
			return;
		}
		IOEntity iOEntity = outputs[0].connectedTo.Get();
		IOEntity iOEntity2 = outputs[1].connectedTo.Get();
		int drain = GetDrain();
		activeDrain = drain;
		SetDischarging((Object)(object)iOEntity != (Object)null || (Object)(object)iOEntity2 != (Object)null);
	}

	public void SetDischarging(bool wantsOn)
	{
		SetPassthroughOn(wantsOn);
	}

	private int GetHighestInputFromHistory()
	{
		int num = 0;
		foreach (int item in inputHistory)
		{
			if (item > num)
			{
				num = item;
			}
		}
		return num;
	}

	public void TickUsage()
	{
		float oldCharge = rustWattSeconds;
		bool num = rustWattSeconds > 0f;
		if (rustWattSeconds >= 1f)
		{
			float num2 = 1f * (float)activeDrain;
			rustWattSeconds -= num2;
		}
		if (rustWattSeconds <= 0f)
		{
			rustWattSeconds = 0f;
		}
		bool flag = rustWattSeconds > 0f;
		ChargeChanged(oldCharge);
		if (num != flag)
		{
			MarkDirty();
			SendNetworkUpdate();
		}
	}

	public virtual void ChargeChanged(float oldCharge)
	{
		bool flag = rustWattSeconds > maxCapactiySeconds * 0.25f;
		bool flag2 = rustWattSeconds > maxCapactiySeconds * 0.75f;
		if (HasFlag(Flags.Reserved5) != flag || HasFlag(Flags.Reserved6) != flag2)
		{
			SetFlag(Flags.Reserved5, flag);
			SetFlag(Flags.Reserved6, flag2);
			SendNetworkUpdate_Flags();
		}
		RefreshFullChargeFlag();
	}

	private void RefreshFullChargeFlag()
	{
		bool flag = (float)Mathf.RoundToInt(rustWattSeconds / 60f) >= maxCapactiySeconds / 60f;
		bool flag2 = HasFlag(Flags.Reserved9);
		if (flag && !flag2)
		{
			SetFlag(Flags.Reserved9, b: true);
			MarkDirtyForceUpdateOutputs();
		}
		else if (!flag && flag2 && ((float)activeDrain > lastChargeIn || lastChargeIn == 0f))
		{
			SetFlag(Flags.Reserved9, b: false);
			MarkDirtyForceUpdateOutputs();
		}
	}

	public void SetCharge(float charge)
	{
		float oldCharge = rustWattSeconds;
		rustWattSeconds = charge;
		ChargeChanged(oldCharge);
	}

	public void AddCharge()
	{
		float oldCharge = rustWattSeconds;
		float num = (lastChargeIn = (float)Mathf.Min(IsFlickering() ? GetHighestInputFromHistory() : currentEnergy, DesiredPower()) * 1f * chargeRatio);
		if (num > 0f)
		{
			rustWattSeconds += num;
			rustWattSeconds = Mathf.Clamp(rustWattSeconds, 0f, maxCapactiySeconds);
			ChargeChanged(oldCharge);
		}
	}

	public void SetPassthroughOn(bool wantsOn)
	{
		if (wantsOn == IsOn() && !wasLoaded)
		{
			return;
		}
		wasLoaded = false;
		SetFlag(Flags.On, wantsOn);
		if (IsOn())
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)TickUsage))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)TickUsage, 1f, 1f, 0.1f);
			}
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TickUsage);
		}
		MarkDirty();
	}

	public void UnBusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.ioEntity == null)
		{
			info.msg.ioEntity = Pool.Get<IOEntity>();
		}
		info.msg.ioEntity.genericFloat1 = rustWattSeconds;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			rustWattSeconds = info.msg.ioEntity.genericFloat1;
		}
	}

	[ServerVar]
	public static void batteryid(Arg arg)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		ElectricBattery electricBattery = BaseNetworkable.serverEntities.Find(arg.GetEntityID(1)) as ElectricBattery;
		if ((Object)(object)electricBattery == (Object)null)
		{
			arg.ReplyWith("Not a battery");
			return;
		}
		string @string = arg.GetString(0, "");
		if (!(@string == "charge"))
		{
			if (@string == "deplete")
			{
				float oldCharge = electricBattery.rustWattSeconds;
				electricBattery.rustWattSeconds = 0f;
				electricBattery.ChargeChanged(oldCharge);
				arg.ReplyWith("Depleted " + electricBattery.GetDisplayName().english);
			}
			else
			{
				arg.ReplyWith("Unknown command");
			}
		}
		else
		{
			float oldCharge2 = electricBattery.rustWattSeconds;
			float num = arg.GetInt(2, (int)electricBattery.maxCapactiySeconds / 60);
			electricBattery.rustWattSeconds = Mathf.Clamp(electricBattery.rustWattSeconds + num * 60f, 0f, electricBattery.maxCapactiySeconds);
			electricBattery.ChargeChanged(oldCharge2);
			arg.ReplyWith("Charged " + electricBattery.GetDisplayName().english);
		}
	}
}


public class DischargeWorkQueue : PersistentObjectWorkQueue<ElectricBattery>
{
	protected override void RunJob(ElectricBattery entity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (!(TimeSince.op_Implicit(entity.lastDischargeCheck) < 1f))
		{
			entity.lastDischargeCheck = TimeSince.op_Implicit(0f);
			entity.CheckDischarge();
		}
	}
}


using UnityEngine;

public class BaseDetector : IOEntity, IDetector
{
	public PlayerDetectionTrigger myTrigger;

	public const Flags Flag_HasContents = Flags.Reserved1;

	public override int ConsumptionAmount()
	{
		return base.ConsumptionAmount();
	}

	public virtual bool ShouldTrigger()
	{
		return IsPowered();
	}

	public virtual void OnObjects()
	{
		SetFlag(Flags.Reserved1, b: true);
		if (ShouldTrigger())
		{
			OnDetectorTriggered();
			MarkDirty();
		}
	}

	public void OnObjectAdded(GameObject obj, Collider col)
	{
	}

	public virtual void OnEmpty()
	{
		SetFlag(Flags.Reserved1, b: false);
		if (ShouldTrigger())
		{
			OnDetectorReleased();
			MarkDirty();
		}
	}

	public virtual void OnDetectorTriggered()
	{
	}

	public virtual void OnDetectorReleased()
	{
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!HasFlag(Flags.Reserved1))
		{
			return 0;
		}
		return base.GetPassthroughAmount();
	}
}


using UnityEngine;

public interface IDetector
{
	bool ShouldTrigger();

	void OnObjects();

	void OnObjectAdded(GameObject obj, Collider col);

	void OnEmpty();
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class LaserDetector : BaseDetector
{
	public const Flags Flag_Triggered = Flags.Reserved12;

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!HasFlag(Flags.Reserved12))
		{
			return 0;
		}
		return currentEnergy;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (IsPowered() && next.HasFlag(Flags.Reserved1))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)VisibilityCheck, 0f, 1f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)VisibilityCheck);
		}
	}

	private void VisibilityCheck()
	{
		if (myTrigger.entityContents == null)
		{
			return;
		}
		bool b = false;
		foreach (BaseEntity entityContent in myTrigger.entityContents)
		{
			if (!entityContent.isClient && CanSee(entityContent))
			{
				b = true;
				break;
			}
		}
		SetFlag(Flags.Reserved12, b);
		MarkDirty();
	}

	public override void OnEmpty()
	{
		base.OnEmpty();
		SetFlag(Flags.Reserved12, b: false);
		MarkDirty();
	}

	public bool CanSee(BaseEntity ent)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		PooledList<RaycastHit> val = Pool.Get<PooledList<RaycastHit>>();
		try
		{
			Vector3 val2 = ((Component)this).transform.position + ((Component)this).transform.forward * 0.25f;
			GamePhysics.TraceAll(new Ray(val2, ((Component)this).transform.forward), 0.12f, (List<RaycastHit>)(object)val, 12f, 0x48A12101 | LayerMask.op_Implicit(myTrigger.InterestLayers), (QueryTriggerInteraction)1, this);
			foreach (RaycastHit item in (List<RaycastHit>)(object)val)
			{
				BaseEntity entity = item.GetEntity();
				if (!((Object)(object)entity == (Object)null) && !entity.isClient)
				{
					return (Object)(object)entity == (Object)(object)ent;
				}
			}
			if (!(ent is BaseVehicle))
			{
				return false;
			}
			Vector3 worldVelocity = ent.GetWorldVelocity();
			if (((Vector3)(ref worldVelocity)).magnitude > 5f)
			{
				Vector3 val3 = ((Component)ent).transform.position + worldVelocity * Time.fixedDeltaTime - val2;
				Vector3 normalized = ((Vector3)(ref val3)).normalized;
				((List<RaycastHit>)(object)val).Clear();
				GamePhysics.TraceAll(new Ray(val2, normalized), 0.25f, (List<RaycastHit>)(object)val, 20f, 0x48A12101 | LayerMask.op_Implicit(myTrigger.InterestLayers), (QueryTriggerInteraction)1, this);
				foreach (RaycastHit item2 in (List<RaycastHit>)(object)val)
				{
					BaseEntity entity2 = item2.GetEntity();
					if (!((Object)(object)entity2 == (Object)null) && !entity2.isClient && (Object)(object)entity2 == (Object)(object)ent)
					{
						return true;
					}
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputAmount == 0)
		{
			SetFlag(Flags.Reserved12, b: false);
		}
	}
}


using UnityEngine;

public class PlayerDetectionTrigger : TriggerBase
{
	public GameObject detector;

	public IDetector _detector;

	private IDetector myDetector
	{
		get
		{
			if (_detector == null && (Object)(object)detector != (Object)null)
			{
				_detector = detector.GetComponent<IDetector>();
			}
			return _detector;
		}
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnObjects()
	{
		base.OnObjects();
		if (myDetector != null)
		{
			myDetector.OnObjects();
		}
	}

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		base.OnObjectAdded(obj, col);
		if (myDetector != null)
		{
			myDetector.OnObjectAdded(obj, col);
		}
	}

	public override void OnEmpty()
	{
		base.OnEmpty();
		if (myDetector != null)
		{
			myDetector.OnEmpty();
		}
	}
}


using System;
using UnityEngine;

public class PressurePad : BaseDetector
{
	public float pressPowerTime = 0.5f;

	public int pressPowerAmount = 2;

	public const Flags Flag_EmittingPower = Flags.Reserved3;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public override bool ShouldTrigger()
	{
		return true;
	}

	public override void OnDetectorTriggered()
	{
		base.OnDetectorTriggered();
		((FacepunchBehaviour)this).Invoke((Action)UnpowerTime, pressPowerTime);
		SetFlag(Flags.Reserved3, b: true);
	}

	public override void OnDetectorReleased()
	{
		base.OnDetectorReleased();
		SetFlag(Flags.Reserved3, b: false);
	}

	public void UnpowerTime()
	{
		SetFlag(Flags.Reserved3, b: false);
		MarkDirty();
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (HasFlag(Flags.Reserved1))
		{
			int passthroughAmount = base.GetPassthroughAmount(0);
			if (HasFlag(Flags.Reserved3))
			{
				return Mathf.Max(pressPowerAmount, passthroughAmount);
			}
			if (IsPowered())
			{
				return passthroughAmount;
			}
		}
		return 0;
	}
}


using UnityEngine;

public class ElectricalHeater : IOEntity
{
	public float fadeDuration = 1f;

	public Light sourceLight;

	public Light secondaryLight;

	public GrowableHeatSource growableHeatSource;

	public override int ConsumptionAmount()
	{
		return 3;
	}

	public override void ResetState()
	{
		base.ResetState();
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool flag = next.HasFlag(Flags.Reserved8);
		if (old.HasFlag(Flags.Reserved8) != flag && (Object)(object)growableHeatSource != (Object)null)
		{
			growableHeatSource.ForceUpdateGrowablesInRange();
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)growableHeatSource != (Object)null)
		{
			growableHeatSource.ForceUpdateGrowablesInRange();
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using Spatial;
using UnityEngine;

public class GrowableHeatSource : EntityComponent<BaseEntity>, IServerComponent
{
	public float heatAmount = 5f;

	public AnimationCurve HeatFalloff = AnimationCurve.Linear(0f, 1f, 1f, 0f);

	public static Grid<GrowableHeatSource> FarmHeatSourceGrid = new Grid<GrowableHeatSource>(32, 8096f);

	public float ApplyHeat(Vector3 forPosition)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)base.baseEntity == (Object)null)
		{
			return 0f;
		}
		if (base.baseEntity.IsOn() || (base.baseEntity is IOEntity iOEntity && iOEntity.IsPowered()))
		{
			float num = Vector3.Distance(forPosition, ((Component)this).transform.position);
			float num2 = HeatFalloff.Evaluate(num / Server.artificialTemperatureGrowableRange);
			return heatAmount * num2;
		}
		return 0f;
	}

	public void ForceUpdateGrowablesInRange()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		List<IHeatSourceListener> list = Pool.Get<List<IHeatSourceListener>>();
		int layerMask = 524544;
		Vis.Entities(((Component)this).transform.position, Server.artificialTemperatureGrowableRange, list, layerMask, (QueryTriggerInteraction)2);
		List<PlanterBox> list2 = Pool.Get<List<PlanterBox>>();
		foreach (IHeatSourceListener item in list)
		{
			if (item is GrowableEntity growableEntity)
			{
				if (!growableEntity.isServer)
				{
					continue;
				}
				PlanterBox planter = growableEntity.GetPlanter();
				if ((Object)(object)planter != (Object)null && !list2.Contains(planter))
				{
					list2.Add(planter);
					planter.ForceTemperatureUpdate();
				}
			}
			item.OnHeatSourceChanged();
		}
		Pool.FreeUnmanaged<PlanterBox>(ref list2);
		Pool.FreeUnmanaged<IHeatSourceListener>(ref list);
	}

	public override void InitShared()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		if (base.baseEntity.isServer)
		{
			Vector3 position = ((Component)this).transform.position;
			FarmHeatSourceGrid.Add(this, position.x, position.z);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.baseEntity.isServer)
		{
			FarmHeatSourceGrid.Remove(this);
		}
	}
}


public interface IHeatSourceListener
{
	void OnHeatSourceChanged();
}


public class ElectricalBlocker : IOEntity
{
	protected int input1Amount;

	protected int input2Amount;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return base.GetPassthroughAmount(outputSlot) * ((!IsOn()) ? 1 : 0);
	}

	public override bool WantsPower(int inputIndex)
	{
		if (inputIndex != 0 || !IsFlickering())
		{
			return !IsOn();
		}
		return true;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public virtual void UpdateBlocked()
	{
		bool num = IsOn();
		SetFlag(Flags.On, input1Amount > 0, recursive: false, networkupdate: false);
		if (num != IsOn())
		{
			MarkDirty();
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		switch (inputSlot)
		{
		case 1:
			input1Amount = inputAmount;
			UpdateBlocked();
			break;
		case 0:
			input2Amount = inputAmount;
			base.UpdateFromInput(inputAmount, inputSlot);
			break;
		}
	}
}


using UnityEngine;

public class ElectricalCombiner : IOEntity
{
	public int input1Amount;

	public int input2Amount;

	public int input3Amount;

	public override bool BlockFluidDraining => true;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int num = input1Amount + input2Amount + input3Amount;
		Mathf.Clamp(num, 0, num);
		return num;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void UpdateFromInput(int inputAmount, int slot)
	{
		if (inputAmount > 0 && IsConnectedTo(this, slot, IOEntity.backtracking * 2, defaultReturn: true))
		{
			inputAmount = 0;
			SetFlag(Flags.Reserved7, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved7, b: false);
		}
		switch (slot)
		{
		case 0:
			input1Amount = inputAmount;
			break;
		case 1:
			input2Amount = inputAmount;
			break;
		case 2:
			input3Amount = inputAmount;
			break;
		}
		int num = input1Amount + input2Amount + input3Amount;
		bool b = num > 0;
		Flags num2 = flags;
		SetFlag(Flags.Reserved1, input1Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, input1Amount > 0 || input2Amount > 0 || input3Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.On, num > 0, recursive: false, networkupdate: false);
		if (num2 != flags)
		{
			SendNetworkUpdate_Flags();
		}
		base.UpdateFromInput(num, slot);
	}
}


using System;
using UnityEngine;

public class ElectricalDFlipFlop : IOEntity
{
	[NonSerialized]
	private int setAmount;

	[NonSerialized]
	private int resetAmount;

	[NonSerialized]
	private int toggleAmount;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public bool GetDesiredState()
	{
		if (setAmount > 0 && resetAmount == 0)
		{
			return true;
		}
		if (setAmount > 0 && resetAmount > 0)
		{
			return true;
		}
		if (setAmount == 0 && resetAmount > 0)
		{
			return false;
		}
		if (toggleAmount > 0)
		{
			return !IsOn();
		}
		if (setAmount == 0 && resetAmount == 0)
		{
			return IsOn();
		}
		return false;
	}

	public void UpdateState()
	{
		if (IsPowered())
		{
			bool num = IsOn();
			bool desiredState = GetDesiredState();
			SetFlag(Flags.On, desiredState);
			if (num != IsOn())
			{
				MarkDirtyForceUpdateOutputs();
			}
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		bool flag = false;
		switch (inputSlot)
		{
		case 1:
			flag = inputAmount != setAmount;
			setAmount = inputAmount;
			break;
		case 2:
			flag = inputAmount != resetAmount;
			resetAmount = inputAmount;
			break;
		case 3:
			flag = inputAmount != toggleAmount;
			toggleAmount = inputAmount;
			break;
		case 0:
			base.UpdateFromInput(inputAmount, inputSlot);
			UpdateState();
			break;
		}
		if (flag)
		{
			UpdateState();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int result = Mathf.Max(0, currentEnergy);
		if (outputSlot == -1)
		{
			return result;
		}
		if (!AllowDrainFrom(outputSlot))
		{
			return 0;
		}
		return result;
	}

	public override void UpdateOutputs()
	{
		if (ShouldUpdateOutputs() && ensureOutputsUpdated)
		{
			int passthroughAmount = GetPassthroughAmount(-1);
			if ((Object)(object)outputs[0].connectedTo.Get() != (Object)null)
			{
				outputs[0].connectedTo.Get().UpdateFromInput(IsOn() ? passthroughAmount : 0, outputs[0].connectedToSlot);
			}
			if ((Object)(object)outputs[1].connectedTo.Get() != (Object)null)
			{
				outputs[1].connectedTo.Get().UpdateFromInput((!IsOn()) ? passthroughAmount : 0, outputs[1].connectedToSlot);
			}
		}
	}

	public override bool AllowDrainFrom(int outputSlot)
	{
		if (outputSlot == -1)
		{
			return true;
		}
		if (!IsOn())
		{
			return outputSlot == 1;
		}
		return outputSlot == 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		return inputIndex == 0;
	}
}


using UnityEngine;

public class RANDSwitch : ElectricalBlocker
{
	private bool rand;

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return GetCurrentEnergy() * (IsOn() ? 1 : 0);
	}

	public override bool WantsPower(int inputIndex)
	{
		if (inputIndex == 0)
		{
			return IsOn();
		}
		return false;
	}

	public override void UpdateBlocked()
	{
		bool num = IsOn();
		SetFlag(Flags.On, rand, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved8, rand, recursive: false, networkupdate: false);
		UpdateHasPower(input1Amount + input2Amount, 1);
		if (num != IsOn())
		{
			MarkDirty();
		}
	}

	public bool RandomRoll()
	{
		return Random.Range(0, 2) == 1;
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (inputSlot == 1 && inputAmount > 0)
		{
			input1Amount = inputAmount;
			rand = RandomRoll();
			UpdateBlocked();
		}
		if (inputSlot == 2)
		{
			if (inputAmount > 0)
			{
				rand = false;
				UpdateBlocked();
			}
		}
		else
		{
			base.UpdateFromInput(inputAmount, inputSlot);
		}
	}
}


public class FuelElectricGenerator : IOEntity
{
	public float electricAmount = 8f;
}


using Oxide.Core;
using UnityEngine;

public class SolarPanel : IOEntity
{
	public class SunUpdateWorkQueue : PersistentObjectWorkQueue<SolarPanel>
	{
		protected override void RunJob(SolarPanel entity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			if (!(TimeSince.op_Implicit(entity.lastSunUpdate) < 5f))
			{
				entity.lastSunUpdate = TimeSince.op_Implicit(Random.Range(-2f, 0f));
				entity.SunUpdate();
			}
		}
	}

	public Transform sunSampler;

	public int maximalPowerOutput = 10;

	public float dot_minimum = 0.1f;

	public float dot_maximum = 0.6f;

	[ServerVar(Saved = true)]
	public static float sunUpdateBudgetMs = 0.05f;

	public static SunUpdateWorkQueue WorkQueue = new SunUpdateWorkQueue();

	private TimeSince lastSunUpdate;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int MaximalPowerOutput()
	{
		return maximalPowerOutput;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		lastSunUpdate = TimeSince.op_Implicit(-4f);
		((PersistentObjectWorkQueue<SolarPanel>)WorkQueue).Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		((PersistentObjectWorkQueue<SolarPanel>)WorkQueue).Remove(this);
	}

	public void SunUpdate()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		int num;
		if (TOD_Sky.Instance.IsNight)
		{
			num = 0;
		}
		else
		{
			Vector3 sunDirection = TOD_Sky.Instance.SunDirection;
			float num2 = Vector3.Dot(sunSampler.forward, sunDirection);
			float num3 = Mathf.InverseLerp(dot_minimum, dot_maximum, num2);
			if (num3 > 0f && !IsVisible(sunSampler.position + sunDirection * 100f, 101f))
			{
				num3 = 0f;
			}
			num = Mathf.FloorToInt((float)maximalPowerOutput * num3 * base.healthFraction);
		}
		bool num4 = currentEnergy != num;
		currentEnergy = num;
		if (num4 && Interface.CallHook("OnSolarPanelSunUpdate", (object)this, (object)num) == null)
		{
			MarkDirty();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot != 0)
		{
			return 0;
		}
		return currentEnergy;
	}
}


using UnityEngine;

public class SunUpdateWorkQueue : PersistentObjectWorkQueue<SolarPanel>
{
	protected override void RunJob(SolarPanel entity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (!(TimeSince.op_Implicit(entity.lastSunUpdate) < 5f))
		{
			entity.lastSunUpdate = TimeSince.op_Implicit(Random.Range(-2f, 0f));
			entity.SunUpdate();
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class Igniter : IOEntity
{
	public float IgniteRange = 5f;

	public float IgniteFrequency = 1f;

	public float IgniteStartDelay;

	public Transform LineOfSightEyes;

	public float SelfDamagePerIgnite = 0.5f;

	public int PowerConsumption = 2;

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public bool CanIgnite()
	{
		return base.healthFraction >= 0.1f;
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		base.UpdateFromInput(inputAmount, inputSlot);
		if (inputAmount > 0 && CanIgnite())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)IgniteInRange, IgniteStartDelay, IgniteFrequency);
			SetFlag(Flags.On, b: true);
			return;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)IgniteInRange))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)IgniteInRange);
		}
		SetFlag(Flags.On, b: false);
	}

	private void IgniteInRange()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(LineOfSightEyes.position, IgniteRange, list, 1237019409, (QueryTriggerInteraction)2);
		int num = 0;
		foreach (BaseEntity item in list)
		{
			if (item.HasFlag(Flags.On) || !item.IsVisible(LineOfSightEyes.position))
			{
				continue;
			}
			if (item.isServer && item is BaseOven)
			{
				(item as BaseOven).StartCooking();
				if (item.HasFlag(Flags.On))
				{
					num++;
				}
			}
			else if (item.isServer && item is IIgniteable igniteable && igniteable.CanIgnite())
			{
				igniteable.Ignite(((Component)this).transform.position);
				num++;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		Hurt(SelfDamagePerIgnite, DamageType.ElectricShock, this, useProtection: false);
		if (!CanIgnite())
		{
			SendChangedToRoot(forceUpdate: true);
		}
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if (!CanIgnite())
		{
			return 0;
		}
		return base.DesiredPower(inputIndex);
	}

	public override void OnRepair()
	{
		base.OnRepair();
		if (CanIgnite())
		{
			SendChangedToRoot(forceUpdate: true);
		}
	}
}


using UnityEngine;

public class OrientableLightGuide : MonoBehaviour
{
	public Transform pivotTransform;
}


using UnityEngine;

public class FlasherLight : IOEntity
{
	public EmissionToggle toggler;

	public Light myLight;

	public float flashSpacing = 0.2f;

	public float flashBurstSpacing = 0.5f;

	public float flashOnTime = 0.1f;

	public int numFlashesPerBurst = 5;

	public float maximumLightRenderDistance = 25f;

	public override void ResetState()
	{
		base.ResetState();
	}
}


using UnityEngine;

public class SirenLight : IOEntity
{
	public EmissionToggle toggler;

	public GameObject lightObj;

	public float speed;

	public override void ResetState()
	{
		base.ResetState();
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using UnityEngine;

public class Sprinkler : IOEntity
{
	public float SplashFrequency = 1f;

	public Transform Eyes;

	public int WaterPerSplash = 1;

	public float DecayPerSplash = 0.8f;

	public const Flags Flag_Radiation = Flags.Reserved3;

	public TriggerSplashable DynamicObjectsTrigger;

	public ItemDefinition currentFuelType;

	private IOEntity currentFuelSource;

	private HashSet<ISplashable> cachedSplashables = new HashSet<ISplashable>();

	private TimeSince updateSplashableCache;

	private bool forceUpdateSplashables;

	public override bool BlockFluidDraining => (Object)(object)currentFuelSource != (Object)null;

	public override int ConsumptionAmount()
	{
		return 2;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		return Mathf.Clamp(currentEnergy, 0, ConsumptionAmount());
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		SetSprinklerState(inputAmount > 0);
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		return inputAmount;
	}

	public void DoSplash()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SprinklerSplash", 0);
		try
		{
			int waterAmount = WaterPerSplash;
			PooledList<ISplashable> val2 = Pool.Get<PooledList<ISplashable>>();
			try
			{
				Vector3 position = Eyes.position;
				if (TimeSince.op_Implicit(updateSplashableCache) > SplashFrequency * 4f || forceUpdateSplashables)
				{
					cachedSplashables.Clear();
					forceUpdateSplashables = false;
					updateSplashableCache = TimeSince.op_Implicit(0f);
					Vector3 up = ((Component)this).transform.up;
					float sprinklerEyeHeightOffset = Server.sprinklerEyeHeightOffset;
					float num = Vector3.Angle(up, Vector3.up) / 180f;
					num = Mathf.Clamp(num, 0.2f, 1f);
					sprinklerEyeHeightOffset *= num;
					Vector3 val3 = position + up * (Server.sprinklerRadius * 0.5f);
					Vector3 val4 = position + up * sprinklerEyeHeightOffset;
					List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
					Vector3 val5 = Vector3.Lerp(val3, val4, 0.5f);
					((Component)DynamicObjectsTrigger).transform.position = val5;
					Transform transform = ((Component)DynamicObjectsTrigger).transform;
					Vector3 val6 = val5 - val3;
					transform.up = ((Vector3)(ref val6)).normalized;
					SplashableStaticGrid.UpdateMobileSplashables();
					SplashableStaticGrid.Grid.Query(val5.x, val5.z, Server.sprinklerRadius, list);
					if (list.Count > 0)
					{
						Transform transform2 = ((Component)DynamicObjectsTrigger).transform;
						Vector3 center = DynamicObjectsTrigger.Capsule.center;
						Bounds val7 = ((Collider)DynamicObjectsTrigger.Capsule).bounds;
						OBB val8 = default(OBB);
						((OBB)(ref val8))..ctor(transform2, new Bounds(center, ((Bounds)(ref val7)).extents * 2f));
						foreach (BaseEntity item in list)
						{
							if ((Object)(object)item != (Object)null && ((OBB)(ref val8)).Intersects(item.WorldSpaceBounds()) && ProcessEntity(item, out var foundSplashable2) && item.IsVisible(position))
							{
								cachedSplashables.Add(foundSplashable2);
							}
						}
					}
					Pool.FreeUnmanaged<BaseEntity>(ref list);
				}
				foreach (ISplashable cachedSplashable in cachedSplashables)
				{
					((List<ISplashable>)(object)val2).Add(cachedSplashable);
				}
				TimeWarning val9 = TimeWarning.New("UpdateDynamicSplashables", 0);
				try
				{
					if (DynamicObjectsTrigger.entityContents != null)
					{
						foreach (BaseEntity entityContent in DynamicObjectsTrigger.entityContents)
						{
							if (ProcessEntity(entityContent, out var foundSplashable3))
							{
								if (DynamicObjectsTrigger.ShouldCheckLineOfSight(entityContent))
								{
									DynamicObjectsTrigger.RecordLineOfSight(entityContent, entityContent.IsVisible(position));
								}
								if (DynamicObjectsTrigger.HasLineOfSight(entityContent))
								{
									((List<ISplashable>)(object)val2).Add(foundSplashable3);
								}
							}
						}
					}
				}
				finally
				{
					((IDisposable)val9)?.Dispose();
				}
				if (((List<ISplashable>)(object)val2).Count > 0)
				{
					int num2 = waterAmount / ((List<ISplashable>)(object)val2).Count;
					float num3 = (float)(waterAmount % ((List<ISplashable>)(object)val2).Count) / (float)((List<ISplashable>)(object)val2).Count;
					foreach (ISplashable item2 in (List<ISplashable>)(object)val2)
					{
						int amount = num2 + ((Random.value < num3) ? 1 : 0);
						if (!item2.IsUnityNull() && item2.WantsSplash(currentFuelType, amount))
						{
							int num4 = item2.DoSplash(currentFuelType, amount);
							waterAmount -= num4;
							if (waterAmount <= 0)
							{
								break;
							}
						}
					}
				}
				if (DecayPerSplash > 0f)
				{
					Hurt(DecayPerSplash);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			bool ProcessEntity(BaseEntity targetEnt, out ISplashable foundSplashable)
			{
				foundSplashable = null;
				if (targetEnt.isClient)
				{
					return false;
				}
				if (targetEnt is ISplashable splashable && splashable.WantsSplash(currentFuelType, waterAmount))
				{
					if (targetEnt is IOEntity entity && IsConnectedTo(entity, IOEntity.backtracking))
					{
						return false;
					}
					if (targetEnt is BasePlayer && currentFuelType.baseRadioactivity > 0f)
					{
						return false;
					}
					foundSplashable = splashable;
					return true;
				}
				return false;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		Interface.CallHook("OnSprinklerSplashed", (object)this);
	}

	public void SetSprinklerState(bool wantsOn)
	{
		if (wantsOn)
		{
			TurnOn();
		}
		else
		{
			TurnOff();
		}
	}

	public void TurnOn()
	{
		if (!IsOn())
		{
			SetFlag(Flags.On, b: true);
			if ((Object)(object)currentFuelType != (Object)null)
			{
				SetFlag(Flags.Reserved3, currentFuelType.baseRadioactivity > 0f);
			}
			forceUpdateSplashables = true;
			if (!((FacepunchBehaviour)this).IsInvoking((Action)DoSplash))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)DoSplash, SplashFrequency * 0.5f, SplashFrequency, SplashFrequency * 0.2f);
			}
		}
	}

	public void TurnOff()
	{
		if (IsOn())
		{
			SetFlag(Flags.On, b: false);
			SetFlag(Flags.Reserved3, b: false);
			if (((FacepunchBehaviour)this).IsInvoking((Action)DoSplash))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)DoSplash);
			}
			currentFuelSource = null;
			currentFuelType = null;
		}
	}

	public override void SetFuelType(ItemDefinition def, IOEntity source)
	{
		base.SetFuelType(def, source);
		currentFuelType = def;
		currentFuelSource = source;
		if ((Object)(object)currentFuelType != (Object)null)
		{
			SetFlag(Flags.Reserved3, currentFuelType.baseRadioactivity > 0f && IsOn());
		}
		else
		{
			SetFlag(Flags.Reserved3, b: false);
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			if (Server.useLegacySprinklerLoadProcess)
			{
				SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
			}
			else if (HasFlag(Flags.On) && !((FacepunchBehaviour)this).IsInvoking((Action)DoSplash))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)DoSplash, SplashFrequency * 0.5f, SplashFrequency, SplashFrequency * 0.2f);
			}
		}
	}
}


using UnityEngine;

public class TriggerSplashable : TriggerBase
{
	public CapsuleCollider Capsule;

	private ListDictionary<BaseEntity, (bool visible, Vector3 lastCheckPos)> visibleState = new ListDictionary<BaseEntity, (bool, Vector3)>();

	internal override GameObject InterestedInObject(GameObject obj)
	{
		if (obj.GetComponent<ISplashable>() == null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null || baseEntity.isClient)
		{
			return null;
		}
		return base.InterestedInObject(obj);
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (visibleState.ContainsKey(ent))
		{
			visibleState.Remove(ent);
		}
	}

	public bool ShouldCheckLineOfSight(BaseEntity ent)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)ent).transform.position;
		if (visibleState.ContainsKey(ent))
		{
			Vector3 val = visibleState[ent].Item2 - position;
			return ((Vector3)(ref val)).sqrMagnitude > 1f;
		}
		return true;
	}

	public bool HasLineOfSight(BaseEntity ent)
	{
		if (visibleState.ContainsKey(ent))
		{
			return visibleState[ent].Item1;
		}
		return false;
	}

	public void RecordLineOfSight(BaseEntity ent, bool state)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (visibleState.ContainsKey(ent))
		{
			visibleState[ent] = (state, ((Component)ent).transform.position);
		}
		else
		{
			visibleState.Add(ent, (state, ((Component)ent).transform.position));
		}
	}
}


using System;
using System.Linq;
using Rust;
using UnityEngine;

public class TeslaCoil : IOEntity
{
	public TargetTrigger targetTrigger;

	public TriggerMovement movementTrigger;

	public float powerToDamageRatio = 2f;

	public float dischargeTickRate = 0.25f;

	public float maxDischargeSelfDamageSeconds = 120f;

	public float maxDamageOutput = 35f;

	public Transform damageEyes;

	public const Flags Flag_WeakShorting = Flags.Reserved1;

	public const Flags Flag_StrongShorting = Flags.Reserved2;

	public int powerForHeavyShorting = 10;

	private float lastDischargeTime;

	public override int ConsumptionAmount()
	{
		return Mathf.CeilToInt(maxDamageOutput / powerToDamageRatio);
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if (!CanDischarge())
		{
			return 0;
		}
		return Mathf.Clamp(currentEnergy, 0, ConsumptionAmount());
	}

	public bool CanDischarge()
	{
		return base.healthFraction >= 0.1f;
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		base.UpdateFromInput(inputAmount, inputSlot);
		if (inputAmount > 0 && CanDischarge())
		{
			float num = Time.time - lastDischargeTime;
			if (num < 0f)
			{
				num = 0f;
			}
			float num2 = Mathf.Min(dischargeTickRate - num, dischargeTickRate);
			((FacepunchBehaviour)this).InvokeRepeating((Action)Discharge, num2, dischargeTickRate);
			SetFlag(Flags.Reserved1, inputAmount < powerForHeavyShorting, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, inputAmount >= powerForHeavyShorting, recursive: false, networkupdate: false);
			SetFlag(Flags.On, b: true);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)Discharge);
			SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
			SetFlag(Flags.On, b: false);
		}
	}

	public void Discharge()
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		float damageAmount = Mathf.Clamp((float)currentEnergy * powerToDamageRatio, 0f, maxDamageOutput) * dischargeTickRate;
		lastDischargeTime = Time.time;
		if (targetTrigger.entityContents != null)
		{
			BaseEntity[] array = targetTrigger.entityContents.ToArray();
			if (array != null)
			{
				BaseEntity[] array2 = array;
				for (int i = 0; i < array2.Length; i++)
				{
					BaseCombatEntity component = ((Component)array2[i]).GetComponent<BaseCombatEntity>();
					if (Object.op_Implicit((Object)(object)component) && component.IsVisible(((Component)damageEyes).transform.position, component.CenterPoint()))
					{
						component.OnAttacked(new HitInfo(this, component, DamageType.ElectricShock, damageAmount));
					}
				}
			}
		}
		float amount = dischargeTickRate / maxDischargeSelfDamageSeconds * MaxHealth();
		Hurt(amount, DamageType.ElectricShock, this, useProtection: false);
		if (!CanDischarge())
		{
			SendChangedToRoot(forceUpdate: true);
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		if (CanDischarge())
		{
			SendChangedToRoot(forceUpdate: true);
		}
	}
}


using UnityEngine;

public class CableTunnel : IOEntity
{
	private const int numChannels = 4;

	private int[] inputAmounts = new int[4];

	public override bool WantsPower(int inputIndex)
	{
		return true;
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		int num = inputAmounts[inputSlot];
		inputAmounts[inputSlot] = inputAmount;
		if (inputAmount != num)
		{
			ensureOutputsUpdated = true;
		}
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public override void UpdateOutputs()
	{
		if (!ShouldUpdateOutputs() || !ensureOutputsUpdated)
		{
			return;
		}
		for (int i = 0; i < 4; i++)
		{
			IOSlot iOSlot = outputs[i];
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOSlot.connectedTo.Get().UpdateFromInput(inputAmounts[i], iOSlot.connectedToSlot);
			}
		}
	}
}


public class BranchConfig : IOConfig<ElectricalBranch>
{
}


public class CommandBlockConfig : IOConfig<CommandBlock>
{
	private string _currentCommand;
}


public class CounterConfig : IOConfig<PowerCounter>
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class DigitalClockConfig : IOConfig<DigitalClock>
{
	public DigitalClockConfigAlarm alarmPrefab;

	public Transform alarmParent;

	public GameObject placeHolder;

	public Button addButton;

	public RustButton muteButton;
}


using Rust.UI;
using UnityEngine;

public class DigitalClockConfigAlarm : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public ClockSlider slider;

	public RustButton toggleButton;

	[Space]
	public GameObject deleteButton;

	private DigitalClockConfig owner;

	private bool deleteButtonHovered;

	public bool Active { get; private set; }
}


using Rust.UI;

public class HBHFConfig : IOConfig<HBHFSensor>
{
	public RustButton authButton;

	public RustButton nonAuthButton;
}


using Rust.UI;
using UnityEngine;

public abstract class IOConfig<T> : UIDialog
{
	[Space]
	public RustInput input;

	public float minValue;

	public float maxValue = 100f;
}


public class SeismicSensorConfig : IOConfig<SeismicSensor>
{
}


public class TimerConfig : IOConfig<CustomTimerSwitch>
{
}


using UnityEngine;

public class DynamicDirtLayerController : MonoBehaviour, IClientComponent, ICustomMaterialReplacer
{
	[Range(0f, 1f)]
	public float Amount = 0.5f;

	public Texture DirtTexture;
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;

public class LootPanelToolCupboard : LootPanel
{
	public List<VirtualItemIcon> costIcons;

	public RustText protectedText;

	public GameObject baseNotProtectedObj;

	public GameObject baseProtectedObj;

	public Phrase protectedPrefix;

	public Tooltip costToolTip;

	public Phrase blocksPhrase;

	public Phrase blocksAndDoorsPhrase;

	public GameObject toolsRow;
}


using System;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class InvisibleVendingMachine : NPCVendingMachine
{
	public GameObjectRef buyEffect;

	public NPCVendingOrderManifest vmoManifest;

	public bool canRefreshOrders;

	public EntityRef<NPCShopKeeper> cachedShopKeeper;

	public const Flags HasAttachedShopkeeper = Flags.Reserved7;

	private static ListHashSet<InvisibleVendingMachine> allMachines = new ListHashSet<InvisibleVendingMachine>();

	public TimeUntil nextOrderRefresh;

	protected override bool BlockOrderRefreshOnLoad => canRefreshOrders;

	public static InvisibleVendingMachine GetMachineAtPosition(float tolerance, Vector3 position)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<InvisibleVendingMachine> enumerator = allMachines.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				InvisibleVendingMachine current = enumerator.Current;
				if ((Object)(object)current != (Object)null && current.Distance(position) < tolerance)
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public void KeeperLookAt(Vector3 pos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		NPCShopKeeper nPCShopKeeper = cachedShopKeeper.Get(base.isServer);
		if (!((Object)(object)nPCShopKeeper == (Object)null))
		{
			nPCShopKeeper.SetAimDirection(Vector3Ex.Direction2D(pos, ((Component)nPCShopKeeper).transform.position));
		}
	}

	public override bool HasVendingSounds()
	{
		return false;
	}

	public override float GetBuyDuration()
	{
		return 0.5f;
	}

	public override void CompletePendingOrder()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(buyEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		NPCShopKeeper nPCShopKeeper = cachedShopKeeper.Get(base.isServer);
		if (Object.op_Implicit((Object)(object)nPCShopKeeper))
		{
			nPCShopKeeper.SignalBroadcast(Signal.Gesture, "victory");
			if ((Object)(object)vend_Player != (Object)null)
			{
				nPCShopKeeper.SetAimDirection(Vector3Ex.Direction2D(((Component)vend_Player).transform.position, ((Component)nPCShopKeeper).transform.position));
			}
		}
		base.CompletePendingOrder();
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		KeeperLookAt(((Component)player).transform.position);
		return base.PlayerOpenLoot(player, panelToOpen);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if ((Object)(object)vmoManifest != (Object)null && info.msg.vendingMachine != null)
		{
			info.msg.vendingMachine.vmoIndex = vmoManifest.GetIndex(vendingOrders);
		}
		info.msg.npcVendingMachine = Pool.Get<NPCVendingMachine>();
		info.msg.npcVendingMachine.attachedNpc = cachedShopKeeper.uid;
		info.msg.npcVendingMachine.nextRefresh = TimeUntil.op_Implicit(nextOrderRefresh);
	}

	public override void ServerInit()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (vmoManifest.GetIndex(vendingOrders) == -1)
		{
			Debug.LogError((object)"VENDING ORDERS NOT FOUND! Did you forget to add these orders to the VMOManifest?");
		}
		if (canRefreshOrders)
		{
			nextOrderRefresh = TimeUntil.op_Implicit(Server.waterWellNpcSalesRefreshFrequency * 60f * 60f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)CheckSellOrderRefresh, 30f, 30f);
		}
		allMachines.TryAdd(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		allMachines.Remove(this);
	}

	public void CheckSellOrderRefresh()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (TimeUntil.op_Implicit(nextOrderRefresh) < 0f)
		{
			nextOrderRefresh = TimeUntil.op_Implicit(Server.waterWellNpcSalesRefreshFrequency * 60f * 60f);
			InstallFromVendingOrders();
		}
	}

	public void SetAttachedNPC(NPCShopKeeper shopkeeper)
	{
		cachedShopKeeper.Set(shopkeeper);
		SetFlag(Flags.Reserved7, (Object)(object)shopkeeper != (Object)null);
		SendNetworkUpdate();
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if ((Object)(object)cachedShopKeeper.Get(base.isServer) == (Object)null)
		{
			return false;
		}
		return base.CanBeLooted(player);
	}

	protected override bool CanShop(BasePlayer bp)
	{
		if (base.CanShop(bp))
		{
			return (Object)(object)cachedShopKeeper.Get(base.isServer) != (Object)null;
		}
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.fromDisk && (Object)(object)vmoManifest != (Object)null && info.msg.vendingMachine != null)
		{
			NPCVendingOrder fromIndex = vmoManifest.GetFromIndex(info.msg.vendingMachine.vmoIndex);
			vendingOrders = fromIndex;
		}
		if (info.msg.npcVendingMachine != null)
		{
			cachedShopKeeper.uid = info.msg.npcVendingMachine.attachedNpc;
			if (base.isServer)
			{
				nextOrderRefresh = TimeUntil.op_Implicit(info.msg.npcVendingMachine.nextRefresh);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/NPC Vending Order")]
public class NPCVendingOrder : ScriptableObject
{
	[Serializable]
	public class Entry
	{
		public ItemDefinition sellItem;

		public int sellItemAmount;

		public bool sellItemAsBP;

		public ItemDefinition currencyItem;

		public int currencyAmount;

		public bool currencyAsBP;

		public int initialStock = -1;

		public int refillAmount = 1;

		public float refillDelay = 10f;

		public EntryRandom randomDetails;
	}

	[Serializable]
	public struct EntryRandom
	{
		public bool useRandom;

		[Range(0f, 1f)]
		[Tooltip("The higher this number, the more likely this will be chosen")]
		public float weight;

		[Tooltip("Minimum price for the currency item")]
		public int minPrice;

		[Tooltip("Maximum price for the currency item")]
		public int maxPrice;

		[Tooltip("Chance for a very low price to occur (0 to 1)")]
		[Range(0f, 1f)]
		public float veryLowPriceChance;

		[Tooltip("Minimum very low price")]
		public int veryLowPriceMin;

		[Tooltip("Maximum very low price")]
		public int veryLowPriceMax;

		public int GetRandomPrice()
		{
			int num = ((!(Random.value < veryLowPriceChance)) ? Random.Range(minPrice, maxPrice + 1) : Random.Range(veryLowPriceMin, veryLowPriceMax + 1));
			return Mathf.RoundToInt(((float)num + 2.5f) / 5f) * 5;
		}
	}

	public Era[] AllowedEras;

	public Entry[] orders;

	public void GetRandomEntries(int count, List<Entry> selectedEntries)
	{
		if (orders == null || orders.Length == 0 || count <= 0)
		{
			return;
		}
		List<bool> list = Pool.Get<List<bool>>();
		for (int i = 0; i < orders.Length; i++)
		{
			list.Add(item: false);
		}
		float num = 0f;
		count = Mathf.Min(count, orders.Length);
		Entry[] array = orders;
		foreach (Entry entry in array)
		{
			num += entry.randomDetails.weight;
		}
		for (int k = 0; k < count; k++)
		{
			if (num == 0f)
			{
				break;
			}
			float num2 = Random.Range(0f, num);
			for (int l = 0; l < orders.Length; l++)
			{
				Entry entry2 = orders[l];
				if (!list[l])
				{
					if (num2 < entry2.randomDetails.weight)
					{
						selectedEntries.Add(entry2);
						list[l] = true;
						num -= entry2.randomDetails.weight;
						break;
					}
					num2 -= entry2.randomDetails.weight;
				}
			}
		}
		Pool.FreeUnmanaged<bool>(ref list);
	}

	[ContextMenu("Print All Orders Info")]
	private void PrintOrdersInfo()
	{
		if (orders == null || orders.Length == 0)
		{
			Debug.Log((object)"No orders available.");
			return;
		}
		string text = "NPC Vending Orders Info:\n";
		Entry[] array = orders;
		foreach (Entry entry in array)
		{
			string arg = (((Object)(object)entry.sellItem != (Object)null) ? ((Object)entry.sellItem).name : "None");
			string arg2 = (((Object)(object)entry.currencyItem != (Object)null) ? ((Object)entry.currencyItem).name : "None");
			text = text + $"Sell Item: {arg}, Amount: {entry.sellItemAmount}, As Blueprint: {entry.sellItemAsBP}\n" + $"Currency Item: {arg2}, Amount: {entry.currencyAmount}, As Blueprint: {entry.currencyAsBP}\n" + $"Refill Amount: {entry.refillAmount}, Refill Delay: {entry.refillDelay}\n" + $"Random Details - Use Random: {entry.randomDetails.useRandom}, Weight: {entry.randomDetails.weight}\n" + $"Min Price: {entry.randomDetails.minPrice}, Max Price: {entry.randomDetails.maxPrice}\n" + $"Very Low Price Chance: {entry.randomDetails.veryLowPriceChance}, " + $"Very Low Price Min: {entry.randomDetails.veryLowPriceMin}, Very Low Price Max: {entry.randomDetails.veryLowPriceMax}\n\n";
			text += " ";
		}
		Debug.Log((object)text);
	}
}


using System;

[Serializable]
public class Entry
{
	public ItemDefinition sellItem;

	public int sellItemAmount;

	public bool sellItemAsBP;

	public ItemDefinition currencyItem;

	public int currencyAmount;

	public bool currencyAsBP;

	public int initialStock = -1;

	public int refillAmount = 1;

	public float refillDelay = 10f;

	public EntryRandom randomDetails;
}


using System;
using UnityEngine;

[Serializable]
public struct EntryRandom
{
	public bool useRandom;

	[Range(0f, 1f)]
	[Tooltip("The higher this number, the more likely this will be chosen")]
	public float weight;

	[Tooltip("Minimum price for the currency item")]
	public int minPrice;

	[Tooltip("Maximum price for the currency item")]
	public int maxPrice;

	[Tooltip("Chance for a very low price to occur (0 to 1)")]
	[Range(0f, 1f)]
	public float veryLowPriceChance;

	[Tooltip("Minimum very low price")]
	public int veryLowPriceMin;

	[Tooltip("Maximum very low price")]
	public int veryLowPriceMax;

	public int GetRandomPrice()
	{
		int num = ((!(Random.value < veryLowPriceChance)) ? Random.Range(minPrice, maxPrice + 1) : Random.Range(veryLowPriceMin, veryLowPriceMax + 1));
		return Mathf.RoundToInt(((float)num + 2.5f) / 5f) * 5;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/NPCVendingOrderManifest")]
public class NPCVendingOrderManifest : ScriptableObject
{
	public NPCVendingOrder[] orderList;

	public int GetIndex(NPCVendingOrder sample)
	{
		if ((Object)(object)sample == (Object)null)
		{
			return -1;
		}
		for (int i = 0; i < orderList.Length; i++)
		{
			NPCVendingOrder nPCVendingOrder = orderList[i];
			if ((Object)(object)sample == (Object)(object)nPCVendingOrder)
			{
				return i;
			}
		}
		return -1;
	}

	public NPCVendingOrder GetFromIndex(int index)
	{
		if (orderList == null)
		{
			return null;
		}
		if (index < 0)
		{
			return null;
		}
		if (index >= orderList.Length)
		{
			return null;
		}
		return orderList[index];
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Safety;
using UnityEngine;

public class NPCVendingMachine : VendingMachine
{
	public class SalesData
	{
		public ulong TotalSales;

		public ulong TotalIntervals;

		public ulong SoldThisInterval;

		public float CurrentMultiplier;

		public bool IsForReceivedCurrency;

		public double GetAverageSalesPerInterval()
		{
			if (TotalSales == 0L || TotalIntervals == 0L)
			{
				return 0.0;
			}
			return (double)TotalSales / (double)TotalIntervals;
		}

		public void RecordSale(int count)
		{
			SoldThisInterval += (ulong)count;
		}

		public void ProcessEndOfInterval()
		{
			double averageSalesPerInterval = GetAverageSalesPerInterval();
			bool flag = TotalIntervals == 0;
			TotalSales += SoldThisInterval;
			TotalIntervals++;
			SoldThisInterval = 0uL;
			float num = 0f;
			num = ((!(GetAverageSalesPerInterval() <= averageSalesPerInterval || flag)) ? PriceIncreaseAmount : (0f - PriceDecreaseAmount));
			if (IsForReceivedCurrency)
			{
				CurrentMultiplier -= num;
			}
			else
			{
				CurrentMultiplier += num;
			}
			CurrentMultiplier = Mathf.Clamp(CurrentMultiplier, MinimumPriceMultiplier, MaximumPriceMultiplier);
		}
	}

	public NPCVendingOrder vendingOrders;

	public Phrase Phrase;

	public NPCVendingOrder[] alternativeVendingOrders;

	public float RefillTime = 1f;

	public int StartingStock = 10;

	public bool BypassDynamicPricing;

	public const int MaxVendingEntries = 7;

	public const int Capacity = 128;

	private static ListHashSet<NPCVendingMachine> allNpcVendingMachines = new ListHashSet<NPCVendingMachine>();

	private float[] refillTimes;

	[ServerVar(Saved = true, Help = "Whether to run the the dynamic pricing system")]
	public static bool DynamicPricingEnabled = true;

	[ServerVar(Saved = true, Help = "How many realtime hours are checked when looking for price increases. Max 72 (10 days), min 0.5 (half an hour)", ShowInAdminUI = true)]
	public static float PriceUpdateFrequencyDefault = 3f;

	[ServerVar(Saved = true, Help = "How many realtime hours are checked when looking for price increases. Max 72 (10 days), min 0.5 (half an hour)", ShowInAdminUI = true)]
	public static float PriceUpdateFrequencyBiWeekly = 2f;

	[ServerVar(Saved = true, Help = "How many realtime hours are checked when looking for price increases. Max 72 (10 days), min 0.5 (half an hour)", ShowInAdminUI = true)]
	public static float PriceUpdateFrequencyWeekly = 1f;

	private static bool hasCachedTags = false;

	private static bool cachedBiWeekly;

	private static bool cachedWeekly;

	[ServerVar(Saved = true, Help = "The maximum point that a price can increase to (2 = 200%)")]
	public static float MaximumPriceMultiplier = 2f;

	[ServerVar(Saved = true, Help = "The Minimum point that the price can drop to (0.5 = 50% off)")]
	public static float MinimumPriceMultiplier = 0.5f;

	[ServerVar(Saved = true, Help = "What discount surcharge should be applied to items when the server starts")]
	public static float StartingPriceMultiplier = 2f;

	[ServerVar(Saved = true, Help = "How much to increase the price by if it is selling a lot (0.05 = 5%)")]
	public static float PriceIncreaseAmount = 0.1f;

	[ServerVar(Saved = true, Help = "How much to decrease the price for if it is underselling (0.05 = 5%)")]
	public static float PriceDecreaseAmount = 0.05f;

	private SalesData[] allSalesData;

	private float timeToNextSalesUpdate;

	private bool preserveSalesData;

	private static ItemDefinition _scrapItem = null;

	private TimeSince lastHourCheck;

	public override EraRestriction CurrentEraRestriction => (EraRestriction)1;

	protected virtual bool BlockOrderRefreshOnLoad => false;

	public override bool ShouldRecordStats => false;

	private static float ScaledByWipeUpdateFrequency
	{
		get
		{
			if (!hasCachedTags)
			{
				cachedBiWeekly = StringEx.Contains(ConVar.Server.tags, "biweekly", CompareOptions.IgnoreCase);
				cachedWeekly = StringEx.Contains(ConVar.Server.tags, "weekly", CompareOptions.IgnoreCase);
				hasCachedTags = true;
			}
			if (cachedBiWeekly)
			{
				return PriceUpdateFrequencyBiWeekly;
			}
			if (cachedWeekly)
			{
				return PriceUpdateFrequencyWeekly;
			}
			return PriceUpdateFrequencyDefault;
		}
	}

	public static float IntervalSeconds => Mathf.Clamp(ScaledByWipeUpdateFrequency, 0.5f, 72f) * 60f * 60f;

	public static ItemDefinition ScrapItem
	{
		get
		{
			if ((Object)(object)_scrapItem == (Object)null)
			{
				_scrapItem = ItemManager.FindItemDefinition("scrap");
			}
			return _scrapItem;
		}
	}

	private bool CanApplyDynamicPricing
	{
		get
		{
			if (!BypassDynamicPricing)
			{
				return DynamicPricingEnabled;
			}
			return false;
		}
	}

	public byte GetBPState(bool sellItemAsBP, bool currencyItemAsBP)
	{
		byte result = 0;
		if (sellItemAsBP)
		{
			result = 1;
		}
		if (currencyItemAsBP)
		{
			result = 2;
		}
		if (sellItemAsBP && currencyItemAsBP)
		{
			result = 3;
		}
		return result;
	}

	public override void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", (object)this, (object)takenCurrencyItem) == null)
		{
			takenCurrencyItem.MoveToContainer(base.inventory);
			takenCurrencyItem.RemoveFromContainer();
			takenCurrencyItem.Remove();
		}
	}

	public override void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnNpcGiveSoldItem", (object)this, (object)soldItem, (object)buyer) == null)
		{
			soldItem.SetItemOwnership(buyer, ItemOwnershipPhrases.VendorSale);
			base.GiveSoldItem(soldItem, buyer);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (!BlockOrderRefreshOnLoad)
		{
			((FacepunchBehaviour)this).Invoke((Action)InstallFromVendingOrders, 1f);
		}
	}

	public void ChangeRefillTime(float newRefillTime)
	{
		RefillTime = newRefillTime;
		if (((FacepunchBehaviour)this).IsInvoking((Action)Refill))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)Refill);
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)Refill, 1f, RefillTime, 0.1f);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		skinID = 861142659uL;
		SendNetworkUpdate();
		if (!BlockOrderRefreshOnLoad || !Application.isLoadingSave)
		{
			((FacepunchBehaviour)this).Invoke((Action)InstallFromVendingOrders, 1f);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)Refill))
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)Refill, 1f, RefillTime, 0.1f);
		}
		DynamicPricingServerInit();
		allNpcVendingMachines.TryAdd(this);
		UpdateDronePrediction();
		IsInDeepSeaCached = this.IsInsideDeepSea();
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		allNpcVendingMachines.Remove(this);
	}

	public virtual void InstallFromVendingOrders()
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Invalid comparison between I4 and Unknown
		if (alternativeVendingOrders != null && alternativeVendingOrders.Length != 0)
		{
			NPCVendingOrder[] array = alternativeVendingOrders;
			foreach (NPCVendingOrder nPCVendingOrder in array)
			{
				if (nPCVendingOrder.AllowedEras == null || nPCVendingOrder.AllowedEras.Length == 0)
				{
					vendingOrders = nPCVendingOrder;
					break;
				}
				Era[] allowedEras = nPCVendingOrder.AllowedEras;
				for (int j = 0; j < allowedEras.Length; j++)
				{
					if ((int)allowedEras[j] == (int)ConVar.Server.Era)
					{
						vendingOrders = nPCVendingOrder;
						break;
					}
				}
			}
		}
		if ((Object)(object)vendingOrders == (Object)null)
		{
			Debug.LogError((object)"No vending orders!");
			return;
		}
		int count = sellOrders.sellOrders.Count;
		ClearSellOrders();
		base.inventory.Clear();
		ItemManager.DoRemoves();
		if (numSlots == 0)
		{
			base.inventory.capacity = 128;
		}
		if (vendingOrders.orders.Length <= 7)
		{
			if (count == vendingOrders.orders.Length)
			{
				preserveSalesData = true;
			}
			try
			{
				NPCVendingOrder.Entry[] orders = vendingOrders.orders;
				foreach (NPCVendingOrder.Entry ent in orders)
				{
					SmartAddItemForSale(ent);
				}
				return;
			}
			finally
			{
				preserveSalesData = false;
			}
		}
		List<NPCVendingOrder.Entry> list = Pool.Get<List<NPCVendingOrder.Entry>>();
		vendingOrders.GetRandomEntries(7, list);
		foreach (NPCVendingOrder.Entry item in list)
		{
			SmartAddItemForSale(item);
		}
		Pool.FreeUnmanaged<NPCVendingOrder.Entry>(ref list);
	}

	private void SmartAddItemForSale(NPCVendingOrder.Entry ent)
	{
		int currencyPerTransaction = ent.currencyAmount;
		if (ent.randomDetails.useRandom)
		{
			currencyPerTransaction = ent.randomDetails.GetRandomPrice();
		}
		AddItemForSale(ent.sellItem.itemid, ent.sellItemAmount, ent.currencyItem.itemid, currencyPerTransaction, GetBPState(ent.sellItemAsBP, ent.currencyAsBP), ent.initialStock);
	}

	public override void InstallDefaultSellOrders()
	{
		base.InstallDefaultSellOrders();
	}

	public void Refill()
	{
		if ((Object)(object)vendingOrders == (Object)null || vendingOrders.orders == null || base.inventory == null)
		{
			return;
		}
		if (refillTimes == null)
		{
			refillTimes = new float[vendingOrders.orders.Length];
		}
		for (int i = 0; i < vendingOrders.orders.Length; i++)
		{
			NPCVendingOrder.Entry entry = vendingOrders.orders[i];
			if (!(Time.realtimeSinceStartup > refillTimes[i]))
			{
				continue;
			}
			int num = 0;
			num = ((!entry.sellItemAsBP) ? Mathf.FloorToInt((float)(base.inventory.GetAmount(entry.sellItem.itemid, onlyUsableAmounts: false) / entry.sellItemAmount)) : Mathf.FloorToInt((float)(base.inventory.GetAmount(base.blueprintBaseDef.itemid, entry.sellItem.itemid, onlyUsableAmounts: false) / entry.sellItemAmount)));
			int num2 = Mathf.Min(StartingStock - num, entry.refillAmount) * entry.sellItemAmount;
			if (num2 > 0)
			{
				transactionActive = true;
				Item item = null;
				if (entry.sellItemAsBP)
				{
					item = ItemManager.Create(base.blueprintBaseDef, num2, 0uL);
					item.blueprintTarget = entry.sellItem.itemid;
				}
				else
				{
					item = ItemManager.Create(entry.sellItem, num2, 0uL);
				}
				if (!item.MoveToContainer(base.inventory))
				{
					item.Remove();
				}
				transactionActive = false;
			}
			refillTimes[i] = Time.realtimeSinceStartup + entry.refillDelay;
		}
	}

	public void ClearSellOrders()
	{
		sellOrders.sellOrders.Clear();
	}

	public void AddItemForSale(int itemID, int amountToSell, int currencyID, int currencyPerTransaction, byte bpState, int initialStockOverride)
	{
		AddSellOrder(itemID, amountToSell, currencyID, currencyPerTransaction, bpState);
		transactionActive = true;
		int num = StartingStock;
		if (initialStockOverride >= 0)
		{
			num = Mathf.Min(initialStockOverride, StartingStock);
		}
		if (bpState == 1 || bpState == 3)
		{
			for (int i = 0; i < num; i++)
			{
				Item item = ItemManager.CreateByItemID(base.blueprintBaseDef.itemid, 1, 0uL);
				item.blueprintTarget = itemID;
				base.inventory.Insert(item);
			}
		}
		else
		{
			base.inventory.AddItem(ItemManager.FindItemDefinition(itemID), amountToSell * num, 0uL);
		}
		transactionActive = false;
		RefreshSellOrderStockLevel();
	}

	public void RefreshStock()
	{
	}

	protected override void RecordSaleAnalytics(Item itemSold, int orderId, int currencyUsed)
	{
		RecordSale(orderId, itemSold.amount, currencyUsed);
	}

	public override string GetTranslationToken()
	{
		return Phrase.token;
	}

	protected override bool CanRotate()
	{
		return false;
	}

	public override bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

	[ServerVar]
	public static void ResetFrequencyTags(Arg arg)
	{
		hasCachedTags = false;
		arg.ReplyWith($"Reset frequency tags. Scaled frequency is now:{ScaledByWipeUpdateFrequency} hours");
	}

	[ServerVar(Help = "Resets the state of all discounts and surcharges from NPC vending machines")]
	public static void resetDynamicPricing()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<NPCVendingMachine> enumerator = allNpcVendingMachines.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.ResetDynamicPricing();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Print out all current price changes on the server")]
	public static void printAllPriceChanges(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		Enumerator<NPCVendingMachine> enumerator = allNpcVendingMachines.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				NPCVendingMachine current = enumerator.Current;
				TextTable val = Pool.Get<TextTable>();
				try
				{
					val.AddColumns(new string[8] { "Item Name", "Original Price", "Discount/Surcharge", "Final Price", "Avg Sales/Interval", "Current Sales/Interval", "Total Sales", "Intervals" });
					int num = 0;
					int num2 = 0;
					foreach (SellOrder sellOrder in current.sellOrders.sellOrders)
					{
						if (sellOrder.priceMultiplier != 1f)
						{
							num++;
							ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellOrder.itemToSellID);
							int totalPriceForOrder = VendingMachine.GetTotalPriceForOrder(sellOrder);
							SalesData salesData = current.allSalesData[num2];
							val.AddRow(new string[8]
							{
								itemDefinition.shortname,
								sellOrder.currencyAmountPerItem.ToString(),
								$"{Mathf.RoundToInt(sellOrder.priceMultiplier * 100f)}%",
								$"{totalPriceForOrder}",
								salesData.GetAverageSalesPerInterval().ToString(),
								salesData.SoldThisInterval.ToString(),
								salesData.TotalSales.ToString(),
								salesData.TotalIntervals.ToString()
							});
						}
						num2++;
					}
					if (num > 0)
					{
						stringBuilder.AppendLine(current.shopName);
						stringBuilder.AppendLine("==============");
						stringBuilder.AppendLine(((object)val).ToString());
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar(Help = "Simulates the provided number of hours passing in the vending machine system")]
	public static void addHours(Arg arg)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)arg.GetInt(0, 0) * 60f * 60f;
		Enumerator<NPCVendingMachine> enumerator = allNpcVendingMachines.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				NPCVendingMachine current = enumerator.Current;
				current.lastHourCheck = TimeSince.op_Implicit(TimeSince.op_Implicit(current.lastHourCheck) + num);
				current.HourCheck();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public void RecordSale(int index, int countReceived, int currencyUsed)
	{
		if (CanApplyDynamicPricing)
		{
			CheckSalesDataLength();
			SalesData obj = allSalesData[index];
			obj.RecordSale(obj.IsForReceivedCurrency ? currencyUsed : countReceived);
		}
	}

	private void CheckSalesDataLength(bool reset = false)
	{
		if (reset)
		{
			allSalesData = null;
		}
		int count = sellOrders.sellOrders.Count;
		if (allSalesData == null || allSalesData.Length != count)
		{
			allSalesData = new SalesData[count];
			for (int i = 0; i < count; i++)
			{
				bool flag = sellOrders.sellOrders[i].itemToSellID == ScrapItem.itemid;
				allSalesData[i] = new SalesData
				{
					IsForReceivedCurrency = flag,
					CurrentMultiplier = (flag ? MinimumPriceMultiplier : StartingPriceMultiplier)
				};
			}
		}
	}

	protected override float GetDiscountForSlot(int sellOrderSlot, SellOrder forOrder)
	{
		if (!CanApplyDynamicPricing)
		{
			return 1f;
		}
		if (!preserveSalesData)
		{
			CheckSalesDataLength();
		}
		if (sellOrderSlot < 0 || sellOrderSlot >= allSalesData.Length)
		{
			return 1f;
		}
		if (forOrder.currencyID != ScrapItem.itemid)
		{
			return 1f;
		}
		return allSalesData[sellOrderSlot].CurrentMultiplier;
	}

	protected override float GetReceivedQuantityMultiplier(int sellOrderSlot, SellOrder forOrder)
	{
		if (!CanApplyDynamicPricing)
		{
			return 1f;
		}
		if (!preserveSalesData)
		{
			CheckSalesDataLength();
		}
		if (sellOrderSlot < 0 || sellOrderSlot >= allSalesData.Length)
		{
			return 1f;
		}
		if (forOrder.itemToSellID != ScrapItem.itemid)
		{
			return 1f;
		}
		return allSalesData[sellOrderSlot].CurrentMultiplier;
	}

	private void DynamicPricingServerInit()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		timeToNextSalesUpdate = IntervalSeconds;
		lastHourCheck = TimeSince.op_Implicit(0f);
		if (DeepSeaManager.IsInsideDeepSea((BaseNetworkable)this))
		{
			BypassDynamicPricing = true;
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)HourCheck, 1f, 15f, 0.1f);
	}

	private void ResetDynamicPricing()
	{
		CheckSalesDataLength(reset: true);
		timeToNextSalesUpdate = IntervalSeconds;
		HourCheck();
	}

	private void HourCheck()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!CanApplyDynamicPricing)
		{
			return;
		}
		float num = TimeSince.op_Implicit(lastHourCheck);
		lastHourCheck = TimeSince.op_Implicit(0f);
		timeToNextSalesUpdate -= num;
		while (timeToNextSalesUpdate < 0f)
		{
			timeToNextSalesUpdate += IntervalSeconds;
			if (allSalesData != null)
			{
				SalesData[] array = allSalesData;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].ProcessEndOfInterval();
				}
			}
			UpdateMapMarker();
			RefreshAndSendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (allSalesData != null && info.forDisk)
		{
			info.msg.vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
			info.msg.vendingDynamicPricing.allSalesData = Pool.Get<List<SalesData>>();
			info.msg.vendingDynamicPricing.timeToNextSalesUpdate = timeToNextSalesUpdate;
			SalesData[] array = allSalesData;
			foreach (SalesData salesData in array)
			{
				SalesData val = Pool.Get<SalesData>();
				val.totalSales = salesData.TotalSales;
				val.totalIntervals = salesData.TotalIntervals;
				val.soldThisInterval = salesData.SoldThisInterval;
				val.currentMultiplier = salesData.CurrentMultiplier;
				val.isForReceivedQuantity = salesData.IsForReceivedCurrency;
				info.msg.vendingDynamicPricing.allSalesData.Add(val);
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		if (info.msg.vendingDynamicPricing != null)
		{
			allSalesData = new SalesData[info.msg.vendingDynamicPricing.allSalesData.Count];
			int num = 0;
			timeToNextSalesUpdate = info.msg.vendingDynamicPricing.timeToNextSalesUpdate;
			foreach (SalesData allSalesDatum in info.msg.vendingDynamicPricing.allSalesData)
			{
				SalesData salesData = new SalesData
				{
					TotalSales = allSalesDatum.totalSales,
					TotalIntervals = allSalesDatum.totalIntervals,
					SoldThisInterval = allSalesDatum.soldThisInterval,
					CurrentMultiplier = allSalesDatum.currentMultiplier,
					IsForReceivedCurrency = allSalesDatum.isForReceivedQuantity
				};
				allSalesData[num] = salesData;
				num++;
			}
		}
		base.Load(info);
	}
}


using UnityEngine;

public class SalesData
{
	public ulong TotalSales;

	public ulong TotalIntervals;

	public ulong SoldThisInterval;

	public float CurrentMultiplier;

	public bool IsForReceivedCurrency;

	public double GetAverageSalesPerInterval()
	{
		if (TotalSales == 0L || TotalIntervals == 0L)
		{
			return 0.0;
		}
		return (double)TotalSales / (double)TotalIntervals;
	}

	public void RecordSale(int count)
	{
		SoldThisInterval += (ulong)count;
	}

	public void ProcessEndOfInterval()
	{
		double averageSalesPerInterval = GetAverageSalesPerInterval();
		bool flag = TotalIntervals == 0;
		TotalSales += SoldThisInterval;
		TotalIntervals++;
		SoldThisInterval = 0uL;
		float num = 0f;
		num = ((!(GetAverageSalesPerInterval() <= averageSalesPerInterval || flag)) ? PriceIncreaseAmount : (0f - PriceDecreaseAmount));
		if (IsForReceivedCurrency)
		{
			CurrentMultiplier -= num;
		}
		else
		{
			CurrentMultiplier += num;
		}
		CurrentMultiplier = Mathf.Clamp(CurrentMultiplier, MinimumPriceMultiplier, MaximumPriceMultiplier);
	}
}


using UnityEngine;
using UnityEngine.UI;

public class AddSellOrderManager : MonoBehaviour
{
	public VirtualItemIcon sellItemIcon;

	public VirtualItemIcon currencyItemIcon;

	public GameObject itemSearchParent;

	public ItemSearchEntry itemSearchEntryPrefab;

	public InputField sellItemInput;

	public InputField sellItemAmount;

	public InputField currencyItemInput;

	public InputField currencyItemAmount;

	public VendingPanelAdmin adminPanel;
}


using UnityEngine;

public class AdminExistingSellOrder : MonoBehaviour
{
	public VirtualItemIcon MerchandiseIcon;

	public VirtualItemIcon CurrencyIcon;

	private VendingPanelAdmin adminPanel;

	private int index;
}


using UnityEngine;
using UnityEngine.UI;

public class ItemSearchEntry : MonoBehaviour
{
	public Button button;

	public Text text;

	public RawImage image;

	public RawImage bpImage;
}


using UnityEngine;

public class LootPanelVendingMachine : LootPanel, IVendingMachineInterface
{
	public GameObjectRef sellOrderPrefab;

	public GameObject sellOrderContainer;

	public GameObject busyOverlayPrefab;

	private GameObject busyOverlayInstance;
}


public interface IVendingMachineInterface
{
}


using UnityEngine;

public class SellOrderEntry : MonoBehaviour, IInventoryChanged
{
	public VirtualItemIcon MerchandiseIcon;

	public VirtualItemIcon CurrencyIcon;

	private ItemDefinition merchandiseInfo;

	private ItemDefinition currencyInfo;

	public GameObject buyButton;

	public GameObject cantaffordNotification;

	public GameObject outOfStockNotification;

	private IVendingMachineInterface vendingPanel;

	public UIIntegerEntry intEntry;

	public VendingPriceMultiplierWidget priceMultiplier;

	public VendingPriceMultiplierWidget receivedCurrencyMultiplier;
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class FeedEntry : FacepunchBehaviour
{
	[Header("References")]
	public FlexElement Element;

	[SerializeField]
	private FlexTransition transition;

	public RectTransform TimeElement;

	[Header("Text")]
	public RustText IndexText;

	public RustText SoldText;

	public RustText EarnedText;

	[Header("Icons")]
	public Image IndexBacking;

	public VirtualItemIcon SoldIcon;

	public VirtualItemIcon EarnedIcon;

	[Header("Tooltips")]
	public Tooltip SoldIconTooltip;

	public Tooltip EarnedIconTooltip;

	public Tooltip TimeTooltip;
}


using TMPro;
using UnityEngine;

public class VendingPanelAdmin : UIDialog
{
	public GameObjectRef statsPanelRef;

	public AddSellOrderManager sellOrderManager;

	public EmojiGallery emojiGallery;

	public GameObject sellOrderAdminContainer;

	public GameObject sellOrderAdminPrefab;

	public TMP_InputField storeNameInputField;

	[Header("Drone Prediction")]
	public DeliveryDroneConfig predictionConfig;

	public GameObject droneAccessible;

	public GameObject droneInaccessible;
}


using Rust.UI;
using UnityEngine;

public class VendingPanelAdminStats : UIDialog
{
	[Header("References")]
	public Transform Feed;

	public TmProEmojiRedirector ShopName;

	public Dropdown TimeDropdown;

	public RustButton[] CategoryButtons;

	public RustText TotalSalesLabel;

	public RustText TotalSalesValue;

	public RustText PeakSaleHourLabel;

	public RustText PeakSaleHourValue;

	public RustText UniqueCustomersLabel;

	public RustText UniqueCustomersValue;

	public RustText RepeatCustomersLabel;

	public RustText RepeatCustomersValue;

	public RustText BestCustomerLabel;

	public RustText BestCustomerValue;

	[Header("Prefabs")]
	public GameObjectRef FeedEntryPrefab;

	public GameObjectRef SingleEntryPrefab;

	public GameObjectRef EmptyFeedEntryPrefab;
}


using Rust.UI;
using UnityEngine;

public class VendingPriceMultiplierWidget : MonoBehaviour
{
	public GameObject SurchargeRoot;

	public RustText SurchargeText;

	public GameObject DiscountRoot;

	public RustText DiscountText;

	public Tooltip SurchargeTooltip;

	public Tooltip DiscountTooltip;

	public GameObject RegularTooltip;

	public GameObject AlwaysOnTopTooltip;

	public bool Invert;
}


public class VendingMachineFront : BaseEntity
{
	public VendingMachine vendingMachine;
}


using UnityEngine;
using UnityEngine.UI;

public class VendingMachineScreen : MonoBehaviour, INotifyLOD, IClientComponent
{
	public enum vmScreenState
	{
		ItemScroll,
		Vending,
		Message,
		ShopName,
		OutOfStock
	}

	public RawImage largeIcon;

	public RawImage blueprintIcon;

	public Text mainText;

	public Text lowerText;

	public Text centerText;

	public RawImage smallIcon;

	public VendingMachine vendingMachine;

	public Sprite outOfStockSprite;

	public Renderer fadeoutMesh;

	public CanvasGroup screenCanvas;

	public Renderer light1;

	public Renderer light2;

	public bool isUpdatedWithNotifySystem;
}


public enum vmScreenState
{
	ItemScroll,
	Vending,
	Message,
	ShopName,
	OutOfStock
}


using System;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class ElectricWindmill : IOEntity
{
	public Animator animator;

	public int maxPowerGeneration = 100;

	public Transform vaneRot;

	public Transform sailsRot;

	public SoundDefinition wooshSound;

	public Transform wooshOrigin;

	private float cachedHeight;

	public float serverWindSpeed;

	public override int MaximalPowerOutput()
	{
		return maxPowerGeneration;
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public Vector3 GetWindAimDir(float time)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		float num = time / 3600f * 360f;
		int num2 = 10;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.Sin(num * (MathF.PI / 180f)) * (float)num2, 0f, Mathf.Cos(num * (MathF.PI / 180f)) * (float)num2);
		return ((Vector3)(ref val)).normalized;
	}

	public override void ServerInit()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)WindUpdate, 1f, 20f, 2f);
		if (GamePhysics.Trace(new Ray(((Component)this).transform.position, Vector3.down), 0f, out var hitInfo, 10f, 8454144, (QueryTriggerInteraction)1, this))
		{
			cachedHeight = ((Component)this).transform.position.y - ((RaycastHit)(ref hitInfo)).point.y;
		}
		else
		{
			cachedHeight = ((Component)this).transform.position.y - TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position);
		}
	}

	public bool AmIVisible()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		int num = 15;
		Vector3 val = ((Component)this).transform.position + Vector3.up * 6f;
		if (!IsVisible(val + ((Component)this).transform.up * (float)num, (float)(num + 1)))
		{
			return false;
		}
		Vector3 windAimDir = GetWindAimDir(Time.time);
		if (!IsVisible(val + windAimDir * (float)num, (float)(num + 1)))
		{
			return false;
		}
		return true;
	}

	public void WindUpdate()
	{
		if (Interface.CallHook("OnWindmillUpdate", (object)this) == null)
		{
			serverWindSpeed = GetWindSpeedScale();
			if (!AmIVisible())
			{
				serverWindSpeed = 0f;
			}
			int num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);
			bool num2 = currentEnergy != num;
			currentEnergy = num;
			if (num2)
			{
				MarkDirty();
			}
			SendNetworkUpdate();
			Interface.CallHook("OnWindmillUpdated", (object)this);
		}
	}

	public float GetWindSpeedScale()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time / 600f;
		float num2 = ((Component)this).transform.position.x / 512f;
		float num3 = ((Component)this).transform.position.z / 512f;
		float num4 = Mathf.PerlinNoise(num2 + num, num3 + num * 0.1f);
		float num5 = cachedHeight;
		if (num5 < 0f)
		{
			num5 = 0f;
		}
		return Mathf.Clamp01(Mathf.InverseLerp(0f, 50f, num5) * 0.5f + num4);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot != 0)
		{
			return 0;
		}
		return currentEnergy;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			if (info.msg.ioEntity == null)
			{
				info.msg.ioEntity = Pool.Get<IOEntity>();
			}
			info.msg.ioEntity.genericFloat1 = Time.time;
			info.msg.ioEntity.genericFloat2 = serverWindSpeed;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class BounceLight : MonoBehaviour
{
	public Light masterLight;

	public float maxBounceLightDistance;

	public float maxBounceLightSpawnRange;

	public List<Light> bouncedLights = new List<Light>();

	public GameObject bounceLightPrefab;

	public int maxBounceLights = 64;

	public float placementBias = 0.2f;

	public float radiusFraction = 2f;

	public float minPlacementDistance;

	public float bounceIntensityOverrideScale = 1f;

	public float mergeDist = 1f;
}


using ProtoBuf;

public class ItemModBeehiveNucleus : ItemMod
{
	public override void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected O, but got Unknown
		base.OnVirginItem(item, creatingPlayer);
		item.instanceData = new InstanceData
		{
			ShouldPool = false,
			dataInt = 0
		};
	}
}


using ProtoBuf;
using UnityEngine;

public class NucleusGradeItemSwap : ItemModSwap
{
	public ItemDefinition NucleusItem;

	protected override void AugmentItem(Item item)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Expected O, but got Unknown
		if ((Object)(object)item.info == (Object)(object)NucleusItem)
		{
			item.instanceData = new InstanceData
			{
				ShouldPool = false,
				dataInt = 0
			};
		}
	}
}


using System.Collections.Generic;

public static class NucleusGrading
{
	public enum NucleusGrade
	{
		Grade3,
		Grade2,
		Grade1
	}

	private static readonly Dictionary<NucleusGrade, float> NucleusXpThresholds = new Dictionary<NucleusGrade, float>
	{
		{
			NucleusGrade.Grade3,
			0f
		},
		{
			NucleusGrade.Grade2,
			200f
		},
		{
			NucleusGrade.Grade1,
			600f
		}
	};

	public static float GetXpThreshold(NucleusGrade grade)
	{
		return NucleusXpThresholds[grade];
	}

	public static string GetGradeAsString(NucleusGrade grade)
	{
		return grade switch
		{
			NucleusGrade.Grade3 => "3", 
			NucleusGrade.Grade2 => "2", 
			NucleusGrade.Grade1 => "1", 
			_ => "0", 
		};
	}

	public static NucleusGrade XpToGrade(float xp)
	{
		if (xp >= NucleusXpThresholds[NucleusGrade.Grade1])
		{
			return NucleusGrade.Grade1;
		}
		if (xp >= NucleusXpThresholds[NucleusGrade.Grade2])
		{
			return NucleusGrade.Grade2;
		}
		return NucleusGrade.Grade3;
	}

	public static float XpToNextGrade(float currentXp)
	{
		NucleusGrade key;
		switch (XpToGrade(currentXp))
		{
		case NucleusGrade.Grade3:
			key = NucleusGrade.Grade2;
			break;
		case NucleusGrade.Grade2:
			key = NucleusGrade.Grade1;
			break;
		default:
			return 0f;
		}
		return NucleusXpThresholds[key] - currentXp;
	}
}


public enum NucleusGrade
{
	Grade3,
	Grade2,
	Grade1
}


using System.Text;
using Rust.UI;

public class NucleusInformationPanel : ItemInformationPanel
{
	public InfoBar xpDisplay;

	public RustText gradeLabel;

	public RustText nextLevelLabel;

	public static readonly Phrase GradePhrase = new Phrase("nucleus.grade", "GRADE {0}");

	public static readonly Phrase XPPhrase = new Phrase("nucleus.xp", "{0} XP");

	public static readonly Phrase XPRequiredPhrase = new Phrase("nucleus.required", "{0} XP REQUIRED");

	public static readonly Phrase MaxPhrase = new Phrase("nucleus.max", "MAX LEVEL");

	private static StringBuilder builder;
}


using UnityEngine;

public class FoodIcon : MonoBehaviour, IEditorComponent
{
	public ItemDefinition FoodItem;
}


using UnityEngine;

public class InstrumentStateBehaviour : StateMachineBehaviour
{
}


using UnityEngine;

public class InstrumentViewmodel : MonoBehaviour
{
	public Animator ViewAnimator;

	public bool UpdateA = true;

	public bool UpdateB = true;

	public bool UpdateC = true;

	public bool UpdateD = true;

	public bool UpdateE = true;

	public bool UpdateF = true;

	public bool UpdateG = true;

	public bool UpdateRecentlyPlayed = true;

	public bool UpdatePlayedNoteTrigger;

	public bool UseTriggers;

	private readonly int note_a = Animator.StringToHash("play_A");

	private readonly int note_b = Animator.StringToHash("play_B");

	private readonly int note_c = Animator.StringToHash("play_C");

	private readonly int note_d = Animator.StringToHash("play_D");

	private readonly int note_e = Animator.StringToHash("play_E");

	private readonly int note_f = Animator.StringToHash("play_F");

	private readonly int note_g = Animator.StringToHash("play_G");

	private readonly int recentlyPlayedHash = Animator.StringToHash("recentlyPlayed");

	private readonly int playedNoteHash = Animator.StringToHash("playedNote");

	public void UpdateSlots(InstrumentKeyController.AnimationSlot currentSlot, bool recentlyPlayed, bool playedNoteThisFrame)
	{
		if (!((Object)(object)ViewAnimator == (Object)null))
		{
			if (UpdateA)
			{
				UpdateState(note_a, currentSlot == InstrumentKeyController.AnimationSlot.One);
			}
			if (UpdateB)
			{
				UpdateState(note_b, currentSlot == InstrumentKeyController.AnimationSlot.Two);
			}
			if (UpdateC)
			{
				UpdateState(note_c, currentSlot == InstrumentKeyController.AnimationSlot.Three);
			}
			if (UpdateD)
			{
				UpdateState(note_d, currentSlot == InstrumentKeyController.AnimationSlot.Four);
			}
			if (UpdateE)
			{
				UpdateState(note_e, currentSlot == InstrumentKeyController.AnimationSlot.Five);
			}
			if (UpdateF)
			{
				UpdateState(note_f, currentSlot == InstrumentKeyController.AnimationSlot.Six);
			}
			if (UpdateG)
			{
				UpdateState(note_g, currentSlot == InstrumentKeyController.AnimationSlot.Seven);
			}
			if (UpdateRecentlyPlayed)
			{
				ViewAnimator.SetBool(recentlyPlayedHash, recentlyPlayed);
			}
			if (UpdatePlayedNoteTrigger && playedNoteThisFrame)
			{
				ViewAnimator.SetTrigger(playedNoteHash);
			}
		}
	}

	private void UpdateState(int param, bool state)
	{
		if (!UseTriggers)
		{
			ViewAnimator.SetBool(param, state);
		}
		else if (state)
		{
			ViewAnimator.SetTrigger(param);
		}
	}
}


public class PaintableReactiveTarget : ReactiveTarget
{
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class BigWheelGame : SpinnerWheel
{
	public float baseSpeed = 180f;

	public float offset = 3.852f;

	public AnimationCurve decelerationCurve;

	public AnimationCurve speedCurve;

	public HitNumber[] hitNumbers;

	private float targetAngle;

	private float minimumSpinTime;

	private bool isSpinning;

	private bool decelerating;

	private float elapsedTime;

	private Random random;

	[ServerVar]
	public static float spinFrequencySeconds = 45f;

	public int spinNumber;

	protected int targetNumber;

	public int lastPaidSpinNumber = -1;

	public List<BigWheelBettingTerminal> terminals = new List<BigWheelBettingTerminal>();

	public override bool AllowPlayerSpins()
	{
		return false;
	}

	public override bool CanUpdateSign(BasePlayer player)
	{
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)InitBettingTerminals, 3f);
		((FacepunchBehaviour)this).Invoke((Action)DoSpin, 10f);
	}

	public void DoSpin()
	{
		int seed = Random.Range(int.MinValue, int.MaxValue);
		random = new Random(seed);
		targetNumber = random.Next(0, hitNumbers.Length);
		targetAngle = 0f - 360f / (float)hitNumbers.Length * (float)targetNumber + offset;
		targetAngle += (float)(random.NextDouble() * 12.0 - 6.0);
		minimumSpinTime = (float)(random.NextDouble() * 5.0 + 13.0);
		elapsedTime = 0f;
		isSpinning = true;
		decelerating = false;
		spinNumber++;
		SetTerminalsLocked(isLocked: true);
	}

	public void SetTerminalsLocked(bool isLocked)
	{
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (!((Object)(object)terminal == (Object)null) && terminal.inventory != null)
			{
				terminal.inventory.SetLocked(isLocked);
			}
		}
	}

	public void RemoveTerminal(BigWheelBettingTerminal terminal)
	{
		terminals.Remove(terminal);
	}

	public void InitBettingTerminals()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		terminals.Clear();
		Vis.Entities(((Component)this).transform.position, 30f, terminals, 256, (QueryTriggerInteraction)2);
		terminals = terminals.Distinct().ToList();
	}

	public float GetMaxSpinSpeed(float time)
	{
		return baseSpeed * speedCurve.Evaluate(time / minimumSpinTime);
	}

	public override void Update_Server()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		if (!isSpinning)
		{
			return;
		}
		float deltaTime = Time.deltaTime;
		elapsedTime += deltaTime;
		float num = NormalizeAngle(wheel.localEulerAngles.y);
		float num2 = NormalizeAngle(targetAngle);
		float num3 = (num2 - num + 360f) % 360f;
		if (!decelerating && (elapsedTime < minimumSpinTime || num3 < 120f))
		{
			float maxSpinSpeed = GetMaxSpinSpeed(elapsedTime);
			wheel.Rotate(((Component)this).transform.up, maxSpinSpeed * deltaTime, (Space)0);
		}
		else
		{
			decelerating = true;
			float num4 = decelerationCurve.Evaluate(num3 / 180f);
			float num5 = GetMaxSpinSpeed(elapsedTime) * num4 * deltaTime;
			if (num5 > num3)
			{
				num5 = num3;
			}
			wheel.Rotate(((Component)this).transform.up, num5, (Space)0);
			if (num3 < 0.1f)
			{
				wheel.localRotation = Quaternion.Euler(0f, num2, 0f);
				isSpinning = false;
				if (spinNumber > lastPaidSpinNumber)
				{
					Payout();
					lastPaidSpinNumber = spinNumber;
					QueueSpin();
				}
			}
		}
		SendNetworkUpdate();
	}

	private float NormalizeAngle(float angle)
	{
		angle %= 360f;
		if (angle < 0f)
		{
			angle += 360f;
		}
		return angle;
	}

	public float SpinSpacing()
	{
		return spinFrequencySeconds;
	}

	public void QueueSpin()
	{
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			terminal.ClientRPC(RpcTarget.NetworkGroup("SetTimeUntilNextSpin"), SpinSpacing());
		}
		((FacepunchBehaviour)this).Invoke((Action)DoSpin, SpinSpacing());
	}

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		Guid value = Guid.NewGuid();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient || (Object)(object)terminal == (Object)null || terminal.inventory == null)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				int amount = slot.amount;
				if (Interface.CallHook("OnBigWheelWin", (object)this, (object)slot, (object)terminal, (object)num) == null)
				{
					slot.amount += slot.amount * num;
					slot.RemoveFromContainer();
					slot.MoveToContainer(terminal.inventory, 5);
					flag = true;
					Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);
				}
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (slot2 != null && Interface.CallHook("OnBigWheelLoss", (object)this, (object)slot2, (object)terminal) == null)
				{
					Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(RpcTarget.NetworkGroup("WinOrLoseSound"), flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

	public HitNumber GetCurrentHitType()
	{
		return hitNumbers[targetNumber];
	}
}


using UnityEngine;

public class HitNumber : MonoBehaviour
{
	public enum HitType
	{
		Yellow,
		Green,
		Blue,
		Purple,
		Red
	}

	public HitType hitType;

	public int ColorToMultiplier(HitType type)
	{
		return type switch
		{
			HitType.Yellow => 1, 
			HitType.Green => 3, 
			HitType.Blue => 5, 
			HitType.Purple => 10, 
			HitType.Red => 20, 
			_ => 0, 
		};
	}

	public void OnDrawGizmosSelected()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.white;
		Gizmos.DrawSphere(((Component)this).transform.position, 0.025f);
	}
}


public enum HitType
{
	Yellow,
	Green,
	Blue,
	Purple,
	Red
}


using Rust.UI;

public class LootPanelBigWheelTerminal : LootPanel
{
	public RustText timeRemainingText;
}


using UnityEngine.UI;

public class SlotMachineLootPanel : LootPanel
{
	public Text spinsRemainingText;

	public Text multiplierText;

	public LocalizeText ScrapCostText;
}


using UnityEngine;

public class SlotMachinePayoutDisplay : MonoBehaviour
{
	public GameObjectRef PayoutWidget;

	public RectTransform WidgetRoot;

	public Sprite[] FaceSprites;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Slot Machine Payouts")]
public class SlotMachinePayoutSettings : ScriptableObject
{
	[Serializable]
	public struct PayoutInfo
	{
		public ItemAmount Item;

		[Range(0f, 15f)]
		public int Result1;

		[Range(0f, 15f)]
		public int Result2;

		[Range(0f, 15f)]
		public int Result3;

		public GameObjectRef OverrideWinEffect;
	}

	[Serializable]
	public struct IndividualPayouts
	{
		public ItemAmount Item;

		[Range(0f, 15f)]
		public int Result;
	}

	public ItemAmount SpinCost;

	public PayoutInfo[] Payouts;

	public int[] VirtualFaces = new int[16];

	public IndividualPayouts[] FacePayouts = new IndividualPayouts[0];

	public int TotalStops;

	public GameObjectRef DefaultWinEffect;
}


using System;
using UnityEngine;

[Serializable]
public struct PayoutInfo
{
	public ItemAmount Item;

	[Range(0f, 15f)]
	public int Result1;

	[Range(0f, 15f)]
	public int Result2;

	[Range(0f, 15f)]
	public int Result3;

	public GameObjectRef OverrideWinEffect;
}


using System;
using UnityEngine;

[Serializable]
public struct IndividualPayouts
{
	public ItemAmount Item;

	[Range(0f, 15f)]
	public int Result;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SlotMachinePayoutWidget : MonoBehaviour
{
	public RustText PayoutAmount;

	public GameObject AnyText;

	public Image[] Faces;
}


using UnityEngine;

public class ChineseLantern : BaseFuelLightSource
{
	public Transform pivotRotator;

	public float swaySpeed = 1f;

	public float swayDistance = 0.25f;

	public float lerpSpeed = 2f;
}


using System;
using Rust;
using UnityEngine;

public class SkyLantern : StorageContainer, IIgniteable
{
	public float gravityScale = -0.1f;

	public float travelSpeed = 2f;

	public float collisionRadius = 0.5f;

	public float rotationSpeed = 5f;

	public float randOffset = 1f;

	public float lifeTime = 120f;

	public float hoverHeight = 14f;

	public Transform collisionCheckPoint;

	private float idealAltitude;

	private Vector3 travelVec = Vector3.forward;

	private float takeOffY;

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		randOffset = ((Random.Range(0.5f, 1f) * (float)Random.Range(0, 2) == 1f) ? (-1f) : 1f);
		Vector3 val = Vector3.forward + Vector3.right * randOffset;
		travelVec = ((Vector3)(ref val)).normalized;
		((FacepunchBehaviour)this).Invoke((Action)StartSinking, lifeTime - 15f);
		((FacepunchBehaviour)this).Invoke((Action)SelfDestroy, lifeTime);
		travelSpeed = Random.Range(1.75f, 2.25f);
		gravityScale *= Random.Range(1f, 1.25f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateIdealAltitude, 0f, 1f);
	}

	public void Ignite(Vector3 fromPos)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).gameObject.transform.RemoveComponent<GroundWatch>();
		((Component)this).gameObject.transform.RemoveComponent<DestroyOnGroundMissing>();
		((Component)this).gameObject.layer = 14;
		takeOffY = ((Component)this).transform.position.y;
		travelVec = Vector3Ex.Direction2D(((Component)this).transform.position, fromPos);
		SetFlag(Flags.On, b: true);
		UpdateIdealAltitude();
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.OnAttacked(info);
		if (base.isServer)
		{
			if (info.damageTypes.Has(DamageType.Heat) && CanIgnite())
			{
				Ignite(info.PointStart);
			}
			else if (IsOn() && !IsBroken())
			{
				StartSinking();
			}
		}
	}

	public void SelfDestroy()
	{
		Kill();
	}

	public bool CanIgnite()
	{
		if (!IsOn())
		{
			return !IsBroken();
		}
		return false;
	}

	public void UpdateIdealAltitude()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (IsOn())
		{
			idealAltitude = WaterLevel.GetWaterOrTerrainSurface(((Component)this).transform.position, waves: false, volumes: false) + hoverHeight;
			if (takeOffY > idealAltitude)
			{
				idealAltitude = takeOffY + hoverHeight;
			}
			if (hoverHeight != 0f)
			{
				idealAltitude -= 2f * Mathf.Abs(randOffset);
			}
		}
	}

	public void StartSinking()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!IsBroken())
		{
			hoverHeight = 0f;
			travelVec = Vector3.zero;
			UpdateIdealAltitude();
			SetFlag(Flags.Broken, b: true);
		}
	}

	public void FixedUpdate()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && IsOn())
		{
			float num = Mathf.Abs(((Component)this).transform.position.y - idealAltitude);
			float num2 = ((((Component)this).transform.position.y < idealAltitude) ? (-1f) : 1f);
			float num3 = Mathf.InverseLerp(0f, 10f, num) * num2;
			if (IsBroken())
			{
				travelVec = Vector3.Lerp(travelVec, Vector3.zero, Time.fixedDeltaTime * 0.5f);
				num3 = 0.7f;
			}
			Vector3 zero = Vector3.zero;
			zero = Vector3.up * gravityScale * Physics.gravity.y * num3;
			zero += travelVec * travelSpeed;
			Vector3 val = ((Component)this).transform.position + zero * Time.fixedDeltaTime;
			Vector3 val2 = Vector3Ex.Direction(val, ((Component)this).transform.position);
			float num4 = Vector3.Distance(val, ((Component)this).transform.position);
			RaycastHit val3 = default(RaycastHit);
			if (!Physics.SphereCast(collisionCheckPoint.position, collisionRadius, val2, ref val3, num4, 1218519297))
			{
				((Component)this).transform.position = val;
				((Component)this).transform.Rotate(Vector3.up, rotationSpeed * randOffset * Time.deltaTime, (Space)1);
			}
			else
			{
				StartSinking();
			}
		}
	}
}


using UnityEngine;

public class FirecrackerRepeater : BaseMonoBehaviour, IClientComponent
{
	public GameObjectRef singleExplosionEffect;

	public Transform[] parts;

	public float partWidth = 0.2f;

	public float partLength = 0.1f;

	public Quaternion[] targetRotations;

	public Quaternion[] initialRotations;

	public Renderer[] renderers;

	public Material materialSource;

	public float explodeRepeatMin = 0.05f;

	public float explodeRepeatMax = 0.15f;

	public float explodeLerpSpeed = 30f;

	public Vector3 twistAmount;

	public float fuseLength = 3f;

	public float explodeStrength = 10f;

	public float explodeDirBlend = 0.5f;

	public float duration = 10f;

	public ParticleSystemContainer smokeParticle;
}


using UnityEngine;

public class StringFirecracker : TimedExplosive
{
	public Rigidbody serverRigidBody;

	public Rigidbody clientMiddleBody;

	public Rigidbody[] clientParts;

	public SpringJoint serverClientJoint;

	public Transform clientFirecrackerTransform;

	public override void InitShared()
	{
		base.InitShared();
		if (!base.isServer)
		{
			return;
		}
		Rigidbody[] array = clientParts;
		foreach (Rigidbody val in array)
		{
			if ((Object)(object)val != (Object)null)
			{
				val.isKinematic = true;
			}
		}
	}

	public void CreatePinJoint()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)serverClientJoint != (Object)null))
		{
			serverClientJoint = ((Component)this).gameObject.AddComponent<SpringJoint>();
			((Joint)serverClientJoint).connectedBody = clientMiddleBody;
			((Joint)serverClientJoint).autoConfigureConnectedAnchor = false;
			((Joint)serverClientJoint).anchor = Vector3.zero;
			((Joint)serverClientJoint).connectedAnchor = Vector3.zero;
			serverClientJoint.minDistance = 0f;
			serverClientJoint.maxDistance = 1f;
			serverClientJoint.damper = 1000f;
			serverClientJoint.spring = 5000f;
			((Joint)serverClientJoint).enableCollision = false;
			((Joint)serverClientJoint).enablePreprocessing = false;
		}
	}
}


public class ArcadeClientAuthTest : ArcadeEntityController
{
	public float speed = 0.2f;

	public float maxSpeed = 1f;

	public BaseArcadeGame myGame;

	public ArcadeEntity myEntity;
}


using System;
using UnityEngine;

public class ArcadeEntity : BaseMonoBehaviour
{
	public uint id;

	public uint spriteID;

	public uint soundID;

	public bool visible;

	public Vector3 heading = new Vector3(0f, 1f, 0f);

	public bool isEnabled;

	public bool dirty;

	public float alpha = 1f;

	public BoxCollider boxCollider;

	public bool host;

	public bool localAuthorativeOverride;

	public ArcadeEntity arcadeEntityParent;

	public uint prefabID;

	[Header("Health")]
	public bool takesDamage;

	public float health = 1f;

	public float maxHealth = 1f;

	[NonSerialized]
	public bool mapLoadedEntiy;
}


using UnityEngine;

public class ArcadeEntityController : BaseMonoBehaviour
{
	public BaseArcadeGame parentGame;

	public ArcadeEntity arcadeEntity;

	public ArcadeEntity sourceEntity;

	public Vector3 heading
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return arcadeEntity.heading;
		}
		set
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			arcadeEntity.heading = value;
		}
	}

	public Vector3 positionLocal
	{
		get
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return ((Component)arcadeEntity).transform.localPosition;
		}
		set
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			((Component)arcadeEntity).transform.localPosition = value;
		}
	}

	public Vector3 positionWorld
	{
		get
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return ((Component)arcadeEntity).transform.position;
		}
		set
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			((Component)arcadeEntity).transform.position = value;
		}
	}
}


using UnityEngine;

public class ArcadeNetworkTrigger : TriggerBase
{
	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class BaseArcadeGame : BaseMonoBehaviour
{
	public static List<BaseArcadeGame> globalActiveGames = new List<BaseArcadeGame>();

	public Camera cameraToRender;

	public RenderTexture renderTexture;

	public Texture2D distantTexture;

	public Transform center;

	public int frameRate = 30;

	public Dictionary<uint, ArcadeEntity> activeArcadeEntities = new Dictionary<uint, ArcadeEntity>();

	public Sprite[] spriteManifest;

	public ArcadeEntity[] entityManifest;

	public bool clientside;

	public bool clientsideInput = true;

	public const int spriteIndexInvisible = 1555;

	public GameObject arcadeEntityPrefab;

	public BaseArcadeMachine ownerMachine;

	public static int gameOffsetIndex = 0;

	private bool isAuthorative;

	public Canvas canvas;

	public BasePlayer GetHostPlayer()
	{
		if (Object.op_Implicit((Object)(object)ownerMachine))
		{
			return ownerMachine.GetDriver();
		}
		return null;
	}
}


using System;
using UnityEngine;

public class BossFormController : ArcadeEntityController
{
	[Serializable]
	public class BossDamagePoint
	{
		public BoxCollider hitBox;

		public float health;

		public ArcadeEntityController damagePrefab;

		public ArcadeEntityController damageInstance;

		public bool destroyed;
	}

	public float animationSpeed = 0.5f;

	public Sprite[] animationFrames;

	public Vector2 roamDistance;

	public Transform colliderParent;

	public BossDamagePoint[] damagePoints;

	public ArcadeEntityController flashController;

	public float health = 50f;
}


using System;
using UnityEngine;

[Serializable]
public class BossDamagePoint
{
	public BoxCollider hitBox;

	public float health;

	public ArcadeEntityController damagePrefab;

	public ArcadeEntityController damageInstance;

	public bool destroyed;
}


using UnityEngine;

public class ChippyArcadeGame : BaseArcadeGame
{
	public ChippyMainCharacter mainChar;

	public SpriteArcadeEntity mainCharAim;

	public ChippyBoss currentBoss;

	public ChippyBoss[] bossPrefabs;

	public SpriteArcadeEntity mainMenuLogo;

	public Transform respawnPoint;

	public Vector2 mouseAim = new Vector2(0f, 1f);

	public TextArcadeEntity levelIndicator;

	public TextArcadeEntity gameOverIndicator;

	public TextArcadeEntity playGameButton;

	public TextArcadeEntity highScoresButton;

	public bool OnMainMenu;

	public bool GameActive;

	public int level;

	public TextArcadeEntity[] scoreDisplays;

	public MenuButtonArcadeEntity[] mainMenuButtons;

	public int selectedButtonIndex;

	public bool OnHighScores;
}


using System;
using UnityEngine;

public class ChippyBoss : SpriteArcadeEntity
{
	[Serializable]
	public class BossDamagePoint
	{
		public BoxCollider hitBox;

		public float health;

		public ArcadeEntityController damagePrefab;

		public ArcadeEntityController damageInstance;

		public bool destroyed;
	}

	public Vector2 roamDistance;

	public float animationSpeed = 0.5f;

	public Sprite[] animationFrames;

	public ArcadeEntity bulletTest;

	public SpriteRenderer flashRenderer;

	public BossDamagePoint[] damagePoints;
}


using System;
using UnityEngine;

[Serializable]
public class BossDamagePoint
{
	public BoxCollider hitBox;

	public float health;

	public ArcadeEntityController damagePrefab;

	public ArcadeEntityController damageInstance;

	public bool destroyed;
}


public class ChippyBulletEntity : SpriteArcadeEntity
{
	public float speed = 4f;

	public float maxSpeed = 4f;

	public float radius;

	public float damage = 1f;

	public ArcadeEntity bulletImpact;
}


using UnityEngine;

public class ChippyMainCharacter : SpriteArcadeEntity
{
	public float speed;

	public float maxSpeed = 0.25f;

	public ChippyBulletEntity bulletPrefab;

	public float fireRate = 0.1f;

	public Vector3 aimDir = Vector3.up;
}


using UnityEngine;

public class ChippyMoveTest : MonoBehaviour
{
	public Vector3 heading = new Vector3(0f, 1f, 0f);

	public float speed = 0.2f;

	public float maxSpeed = 1f;

	private void FixedUpdate()
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Mathf.Abs(((Vector3)(ref heading)).magnitude) > 0f) ? 1f : 0f);
		speed = Mathf.MoveTowards(speed, maxSpeed * num, Time.fixedDeltaTime * ((num == 0f) ? 2f : 2f));
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = new Vector3(heading.x, heading.y, 0f);
		Ray val2 = default(Ray);
		((Ray)(ref val2))..ctor(position, ((Vector3)(ref val)).normalized);
		if (!Physics.Raycast(val2, speed * Time.fixedDeltaTime, 16777216))
		{
			Transform transform = ((Component)this).transform;
			transform.position += ((Ray)(ref val2)).direction * Time.fixedDeltaTime * speed;
			if (Mathf.Abs(((Vector3)(ref heading)).magnitude) > 0f)
			{
				Transform transform2 = ((Component)this).transform;
				Vector3 forward = ((Component)this).transform.forward;
				val = new Vector3(heading.x, heading.y, 0f);
				transform2.rotation = QuaternionEx.LookRotationForcedUp(forward, ((Vector3)(ref val)).normalized);
			}
		}
	}
}


using System;
using UnityEngine;

public class DestroyArcadeEntity : BaseMonoBehaviour
{
	public ArcadeEntity ent;

	public float TimeToDie = 1f;

	public float TimeToDieVariance;

	private void Start()
	{
		((FacepunchBehaviour)this).Invoke((Action)DestroyAction, TimeToDie, TimeToDieVariance * 0.5f);
	}

	private void DestroyAction()
	{
		if (((Object)(object)ent != (Object)null) & ent.host)
		{
			Object.Destroy((Object)(object)((Component)ent).gameObject);
		}
	}
}


public class MenuButtonArcadeEntity : TextArcadeEntity
{
	public string titleText = "";

	public string selectionSuffix = " - ";

	public string clickMessage = "";

	public bool IsHighlighted()
	{
		return alpha == 1f;
	}
}


using UnityEngine;

public class SpriteArcadeEntity : ArcadeEntity
{
	public SpriteRenderer spriteRenderer;
}


public class ArcadeTennisPaddle : ArcadeEntity
{
}


using UnityEngine;

public class TennisArcadeGame : BaseArcadeGame
{
	public ArcadeEntity paddle1;

	public ArcadeEntity paddle2;

	public ArcadeEntity ball;

	public Transform paddle1Origin;

	public Transform paddle2Origin;

	public Transform paddle1Goal;

	public Transform paddle2Goal;

	public Transform ballSpawn;

	public float maxScore = 5f;

	public ArcadeEntity[] paddle1ScoreNodes;

	public ArcadeEntity[] paddle2ScoreNodes;

	public int paddle1Score;

	public int paddle2Score;

	public float sensitivity = 1f;

	public ArcadeEntity logo;

	public bool OnMainMenu;

	public bool GameActive;
}


public class TennisBall : SpriteArcadeEntity
{
	public float speed = 2f;

	public float maxSpeed = 2f;
}


using TMPro;

public class TextArcadeEntity : ArcadeEntity
{
	public TextMeshProUGUI text;
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HeadEntity : BaseEntity
{
	public HeadData CurrentTrophyData;

	private const Wearable.OccupationSlots HeadMask = Wearable.OccupationSlots.HeadTop | Wearable.OccupationSlots.Face | Wearable.OccupationSlots.HeadBack | Wearable.OccupationSlots.Mouth | Wearable.OccupationSlots.Eyes;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.headData == null && CurrentTrophyData != null)
		{
			info.msg.headData = Pool.Get<HeadData>();
			CurrentTrophyData.CopyTo(info.msg.headData);
		}
	}

	public void SetupSourceId(uint sourceID)
	{
		InitTrophyData();
		CurrentTrophyData.entitySource = sourceID;
		CurrentTrophyData.horseBreed = 0;
		CurrentTrophyData.playerId = 0uL;
		CurrentTrophyData.playerName = string.Empty;
		CurrentTrophyData.clothing?.Clear();
	}

	public void SetupPlayerId(string playerName, ulong playerId)
	{
		InitTrophyData();
		CurrentTrophyData.playerName = playerName;
		CurrentTrophyData.playerId = playerId;
	}

	public void AssignClothing(ItemContainer container)
	{
		InitTrophyData();
		if (CurrentTrophyData.clothing == null)
		{
			CurrentTrophyData.clothing = Pool.Get<List<int>>();
		}
		ItemModWearable itemModWearable = default(ItemModWearable);
		foreach (Item item in container.itemList)
		{
			if (((Component)item.info).TryGetComponent<ItemModWearable>(ref itemModWearable) && itemModWearable.entityPrefab.isValid)
			{
				Wearable component = itemModWearable.entityPrefab.Get().GetComponent<Wearable>();
				if ((component.occupationOver & (Wearable.OccupationSlots.HeadTop | Wearable.OccupationSlots.Face | Wearable.OccupationSlots.HeadBack | Wearable.OccupationSlots.Mouth | Wearable.OccupationSlots.Eyes)) != 0 || component.occupationOver == (Wearable.OccupationSlots)0)
				{
					CurrentTrophyData.clothing.Add(item.info.itemid);
				}
			}
		}
	}

	public void AssignHorseBreed(int breed)
	{
		InitTrophyData();
		CurrentTrophyData.horseBreed = breed;
	}

	private void InitTrophyData()
	{
		if (CurrentTrophyData == null)
		{
			CurrentTrophyData = Pool.Get<HeadData>();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.headData != null)
		{
			InitTrophyData();
			info.msg.headData.CopyTo(CurrentTrophyData);
		}
		else if (CurrentTrophyData != null)
		{
			Pool.Free<HeadData>(ref CurrentTrophyData);
		}
	}

	public GameObject GetHeadSource()
	{
		if (CurrentTrophyData == null)
		{
			return null;
		}
		return GameManager.server.FindPrefab(CurrentTrophyData.entitySource);
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class RockingChair : BaseChair
{
	[Header("Rocking Settings")]
	public float Acceleration = 0.8f;

	public float MaxRockingAngle = 9f;

	public float MaxRockVelocity = 4f;

	[Tooltip("Preserve and apply some existing velocity when swinging back and forth.")]
	public bool ApplyVelocityBetweenSwings = true;

	[Range(0f, 2f)]
	public float AppliedVelocity = 1f;

	[Range(0f, 2f)]
	public float WeaponFireImpact = 3f;

	[Header("Audio")]
	public SoundDefinition creakForwardSoundDef;

	public SoundDefinition creakBackwardSoundDef;

	public float creakForwardAngle = 0.1f;

	public float creakBackwardAngle = -0.1f;

	public float creakVelocityThreshold = 0.02f;

	public AnimationCurve creakGainCurve;

	private float initLocalY;

	private Vector3 initLocalRot;

	private float velocity;

	private float oppositePotentialVelocity;

	private TimeSince timeSinceInput;

	private float sineTime;

	private float timeUntilStartSine = 0.4f;

	private float t;

	private float angle;

	private Quaternion max;

	private Quaternion min;

	public override void ServerInit()
	{
		base.ServerInit();
		SaveBaseLocalPos();
		ResetChair();
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		((FacepunchBehaviour)this).Invoke((Action)SaveBaseLocalPos, 0f);
	}

	private void SaveBaseLocalPos()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		Quaternion localRotation = ((Component)this).transform.localRotation;
		initLocalRot = ((Quaternion)(ref localRotation)).eulerAngles;
		initLocalY = ((Component)this).transform.localPosition.y;
		max = Quaternion.Euler(initLocalRot) * Quaternion.AngleAxis(MaxRockingAngle, Vector3.right);
		min = Quaternion.Euler(initLocalRot) * Quaternion.AngleAxis(0f - MaxRockingAngle, Vector3.right);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.rockingChair = Pool.Get<RockingChair>();
		info.msg.rockingChair.initEuler = initLocalRot;
		info.msg.rockingChair.initY = initLocalY;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.rockingChair != null && base.isServer)
		{
			initLocalRot = info.msg.rockingChair.initEuler;
			((Component)this).transform.localRotation = Quaternion.Euler(initLocalRot);
			initLocalY = info.msg.rockingChair.initY;
			if (initLocalY == 0f)
			{
				initLocalY = ((Component)this).transform.localPosition.y;
			}
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		float timeSinceLastTick = player.timeSinceLastTick;
		Vector2 inputVector = GetInputVector(inputState);
		CalculateVelocity(inputVector);
		bool flag = !Mathf.Approximately(inputVector.y, 0f);
		if (flag)
		{
			timeSinceInput = TimeSince.op_Implicit(0f);
			sineTime = 0f;
		}
		else if (TimeSince.op_Implicit(timeSinceInput) > timeUntilStartSine)
		{
			angle = Mathf.Lerp(0f - MaxRockingAngle, MaxRockingAngle, t);
		}
		sineTime += player.timeSinceLastTick * 180f;
		PreventClipping(flag);
		ApplyVelocity(timeSinceLastTick, flag);
	}

	public override void OnWeaponFired(BaseProjectile weapon)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)weapon == (Object)null))
		{
			if ((Object)(object)weapon.recoil != (Object)null)
			{
				velocity += weapon.recoil.recoilPitchMax * WeaponFireImpact;
			}
			timeSinceInput = TimeSince.op_Implicit(0f);
			sineTime = 0f;
		}
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		ResetChair();
	}

	private void PreventClipping(bool hasInput)
	{
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		float num = initLocalY + 0.06f;
		float num2 = Mathx.RemapValClamped(Mathf.Abs(angle), 0f, MaxRockingAngle, 0f, 1f);
		if (num2 > 0.7f)
		{
			((Component)this).transform.localPosition = Mathx.Lerp(new Vector3(((Component)this).transform.localPosition.x, initLocalY, ((Component)this).transform.localPosition.z), new Vector3(((Component)this).transform.localPosition.x, num, ((Component)this).transform.localPosition.z), 1.5f, num2);
		}
		else
		{
			((Component)this).transform.localPosition = Mathx.Lerp(((Component)this).transform.localPosition, new Vector3(((Component)this).transform.localPosition.x, initLocalY, ((Component)this).transform.localPosition.z), 1.5f, Time.deltaTime);
		}
	}

	private void CalculateVelocity(Vector2 currentInput)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		velocity += currentInput.y * Acceleration;
		velocity = Mathf.Clamp(velocity, 0f - MaxRockVelocity, MaxRockVelocity);
		oppositePotentialVelocity = (0f - velocity) * AppliedVelocity;
		int signZero = Mathx.GetSignZero(currentInput.y, true);
		int signZero2 = Mathx.GetSignZero(velocity, true);
		if (ApplyVelocityBetweenSwings && Mathf.Abs(velocity) > 0.3f && Mathx.HasSignFlipped(signZero, signZero2))
		{
			velocity += oppositePotentialVelocity;
		}
	}

	private void ApplyVelocity(float delta, bool hasInput)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		t = Mathf.Sin(sineTime * (MathF.PI / 180f));
		t = Mathx.RemapValClamped(t, -1f, 1f, 0f, 1f);
		t = EaseOutCubicOvershoot(t, 0.2f);
		t = Mathf.Lerp(t, 0.5f, Mathf.Clamp01(TimeSince.op_Implicit(timeSinceInput) / 10f));
		angle += velocity;
		angle = Mathf.Clamp(angle, 0f - MaxRockingAngle, MaxRockingAngle);
		Quaternion val = Quaternion.Euler(initLocalRot) * Quaternion.AngleAxis(angle, Vector3.right);
		Quaternion val2 = Quaternion.Slerp(min, max, t);
		float num = ((!hasInput && TimeSince.op_Implicit(timeSinceInput) > timeUntilStartSine) ? 1 : 0);
		Quaternion val3 = Quaternion.Slerp(val, val2, num);
		((Component)this).transform.localRotation = Quaternion.Slerp(((Component)this).transform.localRotation, val3, delta * 3f);
	}

	private void ResetChair()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localRotation = Quaternion.Euler(initLocalRot);
		((Component)this).transform.localPosition = new Vector3(((Component)this).transform.localPosition.x, initLocalY, ((Component)this).transform.localPosition.z);
	}

	private Vector2 GetInputVector(InputState inputState)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		bool rightDown = false;
		bool forwardDown = inputState.IsDown(BUTTON.FORWARD);
		bool backDown = inputState.IsDown(BUTTON.BACKWARD);
		return ProcessInputVector(leftDown: false, rightDown, forwardDown, backDown);
	}

	private static Vector2 ProcessInputVector(bool leftDown, bool rightDown, bool forwardDown, bool backDown)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Vector2 zero = Vector2.zero;
		if (leftDown && rightDown)
		{
			leftDown = (rightDown = false);
		}
		if (forwardDown && backDown)
		{
			forwardDown = (backDown = false);
		}
		if (forwardDown)
		{
			zero.y = 1f;
		}
		else if (backDown)
		{
			zero.y = -1f;
		}
		if (rightDown)
		{
			zero.x = 1f;
		}
		else if (leftDown)
		{
			zero.x = -1f;
		}
		return zero;
	}

	private float EaseOutCubic(float value)
	{
		return 1f - Mathf.Pow(1f - Mathf.Clamp01(value), 3f);
	}

	private float EaseOutCubicOvershoot(float value, float overshoot)
	{
		return 1f - Mathf.Pow(1f - Mathf.Clamp01(value), 3f) * (1f + overshoot * (Mathf.Clamp01(value) - 1f));
	}
}


using UnityEngine;

public class DiveSite : JunkPile
{
	public Transform bobber;

	public override bool DespawnIfAnyLootTaken => false;

	public override float TimeoutPlayerCheckRadius()
	{
		return 80f;
	}

	public override void Spawn()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if ((Object)(object)BoatBuildingStation.GetStationIntersectingOBB(new OBB(Vector3Ex.WithY(((Component)this).transform.position, 0f), ((Component)this).transform.lossyScale, ((Component)this).transform.rotation, bounds), isServer: true) != (Object)null)
		{
			Kill();
		}
	}
}


using System;
using UnityEngine;

public class DiveSiteBuoy : BaseEntity
{
	public float UpdateCullRange = 128f;

	public Vector3 RotationRate;

	public float InitialSpawnRange = 32f;

	private Action _updateAction;

	private Action updateAction => _updateAction ?? new Action(UpdateMovement);

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (!BaseNetworkable.HasCloseConnections(((Component)this).transform.position, InitialSpawnRange))
		{
			UpdateMovement();
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckForNearbyPlayers, 0f, 10f, 5f);
	}

	private void CheckForNearbyPlayers()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		bool flag = BaseNetworkable.HasCloseConnections(((Component)this).transform.position, UpdateCullRange);
		if (flag && !((FacepunchBehaviour)this).IsInvoking(updateAction))
		{
			((FacepunchBehaviour)this).InvokeRepeating(updateAction, 0f, 0f);
		}
		else if (!flag && ((FacepunchBehaviour)this).IsInvoking(updateAction))
		{
			((FacepunchBehaviour)this).CancelInvoke(updateAction);
		}
		ToggleNetworkPositionTick(flag);
	}

	private void UpdateMovement()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Quaternion rotation = ((Component)this).transform.rotation;
		position.y = WaterLevel.GetWaterSurface(position, waves: true, volumes: false) + Mathf.Sin(Time.time * 3f) * 0.075f;
		rotation *= Quaternion.Euler(RotationRate * Time.deltaTime);
		((Component)this).transform.SetPositionAndRotation(position, rotation);
	}
}


using UnityEngine;

public class EggAmmoRepresentation : MonoBehaviour, IInventoryChanged, IClientComponent
{
	public GameObject[] eggAmmo;
}


using UnityEngine;

public class EggSwap : MonoBehaviour
{
	public Renderer[] eggRenderers;

	public void Show(int index)
	{
		HideAll();
		eggRenderers[index].enabled = true;
	}

	public void HideAll()
	{
		Renderer[] array = eggRenderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = false;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class EggHuntEvent : BaseHuntEvent
{
	public class EggHunter
	{
		public ulong userid;

		public string displayName;

		public int numEggs;
	}

	public float warmupTime = 10f;

	public float warnTime = 20f;

	public float timeAlive;

	public static EggHuntEvent serverEvent = null;

	public static EggHuntEvent clientEvent = null;

	public const int CAST_LAYERS = 10551297;

	[NonSerialized]
	public static float durationSeconds = 180f;

	public Dictionary<ulong, EggHunter> _eggHunters = new Dictionary<ulong, EggHunter>();

	public ItemAmount[] placementAwards;

	private Dictionary<ulong, List<CollectableEasterEgg>> _spawnedEggs = new Dictionary<ulong, List<CollectableEasterEgg>>();

	private readonly int maxEggPerPlayer = 25;

	private int initialSpawnIndex;

	private readonly Stopwatch stopwatch = new Stopwatch();

	private const int maxBatchSize = 1024;

	private const int initialMinEggPerPlayer = 4;

	private const int initialMaxEggPerPlayer = 6;

	private float eggSpawningFrameBudget = 1.5f;

	[ServerVar(Help = "Will spawn eggs for bots, only for debug purposes - don't enable it!")]
	public static bool includeBots = false;

	public static Phrase topBunnyPhrase = new Phrase("egghunt.result.topbunny", "{0} is the top bunny with {1} eggs collected.");

	public static Phrase noPlayersPhrase = new Phrase("egghunt.result.noplayers", "Wow, no one played so no one won.");

	public static Phrase placePhrase = new Phrase("egghunt.result.place", "You placed {0} of {1} with {2} eggs collected.");

	public static Phrase rewardPhrase = new Phrase("egghunt.result.reward", "You received {0}x {1} as an award!.");

	public bool IsEventActive()
	{
		if (timeAlive > warmupTime)
		{
			return timeAlive - warmupTime < durationSeconds;
		}
		return false;
	}

	public void Update()
	{
		timeAlive += Time.deltaTime;
		if (base.isServer && !base.IsDestroyed)
		{
			if (timeAlive - warmupTime > durationSeconds - warnTime)
			{
				SetFlag(Flags.Reserved1, b: true);
			}
			if (timeAlive - warmupTime > durationSeconds && !((FacepunchBehaviour)this).IsInvoking((Action)Cooldown) && Interface.CallHook("OnHuntEventEnd", (object)this) == null)
			{
				SetFlag(Flags.Reserved2, b: true);
				CleanupEggs();
				PrintWinnersAndAward();
				((FacepunchBehaviour)this).Invoke((Action)Cooldown, 10f);
			}
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer)
		{
			serverEvent = null;
		}
		else
		{
			clientEvent = null;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (Object.op_Implicit((Object)(object)serverEvent) && base.isServer)
		{
			serverEvent.Kill();
			serverEvent = null;
		}
		serverEvent = this;
		SpawnEggs();
		((FacepunchBehaviour)this).Invoke((Action)StartEvent, warmupTime);
	}

	private void StartEvent()
	{
		if (Interface.CallHook("OnHuntEventStart", (object)this) == null)
		{
			int count = BasePlayer.activePlayerList.Count;
			if (includeBots)
			{
				count = GetCombinedPlayerList(wantBots: true).Count;
			}
			if (initialSpawnIndex <= count)
			{
				eggSpawningFrameBudget = float.PositiveInfinity;
			}
			EnableEggs();
		}
	}

	private void EnableEggs()
	{
		foreach (KeyValuePair<ulong, List<CollectableEasterEgg>> spawnedEgg in _spawnedEggs)
		{
			foreach (CollectableEasterEgg item in spawnedEgg.Value)
			{
				((Component)item).gameObject.SetActive(true);
				item.SetFlag(Flags.Disabled, b: false);
			}
		}
	}

	[ContextMenu("SpawnDebug")]
	public void SpawnEggs()
	{
		initialSpawnIndex = 0;
		((MonoBehaviour)this).StartCoroutine(SpawnInitialEggs());
	}

	private IEnumerator SpawnInitialEggs()
	{
		NativeArray<RaycastCommand> raycastCommands = new NativeArray<RaycastCommand>(1024, (Allocator)4, (NativeArrayOptions)1);
		NativeArray<RaycastHit> hits = new NativeArray<RaycastHit>(1024, (Allocator)4, (NativeArrayOptions)1);
		NativeArray<ulong> ownerIDs = new NativeArray<ulong>(1024, (Allocator)4, (NativeArrayOptions)1);
		Queue<(Vector3 position, ulong ownerID)> pendingSpawns = new Queue<(Vector3, ulong)>();
		ListHashSet<BasePlayer> playerList = BasePlayer.activePlayerList;
		if (includeBots)
		{
			playerList = GetCombinedPlayerList(wantBots: true);
		}
		while (initialSpawnIndex != playerList.Count)
		{
			stopwatch.Reset();
			stopwatch.Start();
			int commandIndex = 0;
			for (int i = initialSpawnIndex; i < playerList.Count; i++)
			{
				BasePlayer basePlayer = playerList[i];
				if (basePlayer.isInvisible)
				{
					continue;
				}
				int num = Random.Range(4, 6) + Mathf.RoundToInt(basePlayer.eggVision);
				Vector3 position = ((Component)basePlayer).transform.position;
				for (int j = 0; j < num; j++)
				{
					Vector3 randomSpawnPoint = GetRandomSpawnPoint(position, Vector3.zero, 15f, 25f);
					randomSpawnPoint += Vector3.up * 100f;
					raycastCommands[commandIndex] = new RaycastCommand(randomSpawnPoint, Vector3.down, 105f, 10551297, 1);
					ownerIDs[commandIndex] = basePlayer.userID;
					commandIndex++;
					if (commandIndex >= 1024)
					{
						break;
					}
				}
				initialSpawnIndex++;
				if (commandIndex >= 1024 || stopwatch.Elapsed.TotalMilliseconds >= (double)eggSpawningFrameBudget)
				{
					break;
				}
			}
			if (commandIndex > 0)
			{
				JobHandle handle = RaycastCommand.ScheduleBatch(raycastCommands, hits, 1, default(JobHandle));
				yield return (object)new WaitUntil((Func<bool>)(() => ((JobHandle)(ref handle)).IsCompleted));
				((JobHandle)(ref handle)).Complete();
				for (int k = 0; k < commandIndex; k++)
				{
					RaycastCommand val = raycastCommands[k];
					Vector3 val2 = ((RaycastCommand)(ref val)).from;
					RaycastHit val3 = hits[k];
					if ((Object)(object)((RaycastHit)(ref val3)).collider == (Object)null)
					{
						val2.y = TerrainMeta.HeightMap.GetHeight(val2);
					}
					else
					{
						val3 = hits[k];
						val2 = ((RaycastHit)(ref val3)).point;
					}
					pendingSpawns.Enqueue((val2, ownerIDs[k]));
				}
			}
			yield return CoroutineEx.waitForEndOfFrame;
		}
		while (pendingSpawns.Count > 0)
		{
			stopwatch.Reset();
			stopwatch.Start();
			while (pendingSpawns.Count > 0 && stopwatch.Elapsed.TotalMilliseconds < (double)eggSpawningFrameBudget)
			{
				(Vector3 position, ulong ownerID) tuple = pendingSpawns.Dequeue();
				Vector3 item = tuple.position;
				ulong item2 = tuple.ownerID;
				CollectableEasterEgg collectableEasterEgg = SpawnEggAtPoint(item, active: false);
				collectableEasterEgg.ownerUserID = item2;
				collectableEasterEgg.SetFlag(Flags.Disabled, b: true, recursive: false, networkupdate: false);
				collectableEasterEgg.Spawn();
				TryGetPlayerEggs(item2).Add(collectableEasterEgg);
			}
			yield return CoroutineEx.waitForEndOfFrame;
		}
		raycastCommands.Dispose();
		hits.Dispose();
		ownerIDs.Dispose();
	}

	private CollectableEasterEgg SpawnEggAtPoint(Vector3 pos, bool active)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if ((TerrainMeta.TopologyMap.GetTopology(pos) & 0x14080) != 0)
		{
			float waterLevel = WaterLevel.GetWaterLevel(pos, waves: false);
			if (waterLevel > TerrainMeta.HeightMap.GetHeight(pos) && pos.y < waterLevel)
			{
				pos.y = waterLevel;
			}
		}
		GameManager server = GameManager.server;
		string strPrefab = HuntableResourcePathCached[Random.Range(0, HuntableResourcePathCached.Count)];
		Vector3 pos2 = pos;
		bool startActive = active;
		return server.CreateEntity(strPrefab, pos2, default(Quaternion), startActive) as CollectableEasterEgg;
	}

	private Vector3 GetRandomSpawnPoint(Vector3 pos, Vector3 aimDir, float minDist = 1f, float maxDist = 2f, bool raycast = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		aimDir = ((aimDir == Vector3.zero) ? Random.onUnitSphere : AimConeUtil.GetModifiedAimConeDirection(90f, aimDir));
		Vector3 val = pos + Vector3Ex.Direction2D(pos + aimDir * 10f, pos) * Random.Range(minDist, maxDist);
		RaycastHit val2 = default(RaycastHit);
		if (raycast && Physics.Raycast(val + Vector3.up * 100f, Vector3.down, ref val2, 105f, 10551297))
		{
			val.y = ((RaycastHit)(ref val2)).point.y;
		}
		else
		{
			val.y = TerrainMeta.HeightMap.GetHeight(val);
		}
		return val;
	}

	public void OnEggCollected(BasePlayer player, CollectableEasterEgg collectedEgg)
	{
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		IncrementScore(player);
		if (_spawnedEggs.TryGetValue(collectedEgg.ownerUserID, out var value))
		{
			value.Remove(collectedEgg);
		}
		int num = ((!((float)Mathf.RoundToInt(player.eggVision) * 0.5f < 1f)) ? 1 : Random.Range(0, 2));
		int num2 = Random.Range(1 + num, 2 + num);
		List<CollectableEasterEgg> list = TryGetPlayerEggs(player.userID);
		for (int i = 0; i < num2; i++)
		{
			if (list.Count + 1 > maxEggPerPlayer)
			{
				list[0].Kill();
				list.Remove(list[0]);
			}
			Vector3 randomSpawnPoint = GetRandomSpawnPoint(((Component)player).transform.position, player.eyes.BodyForward(), 15f, 25f, raycast: true);
			CollectableEasterEgg collectableEasterEgg = SpawnEggAtPoint(randomSpawnPoint, active: true);
			collectableEasterEgg.ownerUserID = player.userID;
			collectableEasterEgg.Spawn();
			list.Add(collectableEasterEgg);
		}
	}

	private void IncrementScore(BasePlayer player)
	{
		if (!_eggHunters.TryGetValue(player.userID, out var value))
		{
			value = new EggHunter();
			value.displayName = player.displayName;
			value.userid = player.userID;
			_eggHunters.Add(player.userID, value);
		}
		value.numEggs++;
		QueueUpdate();
	}

	private void QueueUpdate()
	{
		if (!((FacepunchBehaviour)this).IsInvoking((Action)DoNetworkUpdate))
		{
			((FacepunchBehaviour)this).Invoke((Action)DoNetworkUpdate, 2f);
		}
	}

	private void DoNetworkUpdate()
	{
		SendNetworkUpdate();
	}

	private List<CollectableEasterEgg> TryGetPlayerEggs(ulong userID)
	{
		if (!_spawnedEggs.TryGetValue(userID, out var value))
		{
			value = new List<CollectableEasterEgg>();
			_spawnedEggs[userID] = value;
		}
		return value;
	}

	protected List<EggHunter> GetTopHunters()
	{
		List<EggHunter> list = Pool.Get<List<EggHunter>>();
		foreach (KeyValuePair<ulong, EggHunter> eggHunter in _eggHunters)
		{
			list.Add(eggHunter.Value);
		}
		list.Sort((EggHunter a, EggHunter b) => b.numEggs.CompareTo(a.numEggs));
		return list;
	}

	protected virtual Phrase GetTopBunnyPhrase()
	{
		return topBunnyPhrase;
	}

	protected virtual Phrase GetNoPlayersPhrase()
	{
		return noPlayersPhrase;
	}

	protected virtual Phrase GetPlacePhrase()
	{
		return placePhrase;
	}

	protected virtual Phrase GetRewardPhrase()
	{
		return rewardPhrase;
	}

	protected void PrintWinnersAndAward()
	{
		List<EggHunter> topHunters = GetTopHunters();
		if (topHunters.Count > 0)
		{
			EggHunter eggHunter = topHunters[0];
			Chat.Broadcast(string.Format(GetTopBunnyPhrase().translated, eggHunter.displayName, eggHunter.numEggs), "", "#eee", 0uL);
			for (int i = 0; i < topHunters.Count; i++)
			{
				EggHunter eggHunter2 = topHunters[i];
				BasePlayer basePlayer = BasePlayer.FindByID(eggHunter2.userid);
				if (Object.op_Implicit((Object)(object)basePlayer))
				{
					string translated = GetPlacePhrase().translated;
					translated = string.Format(translated, i + 1, topHunters.Count, topHunters[i].numEggs);
					basePlayer.ChatMessage(translated);
					ReportEggsCollected(topHunters[i].numEggs);
				}
				else
				{
					Debug.LogWarning((object)("EggHuntEvent PrintWinnersAndAward could not find player with id :" + eggHunter2.userid));
				}
			}
			ReportPlayerParticipated(topHunters.Count);
			for (int j = 0; j < placementAwards.Length && j < topHunters.Count; j++)
			{
				BasePlayer basePlayer2 = BasePlayer.FindByID(topHunters[j].userid);
				if (Object.op_Implicit((Object)(object)basePlayer2))
				{
					basePlayer2.inventory.GiveItem(ItemManager.Create(placementAwards[j].itemDef, (int)placementAwards[j].amount, 0uL), basePlayer2.inventory.containerMain);
					string translated2 = GetRewardPhrase().translated;
					translated2 = string.Format(translated2, (int)placementAwards[j].amount, placementAwards[j].itemDef.displayName.english);
					basePlayer2.ChatMessage(translated2);
				}
			}
		}
		else
		{
			Chat.Broadcast(GetNoPlayersPhrase().translated, "", "#eee", 0uL);
		}
	}

	protected virtual void ReportEggsCollected(int numEggs)
	{
	}

	protected virtual void ReportPlayerParticipated(int topCount)
	{
	}

	private void CleanupEggs()
	{
		foreach (KeyValuePair<ulong, List<CollectableEasterEgg>> spawnedEgg in _spawnedEggs)
		{
			if (spawnedEgg.Value == null)
			{
				continue;
			}
			foreach (CollectableEasterEgg item in spawnedEgg.Value)
			{
				if ((Object)(object)item != (Object)null)
				{
					item.Kill();
				}
			}
		}
	}

	private void Cooldown()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Cooldown);
		Kill();
	}

	public static ListHashSet<BasePlayer> GetCombinedPlayerList(bool wantBots)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		ListHashSet<BasePlayer> val = new ListHashSet<BasePlayer>(BasePlayer.activePlayerList.Count + (wantBots ? BasePlayer.bots.Count : 0));
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				val.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		if (wantBots)
		{
			enumerator = BasePlayer.bots.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current2 = enumerator.Current;
					val.Add(current2);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		return val;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.eggHunt = Pool.Get<EggHunt>();
		List<EggHunter> topHunters = GetTopHunters();
		info.msg.eggHunt.hunters = Pool.Get<List<EggHunter>>();
		for (int i = 0; i < Mathf.Min(10, topHunters.Count); i++)
		{
			EggHunter val = Pool.Get<EggHunter>();
			val.displayName = topHunters[i].displayName;
			val.numEggs = topHunters[i].numEggs;
			val.playerID = topHunters[i].userid;
			info.msg.eggHunt.hunters.Add(val);
		}
	}
}


public class EggHunter
{
	public ulong userid;

	public string displayName;

	public int numEggs;
}


using System;
using UnityEngine;

public class AnimationFlagHandler : MonoBehaviour
{
	public Animator animator;

	public bool forceUpdateIfDisabled;

	public void SetBoolTrue(string name)
	{
		animator.SetBool(name, true);
		TryForceAnimation();
	}

	public void SetBoolFalse(string name)
	{
		animator.SetBool(name, false);
		TryForceAnimation();
	}

	private void TryForceAnimation()
	{
		if (forceUpdateIfDisabled && !((Behaviour)animator).isActiveAndEnabled)
		{
			((Behaviour)animator).enabled = true;
			animator.Update(10f);
			((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)DisableAnimator, 2f);
		}
	}

	private void DisableAnimator()
	{
		if (!((Object)(object)animator == (Object)null))
		{
			((Behaviour)animator).enabled = false;
		}
	}
}


using UnityEngine;

public class JiggleBone : BaseMonoBehaviour
{
	public bool debugMode = true;

	private Vector3 targetPos;

	private Vector3 dynamicPos;

	public Vector3 boneAxis = new Vector3(0f, 0f, 1f);

	public float targetDistance = 2f;

	public float bStiffness = 0.1f;

	public float bMass = 0.9f;

	public float bDamping = 0.75f;

	public float bGravity = 0.75f;

	private Vector3 force;

	private Vector3 acc;

	private Vector3 vel;

	public bool SquashAndStretch = true;

	public float sideStretch = 0.15f;

	public float frontStretch = 0.2f;

	public float disableDistance = 20f;

	private void Awake()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + ((Component)this).transform.TransformDirection(new Vector3(boneAxis.x * targetDistance, boneAxis.y * targetDistance, boneAxis.z * targetDistance));
		dynamicPos = val;
	}

	private void LateUpdate()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_036a: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.rotation = default(Quaternion);
		Vector3 val = ((Component)this).transform.TransformDirection(new Vector3(boneAxis.x * targetDistance, boneAxis.y * targetDistance, boneAxis.z * targetDistance));
		Vector3 val2 = ((Component)this).transform.TransformDirection(new Vector3(0f, 1f, 0f));
		Vector3 val3 = ((Component)this).transform.position + ((Component)this).transform.TransformDirection(new Vector3(boneAxis.x * targetDistance, boneAxis.y * targetDistance, boneAxis.z * targetDistance));
		force.x = (val3.x - dynamicPos.x) * bStiffness;
		acc.x = force.x / bMass;
		vel.x += acc.x * (1f - bDamping);
		force.y = (val3.y - dynamicPos.y) * bStiffness;
		force.y -= bGravity / 10f;
		acc.y = force.y / bMass;
		vel.y += acc.y * (1f - bDamping);
		force.z = (val3.z - dynamicPos.z) * bStiffness;
		acc.z = force.z / bMass;
		vel.z += acc.z * (1f - bDamping);
		dynamicPos += vel + force;
		((Component)this).transform.LookAt(dynamicPos, val2);
		if (SquashAndStretch)
		{
			Vector3 val4 = dynamicPos - val3;
			float magnitude = ((Vector3)(ref val4)).magnitude;
			float num = ((boneAxis.x != 0f) ? (1f + magnitude * frontStretch) : (1f + (0f - magnitude) * sideStretch));
			float num2 = ((boneAxis.y != 0f) ? (1f + magnitude * frontStretch) : (1f + (0f - magnitude) * sideStretch));
			float num3 = ((boneAxis.z != 0f) ? (1f + magnitude * frontStretch) : (1f + (0f - magnitude) * sideStretch));
			((Component)this).transform.localScale = new Vector3(num, num2, num3);
		}
		if (debugMode)
		{
			Debug.DrawRay(((Component)this).transform.position, val, Color.blue);
			Debug.DrawRay(((Component)this).transform.position, val2, Color.green);
			Debug.DrawRay(val3, Vector3.up * 0.2f, Color.yellow);
			Debug.DrawRay(dynamicPos, Vector3.up * 0.2f, Color.red);
		}
	}
}


using UnityEngine;

public class EggUpdater : MonoBehaviour
{
}


public class ItemModCrackOpen : ItemModUnwrap
{
	public static readonly Phrase CrackOpenTitle = new Phrase("crack_open", "Crack Open");

	public static readonly Phrase CrackOpenDesc = new Phrase("crack_open_desc", "Crack open the egg");
}


using UnityEngine;

public class RandomRendererEnable : MonoBehaviour
{
	public Renderer[] randoms;

	public int EnabledIndex { get; private set; }

	public void OnEnable()
	{
		int num2 = (EnabledIndex = Random.Range(0, randoms.Length));
		randoms[num2].enabled = true;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class BunnyEntry : MonoBehaviour
{
	public Text nameText;

	public Text amountText;

	public RawImage starImage;

	public RawImage selfImage;
}


using Rust.UI;
using UnityEngine;

public class EggHuntNote : MonoBehaviour, IClientComponent
{
	public Canvas canvas;

	public CanvasGroup mainGroup;

	public CanvasGroup timerGroup;

	public RustText timerText;

	public static readonly Phrase startsInPhrase = new Phrase("egghunt.start", "Starts in: {0}");
}


using UnityEngine;
using UnityEngine.UI;

public class TopBunnies : MonoBehaviour
{
	public Canvas canvas;

	public BunnyEntry[] topBunnyEntries;

	public Text timerText;

	public CanvasGroup group;

	public Color endingColor;
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class GraveyardFence : SimpleBuildingBlock
{
	public BoxCollider[] pillars;

	public override void ServerInit()
	{
		base.ServerInit();
		UpdatePillars();
	}

	public override void DestroyShared()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.DestroyShared();
		List<GraveyardFence> list = Pool.Get<List<GraveyardFence>>();
		Vis.Entities(((Component)this).transform.position, 5f, list, 2097152, (QueryTriggerInteraction)2);
		foreach (GraveyardFence item in list)
		{
			item.UpdatePillars();
		}
		Pool.FreeUnmanaged<GraveyardFence>(ref list);
	}

	public virtual void UpdatePillars()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		BoxCollider[] array = pillars;
		foreach (BoxCollider val in array)
		{
			((Component)val).gameObject.SetActive(true);
			Collider[] array2 = Physics.OverlapBox(((Component)val).transform.TransformPoint(val.center), val.size * 0.5f, ((Component)val).transform.rotation, 2097152);
			foreach (Collider val2 in array2)
			{
				if (((Component)val2).CompareTag("Usable Auxiliary"))
				{
					BaseEntity baseEntity = ((Component)val2).gameObject.ToBaseEntity();
					if (!((Object)(object)baseEntity == (Object)null) && !EqualNetID((BaseNetworkable)baseEntity) && (Object)(object)val2 != (Object)(object)val)
					{
						((Component)val).gameObject.SetActive(false);
					}
				}
			}
		}
	}
}


public class HalloweenEventNote : EggHuntNote
{
}


public class HalloweenHunt : EggHuntEvent
{
	public static Phrase topCreepPhrase = new Phrase("candyhunt.result.topcreeps", "{0} is the top creep with {1} candies collected.");

	public static Phrase placeCreepPhrase = new Phrase("candyhunt.result.place", "You placed {0} of {1} with {2} candies collected.");

	protected override Phrase GetTopBunnyPhrase()
	{
		return topCreepPhrase;
	}

	protected override Phrase GetPlacePhrase()
	{
		return placeCreepPhrase;
	}

	protected override void ReportPlayerParticipated(int topCount)
	{
	}

	protected override void ReportEggsCollected(int numEggs)
	{
	}
}


public class ItemModOpenLootBag : ItemModUnwrap
{
	public static readonly Phrase OpenLootBagTitle = new Phrase("open_lootbag", "Open Bag");

	public static readonly Phrase OpenLootBagDesc = new Phrase("open_lootbag_desc", "");
}


using UnityEngine;

public class SpiderWeb : BaseCombatEntity
{
	public bool Fresh()
	{
		if (!HasFlag(Flags.Reserved1) && !HasFlag(Flags.Reserved2) && !HasFlag(Flags.Reserved3))
		{
			return !HasFlag(Flags.Reserved4);
		}
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (Fresh())
		{
			int num = Random.Range(0, 4);
			Flags f = Flags.Reserved1;
			switch (num)
			{
			case 0:
				f = Flags.Reserved1;
				break;
			case 1:
				f = Flags.Reserved2;
				break;
			case 2:
				f = Flags.Reserved3;
				break;
			case 3:
				f = Flags.Reserved4;
				break;
			}
			SetFlag(f, b: true);
		}
	}
}


using Facepunch;
using ntw.CurvedTextMeshPro;
using ProtoBuf;
using Rust.UI;
using UnityEngine;

public class SkullTrophy : StorageContainer
{
	public RustText NameText;

	public TextProOnACircle CircleModifier;

	public int AngleModifierMinCharCount = 3;

	public int AngleModifierMaxCharCount = 20;

	public int AngleModifierMinArcAngle = 20;

	public int AngleModifierMaxArcAngle = 45;

	public float SunsetTime = 18f;

	public float SunriseTime = 5f;

	public RendererLOD SkullRenderer;

	public Material[] DaySkull;

	public Material[] NightSkull;

	public Material[] NoSkull;

	public const Flags HasSkull = Flags.Reserved1;

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		SetFlag(Flags.Reserved1, base.inventory.GetSlot(0) != null);
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			if (base.inventory != null && base.inventory.itemList.Count == 1)
			{
				info.msg.skullTrophy = Pool.Get<SkullTrophy>();
				info.msg.skullTrophy.playerName = base.inventory.itemList[0].GetName(false);
				info.msg.skullTrophy.streamerName = base.inventory.itemList[0].GetName(true);
			}
			else if (info.msg.skullTrophy != null)
			{
				info.msg.skullTrophy.playerName = string.Empty;
				info.msg.skullTrophy.streamerName = string.Empty;
			}
		}
	}
}


using UnityEngine;

public class JunkPileBuoyancyPoint : MonoBehaviour
{
}


using System;
using UnityEngine;

public class JunkPileWater : JunkPile, IBudgetedFloatingEntity, IDestroyableOnPlayerBoatCollision
{
	public class JunkpileWaterWorkQueue : PersistentObjectWorkQueue<IBudgetedFloatingEntity>
	{
		protected override void RunJob(IBudgetedFloatingEntity entity)
		{
			if (((PersistentObjectWorkQueue<IBudgetedFloatingEntity>)this).ShouldAdd(entity))
			{
				entity.UpdateNearbyPlayers();
			}
		}

		protected override bool ShouldAdd(IBudgetedFloatingEntity entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.Entity.IsValid();
			}
			return false;
		}
	}

	public Transform[] buoyancyPoints;

	public bool debugDraw;

	public float updateCullRange = 16f;

	public float VehicleCheckRadius = 5f;

	public Rigidbody Body;

	[Range(0f, 1f)]
	public float buoyancyAmplitude = 1f;

	[ServerVar]
	public static bool DestroyableByPlayerBoats = true;

	[ServerVar]
	public static float MinimumPlayerBoatMassToBeDestroyed = 2000f;

	[ServerVar]
	public static float MinimumPlayerBoatVelocityToBeDestroyed = 5f;

	private Action updateMovementFixedTick;

	private Quaternion baseRotation = Quaternion.identity;

	private bool first = true;

	private bool hasPlayersNearby;

	private TimeUntil nextPlayerCheck;

	public static JunkpileWaterWorkQueue junkpileWaterWorkQueue = new JunkpileWaterWorkQueue();

	[Help("How many milliseconds to budget for processing junk pile updates per frame")]
	[ServerVar]
	public static float framebudgetms = 0.05f;

	public BaseEntity Entity => this;

	public override void Spawn()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		position.y = WaterLevel.GetWaterSurface(((Component)this).transform.position, waves: false, volumes: false);
		((Component)this).transform.position = position;
		base.Spawn();
		Quaternion rotation = ((Component)this).transform.rotation;
		baseRotation = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
		if (Physics.CheckSphere(((Component)this).transform.position, VehicleCheckRadius, 134217728))
		{
			Kill();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)EnqueueNearPlayersCheck, 0f, 0.75f, 0.25f);
	}

	public void EnqueueNearPlayersCheck()
	{
		((PersistentObjectWorkQueue<IBudgetedFloatingEntity>)junkpileWaterWorkQueue).Add((IBudgetedFloatingEntity)this);
	}

	public void UpdateMovementFixedTick()
	{
		if (!isSinking)
		{
			SimpleBuoyancyUpdate(buoyancyPoints, ((Component)this).transform, ref baseRotation, Body, ref first, debugDraw, 1f, buoyancyAmplitude);
		}
	}

	public static void SimpleBuoyancyUpdate(Transform[] buoyancyPoints, Transform forTransform, ref Quaternion baseRotation, Rigidbody body, ref bool first, bool debugDraw, float movementMultiplier = 1f, float buoyancyAmplitude = 1f)
	{
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		if (buoyancyPoints != null && buoyancyPoints.Length >= 3)
		{
			Vector3 position = forTransform.position;
			Vector3 localPosition = buoyancyPoints[0].localPosition;
			Vector3 localPosition2 = buoyancyPoints[1].localPosition;
			Vector3 localPosition3 = buoyancyPoints[2].localPosition;
			Vector3 val = localPosition + position;
			Vector3 val2 = localPosition2 + position;
			Vector3 val3 = localPosition3 + position;
			val.y = WaterLevel.GetWaterSurface(val, waves: true, volumes: false);
			val2.y = WaterLevel.GetWaterSurface(val2, waves: true, volumes: false);
			val3.y = WaterLevel.GetWaterSurface(val3, waves: true, volumes: false);
			Vector3 val4 = default(Vector3);
			((Vector3)(ref val4))..ctor(position.x, val.y - localPosition.y, position.z);
			Vector3 val5 = val2 - val;
			Vector3 val6 = Vector3.Cross(val3 - val, val5);
			Quaternion val7 = Quaternion.LookRotation(new Vector3(val6.x, val6.z, val6.y));
			Vector3 eulerAngles = ((Quaternion)(ref val7)).eulerAngles;
			val7 = Quaternion.Euler(0f - eulerAngles.x, 0f, 0f - eulerAngles.y);
			if (first)
			{
				Quaternion rotation = forTransform.rotation;
				baseRotation = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
				first = false;
			}
			Vector3 val8 = Vector3.Lerp(forTransform.position, val4, movementMultiplier);
			Quaternion val9 = Quaternion.Lerp(forTransform.rotation, val7 * baseRotation, movementMultiplier);
			if (!Mathf.Approximately(buoyancyAmplitude, 1f))
			{
				float waterSurface = WaterLevel.GetWaterSurface(val, waves: false, volumes: false);
				val8 = Vector3.Lerp(Vector3Ex.WithY(val4, waterSurface), val4, buoyancyAmplitude);
				val9 = Quaternion.Slerp(baseRotation, val9, buoyancyAmplitude);
			}
			if (!Object.op_Implicit((Object)(object)body))
			{
				forTransform.SetPositionAndRotation(val8, val9);
				return;
			}
			body.MovePosition(val8);
			body.MoveRotation(val9);
		}
		else
		{
			float waterSurface2 = WaterLevel.GetWaterSurface(forTransform.position, waves: true, volumes: false);
			if (!Object.op_Implicit((Object)(object)body))
			{
				forTransform.position = new Vector3(forTransform.position.x, waterSurface2, forTransform.position.z);
			}
			else
			{
				body.MovePosition(new Vector3(body.position.x, waterSurface2, body.position.z));
			}
		}
	}

	public void UpdateNearbyPlayers()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (TimeUntil.op_Implicit(nextPlayerCheck) > 0f)
		{
			return;
		}
		nextPlayerCheck = TimeUntil.op_Implicit(Random.Range(0.5f, 1f));
		hasPlayersNearby = BaseNetworkable.HasCloseConnections(((Component)this).transform.position, updateCullRange);
		ToggleNetworkPositionTick(hasPlayersNearby);
		if (updateMovementFixedTick == null)
		{
			updateMovementFixedTick = UpdateMovementFixedTick;
		}
		if (hasPlayersNearby)
		{
			if (!((FacepunchBehaviour)this).IsInvokingFixedTime(updateMovementFixedTick))
			{
				((FacepunchBehaviour)this).InvokeRepeatingFixedTime(updateMovementFixedTick);
			}
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvokeFixedTime(updateMovementFixedTick);
		}
	}

	public bool ShouldBeDestroyedBy(PlayerBoat boat)
	{
		return ShouldJunkpileBeDestroyedBy(boat);
	}

	public virtual bool ShouldJunkpileBeDestroyedBy(PlayerBoat boat)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)boat == (Object)null)
		{
			return false;
		}
		if (!DestroyableByPlayerBoats)
		{
			return false;
		}
		if (boat.rigidBody.mass >= MinimumPlayerBoatMassToBeDestroyed)
		{
			Vector3 velocity = boat.rigidBody.velocity;
			return ((Vector3)(ref velocity)).magnitude >= MinimumPlayerBoatVelocityToBeDestroyed;
		}
		return false;
	}
}


public class JunkpileWaterWorkQueue : PersistentObjectWorkQueue<IBudgetedFloatingEntity>
{
	protected override void RunJob(IBudgetedFloatingEntity entity)
	{
		if (((PersistentObjectWorkQueue<IBudgetedFloatingEntity>)this).ShouldAdd(entity))
		{
			entity.UpdateNearbyPlayers();
		}
	}

	protected override bool ShouldAdd(IBudgetedFloatingEntity entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.Entity.IsValid();
		}
		return false;
	}
}


public interface IBudgetedFloatingEntity
{
	BaseEntity Entity { get; }

	void UpdateNearbyPlayers();
}


using UnityEngine;

public class JunkPileWaterSpawner : SpawnGroup
{
	public BaseEntity attachToParent;

	protected override void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
	{
		base.PostSpawnProcess(entity, spawnPoint);
		if ((Object)(object)attachToParent != (Object)null)
		{
			entity.SetParent(attachToParent, worldPositionStays: true);
		}
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class DeliveryDrone : Drone
{
	private enum State
	{
		Invalid,
		Takeoff,
		FlyToVendingMachine,
		DescendToVendingMachine,
		PickUpItems,
		AscendBeforeReturn,
		ReturnToTerminal,
		Landing
	}

	[Header("Delivery Drone")]
	public float stateTimeout = 300f;

	public float targetPositionTolerance = 1f;

	public float preferredCruiseHeight = 20f;

	public float preferredHeightAboveObstacle = 5f;

	public float marginAbovePreferredHeight = 3f;

	public float obstacleHeightLockDuration = 3f;

	public int pickUpDelayInTicks = 3;

	public DeliveryDroneConfig config;

	public GameObjectRef mapMarkerPrefab;

	public EntityRef<Marketplace> sourceMarketplace;

	public EntityRef<MarketTerminal> sourceTerminal;

	public EntityRef<VendingMachine> targetVendingMachine;

	public State _state;

	public RealTimeSince _sinceLastStateChange;

	public Vector3? _stateGoalPosition;

	public float? _goToY;

	public TimeSince _sinceLastObstacleBlock;

	public float? _minimumYLock;

	public int _pickUpTicks;

	public BaseEntity _mapMarkerInstance;

	public void Setup(Marketplace marketplace, MarketTerminal terminal, VendingMachine vendingMachine)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		sourceMarketplace.Set(marketplace);
		sourceTerminal.Set(terminal);
		targetVendingMachine.Set(vendingMachine);
		_state = State.Takeoff;
		_sinceLastStateChange = RealTimeSince.op_Implicit(0f);
		_pickUpTicks = 0;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)Think, 0f, 0.5f, 0.25f);
		CreateMapMarker();
	}

	public void CreateMapMarker()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_mapMarkerInstance != (Object)null)
		{
			_mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerPrefab?.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.OwnerID = base.OwnerID;
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		_mapMarkerInstance = baseEntity;
	}

	public void Think()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0345: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0323: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		if (RealTimeSince.op_Implicit(_sinceLastStateChange) > stateTimeout)
		{
			Debug.LogError((object)"Delivery drone hasn't change state in too long, killing", (Object)(object)this);
			ForceRemove();
			return;
		}
		if (!sourceMarketplace.TryGet(serverside: true, out var marketplace) || !sourceTerminal.TryGet(serverside: true, out var _))
		{
			Debug.LogError((object)"Delivery drone's marketplace or terminal was destroyed, killing", (Object)(object)this);
			ForceRemove();
			return;
		}
		if (!targetVendingMachine.TryGet(serverside: true, out var entity2) && _state <= State.AscendBeforeReturn)
		{
			SetState(State.ReturnToTerminal);
		}
		Vector3 currentPosition = ((Component)this).transform.position;
		float num = GetMinimumHeight(Vector3.zero);
		if (_goToY.HasValue)
		{
			if (!IsAtGoToY())
			{
				targetPosition = Vector3Ex.WithY(currentPosition, _goToY.Value);
				return;
			}
			_goToY = null;
			_sinceLastObstacleBlock = TimeSince.op_Implicit(0f);
			_minimumYLock = currentPosition.y;
		}
		Vector3 waitPosition;
		switch (_state)
		{
		case State.Takeoff:
			SetGoalPosition(marketplace.droneLaunchPoint.position + Vector3.up * 15f);
			if (IsAtGoalPosition())
			{
				SetState(State.FlyToVendingMachine);
			}
			break;
		case State.FlyToVendingMachine:
		{
			bool isBlocked2;
			float num2 = CalculatePreferredY(out isBlocked2);
			if (isBlocked2 && currentPosition.y < num2)
			{
				SetGoToY(num2 + marginAbovePreferredHeight);
				return;
			}
			config.FindDescentPoints(entity2, num2 + marginAbovePreferredHeight, out waitPosition, out var descendPosition);
			SetGoalPosition(descendPosition);
			if (IsAtGoalPosition())
			{
				SetState(State.DescendToVendingMachine);
			}
			break;
		}
		case State.DescendToVendingMachine:
		{
			config.FindDescentPoints(entity2, currentPosition.y, out var waitPosition2, out waitPosition);
			SetGoalPosition(waitPosition2);
			if (IsAtGoalPosition())
			{
				SetState(State.PickUpItems);
			}
			break;
		}
		case State.PickUpItems:
			_pickUpTicks++;
			if (_pickUpTicks >= pickUpDelayInTicks)
			{
				SetState(State.AscendBeforeReturn);
			}
			break;
		case State.AscendBeforeReturn:
		{
			config.FindDescentPoints(entity2, num + preferredCruiseHeight, out waitPosition, out var descendPosition2);
			SetGoalPosition(descendPosition2);
			if (IsAtGoalPosition())
			{
				SetState(State.ReturnToTerminal);
			}
			break;
		}
		case State.ReturnToTerminal:
		{
			bool isBlocked3;
			float num3 = CalculatePreferredY(out isBlocked3);
			if (isBlocked3 && currentPosition.y < num3)
			{
				SetGoToY(num3 + marginAbovePreferredHeight);
				return;
			}
			Vector3 val = LandingPosition();
			if (Vector3Ex.Distance2D(currentPosition, val) < 30f)
			{
				val.y = Mathf.Max(val.y, num3 + marginAbovePreferredHeight);
			}
			else
			{
				val.y = num3 + marginAbovePreferredHeight;
			}
			SetGoalPosition(val);
			if (IsAtGoalPosition())
			{
				SetState(State.Landing);
			}
			break;
		}
		case State.Landing:
			SetGoalPosition(LandingPosition());
			if (IsAtGoalPosition())
			{
				marketplace.ReturnDrone(this);
				SetState(State.Invalid);
			}
			break;
		default:
			ForceRemove();
			break;
		}
		if (_minimumYLock.HasValue)
		{
			if (TimeSince.op_Implicit(_sinceLastObstacleBlock) > obstacleHeightLockDuration)
			{
				_minimumYLock = null;
			}
			else if (targetPosition.HasValue && targetPosition.Value.y < _minimumYLock.Value)
			{
				targetPosition = Vector3Ex.WithY(targetPosition.Value, _minimumYLock.Value);
			}
		}
		float CalculatePreferredY(out bool isBlocked)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			//IL_0106: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0126: Unknown result type (might be due to invalid IL or missing references)
			//IL_0129: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_014e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_0158: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016a: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_016f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0171: Unknown result type (might be due to invalid IL or missing references)
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			//IL_0185: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_019b: Unknown result type (might be due to invalid IL or missing references)
			//IL_019d: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01be: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val2 = default(Vector3);
			float num4 = default(float);
			Vector3Ex.ToDirectionAndMagnitude(Vector3Ex.WithY(body.velocity, 0f), ref val2, ref num4);
			if (num4 < 0.5f)
			{
				float num5 = GetMinimumHeight(Vector3.zero) + preferredCruiseHeight;
				Vector3 val3 = Vector3Ex.WithY(currentPosition, num5 + 1000f);
				Vector3Ex.WithY(currentPosition, num5);
				RaycastHit val4 = default(RaycastHit);
				isBlocked = Physics.Raycast(val3, Vector3.down, ref val4, 1000f, LayerMask.op_Implicit(config.layerMask));
				if (!isBlocked)
				{
					return num5;
				}
				return num5 + (1000f - ((RaycastHit)(ref val4)).distance) + preferredHeightAboveObstacle;
			}
			float num6 = num4 * 2f;
			float num7 = GetMinimumHeight(Vector3.zero);
			float num8 = GetMinimumHeight(new Vector3(0f, 0f, num6 / 2f));
			float num9 = GetMinimumHeight(new Vector3(0f, 0f, num6));
			float num10 = Mathf.Max(Mathf.Max(num7, num8), num9) + preferredCruiseHeight;
			Quaternion val5 = Quaternion.FromToRotation(Vector3.forward, val2);
			Vector3 val6 = Vector3Ex.WithZ(config.halfExtents, num6 / 2f);
			Vector3 val7 = Vector3Ex.WithY(Vector3Ex.WithY(currentPosition, num10) + val5 * new Vector3(0f, 0f, val6.z / 2f), num10 + 1000f);
			RaycastHit val8 = default(RaycastHit);
			isBlocked = Physics.BoxCast(val7, val6, Vector3.down, ref val8, val5, 1000f, LayerMask.op_Implicit(config.layerMask));
			if (isBlocked)
			{
				Ray ray = default(Ray);
				((Ray)(ref ray))..ctor(val7, Vector3.down);
				Vector3 val9 = ray.ClosestPoint(((RaycastHit)(ref val8)).point);
				float num11 = Vector3.Distance(((Ray)(ref ray)).origin, val9);
				return num10 + (1000f - num11) + preferredHeightAboveObstacle;
			}
			return num10;
		}
		float GetMinimumHeight(Vector3 offset)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return WaterLevel.GetWaterOrTerrainSurface(((Component)this).transform.TransformPoint(offset), waves: true, volumes: true);
		}
		bool IsAtGoalPosition()
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if (_stateGoalPosition.HasValue)
			{
				return Vector3.Distance(_stateGoalPosition.Value, currentPosition) < targetPositionTolerance;
			}
			return false;
		}
		bool IsAtGoToY()
		{
			if (_goToY.HasValue)
			{
				return Mathf.Abs(_goToY.Value - currentPosition.y) < targetPositionTolerance;
			}
			return false;
		}
		Vector3 LandingPosition()
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return marketplace.droneLaunchPoint.position;
		}
		void SetGoalPosition(Vector3 position)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			_goToY = null;
			_stateGoalPosition = position;
			targetPosition = position;
		}
		void SetGoToY(float y)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			_goToY = y;
			targetPosition = Vector3Ex.WithY(currentPosition, y);
		}
		void SetState(State newState)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			_state = newState;
			_sinceLastStateChange = RealTimeSince.op_Implicit(0f);
			_pickUpTicks = 0;
			_stateGoalPosition = null;
			_goToY = null;
			SetFlag(Flags.Reserved1, _state >= State.AscendBeforeReturn);
		}
	}

	public void ForceRemove()
	{
		if (sourceMarketplace.TryGet(serverside: true, out var entity))
		{
			entity.ReturnDrone(this);
		}
		else
		{
			Kill();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.deliveryDrone = Pool.Get<DeliveryDrone>();
			info.msg.deliveryDrone.marketplaceId = sourceMarketplace.uid;
			info.msg.deliveryDrone.terminalId = sourceTerminal.uid;
			info.msg.deliveryDrone.vendingMachineId = targetVendingMachine.uid;
			info.msg.deliveryDrone.state = (int)_state;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.deliveryDrone != null)
		{
			sourceMarketplace = new EntityRef<Marketplace>(info.msg.deliveryDrone.marketplaceId);
			sourceTerminal = new EntityRef<MarketTerminal>(info.msg.deliveryDrone.terminalId);
			targetVendingMachine = new EntityRef<VendingMachine>(info.msg.deliveryDrone.vendingMachineId);
			_state = (State)info.msg.deliveryDrone.state;
		}
	}

	public override bool CanControl(ulong playerID)
	{
		return false;
	}
}


private enum State
{
	Invalid,
	Takeoff,
	FlyToVendingMachine,
	DescendToVendingMachine,
	PickUpItems,
	AscendBeforeReturn,
	ReturnToTerminal,
	Landing
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Delivery Drone Config")]
public class DeliveryDroneConfig : BaseScriptableObject
{
	public Vector3 vendingMachineOffset = new Vector3(0f, 1f, 1f);

	public float maxDistanceFromVendingMachine = 1f;

	public Vector3 halfExtents = new Vector3(0.5f, 0.5f, 0.5f);

	public float testHeight = 200f;

	public LayerMask layerMask = LayerMask.op_Implicit(161546496);

	public void FindDescentPoints(VendingMachine vendingMachine, float currentY, out Vector3 waitPosition, out Vector3 descendPosition)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		float num = maxDistanceFromVendingMachine / 4f;
		RaycastHit val4 = default(RaycastHit);
		for (int i = 0; i <= 4; i++)
		{
			Vector3 val = Vector3.forward * (num * (float)i);
			Vector3 val2 = ((Component)vendingMachine).transform.TransformPoint(vendingMachineOffset + val);
			Vector3 val3 = val2 + Vector3.up * testHeight;
			if (!Physics.BoxCast(val3, halfExtents, Vector3.down, ref val4, ((Component)vendingMachine).transform.rotation, testHeight, LayerMask.op_Implicit(layerMask)))
			{
				waitPosition = val2;
				descendPosition = Vector3Ex.WithY(val3, currentY);
				return;
			}
			if (i == 4)
			{
				waitPosition = val3 + Vector3.down * (((RaycastHit)(ref val4)).distance - halfExtents.y * 2f);
				descendPosition = Vector3Ex.WithY(val3, currentY);
				return;
			}
		}
		throw new Exception("Bug: FindDescentPoint didn't return a fallback value");
	}

	public bool IsVendingMachineAccessible(VendingMachine vendingMachine, Vector3 offset, out RaycastHit hitInfo)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)vendingMachine).transform.TransformPoint(offset);
		if (Physics.BoxCast(val + Vector3.up * testHeight, halfExtents, Vector3.down, ref hitInfo, ((Component)vendingMachine).transform.rotation, testHeight, LayerMask.op_Implicit(layerMask)))
		{
			return false;
		}
		return vendingMachine.IsVisible(val, 2f);
	}
}


public class MapMarkerDeliveryDrone : MapMarker
{
	public override void ServerInit()
	{
		base.ServerInit();
		base.limitNetworking = true;
	}

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		return (ulong)player.userID == base.OwnerID;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class Marketplace : BaseEntity
{
	[Header("Marketplace")]
	public GameObjectRef terminalPrefab;

	public Transform[] terminalPoints;

	public Transform droneLaunchPoint;

	public GameObjectRef deliveryDronePrefab;

	[NonSerialized]
	public EntityRef<MarketTerminal>[] terminalEntities;

	public NetworkableId SendDrone(BasePlayer player, MarketTerminal sourceTerminal, VendingMachine vendingMachine)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)sourceTerminal == (Object)null || (Object)(object)vendingMachine == (Object)null)
		{
			return default(NetworkableId);
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(deliveryDronePrefab?.resourcePath, droneLaunchPoint.position, droneLaunchPoint.rotation);
		if (!(baseEntity is DeliveryDrone deliveryDrone))
		{
			baseEntity.Kill();
			return default(NetworkableId);
		}
		deliveryDrone.OwnerID = player.userID;
		deliveryDrone.Spawn();
		deliveryDrone.Setup(this, sourceTerminal, vendingMachine);
		return deliveryDrone.net.ID;
	}

	public void ReturnDrone(DeliveryDrone deliveryDrone)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (deliveryDrone.sourceTerminal.TryGet(serverside: true, out var entity))
		{
			entity.CompleteOrder(deliveryDrone.targetVendingMachine.uid);
		}
		deliveryDrone.Kill();
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			SpawnSubEntities();
		}
	}

	private void SpawnSubEntities()
	{
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		if (terminalEntities != null && terminalEntities.Length > terminalPoints.Length)
		{
			for (int i = terminalPoints.Length; i < terminalEntities.Length; i++)
			{
				if (terminalEntities[i].TryGet(serverside: true, out var entity))
				{
					entity.Kill();
				}
			}
		}
		Array.Resize(ref terminalEntities, terminalPoints.Length);
		for (int j = 0; j < terminalPoints.Length; j++)
		{
			Transform val = terminalPoints[j];
			if (!terminalEntities[j].TryGet(serverside: true, out var _))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(terminalPrefab?.resourcePath, val.position, val.rotation);
				baseEntity.SetParent(this, worldPositionStays: true);
				baseEntity.Spawn();
				if (!(baseEntity is MarketTerminal marketTerminal))
				{
					Debug.LogError((object)("Marketplace.terminalPrefab did not spawn a MarketTerminal (it spawned " + ((object)baseEntity).GetType().FullName + ")"));
					baseEntity.Kill();
				}
				else
				{
					marketTerminal.Setup(this);
					terminalEntities[j].Set(marketTerminal);
				}
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.subEntityList != null)
		{
			List<NetworkableId> subEntityIds = info.msg.subEntityList.subEntityIds;
			Array.Resize(ref terminalEntities, subEntityIds.Count);
			for (int i = 0; i < subEntityIds.Count; i++)
			{
				terminalEntities[i] = new EntityRef<MarketTerminal>(subEntityIds[i]);
			}
		}
		SpawnSubEntities();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.subEntityList = Pool.Get<SubEntityList>();
		info.msg.subEntityList.subEntityIds = Pool.Get<List<NetworkableId>>();
		if (terminalEntities != null)
		{
			for (int i = 0; i < terminalEntities.Length; i++)
			{
				info.msg.subEntityList.subEntityIds.Add(terminalEntities[i].uid);
			}
		}
	}
}


using UnityEngine;

public class UIMarketSearch : MonoBehaviour
{
	public GameObjectRef StoreEntryRef;

	public RectTransform StoreRoot;

	public UIMarketTerminal Terminal;
}


using Rust.UI;
using UnityEngine;

public class UIMarketSearchOrderEntry : MonoBehaviour
{
	public RustText ItemName;

	public GameObject OutOfStockRoot;

	public GameObject BpRoot;
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;

public class UIMarketSearchStore : MonoBehaviour
{
	public RustText StoreName;

	public List<UIMarketSearchOrderEntry> Entries;
}


using Rust.UI;
using UnityEngine;

public class UIMarketTerminal : UIDialog, IVendingMachineInterface
{
	public static readonly Phrase PendingDeliveryPluralPhrase = new Phrase("market.pending_delivery.plural", "Waiting for {n} deliveries...");

	public static readonly Phrase PendingDeliverySingularPhrase = new Phrase("market.pending_delivery.singular", "Waiting for delivery...");

	public Canvas canvas;

	public MapView mapView;

	public RectTransform shopDetailsPanel;

	public float shopDetailsMargin = 16f;

	public float easeDuration = 0.2f;

	public LeanTweenType easeType = (LeanTweenType)1;

	public TmProEmojiRedirector shopName;

	public GameObject shopOrderingPanel;

	public RectTransform sellOrderContainer;

	public GameObjectRef sellOrderPrefab;

	public VirtualItemIcon deliveryFeeIcon;

	public GameObject deliveryFeeCantAffordIndicator;

	public GameObject inventoryFullIndicator;

	public GameObject notEligiblePanel;

	public GameObject pendingDeliveryPanel;

	public RustText pendingDeliveryLabel;

	public RectTransform itemNoticesContainer;

	public GameObjectRef itemRemovedPrefab;

	public GameObjectRef itemPendingPrefab;

	public GameObjectRef itemAddedPrefab;

	public CanvasGroup gettingStartedTip;

	public SoundDefinition buyItemSoundDef;

	public SoundDefinition buttonPressSoundDef;
}


using Rust.UI;
using UnityEngine;

public class ConfigureOrnateFrameDialog : UIDialog
{
	public RustInput textInput;

	public FlexibleColorPicker textColorPicker;

	public void OnClickedConfirm()
	{
	}

	public void OnTextChanged(string newText)
	{
	}

	public void OnTextColourChanged(Color newColour)
	{
	}
}


using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class FlagTogglePhotoFrame : PhotoFrame, IFlagNotify
{
	public GameObjectRef IoEntity;

	public Transform IoEntityAnchor;

	[Tooltip("Flags to toggle on the PhotoFrame entity when child IOEntity's flag changes.")]
	public Flags flagsToToggle;

	private EntityRef<IOEntity> spawnedIo;

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.simpleUID != null)
		{
			spawnedIo.uid = info.msg.simpleUID.uid;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SpawnIOEnt();
		}
	}

	public void OnFlagToggled(bool state)
	{
		SetFlag(flagsToToggle, state);
	}

	private void SpawnIOEnt()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (IoEntity.isValid && (Object)(object)IoEntityAnchor != (Object)null)
		{
			IOEntity iOEntity = GameManager.server.CreateEntity(IoEntity.resourcePath, IoEntityAnchor.position, IoEntityAnchor.rotation) as IOEntity;
			iOEntity.SetParent(this, worldPositionStays: true);
			spawnedIo.Set(iOEntity);
			iOEntity.Spawn();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.simpleUID == null)
		{
			info.msg.simpleUID = Pool.Get<SimpleUID>();
		}
		info.msg.simpleUID.uid = spawnedIo.uid;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

public class RadiationSphere : BaseEntity
{
	private struct RadiationLight
	{
		public IOEntity Light;

		public Color OriginalColor;
	}

	public AnimationCurve RadiationCurve;

	public float InvokeDelay = 5f;

	public List<IOEntity> RadiationLights = new List<IOEntity>();

	private float timeStarted;

	private TriggerRadiation[] radiationTriggers;

	public static List<RadiationSphere> All { get; private set; } = new List<RadiationSphere>();

	public override void ServerInit()
	{
		base.ServerInit();
		radiationTriggers = ((Component)this).GetComponentsInChildren<TriggerRadiation>();
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateRadiation, InvokeDelay, InvokeDelay, InvokeDelay / 10f);
		All.Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		All.Remove(this);
	}

	public void RestartRadiation()
	{
		timeStarted = Time.time;
	}

	public void StopRadation()
	{
		timeStarted = 0f;
	}

	public void UpdateRadiation()
	{
		float num = RadiationCurve.Evaluate((Time.time - timeStarted) / 60f * Server.oilrig_radiation_time_scale) * Server.oilrig_radiation_amount_scale;
		if (timeStarted == 0f)
		{
			num = 0f;
		}
		TriggerRadiation[] array = radiationTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].RadiationAmountOverride = num;
		}
		SetLights(num > Server.oilrig_radiation_alarm_threshold);
	}

	private void SetLights(bool state)
	{
		foreach (IOEntity radiationLight in RadiationLights)
		{
			if (!((Object)(object)radiationLight == (Object)null))
			{
				radiationLight.SetFlag(Flags.Reserved8, state);
			}
		}
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == "HackingStarted")
		{
			RestartRadiation();
		}
	}

	public void OnPuzzleReset()
	{
		StopRadation();
	}
}


using UnityEngine;

private struct RadiationLight
{
	public IOEntity Light;

	public Color OriginalColor;
}


using Rust.UI;
using UnityEngine;

public class MonumentSign : LODComponent
{
	public float viewDistance = 30f;

	public GameObject uiRoot;

	public RustText signText;
}


using UnityEngine;
using UnityEngine.UI;

public class NotePanel : MonoBehaviour, IItemPanel
{
	public InputField input;

	private Item item;
}


using Facepunch.Extend;
using UnityEngine;

[Factory("note")]
public class note : ConsoleSystem
{
	[ServerUserVar]
	public static void update(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		ItemId itemID = arg.GetItemID(0);
		string @string = arg.GetString(1, "");
		Item item = arg.Player().inventory.FindItemByUID(itemID);
		if (item != null)
		{
			item.text = StringExtensions.Truncate(@string, 1024, (string)null);
			item.MarkDirty();
		}
	}
}


public class CoverageQueryFlare : BaseMonoBehaviour, IClientComponent
{
	public bool isDynamic;

	public bool timeShimmer;

	public bool positionalShimmer;

	public bool rotate;

	public float maxVisibleDistance = 30f;

	public bool lightScaled;

	public float dotMin = -1f;

	public float dotMax = -1f;

	public CoverageQueries.RadiusSpace coverageRadiusSpace;

	public float coverageRadius = 0.01f;

	public LODDistanceMode DistanceMode;
}


using UnityEngine;

public class OreHotSpot : BaseCombatEntity, ILOD
{
	public float visualDistance = 20f;

	public GameObjectRef visualEffect;

	public GameObjectRef finishEffect;

	public GameObjectRef damageEffect;

	public OreResourceEntity owner;

	public void OreOwner(OreResourceEntity newOwner)
	{
		owner = newOwner;
	}

	public override void ServerInit()
	{
		base.ServerInit();
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (!base.isClient && Object.op_Implicit((Object)(object)owner))
		{
			owner.OnAttacked(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		FireFinishEffect();
		base.OnDied(info);
	}

	public void FireFinishEffect()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (finishEffect.isValid)
		{
			Effect.server.Run(finishEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.forward);
		}
	}
}


using UnityEngine;

public class PlacementTest : MonoBehaviour
{
	public MeshCollider myMeshCollider;

	public Transform testTransform;

	public Transform visualTest;

	public float hemisphere = 45f;

	public float clampTest = 45f;

	public float testDist = 2f;

	private float nextTest;

	public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		degreesOffset = Mathf.Clamp(degreesOffset / 180f, -180f, 180f);
		Vector2 insideUnitCircle = Random.insideUnitCircle;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(insideUnitCircle.x * degreesOffset, Random.Range(-1f, 1f) * degreesOffset, insideUnitCircle.y * degreesOffset);
		Vector3 val2 = input + val;
		return ((Vector3)(ref val2)).normalized;
	}

	public Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight = 0f, float maxHeight = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Vector2 insideUnitCircle = Random.insideUnitCircle;
		Vector3 val = new Vector3(insideUnitCircle.x, 0f, insideUnitCircle.y);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return new Vector3(normalized.x * distance, Random.Range(minHeight, maxHeight), normalized.z * distance);
	}

	public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		degreesOffset = Mathf.Clamp(degreesOffset / 180f, -180f, 180f);
		Vector3 val = hemiInput + Vector3.one * degreesOffset;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = hemiInput + Vector3.one * (0f - degreesOffset);
		Vector3 normalized2 = ((Vector3)(ref val)).normalized;
		for (int i = 0; i < 3; i++)
		{
			((Vector3)(ref inputVec))[i] = Mathf.Clamp(((Vector3)(ref inputVec))[i], ((Vector3)(ref normalized2))[i], ((Vector3)(ref normalized))[i]);
		}
		return ((Vector3)(ref inputVec)).normalized;
	}

	private void Update()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		if (Time.realtimeSinceStartup < nextTest)
		{
			return;
		}
		nextTest = Time.realtimeSinceStartup + 0f;
		Vector3 val = RandomCylinderPointAroundVector(Vector3.up, 0.5f, 0.25f, 0.5f);
		val = ((Component)this).transform.TransformPoint(val);
		((Component)testTransform).transform.position = val;
		if ((Object)(object)testTransform != (Object)null && (Object)(object)visualTest != (Object)null)
		{
			Vector3 position = ((Component)this).transform.position;
			MeshCollider obj = myMeshCollider;
			Vector3 position2 = testTransform.position;
			Vector3 val2 = ((Component)this).transform.position - testTransform.position;
			RaycastHit val3 = default(RaycastHit);
			if (((Collider)obj).Raycast(new Ray(position2, ((Vector3)(ref val2)).normalized), ref val3, 5f))
			{
				position = ((RaycastHit)(ref val3)).point;
			}
			else
			{
				Debug.LogError((object)"Missed");
			}
			((Component)visualTest).transform.position = position;
		}
	}

	public void OnDrawGizmos()
	{
	}
}


public class ItemModParachute : ItemModBackpack
{
	public GameObjectRef ParachuteVehiclePrefab;
}


