using System;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;

[CompilerGenerated]
[Embedded]
[AttributeUsage(AttributeTargets.Module, AllowMultiple = false, Inherited = false)]
internal sealed class RefSafetyRulesAttribute : Attribute
{
	public readonly int Version;

	public RefSafetyRulesAttribute(int P_0)
	{
		Version = P_0;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class SuppressGCTransitionAttribute : Attribute
{
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class UnmanagedCallersOnlyAttribute : Attribute
{
	public Type[]? CallConvs;

	public string? EntryPoint;
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class WasmImportLinkageAttribute : Attribute
{
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Struct, AllowMultiple = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class InlineArrayAttribute : Attribute
{
	public int Length { get; }

	public InlineArrayAttribute(int length)
	{
		Length = length;
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Module | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface | AttributeTargets.Delegate, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class RequiresPreviewFeaturesAttribute : Attribute
{
	public string? Message { get; }

	public string? Url { get; set; }

	public RequiresPreviewFeaturesAttribute()
	{
	}

	public RequiresPreviewFeaturesAttribute(string? message)
	{
		Message = message;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Module | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface, AllowMultiple = true, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class ObsoletedOSPlatformAttribute : Attribute
{
	public string? Message { get; }

	public string? Url { get; set; }

	public ObsoletedOSPlatformAttribute(string platformName)
	{
	}

	public ObsoletedOSPlatformAttribute(string platformName, string? message)
	{
		Message = message;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Module | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface, AllowMultiple = true, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class SupportedOSPlatformAttribute : Attribute
{
	public SupportedOSPlatformAttribute(string platformName)
	{
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class SupportedOSPlatformGuardAttribute : Attribute
{
	public SupportedOSPlatformGuardAttribute(string platformName)
	{
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class TargetPlatformAttribute : Attribute
{
	public TargetPlatformAttribute(string platformName)
	{
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Module | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface, AllowMultiple = true, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class UnsupportedOSPlatformAttribute : Attribute
{
	public string? Message { get; }

	public UnsupportedOSPlatformAttribute(string platformName)
	{
	}

	public UnsupportedOSPlatformAttribute(string platformName, string? message)
	{
		Message = message;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class UnsupportedOSPlatformGuardAttribute : Attribute
{
	public UnsupportedOSPlatformGuardAttribute(string platformName)
	{
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Method | AttributeTargets.Interface | AttributeTargets.Delegate, Inherited = false, AllowMultiple = false)]
[ExcludeFromCodeCoverage]
public sealed class AsyncMethodBuilderAttribute : Attribute
{
	public Type BuilderType { get; }

	public AsyncMethodBuilderAttribute(Type builderType)
	{
		BuilderType = builderType;
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class CallerArgumentExpressionAttribute : Attribute
{
	public string ParameterName { get; }

	public CallerArgumentExpressionAttribute(string parameterName)
	{
		ParameterName = parameterName;
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class CollectionBuilderAttribute : Attribute
{
	public Type BuilderType { get; }

	public string MethodName { get; }

	public CollectionBuilderAttribute(Type builderType, string methodName)
	{
		BuilderType = builderType;
		MethodName = methodName;
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class CompilerFeatureRequiredAttribute : Attribute
{
	public const string RefStructs = "RefStructs";

	public const string RequiredMembers = "RequiredMembers";

	public string FeatureName { get; }

	public bool IsOptional { get; set; }

	public CompilerFeatureRequiredAttribute(string featureName)
	{
		FeatureName = featureName;
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class InterpolatedStringHandlerArgumentAttribute : Attribute
{
	public string[] Arguments { get; }

	public InterpolatedStringHandlerArgumentAttribute(string argument)
	{
		Arguments = new string[1] { argument };
	}

	public InterpolatedStringHandlerArgumentAttribute(params string[] arguments)
	{
		Arguments = arguments;
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class InterpolatedStringHandlerAttribute : Attribute
{
}


using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;

[EditorBrowsable(EditorBrowsableState.Never)]
[ExcludeFromCodeCoverage]
public static class IsExternalInit
{
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class ModuleInitializerAttribute : Attribute
{
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class OverloadResolutionPriorityAttribute : Attribute
{
	public int Priority { get; }

	public OverloadResolutionPriorityAttribute(int priority)
	{
		Priority = priority;
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Parameter, Inherited = true, AllowMultiple = false)]
[ExcludeFromCodeCoverage]
public sealed class ParamCollectionAttribute : Attribute
{
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class RequiredMemberAttribute : Attribute
{
}


using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
[EditorBrowsable(EditorBrowsableState.Never)]
[ExcludeFromCodeCoverage]
public sealed class RequiresLocationAttribute : Attribute
{
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Module | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Event | AttributeTargets.Interface, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class SkipLocalsInitAttribute : Attribute
{
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Assembly, Inherited = false, AllowMultiple = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class DisableRuntimeMarshallingAttribute : Attribute
{
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class UnsafeAccessorAttribute : Attribute
{
	public UnsafeAccessorKind Kind { get; }

	public string? Name { get; set; }

	public UnsafeAccessorAttribute(UnsafeAccessorKind kind)
	{
		Kind = kind;
	}
}


public enum UnsafeAccessorKind
{
	Constructor,
	Method,
	StaticMethod,
	Field,
	StaticField
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class DebuggerDisableUserUnhandledExceptionsAttribute : Attribute
{
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Constructor | AttributeTargets.Method, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class StackTraceHiddenAttribute : Attribute
{
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class ConstantExpectedAttribute : Attribute
{
	public object? Min { get; set; }

	public object? Max { get; set; }
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Module | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface | AttributeTargets.Delegate, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class ExperimentalAttribute : Attribute
{
	public string DiagnosticId { get; }

	public string? UrlFormat { get; set; }

	public ExperimentalAttribute(string diagnosticId)
	{
		DiagnosticId = diagnosticId;
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
[ExcludeFromCodeCoverage]
public sealed class MemberNotNullAttribute : Attribute
{
	public string[] Members { get; }

	public MemberNotNullAttribute(string member)
	{
		Members = new string[1] { member };
	}

	public MemberNotNullAttribute(params string[] members)
	{
		Members = members;
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
[ExcludeFromCodeCoverage]
public sealed class MemberNotNullWhenAttribute : Attribute
{
	public bool ReturnValue { get; }

	public string[] Members { get; }

	public MemberNotNullWhenAttribute(bool returnValue, string member)
	{
		ReturnValue = returnValue;
		Members = new string[1] { member };
	}

	public MemberNotNullWhenAttribute(bool returnValue, params string[] members)
	{
		ReturnValue = returnValue;
		Members = members;
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class SetsRequiredMembersAttribute : Attribute
{
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class StringSyntaxAttribute : Attribute
{
	public const string CompositeFormat = "CompositeFormat";

	public const string DateOnlyFormat = "DateOnlyFormat";

	public const string DateTimeFormat = "DateTimeFormat";

	public const string EnumFormat = "EnumFormat";

	public const string GuidFormat = "GuidFormat";

	public const string Json = "Json";

	public const string NumericFormat = "NumericFormat";

	public const string Regex = "Regex";

	public const string TimeOnlyFormat = "TimeOnlyFormat";

	public const string TimeSpanFormat = "TimeSpanFormat";

	public const string Uri = "Uri";

	public const string Xml = "Xml";

	public string Syntax { get; }

	public object?[] Arguments { get; }

	public StringSyntaxAttribute(string syntax)
	{
		Syntax = syntax;
		Arguments = new object[0];
	}

	public StringSyntaxAttribute(string syntax, params object?[] arguments)
	{
		Syntax = syntax;
		Arguments = arguments;
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
[ExcludeFromCodeCoverage]
public sealed class UnscopedRefAttribute : Attribute
{
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class DynamicallyAccessedMembersAttribute : Attribute
{
	public DynamicallyAccessedMemberTypes MemberTypes { get; }

	public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes)
	{
		MemberTypes = memberTypes;
	}
}


using System;

[Flags]
public enum DynamicallyAccessedMemberTypes
{
	None = 0,
	PublicParameterlessConstructor = 1,
	PublicConstructors = 3,
	NonPublicConstructors = 4,
	PublicMethods = 8,
	NonPublicMethods = 0x10,
	PublicFields = 0x20,
	NonPublicFields = 0x40,
	PublicNestedTypes = 0x80,
	NonPublicNestedTypes = 0x100,
	PublicProperties = 0x200,
	NonPublicProperties = 0x400,
	PublicEvents = 0x800,
	NonPublicEvents = 0x1000,
	Interfaces = 0x2000,
	All = -1
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Field, AllowMultiple = true, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class DynamicDependencyAttribute : Attribute
{
	public string? MemberSignature { get; }

	public DynamicallyAccessedMemberTypes MemberTypes { get; }

	public Type? Type { get; }

	public string? TypeName { get; }

	public string? AssemblyName { get; }

	public string? Condition { get; set; }

	public DynamicDependencyAttribute(string memberSignature)
	{
		MemberSignature = memberSignature;
	}

	public DynamicDependencyAttribute(string memberSignature, Type type)
	{
		MemberSignature = memberSignature;
		Type = type;
	}

	public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName)
	{
		MemberSignature = memberSignature;
		TypeName = typeName;
		AssemblyName = assemblyName;
	}

	public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type)
	{
		MemberTypes = memberTypes;
		Type = type;
	}

	public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName)
	{
		MemberTypes = memberTypes;
		TypeName = typeName;
		AssemblyName = assemblyName;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class FeatureGuardAttribute : Attribute
{
	public Type FeatureType { get; }

	public FeatureGuardAttribute(Type featureType)
	{
		FeatureType = featureType;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Property, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class FeatureSwitchDefinitionAttribute : Attribute
{
	public string SwitchName { get; }

	public FeatureSwitchDefinitionAttribute(string switchName)
	{
		SwitchName = switchName;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Event, Inherited = false, AllowMultiple = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class RequiresAssemblyFilesAttribute : Attribute
{
	public string? Message { get; }

	public string? Url { get; set; }

	public RequiresAssemblyFilesAttribute()
	{
	}

	public RequiresAssemblyFilesAttribute(string message)
	{
		Message = message;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Constructor | AttributeTargets.Method, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class RequiresDynamicCodeAttribute : Attribute
{
	public string Message { get; }

	public string? Url { get; set; }

	public RequiresDynamicCodeAttribute(string message)
	{
		Message = message;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Constructor | AttributeTargets.Method, Inherited = false)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class RequiresUnreferencedCodeAttribute : Attribute
{
	public string Message { get; }

	public string? Url { get; set; }

	public RequiresUnreferencedCodeAttribute(string message)
	{
		Message = message;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]
[ExcludeFromCodeCoverage]
[Conditional("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
public sealed class UnconditionalSuppressMessageAttribute : Attribute
{
	public string Category { get; }

	public string CheckId { get; }

	public string? Scope { get; set; }

	public string? Target { get; set; }

	public string? MessageId { get; set; }

	public string? Justification { get; set; }

	public UnconditionalSuppressMessageAttribute(string category, string checkId)
	{
		Category = category;
		CheckId = checkId;
	}
}


using System;

public static class EnvironmentHelper
{
	public const string SECTION_DELIMITER = ":";

	public const string OXIDE_PREFIX = "OXIDE_";

	public static string GetVariable(string key)
	{
		return Environment.GetEnvironmentVariable(NormalizeKey(key));
	}

	public static void SetVariable(string key, string value, bool throwOnExisting = false, bool force = false)
	{
		key = NormalizeKey(key);
		string text = ((!force) ? Environment.GetEnvironmentVariable(key) : null);
		if (text != null)
		{
			if (throwOnExisting)
			{
				throw new InvalidOperationException("'" + key + "' has existing value of '" + text + "' to override set 'force' to 'true'");
			}
		}
		else
		{
			Environment.SetEnvironmentVariable(key, value);
		}
	}

	private static string NormalizeKey(string key)
	{
		key = key.Trim();
		if (string.IsNullOrEmpty(key))
		{
			return null;
		}
		key = (key.StartsWith("OXIDE_", StringComparison.InvariantCultureIgnoreCase) ? ("OXIDE_" + key.Substring(6)) : ("OXIDE_" + key));
		return key.Replace(":", "__").ToUpperInvariant();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public static class ExtensionMethods
{
	public static AssemblyMetadataAttribute[] Metadata(this Assembly assembly)
	{
		return Attribute.GetCustomAttributes(assembly, typeof(AssemblyMetadataAttribute), inherit: false) as AssemblyMetadataAttribute[];
	}

	public static string[] Metadata(this Assembly assembly, string key)
	{
		return (from meta in Metadata(assembly)
			where meta.Key.Equals(key, StringComparison.InvariantCultureIgnoreCase)
			select meta.Value).ToArray();
	}

	public static HashSet<T> ToHashSet<T>(this IEnumerable<T> collection)
	{
		HashSet<T> hashSet = new HashSet<T>();
		foreach (T item in collection)
		{
			hashSet.Add(item);
		}
		return hashSet;
	}

	public static bool TryPop<T>(this Stack<T> stack, out T value)
	{
		if (stack.Count > 0)
		{
			value = stack.Pop();
			return true;
		}
		value = default(T);
		return false;
	}

	public static bool TryPeek<T>(this Stack<T> stack, out T value)
	{
		if (stack.Count > 0)
		{
			value = stack.Peek();
			return true;
		}
		value = default(T);
		return false;
	}

	public static bool TryDequeue<T>(this Queue<T> queue, out T value)
	{
		if (queue.Count > 0)
		{
			value = queue.Dequeue();
			return true;
		}
		value = default(T);
		return false;
	}

	public static bool TryPeek<T>(this Queue<T> queue, out T value)
	{
		if (queue.Count > 0)
		{
			value = queue.Peek();
			return true;
		}
		value = default(T);
		return false;
	}
}


using Oxide.Pooling;

public interface IArrayPoolProvider<out T> : IPoolProvider<T[]>, IPoolProvider
{
	T[] Take(int length);
}


using System;
using Oxide.Pooling;

public interface IPoolFactory
{
	IPoolProvider<T> GetProvider<T>();

	bool IsHandledType<T>();

	IDisposable RegisterProvider<TProvider>(out TProvider provider, params object[] args) where TProvider : IPoolProvider;
}


public interface IPoolProvider
{
	void Return(object item);
}


using Oxide.Pooling;

public interface IPoolProvider<out T> : IPoolProvider
{
	T Take();
}


using System;
using Oxide.Pooling;

public static class PoolingExtensions
{
	public static IArrayPoolProvider<T> GetArrayProvider<T>(this IPoolFactory factory)
	{
		return factory.GetProvider<T[]>() as IArrayPoolProvider<T>;
	}

	public static T[] PooledCopy<T>(this IArrayPoolProvider<T> provider, T[] source, int offset, int count)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		T[] array = provider?.Take(count) ?? throw new ArgumentNullException("provider");
		try
		{
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = source[offset];
				offset++;
			}
			return array;
		}
		catch
		{
			provider.Return(array);
			throw;
		}
	}

	public static T[] PooledCopy<T>(this IPoolFactory factory, T[] source, int offset, int count)
	{
		if (factory == null)
		{
			throw new ArgumentNullException("factory");
		}
		return (factory.GetProvider<T[]>() as IArrayPoolProvider<T>).PooledCopy(source, offset, count);
	}
}


