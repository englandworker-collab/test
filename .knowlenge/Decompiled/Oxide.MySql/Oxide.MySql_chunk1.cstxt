using System;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Extensions;
using Oxide.Core.Libraries;
using Oxide.Core.MySql.Libraries;

public class MySqlExtension : Extension
{
	internal static Assembly Assembly = Assembly.GetExecutingAssembly();

	internal static AssemblyName AssemblyName = Assembly.GetName();

	internal static VersionNumber AssemblyVersion = new VersionNumber(AssemblyName.Version.Major, AssemblyName.Version.Minor, AssemblyName.Version.Build);

	internal static string AssemblyAuthors = ((AssemblyCompanyAttribute)Attribute.GetCustomAttribute(Assembly, typeof(AssemblyCompanyAttribute), inherit: false)).Company;

	public override bool IsCoreExtension => true;

	public override string Name => "MySql";

	public override string Author => AssemblyAuthors;

	public override VersionNumber Version => AssemblyVersion;

	public MySqlExtension(ExtensionManager manager)
		: base(manager)
	{
	}

	public override void Load()
	{
		((Extension)this).Manager.RegisterLibrary("MySql", (Library)(object)new MySql());
	}

	public override void LoadPluginWatchers(string pluginDirectory)
	{
	}

	public override void OnModLoad()
	{
	}
}


using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading;
using MySqlConnector;
using Oxide.Core;
using Oxide.Core.Database;
using Oxide.Core.Libraries;
using Oxide.Core.MySql.Libraries;
using Oxide.Core.Plugins;

public class MySql : Library, IDatabaseProvider
{
	public class MySqlQuery
	{
		private MySqlCommand _cmd;

		private MySqlConnection _connection;

		public Action<List<Dictionary<string, object>>> Callback { get; internal set; }

		public Action<int> CallbackNonQuery { get; internal set; }

		public Sql Sql { get; internal set; }

		public Connection Connection { get; internal set; }

		public bool NonQuery { get; internal set; }

		private void Cleanup()
		{
			if (_cmd != null)
			{
				_cmd.Dispose();
				_cmd = null;
			}
			_connection = null;
		}

		public bool Handle()
		{
			//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
			List<Dictionary<string, object>> list = null;
			int nonQueryResult = 0;
			long lastInsertRowId = 0L;
			try
			{
				if (Connection == null)
				{
					throw new Exception("Connection is null");
				}
				_connection = (MySqlConnection)Connection.Con;
				if (_connection.State == ConnectionState.Closed)
				{
					_connection.Open();
				}
				_cmd = _connection.CreateCommand();
				_cmd.CommandTimeout = 120;
				_cmd.CommandText = Sql.SQL;
				Sql.AddParams((IDbCommand)_cmd, Sql.Arguments, "@");
				if (NonQuery)
				{
					nonQueryResult = _cmd.ExecuteNonQuery();
				}
				else
				{
					using MySqlDataReader mySqlDataReader = _cmd.ExecuteReader();
					list = new List<Dictionary<string, object>>();
					while (mySqlDataReader.Read() && (!Connection.ConnectionPersistent || (Connection.Con.State != 0 && Connection.Con.State != ConnectionState.Broken)))
					{
						Dictionary<string, object> dictionary = new Dictionary<string, object>();
						for (int i = 0; i < mySqlDataReader.FieldCount; i++)
						{
							dictionary.Add(mySqlDataReader.GetName(i), mySqlDataReader.GetValue(i));
						}
						list.Add(dictionary);
					}
				}
				lastInsertRowId = _cmd.LastInsertedId;
				Cleanup();
			}
			catch (Exception ex)
			{
				string text = "MySql handle raised an exception";
				Connection connection = Connection;
				if (((connection != null) ? connection.Plugin : null) != null)
				{
					text += $" in '{Connection.Plugin.Name} v{Connection.Plugin.Version}' plugin";
				}
				Interface.Oxide.LogException(text, ex);
				Cleanup();
			}
			Interface.Oxide.NextTick((Action)delegate
			{
				//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
				Connection connection2 = Connection;
				if (connection2 != null)
				{
					Plugin plugin = connection2.Plugin;
					if (plugin != null)
					{
						plugin.TrackStart();
					}
				}
				try
				{
					if (Connection != null)
					{
						Connection.LastInsertRowId = lastInsertRowId;
					}
					if (!NonQuery)
					{
						Callback(list);
					}
					else
					{
						CallbackNonQuery?.Invoke(nonQueryResult);
					}
				}
				catch (Exception ex2)
				{
					string text2 = "MySql command callback raised an exception";
					Connection connection3 = Connection;
					if (((connection3 != null) ? connection3.Plugin : null) != null)
					{
						text2 += $" in '{Connection.Plugin.Name} v{Connection.Plugin.Version}' plugin";
					}
					Interface.Oxide.LogException(text2, ex2);
				}
				Connection connection4 = Connection;
				if (connection4 != null)
				{
					Plugin plugin2 = connection4.Plugin;
					if (plugin2 != null)
					{
						plugin2.TrackEnd();
					}
				}
			});
			return true;
		}
	}

	private readonly Queue<MySqlQuery> _queue = new Queue<MySqlQuery>();

	private readonly object _syncroot = new object();

	private readonly AutoResetEvent _workevent = new AutoResetEvent(initialState: false);

	private readonly HashSet<Connection> _runningConnections = new HashSet<Connection>();

	private readonly Dictionary<string, Dictionary<string, Connection>> _connections = new Dictionary<string, Dictionary<string, Connection>>();

	private readonly Thread _worker;

	private readonly Dictionary<Plugin, Callback<Plugin, PluginManager>> _pluginRemovedFromManager;

	private bool _running = true;

	public override bool IsGlobal => false;

	public MySql()
	{
		_pluginRemovedFromManager = new Dictionary<Plugin, Callback<Plugin, PluginManager>>();
		_worker = new Thread(Worker);
		_worker.Start();
	}

	private void Worker()
	{
		while (_running || _queue.Count > 0)
		{
			MySqlQuery mySqlQuery = null;
			lock (_syncroot)
			{
				if (_queue.Count > 0)
				{
					mySqlQuery = _queue.Dequeue();
				}
				else
				{
					foreach (Connection runningConnection in _runningConnections)
					{
						if (runningConnection != null && !runningConnection.ConnectionPersistent)
						{
							CloseDb(runningConnection);
						}
					}
					_runningConnections.Clear();
				}
			}
			if (mySqlQuery != null)
			{
				mySqlQuery.Handle();
				if (mySqlQuery.Connection != null)
				{
					_runningConnections.Add(mySqlQuery.Connection);
				}
			}
			else if (_running)
			{
				_workevent.WaitOne();
			}
		}
	}

	[LibraryFunction("OpenDb")]
	public Connection OpenDb(string host, int port, string database, string user, string password, Plugin plugin, bool persistent = false)
	{
		return OpenDb($"Server={host};Port={port};Database={database};User={user};Password={password};Pooling=false;default command timeout=120;Allow Zero Datetime=true;SslMode=Disabled;AllowPublicKeyRetrieval=true;CharSet=utf8mb4;", plugin, persistent);
	}

	public Connection OpenDb(string conStr, Plugin plugin, bool persistent = false)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Expected O, but got Unknown
		if (!_connections.TryGetValue(((plugin != null) ? plugin.Name : null) ?? "null", out var value))
		{
			value = (_connections[((plugin != null) ? plugin.Name : null) ?? "null"] = new Dictionary<string, Connection>());
		}
		if (value.TryGetValue(conStr, out var value2))
		{
			Interface.Oxide.LogWarning("There is already an open connection, using existing connection instead...", Array.Empty<object>());
		}
		else
		{
			Connection val = new Connection(conStr, persistent)
			{
				Plugin = plugin,
				Con = new MySqlConnection(conStr)
			};
			value2 = (value[conStr] = val);
		}
		if (plugin != null && !_pluginRemovedFromManager.ContainsKey(plugin))
		{
			_pluginRemovedFromManager[plugin] = ((Event<Plugin, PluginManager>)(object)plugin.OnRemovedFromManager).Add((Action<Plugin, PluginManager>)OnRemovedFromManager);
		}
		return value2;
	}

	private void OnRemovedFromManager(Plugin sender, PluginManager manager)
	{
		if (_connections.TryGetValue(sender.Name, out var value))
		{
			foreach (KeyValuePair<string, Connection> item in value)
			{
				if (item.Value.Plugin == sender)
				{
					DbConnection con = item.Value.Con;
					if (con == null || con.State != 0)
					{
						Interface.Oxide.LogWarning("Unclosed MySQL connection from plugin '{0}', closing...", new object[1] { sender.Name });
					}
					item.Value.Con?.Close();
					item.Value.Plugin = null;
				}
			}
			_connections.Remove(sender.Name);
		}
		if (_pluginRemovedFromManager.TryGetValue(sender, out var value2))
		{
			value2.Remove();
			_pluginRemovedFromManager.Remove(sender);
		}
	}

	[LibraryFunction("CloseDb")]
	public void CloseDb(Connection db)
	{
		if (db == null)
		{
			return;
		}
		Dictionary<string, Dictionary<string, Connection>> connections = _connections;
		Plugin plugin = db.Plugin;
		if (connections.TryGetValue(((plugin != null) ? plugin.Name : null) ?? "null", out var value))
		{
			value.Remove(db.ConnectionString);
			if (value.Count == 0)
			{
				Dictionary<string, Dictionary<string, Connection>> connections2 = _connections;
				Plugin plugin2 = db.Plugin;
				connections2.Remove(((plugin2 != null) ? plugin2.Name : null) ?? "null");
				if (db.Plugin != null && _pluginRemovedFromManager.TryGetValue(db.Plugin, out var value2))
				{
					value2.Remove();
					_pluginRemovedFromManager.Remove(db.Plugin);
				}
			}
		}
		db.Con?.Close();
		db.Plugin = null;
	}

	[LibraryFunction("NewSql")]
	public Sql NewSql()
	{
		return Sql.Builder;
	}

	[LibraryFunction("Query")]
	public void Query(Sql sql, Connection db, Action<List<Dictionary<string, object>>> callback)
	{
		MySqlQuery item = new MySqlQuery
		{
			Sql = sql,
			Connection = db,
			Callback = callback
		};
		lock (_syncroot)
		{
			_queue.Enqueue(item);
		}
		_workevent.Set();
	}

	[LibraryFunction("ExecuteNonQuery")]
	public void ExecuteNonQuery(Sql sql, Connection db, Action<int> callback = null)
	{
		MySqlQuery item = new MySqlQuery
		{
			Sql = sql,
			Connection = db,
			CallbackNonQuery = callback,
			NonQuery = true
		};
		lock (_syncroot)
		{
			_queue.Enqueue(item);
		}
		_workevent.Set();
	}

	[LibraryFunction("Insert")]
	public void Insert(Sql sql, Connection db, Action<int> callback = null)
	{
		ExecuteNonQuery(sql, db, callback);
	}

	[LibraryFunction("Update")]
	public void Update(Sql sql, Connection db, Action<int> callback = null)
	{
		ExecuteNonQuery(sql, db, callback);
	}

	[LibraryFunction("Delete")]
	public void Delete(Sql sql, Connection db, Action<int> callback = null)
	{
		ExecuteNonQuery(sql, db, callback);
	}

	public override void Shutdown()
	{
		_running = false;
		_workevent.Set();
		_worker.Join();
	}
}


using System;
using System.Collections.Generic;
using System.Data;
using MySqlConnector;
using Oxide.Core.Database;
using Oxide.Core.Plugins;

public class MySqlQuery
{
	private MySqlCommand _cmd;

	private MySqlConnection _connection;

	public Action<List<Dictionary<string, object>>> Callback { get; internal set; }

	public Action<int> CallbackNonQuery { get; internal set; }

	public Sql Sql { get; internal set; }

	public Connection Connection { get; internal set; }

	public bool NonQuery { get; internal set; }

	private void Cleanup()
	{
		if (_cmd != null)
		{
			_cmd.Dispose();
			_cmd = null;
		}
		_connection = null;
	}

	public bool Handle()
	{
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		List<Dictionary<string, object>> list = null;
		int nonQueryResult = 0;
		long lastInsertRowId = 0L;
		try
		{
			if (Connection == null)
			{
				throw new Exception("Connection is null");
			}
			_connection = (MySqlConnection)Connection.Con;
			if (_connection.State == ConnectionState.Closed)
			{
				_connection.Open();
			}
			_cmd = _connection.CreateCommand();
			_cmd.CommandTimeout = 120;
			_cmd.CommandText = Sql.SQL;
			Sql.AddParams((IDbCommand)_cmd, Sql.Arguments, "@");
			if (NonQuery)
			{
				nonQueryResult = _cmd.ExecuteNonQuery();
			}
			else
			{
				using MySqlDataReader mySqlDataReader = _cmd.ExecuteReader();
				list = new List<Dictionary<string, object>>();
				while (mySqlDataReader.Read() && (!Connection.ConnectionPersistent || (Connection.Con.State != 0 && Connection.Con.State != ConnectionState.Broken)))
				{
					Dictionary<string, object> dictionary = new Dictionary<string, object>();
					for (int i = 0; i < mySqlDataReader.FieldCount; i++)
					{
						dictionary.Add(mySqlDataReader.GetName(i), mySqlDataReader.GetValue(i));
					}
					list.Add(dictionary);
				}
			}
			lastInsertRowId = _cmd.LastInsertedId;
			Cleanup();
		}
		catch (Exception ex)
		{
			string text = "MySql handle raised an exception";
			Connection connection = Connection;
			if (((connection != null) ? connection.Plugin : null) != null)
			{
				text += $" in '{Connection.Plugin.Name} v{Connection.Plugin.Version}' plugin";
			}
			Interface.Oxide.LogException(text, ex);
			Cleanup();
		}
		Interface.Oxide.NextTick((Action)delegate
		{
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			Connection connection2 = Connection;
			if (connection2 != null)
			{
				Plugin plugin = connection2.Plugin;
				if (plugin != null)
				{
					plugin.TrackStart();
				}
			}
			try
			{
				if (Connection != null)
				{
					Connection.LastInsertRowId = lastInsertRowId;
				}
				if (!NonQuery)
				{
					Callback(list);
				}
				else
				{
					CallbackNonQuery?.Invoke(nonQueryResult);
				}
			}
			catch (Exception ex2)
			{
				string text2 = "MySql command callback raised an exception";
				Connection connection3 = Connection;
				if (((connection3 != null) ? connection3.Plugin : null) != null)
				{
					text2 += $" in '{Connection.Plugin.Name} v{Connection.Plugin.Version}' plugin";
				}
				Interface.Oxide.LogException(text2, ex2);
			}
			Connection connection4 = Connection;
			if (connection4 != null)
			{
				Plugin plugin2 = connection4.Plugin;
				if (plugin2 != null)
				{
					plugin2.TrackEnd();
				}
			}
		});
		return true;
	}
}


using MySqlConnector;
using Oxide.Core.Plugins;

public sealed class Connection
{
	internal string ConnectionString { get; set; }

	internal bool ConnectionPersistent { get; set; }

	internal MySqlConnection Con { get; set; }

	internal Plugin Plugin { get; set; }

	public long LastInsertRowId { get; internal set; }

	public Connection(string connection, bool persistent)
	{
		ConnectionString = connection;
		ConnectionPersistent = persistent;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using Oxide.Ext.MySql;

public class Sql
{
	public class SqlJoinClause
	{
		private readonly Sql _sql;

		public SqlJoinClause(Sql sql)
		{
			_sql = sql;
		}

		public Sql On(string onClause, params object[] args)
		{
			return _sql.Append("ON " + onClause, args);
		}
	}

	private static readonly Regex Filter = new Regex("LOAD\\s*DATA|INTO\\s*(OUTFILE|DUMPFILE)|LOAD_FILE", RegexOptions.IgnoreCase | RegexOptions.Compiled);

	private static readonly Regex RxParams = new Regex("(?<!@)@\\w+", RegexOptions.Compiled);

	private readonly object[] _args;

	private readonly string _sql;

	private object[] _argsFinal;

	private Sql _rhs;

	private string _sqlFinal;

	public static Sql Builder => new Sql();

	public string SQL
	{
		get
		{
			Build();
			return _sqlFinal;
		}
	}

	public object[] Arguments
	{
		get
		{
			Build();
			return _argsFinal;
		}
	}

	public Sql()
	{
	}

	public Sql(string sql, params object[] args)
	{
		_sql = sql;
		_args = args;
	}

	private void Build()
	{
		if (_sqlFinal == null)
		{
			StringBuilder stringBuilder = new StringBuilder();
			List<object> list = new List<object>();
			Build(stringBuilder, list, null);
			string text = stringBuilder.ToString();
			if (Filter.IsMatch(text))
			{
				throw new Exception("Commands LOAD DATA, LOAD_FILE, OUTFILE, DUMPFILE not allowed.");
			}
			_sqlFinal = text;
			_argsFinal = list.ToArray();
		}
	}

	public Sql Append(Sql sql)
	{
		if (_rhs != null)
		{
			_rhs.Append(sql);
		}
		else
		{
			_rhs = sql;
		}
		return this;
	}

	public Sql Append(string sql, params object[] args)
	{
		return Append(new Sql(sql, args));
	}

	private static bool Is(Sql sql, string sqltype)
	{
		if (sql != null && sql._sql != null)
		{
			return sql._sql.StartsWith(sqltype, StringComparison.InvariantCultureIgnoreCase);
		}
		return false;
	}

	private void Build(StringBuilder sb, List<object> args, Sql lhs)
	{
		if (!string.IsNullOrEmpty(_sql))
		{
			if (sb.Length > 0)
			{
				sb.Append("\n");
			}
			string text = ProcessParams(_sql, _args, args);
			if (Is(lhs, "WHERE ") && Is(this, "WHERE "))
			{
				text = "AND " + text.Substring(6);
			}
			if (Is(lhs, "ORDER BY ") && Is(this, "ORDER BY "))
			{
				text = ", " + text.Substring(9);
			}
			sb.Append(text);
		}
		_rhs?.Build(sb, args, this);
	}

	public Sql Where(string sql, params object[] args)
	{
		return Append(new Sql("WHERE (" + sql + ")", args));
	}

	public Sql OrderBy(params object[] columns)
	{
		return Append(new Sql("ORDER BY " + string.Join(", ", columns.Select((object x) => x.ToString()).ToArray())));
	}

	public Sql Select(params object[] columns)
	{
		return Append(new Sql("SELECT " + string.Join(", ", columns.Select((object x) => x.ToString()).ToArray())));
	}

	public Sql From(params object[] tables)
	{
		return Append(new Sql("FROM " + string.Join(", ", tables.Select((object x) => x.ToString()).ToArray())));
	}

	public Sql GroupBy(params object[] columns)
	{
		return Append(new Sql("GROUP BY " + string.Join(", ", columns.Select((object x) => x.ToString()).ToArray())));
	}

	private SqlJoinClause Join(string joinType, string table)
	{
		return new SqlJoinClause(Append(new Sql(joinType + table)));
	}

	public SqlJoinClause InnerJoin(string table)
	{
		return Join("INNER JOIN ", table);
	}

	public SqlJoinClause LeftJoin(string table)
	{
		return Join("LEFT JOIN ", table);
	}

	public static string ProcessParams(string sql, object[] argsSrc, List<object> argsDest)
	{
		return RxParams.Replace(sql, delegate(Match m)
		{
			string text = m.Value.Substring(1);
			object obj;
			if (int.TryParse(text, out var result))
			{
				if (result < 0 || result >= argsSrc.Length)
				{
					throw new ArgumentOutOfRangeException($"Parameter '@{result}' specified but only {argsSrc.Length} parameters supplied (in `{sql}`)");
				}
				obj = argsSrc[result];
			}
			else
			{
				bool flag = false;
				obj = null;
				object[] array = argsSrc;
				foreach (object obj2 in array)
				{
					PropertyInfo property = obj2.GetType().GetProperty(text);
					if (!(property == null))
					{
						obj = property.GetValue(obj2, null);
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					throw new ArgumentException("Parameter '@" + text + "' specified but none of the passed arguments have a property with this name (in '" + sql + "')");
				}
			}
			if (obj is IEnumerable && !(obj is string) && !(obj is byte[]))
			{
				StringBuilder stringBuilder = new StringBuilder();
				foreach (object item in obj as IEnumerable)
				{
					stringBuilder.Append(((stringBuilder.Length == 0) ? "@" : ",@") + argsDest.Count);
					argsDest.Add(item);
				}
				return stringBuilder.ToString();
			}
			argsDest.Add(obj);
			return "@" + (argsDest.Count - 1);
		});
	}

	public static void AddParams(IDbCommand cmd, object[] items, string parameterPrefix)
	{
		foreach (object item in items)
		{
			AddParam(cmd, item, "@");
		}
	}

	public static void AddParam(IDbCommand cmd, object item, string parameterPrefix)
	{
		if (item is IDbDataParameter dbDataParameter)
		{
			dbDataParameter.ParameterName = $"{parameterPrefix}{cmd.Parameters.Count}";
			cmd.Parameters.Add(dbDataParameter);
			return;
		}
		IDbDataParameter dbDataParameter2 = cmd.CreateParameter();
		dbDataParameter2.ParameterName = $"{parameterPrefix}{cmd.Parameters.Count}";
		if (item == null)
		{
			dbDataParameter2.Value = DBNull.Value;
		}
		else
		{
			Type type = item.GetType();
			if (type.IsEnum)
			{
				dbDataParameter2.Value = (int)item;
			}
			else if (type == typeof(Guid))
			{
				dbDataParameter2.Value = item.ToString();
				dbDataParameter2.DbType = DbType.String;
				dbDataParameter2.Size = 40;
			}
			else if (type == typeof(string))
			{
				dbDataParameter2.Size = Math.Max(((string)item).Length + 1, 4000);
				dbDataParameter2.Value = item;
			}
			else if (type == typeof(bool))
			{
				dbDataParameter2.Value = (((bool)item) ? 1 : 0);
			}
			else
			{
				dbDataParameter2.Value = item;
			}
		}
		cmd.Parameters.Add(dbDataParameter2);
	}
}


public class SqlJoinClause
{
	private readonly Sql _sql;

	public SqlJoinClause(Sql sql)
	{
		_sql = sql;
	}

	public Sql On(string onClause, params object[] args)
	{
		return _sql.Append("ON " + onClause, args);
	}
}


using System;
using System.Net;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Text;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class UnixDomainSocketEndPoint : EndPoint
{
	public string Filename { get; }

	public override AddressFamily AddressFamily => AddressFamily.Unix;

	public UnixDomainSocketEndPoint(string filename)
	{
		if (filename == null)
		{
			throw new ArgumentNullException("filename");
		}
		if (filename.Length == 0)
		{
			throw new ArgumentException("Cannot be empty.", "filename");
		}
		Filename = filename;
	}

	private UnixDomainSocketEndPoint()
	{
		Filename = "";
	}

	public override EndPoint Create(SocketAddress socketAddress)
	{
		if (socketAddress.Size == 2)
		{
			return new UnixDomainSocketEndPoint();
		}
		int num = socketAddress.Size - 2;
		byte[] array = new byte[num];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = socketAddress[i + 2];
			if (array[i] == 0)
			{
				num = i;
				break;
			}
		}
		return new UnixDomainSocketEndPoint(Encoding.UTF8.GetString(array, 0, num));
	}

	public override SocketAddress Serialize()
	{
		byte[] bytes = Encoding.UTF8.GetBytes(Filename);
		SocketAddress socketAddress = new SocketAddress(AddressFamily, 2 + bytes.Length + 1);
		for (int i = 0; i < bytes.Length; i++)
		{
			socketAddress[2 + i] = bytes[i];
		}
		socketAddress[2 + bytes.Length] = 0;
		return socketAddress;
	}

	public override string ToString()
	{
		return Filename;
	}

	public override int GetHashCode()
	{
		return Filename.GetHashCode();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public override bool Equals(object obj)
	{
		if (obj is UnixDomainSocketEndPoint unixDomainSocketEndPoint)
		{
			return Filename == unixDomainSocketEndPoint.Filename;
		}
		return false;
	}
}


using System;
using System.Data.Common;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal abstract class DbDataSource : IDisposable
{
	public abstract string ConnectionString { get; }

	public DbConnection CreateConnection()
	{
		return CreateDbConnection();
	}

	public DbConnection OpenConnection()
	{
		return OpenDbConnection();
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public ValueTask<DbConnection> OpenConnectionAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return OpenDbConnectionAsync(cancellationToken);
	}

	public DbCommand CreateCommand([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string commandText = null)
	{
		return CreateDbCommand(commandText);
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	public async ValueTask DisposeAsync()
	{
		await DisposeAsyncCore().ConfigureAwait(continueOnCapturedContext: false);
		Dispose(disposing: false);
		GC.SuppressFinalize(this);
	}

	protected abstract DbConnection CreateDbConnection();

	protected virtual DbConnection OpenDbConnection()
	{
		DbConnection dbConnection = CreateDbConnection();
		try
		{
			dbConnection.Open();
			return dbConnection;
		}
		catch
		{
			dbConnection.Dispose();
			throw;
		}
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	protected virtual async ValueTask<DbConnection> OpenDbConnectionAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		DbConnection connection = CreateDbConnection();
		try
		{
			await connection.OpenAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return connection;
		}
		catch
		{
			connection.Dispose();
			throw;
		}
	}

	protected virtual DbCommand CreateDbCommand([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string commandText = null)
	{
		throw new NotSupportedException();
	}

	protected virtual void Dispose(bool disposing)
	{
	}

	protected virtual ValueTask DisposeAsyncCore()
	{
		return default(ValueTask);
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public sealed class MySqlAttribute : ICloneable
{
	public string AttributeName { get; set; } = attributeName ?? "";

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public object Value
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		set;
	}

	public MySqlAttribute(string attributeName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] object value)
	{
		Value = value;
		base..ctor();
	}

	public MySqlAttribute()
		: this("", null)
	{
	}

	public MySqlAttribute Clone()
	{
		return new MySqlAttribute(AttributeName, Value);
	}

	object ICloneable.Clone()
	{
		return Clone();
	}

	internal MySqlParameter ToParameter()
	{
		if (string.IsNullOrEmpty(AttributeName))
		{
			throw new InvalidOperationException("AttributeName must not be null or empty");
		}
		return new MySqlParameter(AttributeName, Value);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public sealed class MySqlAttributeCollection : IEnumerable<MySqlAttribute>, IEnumerable
{
	private readonly List<MySqlAttribute> m_attributes;

	public int Count => m_attributes.Count;

	public MySqlAttribute this[int index] => m_attributes[index];

	public void Add(MySqlAttribute attribute)
	{
		if (attribute == null)
		{
			throw new ArgumentNullException("attribute");
		}
		if (string.IsNullOrEmpty(attribute.AttributeName))
		{
			throw new ArgumentException("Attribute name must not be empty", "attribute");
		}
		foreach (MySqlAttribute attribute2 in m_attributes)
		{
			if (attribute2.AttributeName == attribute.AttributeName)
			{
				throw new ArgumentException("An attribute with the name " + attribute.AttributeName + " already exists in the collection", "attribute");
			}
		}
		m_attributes.Add(attribute);
	}

	public void SetAttribute(string attributeName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] object value)
	{
		if (string.IsNullOrEmpty(attributeName))
		{
			throw new ArgumentException("Attribute name must not be empty", "attributeName");
		}
		for (int i = 0; i < m_attributes.Count; i++)
		{
			if (m_attributes[i].AttributeName == attributeName)
			{
				m_attributes[i] = new MySqlAttribute(attributeName, value);
				return;
			}
		}
		m_attributes.Add(new MySqlAttribute(attributeName, value));
	}

	public void Clear()
	{
		m_attributes.Clear();
	}

	public IEnumerator<MySqlAttribute> GetEnumerator()
	{
		return m_attributes.GetEnumerator();
	}

	public bool Remove(MySqlAttribute attribute)
	{
		return m_attributes.Remove(attribute);
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	internal MySqlAttributeCollection()
	{
		m_attributes = new List<MySqlAttribute>();
	}
}


using System;
using System.Data;
using System.Data.Common;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
public sealed class MySqlBatch : ICancellableCommand, IDisposable
{
	private readonly int m_commandId;

	private bool m_isDisposed;

	private int m_timeout;

	private Action m_cancelAction;

	private Action m_cancelForCommandTimeoutAction;

	private uint m_cancelTimerId;

	private bool m_commandTimedOut;

	public MySqlConnection Connection { get; set; }

	public MySqlTransaction Transaction { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public MySqlBatchCommandCollection BatchCommands
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get;
	}

	public int Timeout
	{
		get
		{
			return m_timeout;
		}
		set
		{
			m_timeout = value;
			((ICancellableCommand)this).EffectiveCommandTimeout = null;
		}
	}

	internal CommandBehavior CurrentCommandBehavior { get; set; }

	int ICancellableCommand.CommandId => m_commandId;

	int ICancellableCommand.CommandTimeout => Timeout;

	int? ICancellableCommand.EffectiveCommandTimeout { get; set; }

	int ICancellableCommand.CancelAttemptCount { get; set; }

	bool ICancellableCommand.IsTimedOut => Volatile.Read(in m_commandTimedOut);

	private bool IsPrepared
	{
		get
		{
			foreach (MySqlBatchCommand batchCommand in BatchCommands)
			{
				if (Connection.Session.TryGetPreparedStatement(batchCommand.CommandText) == null)
				{
					return false;
				}
			}
			return true;
		}
	}

	private IOBehavior AsyncIOBehavior => Connection?.AsyncIOBehavior ?? IOBehavior.Asynchronous;

	public MySqlBatch()
		: this(null, null)
	{
	}

	public MySqlBatch(MySqlConnection connection = null, MySqlTransaction transaction = null)
	{
		Connection = connection;
		Transaction = transaction;
		BatchCommands = new MySqlBatchCommandCollection();
		m_commandId = ICancellableCommandExtensions.GetNextId();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public MySqlDataReader ExecuteReader(CommandBehavior commandBehavior = CommandBehavior.Default)
	{
		return (MySqlDataReader)ExecuteDbDataReader(commandBehavior);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public async Task<MySqlDataReader> ExecuteReaderAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return (MySqlDataReader)(await ExecuteDbDataReaderAsync(CommandBehavior.Default, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	private DbDataReader ExecuteDbDataReader(CommandBehavior behavior)
	{
		this.ResetCommandTimeout();
		return ExecuteReaderAsync(behavior, IOBehavior.Synchronous, CancellationToken.None).Result;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	private async Task<DbDataReader> ExecuteDbDataReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken)
	{
		this.ResetCommandTimeout();
		using (((ICancellableCommand)this).RegisterCancel(cancellationToken))
		{
			return await ExecuteReaderAsync(behavior, AsyncIOBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	private ValueTask<MySqlDataReader> ExecuteReaderAsync(CommandBehavior behavior, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (!IsValid(out var exception))
		{
			return ValueTaskExtensions.FromException<MySqlDataReader>(exception);
		}
		CurrentCommandBehavior = behavior;
		foreach (MySqlBatchCommand batchCommand in BatchCommands)
		{
			batchCommand.Batch = this;
		}
		ICommandPayloadCreator payloadCreator = (IsPrepared ? SingleCommandPayloadCreator.Instance : ConcatenatedCommandPayloadCreator.Instance);
		return CommandExecutor.ExecuteReaderAsync(new CommandListPosition(BatchCommands.Commands), payloadCreator, behavior, null, ioBehavior, cancellationToken);
	}

	public int ExecuteNonQuery()
	{
		return ExecuteNonQueryAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	public object ExecuteScalar()
	{
		return ExecuteScalarAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public Task<int> ExecuteNonQueryAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return ExecuteNonQueryAsync(AsyncIOBehavior, cancellationToken);
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
	public Task<object> ExecuteScalarAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return ExecuteScalarAsync(AsyncIOBehavior, cancellationToken);
	}

	public void Prepare()
	{
		if (!NeedsPrepare(out var exception))
		{
			if (exception != null)
			{
				throw exception;
			}
		}
		else
		{
			DoPrepareAsync(IOBehavior.Synchronous, default(CancellationToken)).GetAwaiter().GetResult();
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public Task PrepareAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return PrepareAsync(AsyncIOBehavior, cancellationToken);
	}

	public void Cancel()
	{
		Connection?.Cancel(this, m_commandId, isCancel: true);
	}

	public void Dispose()
	{
		m_isDisposed = true;
	}

	CancellationTokenRegistration ICancellableCommand.RegisterCancel(CancellationToken cancellationToken)
	{
		if (!cancellationToken.CanBeCanceled)
		{
			return default(CancellationTokenRegistration);
		}
		if (m_cancelAction == null)
		{
			m_cancelAction = Cancel;
		}
		return cancellationToken.Register(m_cancelAction);
	}

	void ICancellableCommand.SetTimeout(int milliseconds)
	{
		Volatile.Write(ref m_commandTimedOut, value: false);
		if (m_cancelTimerId != 0)
		{
			TimerQueue.Instance.Remove(m_cancelTimerId);
		}
		if (milliseconds != int.MaxValue)
		{
			if (m_cancelForCommandTimeoutAction == null)
			{
				m_cancelForCommandTimeoutAction = CancelCommandForTimeout;
			}
			m_cancelTimerId = TimerQueue.Instance.Add(milliseconds, m_cancelForCommandTimeoutAction);
		}
	}

	private void CancelCommandForTimeout()
	{
		Volatile.Write(ref m_commandTimedOut, value: true);
		Cancel();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	private async Task<int> ExecuteNonQueryAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		this.ResetCommandTimeout();
		using (((ICancellableCommand)this).RegisterCancel(cancellationToken))
		{
			using MySqlDataReader reader = await ExecuteReaderAsync(CommandBehavior.Default, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			while (await reader.ReadAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) || await reader.NextResultAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
			{
			}
			return reader.RecordsAffected;
		}
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
	private async Task<object> ExecuteScalarAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		this.ResetCommandTimeout();
		using (((ICancellableCommand)this).RegisterCancel(cancellationToken))
		{
			bool hasSetResult = false;
			object result = null;
			using MySqlDataReader reader = await ExecuteReaderAsync(CommandBehavior.Default, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			do
			{
				bool flag = await reader.ReadAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (!hasSetResult)
				{
					if (flag)
					{
						result = reader.GetValue(0);
					}
					hasSetResult = true;
				}
			}
			while (await reader.NextResultAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
			return result;
		}
	}

	private bool IsValid([<e940fe46-60b5-4fb7-817f-6effabbc4d82>NotNullWhen(false)] out Exception exception)
	{
		if (m_isDisposed)
		{
			exception = new ObjectDisposedException(GetType().Name);
		}
		else if (Connection == null)
		{
			exception = new InvalidOperationException("Connection property must be non-null.");
		}
		else
		{
			ConnectionState state = Connection.State;
			if (state != ConnectionState.Open && state != ConnectionState.Connecting)
			{
				exception = new InvalidOperationException($"Connection must be Open; current state is {Connection.State}");
			}
			else if (!Connection.IgnoreCommandTransaction && Transaction != Connection.CurrentTransaction)
			{
				exception = new InvalidOperationException("The transaction associated with this batch is not the connection's active transaction; see https://fl.vu/mysql-trans");
			}
			else if (BatchCommands.Count == 0)
			{
				exception = new InvalidOperationException("BatchCommands must contain a command");
			}
			else
			{
				exception = GetExceptionForInvalidCommands();
			}
		}
		return exception == null;
	}

	private bool NeedsPrepare(out Exception exception)
	{
		if (m_isDisposed)
		{
			exception = new ObjectDisposedException(GetType().Name);
		}
		else if (Connection == null)
		{
			exception = new InvalidOperationException("Connection property must be non-null.");
		}
		else if (Connection.State != ConnectionState.Open)
		{
			exception = new InvalidOperationException($"Connection must be Open; current state is {Connection.State}");
		}
		else if (BatchCommands.Count == 0)
		{
			exception = new InvalidOperationException("BatchCommands must contain a command");
		}
		else if (Connection.HasActiveReader)
		{
			exception = new InvalidOperationException("Cannot call Prepare when there is an open DataReader for this command; it must be closed first.");
		}
		else
		{
			exception = GetExceptionForInvalidCommands();
		}
		if (exception == null)
		{
			return !Connection.IgnorePrepare;
		}
		return false;
	}

	private InvalidOperationException GetExceptionForInvalidCommands()
	{
		foreach (MySqlBatchCommand batchCommand in BatchCommands)
		{
			if (batchCommand == null)
			{
				return new InvalidOperationException("BatchCommands must not contain null");
			}
			if (string.IsNullOrWhiteSpace(batchCommand.CommandText))
			{
				return new InvalidOperationException("CommandText must be specified on each batch command");
			}
		}
		return null;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	private Task PrepareAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (!NeedsPrepare(out var exception))
		{
			if (exception != null)
			{
				return Task.FromException(exception);
			}
			return Task.CompletedTask;
		}
		return DoPrepareAsync(ioBehavior, cancellationToken);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	private async Task DoPrepareAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		foreach (MySqlBatchCommand batchCommand in BatchCommands)
		{
			if (((IMySqlCommand)batchCommand).CommandType != CommandType.Text)
			{
				throw new NotSupportedException("Only CommandType.Text is currently supported by MySqlBatch.Prepare");
			}
			batchCommand.Batch = this;
			if (Connection.Session.TryGetPreparedStatement(((IMySqlCommand)batchCommand).CommandText) == null)
			{
				await Connection.Session.PrepareAsync(batchCommand, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
		}
	}
}


using System.Data;
using System.Data.Common;
using System.Runtime.CompilerServices;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using MySqlConnector.Core;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlBatchCommand : IMySqlCommand
{
	private MySqlParameterCollection m_parameterCollection;

	private long m_lastInsertedId;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public string CommandText
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		set;
	}

	public CommandType CommandType { get; set; }

	public int RecordsAffected => 0;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public MySqlParameterCollection Parameters
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get
		{
			return m_parameterCollection ?? (m_parameterCollection = new MySqlParameterCollection());
		}
	}

	public bool CanCreateParameter => true;

	bool IMySqlCommand.AllowUserVariables => false;

	CommandBehavior IMySqlCommand.CommandBehavior => Batch.CurrentCommandBehavior;

	MySqlParameterCollection IMySqlCommand.RawParameters => m_parameterCollection;

	MySqlAttributeCollection IMySqlCommand.RawAttributes => null;

	MySqlConnection IMySqlCommand.Connection => Batch?.Connection;

	long IMySqlCommand.LastInsertedId => m_lastInsertedId;

	MySqlParameterCollection IMySqlCommand.OutParameters { get; set; }

	MySqlParameter IMySqlCommand.ReturnParameter { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	ICancellableCommand IMySqlCommand.CancellableCommand
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get
		{
			return Batch;
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	ILogger IMySqlCommand.Logger
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get
		{
			return Batch.Connection.LoggingConfiguration.CommandLogger;
		}
	}

	internal MySqlBatch Batch { get; set; }

	public MySqlBatchCommand()
		: this(null)
	{
	}

	public MySqlBatchCommand(string commandText)
	{
		CommandText = commandText ?? "";
		CommandType = CommandType.Text;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public DbParameter CreateParameter()
	{
		return new MySqlParameter();
	}

	PreparedStatements IMySqlCommand.TryGetPreparedStatements()
	{
		return null;
	}

	void IMySqlCommand.SetLastInsertedId(long lastInsertedId)
	{
		m_lastInsertedId = lastInsertedId;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public sealed class MySqlBatchCommandCollection : IList<MySqlBatchCommand>, ICollection<MySqlBatchCommand>, IEnumerable<MySqlBatchCommand>, IEnumerable
{
	private readonly List<MySqlBatchCommand> m_commands;

	public MySqlBatchCommand this[int index]
	{
		get
		{
			return m_commands[index];
		}
		set
		{
			m_commands[index] = value;
		}
	}

	public int Count => m_commands.Count;

	public bool IsReadOnly => false;

	internal IReadOnlyList<MySqlBatchCommand> Commands => m_commands;

	internal MySqlBatchCommandCollection()
	{
		m_commands = new List<MySqlBatchCommand>();
	}

	public void Add(MySqlBatchCommand item)
	{
		m_commands.Add(item);
	}

	public void Clear()
	{
		m_commands.Clear();
	}

	public bool Contains(MySqlBatchCommand item)
	{
		return m_commands.Contains(item);
	}

	public void CopyTo(MySqlBatchCommand[] array, int arrayIndex)
	{
		throw new NotImplementedException();
	}

	public IEnumerator<MySqlBatchCommand> GetEnumerator()
	{
		foreach (MySqlBatchCommand command in m_commands)
		{
			yield return command;
		}
	}

	public int IndexOf(MySqlBatchCommand item)
	{
		return m_commands.IndexOf(item);
	}

	public void Insert(int index, MySqlBatchCommand item)
	{
		m_commands.Insert(index, item);
	}

	public bool Remove(MySqlBatchCommand item)
	{
		return m_commands.Remove(item);
	}

	public void RemoveAt(int index)
	{
		m_commands.RemoveAt(index);
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Buffers;
using System.Buffers.Text;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Data;
using System.Data.Common;
using System.Globalization;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Logging;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlBulkCopy
{
	private static readonly char[] s_specialCharacters = new char[3] { '\t', '\\', '\n' };

	private static readonly UTF8Encoding s_utf8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true);

	private readonly MySqlConnection m_connection;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private readonly MySqlTransaction m_transaction;

	private readonly ILogger m_logger;

	private int m_rowsCopied;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private IValuesEnumerator m_valuesEnumerator;

	private bool m_wasAborted;

	public MySqlBulkLoaderConflictOption ConflictOption { get; set; }

	public int BulkCopyTimeout { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public string DestinationTableName
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		set;
	}

	public int NotifyAfter { get; set; }

	public List<MySqlBulkCopyColumnMapping> ColumnMappings { get; }

	[Obsolete("Use the MySqlBulkCopyResult.RowsInserted property returned by WriteToServer.")]
	public int RowsCopied => m_rowsCopied;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[method: <31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public event MySqlRowsCopiedEventHandler MySqlRowsCopied;

	public MySqlBulkCopy(MySqlConnection connection, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] MySqlTransaction transaction = null)
	{
		if (connection == null)
		{
			throw new ArgumentNullException("connection");
		}
		m_connection = connection;
		m_transaction = transaction;
		m_logger = m_connection.LoggingConfiguration.BulkCopyLogger;
		ColumnMappings = new List<MySqlBulkCopyColumnMapping>();
	}

	public MySqlBulkCopyResult WriteToServer(DataTable dataTable)
	{
		if (dataTable == null)
		{
			throw new ArgumentNullException("dataTable");
		}
		m_valuesEnumerator = DataRowsValuesEnumerator.Create(dataTable);
		return WriteToServerAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public async ValueTask<MySqlBulkCopyResult> WriteToServerAsync(DataTable dataTable, CancellationToken cancellationToken = default(CancellationToken))
	{
		if (dataTable == null)
		{
			throw new ArgumentNullException("dataTable");
		}
		m_valuesEnumerator = DataRowsValuesEnumerator.Create(dataTable);
		return await WriteToServerAsync(IOBehavior.Asynchronous, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	public MySqlBulkCopyResult WriteToServer(IEnumerable<DataRow> dataRows, int columnCount)
	{
		if (dataRows == null)
		{
			throw new ArgumentNullException("dataRows");
		}
		m_valuesEnumerator = new DataRowsValuesEnumerator(dataRows, columnCount);
		return WriteToServerAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public async ValueTask<MySqlBulkCopyResult> WriteToServerAsync(IEnumerable<DataRow> dataRows, int columnCount, CancellationToken cancellationToken = default(CancellationToken))
	{
		if (dataRows == null)
		{
			throw new ArgumentNullException("dataRows");
		}
		m_valuesEnumerator = new DataRowsValuesEnumerator(dataRows, columnCount);
		return await WriteToServerAsync(IOBehavior.Asynchronous, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	public MySqlBulkCopyResult WriteToServer(IDataReader dataReader)
	{
		if (dataReader == null)
		{
			throw new ArgumentNullException("dataReader");
		}
		m_valuesEnumerator = DataReaderValuesEnumerator.Create(dataReader);
		return WriteToServerAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public async ValueTask<MySqlBulkCopyResult> WriteToServerAsync(IDataReader dataReader, CancellationToken cancellationToken = default(CancellationToken))
	{
		if (dataReader == null)
		{
			throw new ArgumentNullException("dataReader");
		}
		m_valuesEnumerator = DataReaderValuesEnumerator.Create(dataReader);
		return await WriteToServerAsync(IOBehavior.Asynchronous, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	private async ValueTask<MySqlBulkCopyResult> WriteToServerAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		string tableName = DestinationTableName ?? throw new InvalidOperationException("DestinationTableName must be set before calling WriteToServer");
		m_wasAborted = false;
		Log.StartingBulkCopy(m_logger, tableName);
		MySqlBulkLoader bulkLoader = new MySqlBulkLoader(m_connection)
		{
			CharacterSet = "utf8mb4",
			EscapeCharacter = '\\',
			FieldQuotationCharacter = '\0',
			FieldTerminator = "\t",
			LinePrefix = null,
			LineTerminator = "\n",
			Local = true,
			NumberOfLinesToSkip = 0,
			Source = this,
			TableName = tableName,
			Timeout = BulkCopyTimeout,
			ConflictOption = ConflictOption
		};
		bool closeConnection = false;
		if (m_connection.State != ConnectionState.Open)
		{
			m_connection.Open();
			closeConnection = true;
		}
		List<MySqlBulkCopyColumnMapping> columnMappings2 = new List<MySqlBulkCopyColumnMapping>(ColumnMappings);
		bool addDefaultMappings2 = columnMappings2.Count == 0;
		using (MySqlCommand cmd = new MySqlCommand("select * from " + tableName + ";", m_connection, m_transaction))
		{
			using MySqlDataReader mySqlDataReader = await cmd.ExecuteReaderAsync(CommandBehavior.SchemaOnly, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ReadOnlyCollection<DbColumn> columnSchema = mySqlDataReader.GetColumnSchema();
			for (int i = 0; i < Math.Min(m_valuesEnumerator.FieldCount, columnSchema.Count); i++)
			{
				string name = mySqlDataReader.GetName(i);
				if (columnSchema[i].DataTypeName == "BIT")
				{
					AddColumnMapping(m_logger, columnMappings2, addDefaultMappings2, i, name, $"@`\ue002\bcol{i}`", "%COL% = CAST(%VAR% AS UNSIGNED)");
					continue;
				}
				if (columnSchema[i].DataTypeName == "YEAR")
				{
					throw new NotSupportedException("'YEAR' columns are not supported by MySqlBulkLoader.");
				}
				Type dataType = columnSchema[i].DataType;
				bool flag = dataType == typeof(byte[]);
				if (!flag)
				{
					bool flag2 = dataType == typeof(Guid);
					if (flag2)
					{
						MySqlGuidFormat guidFormat = m_connection.GuidFormat;
						bool flag3 = (uint)(guidFormat - 4) <= 2u;
						flag2 = flag3;
					}
					flag = flag2;
				}
				if (flag)
				{
					AddColumnMapping(m_logger, columnMappings2, addDefaultMappings2, i, name, $"@`\ue002\bcol{i}`", "%COL% = UNHEX(%VAR%)");
				}
				else if (addDefaultMappings2)
				{
					Log.AddingDefaultColumnMapping(m_logger, i, name);
					columnMappings2.Add(new MySqlBulkCopyColumnMapping(i, name));
				}
			}
		}
		int j;
		for (j = 0; j < m_valuesEnumerator.FieldCount; j++)
		{
			MySqlBulkCopyColumnMapping mySqlBulkCopyColumnMapping = columnMappings2.FirstOrDefault([<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)] (MySqlBulkCopyColumnMapping x) => x.SourceOrdinal == j);
			if (mySqlBulkCopyColumnMapping == null)
			{
				Log.IgnoringColumn(m_logger, j);
				bulkLoader.Columns.Add("@`\ue002\bignore`");
				continue;
			}
			if (mySqlBulkCopyColumnMapping.DestinationColumn.Length == 0)
			{
				throw new InvalidOperationException($"MySqlBulkCopyColumnMapping.DestinationName is not set for SourceOrdinal {mySqlBulkCopyColumnMapping.SourceOrdinal}");
			}
			if (mySqlBulkCopyColumnMapping.DestinationColumn[0] == '@' && mySqlBulkCopyColumnMapping.Expression != null)
			{
				bulkLoader.Columns.Add(mySqlBulkCopyColumnMapping.DestinationColumn);
			}
			else
			{
				bulkLoader.Columns.Add(QuoteIdentifier(mySqlBulkCopyColumnMapping.DestinationColumn));
			}
			if (mySqlBulkCopyColumnMapping.Expression != null)
			{
				bulkLoader.Expressions.Add(mySqlBulkCopyColumnMapping.Expression);
			}
		}
		foreach (MySqlBulkCopyColumnMapping item in columnMappings2)
		{
			if (item.SourceOrdinal < 0 || item.SourceOrdinal >= m_valuesEnumerator.FieldCount)
			{
				throw new InvalidOperationException($"SourceOrdinal {item.SourceOrdinal} is an invalid value");
			}
		}
		List<MySqlError> errors = new List<MySqlError>();
		MySqlInfoMessageEventHandler infoMessageHandler = delegate(object s, MySqlInfoMessageEventArgs e)
		{
			errors.AddRange(e.Errors);
		};
		m_connection.InfoMessage += infoMessageHandler;
		int num;
		try
		{
			num = await bulkLoader.LoadAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		finally
		{
			m_connection.InfoMessage -= infoMessageHandler;
		}
		if (closeConnection)
		{
			m_connection.Close();
		}
		Log.FinishedBulkCopy(m_logger, tableName);
		if (!m_wasAborted && num != m_rowsCopied && ConflictOption == MySqlBulkLoaderConflictOption.None)
		{
			Log.BulkCopyFailed(m_logger, tableName, m_rowsCopied, num);
			throw new MySqlException(MySqlErrorCode.BulkCopyFailed, string.Format("{0} row{1} copied to {2} but only {3} {4} inserted.", m_rowsCopied, (m_rowsCopied == 1) ? " was" : "s were", tableName, num, (num == 1) ? "was" : "were"));
		}
		return new MySqlBulkCopyResult(errors, num);
		static void AddColumnMapping(ILogger logger, List<MySqlBulkCopyColumnMapping> columnMappings, bool addDefaultMappings, int destinationOrdinal, string destinationColumn, string variableName, string expression)
		{
			expression = expression.Replace("%COL%", "`" + destinationColumn + "`").Replace("%VAR%", variableName);
			MySqlBulkCopyColumnMapping mySqlBulkCopyColumnMapping2 = columnMappings.FirstOrDefault([<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)] (MySqlBulkCopyColumnMapping x) => destinationColumn.Equals(x.DestinationColumn, StringComparison.OrdinalIgnoreCase));
			if (mySqlBulkCopyColumnMapping2 != null)
			{
				if (mySqlBulkCopyColumnMapping2.Expression != null)
				{
					Log.ColumnMappingAlreadyHasExpression(logger, mySqlBulkCopyColumnMapping2.SourceOrdinal, destinationColumn, mySqlBulkCopyColumnMapping2.Expression);
				}
				else
				{
					Log.SettingExpressionToMapColumn(logger, mySqlBulkCopyColumnMapping2.SourceOrdinal, destinationColumn, expression);
					columnMappings.Remove(mySqlBulkCopyColumnMapping2);
					columnMappings.Add(new MySqlBulkCopyColumnMapping(mySqlBulkCopyColumnMapping2.SourceOrdinal, variableName, expression));
				}
			}
			else if (addDefaultMappings)
			{
				Log.AddingDefaultColumnMapping(logger, destinationOrdinal, destinationColumn);
				columnMappings.Add(new MySqlBulkCopyColumnMapping(destinationOrdinal, variableName, expression));
			}
		}
		static string QuoteIdentifier(string identifier)
		{
			return "`" + identifier.Replace("`", "``") + "`";
		}
	}

	internal async Task SendDataReaderAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		byte[] buffer = ArrayPool<byte>.Shared.Rent(1048576);
		int outputIndex = 0;
		m_rowsCopied = 0;
		MySqlRowsCopiedEventArgs eventArgs = null;
		if (NotifyAfter > 0 && this.MySqlRowsCopied != null)
		{
			eventArgs = new MySqlRowsCopiedEventArgs();
		}
		try
		{
			object[] values = new object[m_valuesEnumerator.FieldCount];
			Encoder utf8Encoder2 = null;
			while ((ioBehavior != IOBehavior.Asynchronous) ? m_valuesEnumerator.MoveNext() : (await m_valuesEnumerator.MoveNextAsync().ConfigureAwait(continueOnCapturedContext: false)))
			{
				m_valuesEnumerator.GetValues(values);
				for (int valueIndex = 0; valueIndex < values.Length; valueIndex++)
				{
					if (valueIndex > 0)
					{
						buffer[outputIndex++] = 9;
					}
					int inputIndex2 = 0;
					int bytesWritten2 = 0;
					while (true)
					{
						if (outputIndex < 1048575)
						{
							MySqlConnection connection2 = m_connection;
							object value2 = values[valueIndex];
							Span<byte> span = MemoryExtensions.AsSpan(buffer, 0, 1048575);
							int num = outputIndex;
							if (WriteValue(connection2, value2, ref inputIndex2, ref utf8Encoder2, span.Slice(num, span.Length - num), out bytesWritten2))
							{
								break;
							}
						}
						PayloadData payload = new PayloadData(new ArraySegment<byte>(buffer, 0, outputIndex + bytesWritten2));
						await m_connection.Session.SendReplyAsync(payload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						outputIndex = 0;
						bytesWritten2 = 0;
					}
					outputIndex += bytesWritten2;
				}
				buffer[outputIndex++] = 10;
				m_rowsCopied++;
				if (eventArgs != null && m_rowsCopied % NotifyAfter == 0)
				{
					eventArgs.RowsCopied = m_rowsCopied;
					this.MySqlRowsCopied(this, eventArgs);
					if (eventArgs.Abort)
					{
						break;
					}
				}
			}
			if (outputIndex != 0 && ((!(eventArgs?.Abort)) ?? true))
			{
				PayloadData payload2 = new PayloadData(new ArraySegment<byte>(buffer, 0, outputIndex));
				await m_connection.Session.SendReplyAsync(payload2, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
		}
		finally
		{
			ArrayPool<byte>.Shared.Return(buffer);
			m_wasAborted = eventArgs?.Abort ?? false;
		}
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
		static bool WriteBytes(ReadOnlySpan<byte> value, ref int inputIndex, Span<byte> output, out int bytesWritten)
		{
			ReadOnlySpan<byte> readOnlySpan2 = "0123456789ABCDEF"u8;
			bytesWritten = 0;
			while (inputIndex < value.Length && output.Length > 2)
			{
				byte b = value[inputIndex];
				output[0] = readOnlySpan2[(b >> 4) & 0xF];
				output[1] = readOnlySpan2[b & 0xF];
				output = output.Slice(2, output.Length - 2);
				bytesWritten += 2;
				inputIndex++;
			}
			return inputIndex == value.Length;
		}
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
		static bool WriteString([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] string value, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] ref Encoder utf8Encoder, Span<byte> output, out int bytesWritten)
		{
			int inputIndex3 = 0;
			if (WriteSubstring(value, ref inputIndex3, ref utf8Encoder, output, out bytesWritten))
			{
				return true;
			}
			bytesWritten = 0;
			return false;
		}
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
		static bool WriteSubstring([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] string value, ref int inputIndex, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] ref Encoder utf8Encoder, Span<byte> output, out int bytesWritten)
		{
			bytesWritten = 0;
			while (inputIndex < value.Length)
			{
				if (Array.IndexOf(s_specialCharacters, value[inputIndex]) != -1)
				{
					if (output.Length <= 2)
					{
						return false;
					}
					output[0] = 92;
					output[1] = (byte)value[inputIndex];
					ref Span<byte> reference = ref output;
					output = reference.Slice(2, reference.Length - 2);
					bytesWritten += 2;
					inputIndex++;
				}
				else
				{
					int num4 = value.IndexOfAny(s_specialCharacters, inputIndex);
					if (num4 == -1)
					{
						num4 = value.Length;
					}
					if (utf8Encoder == null)
					{
						utf8Encoder = s_utf8Encoding.GetEncoder();
					}
					if (output.Length < 4 && utf8Encoder.GetByteCount(MemoryExtensions.AsSpan(value, inputIndex, Math.Min(2, num4 - inputIndex)), flush: false) > output.Length)
					{
						return false;
					}
					utf8Encoder.Convert(MemoryExtensions.AsSpan(value, inputIndex, num4 - inputIndex), output, num4 == value.Length, out var charsUsed, out var bytesUsed, out var completed);
					bytesWritten += bytesUsed;
					ref Span<byte> reference = ref output;
					int num5 = bytesUsed;
					output = reference.Slice(num5, reference.Length - num5);
					inputIndex += charsUsed;
					if (!completed)
					{
						return false;
					}
				}
			}
			return true;
		}
		static bool WriteValue(MySqlConnection connection, object value, ref int inputIndex, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] ref Encoder utf8Encoder, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] Span<byte> output, out int bytesWritten)
		{
			if (output.Length == 0)
			{
				bytesWritten = 0;
				return false;
			}
			if (value == null || value == DBNull.Value)
			{
				ReadOnlySpan<byte> readOnlySpan = "\\N"u8;
				if (output.Length < readOnlySpan.Length)
				{
					bytesWritten = 0;
					return false;
				}
				readOnlySpan.CopyTo(output);
				bytesWritten = readOnlySpan.Length;
				return true;
			}
			if (value is string value3)
			{
				return WriteSubstring(value3, ref inputIndex, ref utf8Encoder, output, out bytesWritten);
			}
			if (value is char c)
			{
				return WriteString(c.ToString(), ref utf8Encoder, output, out bytesWritten);
			}
			if (value is byte value4)
			{
				return Utf8Formatter.TryFormat(value4, output, out bytesWritten);
			}
			if (value is sbyte value5)
			{
				return Utf8Formatter.TryFormat(value5, output, out bytesWritten);
			}
			if (value is short value6)
			{
				return Utf8Formatter.TryFormat(value6, output, out bytesWritten);
			}
			if (value is ushort value7)
			{
				return Utf8Formatter.TryFormat(value7, output, out bytesWritten);
			}
			if (value is int value8)
			{
				return Utf8Formatter.TryFormat(value8, output, out bytesWritten);
			}
			if (value is uint value9)
			{
				return Utf8Formatter.TryFormat(value9, output, out bytesWritten);
			}
			if (value is long value10)
			{
				return Utf8Formatter.TryFormat(value10, output, out bytesWritten);
			}
			if (value is ulong value11)
			{
				return Utf8Formatter.TryFormat(value11, output, out bytesWritten);
			}
			if (value is decimal value12)
			{
				return Utf8Formatter.TryFormat(value12, output, out bytesWritten);
			}
			if ((value is byte[] || value is ReadOnlyMemory<byte> || value is Memory<byte> || value is ArraySegment<byte> || value is MySqlGeometry) ? true : false)
			{
				ReadOnlySpan<byte> value13 = ((value is byte[] array) ? ((ReadOnlySpan<byte>)MemoryExtensions.AsSpan(array)) : ((value is ArraySegment<byte> segment) ? ((ReadOnlySpan<byte>)MemoryExtensions.AsSpan(segment)) : ((value is Memory<byte> memory) ? ((ReadOnlySpan<byte>)memory.Span) : ((!(value is MySqlGeometry mySqlGeometry)) ? ((ReadOnlyMemory<byte>)value).Span : mySqlGeometry.ValueSpan))));
				return WriteBytes(value13, ref inputIndex, output, out bytesWritten);
			}
			if (value is bool flag)
			{
				if (output.Length < 1)
				{
					bytesWritten = 0;
					return false;
				}
				output[0] = (byte)(flag ? 49 : 48);
				bytesWritten = 1;
				return true;
			}
			if (value is float num2)
			{
				return WriteString(num2.ToString("R", CultureInfo.InvariantCulture), ref utf8Encoder, output, out bytesWritten);
			}
			if (value is double num3)
			{
				return WriteString(num3.ToString("R", CultureInfo.InvariantCulture), ref utf8Encoder, output, out bytesWritten);
			}
			if (value is MySqlDateTime mySqlDateTime)
			{
				if (mySqlDateTime.IsValidDateTime)
				{
					return WriteString(mySqlDateTime.GetDateTime().ToString("yyyy'-'MM'-'dd' 'HH':'mm':'ss'.'ffffff", CultureInfo.InvariantCulture), ref utf8Encoder, output, out bytesWritten);
				}
				return WriteString("0000-00-00", ref utf8Encoder, output, out bytesWritten);
			}
			if (value is DateTime dateTime)
			{
				if (connection.DateTimeKind == DateTimeKind.Utc && dateTime.Kind == DateTimeKind.Local)
				{
					throw new MySqlException("DateTime.Kind must not be Local when DateTimeKind setting is Utc");
				}
				if (connection.DateTimeKind == DateTimeKind.Local && dateTime.Kind == DateTimeKind.Utc)
				{
					throw new MySqlException("DateTime.Kind must not be Utc when DateTimeKind setting is Local");
				}
				return WriteString(dateTime.ToString("yyyy'-'MM'-'dd' 'HH':'mm':'ss'.'ffffff", CultureInfo.InvariantCulture), ref utf8Encoder, output, out bytesWritten);
			}
			if (value is DateTimeOffset { UtcDateTime: var utcDateTime })
			{
				return WriteString(utcDateTime.ToString("yyyy'-'MM'-'dd' 'HH':'mm':'ss'.'ffffff", CultureInfo.InvariantCulture), ref utf8Encoder, output, out bytesWritten);
			}
			if (value is TimeSpan timeSpan)
			{
				bool flag2 = false;
				if (timeSpan.Ticks < 0)
				{
					flag2 = true;
					timeSpan = TimeSpan.FromTicks(-timeSpan.Ticks);
				}
				return WriteString(FormattableString.Invariant(FormattableStringFactory.Create("{0}{1}:{2:mm':'ss'.'ffffff}", flag2 ? "-" : "", timeSpan.Days * 24 + timeSpan.Hours, timeSpan)), ref utf8Encoder, output, out bytesWritten);
			}
			if (value is Guid value14)
			{
				MySqlGuidFormat guidFormat = connection.GuidFormat;
				if ((uint)(guidFormat - 4) <= 2u)
				{
					byte[] array2 = value14.ToByteArray();
					if (connection.GuidFormat != MySqlGuidFormat.LittleEndianBinary16)
					{
						Utility.SwapBytes(array2, 0, 3);
						Utility.SwapBytes(array2, 1, 2);
						Utility.SwapBytes(array2, 4, 5);
						Utility.SwapBytes(array2, 6, 7);
						if (connection.GuidFormat == MySqlGuidFormat.TimeSwapBinary16)
						{
							Utility.SwapBytes(array2, 0, 4);
							Utility.SwapBytes(array2, 1, 5);
							Utility.SwapBytes(array2, 2, 6);
							Utility.SwapBytes(array2, 3, 7);
							Utility.SwapBytes(array2, 0, 2);
							Utility.SwapBytes(array2, 1, 3);
						}
					}
					return WriteBytes(array2, ref inputIndex, output, out bytesWritten);
				}
				bool flag3 = connection.GuidFormat == MySqlGuidFormat.Char32;
				return Utf8Formatter.TryFormat(value14, output, out bytesWritten, flag3 ? 'N' : 'D');
			}
			if (value is Enum @enum)
			{
				return WriteString(@enum.ToString("d"), ref utf8Encoder, output, out bytesWritten);
			}
			if (value is BigInteger bigInteger)
			{
				return WriteString(bigInteger.ToString(CultureInfo.InvariantCulture), ref utf8Encoder, output, out bytesWritten);
			}
			if (value is MySqlDecimal mySqlDecimal)
			{
				return WriteString(mySqlDecimal.ToString(), ref utf8Encoder, output, out bytesWritten);
			}
			throw new NotSupportedException($"Type {value.GetType().Name} not currently supported. Value: {value}");
		}
	}
}


using System.Runtime.CompilerServices;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public sealed class MySqlBulkCopyColumnMapping(int sourceOrdinal, string destinationColumn, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] [property: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string expression = null)
{
	public int SourceOrdinal { get; set; } = sourceOrdinal;

	public string DestinationColumn { get; set; } = destinationColumn;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public string Expression
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		set;
	} = expression;

	public MySqlBulkCopyColumnMapping()
		: this(0, "")
	{
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public sealed class MySqlBulkCopyResult
{
	public IReadOnlyList<MySqlError> Warnings { get; }

	public int RowsInserted { get; }

	internal MySqlBulkCopyResult(IReadOnlyList<MySqlError> warnings, int rowsInserted)
	{
		Warnings = warnings;
		RowsInserted = rowsInserted;
	}
}


using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MySqlConnector;
using MySqlConnector.Protocol.Serialization;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlBulkLoader
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	internal const string SourcePrefix = ":SOURCE:";

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private static readonly object s_lock = new object();

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private static readonly Dictionary<string, object> s_sources = new Dictionary<string, object>();

	public string CharacterSet { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public List<string> Columns
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get;
	}

	public MySqlBulkLoaderConflictOption ConflictOption { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public MySqlConnection Connection
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		set;
	}

	public char EscapeCharacter { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public List<string> Expressions
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get;
	}

	public char FieldQuotationCharacter { get; set; }

	public bool FieldQuotationOptional { get; set; }

	public string FieldTerminator { get; set; }

	public string FileName { get; set; }

	public string LinePrefix { get; set; }

	public string LineTerminator { get; set; }

	public bool Local { get; set; }

	public int NumberOfLinesToSkip { get; set; }

	public MySqlBulkLoaderPriority Priority { get; set; }

	public Stream SourceStream
	{
		get
		{
			return Source as Stream;
		}
		set
		{
			Source = value;
		}
	}

	public string TableName { get; set; }

	public int Timeout { get; set; }

	internal object Source { get; set; }

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public MySqlBulkLoader(MySqlConnection connection)
	{
		Connection = connection;
		Local = true;
		Columns = new List<string>();
		Expressions = new List<string>();
	}

	public int Load()
	{
		return LoadAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public Task<int> LoadAsync()
	{
		return LoadAsync(IOBehavior.Asynchronous, CancellationToken.None).AsTask();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public Task<int> LoadAsync(CancellationToken cancellationToken)
	{
		return LoadAsync(IOBehavior.Asynchronous, cancellationToken).AsTask();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	internal async ValueTask<int> LoadAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (Connection == null)
		{
			throw new InvalidOperationException("Connection not set");
		}
		if (string.IsNullOrWhiteSpace(TableName))
		{
			throw new InvalidOperationException("TableName is required.");
		}
		if (!string.IsNullOrWhiteSpace(FileName) && Source != null)
		{
			throw new InvalidOperationException("Exactly one of FileName or SourceStream must be set.");
		}
		if (!string.IsNullOrWhiteSpace(FileName))
		{
			if (Local)
			{
				string text = GenerateSourceFileName();
				lock (s_lock)
				{
					s_sources.Add(text, CreateFileStream(FileName));
				}
				FileName = text;
			}
		}
		else
		{
			if (!Local)
			{
				throw new InvalidOperationException("Local must be true to use SourceStream, SourceDataTable, or SourceDataReader.");
			}
			FileName = GenerateSourceFileName();
			lock (s_lock)
			{
				s_sources.Add(FileName, Source);
			}
		}
		bool closeConnection = false;
		if (Connection.State != ConnectionState.Open)
		{
			closeConnection = true;
			Connection.Open();
		}
		bool closeStream = SourceStream != null;
		try
		{
			if (Local && !Connection.AllowLoadLocalInfile)
			{
				throw new NotSupportedException("To use MySqlBulkLoader.Local=true, set AllowLoadLocalInfile=true in the connection string. See https://fl.vu/mysql-load-data");
			}
			using MySqlCommand cmd = new MySqlCommand(CreateSql(), Connection, Connection.CurrentTransaction)
			{
				AllowUserVariables = true,
				CommandTimeout = Timeout
			};
			int result = await cmd.ExecuteNonQueryAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			closeStream = false;
			return result;
		}
		finally
		{
			if (closeStream && TryGetAndRemoveSource(FileName, out var source))
			{
				((IDisposable)source).Dispose();
			}
			if (closeConnection)
			{
				Connection.Close();
			}
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	private string CreateSql()
	{
		StringBuilder stringBuilder = new StringBuilder("LOAD DATA ");
		StringBuilder stringBuilder2 = stringBuilder;
		stringBuilder2.Append(Priority switch
		{
			MySqlBulkLoaderPriority.Low => "LOW_PRIORITY ", 
			MySqlBulkLoaderPriority.Concurrent => "CONCURRENT ", 
			_ => "", 
		});
		if (Local)
		{
			stringBuilder.Append("LOCAL ");
		}
		stringBuilder.Append("INFILE '" + MySqlHelper.EscapeString(FileName) + "' ");
		stringBuilder2 = stringBuilder;
		stringBuilder2.Append(ConflictOption switch
		{
			MySqlBulkLoaderConflictOption.Replace => "REPLACE ", 
			MySqlBulkLoaderConflictOption.Ignore => "IGNORE ", 
			_ => "", 
		});
		stringBuilder.Append("INTO TABLE " + TableName + " ");
		if (CharacterSet != null)
		{
			stringBuilder.Append("CHARACTER SET " + CharacterSet + " ");
		}
		string text = ((FieldTerminator == null) ? "" : ("TERMINATED BY '" + MySqlHelper.EscapeString(FieldTerminator) + "' "));
		string text2 = ((FieldQuotationCharacter == '\0') ? "" : ((FieldQuotationOptional ? "OPTIONALLY " : "") + "ENCLOSED BY '" + MySqlHelper.EscapeString(FieldQuotationCharacter.ToString()) + "' "));
		string text3 = ((EscapeCharacter == '\0') ? "" : ("ESCAPED BY '" + MySqlHelper.EscapeString(EscapeCharacter.ToString()) + "' "));
		if (text.Length + text2.Length + text3.Length > 0)
		{
			stringBuilder.Append("FIELDS " + text + text2 + text3);
		}
		string text4 = ((LineTerminator == null) ? "" : ("TERMINATED BY '" + MySqlHelper.EscapeString(LineTerminator) + "' "));
		string text5 = ((LinePrefix == null) ? "" : ("STARTING BY '" + MySqlHelper.EscapeString(LinePrefix) + "' "));
		if (text4.Length + text5.Length > 0)
		{
			stringBuilder.Append("LINES " + text4 + text5);
		}
		stringBuilder.AppendFormat(CultureInfo.InvariantCulture, "IGNORE {0} LINES ", NumberOfLinesToSkip);
		if (Columns.Count > 0)
		{
			stringBuilder.Append("(" + string.Join(",", Columns) + ") ");
		}
		if (Expressions.Count > 0)
		{
			stringBuilder.Append("SET " + string.Join(",", Expressions));
		}
		stringBuilder.Append(';');
		return stringBuilder.ToString();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	private static FileStream CreateFileStream(string fileName)
	{
		try
		{
			return File.OpenRead(fileName);
		}
		catch (Exception innerException)
		{
			throw new MySqlException("Could not access file \"" + fileName + "\"", innerException);
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	internal static object GetAndRemoveSource(string sourceKey)
	{
		lock (s_lock)
		{
			object result = s_sources[sourceKey];
			s_sources.Remove(sourceKey);
			return result;
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	internal static bool TryGetAndRemoveSource(string sourceKey, [<e940fe46-60b5-4fb7-817f-6effabbc4d82>NotNullWhen(true)][<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] out object source)
	{
		lock (s_lock)
		{
			if (s_sources.TryGetValue(sourceKey, out source))
			{
				return s_sources.Remove(sourceKey);
			}
		}
		return false;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	private static string GenerateSourceFileName()
	{
		return ":SOURCE:" + Guid.NewGuid().ToString("N");
	}
}


public enum MySqlBulkLoaderConflictOption
{
	None,
	Replace,
	Ignore
}


public enum MySqlBulkLoaderPriority
{
	None,
	Low,
	Concurrent
}


public enum MySqlCertificateStoreLocation
{
	None,
	CurrentUser,
	LocalMachine
}


using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlCommand : DbCommand, IMySqlCommand, ICancellableCommand, ICloneable
{
	private readonly int m_commandId;

	private bool m_isDisposed;

	private MySqlConnection m_connection;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private string m_commandText;

	private MySqlParameterCollection m_parameterCollection;

	private MySqlAttributeCollection m_attributeCollection;

	private int? m_commandTimeout;

	private CommandType m_commandType;

	private CommandBehavior m_commandBehavior;

	private Action m_cancelAction;

	private Action m_cancelForCommandTimeoutAction;

	private uint m_cancelTimerId;

	private bool m_commandTimedOut;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public new MySqlParameterCollection Parameters
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get
		{
			return m_parameterCollection ?? (m_parameterCollection = new MySqlParameterCollection());
		}
	}

	MySqlParameterCollection IMySqlCommand.RawParameters => m_parameterCollection;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public MySqlAttributeCollection Attributes
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get
		{
			return m_attributeCollection ?? (m_attributeCollection = new MySqlAttributeCollection());
		}
	}

	MySqlAttributeCollection IMySqlCommand.RawAttributes => m_attributeCollection;

	bool IMySqlCommand.AllowUserVariables => AllowUserVariables;

	internal bool AllowUserVariables { get; set; }

	internal bool NoActivity { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public override string CommandText
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get
		{
			return m_commandText;
		}
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			if (m_connection?.ActiveCommandId == m_commandId)
			{
				throw new InvalidOperationException("Cannot set MySqlCommand.CommandText when there is an open DataReader for this command; it must be closed first.");
			}
			m_commandText = value ?? "";
		}
	}

	public bool IsPrepared => ((IMySqlCommand)this).TryGetPreparedStatements() != null;

	public new MySqlTransaction Transaction { get; set; }

	public new MySqlConnection Connection
	{
		get
		{
			return m_connection;
		}
		set
		{
			if (m_connection?.ActiveCommandId == m_commandId)
			{
				throw new InvalidOperationException("Cannot set MySqlCommand.Connection when there is an open DataReader for this command; it must be closed first.");
			}
			m_connection = value;
		}
	}

	public override int CommandTimeout
	{
		get
		{
			return Math.Min(m_commandTimeout ?? Connection?.DefaultCommandTimeout ?? 0, 2147483);
		}
		set
		{
			if (value < 0)
			{
				throw new ArgumentOutOfRangeException("value", "CommandTimeout must be greater than or equal to zero.");
			}
			m_commandTimeout = value;
			((ICancellableCommand)this).EffectiveCommandTimeout = null;
		}
	}

	public override CommandType CommandType
	{
		get
		{
			return m_commandType;
		}
		set
		{
			if (value != CommandType.Text && value != CommandType.StoredProcedure)
			{
				throw new ArgumentException("CommandType must be Text or StoredProcedure.", "value");
			}
			m_commandType = value;
		}
	}

	public override bool DesignTimeVisible { get; set; }

	public override UpdateRowSource UpdatedRowSource { get; set; }

	public long LastInsertedId { get; private set; }

	protected override DbConnection DbConnection
	{
		get
		{
			return Connection;
		}
		set
		{
			Connection = (MySqlConnection)value;
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	protected override DbParameterCollection DbParameterCollection
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get
		{
			return Parameters;
		}
	}

	protected override DbTransaction DbTransaction
	{
		get
		{
			return Transaction;
		}
		set
		{
			Transaction = (MySqlTransaction)value;
		}
	}

	bool ICancellableCommand.IsTimedOut => Volatile.Read(in m_commandTimedOut);

	int ICancellableCommand.CommandId => m_commandId;

	int? ICancellableCommand.EffectiveCommandTimeout { get; set; }

	int ICancellableCommand.CancelAttemptCount { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	ICancellableCommand IMySqlCommand.CancellableCommand
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get
		{
			return this;
		}
	}

	private IOBehavior AsyncIOBehavior => Connection?.AsyncIOBehavior ?? IOBehavior.Asynchronous;

	CommandBehavior IMySqlCommand.CommandBehavior => m_commandBehavior;

	MySqlParameterCollection IMySqlCommand.OutParameters { get; set; }

	MySqlParameter IMySqlCommand.ReturnParameter { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	ILogger IMySqlCommand.Logger
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get
		{
			return Connection.LoggingConfiguration.CommandLogger;
		}
	}

	public MySqlCommand()
		: this(null, null, null)
	{
	}

	public MySqlCommand(string commandText)
		: this(commandText, null, null)
	{
	}

	public MySqlCommand(MySqlConnection connection, MySqlTransaction transaction)
		: this(null, connection, transaction)
	{
	}

	public MySqlCommand(string commandText, MySqlConnection connection)
		: this(commandText, connection, null)
	{
	}

	public MySqlCommand(string commandText, MySqlConnection connection, MySqlTransaction transaction)
	{
		GC.SuppressFinalize(this);
		m_commandId = ICancellableCommandExtensions.GetNextId();
		m_commandText = commandText ?? "";
		Connection = connection;
		Transaction = transaction;
		CommandType = CommandType.Text;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	private MySqlCommand(MySqlCommand other)
		: this(other.CommandText, other.Connection, other.Transaction)
	{
		GC.SuppressFinalize(this);
		m_commandTimeout = other.m_commandTimeout;
		((ICancellableCommand)this).EffectiveCommandTimeout = null;
		m_commandType = other.m_commandType;
		DesignTimeVisible = other.DesignTimeVisible;
		UpdatedRowSource = other.UpdatedRowSource;
		m_parameterCollection = other.CloneRawParameters();
		m_attributeCollection = other.CloneRawAttributes();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public new MySqlParameter CreateParameter()
	{
		return (MySqlParameter)base.CreateParameter();
	}

	public override void Cancel()
	{
		Connection?.Cancel(this, m_commandId, isCancel: true);
	}

	public override int ExecuteNonQuery()
	{
		return ExecuteNonQueryAsync(IOBehavior.Synchronous, CancellationToken.None).Result;
	}

	public override object ExecuteScalar()
	{
		return ExecuteScalarAsync(IOBehavior.Synchronous, CancellationToken.None).Result;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public new MySqlDataReader ExecuteReader()
	{
		return ExecuteReaderAsync(CommandBehavior.Default, IOBehavior.Synchronous, default(CancellationToken)).Result;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public new MySqlDataReader ExecuteReader(CommandBehavior commandBehavior)
	{
		return ExecuteReaderAsync(commandBehavior, IOBehavior.Synchronous, default(CancellationToken)).GetAwaiter().GetResult();
	}

	public override void Prepare()
	{
		if (!NeedsPrepare(out var exception))
		{
			if (exception != null)
			{
				throw exception;
			}
		}
		else
		{
			Connection.Session.PrepareAsync(this, IOBehavior.Synchronous, default(CancellationToken)).GetAwaiter().GetResult();
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public new Task PrepareAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return PrepareAsync(AsyncIOBehavior, cancellationToken);
	}

	internal MySqlParameterCollection CloneRawParameters()
	{
		if (m_parameterCollection == null)
		{
			return null;
		}
		MySqlParameterCollection mySqlParameterCollection = new MySqlParameterCollection();
		foreach (MySqlParameter item in (IEnumerable<MySqlParameter>)m_parameterCollection)
		{
			mySqlParameterCollection.Add(item.Clone());
		}
		return mySqlParameterCollection;
	}

	private MySqlAttributeCollection CloneRawAttributes()
	{
		if (m_attributeCollection == null)
		{
			return null;
		}
		MySqlAttributeCollection mySqlAttributeCollection = new MySqlAttributeCollection();
		foreach (MySqlAttribute item in m_attributeCollection)
		{
			mySqlAttributeCollection.Add(new MySqlAttribute(item.AttributeName, item.Value));
		}
		return mySqlAttributeCollection;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	private Task PrepareAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (!NeedsPrepare(out var exception))
		{
			if (exception != null)
			{
				return Task.FromException(exception);
			}
			return Task.CompletedTask;
		}
		return Connection.Session.PrepareAsync(this, ioBehavior, cancellationToken);
	}

	private bool NeedsPrepare(out Exception exception)
	{
		exception = null;
		if (Connection == null)
		{
			exception = new InvalidOperationException("Connection property must be non-null.");
		}
		else if (Connection.State != ConnectionState.Open)
		{
			exception = new InvalidOperationException($"Connection must be Open; current state is {Connection.State}");
		}
		else if (string.IsNullOrWhiteSpace(CommandText))
		{
			exception = new InvalidOperationException("CommandText must be specified");
		}
		else if (Connection?.HasActiveReader ?? false)
		{
			exception = new InvalidOperationException("Cannot call Prepare when there is an open DataReader for this command's connection; it must be closed first.");
		}
		if (exception != null || Connection.IgnorePrepare)
		{
			return false;
		}
		CommandType commandType = CommandType;
		if (commandType != CommandType.StoredProcedure && commandType != CommandType.Text)
		{
			exception = new NotSupportedException("Only CommandType.Text and CommandType.StoredProcedure are currently supported by MySqlCommand.Prepare.");
			return false;
		}
		return Connection.Session.TryGetPreparedStatement(CommandText) == null;
	}

	void IMySqlCommand.SetLastInsertedId(long lastInsertedId)
	{
		LastInsertedId = lastInsertedId;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	protected override DbParameter CreateDbParameter()
	{
		return new MySqlParameter();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	protected override DbDataReader ExecuteDbDataReader(CommandBehavior behavior)
	{
		return ExecuteReaderAsync(behavior, IOBehavior.Synchronous, CancellationToken.None).Result;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public override Task<int> ExecuteNonQueryAsync(CancellationToken cancellationToken)
	{
		return ExecuteNonQueryAsync(AsyncIOBehavior, cancellationToken).AsTask();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	internal async ValueTask<int> ExecuteNonQueryAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		Volatile.Write(ref m_commandTimedOut, value: false);
		this.ResetCommandTimeout();
		using (((ICancellableCommand)this).RegisterCancel(cancellationToken))
		{
			using MySqlDataReader reader = await ExecuteReaderNoResetTimeoutAsync(CommandBehavior.Default, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			while (await reader.ReadAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) || await reader.NextResultAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
			{
			}
			return reader.RecordsAffected;
		}
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
	public override Task<object> ExecuteScalarAsync(CancellationToken cancellationToken)
	{
		return ExecuteScalarAsync(AsyncIOBehavior, cancellationToken).AsTask();
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 2 })]
	internal async ValueTask<object> ExecuteScalarAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		Volatile.Write(ref m_commandTimedOut, value: false);
		this.ResetCommandTimeout();
		using (((ICancellableCommand)this).RegisterCancel(cancellationToken))
		{
			bool hasSetResult = false;
			object result = null;
			using MySqlDataReader reader = await ExecuteReaderNoResetTimeoutAsync(CommandBehavior.Default, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			do
			{
				bool flag = await reader.ReadAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (!hasSetResult)
				{
					if (flag)
					{
						result = reader.GetValue(0);
					}
					hasSetResult = true;
				}
			}
			while (await reader.NextResultAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
			return result;
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public new Task<MySqlDataReader> ExecuteReaderAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return ExecuteReaderAsync(CommandBehavior.Default, AsyncIOBehavior, cancellationToken).AsTask();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public new Task<MySqlDataReader> ExecuteReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken = default(CancellationToken))
	{
		return ExecuteReaderAsync(behavior, AsyncIOBehavior, cancellationToken).AsTask();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	protected override async Task<DbDataReader> ExecuteDbDataReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken)
	{
		return await ExecuteReaderAsync(behavior, AsyncIOBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	internal async ValueTask<MySqlDataReader> ExecuteReaderAsync(CommandBehavior behavior, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		Volatile.Write(ref m_commandTimedOut, value: false);
		this.ResetCommandTimeout();
		using (((ICancellableCommand)this).RegisterCancel(cancellationToken))
		{
			return await ExecuteReaderNoResetTimeoutAsync(behavior, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	internal ValueTask<MySqlDataReader> ExecuteReaderNoResetTimeoutAsync(CommandBehavior behavior, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (!IsValid(out var exception))
		{
			return ValueTaskExtensions.FromException<MySqlDataReader>(exception);
		}
		Activity activity = (NoActivity ? null : Connection.Session.StartActivity("Execute", "db.statement", CommandText));
		m_commandBehavior = behavior;
		return CommandExecutor.ExecuteReaderAsync(new CommandListPosition(this), SingleCommandPayloadCreator.Instance, behavior, activity, ioBehavior, cancellationToken);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public MySqlCommand Clone()
	{
		return new MySqlCommand(this);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	object ICloneable.Clone()
	{
		return Clone();
	}

	protected override void Dispose(bool disposing)
	{
		m_isDisposed = true;
		base.Dispose(disposing);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public new Task DisposeAsync()
	{
		Dispose();
		return Task.CompletedTask;
	}

	CancellationTokenRegistration ICancellableCommand.RegisterCancel(CancellationToken cancellationToken)
	{
		if (!cancellationToken.CanBeCanceled)
		{
			return default(CancellationTokenRegistration);
		}
		if (m_cancelAction == null)
		{
			m_cancelAction = Cancel;
		}
		return cancellationToken.Register(m_cancelAction);
	}

	void ICancellableCommand.SetTimeout(int milliseconds)
	{
		if (m_cancelTimerId != 0)
		{
			TimerQueue.Instance.Remove(m_cancelTimerId);
		}
		if (milliseconds != int.MaxValue)
		{
			if (m_cancelForCommandTimeoutAction == null)
			{
				m_cancelForCommandTimeoutAction = CancelCommandForTimeout;
			}
			m_cancelTimerId = TimerQueue.Instance.Add(milliseconds, m_cancelForCommandTimeoutAction);
		}
	}

	private void CancelCommandForTimeout()
	{
		Volatile.Write(ref m_commandTimedOut, value: true);
		Connection?.Cancel(this, m_commandId, isCancel: false);
	}

	private bool IsValid([<e940fe46-60b5-4fb7-817f-6effabbc4d82>NotNullWhen(false)] out Exception exception)
	{
		exception = null;
		if (m_isDisposed)
		{
			exception = new ObjectDisposedException(GetType().Name);
		}
		else if (Connection == null)
		{
			exception = new InvalidOperationException("Connection property must be non-null.");
		}
		else
		{
			ConnectionState state = Connection.State;
			if (state != ConnectionState.Open && state != ConnectionState.Connecting)
			{
				exception = new InvalidOperationException($"Connection must be Open; current state is {Connection.State}");
			}
			else if (!Connection.IgnoreCommandTransaction && Transaction != Connection.CurrentTransaction)
			{
				exception = new InvalidOperationException("The transaction associated with this command is not the connection's active transaction; see https://fl.vu/mysql-trans");
			}
			else if (string.IsNullOrWhiteSpace(CommandText))
			{
				exception = new InvalidOperationException("CommandText must be specified");
			}
		}
		return exception == null;
	}

	PreparedStatements IMySqlCommand.TryGetPreparedStatements()
	{
		if (CommandType != CommandType.Text || string.IsNullOrWhiteSpace(CommandText) || m_connection == null || m_connection.State != ConnectionState.Open)
		{
			return null;
		}
		return m_connection.Session.TryGetPreparedStatement(CommandText);
	}
}


using System;
using System.Data;
using System.Data.Common;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Protocol.Serialization;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlCommandBuilder : DbCommandBuilder
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public new MySqlDataAdapter DataAdapter
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get
		{
			return (MySqlDataAdapter)base.DataAdapter;
		}
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		set
		{
			base.DataAdapter = value;
		}
	}

	public static void DeriveParameters(MySqlCommand command)
	{
		DeriveParametersAsync(IOBehavior.Synchronous, command, CancellationToken.None).GetAwaiter().GetResult();
	}

	public static Task DeriveParametersAsync(MySqlCommand command)
	{
		return DeriveParametersAsync(command?.Connection?.AsyncIOBehavior ?? IOBehavior.Asynchronous, command, CancellationToken.None);
	}

	public static Task DeriveParametersAsync(MySqlCommand command, CancellationToken cancellationToken)
	{
		return DeriveParametersAsync(command?.Connection?.AsyncIOBehavior ?? IOBehavior.Asynchronous, command, cancellationToken);
	}

	private static async Task DeriveParametersAsync(IOBehavior ioBehavior, MySqlCommand command, CancellationToken cancellationToken)
	{
		if (command == null)
		{
			throw new ArgumentNullException("command");
		}
		if (command.CommandType != CommandType.StoredProcedure)
		{
			throw new ArgumentException($"MySqlCommand.CommandType must be StoredProcedure not {command.CommandType}", "command");
		}
		if (string.IsNullOrWhiteSpace(command.CommandText))
		{
			throw new ArgumentException("MySqlCommand.CommandText must be set to a stored procedure name", "command");
		}
		MySqlConnection connection = command.Connection;
		if (connection == null || connection.State != ConnectionState.Open)
		{
			throw new ArgumentException("MySqlCommand.Connection must be an open connection.", "command");
		}
		if (command.Connection.Session.ServerVersion.Version < ServerVersions.SupportsProcedureCache)
		{
			throw new NotSupportedException("MySQL Server " + command.Connection.Session.ServerVersion.OriginalString + " doesn't support INFORMATION_SCHEMA");
		}
		CachedProcedure cachedProcedure = await command.Connection.GetCachedProcedure(command.CommandText, revalidateMissing: true, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		if (cachedProcedure == null)
		{
			NormalizedSchema normalizedSchema = NormalizedSchema.MustNormalize(command.CommandText, command.Connection.Database);
			throw new MySqlException("Procedure or function '" + normalizedSchema.Component + "' cannot be found in database '" + normalizedSchema.Schema + "'.");
		}
		command.Parameters.Clear();
		foreach (CachedParameter parameter in cachedProcedure.Parameters)
		{
			MySqlParameter mySqlParameter = command.Parameters.Add("@" + parameter.Name, parameter.MySqlDbType);
			mySqlParameter.Direction = parameter.Direction;
			mySqlParameter.Size = parameter.Length;
		}
	}

	public MySqlCommandBuilder()
	{
		GC.SuppressFinalize(this);
		QuotePrefix = "`";
		QuoteSuffix = "`";
	}

	public MySqlCommandBuilder(MySqlDataAdapter dataAdapter)
		: this()
	{
		DataAdapter = dataAdapter;
	}

	public new MySqlCommand GetDeleteCommand()
	{
		return (MySqlCommand)base.GetDeleteCommand();
	}

	public new MySqlCommand GetInsertCommand()
	{
		return (MySqlCommand)base.GetInsertCommand();
	}

	public new MySqlCommand GetUpdateCommand()
	{
		return (MySqlCommand)base.GetUpdateCommand();
	}

	protected override void ApplyParameterInfo(DbParameter parameter, DataRow row, StatementType statementType, bool whereClause)
	{
		((MySqlParameter)parameter).MySqlDbType = (MySqlDbType)row[SchemaTableColumn.ProviderType];
	}

	protected override string GetParameterName(int parameterOrdinal)
	{
		return FormattableString.Invariant($"@p{parameterOrdinal}");
	}

	protected override string GetParameterName(string parameterName)
	{
		return "@" + parameterName;
	}

	protected override string GetParameterPlaceholder(int parameterOrdinal)
	{
		return GetParameterName(parameterOrdinal);
	}

	protected override void SetRowUpdatingHandler(DbDataAdapter adapter)
	{
		if (!(adapter is MySqlDataAdapter mySqlDataAdapter))
		{
			throw new ArgumentException("adapter needs to be a MySqlDataAdapter", "adapter");
		}
		if (adapter == DataAdapter)
		{
			mySqlDataAdapter.RowUpdating -= RowUpdatingHandler;
		}
		else
		{
			mySqlDataAdapter.RowUpdating += RowUpdatingHandler;
		}
	}

	public override string QuoteIdentifier(string unquotedIdentifier)
	{
		return QuotePrefix + unquotedIdentifier.Replace("`", "``") + QuoteSuffix;
	}

	public override string UnquoteIdentifier(string quotedIdentifier)
	{
		if (quotedIdentifier != null)
		{
			int length = quotedIdentifier.Length;
			if (length >= 2 && quotedIdentifier[0] == '`' && quotedIdentifier[length - 1] == '`')
			{
				string text = quotedIdentifier;
				quotedIdentifier = text.Substring(1, text.Length - 1 - 1);
			}
		}
		return quotedIdentifier.Replace("``", "`");
	}

	private void RowUpdatingHandler(object sender, MySqlRowUpdatingEventArgs e)
	{
		RowUpdatingHandler(e);
	}
}


using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;
using System.Transactions;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Logging;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlConnection : DbConnection, ICloneable
{
	private static readonly StateChangeEventArgs s_stateChangeClosedConnecting = new StateChangeEventArgs(ConnectionState.Closed, ConnectionState.Connecting);

	private static readonly StateChangeEventArgs s_stateChangeConnectingOpen = new StateChangeEventArgs(ConnectionState.Connecting, ConnectionState.Open);

	private static readonly StateChangeEventArgs s_stateChangeOpenClosed = new StateChangeEventArgs(ConnectionState.Open, ConnectionState.Closed);

	private static readonly object s_lock = new object();

	private static readonly Dictionary<Transaction, List<EnlistedTransactionBase>> s_transactionConnections = new Dictionary<Transaction, List<EnlistedTransactionBase>>();

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0 })]
	private static readonly ReadOnlyMemory<byte>[] s_startTransactionPayloads = new ReadOnlyMemory<byte>[30];

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private readonly MySqlDataSource m_dataSource;

	private readonly ILogger m_logger;

	private readonly ILogger m_transactionLogger;

	private string m_connectionString;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private ConnectionSettings m_connectionSettings;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private ServerSession m_session;

	private ConnectionState m_connectionState;

	private bool m_hasBeenOpened;

	private bool m_isDisposed;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 2 })]
	private Dictionary<string, CachedProcedure> m_cachedProcedures;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private SchemaProvider m_schemaProvider;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private MySqlDataReader m_activeReader;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private EnlistedTransactionBase m_enlistedTransaction;

	public override string ConnectionString
	{
		get
		{
			if (!m_hasBeenOpened)
			{
				return m_connectionString;
			}
			MySqlConnectionStringBuilder connectionStringBuilder = GetConnectionSettings().ConnectionStringBuilder;
			return connectionStringBuilder.GetConnectionString(connectionStringBuilder.PersistSecurityInfo);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			if (m_connectionState == ConnectionState.Open)
			{
				throw new InvalidOperationException("Cannot change the connection string on an open connection.");
			}
			m_hasBeenOpened = false;
			m_connectionString = value ?? "";
			m_connectionSettings = null;
		}
	}

	public override string Database => m_session?.DatabaseOverride ?? GetConnectionSettings().Database;

	public override ConnectionState State => m_connectionState;

	public override string DataSource => GetConnectionSettings().ConnectionStringBuilder.Server;

	public override string ServerVersion => Session.ServerVersion.OriginalString;

	public int ServerThread => Session.ConnectionId;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	public Func<X509CertificateCollection, ValueTask> ProvideClientCertificatesCallback
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
		get;
		[param: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
		set;
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 1 })]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 1 })]
	public Func<MySqlProvidePasswordContext, string> ProvidePasswordCallback
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 1 })]
		get;
		[param: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 1 })]
		set;
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public RemoteCertificateValidationCallback RemoteCertificateValidationCallback
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		set;
	}

	protected override DbProviderFactory DbProviderFactory => MySqlConnectorFactory.Instance;

	public override int ConnectionTimeout => GetConnectionSettings().ConnectionTimeout;

	public new bool CanCreateBatch => true;

	internal ServerSession Session
	{
		get
		{
			VerifyNotDisposed();
			if (m_session == null || State != ConnectionState.Open)
			{
				throw new InvalidOperationException($"Connection must be Open; current state is {State}");
			}
			return m_session;
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	internal MySqlTransaction CurrentTransaction
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		set;
	}

	internal MySqlConnectorLoggingConfiguration LoggingConfiguration { get; }

	internal bool AllowLoadLocalInfile => GetInitializedConnectionSettings().AllowLoadLocalInfile;

	internal bool AllowUserVariables => GetInitializedConnectionSettings().AllowUserVariables;

	internal bool AllowZeroDateTime => GetInitializedConnectionSettings().AllowZeroDateTime;

	internal bool ConvertZeroDateTime => GetInitializedConnectionSettings().ConvertZeroDateTime;

	internal DateTimeKind DateTimeKind => GetInitializedConnectionSettings().DateTimeKind;

	internal int DefaultCommandTimeout => GetConnectionSettings().DefaultCommandTimeout;

	internal MySqlGuidFormat GuidFormat => GetInitializedConnectionSettings().GuidFormat;

	internal bool IgnoreCommandTransaction
	{
		get
		{
			if (!GetInitializedConnectionSettings().IgnoreCommandTransaction)
			{
				return m_enlistedTransaction is StandardEnlistedTransaction;
			}
			return true;
		}
	}

	internal bool IgnorePrepare => GetInitializedConnectionSettings().IgnorePrepare;

	internal bool NoBackslashEscapes => GetInitializedConnectionSettings().NoBackslashEscapes;

	internal bool TreatTinyAsBoolean => GetInitializedConnectionSettings().TreatTinyAsBoolean;

	internal IOBehavior AsyncIOBehavior
	{
		get
		{
			if (!GetConnectionSettings().ForceSynchronous)
			{
				return IOBehavior.Asynchronous;
			}
			return IOBehavior.Synchronous;
		}
	}

	internal IOBehavior SimpleAsyncIOBehavior
	{
		get
		{
			if ((!(m_connectionSettings?.ForceSynchronous)) ?? true)
			{
				return IOBehavior.Asynchronous;
			}
			return IOBehavior.Synchronous;
		}
	}

	internal MySqlSslMode SslMode => GetInitializedConnectionSettings().SslMode;

	internal int? ActiveCommandId => m_session?.ActiveCommandId;

	internal bool SupportsPerQueryVariables => m_session?.SupportsPerQueryVariables ?? false;

	internal bool HasActiveReader => m_activeReader != null;

	internal bool SslIsEncrypted => m_session.SslIsEncrypted;

	internal bool SslIsSigned => m_session.SslIsSigned;

	internal bool SslIsAuthenticated => m_session.SslIsAuthenticated;

	internal bool SslIsMutuallyAuthenticated => m_session.SslIsMutuallyAuthenticated;

	internal SslProtocols SslProtocol => m_session.SslProtocol;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[method: <31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public event MySqlInfoMessageEventHandler InfoMessage;

	public MySqlConnection()
		: this("")
	{
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public MySqlConnection(string connectionString)
		: this(connectionString ?? "", MySqlConnectorLoggingConfiguration.GlobalConfiguration)
	{
	}

	internal MySqlConnection(MySqlDataSource dataSource)
		: this(dataSource.ConnectionString, dataSource.LoggingConfiguration)
	{
		m_dataSource = dataSource;
	}

	private MySqlConnection(string connectionString, MySqlConnectorLoggingConfiguration loggingConfiguration)
	{
		GC.SuppressFinalize(this);
		m_connectionString = connectionString;
		LoggingConfiguration = loggingConfiguration;
		m_logger = loggingConfiguration.ConnectionLogger;
		m_transactionLogger = loggingConfiguration.TransactionLogger;
	}

	public new MySqlTransaction BeginTransaction()
	{
		return BeginTransactionAsync(System.Data.IsolationLevel.Unspecified, null, IOBehavior.Synchronous, default(CancellationToken)).GetAwaiter().GetResult();
	}

	public new MySqlTransaction BeginTransaction(System.Data.IsolationLevel isolationLevel)
	{
		return BeginTransactionAsync(isolationLevel, null, IOBehavior.Synchronous, default(CancellationToken)).GetAwaiter().GetResult();
	}

	public MySqlTransaction BeginTransaction(System.Data.IsolationLevel isolationLevel, bool isReadOnly)
	{
		return BeginTransactionAsync(isolationLevel, isReadOnly, IOBehavior.Synchronous, default(CancellationToken)).GetAwaiter().GetResult();
	}

	protected override DbTransaction BeginDbTransaction(System.Data.IsolationLevel isolationLevel)
	{
		return BeginTransactionAsync(isolationLevel, null, IOBehavior.Synchronous, default(CancellationToken)).GetAwaiter().GetResult();
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public new ValueTask<MySqlTransaction> BeginTransactionAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return BeginTransactionAsync(System.Data.IsolationLevel.Unspecified, null, AsyncIOBehavior, cancellationToken);
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public new ValueTask<MySqlTransaction> BeginTransactionAsync(System.Data.IsolationLevel isolationLevel, CancellationToken cancellationToken = default(CancellationToken))
	{
		return BeginTransactionAsync(isolationLevel, null, AsyncIOBehavior, cancellationToken);
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public ValueTask<MySqlTransaction> BeginTransactionAsync(System.Data.IsolationLevel isolationLevel, bool isReadOnly, CancellationToken cancellationToken = default(CancellationToken))
	{
		return BeginTransactionAsync(isolationLevel, isReadOnly, AsyncIOBehavior, cancellationToken);
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	private async ValueTask<MySqlTransaction> BeginTransactionAsync(System.Data.IsolationLevel isolationLevel, bool? isReadOnly, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (State != ConnectionState.Open)
		{
			throw new InvalidOperationException("Connection is not open.");
		}
		if (CurrentTransaction != null)
		{
			throw new InvalidOperationException("Transactions may not be nested.");
		}
		if (m_enlistedTransaction != null)
		{
			throw new InvalidOperationException("Cannot begin a transaction when already enlisted in a transaction.");
		}
		Log.StartingTransaction(m_transactionLogger, m_session.Id);
		ReadOnlyMemory<byte> startTransactionPayload = GetStartTransactionPayload(isolationLevel, isReadOnly, m_session.SupportsQueryAttributes);
		ConnectionSettings initializedConnectionSettings = GetInitializedConnectionSettings();
		if ((initializedConnectionSettings != null && !initializedConnectionSettings.UseCompression && !((!initializedConnectionSettings.Pipelining) ?? false)) ? true : false)
		{
			await m_session.SendRawAsync(startTransactionPayload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			OkPayload.Verify((await m_session.ReceiveReplyAsync(1, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span, m_session.SupportsDeprecateEof, m_session.SupportsSessionTrack);
			OkPayload.Verify((await m_session.ReceiveReplyAsync(1, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span, m_session.SupportsDeprecateEof, m_session.SupportsSessionTrack);
		}
		else
		{
			await m_session.SendAsync(new PayloadData(startTransactionPayload.Slice(4, startTransactionPayload.Span[0])), ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			OkPayload.Verify((await m_session.ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span, m_session.SupportsDeprecateEof, m_session.SupportsSessionTrack);
			await m_session.SendAsync(new PayloadData(startTransactionPayload.Slice(8 + startTransactionPayload.Span[0], startTransactionPayload.Span[startTransactionPayload.Span[0] + 4])), ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			OkPayload.Verify((await m_session.ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span, m_session.SupportsDeprecateEof, m_session.SupportsSessionTrack);
		}
		return CurrentTransaction = new MySqlTransaction(this, isolationLevel, m_transactionLogger);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	internal static ReadOnlyMemory<byte> GetStartTransactionPayload(System.Data.IsolationLevel isolationLevel, bool? isReadOnly, bool supportsQueryAttributes)
	{
		int num = isolationLevel switch
		{
			System.Data.IsolationLevel.ReadUncommitted => 0, 
			System.Data.IsolationLevel.ReadCommitted => 1, 
			System.Data.IsolationLevel.Serializable => 2, 
			System.Data.IsolationLevel.RepeatableRead => 3, 
			System.Data.IsolationLevel.Snapshot => 3, 
			System.Data.IsolationLevel.Unspecified => 3, 
			_ => throw new NotSupportedException($"IsolationLevel.{isolationLevel} is not supported."), 
		};
		int num2 = ((isolationLevel == System.Data.IsolationLevel.Snapshot) ? 1 : 0);
		int num3 = (isReadOnly.HasValue ? ((isReadOnly != true) ? 1 : 2) : 0);
		int num4 = num3;
		int num5 = ((supportsQueryAttributes ? 1 : 0) * 5 + num + num2) * 3 + num4;
		if (s_startTransactionPayloads[num5].IsEmpty)
		{
			byte[] array = new byte[125];
			int num6 = 4;
			int num7 = 0;
			array[num6] = 3;
			num6++;
			num7++;
			if (supportsQueryAttributes)
			{
				array[num6 + 1] = 1;
				num6 += 2;
				num7 += 2;
			}
			ReadOnlySpan<byte> readOnlySpan = "set session transaction isolation level "u8;
			readOnlySpan.CopyTo(MemoryExtensions.AsSpan(array, num6));
			num7 += readOnlySpan.Length;
			num6 += readOnlySpan.Length;
			ReadOnlySpan<byte> readOnlySpan2 = num switch
			{
				0 => "read uncommitted"u8, 
				1 => "read committed"u8, 
				2 => "serializable"u8, 
				_ => "repeatable read"u8, 
			};
			readOnlySpan2.CopyTo(MemoryExtensions.AsSpan(array, num6));
			num6 += readOnlySpan2.Length;
			num7 += readOnlySpan2.Length;
			array[num6] = 59;
			num6++;
			num7++;
			array[0] = (byte)num7;
			num6 += 4;
			array[num6] = 3;
			num6++;
			num7 = 1;
			if (supportsQueryAttributes)
			{
				array[num6 + 1] = 1;
				num6 += 2;
				num7 += 2;
			}
			ReadOnlySpan<byte> readOnlySpan3 = "start transaction"u8;
			readOnlySpan3.CopyTo(MemoryExtensions.AsSpan(array, num6));
			num7 += readOnlySpan3.Length;
			num6 += readOnlySpan3.Length;
			if (num2 == 1)
			{
				ReadOnlySpan<byte> readOnlySpan4 = " with consistent snapshot"u8;
				readOnlySpan4.CopyTo(MemoryExtensions.AsSpan(array, num6));
				num7 += readOnlySpan4.Length;
				num6 += readOnlySpan4.Length;
			}
			if (num2 > 0 && num4 > 0)
			{
				array[num6] = 44;
				num6++;
				num7++;
			}
			ReadOnlySpan<byte> readOnlySpan5 = num4 switch
			{
				1 => " read write"u8, 
				2 => " read only"u8, 
				_ => ""u8, 
			};
			readOnlySpan5.CopyTo(MemoryExtensions.AsSpan(array, num6));
			num6 += readOnlySpan5.Length;
			num7 += readOnlySpan5.Length;
			array[num6] = 59;
			num6++;
			num7++;
			array[array[0] + 4] = (byte)num7;
			s_startTransactionPayloads[num5] = new ReadOnlyMemory<byte>(array, 0, array[0] + array[array[0] + 4] + 8);
		}
		return s_startTransactionPayloads[num5];
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public override void EnlistTransaction(Transaction transaction)
	{
		if (State != ConnectionState.Open)
		{
			throw new InvalidOperationException("Connection is not open.");
		}
		if (!((!(m_enlistedTransaction?.Transaction.Equals(transaction))) ?? true))
		{
			return;
		}
		if (m_enlistedTransaction != null)
		{
			throw new MySqlException("Already enlisted in a Transaction.");
		}
		if (CurrentTransaction != null)
		{
			throw new InvalidOperationException("Can't enlist in a Transaction when there is an active MySqlTransaction.");
		}
		if ((object)transaction == null)
		{
			return;
		}
		MySqlConnection mySqlConnection = FindExistingEnlistedSession(transaction);
		if (mySqlConnection != null)
		{
			CloseAsync(changeState: false, IOBehavior.Synchronous).GetAwaiter().GetResult();
			TakeSessionFrom(mySqlConnection);
			return;
		}
		m_enlistedTransaction = (GetInitializedConnectionSettings().UseXaTransactions ? ((EnlistedTransactionBase)new XaEnlistedTransaction(transaction, this)) : ((EnlistedTransactionBase)new StandardEnlistedTransaction(transaction, this)));
		m_enlistedTransaction.Start();
		lock (s_lock)
		{
			if (!s_transactionConnections.TryGetValue(transaction, out var value))
			{
				value = (s_transactionConnections[transaction] = new List<EnlistedTransactionBase>());
			}
			value.Add(m_enlistedTransaction);
		}
	}

	internal void UnenlistTransaction()
	{
		Transaction transaction = m_enlistedTransaction.Transaction;
		m_enlistedTransaction = null;
		bool? flag = null;
		lock (s_lock)
		{
			List<EnlistedTransactionBase> list = s_transactionConnections[transaction];
			for (int i = 0; i < list.Count; i++)
			{
				if (list[i].Connection == this)
				{
					flag = list[i].IsIdle;
					list.RemoveAt(i);
					break;
				}
			}
			if (list.Count == 0)
			{
				s_transactionConnections.Remove(transaction);
			}
		}
		if (!flag.HasValue)
		{
			throw new InvalidOperationException("Didn't find transaction");
		}
		if (flag.Value)
		{
			Close();
		}
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private MySqlConnection FindExistingEnlistedSession(Transaction transaction)
	{
		bool flag = false;
		bool flag2 = false;
		lock (s_lock)
		{
			if (s_transactionConnections.TryGetValue(transaction, out var value))
			{
				flag = true;
				foreach (EnlistedTransactionBase item in value)
				{
					flag2 = item.Connection.GetInitializedConnectionSettings().UseXaTransactions;
					if (item.IsIdle && item.Connection.m_connectionString == m_connectionString)
					{
						MySqlConnection connection = item.Connection;
						item.Connection = this;
						item.IsIdle = false;
						return connection;
					}
				}
			}
		}
		if (GetInitializedConnectionSettings().UseXaTransactions)
		{
			if (flag && !flag2)
			{
				throw new NotSupportedException("Cannot start an XA transaction when there is an existing non-XA transaction.");
			}
		}
		else if (flag)
		{
			throw new NotSupportedException("Multiple simultaneous connections or connections with different connection strings inside the same transaction are not supported when UseXaTransactions=False.");
		}
		return null;
	}

	private void TakeSessionFrom(MySqlConnection other)
	{
		m_session = other.m_session;
		m_session.OwningConnection = new WeakReference<MySqlConnection>(this);
		other.m_session = null;
		m_cachedProcedures = other.m_cachedProcedures;
		other.m_cachedProcedures = null;
		m_enlistedTransaction = other.m_enlistedTransaction;
		other.m_enlistedTransaction = null;
	}

	public override void Close()
	{
		CloseAsync(changeState: true, IOBehavior.Synchronous).GetAwaiter().GetResult();
	}

	public new Task CloseAsync()
	{
		return CloseAsync(changeState: true, SimpleAsyncIOBehavior);
	}

	internal Task CloseAsync(IOBehavior ioBehavior)
	{
		return CloseAsync(changeState: true, ioBehavior);
	}

	public override void ChangeDatabase(string databaseName)
	{
		ChangeDatabaseAsync(IOBehavior.Synchronous, databaseName, CancellationToken.None).GetAwaiter().GetResult();
	}

	public new Task ChangeDatabaseAsync(string databaseName, CancellationToken cancellationToken = default(CancellationToken))
	{
		return ChangeDatabaseAsync(AsyncIOBehavior, databaseName, cancellationToken);
	}

	private async Task ChangeDatabaseAsync(IOBehavior ioBehavior, string databaseName, CancellationToken cancellationToken)
	{
		if (string.IsNullOrWhiteSpace(databaseName))
		{
			throw new ArgumentException("Database name is not valid.", "databaseName");
		}
		if (State != ConnectionState.Open)
		{
			throw new InvalidOperationException("Connection is not open.");
		}
		using (PayloadData initDatabasePayload = InitDatabasePayload.Create(databaseName))
		{
			await m_session.SendAsync(initDatabasePayload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		OkPayload.Verify((await m_session.ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span, m_session.SupportsDeprecateEof, m_session.SupportsSessionTrack);
		m_session.DatabaseOverride = databaseName;
	}

	public new MySqlCommand CreateCommand()
	{
		return (MySqlCommand)base.CreateCommand();
	}

	public bool Ping()
	{
		return PingAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	public Task<bool> PingAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return PingAsync(SimpleAsyncIOBehavior, cancellationToken).AsTask();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private async ValueTask<bool> PingAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (m_session == null)
		{
			return false;
		}
		try
		{
			if (await m_session.TryPingAsync(logInfo: true, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
			{
				return true;
			}
		}
		catch (InvalidOperationException)
		{
		}
		SetState(ConnectionState.Closed);
		return false;
	}

	public override void Open()
	{
		OpenAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	public override Task OpenAsync(CancellationToken cancellationToken)
	{
		return OpenAsync(null, cancellationToken);
	}

	internal async Task OpenAsync(IOBehavior? ioBehavior, CancellationToken cancellationToken)
	{
		long timestamp = Stopwatch.GetTimestamp();
		VerifyNotDisposed();
		cancellationToken.ThrowIfCancellationRequested();
		if (State != 0)
		{
			throw new InvalidOperationException($"Cannot Open when State is {State}.");
		}
		using Activity activity = ActivitySourceHelper.StartActivity("Open");
		try
		{
			SetState(ConnectionState.Connecting);
			ConnectionPool connectionPool = m_dataSource?.Pool ?? ConnectionPool.GetPool(m_connectionString, LoggingConfiguration);
			if (m_connectionSettings == null)
			{
				m_connectionSettings = connectionPool?.ConnectionSettings ?? new ConnectionSettings(new MySqlConnectionStringBuilder(m_connectionString));
			}
			if (m_connectionSettings.AutoEnlist && (object)Transaction.Current != null)
			{
				MySqlConnection mySqlConnection = FindExistingEnlistedSession(Transaction.Current);
				if (mySqlConnection != null)
				{
					TakeSessionFrom(mySqlConnection);
					ActivitySourceHelper.CopyTags(m_session.ActivityTags, activity);
					m_hasBeenOpened = true;
					SetState(ConnectionState.Open);
					return;
				}
			}
			try
			{
				m_session = await CreateSessionAsync(connectionPool, timestamp, activity, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				m_hasBeenOpened = true;
				SetState(ConnectionState.Open);
			}
			catch (OperationCanceledException ex)
			{
				SetState(ConnectionState.Closed);
				if (!cancellationToken.Equals(ex.CancellationToken))
				{
					cancellationToken.ThrowIfCancellationRequested();
				}
				throw;
			}
			catch (MySqlException)
			{
				SetState(ConnectionState.Closed);
				cancellationToken.ThrowIfCancellationRequested();
				throw;
			}
			catch (SocketException)
			{
				SetState(ConnectionState.Closed);
				throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Unable to connect to any of the specified MySQL hosts.");
			}
			if (m_connectionSettings.AutoEnlist && (object)Transaction.Current != null)
			{
				EnlistTransaction(Transaction.Current);
			}
		}
		catch (Exception exception) when (activity?.IsAllDataRequested ?? false)
		{
			MySqlConnectionStringBuilder mySqlConnectionStringBuilder = m_connectionSettings?.ConnectionStringBuilder;
			if (mySqlConnectionStringBuilder != null)
			{
				activity.SetTag("db.connection_string", mySqlConnectionStringBuilder.GetConnectionString(mySqlConnectionStringBuilder.PersistSecurityInfo));
			}
			activity.SetException(exception);
			throw;
		}
	}

	public async ValueTask ResetConnectionAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		ServerSession session = Session;
		Log.ResettingConnection(m_logger, session.Id);
		await session.SendAsync(ResetConnectionPayload.Instance, AsyncIOBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		OkPayload.Verify((await session.ReceiveReplyAsync(AsyncIOBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span, session.SupportsDeprecateEof, session.SupportsSessionTrack);
	}

	public static void ClearPool(MySqlConnection connection)
	{
		ClearPoolAsync(connection, IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	public static Task ClearPoolAsync(MySqlConnection connection, CancellationToken cancellationToken = default(CancellationToken))
	{
		return ClearPoolAsync(connection, connection.AsyncIOBehavior, cancellationToken);
	}

	public static void ClearAllPools()
	{
		ConnectionPool.ClearPoolsAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	public static Task ClearAllPoolsAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return ConnectionPool.ClearPoolsAsync(IOBehavior.Asynchronous, cancellationToken);
	}

	private static async Task ClearPoolAsync(MySqlConnection connection, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (connection == null)
		{
			throw new ArgumentNullException("connection");
		}
		ConnectionPool pool = ConnectionPool.GetPool(connection.m_connectionString, null, createIfNotFound: false);
		if (pool != null)
		{
			await pool.ClearAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
	}

	protected override DbCommand CreateDbCommand()
	{
		return new MySqlCommand(this, null);
	}

	public override DataTable GetSchema()
	{
		return GetSchemaProvider().GetSchemaAsync(IOBehavior.Synchronous, "MetaDataCollections", null, default(CancellationToken)).GetAwaiter().GetResult();
	}

	public override DataTable GetSchema(string collectionName)
	{
		return GetSchemaProvider().GetSchemaAsync(IOBehavior.Synchronous, collectionName, null, default(CancellationToken)).GetAwaiter().GetResult();
	}

	public override DataTable GetSchema(string collectionName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })] string[] restrictionValues)
	{
		return GetSchemaProvider().GetSchemaAsync(IOBehavior.Synchronous, collectionName, restrictionValues, default(CancellationToken)).GetAwaiter().GetResult();
	}

	public new Task<DataTable> GetSchemaAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return GetSchemaProvider().GetSchemaAsync(AsyncIOBehavior, "MetaDataCollections", null, cancellationToken).AsTask();
	}

	public new Task<DataTable> GetSchemaAsync(string collectionName, CancellationToken cancellationToken = default(CancellationToken))
	{
		return GetSchemaProvider().GetSchemaAsync(AsyncIOBehavior, collectionName, null, cancellationToken).AsTask();
	}

	public new Task<DataTable> GetSchemaAsync(string collectionName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })] string[] restrictionValues, CancellationToken cancellationToken = default(CancellationToken))
	{
		return GetSchemaProvider().GetSchemaAsync(AsyncIOBehavior, collectionName, restrictionValues, cancellationToken).AsTask();
	}

	private SchemaProvider GetSchemaProvider()
	{
		return m_schemaProvider ?? (m_schemaProvider = new SchemaProvider(this));
	}

	public new MySqlBatch CreateBatch()
	{
		return new MySqlBatch(this);
	}

	protected override void Dispose(bool disposing)
	{
		try
		{
			if (disposing)
			{
				CloseAsync(changeState: true, IOBehavior.Synchronous).GetAwaiter().GetResult();
			}
		}
		finally
		{
			m_isDisposed = true;
			base.Dispose(disposing);
		}
	}

	public new async Task DisposeAsync()
	{
		try
		{
			await CloseAsync(changeState: true, SimpleAsyncIOBehavior).ConfigureAwait(continueOnCapturedContext: false);
		}
		finally
		{
			m_isDisposed = true;
			base.Dispose(disposing: true);
		}
	}

	public MySqlConnection Clone()
	{
		return new MySqlConnection(this, m_dataSource, m_connectionString, m_hasBeenOpened);
	}

	object ICloneable.Clone()
	{
		return Clone();
	}

	public MySqlConnection CloneWith(string connectionString)
	{
		MySqlConnectionStringBuilder mySqlConnectionStringBuilder = new MySqlConnectionStringBuilder(connectionString ?? throw new ArgumentNullException("connectionString"));
		MySqlConnectionStringBuilder connectionStringBuilder = GetConnectionSettings().ConnectionStringBuilder;
		bool flag = mySqlConnectionStringBuilder.Password.Length == 0 && (!mySqlConnectionStringBuilder.PersistSecurityInfo || connectionStringBuilder.PersistSecurityInfo);
		if (flag)
		{
			mySqlConnectionStringBuilder.Password = connectionStringBuilder.Password;
		}
		string connectionString2 = mySqlConnectionStringBuilder.ConnectionString;
		MySqlDataSource dataSource = ((connectionString2 == connectionStringBuilder.ConnectionString) ? m_dataSource : null);
		return new MySqlConnection(this, dataSource, connectionString2, m_hasBeenOpened && flag && !connectionStringBuilder.PersistSecurityInfo);
	}

	internal void SetSessionFailed(Exception exception)
	{
		m_session.SetFailed(exception);
	}

	internal void Cancel(ICancellableCommand command, int commandId, bool isCancel)
	{
		string text = m_session?.Id;
		if (text == null || State != ConnectionState.Open || !(m_session?.TryStartCancel(command) ?? false))
		{
			Log.IgnoringCancellationForCommand(m_logger, commandId);
			return;
		}
		Log.CommandHasBeenCanceled(m_logger, commandId, text, isCancel ? "Cancel()" : "command timeout");
		try
		{
			MySqlConnectionStringBuilder mySqlConnectionStringBuilder = new MySqlConnectionStringBuilder(m_connectionString)
			{
				AutoEnlist = false,
				Pooling = false
			};
			IPEndPoint iPEndPoint = m_session.IPEndPoint;
			if (iPEndPoint != null)
			{
				IPAddress address = iPEndPoint.Address;
				if (address != null)
				{
					int port = iPEndPoint.Port;
					mySqlConnectionStringBuilder.Server = address.ToString();
					mySqlConnectionStringBuilder.Port = (uint)port;
				}
			}
			mySqlConnectionStringBuilder.UserID = m_session.UserID;
			int cancellationTimeout = GetConnectionSettings().CancellationTimeout;
			mySqlConnectionStringBuilder.ConnectionTimeout = ((cancellationTimeout < 1) ? 3u : ((uint)cancellationTimeout));
			using MySqlConnection mySqlConnection = CloneWith(mySqlConnectionStringBuilder.ConnectionString);
			mySqlConnection.Open();
			using MySqlCommand mySqlCommand = new MySqlCommand(FormattableString.Invariant($"KILL QUERY {command.Connection.ServerThread}"), mySqlConnection);
			mySqlCommand.CommandTimeout = ((cancellationTimeout < 1) ? 3 : cancellationTimeout);
			m_session?.DoCancel(command, mySqlCommand);
		}
		catch (InvalidOperationException exception)
		{
			Log.IgnoringCancellationForClosedConnection(m_logger, exception, text);
			m_session?.AbortCancel(command);
		}
		catch (MySqlException exception2)
		{
			Log.CancelingCommandFailed(m_logger, exception2, text, command.CommandId);
			m_session?.AbortCancel(command);
		}
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
	internal async Task<CachedProcedure> GetCachedProcedure(string name, bool revalidateMissing, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		Log.GettingCachedProcedure(m_logger, m_session.Id, name);
		if (State != ConnectionState.Open)
		{
			throw new InvalidOperationException("Connection is not open.");
		}
		Dictionary<string, CachedProcedure> cachedProcedures = m_session.Pool?.GetProcedureCache() ?? m_cachedProcedures;
		if (cachedProcedures == null)
		{
			Log.PoolDoesNotHaveSharedProcedureCache(m_logger, m_session.Id, m_session.Pool?.Id);
			cachedProcedures = (m_cachedProcedures = new Dictionary<string, CachedProcedure>());
		}
		NormalizedSchema normalized = NormalizedSchema.MustNormalize(name, Database);
		if (string.IsNullOrEmpty(normalized.Schema))
		{
			Log.CouldNotNormalizeDatabaseAndName(m_logger, m_session.Id, name, Database);
			return null;
		}
		bool flag;
		CachedProcedure value;
		lock (cachedProcedures)
		{
			flag = cachedProcedures.TryGetValue(normalized.FullyQualified, out value);
		}
		if (!flag || (value == null && revalidateMissing))
		{
			value = await CachedProcedure.FillAsync(ioBehavior, this, normalized.Schema, normalized.Component, m_logger, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (value == null)
			{
				Log.FailedToCacheProcedure(m_logger, m_session.Id, normalized.Schema, normalized.Component);
			}
			else
			{
				Log.CachingProcedure(m_logger, m_session.Id, normalized.Schema, normalized.Component);
			}
			int count;
			lock (cachedProcedures)
			{
				cachedProcedures[normalized.FullyQualified] = value;
				count = cachedProcedures.Count;
			}
			Log.ProcedureCacheCount(m_logger, m_session.Id, count);
		}
		if (value == null)
		{
			Log.DidNotFindCachedProcedure(m_logger, m_session.Id, normalized.Schema, normalized.Component);
		}
		else
		{
			Log.ReturningCachedProcedure(m_logger, m_session.Id, normalized.Schema, normalized.Component);
		}
		return value;
	}

	internal void SetActiveReader(MySqlDataReader dataReader)
	{
		if (dataReader == null)
		{
			throw new ArgumentNullException("dataReader");
		}
		if (m_activeReader != null)
		{
			throw new InvalidOperationException("Can't replace active reader.");
		}
		m_activeReader = dataReader;
	}

	internal void FinishQuerying(bool hasWarnings)
	{
		m_session.FinishQuerying();
		m_activeReader = null;
		if (!hasWarnings || this.InfoMessage == null)
		{
			return;
		}
		List<MySqlError> list = new List<MySqlError>();
		using (MySqlCommand mySqlCommand = new MySqlCommand("SHOW WARNINGS;", this))
		{
			mySqlCommand.Transaction = CurrentTransaction;
			using MySqlDataReader mySqlDataReader = mySqlCommand.ExecuteReader();
			while (mySqlDataReader.Read())
			{
				list.Add(new MySqlError(mySqlDataReader.GetString(0), mySqlDataReader.GetInt32(1), mySqlDataReader.GetString(2)));
			}
		}
		this.InfoMessage(this, new MySqlInfoMessageEventArgs(list));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	private async ValueTask<ServerSession> CreateSessionAsync(ConnectionPool pool, long startingTimestamp, Activity activity, IOBehavior? ioBehavior, CancellationToken cancellationToken)
	{
		MetricsReporter.AddPendingRequest(pool);
		ConnectionSettings connectionSettings = GetInitializedConnectionSettings();
		IOBehavior actualIOBehavior = (IOBehavior)(((int?)ioBehavior) ?? ((!connectionSettings.ForceSynchronous) ? 1 : 0));
		CancellationTokenSource timeoutSource = null;
		CancellationTokenSource linkedSource = null;
		try
		{
			if (connectionSettings.ConnectionTimeout != 0)
			{
				timeoutSource = new CancellationTokenSource(TimeSpan.FromMilliseconds(Math.Max(1, connectionSettings.ConnectionTimeoutMilliseconds - Utility.GetElapsedMilliseconds(startingTimestamp))));
			}
			if (cancellationToken.CanBeCanceled && timeoutSource != null)
			{
				linkedSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutSource.Token);
			}
			CancellationToken cancellationToken2 = linkedSource?.Token ?? timeoutSource?.Token ?? cancellationToken;
			if (pool != null)
			{
				return await pool.GetSessionAsync(this, startingTimestamp, connectionSettings.ConnectionTimeoutMilliseconds, activity, actualIOBehavior, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
			}
			ILoadBalancer loadBalancer = ((connectionSettings.LoadBalance == MySqlLoadBalance.Random && connectionSettings.HostNames.Count > 1) ? RandomLoadBalancer.Instance : FailOverLoadBalancer.Instance);
			ServerSession session = new ServerSession(m_logger)
			{
				OwningConnection = new WeakReference<MySqlConnection>(this)
			};
			Log.CreatedNonPooledSession(m_logger, session.Id);
			try
			{
				await session.ConnectAsync(connectionSettings, this, startingTimestamp, loadBalancer, activity, actualIOBehavior, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
				return session;
			}
			catch (Exception)
			{
				await session.DisposeAsync(actualIOBehavior, default(CancellationToken)).ConfigureAwait(continueOnCapturedContext: false);
				throw;
			}
		}
		catch (OperationCanceledException) when (timeoutSource?.IsCancellationRequested ?? false)
		{
			MetricsReporter.AddTimeout(pool, connectionSettings);
			string text = ((pool?.IsEmpty ?? false) ? " All pooled connections are in use." : "");
			throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Connect Timeout expired." + text);
		}
		catch (MySqlException ex3) when ((timeoutSource?.IsCancellationRequested ?? false) || ex3.ErrorCode == MySqlErrorCode.CommandTimeoutExpired)
		{
			MetricsReporter.AddTimeout(pool, connectionSettings);
			throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Connect Timeout expired.", ex3);
		}
		catch (MySqlException ex4) when (ex4.ErrorCode == MySqlErrorCode.UnableToConnectToHost && ex4.Message == "Connect Timeout expired.")
		{
			MetricsReporter.AddTimeout(pool, connectionSettings);
			throw;
		}
		finally
		{
			MetricsReporter.RemovePendingRequest(pool);
			linkedSource?.Dispose();
			timeoutSource?.Dispose();
		}
	}

	internal void SetState(ConnectionState newState)
	{
		if (m_connectionState != newState)
		{
			ConnectionState connectionState = m_connectionState;
			m_connectionState = newState;
			StateChangeEventArgs stateChange = ((connectionState == ConnectionState.Closed && newState == ConnectionState.Connecting) ? s_stateChangeClosedConnecting : ((connectionState == ConnectionState.Connecting && newState == ConnectionState.Open) ? s_stateChangeConnectingOpen : ((connectionState == ConnectionState.Open && newState == ConnectionState.Closed) ? s_stateChangeOpenClosed : new StateChangeEventArgs(connectionState, newState))));
			OnStateChange(stateChange);
		}
	}

	private MySqlConnection(MySqlConnection other, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] MySqlDataSource dataSource, string connectionString, bool hasBeenOpened)
		: this(connectionString, other.LoggingConfiguration)
	{
		m_dataSource = dataSource;
		m_hasBeenOpened = hasBeenOpened;
		ProvideClientCertificatesCallback = other.ProvideClientCertificatesCallback;
		ProvidePasswordCallback = other.ProvidePasswordCallback;
		RemoteCertificateValidationCallback = other.RemoteCertificateValidationCallback;
	}

	private void VerifyNotDisposed()
	{
		if (m_isDisposed)
		{
			throw new ObjectDisposedException(GetType().Name);
		}
	}

	private async Task CloseAsync(bool changeState, IOBehavior ioBehavior)
	{
		if (m_activeReader != null || CurrentTransaction != null || m_enlistedTransaction != null || !(m_connectionSettings?.Pooling ?? false))
		{
			await DoCloseAsync(changeState, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
			return;
		}
		m_cachedProcedures = null;
		if (m_session != null)
		{
			await m_session.ReturnToPoolAsync(ioBehavior, this).ConfigureAwait(continueOnCapturedContext: false);
			m_session = null;
		}
		if (changeState)
		{
			SetState(ConnectionState.Closed);
		}
	}

	private async Task DoCloseAsync(bool changeState, IOBehavior ioBehavior)
	{
		if (m_enlistedTransaction != null)
		{
			if (m_activeReader != null)
			{
				await m_activeReader.DisposeAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
			}
			m_activeReader = null;
			MySqlConnection mySqlConnection = new MySqlConnection
			{
				m_connectionString = m_connectionString,
				m_connectionSettings = m_connectionSettings,
				m_connectionState = m_connectionState,
				m_hasBeenOpened = true
			};
			mySqlConnection.TakeSessionFrom(this);
			lock (s_lock)
			{
				foreach (EnlistedTransactionBase item in s_transactionConnections[mySqlConnection.m_enlistedTransaction.Transaction])
				{
					if (item.Connection == this)
					{
						item.Connection = mySqlConnection;
						item.IsIdle = true;
						break;
					}
				}
			}
			if (changeState)
			{
				SetState(ConnectionState.Closed);
			}
			return;
		}
		m_cachedProcedures = null;
		try
		{
			if (m_activeReader != null || CurrentTransaction != null)
			{
				await CloseDatabaseAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
			}
		}
		finally
		{
			if (m_session != null)
			{
				if (GetInitializedConnectionSettings().Pooling)
				{
					await m_session.ReturnToPoolAsync(ioBehavior, this).ConfigureAwait(continueOnCapturedContext: false);
				}
				else
				{
					await m_session.DisposeAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
					m_session.OwningConnection = null;
				}
				m_session = null;
			}
			if (changeState)
			{
				SetState(ConnectionState.Closed);
			}
		}
	}

	private async ValueTask CloseDatabaseAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (m_activeReader != null)
		{
			await m_activeReader.DisposeAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		if (CurrentTransaction != null && m_session.IsConnected)
		{
			await CurrentTransaction.DisposeAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			CurrentTransaction = null;
		}
	}

	private ConnectionSettings GetConnectionSettings()
	{
		return m_connectionSettings ?? (m_connectionSettings = new ConnectionSettings(new MySqlConnectionStringBuilder(m_connectionString)));
	}

	private ConnectionSettings GetInitializedConnectionSettings()
	{
		return m_connectionSettings;
	}
}


public enum MySqlConnectionProtocol
{
	Sockets = 1,
	Socket = 1,
	Tcp = 1,
	Pipe = 2,
	NamedPipe = 2,
	UnixSocket = 3,
	Unix = 3,
	SharedMemory = 4,
	Memory = 4
}


using System;
using System.Collections;
using System.ComponentModel;
using System.Data.Common;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlConnectionStringBuilder : DbConnectionStringBuilder
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private string m_cachedConnectionString;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private string m_cachedConnectionStringWithoutPassword;

	[DefaultValue("")]
	[Description("The host name or network address of the MySQL Server to which to connect.")]
	[DisplayName("Server")]
	[Category("Connection")]
	public string Server
	{
		get
		{
			return MySqlConnectionStringOption.Server.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.Server.SetValue(this, value);
		}
	}

	[DefaultValue(3306L)]
	[DisplayName("Port")]
	[Description("The TCP port on which MySQL Server is listening for connections.")]
	[Category("Connection")]
	public uint Port
	{
		get
		{
			return MySqlConnectionStringOption.Port.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.Port.SetValue(this, value);
		}
	}

	[Category("Connection")]
	[DefaultValue("")]
	[DisplayName("User ID")]
	[Description("The MySQL user ID.")]
	public string UserID
	{
		get
		{
			return MySqlConnectionStringOption.UserID.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.UserID.SetValue(this, value);
		}
	}

	[DisplayName("Password")]
	[DefaultValue("")]
	[Description("The password for the MySQL user.")]
	[Category("Connection")]
	public string Password
	{
		get
		{
			return MySqlConnectionStringOption.Password.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.Password.SetValue(this, value);
		}
	}

	[Description("The case-sensitive name of the initial database to use")]
	[Category("Connection")]
	[DisplayName("Database")]
	[DefaultValue("The case-sensitive name of the initial database to use.")]
	public string Database
	{
		get
		{
			return MySqlConnectionStringOption.Database.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.Database.SetValue(this, value);
		}
	}

	[Description("Specifies how load is distributed across backend servers.")]
	[DefaultValue(MySqlLoadBalance.RoundRobin)]
	[Category("Connection")]
	[DisplayName("Load Balance")]
	public MySqlLoadBalance LoadBalance
	{
		get
		{
			return MySqlConnectionStringOption.LoadBalance.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.LoadBalance.SetValue(this, value);
		}
	}

	[Description("The protocol to use to connect to the MySQL Server.")]
	[DisplayName("Connection Protocol")]
	[Category("Connection")]
	[DefaultValue(MySqlConnectionProtocol.Sockets)]
	public MySqlConnectionProtocol ConnectionProtocol
	{
		get
		{
			return MySqlConnectionStringOption.ConnectionProtocol.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.ConnectionProtocol.SetValue(this, value);
		}
	}

	[DefaultValue("MYSQL")]
	[Category("Connection")]
	[DisplayName("Pipe Name")]
	[Description("The name of the Windows named pipe to use to connect to the server.")]
	public string PipeName
	{
		get
		{
			return MySqlConnectionStringOption.PipeName.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.PipeName.SetValue(this, value);
		}
	}

	[Description("Whether to use SSL/TLS when connecting to the MySQL server.")]
	[DefaultValue(MySqlSslMode.Preferred)]
	[Category("TLS")]
	[DisplayName("SSL Mode")]
	public MySqlSslMode SslMode
	{
		get
		{
			return MySqlConnectionStringOption.SslMode.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.SslMode.SetValue(this, value);
		}
	}

	[DefaultValue("")]
	[Category("TLS")]
	[DisplayName("Certificate File")]
	[Description("The path to a certificate file in PKCS #12 (.pfx) format containing a bundled Certificate and Private Key used for mutual authentication.")]
	public string CertificateFile
	{
		get
		{
			return MySqlConnectionStringOption.CertificateFile.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.CertificateFile.SetValue(this, value);
		}
	}

	[Category("TLS")]
	[DefaultValue("")]
	[Description("The password for the certificate specified using the Certificate File option.")]
	[DisplayName("Certificate Password")]
	public string CertificatePassword
	{
		get
		{
			return MySqlConnectionStringOption.CertificatePassword.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.CertificatePassword.SetValue(this, value);
		}
	}

	[Description("Uses a certificate from the specified Certificate Store on the machine.")]
	[Category("TLS")]
	[DefaultValue(MySqlCertificateStoreLocation.None)]
	[DisplayName("Certificate Store Location")]
	public MySqlCertificateStoreLocation CertificateStoreLocation
	{
		get
		{
			return MySqlConnectionStringOption.CertificateStoreLocation.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.CertificateStoreLocation.SetValue(this, value);
		}
	}

	[DefaultValue("")]
	[DisplayName("Certificate Thumbprint")]
	[Description("Specifies which certificate should be used from the certificate store specified in Certificate Store Location")]
	[Category("TLS")]
	public string CertificateThumbprint
	{
		get
		{
			return MySqlConnectionStringOption.CertificateThumbprint.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.CertificateThumbprint.SetValue(this, value);
		}
	}

	[Description("The path to the clients SSL certificate file in PEM format.")]
	[DisplayName("SSL Cert")]
	[DefaultValue("")]
	[Category("TLS")]
	public string SslCert
	{
		get
		{
			return MySqlConnectionStringOption.SslCert.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.SslCert.SetValue(this, value);
		}
	}

	[Description("The path to the clients SSL private key in PEM format.")]
	[DisplayName("SSL Key")]
	[Category("TLS")]
	[DefaultValue("")]
	public string SslKey
	{
		get
		{
			return MySqlConnectionStringOption.SslKey.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.SslKey.SetValue(this, value);
		}
	}

	[DisplayName("CA Certificate File")]
	[Category("Obsolete")]
	[Obsolete("Use SslCa instead.")]
	[Browsable(false)]
	public string CACertificateFile
	{
		get
		{
			return MySqlConnectionStringOption.SslCa.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.SslCa.SetValue(this, value);
		}
	}

	[DefaultValue("")]
	[DisplayName("SSL CA")]
	[Description("The path to a CA certificate file in a PEM Encoded (.pem) format.")]
	[Category("TLS")]
	public string SslCa
	{
		get
		{
			return MySqlConnectionStringOption.SslCa.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.SslCa.SetValue(this, value);
		}
	}

	[DefaultValue("")]
	[DisplayName("TLS Version")]
	[Description("The TLS versions which may be used during TLS negotiation.")]
	[Category("TLS")]
	public string TlsVersion
	{
		get
		{
			return MySqlConnectionStringOption.TlsVersion.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.TlsVersion.SetValue(this, value);
		}
	}

	[DisplayName("TLS Cipher Suites")]
	[DefaultValue("")]
	[Category("TLS")]
	[Description("The TLS cipher suites which may be used during TLS negotiation.")]
	public string TlsCipherSuites
	{
		get
		{
			return MySqlConnectionStringOption.TlsCipherSuites.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.TlsCipherSuites.SetValue(this, value);
		}
	}

	[DisplayName("Pooling")]
	[Description("Enables connection pooling.")]
	[Category("Pooling")]
	[DefaultValue(true)]
	public bool Pooling
	{
		get
		{
			return MySqlConnectionStringOption.Pooling.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.Pooling.SetValue(this, value);
		}
	}

	[DisplayName("Connection Lifetime")]
	[DefaultValue(0L)]
	[Category("Pooling")]
	[Description("The maximum lifetime (in seconds) for any connection, or 0 for no lifetime limit.")]
	public uint ConnectionLifeTime
	{
		get
		{
			return MySqlConnectionStringOption.ConnectionLifeTime.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.ConnectionLifeTime.SetValue(this, value);
		}
	}

	[DefaultValue(true)]
	[Category("Pooling")]
	[DisplayName("Connection Reset")]
	[Description("Whether connections are reset when being retrieved from the pool.")]
	public bool ConnectionReset
	{
		get
		{
			return MySqlConnectionStringOption.ConnectionReset.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.ConnectionReset.SetValue(this, value);
		}
	}

	[DefaultValue(true)]
	[Category("Obsolete")]
	[DisplayName("Defer Connection Reset")]
	[Obsolete("This option is no longer supported in MySqlConnector >= 1.4.0.")]
	public bool DeferConnectionReset
	{
		get
		{
			return MySqlConnectionStringOption.DeferConnectionReset.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.DeferConnectionReset.SetValue(this, value);
		}
	}

	[DefaultValue(0L)]
	[Category("Obsolete")]
	[DisplayName("Connection Idle Ping Time")]
	[Obsolete("This option is no longer supported in MySqlConnector >= 1.4.0.")]
	public uint ConnectionIdlePingTime
	{
		get
		{
			return MySqlConnectionStringOption.ConnectionIdlePingTime.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.ConnectionIdlePingTime.SetValue(this, value);
		}
	}

	[DefaultValue(180L)]
	[Category("Pooling")]
	[Description("The amount of time (in seconds) that a connection can remain idle in the pool.")]
	[DisplayName("Connection Idle Timeout")]
	public uint ConnectionIdleTimeout
	{
		get
		{
			return MySqlConnectionStringOption.ConnectionIdleTimeout.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.ConnectionIdleTimeout.SetValue(this, value);
		}
	}

	[Category("Pooling")]
	[DisplayName("Minimum Pool Size")]
	[Description("The minimum number of connections to leave in the pool if Connection Idle Timeout is reached.")]
	[DefaultValue(0L)]
	public uint MinimumPoolSize
	{
		get
		{
			return MySqlConnectionStringOption.MinimumPoolSize.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.MinimumPoolSize.SetValue(this, value);
		}
	}

	[DefaultValue(100L)]
	[DisplayName("Maximum Pool Size")]
	[Category("Pooling")]
	[Description("The maximum number of connections allowed in the pool.")]
	public uint MaximumPoolSize
	{
		get
		{
			return MySqlConnectionStringOption.MaximumPoolSize.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.MaximumPoolSize.SetValue(this, value);
		}
	}

	[Description("The number of seconds between checks for DNS changes.")]
	[DefaultValue(0L)]
	[Category("Pooling")]
	[DisplayName("DNS Check Interval")]
	public uint DnsCheckInterval
	{
		get
		{
			return MySqlConnectionStringOption.DnsCheckInterval.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.DnsCheckInterval.SetValue(this, value);
		}
	}

	[DefaultValue(false)]
	[Category("Other")]
	[Description("Allows the LOAD DATA LOCAL command to request files from the client.")]
	[DisplayName("Allow Load Local Infile")]
	public bool AllowLoadLocalInfile
	{
		get
		{
			return MySqlConnectionStringOption.AllowLoadLocalInfile.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.AllowLoadLocalInfile.SetValue(this, value);
		}
	}

	[Description("Allows the client to automatically request the RSA public key from the server.")]
	[DisplayName("Allow Public Key Retrieval")]
	[Category("Other")]
	[DefaultValue(false)]
	public bool AllowPublicKeyRetrieval
	{
		get
		{
			return MySqlConnectionStringOption.AllowPublicKeyRetrieval.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.AllowPublicKeyRetrieval.SetValue(this, value);
		}
	}

	[DisplayName("Allow User Variables")]
	[Description("Allows user-defined variables (prefixed with @) to be used in SQL statements.")]
	[DefaultValue(false)]
	[Category("Other")]
	public bool AllowUserVariables
	{
		get
		{
			return MySqlConnectionStringOption.AllowUserVariables.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.AllowUserVariables.SetValue(this, value);
		}
	}

	[DisplayName("Allow Zero DateTime")]
	[Description("Returns DATETIME fields as MySqlDateTime objects instead of DateTime objects.")]
	[Category("Other")]
	[DefaultValue(false)]
	public bool AllowZeroDateTime
	{
		get
		{
			return MySqlConnectionStringOption.AllowZeroDateTime.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.AllowZeroDateTime.SetValue(this, value);
		}
	}

	[DefaultValue("")]
	[Category("Other")]
	[Description("Sets the program_name connection attribute passed to MySQL Server.")]
	[DisplayName("Application Name")]
	public string ApplicationName
	{
		get
		{
			return MySqlConnectionStringOption.ApplicationName.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.ApplicationName.SetValue(this, value);
		}
	}

	[DisplayName("Auto Enlist")]
	[Category("Other")]
	[DefaultValue(true)]
	[Description("Automatically enlists this connection in any active TransactionScope.")]
	public bool AutoEnlist
	{
		get
		{
			return MySqlConnectionStringOption.AutoEnlist.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.AutoEnlist.SetValue(this, value);
		}
	}

	[DefaultValue(2)]
	[Category("Other")]
	[Description("The length of time (in seconds) to wait for a query to be canceled when MySqlCommand.CommandTimeout expires, or zero for no timeout.")]
	[DisplayName("Cancellation Timeout")]
	public int CancellationTimeout
	{
		get
		{
			return MySqlConnectionStringOption.CancellationTimeout.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.CancellationTimeout.SetValue(this, value);
		}
	}

	[DisplayName("Character Set")]
	[DefaultValue("")]
	[Category("Obsolete")]
	public string CharacterSet
	{
		get
		{
			return MySqlConnectionStringOption.CharacterSet.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.CharacterSet.SetValue(this, value);
		}
	}

	[Description("The length of time (in seconds) to wait for a connection to the server before terminating the attempt and generating an error.")]
	[Category("Connection")]
	[DisplayName("Connection Timeout")]
	[DefaultValue(15L)]
	public uint ConnectionTimeout
	{
		get
		{
			return MySqlConnectionStringOption.ConnectionTimeout.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.ConnectionTimeout.SetValue(this, value);
		}
	}

	[Description("Whether invalid DATETIME fields should be converted to DateTime.MinValue.")]
	[DisplayName("Convert Zero DateTime")]
	[Category("Other")]
	[DefaultValue(false)]
	public bool ConvertZeroDateTime
	{
		get
		{
			return MySqlConnectionStringOption.ConvertZeroDateTime.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.ConvertZeroDateTime.SetValue(this, value);
		}
	}

	[DefaultValue(MySqlDateTimeKind.Unspecified)]
	[Category("Other")]
	[Description("The DateTimeKind to use when deserializing DATETIME values.")]
	[DisplayName("DateTime Kind")]
	public MySqlDateTimeKind DateTimeKind
	{
		get
		{
			return MySqlConnectionStringOption.DateTimeKind.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.DateTimeKind.SetValue(this, value);
		}
	}

	[Category("Other")]
	[DisplayName("Default Command Timeout")]
	[Description("The length of time (in seconds) each command can execute before the query is cancelled on the server, or zero to disable timeouts.")]
	[DefaultValue(30L)]
	public uint DefaultCommandTimeout
	{
		get
		{
			return MySqlConnectionStringOption.DefaultCommandTimeout.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.DefaultCommandTimeout.SetValue(this, value);
		}
	}

	[DefaultValue(false)]
	[Description("Forces all async methods to execute synchronously.")]
	[DisplayName("Force Synchronous")]
	[Category("Other")]
	public bool ForceSynchronous
	{
		get
		{
			return MySqlConnectionStringOption.ForceSynchronous.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.ForceSynchronous.SetValue(this, value);
		}
	}

	[Description("Determines which column type (if any) should be read as a Guid.")]
	[DisplayName("GUID Format")]
	[Category("Other")]
	[DefaultValue(MySqlGuidFormat.Default)]
	public MySqlGuidFormat GuidFormat
	{
		get
		{
			return MySqlConnectionStringOption.GuidFormat.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.GuidFormat.SetValue(this, value);
		}
	}

	[Category("Other")]
	[DefaultValue(false)]
	[DisplayName("Ignore Command Transaction")]
	[Description("Does not check the MySqlCommand.Transaction property for validity when executing a command.")]
	public bool IgnoreCommandTransaction
	{
		get
		{
			return MySqlConnectionStringOption.IgnoreCommandTransaction.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.IgnoreCommandTransaction.SetValue(this, value);
		}
	}

	[Category("Other")]
	[DisplayName("Ignore Prepare")]
	[Description("Ignores calls to MySqlCommand.Prepare and PrepareAsync.")]
	[DefaultValue(false)]
	public bool IgnorePrepare
	{
		get
		{
			return MySqlConnectionStringOption.IgnorePrepare.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.IgnorePrepare.SetValue(this, value);
		}
	}

	[Description("Instructs the MySQL server that this is an interactive session.")]
	[DisplayName("Interactive Session")]
	[Category("Connection")]
	[DefaultValue(false)]
	public bool InteractiveSession
	{
		get
		{
			return MySqlConnectionStringOption.InteractiveSession.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.InteractiveSession.SetValue(this, value);
		}
	}

	[Category("Connection")]
	[DefaultValue(0L)]
	[DisplayName("Keep Alive")]
	[Description("TCP Keepalive idle time (in seconds), or 0 to use OS defaults.")]
	public uint Keepalive
	{
		get
		{
			return MySqlConnectionStringOption.Keepalive.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.Keepalive.SetValue(this, value);
		}
	}

	[Description("Doesn't escape backslashes in string parameters. For use with the NO_BACKSLASH_ESCAPES MySQL server mode.")]
	[Category("Other")]
	[DefaultValue(false)]
	[DisplayName("No Backslash Escapes")]
	public bool NoBackslashEscapes
	{
		get
		{
			return MySqlConnectionStringOption.NoBackslashEscapes.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.NoBackslashEscapes.SetValue(this, value);
		}
	}

	[DefaultValue(false)]
	[DisplayName("Old Guids")]
	[Category("Obsolete")]
	public bool OldGuids
	{
		get
		{
			return MySqlConnectionStringOption.OldGuids.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.OldGuids.SetValue(this, value);
		}
	}

	[DefaultValue(false)]
	[DisplayName("Persist Security Info")]
	[Category("Other")]
	[Description("Preserves security-sensitive information in the connection string retrieved from any open MySqlConnection.")]
	public bool PersistSecurityInfo
	{
		get
		{
			return MySqlConnectionStringOption.PersistSecurityInfo.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.PersistSecurityInfo.SetValue(this, value);
		}
	}

	[Category("Other")]
	[DefaultValue(true)]
	[Description("Enables query pipelining.")]
	[DisplayName("Pipelining")]
	public bool Pipelining
	{
		get
		{
			return MySqlConnectionStringOption.Pipelining.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.Pipelining.SetValue(this, value);
		}
	}

	[DefaultValue(MySqlServerRedirectionMode.Disabled)]
	[Description("Whether to use server redirection.")]
	[DisplayName("Server Redirection Mode")]
	[Category("Connection")]
	public MySqlServerRedirectionMode ServerRedirectionMode
	{
		get
		{
			return MySqlConnectionStringOption.ServerRedirectionMode.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.ServerRedirectionMode.SetValue(this, value);
		}
	}

	[Description("The path to a file containing the server's RSA public key.")]
	[Category("Connection")]
	[DefaultValue("")]
	[DisplayName("Server RSA Public Key File")]
	public string ServerRsaPublicKeyFile
	{
		get
		{
			return MySqlConnectionStringOption.ServerRsaPublicKeyFile.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.ServerRsaPublicKeyFile.SetValue(this, value);
		}
	}

	[Category("Connection")]
	[DisplayName("Server SPN")]
	[DefaultValue("")]
	[Description("The servers Service Principal Name (for auth_gssapi_client authentication).")]
	public string ServerSPN
	{
		get
		{
			return MySqlConnectionStringOption.ServerSPN.GetValue(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption.ServerSPN.SetValue(this, value);
		}
	}

	[DefaultValue(true)]
	[Category("Other")]
	[Description("Returns TINYINT(1) fields as Boolean values.")]
	[DisplayName("Treat Tiny As Boolean")]
	public bool TreatTinyAsBoolean
	{
		get
		{
			return MySqlConnectionStringOption.TreatTinyAsBoolean.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.TreatTinyAsBoolean.SetValue(this, value);
		}
	}

	[DisplayName("Use Affected Rows")]
	[DefaultValue(false)]
	[Category("Other")]
	[Description("Report changed rows instead of found rows.")]
	public bool UseAffectedRows
	{
		get
		{
			return MySqlConnectionStringOption.UseAffectedRows.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.UseAffectedRows.SetValue(this, value);
		}
	}

	[DefaultValue(false)]
	[Category("Other")]
	[DisplayName("Use Compression")]
	[Description("Compress packets sent to and from the server.")]
	public bool UseCompression
	{
		get
		{
			return MySqlConnectionStringOption.UseCompression.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.UseCompression.SetValue(this, value);
		}
	}

	[DefaultValue(true)]
	[Description("Use XA transactions to implement System.Transactions distributed transactions.")]
	[DisplayName("Use XA Transactions")]
	[Category("Other")]
	public bool UseXaTransactions
	{
		get
		{
			return MySqlConnectionStringOption.UseXaTransactions.GetValue(this);
		}
		set
		{
			MySqlConnectionStringOption.UseXaTransactions.SetValue(this, value);
		}
	}

	public override ICollection Keys => (from string x in base.Keys
		orderby MySqlConnectionStringOption.OptionNames.IndexOf(x)
		select x).ToList();

	public override object this[string key]
	{
		get
		{
			return MySqlConnectionStringOption.GetOptionForKey(key).GetObject(this);
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			MySqlConnectionStringOption optionForKey = MySqlConnectionStringOption.GetOptionForKey(key);
			if (value == null)
			{
				base[optionForKey.Key] = null;
			}
			else
			{
				optionForKey.SetObject(this, value);
			}
		}
	}

	public MySqlConnectionStringBuilder()
	{
	}

	public MySqlConnectionStringBuilder(string connectionString)
	{
		base.ConnectionString = connectionString;
	}

	public override bool ContainsKey(string keyword)
	{
		MySqlConnectionStringOption mySqlConnectionStringOption = MySqlConnectionStringOption.TryGetOptionForKey(keyword);
		if (mySqlConnectionStringOption != null)
		{
			return base.ContainsKey(mySqlConnectionStringOption.Key);
		}
		return false;
	}

	public override bool Remove(string keyword)
	{
		MySqlConnectionStringOption mySqlConnectionStringOption = MySqlConnectionStringOption.TryGetOptionForKey(keyword);
		if (mySqlConnectionStringOption != null)
		{
			return base.Remove(mySqlConnectionStringOption.Key);
		}
		return false;
	}

	internal void DoSetValue(string key, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] object value)
	{
		base[key] = value;
	}

	internal string GetConnectionString(bool includePassword)
	{
		string connectionString = base.ConnectionString;
		if (includePassword)
		{
			return connectionString;
		}
		if (m_cachedConnectionString != connectionString)
		{
			MySqlConnectionStringBuilder mySqlConnectionStringBuilder = new MySqlConnectionStringBuilder(connectionString);
			foreach (string key in Keys)
			{
				foreach (string key2 in MySqlConnectionStringOption.Password.Keys)
				{
					if (string.Equals(key, key2, StringComparison.OrdinalIgnoreCase))
					{
						mySqlConnectionStringBuilder.Remove(key);
					}
				}
			}
			m_cachedConnectionStringWithoutPassword = mySqlConnectionStringBuilder.ConnectionString;
			m_cachedConnectionString = connectionString;
		}
		return m_cachedConnectionStringWithoutPassword;
	}

	protected override void GetProperties(Hashtable propertyDescriptors)
	{
		base.GetProperties(propertyDescriptors);
		foreach (PropertyDescriptor item in (from PropertyDescriptor x in propertyDescriptors.Values
			where !x.Attributes.OfType<CategoryAttribute>().Any() || x.Attributes.OfType<ObsoleteAttribute>().Any()
			select x).ToList())
		{
			propertyDescriptors.Remove(item.DisplayName);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using MySqlConnector;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal abstract class MySqlConnectionStringOption
{
	public static readonly MySqlConnectionStringReferenceOption<string> Server;

	public static readonly MySqlConnectionStringValueOption<uint> Port;

	public static readonly MySqlConnectionStringReferenceOption<string> UserID;

	public static readonly MySqlConnectionStringReferenceOption<string> Password;

	public static readonly MySqlConnectionStringReferenceOption<string> Database;

	public static readonly MySqlConnectionStringValueOption<MySqlLoadBalance> LoadBalance;

	public static readonly MySqlConnectionStringValueOption<MySqlConnectionProtocol> ConnectionProtocol;

	public static readonly MySqlConnectionStringReferenceOption<string> PipeName;

	public static readonly MySqlConnectionStringValueOption<MySqlSslMode> SslMode;

	public static readonly MySqlConnectionStringReferenceOption<string> CertificateFile;

	public static readonly MySqlConnectionStringReferenceOption<string> CertificatePassword;

	public static readonly MySqlConnectionStringValueOption<MySqlCertificateStoreLocation> CertificateStoreLocation;

	public static readonly MySqlConnectionStringReferenceOption<string> CertificateThumbprint;

	public static readonly MySqlConnectionStringReferenceOption<string> SslCert;

	public static readonly MySqlConnectionStringReferenceOption<string> SslKey;

	public static readonly MySqlConnectionStringReferenceOption<string> SslCa;

	public static readonly MySqlConnectionStringReferenceOption<string> TlsVersion;

	public static readonly MySqlConnectionStringReferenceOption<string> TlsCipherSuites;

	public static readonly MySqlConnectionStringValueOption<bool> Pooling;

	public static readonly MySqlConnectionStringValueOption<uint> ConnectionLifeTime;

	public static readonly MySqlConnectionStringValueOption<bool> ConnectionReset;

	public static readonly MySqlConnectionStringValueOption<bool> DeferConnectionReset;

	public static readonly MySqlConnectionStringValueOption<uint> ConnectionIdlePingTime;

	public static readonly MySqlConnectionStringValueOption<uint> ConnectionIdleTimeout;

	public static readonly MySqlConnectionStringValueOption<uint> MinimumPoolSize;

	public static readonly MySqlConnectionStringValueOption<uint> MaximumPoolSize;

	public static readonly MySqlConnectionStringValueOption<uint> DnsCheckInterval;

	public static readonly MySqlConnectionStringValueOption<bool> AllowLoadLocalInfile;

	public static readonly MySqlConnectionStringValueOption<bool> AllowPublicKeyRetrieval;

	public static readonly MySqlConnectionStringValueOption<bool> AllowUserVariables;

	public static readonly MySqlConnectionStringValueOption<bool> AllowZeroDateTime;

	public static readonly MySqlConnectionStringReferenceOption<string> ApplicationName;

	public static readonly MySqlConnectionStringValueOption<bool> AutoEnlist;

	public static readonly MySqlConnectionStringValueOption<int> CancellationTimeout;

	public static readonly MySqlConnectionStringReferenceOption<string> CharacterSet;

	public static readonly MySqlConnectionStringValueOption<uint> ConnectionTimeout;

	public static readonly MySqlConnectionStringValueOption<bool> ConvertZeroDateTime;

	public static readonly MySqlConnectionStringValueOption<MySqlDateTimeKind> DateTimeKind;

	public static readonly MySqlConnectionStringValueOption<uint> DefaultCommandTimeout;

	public static readonly MySqlConnectionStringValueOption<bool> ForceSynchronous;

	public static readonly MySqlConnectionStringValueOption<MySqlGuidFormat> GuidFormat;

	public static readonly MySqlConnectionStringValueOption<bool> IgnoreCommandTransaction;

	public static readonly MySqlConnectionStringValueOption<bool> IgnorePrepare;

	public static readonly MySqlConnectionStringValueOption<bool> InteractiveSession;

	public static readonly MySqlConnectionStringValueOption<uint> Keepalive;

	public static readonly MySqlConnectionStringValueOption<bool> NoBackslashEscapes;

	public static readonly MySqlConnectionStringValueOption<bool> OldGuids;

	public static readonly MySqlConnectionStringValueOption<bool> PersistSecurityInfo;

	public static readonly MySqlConnectionStringValueOption<bool> Pipelining;

	public static readonly MySqlConnectionStringValueOption<MySqlServerRedirectionMode> ServerRedirectionMode;

	public static readonly MySqlConnectionStringReferenceOption<string> ServerRsaPublicKeyFile;

	public static readonly MySqlConnectionStringReferenceOption<string> ServerSPN;

	public static readonly MySqlConnectionStringValueOption<bool> TreatTinyAsBoolean;

	public static readonly MySqlConnectionStringValueOption<bool> UseAffectedRows;

	public static readonly MySqlConnectionStringValueOption<bool> UseCompression;

	public static readonly MySqlConnectionStringValueOption<bool> UseXaTransactions;

	private const string c_tlsVersionsRegexPattern = "\\s*TLS( ?v?(1|1\\.?0|1\\.?1|1\\.?2|1\\.?3))?$";

	private static readonly Regex s_tlsVersionsRegex;

	private static readonly Dictionary<string, MySqlConnectionStringOption> s_options;

	private readonly IReadOnlyList<string> m_keys;

	public static List<string> OptionNames { get; }

	public string Key => m_keys[0];

	public IReadOnlyList<string> Keys => m_keys;

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public static MySqlConnectionStringOption TryGetOptionForKey(string key)
	{
		if (!s_options.TryGetValue(key, out var value))
		{
			return null;
		}
		return value;
	}

	public static MySqlConnectionStringOption GetOptionForKey(string key)
	{
		return TryGetOptionForKey(key) ?? throw new ArgumentException("Option '" + key + "' not supported.");
	}

	public abstract object GetObject(MySqlConnectionStringBuilder builder);

	public abstract void SetObject(MySqlConnectionStringBuilder builder, object value);

	protected MySqlConnectionStringOption(IReadOnlyList<string> keys)
	{
		m_keys = keys;
	}

	private static void AddOption(Dictionary<string, MySqlConnectionStringOption> options, MySqlConnectionStringOption option)
	{
		foreach (string key in option.m_keys)
		{
			options.Add(key, option);
		}
		OptionNames.Add(option.m_keys[0]);
	}

	static MySqlConnectionStringOption()
	{
		OptionNames = new List<string>();
		s_tlsVersionsRegex = new Regex("\\s*TLS( ?v?(1|1\\.?0|1\\.?1|1\\.?2|1\\.?3))?$", RegexOptions.IgnoreCase);
		Dictionary<string, MySqlConnectionStringOption> options = new Dictionary<string, MySqlConnectionStringOption>(StringComparer.OrdinalIgnoreCase);
		AddOption(options, Server = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[7] { "Server", "Host", "Data Source", "DataSource", "Address", "Addr", "Network Address" }), ""));
		AddOption(options, Port = new MySqlConnectionStringValueOption<uint>(new <>z__ReadOnlyArray<string>(new string[1] { "Port" }), 3306u));
		AddOption(options, UserID = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[6] { "User ID", "UserID", "Username", "Uid", "User name", "User" }), ""));
		AddOption(options, Password = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[2] { "Password", "pwd" }), ""));
		AddOption(options, Database = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[2] { "Database", "Initial Catalog" }), ""));
		AddOption(options, LoadBalance = new MySqlConnectionStringValueOption<MySqlLoadBalance>(new <>z__ReadOnlyArray<string>(new string[2] { "Load Balance", "LoadBalance" }), MySqlLoadBalance.RoundRobin));
		AddOption(options, ConnectionProtocol = new MySqlConnectionStringValueOption<MySqlConnectionProtocol>(new <>z__ReadOnlyArray<string>(new string[3] { "Connection Protocol", "ConnectionProtocol", "Protocol" }), MySqlConnectionProtocol.Sockets));
		AddOption(options, PipeName = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[3] { "Pipe Name", "PipeName", "Pipe" }), "MYSQL"));
		AddOption(options, SslMode = new MySqlConnectionStringValueOption<MySqlSslMode>(new <>z__ReadOnlyArray<string>(new string[2] { "SSL Mode", "SslMode" }), MySqlSslMode.Preferred));
		AddOption(options, CertificateFile = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[2] { "Certificate File", "CertificateFile" }), ""));
		AddOption(options, CertificatePassword = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[2] { "Certificate Password", "CertificatePassword" }), ""));
		AddOption(options, CertificateStoreLocation = new MySqlConnectionStringValueOption<MySqlCertificateStoreLocation>(new <>z__ReadOnlyArray<string>(new string[2] { "Certificate Store Location", "CertificateStoreLocation" }), MySqlCertificateStoreLocation.None));
		AddOption(options, CertificateThumbprint = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[3] { "Certificate Thumbprint", "CertificateThumbprint", "Certificate Thumb Print" }), ""));
		AddOption(options, SslCert = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[3] { "SSL Cert", "SslCert", "Ssl-Cert" }), ""));
		AddOption(options, SslKey = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[3] { "SSL Key", "SslKey", "Ssl-Key" }), ""));
		AddOption(options, SslCa = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[5] { "SSL CA", "CACertificateFile", "CA Certificate File", "SslCa", "Ssl-Ca" }), ""));
		AddOption(options, TlsVersion = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[3] { "TLS Version", "TlsVersion", "Tls-Version" }), "", ([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string value) =>
		{
			if (string.IsNullOrWhiteSpace(value))
			{
				return "";
			}
			Span<bool> span = stackalloc bool[4];
			string[] array = value.TrimStart('[', '(').TrimEnd(')', ']').Split(new char[1] { ',' });
			foreach (string text in array)
			{
				Match match = TlsVersionsRegex().Match(text);
				if (!match.Success)
				{
					throw new ArgumentException("Unrecognized TlsVersion protocol version '" + text + "'; permitted versions are: TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3.");
				}
				string value2 = match.Groups[2].Value;
				if (value2 == null || value2.Length != 0)
				{
					switch (value2)
					{
					case "1":
					case "10":
					case "1.0":
						break;
					default:
						goto IL_00da;
					}
				}
				bool flag = true;
				goto IL_00dd;
				IL_00da:
				flag = false;
				goto IL_00dd;
				IL_00dd:
				if (flag)
				{
					span[0] = true;
				}
				else if ((value2 == "11" || value2 == "1.1") ? true : false)
				{
					span[1] = true;
				}
				else if ((value2 == "12" || value2 == "1.2") ? true : false)
				{
					span[2] = true;
				}
				else if ((value2 == "13" || value2 == "1.3") ? true : false)
				{
					span[3] = true;
				}
			}
			string text2 = "";
			_ = stackalloc char[7];
			for (int i = 0; i < span.Length; i++)
			{
				if (span[i])
				{
					if (text2.Length != 0)
					{
						text2 += ", ";
					}
					text2 += FormattableString.Invariant($"TLS 1.{i}");
				}
			}
			return text2;
		}));
		AddOption(options, TlsCipherSuites = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[2] { "TLS Cipher Suites", "TlsCipherSuites" }), ""));
		AddOption(options, Pooling = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[1] { "Pooling" }), defaultValue: true));
		AddOption(options, ConnectionLifeTime = new MySqlConnectionStringValueOption<uint>(new <>z__ReadOnlyArray<string>(new string[2] { "Connection Lifetime", "ConnectionLifeTime" }), 0u));
		AddOption(options, ConnectionReset = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Connection Reset", "ConnectionReset" }), defaultValue: true));
		AddOption(options, DeferConnectionReset = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Defer Connection Reset", "DeferConnectionReset" }), defaultValue: true));
		AddOption(options, ConnectionIdlePingTime = new MySqlConnectionStringValueOption<uint>(new <>z__ReadOnlyArray<string>(new string[2] { "Connection Idle Ping Time", "ConnectionIdlePingTime" }), 0u));
		AddOption(options, ConnectionIdleTimeout = new MySqlConnectionStringValueOption<uint>(new <>z__ReadOnlyArray<string>(new string[2] { "Connection Idle Timeout", "ConnectionIdleTimeout" }), 180u));
		AddOption(options, MinimumPoolSize = new MySqlConnectionStringValueOption<uint>(new <>z__ReadOnlyArray<string>(new string[4] { "Minimum Pool Size", "Min Pool Size", "MinimumPoolSize", "minpoolsize" }), 0u));
		AddOption(options, MaximumPoolSize = new MySqlConnectionStringValueOption<uint>(new <>z__ReadOnlyArray<string>(new string[4] { "Maximum Pool Size", "Max Pool Size", "MaximumPoolSize", "maxpoolsize" }), 100u));
		AddOption(options, DnsCheckInterval = new MySqlConnectionStringValueOption<uint>(new <>z__ReadOnlyArray<string>(new string[2] { "DNS Check Interval", "DnsCheckInterval" }), 0u));
		AddOption(options, AllowLoadLocalInfile = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Allow Load Local Infile", "AllowLoadLocalInfile" }), defaultValue: false));
		AddOption(options, AllowPublicKeyRetrieval = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Allow Public Key Retrieval", "AllowPublicKeyRetrieval" }), defaultValue: false));
		AddOption(options, AllowUserVariables = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Allow User Variables", "AllowUserVariables" }), defaultValue: false));
		AddOption(options, AllowZeroDateTime = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Allow Zero DateTime", "AllowZeroDateTime" }), defaultValue: false));
		AddOption(options, ApplicationName = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[2] { "Application Name", "ApplicationName" }), ""));
		AddOption(options, AutoEnlist = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Auto Enlist", "AutoEnlist" }), defaultValue: true));
		AddOption(options, CancellationTimeout = new MySqlConnectionStringValueOption<int>(new <>z__ReadOnlyArray<string>(new string[2] { "Cancellation Timeout", "CancellationTimeout" }), 2, delegate(int x)
		{
			if (x < -1)
			{
				throw new ArgumentOutOfRangeException("CancellationTimeout", "CancellationTimeout must be greater than or equal to -1");
			}
			return x;
		}));
		AddOption(options, CharacterSet = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[3] { "Character Set", "CharSet", "CharacterSet" }), ""));
		AddOption(options, ConnectionTimeout = new MySqlConnectionStringValueOption<uint>(new <>z__ReadOnlyArray<string>(new string[3] { "Connection Timeout", "ConnectionTimeout", "Connect Timeout" }), 15u));
		AddOption(options, ConvertZeroDateTime = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Convert Zero DateTime", "ConvertZeroDateTime" }), defaultValue: false));
		AddOption(options, DateTimeKind = new MySqlConnectionStringValueOption<MySqlDateTimeKind>(new <>z__ReadOnlyArray<string>(new string[2] { "DateTime Kind", "DateTimeKind" }), MySqlDateTimeKind.Unspecified));
		AddOption(options, DefaultCommandTimeout = new MySqlConnectionStringValueOption<uint>(new <>z__ReadOnlyArray<string>(new string[3] { "Default Command Timeout", "DefaultCommandTimeout", "Command Timeout" }), 30u));
		AddOption(options, ForceSynchronous = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Force Synchronous", "ForceSynchronous" }), defaultValue: false));
		AddOption(options, GuidFormat = new MySqlConnectionStringValueOption<MySqlGuidFormat>(new <>z__ReadOnlyArray<string>(new string[2] { "GUID Format", "GuidFormat" }), MySqlGuidFormat.Default));
		AddOption(options, IgnoreCommandTransaction = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Ignore Command Transaction", "IgnoreCommandTransaction" }), defaultValue: false));
		AddOption(options, IgnorePrepare = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Ignore Prepare", "IgnorePrepare" }), defaultValue: false));
		AddOption(options, InteractiveSession = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[3] { "Interactive Session", "InteractiveSession", "Interactive" }), defaultValue: false));
		AddOption(options, Keepalive = new MySqlConnectionStringValueOption<uint>(new <>z__ReadOnlyArray<string>(new string[2] { "Keep Alive", "Keepalive" }), 0u));
		AddOption(options, NoBackslashEscapes = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "No Backslash Escapes", "NoBackslashEscapes" }), defaultValue: false));
		AddOption(options, OldGuids = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Old Guids", "OldGuids" }), defaultValue: false));
		AddOption(options, PersistSecurityInfo = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Persist Security Info", "PersistSecurityInfo" }), defaultValue: false));
		AddOption(options, Pipelining = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[1] { "Pipelining" }), defaultValue: true));
		AddOption(options, ServerRedirectionMode = new MySqlConnectionStringValueOption<MySqlServerRedirectionMode>(new <>z__ReadOnlyArray<string>(new string[2] { "Server Redirection Mode", "ServerRedirectionMode" }), MySqlServerRedirectionMode.Disabled));
		AddOption(options, ServerRsaPublicKeyFile = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[2] { "Server RSA Public Key File", "ServerRsaPublicKeyFile" }), ""));
		AddOption(options, ServerSPN = new MySqlConnectionStringReferenceOption<string>(new <>z__ReadOnlyArray<string>(new string[2] { "Server SPN", "ServerSPN" }), ""));
		AddOption(options, TreatTinyAsBoolean = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Treat Tiny As Boolean", "TreatTinyAsBoolean" }), defaultValue: true));
		AddOption(options, UseAffectedRows = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Use Affected Rows", "UseAffectedRows" }), defaultValue: false));
		AddOption(options, UseCompression = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[3] { "Use Compression", "Compress", "UseCompression" }), defaultValue: false));
		AddOption(options, UseXaTransactions = new MySqlConnectionStringValueOption<bool>(new <>z__ReadOnlyArray<string>(new string[2] { "Use XA Transactions", "UseXaTransactions" }), defaultValue: true));
		s_options = options;
	}

	private static Regex TlsVersionsRegex()
	{
		return s_tlsVersionsRegex;
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using MySqlConnector;

internal sealed class MySqlConnectionStringValueOption<T> : MySqlConnectionStringOption where T : struct
{
	private readonly T m_defaultValue;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 0, 0 })]
	private readonly Func<T, T> m_coerce;

	public MySqlConnectionStringValueOption([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] IReadOnlyList<string> keys, T defaultValue, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 0, 0 })] Func<T, T> coerce = null)
		: base(keys)
	{
		m_defaultValue = defaultValue;
		m_coerce = coerce;
	}

	public T GetValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] MySqlConnectionStringBuilder builder)
	{
		if (!builder.TryGetValue(base.Key, out object value))
		{
			return m_defaultValue;
		}
		return ChangeType(value);
	}

	public void SetValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] MySqlConnectionStringBuilder builder, T value)
	{
		builder.DoSetValue(base.Key, (m_coerce == null) ? value : m_coerce(value));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public override object GetObject(MySqlConnectionStringBuilder builder)
	{
		return GetValue(builder);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public override void SetObject(MySqlConnectionStringBuilder builder, object value)
	{
		SetValue(builder, ChangeType(value));
	}

	private T ChangeType([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] object objectValue)
	{
		if (typeof(T) == typeof(bool) && objectValue is string a)
		{
			if (string.Equals(a, "yes", StringComparison.OrdinalIgnoreCase))
			{
				return (T)(object)true;
			}
			if (string.Equals(a, "no", StringComparison.OrdinalIgnoreCase))
			{
				return (T)(object)false;
			}
		}
		if ((typeof(T) == typeof(MySqlLoadBalance) || typeof(T) == typeof(MySqlSslMode) || typeof(T) == typeof(MySqlServerRedirectionMode) || typeof(T) == typeof(MySqlDateTimeKind) || typeof(T) == typeof(MySqlGuidFormat) || typeof(T) == typeof(MySqlConnectionProtocol) || typeof(T) == typeof(MySqlCertificateStoreLocation)) && objectValue is string value)
		{
			try
			{
				return (T)Enum.Parse(typeof(T), value, ignoreCase: true);
			}
			catch (Exception ex) when (!(ex is ArgumentException))
			{
				throw new ArgumentException(FormattableString.Invariant($"Value '{objectValue}' not supported for option '{typeof(T).Name}'."), ex);
			}
		}
		try
		{
			return (T)Convert.ChangeType(objectValue, typeof(T), CultureInfo.InvariantCulture);
		}
		catch (Exception innerException)
		{
			throw new ArgumentException(FormattableString.Invariant($"Invalid value '{objectValue}' for '{base.Key}' connection string option."), innerException);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class MySqlConnectionStringReferenceOption<T> : MySqlConnectionStringOption where T : class
{
	private readonly T m_defaultValue;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 2, 1 })]
	private readonly Func<T, T> m_coerce;

	public MySqlConnectionStringReferenceOption(IReadOnlyList<string> keys, T defaultValue, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 2, 1 })] Func<T, T> coerce = null)
		: base(keys)
	{
		m_defaultValue = defaultValue;
		m_coerce = coerce;
	}

	public T GetValue(MySqlConnectionStringBuilder builder)
	{
		if (!builder.TryGetValue(base.Key, out object value))
		{
			return m_defaultValue;
		}
		return ChangeType(value);
	}

	public void SetValue(MySqlConnectionStringBuilder builder, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] T value)
	{
		builder.DoSetValue(base.Key, (m_coerce == null) ? value : m_coerce(value));
	}

	public override object GetObject(MySqlConnectionStringBuilder builder)
	{
		return GetValue(builder);
	}

	public override void SetObject(MySqlConnectionStringBuilder builder, object value)
	{
		SetValue(builder, ChangeType(value));
	}

	private static T ChangeType(object objectValue)
	{
		return (T)Convert.ChangeType(objectValue, typeof(T), CultureInfo.InvariantCulture);
	}
}


using System.Data.Common;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlConnectorFactory : DbProviderFactory
{
	public static readonly MySqlConnectorFactory Instance = new MySqlConnectorFactory();

	public override bool CanCreateDataSourceEnumerator => false;

	public new bool CanCreateBatch => true;

	public override DbCommand CreateCommand()
	{
		return new MySqlCommand();
	}

	public override DbConnection CreateConnection()
	{
		return new MySqlConnection();
	}

	public override DbConnectionStringBuilder CreateConnectionStringBuilder()
	{
		return new MySqlConnectionStringBuilder();
	}

	public override DbParameter CreateParameter()
	{
		return new MySqlParameter();
	}

	public override DbCommandBuilder CreateCommandBuilder()
	{
		return new MySqlCommandBuilder();
	}

	public override DbDataAdapter CreateDataAdapter()
	{
		return new MySqlDataAdapter();
	}

	public new MySqlBatch CreateBatch()
	{
		return new MySqlBatch();
	}

	public new MySqlBatchCommand CreateBatchCommand()
	{
		return new MySqlBatchCommand();
	}

	public new DbDataSource CreateDataSource(string connectionString)
	{
		return new MySqlDataSource(connectionString);
	}

	private MySqlConnectorFactory()
	{
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;

[Serializable]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlConversionException : Exception
{
	internal MySqlConversionException(string message)
		: base(message)
	{
	}

	private MySqlConversionException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using MySqlConnector;
using MySqlConnector.Core;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
public sealed class MySqlDataAdapter : DbDataAdapter
{
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	internal sealed class InsertSqlParser : SqlParser
	{
		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
		private readonly MySqlParameterCollection m_parameters;

		public List<int> ParameterIndexes { get; }

		public string CommandText { get; private set; }

		public InsertSqlParser(IMySqlCommand command)
			: base(new StatementPreparer(command.CommandText, null, command.CreateStatementPreparerOptions()))
		{
			CommandText = command.CommandText;
			m_parameters = command.RawParameters;
			ParameterIndexes = new List<int>();
		}

		protected override void OnNamedParameter(int index, int length)
		{
			string parameterName = CommandText.Substring(index, length);
			int item = m_parameters?.NormalizedIndexOf(parameterName) ?? (-1);
			ParameterIndexes.Add(item);
			string text = CommandText.Substring(0, index);
			string text2 = new string(' ', length);
			string commandText = CommandText;
			int num = index + length;
			CommandText = text + text2 + commandText.Substring(num, commandText.Length - num);
		}

		protected override void OnPositionalParameter(int index)
		{
			ParameterIndexes.Add(ParameterIndexes.Count);
			string text = CommandText.Substring(0, index);
			string commandText = CommandText;
			int num = index + 1;
			CommandText = text + " " + commandText.Substring(num, commandText.Length - num);
		}
	}

	private MySqlBatch m_batch;

	public new MySqlCommand DeleteCommand
	{
		get
		{
			return (MySqlCommand)base.DeleteCommand;
		}
		set
		{
			base.DeleteCommand = value;
		}
	}

	public new MySqlCommand InsertCommand
	{
		get
		{
			return (MySqlCommand)base.InsertCommand;
		}
		set
		{
			base.InsertCommand = value;
		}
	}

	public new MySqlCommand SelectCommand
	{
		get
		{
			return (MySqlCommand)base.SelectCommand;
		}
		set
		{
			base.SelectCommand = value;
		}
	}

	public new MySqlCommand UpdateCommand
	{
		get
		{
			return (MySqlCommand)base.UpdateCommand;
		}
		set
		{
			base.UpdateCommand = value;
		}
	}

	public override int UpdateBatchSize { get; set; }

	public event MySqlRowUpdatingEventHandler RowUpdating;

	public event MySqlRowUpdatedEventHandler RowUpdated;

	public MySqlDataAdapter()
	{
		GC.SuppressFinalize(this);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public MySqlDataAdapter(MySqlCommand selectCommand)
		: this()
	{
		SelectCommand = selectCommand;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public MySqlDataAdapter(string selectCommandText, MySqlConnection connection)
		: this(new MySqlCommand(selectCommandText, connection))
	{
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public MySqlDataAdapter(string selectCommandText, string connectionString)
		: this(new MySqlCommand(selectCommandText, new MySqlConnection(connectionString)))
	{
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	protected override void OnRowUpdating(RowUpdatingEventArgs value)
	{
		this.RowUpdating?.Invoke(this, (MySqlRowUpdatingEventArgs)value);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	protected override void OnRowUpdated(RowUpdatedEventArgs value)
	{
		this.RowUpdated?.Invoke(this, (MySqlRowUpdatedEventArgs)value);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	protected override RowUpdatingEventArgs CreateRowUpdatingEvent(DataRow dataRow, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] IDbCommand command, StatementType statementType, DataTableMapping tableMapping)
	{
		return new MySqlRowUpdatingEventArgs(dataRow, command, statementType, tableMapping);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	protected override RowUpdatedEventArgs CreateRowUpdatedEvent(DataRow dataRow, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] IDbCommand command, StatementType statementType, DataTableMapping tableMapping)
	{
		return new MySqlRowUpdatedEventArgs(dataRow, command, statementType, tableMapping);
	}

	protected override void InitializeBatching()
	{
		m_batch = new MySqlBatch();
	}

	protected override void TerminateBatching()
	{
		m_batch?.Dispose();
		m_batch = null;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	protected override int AddToBatch(IDbCommand command)
	{
		MySqlCommand mySqlCommand = (MySqlCommand)command;
		if (m_batch.Connection == null)
		{
			m_batch.Connection = mySqlCommand.Connection;
			m_batch.Transaction = mySqlCommand.Transaction;
		}
		int count = m_batch.BatchCommands.Count;
		MySqlBatchCommand mySqlBatchCommand = new MySqlBatchCommand
		{
			CommandText = command.CommandText,
			CommandType = command.CommandType
		};
		MySqlParameterCollection mySqlParameterCollection = mySqlCommand.CloneRawParameters();
		if (mySqlParameterCollection != null)
		{
			foreach (object item in mySqlParameterCollection)
			{
				mySqlBatchCommand.Parameters.Add(item);
			}
		}
		m_batch.BatchCommands.Add(mySqlBatchCommand);
		return count;
	}

	protected override void ClearBatch()
	{
		m_batch.BatchCommands.Clear();
	}

	protected override int ExecuteBatch()
	{
		MySqlCommand mySqlCommand = TryConvertToCommand(m_batch);
		if (mySqlCommand != null)
		{
			mySqlCommand.Connection = m_batch.Connection;
			mySqlCommand.Transaction = m_batch.Transaction;
			return mySqlCommand.ExecuteNonQuery();
		}
		return m_batch.ExecuteNonQuery();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	internal static MySqlCommand TryConvertToCommand(MySqlBatch batch)
	{
		if (batch.BatchCommands.Count < 1)
		{
			return null;
		}
		MySqlBatchCommand mySqlBatchCommand = batch.BatchCommands[0];
		if (mySqlBatchCommand.Parameters.Count == 0)
		{
			return null;
		}
		mySqlBatchCommand.Batch = batch;
		string commandText = mySqlBatchCommand.CommandText;
		for (int i = 1; i < batch.BatchCommands.Count; i++)
		{
			if (batch.BatchCommands[i].CommandText != commandText)
			{
				return null;
			}
		}
		if (!commandText.StartsWith("INSERT INTO ", StringComparison.OrdinalIgnoreCase))
		{
			return null;
		}
		Match match = Regex.Match(commandText, "\\bVALUES\\s*\\([^)]+\\)\\s*;?\\s*$", RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.CultureInvariant);
		if (!match.Success)
		{
			return null;
		}
		InsertSqlParser insertSqlParser = new InsertSqlParser(mySqlBatchCommand);
		insertSqlParser.Parse(commandText);
		foreach (int parameterIndex in insertSqlParser.ParameterIndexes)
		{
			if (parameterIndex < 0 || parameterIndex >= mySqlBatchCommand.Parameters.Count)
			{
				return null;
			}
		}
		string commandText2 = insertSqlParser.CommandText;
		int num = match.Index + 6;
		if (!string.IsNullOrWhiteSpace(commandText2.Substring(num, commandText2.Length - num).Trim().TrimEnd(new char[1] { ';' })
			.Trim()
			.TrimStart(new char[1] { '(' })
			.TrimEnd(new char[1] { ')' })
			.Replace(",", "")))
		{
			return null;
		}
		MySqlCommand mySqlCommand = new MySqlCommand();
		StringBuilder stringBuilder = new StringBuilder(commandText.Substring(0, match.Index + 6));
		int num2 = 0;
		for (int j = 0; j < batch.BatchCommands.Count; j++)
		{
			MySqlBatchCommand mySqlBatchCommand2 = batch.BatchCommands[j];
			if (j != 0)
			{
				stringBuilder.Append(',');
			}
			stringBuilder.Append('(');
			for (int k = 0; k < insertSqlParser.ParameterIndexes.Count; k++)
			{
				if (k != 0)
				{
					stringBuilder.Append(',');
				}
				string text = "@p" + num2.ToString(CultureInfo.InvariantCulture);
				stringBuilder.Append(text);
				num2++;
				MySqlParameter mySqlParameter = mySqlBatchCommand2.Parameters[insertSqlParser.ParameterIndexes[k]].Clone();
				mySqlParameter.ParameterName = text;
				mySqlCommand.Parameters.Add(mySqlParameter);
			}
			stringBuilder.Append(')');
		}
		stringBuilder.Append(';');
		mySqlCommand.CommandText = stringBuilder.ToString();
		return mySqlCommand;
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector.Core;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class InsertSqlParser : SqlParser
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private readonly MySqlParameterCollection m_parameters;

	public List<int> ParameterIndexes { get; }

	public string CommandText { get; private set; }

	public InsertSqlParser(IMySqlCommand command)
		: base(new StatementPreparer(command.CommandText, null, command.CreateStatementPreparerOptions()))
	{
		CommandText = command.CommandText;
		m_parameters = command.RawParameters;
		ParameterIndexes = new List<int>();
	}

	protected override void OnNamedParameter(int index, int length)
	{
		string parameterName = CommandText.Substring(index, length);
		int item = m_parameters?.NormalizedIndexOf(parameterName) ?? (-1);
		ParameterIndexes.Add(item);
		string text = CommandText.Substring(0, index);
		string text2 = new string(' ', length);
		string commandText = CommandText;
		int num = index + length;
		CommandText = text + text2 + commandText.Substring(num, commandText.Length - num);
	}

	protected override void OnPositionalParameter(int index)
	{
		ParameterIndexes.Add(ParameterIndexes.Count);
		string text = CommandText.Substring(0, index);
		string commandText = CommandText;
		int num = index + 1;
		CommandText = text + " " + commandText.Substring(num, commandText.Length - num);
	}
}


using MySqlConnector;

public delegate void MySqlRowUpdatingEventHandler(object sender, MySqlRowUpdatingEventArgs e);


using MySqlConnector;

public delegate void MySqlRowUpdatedEventHandler(object sender, MySqlRowUpdatedEventArgs e);


using System.Data;
using System.Data.Common;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
public sealed class MySqlRowUpdatingEventArgs : RowUpdatingEventArgs
{
	public new MySqlCommand Command => (MySqlCommand)base.Command;

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public MySqlRowUpdatingEventArgs(DataRow row, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] IDbCommand command, StatementType statementType, DataTableMapping tableMapping)
		: base(row, command, statementType, tableMapping)
	{
	}
}


using System.Data;
using System.Data.Common;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
public sealed class MySqlRowUpdatedEventArgs : RowUpdatedEventArgs
{
	public new MySqlCommand Command => (MySqlCommand)base.Command;

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public MySqlRowUpdatedEventArgs(DataRow row, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] IDbCommand command, StatementType statementType, DataTableMapping tableMapping)
		: base(row, command, statementType, tableMapping)
	{
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Logging;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public sealed class MySqlDataReader : DbDataReader, IDbColumnSchemaGenerator
{
	private readonly ResultSet m_resultSet;

	private CommandBehavior m_behavior;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private ICommandPayloadCreator m_payloadCreator;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 2 })]
	private IDictionary<string, CachedProcedure> m_cachedProcedures;

	private CommandListPosition m_commandListPosition;

	private bool m_closed;

	private bool m_hasWarnings;

	private bool m_hasMoreResults;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private DataTable m_schemaTable;

	public override int FieldCount
	{
		get
		{
			VerifyNotDisposed();
			if (m_resultSet != null)
			{
				if (!m_resultSet.ContainsCommandParameters)
				{
					return m_resultSet.FieldCount;
				}
				return 0;
			}
			throw new InvalidOperationException("There is no current result set.");
		}
	}

	public override object this[int ordinal] => GetResultSet().GetCurrentRow()[ordinal];

	public override object this[string name] => GetResultSet().GetCurrentRow()[name];

	public override bool HasRows
	{
		get
		{
			VerifyNotDisposed();
			if (m_resultSet != null)
			{
				if (!m_resultSet.ContainsCommandParameters)
				{
					return m_resultSet.HasRows;
				}
				return false;
			}
			throw new InvalidOperationException("There is no current result set.");
		}
	}

	public override bool IsClosed => Command == null;

	public override int RecordsAffected
	{
		get
		{
			ulong? realRecordsAffected = RealRecordsAffected;
			if (realRecordsAffected.HasValue)
			{
				ulong valueOrDefault = realRecordsAffected.GetValueOrDefault();
				return checked((int)valueOrDefault);
			}
			return -1;
		}
	}

	public override int Depth => GetResultSet().Depth;

	public override int VisibleFieldCount => FieldCount;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	internal Activity Activity
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		private set;
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	internal IMySqlCommand Command
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		private set;
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	internal MySqlConnection Connection
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get
		{
			return Command?.Connection;
		}
	}

	internal ulong? RealRecordsAffected { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	internal ServerSession Session
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get
		{
			return Command?.Connection.Session;
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	internal PreparedStatement LastUsedPreparedStatement
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get
		{
			return m_commandListPosition.LastUsedPreparedStatement;
		}
	}

	public override bool NextResult()
	{
		Command?.CancellableCommand.ResetCommandTimeout();
		return NextResultAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	public override bool Read()
	{
		VerifyNotDisposed();
		Command.CancellableCommand.ResetCommandTimeout();
		return m_resultSet.Read();
	}

	public override async Task<bool> ReadAsync(CancellationToken cancellationToken)
	{
		VerifyNotDisposed();
		Command.CancellableCommand.ResetCommandTimeout();
		using (Command.CancellableCommand.RegisterCancel(cancellationToken))
		{
			return await m_resultSet.ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
	}

	internal Task<bool> ReadAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		return m_resultSet.ReadAsync(ioBehavior, cancellationToken);
	}

	public override async Task<bool> NextResultAsync(CancellationToken cancellationToken)
	{
		VerifyNotDisposed();
		Command.CancellableCommand.ResetCommandTimeout();
		using (Command.CancellableCommand.RegisterCancel(cancellationToken))
		{
			return await NextResultAsync(Command?.Connection?.AsyncIOBehavior ?? IOBehavior.Asynchronous, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
	}

	internal async Task<bool> NextResultAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		VerifyNotDisposed();
		try
		{
			while (true)
			{
				await m_resultSet.ReadEntireAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				await ScanResultSetAsync(ioBehavior, m_resultSet, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (m_hasMoreResults && m_resultSet.ContainsCommandParameters)
				{
					await ReadOutParametersAsync(Command, m_resultSet, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					continue;
				}
				if (!m_hasMoreResults)
				{
					if (m_commandListPosition.CommandIndex < m_commandListPosition.CommandCount)
					{
						Command = m_commandListPosition.CommandAt(m_commandListPosition.CommandIndex);
						using (Command.CancellableCommand.RegisterCancel(cancellationToken))
						{
							ByteBufferWriter byteBufferWriter = new ByteBufferWriter();
							if (!Command.Connection.Session.IsCancelingQuery && m_payloadCreator.WriteQueryCommand(ref m_commandListPosition, m_cachedProcedures, byteBufferWriter, appendSemicolon: false))
							{
								using PayloadData payload = byteBufferWriter.ToPayloadData();
								await Command.Connection.Session.SendAsync(payload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
								await m_resultSet.ReadResultSetHeaderAsync(ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
								ActivateResultSet(cancellationToken);
								m_hasMoreResults = true;
							}
						}
					}
				}
				else
				{
					ActivateResultSet(cancellationToken);
				}
				if (!m_hasMoreResults || (Command.CommandBehavior & (CommandBehavior.SingleResult | CommandBehavior.SingleRow)) == 0)
				{
					break;
				}
			}
			if (!m_hasMoreResults)
			{
				m_resultSet.Reset();
			}
			m_schemaTable = null;
			return m_hasMoreResults;
		}
		catch (MySqlException)
		{
			m_resultSet.Reset();
			m_hasMoreResults = false;
			m_schemaTable = null;
			throw;
		}
	}

	private void ActivateResultSet(CancellationToken cancellationToken)
	{
		if (m_resultSet.ReadResultSetHeaderException != null)
		{
			MySqlException ex = m_resultSet.ReadResultSetHeaderException.SourceException as MySqlException;
			if (ex?.SqlState == null)
			{
				Command.Connection.SetSessionFailed(m_resultSet.ReadResultSetHeaderException.SourceException);
			}
			if (ex != null && ex.ErrorCode == MySqlErrorCode.QueryInterrupted && cancellationToken.IsCancellationRequested)
			{
				throw new OperationCanceledException(ex.Message, ex, cancellationToken);
			}
			if (ex != null && ex.ErrorCode == MySqlErrorCode.QueryInterrupted && Command.CancellableCommand.IsTimedOut)
			{
				throw MySqlException.CreateForTimeout(ex);
			}
			if (ex != null)
			{
				ServerSession.ThrowIfStatementContainsDelimiter(ex, Command);
				m_resultSet.ReadResultSetHeaderException.Throw();
			}
			throw new MySqlException("Failed to read the result set.", m_resultSet.ReadResultSetHeaderException.SourceException);
		}
		m_hasWarnings = m_resultSet.WarningCount != 0;
	}

	private async ValueTask ScanResultSetAsync(IOBehavior ioBehavior, ResultSet resultSet, CancellationToken cancellationToken)
	{
		if (!m_hasMoreResults)
		{
			return;
		}
		ResultSetState bufferState = resultSet.BufferState;
		if ((bufferState == ResultSetState.None || bufferState == ResultSetState.NoMoreData) ? true : false)
		{
			m_hasMoreResults = false;
			return;
		}
		if (resultSet.BufferState != ResultSetState.HasMoreData)
		{
			throw new InvalidOperationException($"Invalid state: {resultSet.BufferState}");
		}
		using (Command.CancellableCommand.RegisterCancel(cancellationToken))
		{
			try
			{
				await resultSet.ReadResultSetHeaderAsync(ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
				m_hasMoreResults = resultSet.BufferState != ResultSetState.NoMoreData;
			}
			catch (MySqlException ex) when (ex.ErrorCode == MySqlErrorCode.QueryInterrupted)
			{
				m_hasMoreResults = false;
				cancellationToken.ThrowIfCancellationRequested();
				throw;
			}
		}
	}

	public override string GetName(int ordinal)
	{
		return GetResultSet().GetName(ordinal);
	}

	public override int GetValues(object[] values)
	{
		return GetResultSet().GetCurrentRow().GetValues(values);
	}

	public override bool IsDBNull(int ordinal)
	{
		return GetResultSet().GetCurrentRow().IsDBNull(ordinal);
	}

	public override int GetOrdinal(string name)
	{
		return GetResultSet().GetOrdinal(name);
	}

	public override bool GetBoolean(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetBoolean(ordinal);
	}

	public bool GetBoolean(string name)
	{
		return GetBoolean(GetOrdinal(name));
	}

	public override byte GetByte(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetByte(ordinal);
	}

	public byte GetByte(string name)
	{
		return GetByte(GetOrdinal(name));
	}

	public sbyte GetSByte(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetSByte(ordinal);
	}

	public sbyte GetSByte(string name)
	{
		return GetSByte(GetOrdinal(name));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public override long GetBytes(int ordinal, long dataOffset, byte[] buffer, int bufferOffset, int length)
	{
		return GetResultSet().GetCurrentRow().GetBytes(ordinal, dataOffset, buffer, bufferOffset, length);
	}

	public long GetBytes(string name, long dataOffset, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] byte[] buffer, int bufferOffset, int length)
	{
		return GetResultSet().GetCurrentRow().GetBytes(GetOrdinal(name), dataOffset, buffer, bufferOffset, length);
	}

	public override char GetChar(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetChar(ordinal);
	}

	public char GetChar(string name)
	{
		return GetChar(GetOrdinal(name));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public override long GetChars(int ordinal, long dataOffset, char[] buffer, int bufferOffset, int length)
	{
		return GetResultSet().GetCurrentRow().GetChars(ordinal, dataOffset, buffer, bufferOffset, length);
	}

	public override Guid GetGuid(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetGuid(ordinal);
	}

	public Guid GetGuid(string name)
	{
		return GetGuid(GetOrdinal(name));
	}

	public override short GetInt16(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetInt16(ordinal);
	}

	public short GetInt16(string name)
	{
		return GetInt16(GetOrdinal(name));
	}

	public override int GetInt32(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetInt32(ordinal);
	}

	public int GetInt32(string name)
	{
		return GetInt32(GetOrdinal(name));
	}

	public override long GetInt64(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetInt64(ordinal);
	}

	public long GetInt64(string name)
	{
		return GetInt64(GetOrdinal(name));
	}

	public override string GetDataTypeName(int ordinal)
	{
		return GetResultSet().GetDataTypeName(ordinal);
	}

	public Type GetFieldType(string name)
	{
		return GetFieldType(GetOrdinal(name));
	}

	public override Type GetFieldType(int ordinal)
	{
		return GetResultSet().GetFieldType(ordinal);
	}

	public override object GetValue(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetValue(ordinal);
	}

	public override IEnumerator GetEnumerator()
	{
		return new DbEnumerator(this, closeReader: false);
	}

	protected override DbDataReader GetDbDataReader(int ordinal)
	{
		throw new NotSupportedException();
	}

	public override DateTime GetDateTime(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetDateTime(ordinal);
	}

	public DateTime GetDateTime(string name)
	{
		return GetDateTime(GetOrdinal(name));
	}

	public DateTimeOffset GetDateTimeOffset(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetDateTimeOffset(ordinal);
	}

	public DateTimeOffset GetDateTimeOffset(string name)
	{
		return GetDateTimeOffset(GetOrdinal(name));
	}

	public MySqlDateTime GetMySqlDateTime(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetMySqlDateTime(ordinal);
	}

	public MySqlDateTime GetMySqlDateTime(string name)
	{
		return GetMySqlDateTime(GetOrdinal(name));
	}

	public MySqlGeometry GetMySqlGeometry(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetMySqlGeometry(ordinal);
	}

	public MySqlGeometry GetMySqlGeometry(string name)
	{
		return GetMySqlGeometry(GetOrdinal(name));
	}

	public MySqlDecimal GetMySqlDecimal(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetMySqlDecimal(ordinal);
	}

	public MySqlDecimal GetMySqlDecimal(string name)
	{
		return GetMySqlDecimal(GetOrdinal(name));
	}

	public TimeSpan GetTimeSpan(int ordinal)
	{
		return (TimeSpan)GetValue(ordinal);
	}

	public TimeSpan GetTimeSpan(string name)
	{
		return GetTimeSpan(GetOrdinal(name));
	}

	public override Stream GetStream(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetStream(ordinal);
	}

	public Stream GetStream(string name)
	{
		return GetStream(GetOrdinal(name));
	}

	public override TextReader GetTextReader(int ordinal)
	{
		return new StringReader(GetString(ordinal));
	}

	public TextReader GetTextReader(string name)
	{
		return new StringReader(GetString(name));
	}

	public override string GetString(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetString(ordinal);
	}

	public string GetString(string name)
	{
		return GetString(GetOrdinal(name));
	}

	public override decimal GetDecimal(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetDecimal(ordinal);
	}

	public decimal GetDecimal(string name)
	{
		return GetDecimal(GetOrdinal(name));
	}

	public override double GetDouble(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetDouble(ordinal);
	}

	public double GetDouble(string name)
	{
		return GetDouble(GetOrdinal(name));
	}

	public override float GetFloat(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetFloat(ordinal);
	}

	public float GetFloat(string name)
	{
		return GetFloat(GetOrdinal(name));
	}

	public ushort GetUInt16(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetUInt16(ordinal);
	}

	public ushort GetUInt16(string name)
	{
		return GetUInt16(GetOrdinal(name));
	}

	public uint GetUInt32(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetUInt32(ordinal);
	}

	public uint GetUInt32(string name)
	{
		return GetUInt32(GetOrdinal(name));
	}

	public ulong GetUInt64(int ordinal)
	{
		return GetResultSet().GetCurrentRow().GetUInt64(ordinal);
	}

	public ulong GetUInt64(string name)
	{
		return GetUInt64(GetOrdinal(name));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public override DataTable GetSchemaTable()
	{
		return m_schemaTable ?? (m_schemaTable = BuildSchemaTable());
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
	public new Task<DataTable> GetSchemaTableAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		cancellationToken.ThrowIfCancellationRequested();
		return Task.FromResult(GetSchemaTable());
	}

	public override void Close()
	{
		DisposeAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	public ReadOnlyCollection<DbColumn> GetColumnSchema()
	{
		if (!m_resultSet.HasResultSet || m_resultSet.ContainsCommandParameters)
		{
			return new ReadOnlyCollection<DbColumn>(new List<DbColumn>());
		}
		ReadOnlySpan<ColumnDefinitionPayload> columnDefinitions = m_resultSet.ColumnDefinitions;
		ResultSet resultSet = GetResultSet();
		List<DbColumn> list = new List<DbColumn>(columnDefinitions.Length);
		for (int i = 0; i < columnDefinitions.Length; i++)
		{
			list.Add(new MySqlDbColumn(i, columnDefinitions[i], Connection.AllowZeroDateTime, resultSet.GetColumnType(i)));
		}
		return list.AsReadOnly();
	}

	public new Task<ReadOnlyCollection<DbColumn>> GetColumnSchemaAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		cancellationToken.ThrowIfCancellationRequested();
		return Task.FromResult(GetColumnSchema());
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public override T GetFieldValue<T>(int ordinal)
	{
		if (typeof(T) == typeof(bool))
		{
			return (T)(object)GetBoolean(ordinal);
		}
		if (typeof(T) == typeof(byte))
		{
			return (T)(object)GetByte(ordinal);
		}
		if (typeof(T) == typeof(sbyte))
		{
			return (T)(object)GetSByte(ordinal);
		}
		if (typeof(T) == typeof(short))
		{
			return (T)(object)GetInt16(ordinal);
		}
		if (typeof(T) == typeof(ushort))
		{
			return (T)(object)GetUInt16(ordinal);
		}
		if (typeof(T) == typeof(int))
		{
			return (T)(object)GetInt32(ordinal);
		}
		if (typeof(T) == typeof(uint))
		{
			return (T)(object)GetUInt32(ordinal);
		}
		if (typeof(T) == typeof(long))
		{
			return (T)(object)GetInt64(ordinal);
		}
		if (typeof(T) == typeof(ulong))
		{
			return (T)(object)GetUInt64(ordinal);
		}
		if (typeof(T) == typeof(char))
		{
			return (T)(object)GetChar(ordinal);
		}
		if (typeof(T) == typeof(decimal))
		{
			return (T)(object)GetDecimal(ordinal);
		}
		if (typeof(T) == typeof(double))
		{
			return (T)(object)GetDouble(ordinal);
		}
		if (typeof(T) == typeof(float))
		{
			return (T)(object)GetFloat(ordinal);
		}
		if (typeof(T) == typeof(string))
		{
			return (T)(object)GetString(ordinal);
		}
		if (typeof(T) == typeof(DateTime))
		{
			return (T)(object)GetDateTime(ordinal);
		}
		if (typeof(T) == typeof(DateTimeOffset))
		{
			return (T)(object)GetDateTimeOffset(ordinal);
		}
		if (typeof(T) == typeof(Guid))
		{
			return (T)(object)GetGuid(ordinal);
		}
		if (typeof(T) == typeof(MySqlGeometry))
		{
			return (T)(object)GetMySqlGeometry(ordinal);
		}
		if (typeof(T) == typeof(Stream))
		{
			return (T)(object)GetStream(ordinal);
		}
		if (typeof(T) == typeof(TextReader) || typeof(T) == typeof(StringReader))
		{
			return (T)(object)GetTextReader(ordinal);
		}
		if (typeof(T) == typeof(TimeSpan))
		{
			return (T)(object)GetTimeSpan(ordinal);
		}
		if (typeof(T) == typeof(MySqlDecimal))
		{
			return (T)(object)GetMySqlDecimal(ordinal);
		}
		return base.GetFieldValue<T>(ordinal);
	}

	protected override void Dispose(bool disposing)
	{
		try
		{
			if (disposing)
			{
				DisposeAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
			}
		}
		finally
		{
			base.Dispose(disposing);
		}
	}

	public new Task DisposeAsync()
	{
		return DisposeAsync(Connection?.AsyncIOBehavior ?? IOBehavior.Asynchronous, CancellationToken.None);
	}

	internal async Task InitAsync(CommandListPosition commandListPosition, ICommandPayloadCreator payloadCreator, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 2 })] IDictionary<string, CachedProcedure> cachedProcedures, IMySqlCommand command, CommandBehavior behavior, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Activity activity, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (m_hasMoreResults)
		{
			throw new InvalidOperationException("Expected m_hasMoreResults to be false");
		}
		if (m_resultSet.BufferState != 0 || m_resultSet.State != 0)
		{
			throw new InvalidOperationException("Expected BufferState and State to be ResultSetState.None.");
		}
		m_closed = false;
		m_hasWarnings = false;
		RealRecordsAffected = null;
		m_commandListPosition = commandListPosition;
		m_payloadCreator = payloadCreator;
		m_cachedProcedures = cachedProcedures;
		Command = command;
		m_behavior = behavior;
		Activity = activity;
		command.Connection.SetActiveReader(this);
		try
		{
			await m_resultSet.ReadResultSetHeaderAsync(ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
			ActivateResultSet(cancellationToken);
			m_hasMoreResults = true;
			if (m_resultSet.ContainsCommandParameters)
			{
				await ReadOutParametersAsync(command, m_resultSet, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			while (m_resultSet.State == ResultSetState.NoMoreData && commandListPosition.CommandIndex < commandListPosition.CommandCount)
			{
				await NextResultAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
		}
		catch (Exception exception)
		{
			if (activity != null && activity.IsAllDataRequested)
			{
				activity.SetException(exception);
				activity.Stop();
			}
			Dispose();
			throw;
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	internal DataTable BuildSchemaTable()
	{
		if (!m_resultSet.HasResultSet || m_resultSet.ContainsCommandParameters)
		{
			return null;
		}
		DataTable dataTable = new DataTable("SchemaTable")
		{
			Locale = CultureInfo.InvariantCulture,
			MinimumCapacity = m_resultSet.ColumnDefinitions.Length
		};
		DataColumn column = new DataColumn(SchemaTableColumn.ColumnName, typeof(string));
		DataColumn dataColumn = new DataColumn(SchemaTableColumn.ColumnOrdinal, typeof(int));
		DataColumn column2 = new DataColumn(SchemaTableColumn.ColumnSize, typeof(int));
		DataColumn dataColumn2 = new DataColumn(SchemaTableColumn.NumericPrecision, typeof(int));
		DataColumn dataColumn3 = new DataColumn(SchemaTableColumn.NumericScale, typeof(int));
		DataColumn column3 = new DataColumn(SchemaTableColumn.DataType, typeof(Type));
		DataColumn column4 = new DataColumn(SchemaTableColumn.ProviderType, typeof(int));
		DataColumn dataColumn4 = new DataColumn(SchemaTableColumn.IsLong, typeof(bool));
		DataColumn column5 = new DataColumn(SchemaTableColumn.AllowDBNull, typeof(bool));
		DataColumn column6 = new DataColumn(SchemaTableOptionalColumn.IsReadOnly, typeof(bool));
		DataColumn column7 = new DataColumn(SchemaTableOptionalColumn.IsRowVersion, typeof(bool));
		DataColumn column8 = new DataColumn(SchemaTableColumn.IsUnique, typeof(bool));
		DataColumn column9 = new DataColumn(SchemaTableColumn.IsKey, typeof(bool));
		DataColumn column10 = new DataColumn(SchemaTableOptionalColumn.IsAutoIncrement, typeof(bool));
		DataColumn column11 = new DataColumn(SchemaTableOptionalColumn.IsHidden, typeof(bool));
		DataColumn column12 = new DataColumn(SchemaTableOptionalColumn.BaseCatalogName, typeof(string));
		DataColumn column13 = new DataColumn(SchemaTableColumn.BaseSchemaName, typeof(string));
		DataColumn column14 = new DataColumn(SchemaTableColumn.BaseTableName, typeof(string));
		DataColumn column15 = new DataColumn(SchemaTableColumn.BaseColumnName, typeof(string));
		DataColumn column16 = new DataColumn(SchemaTableColumn.IsAliased, typeof(bool));
		DataColumn column17 = new DataColumn(SchemaTableColumn.IsExpression, typeof(bool));
		DataColumn column18 = new DataColumn("IsIdentity", typeof(bool));
		dataColumn.DefaultValue = 0;
		dataColumn2.DefaultValue = 0;
		dataColumn3.DefaultValue = 0;
		dataColumn4.DefaultValue = false;
		DataColumnCollection columns = dataTable.Columns;
		columns.Add(column);
		columns.Add(dataColumn);
		columns.Add(column2);
		columns.Add(dataColumn2);
		columns.Add(dataColumn3);
		columns.Add(column8);
		columns.Add(column9);
		columns.Add(column12);
		columns.Add(column15);
		columns.Add(column13);
		columns.Add(column14);
		columns.Add(column3);
		columns.Add(column5);
		columns.Add(column4);
		columns.Add(column16);
		columns.Add(column17);
		columns.Add(column18);
		columns.Add(column10);
		columns.Add(column7);
		columns.Add(column11);
		columns.Add(dataColumn4);
		columns.Add(column6);
		foreach (MySqlDbColumn item in GetColumnSchema())
		{
			DataRow dataRow = dataTable.NewRow();
			dataRow[column] = item.ColumnName;
			dataRow[dataColumn] = item.ColumnOrdinal;
			dataRow[column3] = item.DataType;
			dataRow[column2] = item.ColumnSize;
			dataRow[column4] = item.ProviderType;
			dataRow[dataColumn4] = item.IsLong;
			dataRow[column8] = false;
			dataRow[column9] = item.IsKey;
			dataRow[column5] = item.AllowDBNull;
			dataRow[dataColumn3] = item.NumericScale;
			dataRow[dataColumn2] = item.NumericPrecision.GetValueOrDefault();
			dataRow[column12] = item.BaseCatalogName;
			dataRow[column15] = item.BaseColumnName;
			dataRow[column13] = item.BaseSchemaName;
			dataRow[column14] = item.BaseTableName;
			dataRow[column10] = item.IsAutoIncrement;
			dataRow[column7] = false;
			dataRow[column6] = item.IsReadOnly;
			dataTable.Rows.Add(dataRow);
			dataRow.AcceptChanges();
		}
		return dataTable;
	}

	internal MySqlDataReader()
	{
		m_resultSet = new ResultSet(this);
	}

	internal async Task DisposeAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (m_closed)
		{
			return;
		}
		m_closed = true;
		if (m_resultSet != null && Command.Connection.State == ConnectionState.Open)
		{
			Command.Connection.Session.SetTimeout(int.MaxValue);
			try
			{
				while (await NextResultAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
				{
				}
			}
			catch (MySqlException ex)
			{
				if (ex.ErrorCode != MySqlErrorCode.QueryInterrupted)
				{
					Log.IgnoringExceptionInDisposeAsync(Command.Logger, ex, Command.Connection.Session.Id, ex.Message, Command.CommandText);
				}
			}
		}
		m_hasMoreResults = false;
		MySqlConnection connection = Command.Connection;
		Command.CancellableCommand.SetTimeout(int.MaxValue);
		connection.FinishQuerying(m_hasWarnings);
		Activity?.Stop();
		Activity = null;
		if ((m_behavior & CommandBehavior.CloseConnection) != 0)
		{
			await connection.CloseAsync(ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
		}
		Command = null;
		m_commandListPosition = default(CommandListPosition);
		m_payloadCreator = null;
		m_cachedProcedures = null;
	}

	private static async Task ReadOutParametersAsync(IMySqlCommand command, ResultSet resultSet, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		await resultSet.ReadAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		Row currentRow = resultSet.GetCurrentRow();
		if (currentRow.GetString(0) != SingleCommandPayloadCreator.OutParameterSentinelColumnName)
		{
			throw new InvalidOperationException("Expected out parameter values.");
		}
		for (int i = 0; i < command.OutParameters.Count; i++)
		{
			MySqlParameter mySqlParameter = command.OutParameters[i];
			int ordinal = i + 1;
			if (mySqlParameter.HasSetDbType && !currentRow.IsDBNull(ordinal))
			{
				DbTypeMapping dbTypeMapping = TypeMapper.Instance.GetDbTypeMapping(mySqlParameter.DbType);
				if (dbTypeMapping != null)
				{
					mySqlParameter.Value = dbTypeMapping.DoConversion(currentRow.GetValue(ordinal));
					continue;
				}
			}
			mySqlParameter.Value = currentRow.GetValue(ordinal);
		}
		if (await resultSet.ReadAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
		{
			throw new InvalidOperationException("Expected only one row.");
		}
	}

	private void VerifyNotDisposed()
	{
		if (Command == null)
		{
			throw new InvalidOperationException("Can't call this method when MySqlDataReader is closed.");
		}
	}

	private ResultSet GetResultSet()
	{
		VerifyNotDisposed();
		if (m_resultSet != null && !m_resultSet.ContainsCommandParameters)
		{
			return m_resultSet;
		}
		throw new InvalidOperationException("There is no current result set.");
	}
}


using System;
using System.Data.Common;
using System.Net.Security;
using System.Runtime.CompilerServices;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Logging;
using MySqlConnector.Protocol.Serialization;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public sealed class MySqlDataSource : DbDataSource
{
	private static int s_lastId;

	private readonly ILogger m_logger;

	private readonly int m_id;

	private readonly string m_connectionString;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	private readonly Func<X509CertificateCollection, ValueTask> m_clientCertificatesCallback;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private readonly RemoteCertificateValidationCallback m_remoteCertificateValidationCallback;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 0, 1 })]
	private readonly Func<MySqlProvidePasswordContext, CancellationToken, ValueTask<string>> m_periodicPasswordProvider;

	private readonly TimeSpan m_periodicPasswordProviderSuccessRefreshInterval;

	private readonly TimeSpan m_periodicPasswordProviderFailureRefreshInterval;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private readonly MySqlProvidePasswordContext m_providePasswordContext;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private readonly CancellationTokenSource m_passwordProviderTimerCancellationTokenSource;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private readonly Timer m_passwordProviderTimer;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private readonly Task m_initialPasswordRefreshTask;

	private bool m_isDisposed;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private string m_password;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 1 })]
	private Func<MySqlProvidePasswordContext, string> m_providePasswordCallback;

	public override string ConnectionString => m_connectionString;

	public string Password
	{
		set
		{
			if (m_periodicPasswordProvider != null)
			{
				throw new InvalidOperationException("Cannot set Password when this MySqlDataSource is configured with a PeriodicPasswordProvider.");
			}
			m_password = value ?? throw new ArgumentNullException("value");
			m_providePasswordCallback = ProvidePasswordFromField;
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	internal ConnectionPool Pool
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
	}

	internal MySqlConnectorLoggingConfiguration LoggingConfiguration { get; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	internal string Name
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
	}

	public MySqlDataSource(string connectionString)
		: this(connectionString ?? throw new ArgumentNullException("connectionString"), MySqlConnectorLoggingConfiguration.NullConfiguration, null, null, null, null, default(TimeSpan), default(TimeSpan))
	{
	}

	internal MySqlDataSource(string connectionString, MySqlConnectorLoggingConfiguration loggingConfiguration, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string name, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })] Func<X509CertificateCollection, ValueTask> clientCertificatesCallback, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] RemoteCertificateValidationCallback remoteCertificateValidationCallback, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 0, 1 })] Func<MySqlProvidePasswordContext, CancellationToken, ValueTask<string>> periodicPasswordProvider, TimeSpan periodicPasswordProviderSuccessRefreshInterval, TimeSpan periodicPasswordProviderFailureRefreshInterval)
	{
		m_connectionString = connectionString;
		LoggingConfiguration = loggingConfiguration;
		Name = name;
		m_clientCertificatesCallback = clientCertificatesCallback;
		m_remoteCertificateValidationCallback = remoteCertificateValidationCallback;
		m_logger = loggingConfiguration.DataSourceLogger;
		Pool = ConnectionPool.CreatePool(m_connectionString, LoggingConfiguration, name);
		m_id = Interlocked.Increment(ref s_lastId);
		if (Pool != null && Name != null)
		{
			Log.DataSourceCreatedWithPoolWithName(m_logger, m_id, Pool.Id, Name);
		}
		else if (Pool != null)
		{
			Log.DataSourceCreatedWithPoolWithoutName(m_logger, m_id, Pool.Id);
		}
		else if (Name != null)
		{
			Log.DataSourceCreatedWithoutPoolWithName(m_logger, m_id, Name);
		}
		else
		{
			Log.DataSourceCreatedWithoutPoolWithoutName(m_logger, m_id);
		}
		if (periodicPasswordProvider != null)
		{
			m_periodicPasswordProvider = periodicPasswordProvider;
			m_periodicPasswordProviderSuccessRefreshInterval = periodicPasswordProviderSuccessRefreshInterval;
			m_periodicPasswordProviderFailureRefreshInterval = periodicPasswordProviderFailureRefreshInterval;
			m_passwordProviderTimerCancellationTokenSource = new CancellationTokenSource();
			MySqlConnectionStringBuilder mySqlConnectionStringBuilder = new MySqlConnectionStringBuilder(m_connectionString);
			m_providePasswordContext = new MySqlProvidePasswordContext(mySqlConnectionStringBuilder.Server, (int)mySqlConnectionStringBuilder.Port, mySqlConnectionStringBuilder.UserID, mySqlConnectionStringBuilder.Database);
			m_passwordProviderTimer = new Timer([<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)] (object _) =>
			{
				_ = RefreshPassword();
			}, null, Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
			m_initialPasswordRefreshTask = Task.Run((Func<Task?>)RefreshPassword);
			m_providePasswordCallback = ProvidePasswordFromInitialRefreshTask;
		}
	}

	public new MySqlConnection CreateConnection()
	{
		return (MySqlConnection)base.CreateConnection();
	}

	public new MySqlConnection OpenConnection()
	{
		return (MySqlConnection)base.OpenConnection();
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public new async ValueTask<MySqlConnection> OpenConnectionAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return (MySqlConnection)(await base.OpenConnectionAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
	}

	protected override DbConnection CreateDbConnection()
	{
		if (m_isDisposed)
		{
			throw new ObjectDisposedException("MySqlDataSource");
		}
		return new MySqlConnection(this)
		{
			ProvideClientCertificatesCallback = m_clientCertificatesCallback,
			ProvidePasswordCallback = m_providePasswordCallback,
			RemoteCertificateValidationCallback = m_remoteCertificateValidationCallback
		};
	}

	protected override void Dispose(bool disposing)
	{
		try
		{
			if (disposing)
			{
				DisposeAsync(IOBehavior.Synchronous).GetAwaiter().GetResult();
			}
		}
		finally
		{
			base.Dispose(disposing);
		}
	}

	protected override ValueTask DisposeAsyncCore()
	{
		return DisposeAsync(IOBehavior.Asynchronous);
	}

	private async ValueTask DisposeAsync(IOBehavior ioBehavior)
	{
		CancellationTokenSource passwordProviderTimerCancellationTokenSource = m_passwordProviderTimerCancellationTokenSource;
		if (passwordProviderTimerCancellationTokenSource != null)
		{
			passwordProviderTimerCancellationTokenSource.Cancel();
			passwordProviderTimerCancellationTokenSource.Dispose();
		}
		if (Pool != null)
		{
			await Pool.ClearAsync(ioBehavior, default(CancellationToken)).ConfigureAwait(continueOnCapturedContext: false);
			Pool.Dispose();
		}
		m_isDisposed = true;
	}

	private async Task RefreshPassword()
	{
		try
		{
			m_password = await m_periodicPasswordProvider(m_providePasswordContext, m_passwordProviderTimerCancellationTokenSource.Token).ConfigureAwait(continueOnCapturedContext: false);
			m_providePasswordCallback = ProvidePasswordFromField;
			m_passwordProviderTimer.Change(m_periodicPasswordProviderSuccessRefreshInterval, Timeout.InfiniteTimeSpan);
		}
		catch (Exception ex)
		{
			Log.PeriodicPasswordProviderFailed(m_logger, ex, m_id, ex.Message);
			m_passwordProviderTimer.Change(m_periodicPasswordProviderFailureRefreshInterval, Timeout.InfiniteTimeSpan);
			throw new MySqlException("The periodic password provider failed", ex);
		}
	}

	private string ProvidePasswordFromField(MySqlProvidePasswordContext context)
	{
		return m_password;
	}

	private string ProvidePasswordFromInitialRefreshTask(MySqlProvidePasswordContext context)
	{
		if (m_password == null)
		{
			m_initialPasswordRefreshTask.GetAwaiter().GetResult();
			m_providePasswordCallback = ProvidePasswordFromField;
		}
		return m_password;
	}
}


using System;
using System.Net.Security;
using System.Runtime.CompilerServices;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using MySqlConnector.Logging;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlDataSourceBuilder
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private ILoggerFactory m_loggerFactory;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private string m_name;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	private Func<X509CertificateCollection, ValueTask> m_clientCertificatesCallback;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private RemoteCertificateValidationCallback m_remoteCertificateValidationCallback;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 0, 1 })]
	private Func<MySqlProvidePasswordContext, CancellationToken, ValueTask<string>> m_periodicPasswordProvider;

	private TimeSpan m_periodicPasswordProviderSuccessRefreshInterval;

	private TimeSpan m_periodicPasswordProviderFailureRefreshInterval;

	public MySqlConnectionStringBuilder ConnectionStringBuilder { get; }

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public MySqlDataSourceBuilder(string connectionString = null)
	{
		ConnectionStringBuilder = new MySqlConnectionStringBuilder(connectionString ?? "");
	}

	public MySqlDataSourceBuilder UseLoggerFactory([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] ILoggerFactory loggerFactory)
	{
		m_loggerFactory = loggerFactory;
		return this;
	}

	public MySqlDataSourceBuilder UseName([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string name)
	{
		m_name = name;
		return this;
	}

	public MySqlDataSourceBuilder UseClientCertificatesCallback([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })] Func<X509CertificateCollection, ValueTask> callback)
	{
		m_clientCertificatesCallback = callback;
		return this;
	}

	public MySqlDataSourceBuilder UsePeriodicPasswordProvider([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 0, 1 })] Func<MySqlProvidePasswordContext, CancellationToken, ValueTask<string>> passwordProvider, TimeSpan successRefreshInterval, TimeSpan failureRefreshInterval)
	{
		m_periodicPasswordProvider = passwordProvider;
		m_periodicPasswordProviderSuccessRefreshInterval = successRefreshInterval;
		m_periodicPasswordProviderFailureRefreshInterval = failureRefreshInterval;
		return this;
	}

	public MySqlDataSourceBuilder UseRemoteCertificateValidationCallback(RemoteCertificateValidationCallback callback)
	{
		m_remoteCertificateValidationCallback = callback;
		return this;
	}

	public MySqlDataSource Build()
	{
		MySqlConnectorLoggingConfiguration loggingConfiguration = ((m_loggerFactory == null) ? MySqlConnectorLoggingConfiguration.NullConfiguration : new MySqlConnectorLoggingConfiguration(m_loggerFactory));
		return new MySqlDataSource(ConnectionStringBuilder.ConnectionString, loggingConfiguration, m_name, m_clientCertificatesCallback, m_remoteCertificateValidationCallback, m_periodicPasswordProvider, m_periodicPasswordProviderSuccessRefreshInterval, m_periodicPasswordProviderFailureRefreshInterval);
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
public struct MySqlDateTime : IComparable, IComparable<MySqlDateTime>, IConvertible, IEquatable<MySqlDateTime>
{
	public readonly bool IsValidDateTime
	{
		get
		{
			if (Year != 0 && Month != 0)
			{
				return Day != 0;
			}
			return false;
		}
	}

	public int Year { get; set; }

	public int Month { get; set; }

	public int Day { get; set; }

	public int Hour { get; set; }

	public int Minute { get; set; }

	public int Second { get; set; }

	public int Microsecond { get; set; }

	public int Millisecond
	{
		readonly get
		{
			return Microsecond / 1000;
		}
		set
		{
			Microsecond = value * 1000;
		}
	}

	public MySqlDateTime(int year, int month, int day, int hour, int minute, int second, int microsecond)
	{
		Year = year;
		Month = month;
		Day = day;
		Hour = hour;
		Minute = minute;
		Second = second;
		Microsecond = microsecond;
	}

	public MySqlDateTime(DateTime dt)
		: this(dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, (int)(dt.Ticks % 10000000) / 10)
	{
	}

	public MySqlDateTime(MySqlDateTime other)
		: this(other.Year, other.Month, other.Day, other.Hour, other.Minute, other.Second, other.Microsecond)
	{
	}

	public readonly DateTime GetDateTime()
	{
		if (IsValidDateTime)
		{
			return new DateTime(Year, Month, Day, Hour, Minute, Second, DateTimeKind.Unspecified).AddTicks(Microsecond * 10);
		}
		throw new MySqlConversionException("Cannot convert MySqlDateTime to DateTime when IsValidDateTime is false.");
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public override readonly string ToString()
	{
		if (!IsValidDateTime)
		{
			return "0000-00-00";
		}
		return GetDateTime().ToString();
	}

	public static explicit operator DateTime(MySqlDateTime val)
	{
		if (val.IsValidDateTime)
		{
			return val.GetDateTime();
		}
		return DateTime.MinValue;
	}

	public override bool Equals(object obj)
	{
		if (obj is MySqlDateTime other)
		{
			return ((IEquatable<MySqlDateTime>)this).Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (((((((((((Year * 33) ^ Month) * 33) ^ Day) * 33) ^ Hour) * 33) ^ Minute) * 33) ^ Second) * 33) ^ Microsecond;
	}

	public static bool operator ==(MySqlDateTime left, MySqlDateTime right)
	{
		return ((IComparable<MySqlDateTime>)left).CompareTo(right) == 0;
	}

	public static bool operator !=(MySqlDateTime left, MySqlDateTime right)
	{
		return ((IComparable<MySqlDateTime>)left).CompareTo(right) != 0;
	}

	public static bool operator <(MySqlDateTime left, MySqlDateTime right)
	{
		return ((IComparable<MySqlDateTime>)left).CompareTo(right) < 0;
	}

	public static bool operator <=(MySqlDateTime left, MySqlDateTime right)
	{
		return ((IComparable<MySqlDateTime>)left).CompareTo(right) <= 0;
	}

	public static bool operator >(MySqlDateTime left, MySqlDateTime right)
	{
		return ((IComparable<MySqlDateTime>)left).CompareTo(right) > 0;
	}

	public static bool operator >=(MySqlDateTime left, MySqlDateTime right)
	{
		return ((IComparable<MySqlDateTime>)left).CompareTo(right) >= 0;
	}

	readonly int IComparable.CompareTo(object obj)
	{
		if (!(obj is MySqlDateTime other))
		{
			throw new ArgumentException("CompareTo can only be called with another MySqlDateTime", "obj");
		}
		return ((IComparable<MySqlDateTime>)this).CompareTo(other);
	}

	readonly int IComparable<MySqlDateTime>.CompareTo(MySqlDateTime other)
	{
		if (Year < other.Year)
		{
			return -1;
		}
		if (Year > other.Year)
		{
			return 1;
		}
		if (Month < other.Month)
		{
			return -1;
		}
		if (Month > other.Month)
		{
			return 1;
		}
		if (Day < other.Day)
		{
			return -1;
		}
		if (Day > other.Day)
		{
			return 1;
		}
		if (Hour < other.Hour)
		{
			return -1;
		}
		if (Hour > other.Hour)
		{
			return 1;
		}
		if (Minute < other.Minute)
		{
			return -1;
		}
		if (Minute > other.Minute)
		{
			return 1;
		}
		if (Second < other.Second)
		{
			return -1;
		}
		if (Second > other.Second)
		{
			return 1;
		}
		return Microsecond.CompareTo(other.Microsecond);
	}

	readonly bool IEquatable<MySqlDateTime>.Equals(MySqlDateTime other)
	{
		return ((IComparable<MySqlDateTime>)this).CompareTo(other) == 0;
	}

	DateTime IConvertible.ToDateTime(IFormatProvider provider)
	{
		if (!IsValidDateTime)
		{
			throw new InvalidCastException();
		}
		return GetDateTime();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	string IConvertible.ToString([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] IFormatProvider provider)
	{
		if (!IsValidDateTime)
		{
			return "0000-00-00";
		}
		return GetDateTime().ToString(provider);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	object IConvertible.ToType(Type conversionType, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] IFormatProvider provider)
	{
		if (!(conversionType == typeof(DateTime)))
		{
			if (!(conversionType == typeof(string)))
			{
				throw new InvalidCastException();
			}
			return ((IConvertible)this).ToString(provider);
		}
		return GetDateTime();
	}

	TypeCode IConvertible.GetTypeCode()
	{
		return TypeCode.Object;
	}

	bool IConvertible.ToBoolean(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}

	char IConvertible.ToChar(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}

	sbyte IConvertible.ToSByte(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}

	byte IConvertible.ToByte(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}

	short IConvertible.ToInt16(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}

	ushort IConvertible.ToUInt16(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}

	int IConvertible.ToInt32(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}

	uint IConvertible.ToUInt32(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}

	long IConvertible.ToInt64(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}

	ulong IConvertible.ToUInt64(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}

	float IConvertible.ToSingle(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}

	double IConvertible.ToDouble(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}

	decimal IConvertible.ToDecimal(IFormatProvider provider)
	{
		throw new InvalidCastException();
	}
}


public enum MySqlDateTimeKind
{
	Unspecified,
	Utc,
	Local
}


using System;
using System.Data.Common;
using System.Globalization;
using System.Runtime.CompilerServices;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;

public sealed class MySqlDbColumn : DbColumn
{
	public MySqlDbType ProviderType { get; }

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	internal MySqlDbColumn(int ordinal, ColumnDefinitionPayload column, bool allowZeroDateTime, MySqlDbType mySqlDbType)
	{
		ColumnTypeMetadata columnTypeMetadata = TypeMapper.Instance.GetColumnTypeMetadata(mySqlDbType);
		Type clrType = columnTypeMetadata.DbTypeMapping.ClrType;
		long num = ((clrType == typeof(string) || clrType == typeof(Guid)) ? (column.ColumnLength / ProtocolUtility.GetBytesPerCharacter(column.CharacterSet)) : column.ColumnLength);
		base.AllowDBNull = (column.ColumnFlags & ColumnFlags.NotNull) == 0;
		base.BaseCatalogName = null;
		base.BaseColumnName = column.PhysicalName;
		base.BaseSchemaName = column.SchemaName;
		base.BaseTableName = column.PhysicalTable;
		base.ColumnName = column.Name;
		base.ColumnOrdinal = ordinal;
		base.ColumnSize = (int)((num > int.MaxValue) ? int.MaxValue : num);
		base.DataType = ((allowZeroDateTime && clrType == typeof(DateTime)) ? typeof(MySqlDateTime) : clrType);
		base.DataTypeName = columnTypeMetadata.SimpleDataTypeName;
		if (mySqlDbType == MySqlDbType.String)
		{
			base.DataTypeName += string.Format(CultureInfo.InvariantCulture, "({0})", num);
		}
		base.IsAliased = column.PhysicalName != column.Name;
		base.IsAutoIncrement = (column.ColumnFlags & ColumnFlags.AutoIncrement) != 0;
		base.IsExpression = false;
		base.IsHidden = false;
		base.IsKey = (column.ColumnFlags & ColumnFlags.PrimaryKey) != 0;
		bool flag = column.ColumnLength > 255;
		ColumnType columnType;
		if (flag)
		{
			bool flag2 = (column.ColumnFlags & ColumnFlags.Blob) != 0;
			if (!flag2)
			{
				columnType = column.ColumnType;
				flag2 = (uint)(columnType - 249) <= 3u;
			}
			flag = flag2;
		}
		base.IsLong = flag;
		base.IsReadOnly = false;
		base.IsUnique = (column.ColumnFlags & ColumnFlags.UniqueKey) != 0;
		columnType = column.ColumnType;
		if ((columnType == ColumnType.Decimal || columnType == ColumnType.NewDecimal) ? true : false)
		{
			base.NumericPrecision = (int)column.ColumnLength;
			if ((column.ColumnFlags & ColumnFlags.Unsigned) == 0)
			{
				base.NumericPrecision--;
			}
			if (column.Decimals > 0)
			{
				base.NumericPrecision--;
			}
		}
		base.NumericScale = column.Decimals;
		ProviderType = mySqlDbType;
	}
}


using System;

public enum MySqlDbType
{
	Bool = -1,
	Decimal = 0,
	Byte = 1,
	Int16 = 2,
	Int32 = 3,
	Float = 4,
	Double = 5,
	Null = 6,
	Timestamp = 7,
	Int64 = 8,
	Int24 = 9,
	Date = 10,
	Time = 11,
	DateTime = 12,
	[Obsolete("The Datetime enum value is obsolete.  Please use DateTime.")]
	Datetime = 12,
	Year = 13,
	Newdate = 14,
	VarString = 15,
	Bit = 16,
	JSON = 245,
	NewDecimal = 246,
	Enum = 247,
	Set = 248,
	TinyBlob = 249,
	MediumBlob = 250,
	LongBlob = 251,
	Blob = 252,
	VarChar = 253,
	String = 254,
	Geometry = 255,
	UByte = 501,
	UInt16 = 502,
	UInt32 = 503,
	UInt64 = 508,
	UInt24 = 509,
	Binary = 600,
	VarBinary = 601,
	TinyText = 749,
	MediumText = 750,
	LongText = 751,
	Text = 752,
	Guid = 800
}


using System;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public readonly struct MySqlDecimal
{
	private static readonly Regex s_pattern = new Regex("^-?([0-9]+)(\\.([0-9]+))?$");

	private readonly string m_value;

	public decimal Value => decimal.Parse(m_value, CultureInfo.InvariantCulture);

	public double ToDouble()
	{
		return double.Parse(m_value, CultureInfo.InvariantCulture);
	}

	public override string ToString()
	{
		return m_value;
	}

	internal MySqlDecimal(string value)
	{
		Match match = s_pattern.Match(value);
		if (match != null && match.Success)
		{
			int length = match.Groups[1].Length;
			int length2 = match.Groups[3].Value.TrimEnd(new char[1] { '0' }).Length;
			bool num = length + length2 <= 65 && length2 <= 30;
			bool flag = value[0] == '-' && match.Groups[1].Value == "0" && length2 == 0;
			if (num && !flag)
			{
				m_value = value;
				return;
			}
		}
		throw new FormatException("Could not parse the value as a MySqlDecimal: " + value);
	}
}


using System;
using System.IO;

[Serializable]
public sealed class MySqlEndOfStreamException : EndOfStreamException
{
	public int ExpectedByteCount { get; }

	public int ReadByteCount { get; }

	internal MySqlEndOfStreamException(int expectedByteCount, int readByteCount)
		: base("An incomplete response was received from the server")
	{
		ExpectedByteCount = expectedByteCount;
		ReadByteCount = readByteCount;
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlError
{
	public string Level { get; }

	[Obsolete("Use ErrorCode")]
	public int Code { get; }

	public MySqlErrorCode ErrorCode { get; }

	public string Message { get; }

	internal MySqlError(string level, int code, string message)
	{
		Level = level;
		Code = code;
		ErrorCode = (MySqlErrorCode)code;
		Message = message;
	}
}


using System;
using System.CodeDom.Compiler;

[GeneratedCode("https://gist.github.com/bgrainger/791cecb647d514a9dd2f3d83b2387e49", "5")]
public enum MySqlErrorCode
{
	ProvidePasswordCallbackFailed = -4,
	DelimiterNotSupported = -3,
	BulkCopyFailed = -2,
	CommandTimeoutExpired = -1,
	None = 0,
	HashCheck = 1000,
	ISAMCheck = 1001,
	No = 1002,
	Yes = 1003,
	CannotCreateFile = 1004,
	CannotCreateTable = 1005,
	CannotCreateDatabase = 1006,
	DatabaseCreateExists = 1007,
	DatabaseDropExists = 1008,
	DatabaseDropDelete = 1009,
	DatabaseDropRemoveDir = 1010,
	CannotDeleteFile = 1011,
	CannotFindSystemRecord = 1012,
	CannotGetStatus = 1013,
	CannotGetWorkingDirectory = 1014,
	CannotLock = 1015,
	CannotOpenFile = 1016,
	FileNotFound = 1017,
	CannotReadDirectory = 1018,
	CannotSetWorkingDirectory = 1019,
	CheckRead = 1020,
	DiskFull = 1021,
	DuplicateKey = 1022,
	ErrorOnClose = 1023,
	ErrorOnRead = 1024,
	ErrorOnRename = 1025,
	ErrorOnWrite = 1026,
	FileUsed = 1027,
	FileSortAborted = 1028,
	FormNotFound = 1029,
	GetErrorNumber = 1030,
	IllegalHA = 1031,
	KeyNotFound = 1032,
	NotFormFile = 1033,
	NotKeyFile = 1034,
	OldKeyFile = 1035,
	OpenAsReadOnly = 1036,
	OutOfMemory = 1037,
	OutOfSortMemory = 1038,
	UnexepectedEOF = 1039,
	ConnectionCountError = 1040,
	OutOfResources = 1041,
	UnableToConnectToHost = 1042,
	HandshakeError = 1043,
	DatabaseAccessDenied = 1044,
	AccessDenied = 1045,
	NoDatabaseSelected = 1046,
	UnknownCommand = 1047,
	ColumnCannotBeNull = 1048,
	UnknownDatabase = 1049,
	TableExists = 1050,
	BadTable = 1051,
	NonUnique = 1052,
	ServerShutdown = 1053,
	BadFieldError = 1054,
	WrongFieldWithGroup = 1055,
	WrongGroupField = 1056,
	WrongSumSelected = 1057,
	WrongValueCount = 1058,
	TooLongIdentifier = 1059,
	DuplicateFieldName = 1060,
	DuplicateKeyName = 1061,
	DuplicateKeyEntry = 1062,
	WrongFieldSpecifier = 1063,
	ParseError = 1064,
	EmptyQuery = 1065,
	NonUniqueTable = 1066,
	InvalidDefault = 1067,
	MultiplePrimaryKey = 1068,
	TooManyKeys = 1069,
	TooManyKeysParts = 1070,
	TooLongKey = 1071,
	KeyColumnDoesNotExist = 1072,
	BlobUsedAsKey = 1073,
	TooBigFieldLength = 1074,
	WrongAutoKey = 1075,
	Ready = 1076,
	NormalShutdown = 1077,
	GotSignal = 1078,
	ShutdownComplete = 1079,
	ForcingClose = 1080,
	IPSocketError = 1081,
	NoSuchIndex = 1082,
	WrongFieldTerminators = 1083,
	BlobsAndNoTerminated = 1084,
	TextFileNotReadable = 1085,
	FileExists = 1086,
	LoadInfo = 1087,
	AlterInfo = 1088,
	WrongSubKey = 1089,
	CannotRemoveAllFields = 1090,
	CannotDropFieldOrKey = 1091,
	InsertInfo = 1092,
	UpdateTableUsed = 1093,
	NoSuchThread = 1094,
	KillDenied = 1095,
	NoTablesUsed = 1096,
	TooBigSet = 1097,
	NoUniqueLogFile = 1098,
	TableNotLockedForWrite = 1099,
	TableNotLocked = 1100,
	BlobCannotHaveDefault = 1101,
	WrongDatabaseName = 1102,
	WrongTableName = 1103,
	TooBigSelect = 1104,
	UnknownError = 1105,
	UnknownProcedure = 1106,
	WrongParameterCountToProcedure = 1107,
	WrongParametersToProcedure = 1108,
	UnknownTable = 1109,
	FieldSpecifiedTwice = 1110,
	InvalidGroupFunctionUse = 1111,
	UnsupportedExtenstion = 1112,
	TableMustHaveColumns = 1113,
	RecordFileFull = 1114,
	UnknownCharacterSet = 1115,
	TooManyTables = 1116,
	TooManyFields = 1117,
	TooBigRowSize = 1118,
	StackOverrun = 1119,
	WrongOuterJoin = 1120,
	NullColumnInIndex = 1121,
	CannotFindUDF = 1122,
	CannotInitializeUDF = 1123,
	UDFNoPaths = 1124,
	UDFExists = 1125,
	CannotOpenLibrary = 1126,
	CannotFindDLEntry = 1127,
	FunctionNotDefined = 1128,
	HostIsBlocked = 1129,
	HostNotPrivileged = 1130,
	AnonymousUser = 1131,
	PasswordNotAllowed = 1132,
	PasswordNoMatch = 1133,
	UpdateInfo = 1134,
	CannotCreateThread = 1135,
	WrongValueCountOnRow = 1136,
	CannotReopenTable = 1137,
	InvalidUseOfNull = 1138,
	RegExpError = 1139,
	MixOfGroupFunctionAndFields = 1140,
	NonExistingGrant = 1141,
	TableAccessDenied = 1142,
	ColumnAccessDenied = 1143,
	IllegalGrantForTable = 1144,
	GrantWrongHostOrUser = 1145,
	NoSuchTable = 1146,
	NonExistingTableGrant = 1147,
	NotAllowedCommand = 1148,
	SyntaxError = 1149,
	DelayedCannotChangeLock = 1150,
	TooManyDelayedThreads = 1151,
	AbortingConnection = 1152,
	PacketTooLarge = 1153,
	NetReadErrorFromPipe = 1154,
	NetFCntlError = 1155,
	NetPacketsOutOfOrder = 1156,
	NetUncompressError = 1157,
	NetReadError = 1158,
	NetReadInterrupted = 1159,
	NetErrorOnWrite = 1160,
	NetWriteInterrupted = 1161,
	TooLongString = 1162,
	TableCannotHandleBlob = 1163,
	TableCannotHandleAutoIncrement = 1164,
	DelayedInsertTableLocked = 1165,
	WrongColumnName = 1166,
	WrongKeyColumn = 1167,
	WrongMergeTable = 1168,
	DuplicateUnique = 1169,
	BlobKeyWithoutLength = 1170,
	PrimaryCannotHaveNull = 1171,
	TooManyRows = 1172,
	RequiresPrimaryKey = 1173,
	NoRAIDCompiled = 1174,
	UpdateWithoutKeysInSafeMode = 1175,
	KeyDoesNotExist = 1176,
	CheckNoSuchTable = 1177,
	CheckNotImplemented = 1178,
	CannotDoThisDuringATransaction = 1179,
	ErrorDuringCommit = 1180,
	ErrorDuringRollback = 1181,
	ErrorDuringFlushLogs = 1182,
	ErrorDuringCheckpoint = 1183,
	NewAbortingConnection = 1184,
	DumpNotImplemented = 1185,
	FlushMasterBinLogClosed = 1186,
	IndexRebuild = 1187,
	MasterError = 1188,
	MasterNetRead = 1189,
	MasterNetWrite = 1190,
	FullTextMatchingKeyNotFound = 1191,
	LockOrActiveTransaction = 1192,
	UnknownSystemVariable = 1193,
	CrashedOnUsage = 1194,
	CrashedOnRepair = 1195,
	WarningNotCompleteRollback = 1196,
	TransactionCacheFull = 1197,
	SlaveMustStop = 1198,
	SlaveNotRunning = 1199,
	BadSlave = 1200,
	MasterInfo = 1201,
	SlaveThread = 1202,
	TooManyUserConnections = 1203,
	SetConstantsOnly = 1204,
	LockWaitTimeout = 1205,
	LockTableFull = 1206,
	ReadOnlyTransaction = 1207,
	DropDatabaseWithReadLock = 1208,
	CreateDatabaseWithReadLock = 1209,
	WrongArguments = 1210,
	NoPermissionToCreateUser = 1211,
	UnionTablesInDifferentDirectory = 1212,
	LockDeadlock = 1213,
	TableCannotHandleFullText = 1214,
	CannotAddForeignConstraint = 1215,
	NoReferencedRow = 1216,
	RowIsReferenced = 1217,
	ConnectToMaster = 1218,
	QueryOnMaster = 1219,
	ErrorWhenExecutingCommand = 1220,
	WrongUsage = 1221,
	WrongNumberOfColumnsInSelect = 1222,
	CannotUpdateWithReadLock = 1223,
	MixingNotAllowed = 1224,
	DuplicateArgument = 1225,
	UserLimitReached = 1226,
	SpecifiedAccessDeniedError = 1227,
	LocalVariableError = 1228,
	GlobalVariableError = 1229,
	NotDefaultError = 1230,
	WrongValueForVariable = 1231,
	WrongTypeForVariable = 1232,
	VariableCannotBeRead = 1233,
	CannotUseOptionHere = 1234,
	NotSupportedYet = 1235,
	MasterFatalErrorReadingBinLog = 1236,
	SlaveIgnoredTable = 1237,
	IncorrectGlobalLocalVariable = 1238,
	WrongForeignKeyDefinition = 1239,
	KeyReferenceDoesNotMatchTableReference = 1240,
	OpearnColumnsError = 1241,
	SubQueryNoOneRow = 1242,
	UnknownStatementHandler = 1243,
	CorruptHelpDatabase = 1244,
	CyclicReference = 1245,
	AutoConvert = 1246,
	IllegalReference = 1247,
	DerivedMustHaveAlias = 1248,
	SelectReduced = 1249,
	TableNameNotAllowedHere = 1250,
	NotSupportedAuthMode = 1251,
	SpatialCannotHaveNull = 1252,
	CollationCharsetMismatch = 1253,
	SlaveWasRunning = 1254,
	SlaveWasNotRunning = 1255,
	TooBigForUncompress = 1256,
	ZipLibMemoryError = 1257,
	ZipLibBufferError = 1258,
	ZipLibDataError = 1259,
	CutValueGroupConcat = 1260,
	WarningTooFewRecords = 1261,
	WarningTooManyRecords = 1262,
	WarningNullToNotNull = 1263,
	WarningDataOutOfRange = 1264,
	[Obsolete("Use WarningDataTruncated.")]
	WaningDataTruncated = 1265,
	WarningDataTruncated = 1265,
	[Obsolete("Use WarningUsingOtherHandler.")]
	WaningUsingOtherHandler = 1266,
	WarningUsingOtherHandler = 1266,
	CannotAggregateTwoCollations = 1267,
	DropUserError = 1268,
	RevokeGrantsError = 1269,
	CannotAggregateThreeCollations = 1270,
	CannotAggregateNCollations = 1271,
	VariableIsNotStructure = 1272,
	UnknownCollation = 1273,
	SlaveIgnoreSSLParameters = 1274,
	ServerIsInSecureAuthMode = 1275,
	[Obsolete("Use WarningFieldResolved.")]
	WaningFieldResolved = 1276,
	WarningFieldResolved = 1276,
	BadSlaveUntilCondition = 1277,
	MissingSkipSlave = 1278,
	ErrorUntilConditionIgnored = 1279,
	WrongNameForIndex = 1280,
	WrongNameForCatalog = 1281,
	WarningQueryCacheResize = 1282,
	BadFullTextColumn = 1283,
	UnknownKeyCache = 1284,
	WarningHostnameWillNotWork = 1285,
	UnknownStorageEngine = 1286,
	[Obsolete("Use WarningDeprecatedSyntax.")]
	WaningDeprecatedSyntax = 1287,
	WarningDeprecatedSyntax = 1287,
	NonUpdateableTable = 1288,
	FeatureDisabled = 1289,
	OptionPreventsStatement = 1290,
	DuplicatedValueInType = 1291,
	TruncatedWrongValue = 1292,
	TooMuchAutoTimestampColumns = 1293,
	InvalidOnUpdate = 1294,
	UnsupportedPreparedStatement = 1295,
	GetErroMessage = 1296,
	GetTemporaryErrorMessage = 1297,
	UnknownTimeZone = 1298,
	WarningInvalidTimestamp = 1299,
	InvalidCharacterString = 1300,
	WarningAllowedPacketOverflowed = 1301,
	ConflictingDeclarations = 1302,
	StoredProcedureNoRecursiveCreate = 1303,
	StoredProcedureAlreadyExists = 1304,
	StoredProcedureDoesNotExist = 1305,
	StoredProcedureDropFailed = 1306,
	StoredProcedureStoreFailed = 1307,
	StoredProcedureLiLabelMismatch = 1308,
	StoredProcedureLabelRedefine = 1309,
	StoredProcedureLabelMismatch = 1310,
	StoredProcedureUninitializedVariable = 1311,
	StoredProcedureBadSelect = 1312,
	StoredProcedureBadReturn = 1313,
	StoredProcedureBadStatement = 1314,
	UpdateLogDeprecatedIgnored = 1315,
	UpdateLogDeprecatedTranslated = 1316,
	QueryInterrupted = 1317,
	StoredProcedureNumberOfArguments = 1318,
	StoredProcedureConditionMismatch = 1319,
	StoredProcedureNoReturn = 1320,
	StoredProcedureNoReturnEnd = 1321,
	StoredProcedureBadCursorQuery = 1322,
	StoredProcedureBadCursorSelect = 1323,
	StoredProcedureCursorMismatch = 1324,
	StoredProcedureAlreadyOpen = 1325,
	StoredProcedureCursorNotOpen = 1326,
	StoredProcedureUndeclaredVariabel = 1327,
	StoredProcedureWrongNumberOfFetchArguments = 1328,
	StoredProcedureFetchNoData = 1329,
	StoredProcedureDuplicateParameter = 1330,
	StoredProcedureDuplicateVariable = 1331,
	StoredProcedureDuplicateCondition = 1332,
	StoredProcedureDuplicateCursor = 1333,
	StoredProcedureCannotAlter = 1334,
	StoredProcedureSubSelectNYI = 1335,
	StatementNotAllowedInStoredFunctionOrTrigger = 1336,
	StoredProcedureVariableConditionAfterCursorHandler = 1337,
	StoredProcedureCursorAfterHandler = 1338,
	StoredProcedureCaseNotFound = 1339,
	FileParserTooBigFile = 1340,
	FileParserBadHeader = 1341,
	FileParserEOFInComment = 1342,
	FileParserErrorInParameter = 1343,
	FileParserEOFInUnknownParameter = 1344,
	ViewNoExplain = 1345,
	FrmUnknownType = 1346,
	WrongObject = 1347,
	NonUpdateableColumn = 1348,
	ViewSelectDerived = 1349,
	ViewSelectClause = 1350,
	ViewSelectVariable = 1351,
	ViewSelectTempTable = 1352,
	ViewWrongList = 1353,
	WarningViewMerge = 1354,
	WarningViewWithoutKey = 1355,
	ViewInvalid = 1356,
	StoredProcedureNoDropStoredProcedure = 1357,
	StoredProcedureGotoInHandler = 1358,
	TriggerAlreadyExists = 1359,
	TriggerDoesNotExist = 1360,
	TriggerOnViewOrTempTable = 1361,
	TriggerCannotChangeRow = 1362,
	TriggerNoSuchRowInTrigger = 1363,
	NoDefaultForField = 1364,
	DivisionByZero = 1365,
	TruncatedWrongValueForField = 1366,
	IllegalValueForType = 1367,
	ViewNonUpdatableCheck = 1368,
	ViewCheckFailed = 1369,
	PrecedureAccessDenied = 1370,
	RelayLogFail = 1371,
	PasswordLength = 1372,
	UnknownTargetBinLog = 1373,
	IOErrorLogIndexRead = 1374,
	BinLogPurgeProhibited = 1375,
	FSeekFail = 1376,
	BinLogPurgeFatalError = 1377,
	LogInUse = 1378,
	LogPurgeUnknownError = 1379,
	RelayLogInit = 1380,
	NoBinaryLogging = 1381,
	ReservedSyntax = 1382,
	WSAStartupFailed = 1383,
	DifferentGroupsProcedure = 1384,
	NoGroupForProcedure = 1385,
	OrderWithProcedure = 1386,
	LoggingProhibitsChangingOf = 1387,
	NoFileMapping = 1388,
	WrongMagic = 1389,
	PreparedStatementManyParameters = 1390,
	KeyPartZero = 1391,
	ViewChecksum = 1392,
	ViewMultiUpdate = 1393,
	ViewNoInsertFieldList = 1394,
	ViewDeleteMergeView = 1395,
	CannotUser = 1396,
	XAERNotA = 1397,
	XAERInvalid = 1398,
	XAERRemoveFail = 1399,
	XAEROutside = 1400,
	XAERRemoveError = 1401,
	XARBRollback = 1402,
	NonExistingProcedureGrant = 1403,
	ProcedureAutoGrantFail = 1404,
	ProcedureAutoRevokeFail = 1405,
	DataTooLong = 1406,
	StoredProcedureSQLState = 1407,
	StartupError = 1408,
	LoadFromFixedSizeRowsToVariable = 1409,
	CannotCreateUserWithGrant = 1410,
	WrongValueForType = 1411,
	TableDefinitionChanged = 1412,
	StoredProcedureDuplicateHandler = 1413,
	StoredProcedureNotVariableArgument = 1414,
	StoredProcedureNoReturnSet = 1415,
	CannotCreateGeometryObject = 1416,
	FailedRoutineBreaksBinLog = 1417,
	BinLogUnsafeRoutine = 1418,
	BinLogCreateRoutineNeedSuper = 1419,
	ExecuteStatementWithOpenCursor = 1420,
	StatementHasNoOpenCursor = 1421,
	CommitNotAllowedIfStoredFunctionOrTrigger = 1422,
	NoDefaultForViewField = 1423,
	StoredProcedureNoRecursion = 1424,
	TooBigScale = 1425,
	TooBigPrecision = 1426,
	MBiggerThanD = 1427,
	WrongLockOfSystemTable = 1428,
	ConnectToForeignDataSource = 1429,
	QueryOnForeignDataSource = 1430,
	ForeignDataSourceDoesNotExist = 1431,
	ForeignDataStringInvalidCannotCreate = 1432,
	ForeignDataStringInvalid = 1433,
	CannotCreateFederatedTable = 1434,
	TriggerInWrongSchema = 1435,
	StackOverrunNeedMore = 1436,
	TooLongBody = 1437,
	WarningCannotDropDefaultKeyCache = 1438,
	TooBigDisplayWidth = 1439,
	XAERDuplicateID = 1440,
	DateTimeFunctionOverflow = 1441,
	CannotUpdateUsedTableInStoredFunctionOrTrigger = 1442,
	ViewPreventUpdate = 1443,
	PreparedStatementNoRecursion = 1444,
	StoredProcedureCannotSetAutoCommit = 1445,
	MalformedDefiner = 1446,
	ViewFrmNoUser = 1447,
	ViewOtherUser = 1448,
	NoSuchUser = 1449,
	ForbidSchemaChange = 1450,
	RowIsReferenced2 = 1451,
	NoReferencedRow2 = 1452,
	StoredProcedureBadVariableShadow = 1453,
	TriggerNoDefiner = 1454,
	OldFileFormat = 1455,
	StoredProcedureRecursionLimit = 1456,
	StoredProcedureTableCorrupt = 1457,
	StoredProcedureWrongName = 1458,
	TableNeedsUpgrade = 1459,
	StoredProcedureNoAggregate = 1460,
	MaxPreparedStatementCountReached = 1461,
	ViewRecursive = 1462,
	NonGroupingFieldUsed = 1463,
	TableCannotHandleSpatialKeys = 1464,
	NoTriggersOnSystemSchema = 1465,
	RemovedSpaces = 1466,
	AutoIncrementReadFailed = 1467,
	UserNameError = 1468,
	HostNameError = 1469,
	WrongStringLength = 1470,
	NonInsertableTable = 1471,
	AdminWrongMergeTable = 1472,
	TooHighLevelOfNestingForSelect = 1473,
	NameBecomesEmpty = 1474,
	AmbiguousFieldTerm = 1475,
	ForeignServerExists = 1476,
	ForeignServerDoesNotExist = 1477,
	IllegalHACreateOption = 1478,
	PartitionRequiresValues = 1479,
	PartitionWrongValues = 1480,
	PartitionMaxValue = 1481,
	PartitionSubPartition = 1482,
	PartitionSubPartMix = 1483,
	PartitionWrongNoPart = 1484,
	PartitionWrongNoSubPart = 1485,
	WrongExpressionInParitionFunction = 1486,
	NoConstantExpressionInRangeOrListError = 1487,
	FieldNotFoundPartitionErrror = 1488,
	ListOfFieldsOnlyInHash = 1489,
	InconsistentPartitionInfo = 1490,
	PartitionFunctionNotAllowed = 1491,
	PartitionsMustBeDefined = 1492,
	RangeNotIncreasing = 1493,
	InconsistentTypeOfFunctions = 1494,
	MultipleDefinitionsConstantInListPartition = 1495,
	PartitionEntryError = 1496,
	MixHandlerError = 1497,
	PartitionNotDefined = 1498,
	TooManyPartitions = 1499,
	SubPartitionError = 1500,
	CannotCreateHandlerFile = 1501,
	BlobFieldInPartitionFunction = 1502,
	UniqueKeyNeedAllFieldsInPartitioningFunction = 1503,
	NoPartitions = 1504,
	PartitionManagementOnNoPartitioned = 1505,
	ForeignKeyOnPartitioned = 1506,
	DropPartitionNonExistent = 1507,
	DropLastPartition = 1508,
	CoalesceOnlyOnHashPartition = 1509,
	ReorganizeHashOnlyOnSameNumber = 1510,
	ReorganizeNoParameter = 1511,
	OnlyOnRangeListPartition = 1512,
	AddPartitionSubPartition = 1513,
	AddPartitionNoNewPartition = 1514,
	CoalescePartitionNoPartition = 1515,
	ReorganizePartitionNotExist = 1516,
	SameNamePartition = 1517,
	NoBinLog = 1518,
	ConsecutiveReorganizePartitions = 1519,
	ReorganizeOutsideRange = 1520,
	PartitionFunctionFailure = 1521,
	PartitionStateError = 1522,
	LimitedPartitionRange = 1523,
	PluginIsNotLoaded = 1524,
	WrongValue = 1525,
	NoPartitionForGivenValue = 1526,
	FileGroupOptionOnlyOnce = 1527,
	CreateFileGroupFailed = 1528,
	DropFileGroupFailed = 1529,
	TableSpaceAutoExtend = 1530,
	WrongSizeNumber = 1531,
	SizeOverflow = 1532,
	AlterFileGroupFailed = 1533,
	BinLogRowLogginFailed = 1534,
	BinLogRowWrongTableDefinition = 1535,
	BinLogRowRBRToSBR = 1536,
	EventAlreadyExists = 1537,
	EventStoreFailed = 1538,
	EventDoesNotExist = 1539,
	EventCannotAlter = 1540,
	EventDropFailed = 1541,
	EventIntervalNotPositiveOrTooBig = 1542,
	EventEndsBeforeStarts = 1543,
	EventExecTimeInThePast = 1544,
	EventOpenTableFailed = 1545,
	EventNeitherMExpresssionNorMAt = 1546,
	ColumnCountDoesNotMatchCorrupted = 1547,
	CannotLoadFromTable = 1548,
	EventCannotDelete = 1549,
	EventCompileError = 1550,
	EventSameName = 1551,
	EventDataTooLong = 1552,
	DropIndexForeignKey = 1553,
	WarningDeprecatedSyntaxWithVersion = 1554,
	CannotWriteLockLogTable = 1555,
	CannotLockLogTable = 1556,
	ForeignDuplicateKey = 1557,
	ColumnCountDoesNotMatchPleaseUpdate = 1558,
	TemoraryTablePreventSwitchOutOfRBR = 1559,
	StoredFunctionPreventsSwitchBinLogFormat = 1560,
	NDBCannotSwitchBinLogFormat = 1561,
	PartitionNoTemporary = 1562,
	PartitionConstantDomain = 1563,
	PartitionFunctionIsNotAllowed = 1564,
	DDLLogError = 1565,
	NullInValuesLessThan = 1566,
	WrongPartitionName = 1567,
	CannotChangeTransactionIsolation = 1568,
	DuplicateEntryAutoIncrementCase = 1569,
	EventModifyQueueError = 1570,
	EventSetVariableError = 1571,
	PartitionMergeError = 1572,
	CannotActivateLog = 1573,
	RBRNotAvailable = 1574,
	Base64DecodeError = 1575,
	EventRecursionForbidden = 1576,
	EventsDatabaseError = 1577,
	OnlyIntegersAllowed = 1578,
	UnsupportedLogEngine = 1579,
	BadLogStatement = 1580,
	CannotRenameLogTable = 1581,
	WrongParameterCountToNativeFCT = 1582,
	WrongParametersToNativeFCT = 1583,
	WrongParametersToStoredFCT = 1584,
	NativeFCTNameCollision = 1585,
	DuplicateEntryWithKeyName = 1586,
	BinLogPurgeEMFile = 1587,
	EventCannotCreateInThePast = 1588,
	EventCannotAlterInThePast = 1589,
	SlaveIncident = 1590,
	NoPartitionForGivenValueSilent = 1591,
	BinLogUnsafeStatement = 1592,
	SlaveFatalError = 1593,
	SlaveRelayLogReadFailure = 1594,
	SlaveRelayLogWriteFailure = 1595,
	SlaveCreateEventFailure = 1596,
	SlaveMasterComFailure = 1597,
	BinLogLoggingImpossible = 1598,
	ViewNoCreationContext = 1599,
	ViewInvalidCreationContext = 1600,
	StoredRoutineInvalidCreateionContext = 1601,
	TiggerCorruptedFile = 1602,
	TriggerNoCreationContext = 1603,
	TriggerInvalidCreationContext = 1604,
	EventInvalidCreationContext = 1605,
	TriggerCannotOpenTable = 1606,
	CannotCreateSubRoutine = 1607,
	[Obsolete("Use CannotCreateSubRoutine")]
	CannoCreateSubRoutine = 1607,
	SlaveAmbiguousExecMode = 1608,
	NoFormatDescriptionEventBeforeBinLogStatement = 1609,
	SlaveCorruptEvent = 1610,
	LoadDataInvalidColumn = 1611,
	LogPurgeNoFile = 1612,
	XARBTimeout = 1613,
	XARBDeadlock = 1614,
	NeedRePrepare = 1615,
	DelayedNotSupported = 1616,
	WarningNoMasterInfo = 1617,
	WarningOptionIgnored = 1618,
	WarningPluginDeleteBuiltIn = 1619,
	WarningPluginBusy = 1620,
	VariableIsReadonly = 1621,
	WarningEngineTransactionRollback = 1622,
	SlaveHeartbeatFailure = 1623,
	SlaveHeartbeatValueOutOfRange = 1624,
	NDBReplicationSchemaError = 1625,
	ConflictFunctionParseError = 1626,
	ExcepionsWriteError = 1627,
	TooLongTableComment = 1628,
	TooLongFieldComment = 1629,
	FunctionInExistentNameCollision = 1630,
	DatabaseNameError = 1631,
	TableNameErrror = 1632,
	PartitionNameError = 1633,
	SubPartitionNameError = 1634,
	TemporaryNameError = 1635,
	RenamedNameError = 1636,
	TooManyConcurrentTransactions = 1637,
	WarningNonASCIISeparatorNotImplemented = 1638,
	DebugSyncTimeout = 1639,
	DebugSyncHitLimit = 1640,
	WarnDeprecatedSyntaxNoReplacement = 1681,
	TooLongIndexComment = 1688,
	LockAborted = 1689,
	DataOutOfRange = 1690,
	CannotExecuteInReadOnlyTransaction = 1792,
	InnodbReadOnly = 1874,
	TableCorrupt = 1877,
	TempFileWriteFailure = 1878,
	ExplainNotSupported = 3012,
	InvalidFieldSize = 3013,
	QueryTimeout = 3024,
	UserLockWrongName = 3057,
	UserLockDeadlock = 3058,
	InvalidJsonData = 3069,
	InvalidJsonText = 3140,
	InvalidJsonTextInParam = 3141,
	InvalidJsonBinaryData = 3142,
	InvalidJsonPath = 3143,
	InvalidJsonCharset = 3144,
	InvalidJsonCharsetInFunction = 3145,
	InvalidTypeForJson = 3146,
	InvalidCastToJson = 3147,
	InvalidJsonPathCharset = 3148,
	InvalidJsonPathWildcard = 3149,
	JsonValueTooBig = 3150,
	JsonKeyTooBig = 3151,
	JsonUsedAsKey = 3152,
	JsonVacuousPath = 3153,
	JsonBadOneOrAllArg = 3154,
	NumericJsonValueOutOfRange = 3155,
	InvalidJsonValueForCast = 3156,
	JsonDocumentTooDeep = 3157,
	JsonDocumentNullKey = 3158,
	InvalidJsonPathArrayCell = 3165,
	NoSuchDb = 3503,
	MissingJsonTableValue = 3665,
	WrongJsonTableValue = 3666,
	JsonTableValueOutOfRange = 3669,
	JsonTableMaxNestedPath = 3670,
	InvalidJsonType = 3853,
	CannotConvertString = 3854,
	ClientInteractionTimeout = 4031
}


using System;
using System.Collections;
using System.Data.Common;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using MySqlConnector;

[Serializable]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlException : DbException
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private IDictionary m_data;

	public int Number { get; }

	public new MySqlErrorCode ErrorCode { get; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public new string SqlState
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
	}

	public new bool IsTransient => IsErrorTransient(ErrorCode);

	public override IDictionary Data
	{
		get
		{
			if (m_data == null)
			{
				m_data = base.Data;
				m_data["Server Error Code"] = Number;
				m_data["SqlState"] = SqlState;
			}
			return m_data;
		}
	}

	private MySqlException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
		Number = info.GetInt32("Number");
		ErrorCode = (MySqlErrorCode)Number;
		SqlState = info.GetString("SqlState");
	}

	public override void GetObjectData(SerializationInfo info, StreamingContext context)
	{
		base.GetObjectData(info, context);
		info.AddValue("Number", Number);
		info.AddValue("SqlState", SqlState);
	}

	internal MySqlException(string message)
		: this(message, null)
	{
	}

	internal MySqlException(string message, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception innerException)
		: this(MySqlErrorCode.None, null, message, innerException)
	{
	}

	internal MySqlException(MySqlErrorCode errorCode, string message)
		: this(errorCode, null, message, null)
	{
	}

	internal MySqlException(MySqlErrorCode errorCode, string message, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception innerException)
		: this(errorCode, null, message, innerException)
	{
	}

	internal MySqlException(MySqlErrorCode errorCode, string sqlState, string message)
		: this(errorCode, sqlState, message, null)
	{
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	internal MySqlException(MySqlErrorCode errorCode, string sqlState, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] string message, Exception innerException)
		: base(message, innerException)
	{
		ErrorCode = errorCode;
		Number = (int)errorCode;
		SqlState = sqlState;
	}

	internal static MySqlException CreateForTimeout()
	{
		return CreateForTimeout(null);
	}

	internal static MySqlException CreateForTimeout([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception innerException)
	{
		return new MySqlException(MySqlErrorCode.CommandTimeoutExpired, "The Command Timeout expired before the operation completed.", innerException);
	}

	private static bool IsErrorTransient(MySqlErrorCode errorCode)
	{
		switch (errorCode)
		{
		case MySqlErrorCode.ConnectionCountError:
		case MySqlErrorCode.UnableToConnectToHost:
		case MySqlErrorCode.LockWaitTimeout:
		case MySqlErrorCode.LockDeadlock:
		case MySqlErrorCode.XARBDeadlock:
			return true;
		default:
			return false;
		}
	}
}


using System;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using MySqlConnector;

public sealed class MySqlGeometry
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private readonly byte[] m_bytes;

	public int SRID => BinaryPrimitives.ReadInt32LittleEndian(m_bytes);

	public ReadOnlySpan<byte> WKB
	{
		get
		{
			ReadOnlySpan<byte> valueSpan = ValueSpan;
			return valueSpan.Slice(4, valueSpan.Length - 4);
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public byte[] Value
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get
		{
			return ValueSpan.ToArray();
		}
	}

	internal ReadOnlySpan<byte> ValueSpan => m_bytes;

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public static MySqlGeometry FromWkb(int srid, ReadOnlySpan<byte> wkb)
	{
		byte[] array = new byte[wkb.Length + 4];
		BinaryPrimitives.WriteInt32LittleEndian(array, srid);
		Span<byte> span = MemoryExtensions.AsSpan(array);
		wkb.CopyTo(span.Slice(4, span.Length - 4));
		return new MySqlGeometry(array);
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public static MySqlGeometry FromMySql(ReadOnlySpan<byte> value)
	{
		return new MySqlGeometry(value.ToArray());
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	internal MySqlGeometry(byte[] bytes)
	{
		m_bytes = bytes;
	}
}


public enum MySqlGuidFormat
{
	Default,
	None,
	Char36,
	Char32,
	Binary16,
	TimeSwapBinary16,
	LittleEndianBinary16
}


using System;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector;

public sealed class MySqlHelper
{
	[Obsolete("Use MySqlConnection.ClearAllPools or MySqlConnection.ClearAllPoolsAsync")]
	public static void ClearConnectionPools()
	{
		MySqlConnection.ClearAllPools();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static string EscapeString(string value)
	{
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		StringBuilder stringBuilder = null;
		int num = -1;
		for (int i = 0; i < value.Length; i++)
		{
			char c = value[i];
			if ((c == '"' || c == '\'' || c == '\\') ? true : false)
			{
				if (stringBuilder == null)
				{
					stringBuilder = new StringBuilder();
				}
				stringBuilder.Append(value, num + 1, i - (num + 1));
				stringBuilder.Append('\\');
				stringBuilder.Append(value[i]);
				num = i;
			}
		}
		stringBuilder?.Append(value, num + 1, value.Length - (num + 1));
		return stringBuilder?.ToString() ?? value;
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public sealed class MySqlInfoMessageEventArgs : EventArgs
{
	public IReadOnlyList<MySqlError> Errors { get; }

	internal MySqlInfoMessageEventArgs(IReadOnlyList<MySqlError> errors)
	{
		Errors = errors;
	}
}


using MySqlConnector;

public delegate void MySqlInfoMessageEventHandler(object sender, MySqlInfoMessageEventArgs args);


public enum MySqlLoadBalance
{
	RoundRobin,
	FailOver,
	Random,
	LeastConnections
}


using System;
using System.Buffers.Text;
using System.Data;
using System.Data.Common;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlParameter : DbParameter, IDbDataParameter, IDataParameter, ICloneable
{
	private DbType m_dbType;

	private MySqlDbType m_mySqlDbType;

	private string m_name;

	private ParameterDirection? m_direction;

	private string m_sourceColumn;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private object m_value;

	public override DbType DbType
	{
		get
		{
			return m_dbType;
		}
		set
		{
			m_dbType = value;
			m_mySqlDbType = TypeMapper.Instance.GetMySqlDbTypeForDbType(value);
			HasSetDbType = true;
		}
	}

	public MySqlDbType MySqlDbType
	{
		get
		{
			return m_mySqlDbType;
		}
		set
		{
			m_dbType = TypeMapper.Instance.GetDbTypeForMySqlDbType(value);
			m_mySqlDbType = value;
			HasSetDbType = true;
		}
	}

	public override ParameterDirection Direction
	{
		get
		{
			return m_direction ?? ParameterDirection.Input;
		}
		set
		{
			if (((uint)(value - 1) > 2u && value != ParameterDirection.ReturnValue) || 1 == 0)
			{
				throw new ArgumentOutOfRangeException("value", $"{value} is not a supported value for ParameterDirection");
			}
			m_direction = value;
		}
	}

	public override bool IsNullable { get; set; }

	public override byte Precision { get; set; }

	public override byte Scale { get; set; }

	public override string ParameterName
	{
		get
		{
			return m_name;
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			m_name = value ?? "";
			string text = ((value == null) ? "" : NormalizeParameterName(m_name));
			ParameterCollection?.ChangeParameterName(this, NormalizedParameterName, text);
			NormalizedParameterName = text;
		}
	}

	public override int Size { get; set; }

	public override string SourceColumn
	{
		get
		{
			return m_sourceColumn;
		}
		[param: <f1ae102e-e29f-42d0-b906-c0ed4b29cd99>AllowNull]
		set
		{
			m_sourceColumn = value ?? "";
		}
	}

	public override bool SourceColumnNullMapping { get; set; }

	public override DataRowVersion SourceVersion { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public override object Value
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get
		{
			return m_value;
		}
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		set
		{
			m_value = value;
			if (!HasSetDbType && value != null)
			{
				DbTypeMapping dbTypeMapping = TypeMapper.Instance.GetDbTypeMapping(value.GetType());
				if (dbTypeMapping != null)
				{
					m_dbType = dbTypeMapping.DbTypes[0];
					m_mySqlDbType = TypeMapper.Instance.GetMySqlDbTypeForDbType(m_dbType);
				}
			}
		}
	}

	internal bool HasSetDirection => m_direction.HasValue;

	internal bool HasSetDbType { get; set; }

	internal string NormalizedParameterName { get; private set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	internal MySqlParameterCollection ParameterCollection
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		set;
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private static ReadOnlySpan<byte> BinaryBytes
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
		get
		{
			return "_binary'"u8;
		}
	}

	public MySqlParameter()
		: this((string)null, (object)null)
	{
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public MySqlParameter(string name, object value)
	{
		ResetDbType();
		m_name = name ?? "";
		NormalizedParameterName = NormalizeParameterName(m_name);
		Value = value;
		m_sourceColumn = "";
		SourceVersion = DataRowVersion.Current;
	}

	public MySqlParameter(string name, MySqlDbType mySqlDbType)
		: this(name, mySqlDbType, 0)
	{
	}

	public MySqlParameter(string name, MySqlDbType mySqlDbType, int size)
		: this(name, mySqlDbType, size, "")
	{
	}

	public MySqlParameter(string name, MySqlDbType mySqlDbType, int size, string sourceColumn)
	{
		m_name = name ?? "";
		NormalizedParameterName = NormalizeParameterName(m_name);
		MySqlDbType = mySqlDbType;
		Size = size;
		m_sourceColumn = sourceColumn ?? "";
		SourceVersion = DataRowVersion.Current;
	}

	public MySqlParameter(string name, MySqlDbType mySqlDbType, int size, ParameterDirection direction, bool isNullable, byte precision, byte scale, string sourceColumn, DataRowVersion sourceVersion, object value)
		: this(name, mySqlDbType, size, sourceColumn)
	{
		Direction = direction;
		IsNullable = isNullable;
		Precision = precision;
		Scale = scale;
		SourceVersion = sourceVersion;
		Value = value;
	}

	public override void ResetDbType()
	{
		m_mySqlDbType = MySqlDbType.VarChar;
		m_dbType = DbType.String;
		HasSetDbType = false;
	}

	public MySqlParameter Clone()
	{
		return new MySqlParameter(this);
	}

	object ICloneable.Clone()
	{
		return Clone();
	}

	internal MySqlParameter WithParameterName(string parameterName)
	{
		return new MySqlParameter(this, parameterName);
	}

	private MySqlParameter(MySqlParameter other)
	{
		m_dbType = other.m_dbType;
		m_mySqlDbType = other.m_mySqlDbType;
		m_direction = other.m_direction;
		HasSetDbType = other.HasSetDbType;
		IsNullable = other.IsNullable;
		Size = other.Size;
		m_name = other.m_name;
		NormalizedParameterName = other.NormalizedParameterName;
		m_value = other.m_value;
		Precision = other.Precision;
		Scale = other.Scale;
		m_sourceColumn = other.m_sourceColumn;
		SourceColumnNullMapping = other.SourceColumnNullMapping;
		SourceVersion = other.SourceVersion;
	}

	private MySqlParameter(MySqlParameter other, string parameterName)
		: this(other)
	{
		if (parameterName == null)
		{
			throw new ArgumentNullException("parameterName");
		}
		ParameterName = parameterName;
	}

	internal void AppendSqlString(ByteBufferWriter writer, StatementPreparerOptions options)
	{
		bool flag = (options & StatementPreparerOptions.NoBackslashEscapes) == StatementPreparerOptions.NoBackslashEscapes;
		if (Value == null || Value == DBNull.Value)
		{
			writer.Write("NULL"u8);
			return;
		}
		if (Value is string text)
		{
			WriteString(writer, flag, MemoryExtensions.AsSpan(text));
			return;
		}
		if (Value is ReadOnlyMemory<char> readOnlyMemory)
		{
			WriteString(writer, flag, readOnlyMemory.Span);
			return;
		}
		if (Value is Memory<char> memory)
		{
			WriteString(writer, flag, memory.Span);
			return;
		}
		if (Value is char c)
		{
			writer.Write((byte)39);
			char c2 = c;
			if (c2 != 0)
			{
				if (c2 != '\'')
				{
					if (c2 != '\\' || flag)
					{
						goto IL_0105;
					}
					writer.Write((ushort)23644);
				}
				else
				{
					writer.Write((ushort)10023);
				}
			}
			else
			{
				if (flag)
				{
					goto IL_0105;
				}
				writer.Write((ushort)12380);
			}
			goto IL_0112;
		}
		if (Value is byte value2)
		{
			Utf8Formatter.TryFormat(value2, writer.GetSpan(3), out var bytesWritten);
			writer.Advance(bytesWritten);
			return;
		}
		if (Value is sbyte value3)
		{
			Utf8Formatter.TryFormat(value3, writer.GetSpan(4), out var bytesWritten2);
			writer.Advance(bytesWritten2);
			return;
		}
		if (Value is decimal num)
		{
			writer.WriteAscii(num.ToString(CultureInfo.InvariantCulture));
			return;
		}
		if (Value is short value4)
		{
			writer.WriteString(value4);
			return;
		}
		if (Value is ushort value5)
		{
			writer.WriteString(value5);
			return;
		}
		if (Value is int value6)
		{
			writer.WriteString(value6);
			return;
		}
		if (Value is uint value7)
		{
			writer.WriteString(value7);
			return;
		}
		if (Value is long value8)
		{
			writer.WriteString(value8);
			return;
		}
		if (Value is ulong value9)
		{
			writer.WriteString(value9);
			return;
		}
		object value10 = Value;
		bool flag2;
		if ((value10 is byte[] || value10 is ReadOnlyMemory<byte> || value10 is Memory<byte> || value10 is ArraySegment<byte> || value10 is MySqlGeometry || value10 is MemoryStream) ? true : false)
		{
			value10 = Value;
			ReadOnlySpan<byte> readOnlySpan = ((value10 is byte[] array) ? ((ReadOnlySpan<byte>)MemoryExtensions.AsSpan(array)) : ((value10 is ArraySegment<byte> segment) ? ((ReadOnlySpan<byte>)MemoryExtensions.AsSpan(segment)) : ((value10 is Memory<byte> memory2) ? ((ReadOnlySpan<byte>)memory2.Span) : ((value10 is MySqlGeometry mySqlGeometry) ? mySqlGeometry.ValueSpan : ((!(value10 is MemoryStream memoryStream)) ? ((ReadOnlyMemory<byte>)Value).Span : ((ReadOnlySpan<byte>)(memoryStream.TryGetBuffer(out var buffer) ? MemoryExtensions.AsSpan(buffer) : MemoryExtensions.AsSpan(memoryStream.ToArray()))))))));
			ReadOnlySpan<byte> readOnlySpan2 = readOnlySpan;
			int num2 = readOnlySpan2.Length + BinaryBytes.Length + 1;
			readOnlySpan = readOnlySpan2;
			for (int i = 0; i < readOnlySpan.Length; i++)
			{
				byte b = readOnlySpan[i];
				flag2 = b == 39;
				if (!flag2)
				{
					bool flag3 = ((b == 0 || b == 92) ? true : false);
					flag2 = flag3 && !flag;
				}
				if (flag2)
				{
					num2++;
				}
			}
			Span<byte> span = writer.GetSpan(num2);
			BinaryBytes.CopyTo(span);
			int length = BinaryBytes.Length;
			readOnlySpan = readOnlySpan2;
			for (int i = 0; i < readOnlySpan.Length; i++)
			{
				byte b2 = readOnlySpan[i];
				if (b2 == 0 && !flag)
				{
					span[length++] = 92;
					span[length++] = 48;
					continue;
				}
				if (b2 == 39 || (b2 == 92 && !flag))
				{
					span[length++] = b2;
				}
				span[length++] = b2;
			}
			span[length++] = 39;
			writer.Advance(length);
			return;
		}
		if (Value is bool flag4)
		{
			writer.Write(flag4 ? "true"u8 : "false"u8);
			return;
		}
		if (Value is float num3)
		{
			writer.WriteAscii(num3.ToString("R", CultureInfo.InvariantCulture));
			return;
		}
		if (Value is double num4)
		{
			writer.WriteAscii(num4.ToString("R", CultureInfo.InvariantCulture));
			return;
		}
		if (Value is BigInteger bigInteger)
		{
			writer.WriteAscii(bigInteger.ToString(CultureInfo.InvariantCulture));
			return;
		}
		if (Value is MySqlDecimal mySqlDecimal)
		{
			writer.WriteAscii(mySqlDecimal.ToString());
			return;
		}
		if (Value is MySqlDateTime mySqlDateTime)
		{
			if (mySqlDateTime.IsValidDateTime)
			{
				string value11 = FormattableString.Invariant($"timestamp('{mySqlDateTime.GetDateTime():yyyy'-'MM'-'dd' 'HH':'mm':'ss'.'ffffff}')");
				writer.WriteAscii(value11);
			}
			else
			{
				writer.Write("timestamp('0000-00-00')"u8);
			}
			return;
		}
		if (Value is DateTime dateTime)
		{
			if ((options & StatementPreparerOptions.DateTimeUtc) != 0 && dateTime.Kind == DateTimeKind.Local)
			{
				throw new MySqlException("DateTime.Kind must not be Local when DateTimeKind setting is Utc (parameter name: " + ParameterName + ")");
			}
			if ((options & StatementPreparerOptions.DateTimeLocal) != 0 && dateTime.Kind == DateTimeKind.Utc)
			{
				throw new MySqlException("DateTime.Kind must not be Utc when DateTimeKind setting is Local (parameter name: " + ParameterName + ")");
			}
			string value12 = FormattableString.Invariant($"timestamp('{dateTime:yyyy'-'MM'-'dd' 'HH':'mm':'ss'.'ffffff}')");
			writer.WriteAscii(value12);
			return;
		}
		if (Value is DateTimeOffset dateTimeOffset)
		{
			string value13 = FormattableString.Invariant($"timestamp('{dateTimeOffset.UtcDateTime:yyyy'-'MM'-'dd' 'HH':'mm':'ss'.'ffffff}')");
			writer.WriteAscii(value13);
			return;
		}
		if (Value is TimeSpan timeSpan)
		{
			writer.Write("time '"u8);
			if (timeSpan.Ticks < 0)
			{
				writer.Write((byte)45);
				timeSpan = TimeSpan.FromTicks(-timeSpan.Ticks);
			}
			string value14 = FormattableString.Invariant($"{timeSpan.Days * 24 + timeSpan.Hours}:{timeSpan:mm':'ss'.'ffffff}'");
			writer.WriteAscii(value14);
			return;
		}
		if (Value is Guid value15)
		{
			StatementPreparerOptions statementPreparerOptions = options & StatementPreparerOptions.GuidFormatMask;
			if ((statementPreparerOptions == StatementPreparerOptions.GuidFormatBinary16 || statementPreparerOptions == StatementPreparerOptions.GuidFormatTimeSwapBinary16 || statementPreparerOptions == StatementPreparerOptions.GuidFormatLittleEndianBinary16) ? true : false)
			{
				byte[] array2 = value15.ToByteArray();
				if (statementPreparerOptions != StatementPreparerOptions.GuidFormatLittleEndianBinary16)
				{
					Utility.SwapBytes(array2, 0, 3);
					Utility.SwapBytes(array2, 1, 2);
					Utility.SwapBytes(array2, 4, 5);
					Utility.SwapBytes(array2, 6, 7);
					if (statementPreparerOptions == StatementPreparerOptions.GuidFormatTimeSwapBinary16)
					{
						Utility.SwapBytes(array2, 0, 4);
						Utility.SwapBytes(array2, 1, 5);
						Utility.SwapBytes(array2, 2, 6);
						Utility.SwapBytes(array2, 3, 7);
						Utility.SwapBytes(array2, 0, 2);
						Utility.SwapBytes(array2, 1, 3);
					}
				}
				writer.Write(BinaryBytes);
				byte[] array3 = array2;
				foreach (byte b3 in array3)
				{
					if ((b3 == 0 || b3 == 39 || b3 == 92) ? true : false)
					{
						writer.Write((byte)92);
					}
					writer.Write((byte)((b3 == 0) ? 48 : b3));
				}
				writer.Write((byte)39);
			}
			else
			{
				bool flag5 = statementPreparerOptions == StatementPreparerOptions.GuidFormatChar32;
				int num5 = (flag5 ? 34 : 38);
				Span<byte> span2 = writer.GetSpan(num5);
				span2[0] = 39;
				Utf8Formatter.TryFormat(value15, span2.Slice(1, span2.Length - 1), out var _, flag5 ? 'N' : 'D');
				span2[num5 - 1] = 39;
				writer.Advance(num5);
			}
			return;
		}
		if (Value is StringBuilder stringBuilder)
		{
			WriteString(writer, flag, MemoryExtensions.AsSpan(stringBuilder.ToString()));
			return;
		}
		MySqlDbType mySqlDbType = MySqlDbType;
		flag2 = (uint)(mySqlDbType - 253) <= 1u;
		if (flag2 && HasSetDbType && Value is Enum @enum)
		{
			writer.Write((byte)39);
			writer.Write(@enum.ToString("G"));
			writer.Write((byte)39);
			return;
		}
		if (Value is Enum enum2)
		{
			writer.Write(enum2.ToString("d"));
			return;
		}
		if (MySqlDbType == MySqlDbType.Int16)
		{
			writer.WriteString((short)Value);
			return;
		}
		if (MySqlDbType == MySqlDbType.UInt16)
		{
			writer.WriteString((ushort)Value);
			return;
		}
		if (MySqlDbType == MySqlDbType.Int32)
		{
			writer.WriteString((int)Value);
			return;
		}
		if (MySqlDbType == MySqlDbType.UInt32)
		{
			writer.WriteString((uint)Value);
			return;
		}
		if (MySqlDbType == MySqlDbType.Int64)
		{
			writer.WriteString((long)Value);
			return;
		}
		if (MySqlDbType == MySqlDbType.UInt64)
		{
			writer.WriteString((ulong)Value);
			return;
		}
		throw new NotSupportedException($"Parameter type {Value.GetType().Name} is not supported; see https://fl.vu/mysql-param-type. Value: {Value}");
		IL_0112:
		writer.Write((byte)39);
		return;
		IL_0105:
		writer.Write(c.ToString());
		goto IL_0112;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
		static void WriteString([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ByteBufferWriter writer, bool noBackslashEscapes, ReadOnlySpan<char> value)
		{
			writer.Write((byte)39);
			int num6 = 0;
			while (num6 < value.Length)
			{
				int num7 = num6;
				ReadOnlySpan<char> readOnlySpan3 = value.Slice(num7, value.Length - num7);
				int num8 = readOnlySpan3.IndexOfAny('\0', '\'', '\\');
				if (num8 == -1)
				{
					writer.Write(readOnlySpan3);
					num6 += readOnlySpan3.Length;
				}
				else
				{
					writer.Write(readOnlySpan3.Slice(0, num8));
					if (readOnlySpan3[num8] == '\\' && !noBackslashEscapes)
					{
						writer.Write((ushort)23644);
					}
					else if (readOnlySpan3[num8] == '\\' && noBackslashEscapes)
					{
						writer.Write((byte)92);
					}
					else if (readOnlySpan3[num8] == '\'')
					{
						writer.Write((ushort)10023);
					}
					else if (readOnlySpan3[num8] == '\0' && !noBackslashEscapes)
					{
						writer.Write((ushort)12380);
					}
					else if (readOnlySpan3[num8] == '\0' && noBackslashEscapes)
					{
						writer.Write((byte)0);
					}
					num6 += num8 + 1;
				}
			}
			writer.Write((byte)39);
		}
	}

	internal void AppendBinary(ByteBufferWriter writer, StatementPreparerOptions options)
	{
		if (Value != null && Value != DBNull.Value)
		{
			AppendBinary(writer, Value, options);
		}
	}

	private void AppendBinary(ByteBufferWriter writer, object value, StatementPreparerOptions options)
	{
		if (value is string value2)
		{
			writer.WriteLengthEncodedString(value2);
			return;
		}
		if (value is char c)
		{
			writer.WriteLengthEncodedString(c.ToString());
			return;
		}
		if (value is sbyte b)
		{
			writer.Write((byte)b);
			return;
		}
		if (value is byte value3)
		{
			writer.Write(value3);
			return;
		}
		if (value is bool flag)
		{
			writer.Write(flag ? ((byte)1) : ((byte)0));
			return;
		}
		if (value is short num)
		{
			writer.Write((ushort)num);
			return;
		}
		if (value is ushort value4)
		{
			writer.Write(value4);
			return;
		}
		if (value is int value5)
		{
			writer.Write(value5);
			return;
		}
		if (value is uint value6)
		{
			writer.Write(value6);
			return;
		}
		if (value is long value7)
		{
			writer.Write((ulong)value7);
			return;
		}
		if (value is ulong value8)
		{
			writer.Write(value8);
			return;
		}
		if (value is byte[] array)
		{
			writer.WriteLengthEncodedInteger((ulong)array.Length);
			writer.Write((ReadOnlySpan<byte>)array);
			return;
		}
		if (value is ReadOnlyMemory<byte> readOnlyMemory)
		{
			writer.WriteLengthEncodedInteger((ulong)readOnlyMemory.Length);
			writer.Write(readOnlyMemory.Span);
			return;
		}
		if (value is Memory<byte> memory)
		{
			writer.WriteLengthEncodedInteger((ulong)memory.Length);
			writer.Write(memory.Span);
			return;
		}
		if (value is ArraySegment<byte> arraySegment)
		{
			writer.WriteLengthEncodedInteger((ulong)arraySegment.Count);
			writer.Write(arraySegment);
			return;
		}
		if (value is MySqlGeometry mySqlGeometry)
		{
			writer.WriteLengthEncodedInteger((ulong)mySqlGeometry.ValueSpan.Length);
			writer.Write(mySqlGeometry.ValueSpan);
			return;
		}
		if (value is MemoryStream memoryStream)
		{
			if (!memoryStream.TryGetBuffer(out var buffer))
			{
				buffer = new ArraySegment<byte>(memoryStream.ToArray());
			}
			writer.WriteLengthEncodedInteger((ulong)buffer.Count);
			writer.Write(buffer);
			return;
		}
		if (value is float value9)
		{
			writer.Write((ReadOnlySpan<byte>)BitConverter.GetBytes(value9));
			return;
		}
		if (value is double value10)
		{
			writer.Write((ulong)BitConverter.DoubleToInt64Bits(value10));
			return;
		}
		if (value is decimal num2)
		{
			writer.WriteLengthEncodedAsciiString(num2.ToString(CultureInfo.InvariantCulture));
			return;
		}
		if (value is BigInteger bigInteger)
		{
			writer.WriteLengthEncodedAsciiString(bigInteger.ToString(CultureInfo.InvariantCulture));
			return;
		}
		if (value is MySqlDateTime mySqlDateTime)
		{
			if (mySqlDateTime.IsValidDateTime)
			{
				WriteDateTime(writer, mySqlDateTime.GetDateTime());
			}
			else
			{
				writer.Write((byte)0);
			}
			return;
		}
		if (value is MySqlDecimal mySqlDecimal)
		{
			writer.WriteLengthEncodedAsciiString(mySqlDecimal.ToString());
			return;
		}
		if (value is DateTime dateTime)
		{
			if ((options & StatementPreparerOptions.DateTimeUtc) != 0 && dateTime.Kind == DateTimeKind.Local)
			{
				throw new MySqlException("DateTime.Kind must not be Local when DateTimeKind setting is Utc (parameter name: " + ParameterName + ")");
			}
			if ((options & StatementPreparerOptions.DateTimeLocal) != 0 && dateTime.Kind == DateTimeKind.Utc)
			{
				throw new MySqlException("DateTime.Kind must not be Utc when DateTimeKind setting is Local (parameter name: " + ParameterName + ")");
			}
			WriteDateTime(writer, dateTime);
			return;
		}
		if (value is DateTimeOffset dateTimeOffset)
		{
			WriteDateTime(writer, dateTimeOffset.UtcDateTime);
			return;
		}
		if (value is TimeSpan timeSpan)
		{
			WriteTime(writer, timeSpan);
			return;
		}
		if (value is Guid value11)
		{
			StatementPreparerOptions statementPreparerOptions = options & StatementPreparerOptions.GuidFormatMask;
			if ((statementPreparerOptions == StatementPreparerOptions.GuidFormatBinary16 || statementPreparerOptions == StatementPreparerOptions.GuidFormatTimeSwapBinary16 || statementPreparerOptions == StatementPreparerOptions.GuidFormatLittleEndianBinary16) ? true : false)
			{
				byte[] array2 = value11.ToByteArray();
				if (statementPreparerOptions != StatementPreparerOptions.GuidFormatLittleEndianBinary16)
				{
					Utility.SwapBytes(array2, 0, 3);
					Utility.SwapBytes(array2, 1, 2);
					Utility.SwapBytes(array2, 4, 5);
					Utility.SwapBytes(array2, 6, 7);
					if (statementPreparerOptions == StatementPreparerOptions.GuidFormatTimeSwapBinary16)
					{
						Utility.SwapBytes(array2, 0, 4);
						Utility.SwapBytes(array2, 1, 5);
						Utility.SwapBytes(array2, 2, 6);
						Utility.SwapBytes(array2, 3, 7);
						Utility.SwapBytes(array2, 0, 2);
						Utility.SwapBytes(array2, 1, 3);
					}
				}
				writer.Write((byte)16);
				writer.Write((ReadOnlySpan<byte>)array2);
			}
			else
			{
				bool flag2 = statementPreparerOptions == StatementPreparerOptions.GuidFormatChar32;
				int num3 = (flag2 ? 32 : 36);
				writer.Write((byte)num3);
				Span<byte> span = writer.GetSpan(num3);
				Utf8Formatter.TryFormat(value11, span, out var _, flag2 ? 'N' : 'D');
				writer.Advance(num3);
			}
			return;
		}
		if (value is ReadOnlyMemory<char> readOnlyMemory2)
		{
			writer.WriteLengthEncodedString(readOnlyMemory2.Span);
			return;
		}
		if (value is Memory<char> memory2)
		{
			writer.WriteLengthEncodedString(memory2.Span);
			return;
		}
		if (value is StringBuilder stringBuilder)
		{
			writer.WriteLengthEncodedString(stringBuilder);
			return;
		}
		MySqlDbType mySqlDbType = MySqlDbType;
		bool flag3 = (uint)(mySqlDbType - 253) <= 1u;
		if (flag3 && HasSetDbType && value is Enum @enum)
		{
			writer.WriteLengthEncodedString(@enum.ToString("G"));
			return;
		}
		if (value is Enum)
		{
			object value12 = Convert.ChangeType(value, Enum.GetUnderlyingType(value.GetType()), CultureInfo.InvariantCulture);
			AppendBinary(writer, value12, options);
			return;
		}
		if (MySqlDbType == MySqlDbType.Int16)
		{
			writer.Write((ushort)(short)value);
			return;
		}
		if (MySqlDbType == MySqlDbType.UInt16)
		{
			writer.Write((ushort)value);
			return;
		}
		if (MySqlDbType == MySqlDbType.Int32)
		{
			writer.Write((int)value);
			return;
		}
		if (MySqlDbType == MySqlDbType.UInt32)
		{
			writer.Write((uint)value);
			return;
		}
		if (MySqlDbType == MySqlDbType.Int64)
		{
			writer.Write((ulong)(long)value);
			return;
		}
		if (MySqlDbType == MySqlDbType.UInt64)
		{
			writer.Write((ulong)value);
			return;
		}
		throw new NotSupportedException($"Parameter type {value.GetType().Name} is not supported; see https://fl.vu/mysql-param-type. Value: {value}");
	}

	internal static string NormalizeParameterName(string name)
	{
		string text = name.Trim();
		int length;
		if (text != null)
		{
			length = text.Length;
			if (length < 3)
			{
				if (length >= 1)
				{
					char c = text[0];
					if (c == '?' || c == '@')
					{
						goto IL_00c9;
					}
				}
			}
			else
			{
				char c = text[0];
				if (c == '?' || c == '@')
				{
					switch (text[1])
					{
					case '`':
					{
						string text2 = text.Substring(2, length - 1 - 2);
						if (text[length - 1] != '`')
						{
							break;
						}
						return text2.Replace("``", "`");
					}
					case '\'':
					{
						string text2 = text.Substring(2, length - 1 - 2);
						if (text[length - 1] != '\'')
						{
							break;
						}
						return text2.Replace("''", "'");
					}
					case '"':
					{
						string text2 = text.Substring(2, length - 1 - 2);
						if (text[length - 1] != '"')
						{
							break;
						}
						return text2.Replace("\"\"", "\"");
					}
					}
					goto IL_00c9;
				}
			}
			return text;
		}
		<54935a9f-04ec-42f0-b2db-de3406f234de><PrivateImplementationDetails>.ThrowInvalidOperationException();
		string result = default(string);
		return result;
		IL_00c9:
		return text.Substring(1, length - 1);
	}

	private static void WriteDateTime(ByteBufferWriter writer, DateTime dateTime)
	{
		int num = (int)(dateTime.Ticks % 10000000) / 10;
		byte b = (byte)((num != 0) ? 11 : ((dateTime.Hour == 0 && dateTime.Minute == 0 && dateTime.Second == 0) ? 4 : 7));
		writer.Write(b);
		writer.Write((ushort)dateTime.Year);
		writer.Write((byte)dateTime.Month);
		writer.Write((byte)dateTime.Day);
		if (b > 4)
		{
			writer.Write((byte)dateTime.Hour);
			writer.Write((byte)dateTime.Minute);
			writer.Write((byte)dateTime.Second);
			if (b > 7)
			{
				writer.Write(num);
			}
		}
	}

	private static void WriteTime(ByteBufferWriter writer, TimeSpan timeSpan)
	{
		long ticks = timeSpan.Ticks;
		if (ticks == 0L)
		{
			writer.Write((byte)0);
			return;
		}
		if (ticks < 0)
		{
			timeSpan = TimeSpan.FromTicks(-ticks);
		}
		int num = (int)(timeSpan.Ticks % 10000000) / 10;
		writer.Write((byte)((num == 0) ? 8u : 12u));
		writer.Write((ticks < 0) ? ((byte)1) : ((byte)0));
		writer.Write(timeSpan.Days);
		writer.Write((byte)timeSpan.Hours);
		writer.Write((byte)timeSpan.Minutes);
		writer.Write((byte)timeSpan.Seconds);
		if (num != 0)
		{
			writer.Write(num);
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Linq;
using System.Runtime.CompilerServices;
using MySqlConnector;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlParameterCollection : DbParameterCollection, IEnumerable<MySqlParameter>, IEnumerable
{
	private readonly List<MySqlParameter> m_parameters;

	private readonly Dictionary<string, int> m_nameToIndex;

	public override bool IsFixedSize => false;

	public override bool IsReadOnly => false;

	public override bool IsSynchronized => false;

	public override int Count => m_parameters.Count;

	public override object SyncRoot
	{
		get
		{
			throw new NotSupportedException();
		}
	}

	public new MySqlParameter this[int index]
	{
		get
		{
			return m_parameters[index];
		}
		set
		{
			SetParameter(index, value);
		}
	}

	public new MySqlParameter this[string name]
	{
		get
		{
			return (MySqlParameter)GetParameter(name);
		}
		set
		{
			SetParameter(name, value);
		}
	}

	internal MySqlParameterCollection()
	{
		m_parameters = new List<MySqlParameter>();
		m_nameToIndex = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
	}

	public MySqlParameter Add(string parameterName, DbType dbType)
	{
		MySqlParameter mySqlParameter = new MySqlParameter
		{
			ParameterName = parameterName,
			DbType = dbType
		};
		AddParameter(mySqlParameter, m_parameters.Count);
		return mySqlParameter;
	}

	public override int Add(object value)
	{
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		AddParameter((MySqlParameter)value, m_parameters.Count);
		return m_parameters.Count - 1;
	}

	public MySqlParameter Add(MySqlParameter parameter)
	{
		if (parameter == null)
		{
			throw new ArgumentNullException("parameter");
		}
		AddParameter(parameter, m_parameters.Count);
		return parameter;
	}

	public MySqlParameter Add(string parameterName, MySqlDbType mySqlDbType)
	{
		return Add(new MySqlParameter(parameterName, mySqlDbType));
	}

	public MySqlParameter Add(string parameterName, MySqlDbType mySqlDbType, int size)
	{
		return Add(new MySqlParameter(parameterName, mySqlDbType, size));
	}

	public override void AddRange(Array values)
	{
		foreach (object value in values)
		{
			Add(value);
		}
	}

	public MySqlParameter AddWithValue(string parameterName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] object value)
	{
		MySqlParameter mySqlParameter = new MySqlParameter
		{
			ParameterName = parameterName,
			Value = value
		};
		AddParameter(mySqlParameter, m_parameters.Count);
		return mySqlParameter;
	}

	public override bool Contains(object value)
	{
		if (value is MySqlParameter item)
		{
			return m_parameters.Contains(item);
		}
		return false;
	}

	public override bool Contains(string value)
	{
		return IndexOf(value) != -1;
	}

	public override void CopyTo(Array array, int index)
	{
		((ICollection)m_parameters).CopyTo(array, index);
	}

	public override void Clear()
	{
		foreach (MySqlParameter parameter in m_parameters)
		{
			parameter.ParameterCollection = null;
		}
		m_parameters.Clear();
		m_nameToIndex.Clear();
	}

	public override IEnumerator GetEnumerator()
	{
		return m_parameters.GetEnumerator();
	}

	IEnumerator<MySqlParameter> IEnumerable<MySqlParameter>.GetEnumerator()
	{
		return m_parameters.GetEnumerator();
	}

	protected override DbParameter GetParameter(int index)
	{
		return m_parameters[index];
	}

	protected override DbParameter GetParameter(string parameterName)
	{
		int num = IndexOf(parameterName);
		if (num == -1)
		{
			throw new ArgumentException("Parameter '" + parameterName + "' not found in the collection", "parameterName");
		}
		return m_parameters[num];
	}

	public override int IndexOf(object value)
	{
		if (!(value is MySqlParameter item))
		{
			return -1;
		}
		return m_parameters.IndexOf(item);
	}

	public override int IndexOf(string parameterName)
	{
		return NormalizedIndexOf(parameterName);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	internal int NormalizedIndexOf(string parameterName)
	{
		return UnsafeIndexOf(MySqlParameter.NormalizeParameterName(parameterName ?? ""));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	internal int UnsafeIndexOf(string normalizedParameterName)
	{
		if (!m_nameToIndex.TryGetValue(normalizedParameterName ?? "", out var value))
		{
			return -1;
		}
		return value;
	}

	public override void Insert(int index, object value)
	{
		AddParameter((MySqlParameter)(value ?? throw new ArgumentNullException("value")), index);
	}

	public override void Remove(object value)
	{
		RemoveAt(IndexOf(value ?? throw new ArgumentNullException("value")));
	}

	public override void RemoveAt(int index)
	{
		MySqlParameter mySqlParameter = m_parameters[index];
		if (mySqlParameter.NormalizedParameterName != null)
		{
			m_nameToIndex.Remove(mySqlParameter.NormalizedParameterName);
		}
		mySqlParameter.ParameterCollection = null;
		m_parameters.RemoveAt(index);
		foreach (KeyValuePair<string, int> item in m_nameToIndex.ToList())
		{
			if (item.Value > index)
			{
				m_nameToIndex[item.Key] = item.Value - 1;
			}
		}
	}

	public override void RemoveAt(string parameterName)
	{
		RemoveAt(IndexOf(parameterName));
	}

	protected override void SetParameter(int index, DbParameter value)
	{
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		MySqlParameter mySqlParameter = (MySqlParameter)value;
		MySqlParameter mySqlParameter2 = m_parameters[index];
		if (mySqlParameter2.NormalizedParameterName != null)
		{
			m_nameToIndex.Remove(mySqlParameter2.NormalizedParameterName);
		}
		mySqlParameter2.ParameterCollection = null;
		m_parameters[index] = mySqlParameter;
		if (mySqlParameter.NormalizedParameterName != null)
		{
			m_nameToIndex.Add(mySqlParameter.NormalizedParameterName, index);
		}
		mySqlParameter.ParameterCollection = this;
	}

	protected override void SetParameter(string parameterName, DbParameter value)
	{
		SetParameter(IndexOf(parameterName), value);
	}

	internal void ChangeParameterName(MySqlParameter parameter, string oldName, string newName)
	{
		if (m_nameToIndex.TryGetValue(oldName, out var value) && m_parameters[value] == parameter)
		{
			m_nameToIndex.Remove(oldName);
		}
		else
		{
			value = m_parameters.IndexOf(parameter);
		}
		if (newName.Length != 0)
		{
			if (m_nameToIndex.ContainsKey(newName))
			{
				throw new MySqlException("There is already a parameter with the name '" + parameter.ParameterName + "' in this collection.");
			}
			m_nameToIndex[newName] = value;
		}
	}

	private void AddParameter(MySqlParameter parameter, int index)
	{
		if (!string.IsNullOrEmpty(parameter.NormalizedParameterName) && NormalizedIndexOf(parameter.NormalizedParameterName) != -1)
		{
			throw new MySqlException("Parameter '" + parameter.ParameterName + "' has already been defined.");
		}
		if (index < m_parameters.Count)
		{
			foreach (KeyValuePair<string, int> item in m_nameToIndex.ToList())
			{
				if (item.Value >= index)
				{
					m_nameToIndex[item.Key] = item.Value + 1;
				}
			}
		}
		m_parameters.Insert(index, parameter);
		if (!string.IsNullOrEmpty(parameter.NormalizedParameterName))
		{
			m_nameToIndex[parameter.NormalizedParameterName] = index;
		}
		parameter.ParameterCollection = this;
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using MySqlConnector;

[Serializable]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public sealed class MySqlProtocolException : InvalidOperationException
{
	internal static MySqlProtocolException CreateForPacketOutOfOrder(int expectedSequenceNumber, int packetSequenceNumber)
	{
		return new MySqlProtocolException($"Packet received out-of-order. Expected {expectedSequenceNumber:d}; got {packetSequenceNumber:d}.");
	}

	private MySqlProtocolException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}

	private MySqlProtocolException(string message)
		: base(message)
	{
	}
}


using System.Runtime.CompilerServices;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public sealed class MySqlProvidePasswordContext
{
	public string Server { get; }

	public int Port { get; }

	public string UserId { get; }

	public string Database { get; }

	internal MySqlProvidePasswordContext(string server, int port, string userId, string database)
	{
		Server = server;
		Port = port;
		UserId = userId;
		Database = database;
	}
}


using System;

public sealed class MySqlRowsCopiedEventArgs : EventArgs
{
	public bool Abort { get; set; }

	public long RowsCopied { get; internal set; }

	internal MySqlRowsCopiedEventArgs()
	{
	}
}


using MySqlConnector;

public delegate void MySqlRowsCopiedEventHandler(object sender, MySqlRowsCopiedEventArgs e);


public enum MySqlServerRedirectionMode
{
	Disabled,
	Preferred,
	Required
}


public enum MySqlSslMode
{
	None = 0,
	Disabled = 0,
	Preferred = 1,
	Required = 2,
	VerifyCA = 3,
	VerifyFull = 4
}


using System;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.IO;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using MySqlConnector.Logging;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public sealed class MySqlTransaction : DbTransaction
{
	private readonly ILogger m_logger;

	private bool m_isDisposed;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public new MySqlConnection Connection
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		private set;
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	protected override DbConnection DbConnection
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get
		{
			return Connection;
		}
	}

	public override IsolationLevel IsolationLevel { get; }

	public override void Commit()
	{
		CommitAsync(IOBehavior.Synchronous, default(CancellationToken)).GetAwaiter().GetResult();
	}

	public new Task CommitAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return CommitAsync(Connection?.AsyncIOBehavior ?? IOBehavior.Asynchronous, cancellationToken);
	}

	private async Task CommitAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		VerifyValid();
		using Activity activity = Connection.Session.StartActivity("Commit");
		Log.CommittingTransaction(m_logger, Connection.Session.Id);
		try
		{
			using (MySqlCommand cmd = new MySqlCommand("commit", Connection, this)
			{
				NoActivity = true
			})
			{
				await cmd.ExecuteNonQueryAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			Connection.CurrentTransaction = null;
			Log.CommittedTransaction(m_logger, Connection.Session.Id);
			Connection = null;
		}
		catch (Exception exception) when (activity?.IsAllDataRequested ?? false)
		{
			activity.SetException(exception);
			throw;
		}
	}

	public override void Rollback()
	{
		RollbackAsync(IOBehavior.Synchronous, default(CancellationToken)).GetAwaiter().GetResult();
	}

	public new Task RollbackAsync(CancellationToken cancellationToken = default(CancellationToken))
	{
		return RollbackAsync(Connection?.AsyncIOBehavior ?? IOBehavior.Asynchronous, cancellationToken);
	}

	private async Task RollbackAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		VerifyValid();
		await DoRollback(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		Connection.CurrentTransaction = null;
		Connection = null;
	}

	public new void Release(string savepointName)
	{
		ExecuteSavepointAsync("release ", savepointName, IOBehavior.Synchronous, default(CancellationToken)).GetAwaiter().GetResult();
	}

	public new Task ReleaseAsync(string savepointName, CancellationToken cancellationToken = default(CancellationToken))
	{
		return ExecuteSavepointAsync("release ", savepointName, Connection?.AsyncIOBehavior ?? IOBehavior.Asynchronous, cancellationToken);
	}

	public new void Rollback(string savepointName)
	{
		ExecuteSavepointAsync("rollback to ", savepointName, IOBehavior.Synchronous, default(CancellationToken)).GetAwaiter().GetResult();
	}

	public new Task RollbackAsync(string savepointName, CancellationToken cancellationToken = default(CancellationToken))
	{
		return ExecuteSavepointAsync("rollback to ", savepointName, Connection?.AsyncIOBehavior ?? IOBehavior.Asynchronous, cancellationToken);
	}

	public new void Save(string savepointName)
	{
		ExecuteSavepointAsync("", savepointName, IOBehavior.Synchronous, default(CancellationToken)).GetAwaiter().GetResult();
	}

	public new Task SaveAsync(string savepointName, CancellationToken cancellationToken = default(CancellationToken))
	{
		return ExecuteSavepointAsync("", savepointName, Connection?.AsyncIOBehavior ?? IOBehavior.Asynchronous, cancellationToken);
	}

	private async Task ExecuteSavepointAsync(string command, string savepointName, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		VerifyValid();
		if (savepointName == null)
		{
			throw new ArgumentNullException("savepointName");
		}
		if (savepointName.Length == 0)
		{
			throw new ArgumentException("savepointName must not be empty", "savepointName");
		}
		using MySqlCommand cmd = new MySqlCommand(command + "savepoint " + QuoteIdentifier(savepointName), Connection, this)
		{
			NoActivity = true
		};
		await cmd.ExecuteNonQueryAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	protected override void Dispose(bool disposing)
	{
		try
		{
			if (disposing)
			{
				DisposeAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
			}
		}
		finally
		{
			base.Dispose(disposing);
		}
	}

	public new Task DisposeAsync()
	{
		return DisposeAsync(Connection?.AsyncIOBehavior ?? IOBehavior.Asynchronous, CancellationToken.None);
	}

	internal Task DisposeAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		m_isDisposed = true;
		if (Connection?.CurrentTransaction == this)
		{
			return DoDisposeAsync(ioBehavior, cancellationToken);
		}
		Connection = null;
		return Task.CompletedTask;
	}

	private async Task DoDisposeAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (Connection?.CurrentTransaction == this)
		{
			if (Connection.State == ConnectionState.Open && Connection.Session.IsConnected)
			{
				try
				{
					await DoRollback(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (IOException)
				{
				}
				catch (SocketException)
				{
				}
			}
			Connection.CurrentTransaction = null;
		}
		Connection = null;
	}

	internal MySqlTransaction(MySqlConnection connection, IsolationLevel isolationLevel, ILogger logger)
	{
		Connection = connection;
		IsolationLevel = isolationLevel;
		m_logger = logger;
		Log.StartedTransaction(m_logger, Connection.Session.Id);
	}

	private async Task DoRollback(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		using Activity activity = Connection.Session.StartActivity("Rollback");
		Log.RollingBackTransaction(m_logger, Connection.Session.Id);
		try
		{
			using MySqlCommand cmd = new MySqlCommand("rollback", Connection, this)
			{
				NoActivity = true
			};
			await cmd.ExecuteNonQueryAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			Log.RolledBackTransaction(m_logger, Connection.Session.Id);
		}
		catch (Exception exception) when (activity?.IsAllDataRequested ?? false)
		{
			activity.SetException(exception);
			throw;
		}
	}

	private void VerifyValid()
	{
		if (m_isDisposed)
		{
			throw new ObjectDisposedException("MySqlTransaction");
		}
		if (Connection == null)
		{
			throw new InvalidOperationException("Already committed or rolled back.");
		}
		if (Connection.CurrentTransaction == null)
		{
			throw new InvalidOperationException("There is no active transaction.");
		}
		if (Connection.CurrentTransaction != this)
		{
			throw new InvalidOperationException("This is not the active transaction.");
		}
	}

	private static string QuoteIdentifier(string identifier)
	{
		return "`" + identifier.Replace("`", "``") + "`";
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Globalization;
using System.Reflection;
using System.Runtime.CompilerServices;
using MySqlConnector;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal static class ActivitySourceHelper
{
	public const string DatabaseConnectionIdTagName = "db.connection_id";

	public const string DatabaseConnectionStringTagName = "db.connection_string";

	public const string DatabaseNameTagName = "db.name";

	public const string DatabaseStatementTagName = "db.statement";

	public const string DatabaseSystemTagName = "db.system";

	public const string DatabaseUserTagName = "db.user";

	public const string NetPeerIpTagName = "net.peer.ip";

	public const string NetPeerNameTagName = "net.peer.name";

	public const string NetPeerPortTagName = "net.peer.port";

	public const string NetTransportTagName = "net.transport";

	public const string ThreadIdTagName = "thread.id";

	public const string DatabaseSystemValue = "mysql";

	public const string NetTransportNamedPipeValue = "pipe";

	public const string NetTransportTcpIpValue = "ip_tcp";

	public const string NetTransportUnixValue = "unix";

	public const string ExecuteActivityName = "Execute";

	public const string OpenActivityName = "Open";

	public static Meter Meter { get; } = new Meter("MySqlConnector", GetVersion());

	private static ActivitySource ActivitySource { get; } = new ActivitySource("MySqlConnector", GetVersion());

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public static Activity StartActivity(string name, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 0, 1, 2 })] IEnumerable<KeyValuePair<string, object>> activityTags = null)
	{
		Activity activity = ActivitySource.StartActivity(name, ActivityKind.Client, default(ActivityContext), activityTags);
		if (activity != null && activity.IsAllDataRequested)
		{
			activity.SetTag("thread.id", Environment.CurrentManagedThreadId.ToString(CultureInfo.InvariantCulture));
		}
		return activity;
	}

	public static void SetException(this Activity activity, Exception exception)
	{
		string description = ((exception is MySqlException { ErrorCode: var errorCode }) ? errorCode.ToString() : exception.Message);
		activity.SetStatus(ActivityStatusCode.Error, description);
		ActivityTagsCollection tags = new ActivityTagsCollection
		{
			{
				"exception.type",
				exception.GetType().FullName
			},
			{ "exception.message", exception.Message },
			{
				"exception.stacktrace",
				exception.ToString()
			}
		};
		activity.AddEvent(new ActivityEvent("exception", default(DateTimeOffset), tags));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public static void CopyTags([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })] IEnumerable<KeyValuePair<string, object>> tags, Activity activity)
	{
		if (activity == null || !activity.IsAllDataRequested)
		{
			return;
		}
		foreach (KeyValuePair<string, object> tag in tags)
		{
			activity.SetTag(tag.Key, tag.Value);
		}
	}

	private static string GetVersion()
	{
		return typeof(ActivitySourceHelper).Assembly.GetCustomAttribute<AssemblyFileVersionAttribute>().Version;
	}
}


using System;
using System.Runtime.CompilerServices;

internal static class Adler32
{
	public const uint SeedValue = 1u;

	private const uint BASE = 65521u;

	private const uint NMAX = 5552u;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static uint Calculate(ReadOnlySpan<byte> buffer)
	{
		if (buffer.IsEmpty)
		{
			return 1u;
		}
		return CalculateScalar(buffer);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private unsafe static uint CalculateScalar(ReadOnlySpan<byte> buffer)
	{
		uint num = 1u;
		uint num2 = 0u;
		fixed (byte* ptr = buffer)
		{
			byte* ptr2 = ptr;
			uint num3 = (uint)buffer.Length;
			while (num3 != 0)
			{
				uint num4 = ((num3 < 5552) ? num3 : 5552u);
				num3 -= num4;
				while (num4 >= 16)
				{
					num2 += (num += *ptr2);
					num2 += (num += ptr2[1]);
					num2 += (num += ptr2[2]);
					num2 += (num += ptr2[3]);
					num2 += (num += ptr2[4]);
					num2 += (num += ptr2[5]);
					num2 += (num += ptr2[6]);
					num2 += (num += ptr2[7]);
					num2 += (num += ptr2[8]);
					num2 += (num += ptr2[9]);
					num2 += (num += ptr2[10]);
					num2 += (num += ptr2[11]);
					num2 += (num += ptr2[12]);
					num2 += (num += ptr2[13]);
					num2 += (num += ptr2[14]);
					num2 += (num += ptr2[15]);
					ptr2 += 16;
					num4 -= 16;
				}
				while (num4-- != 0)
				{
					num2 += (num += *(ptr2++));
				}
				num %= 65521;
				num2 %= 65521;
			}
			return (num2 << 16) | num;
		}
	}
}


internal static class Constants
{
	public const int InfiniteTimeout = int.MaxValue;
}


using System;
using System.Runtime.CompilerServices;

internal sealed class ResizableArray<[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] T>
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	private T[] m_array;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	public T[] Array
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
		get
		{
			return m_array;
		}
	}

	public int Count
	{
		get
		{
			T[] array = m_array;
			if (array == null)
			{
				return 0;
			}
			return array.Length;
		}
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public Span<T> AsSpan(int start)
	{
		return MemoryExtensions.AsSpan(m_array, start);
	}

	internal void DoResize(int length)
	{
		if (m_array == null || length > m_array.Length)
		{
			System.Array.Resize(ref m_array, Math.Max(length, Count * 2));
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal readonly struct ResizableArraySegment<T>
{
	public ResizableArray<T> Array { get; }

	public int Offset { get; }

	public int Count { get; }

	public ResizableArraySegment(ResizableArray<T> array, int offset, int count)
	{
		Array = array;
		Offset = offset;
		Count = count;
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public static implicit operator ReadOnlySpan<T>([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })] ResizableArraySegment<T> segment)
	{
		return new ReadOnlySpan<T>(segment.Array.Array, segment.Offset, segment.Count);
	}
}


using System;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class SocketAwaitable : INotifyCompletion
{
	private static readonly Action s_sentinel = delegate
	{
	};

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private Action m_continuation;

	public bool IsCompleted => WasCompleted;

	internal bool WasCompleted { get; set; }

	internal SocketAsyncEventArgs EventArgs { get; }

	public SocketAwaitable(SocketAsyncEventArgs eventArgs)
	{
		EventArgs = eventArgs ?? throw new ArgumentNullException("eventArgs");
		eventArgs.Completed += [<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)] (object s, SocketAsyncEventArgs e) =>
		{
			(m_continuation ?? Interlocked.CompareExchange(ref m_continuation, s_sentinel, null))?.Invoke();
		};
	}

	public SocketAwaitable GetAwaiter()
	{
		return this;
	}

	public void OnCompleted(Action continuation)
	{
		if (m_continuation == s_sentinel || Interlocked.CompareExchange(ref m_continuation, continuation, null) == s_sentinel)
		{
			Task.Run(continuation);
		}
	}

	public void GetResult()
	{
		if (EventArgs.SocketError != 0)
		{
			throw new SocketException((int)EventArgs.SocketError);
		}
	}

	internal void Reset()
	{
		WasCompleted = false;
		m_continuation = null;
	}
}


using System;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MySqlConnector.Utilities;

internal static class SocketExtensions
{
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static SocketAwaitable ReceiveAsync(this Socket socket, SocketAwaitable awaitable)
	{
		awaitable.Reset();
		if (!socket.ReceiveAsync(awaitable.EventArgs))
		{
			awaitable.WasCompleted = true;
		}
		return awaitable;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static SocketAwaitable SendAsync(this Socket socket, SocketAwaitable awaitable)
	{
		awaitable.Reset();
		if (!socket.SendAsync(awaitable.EventArgs))
		{
			awaitable.WasCompleted = true;
		}
		return awaitable;
	}

	public static void SetBuffer([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] this SocketAsyncEventArgs args, Memory<byte> buffer)
	{
		MemoryMarshal.TryGetArray((ReadOnlyMemory<byte>)buffer, out ArraySegment<byte> segment);
		args.SetBuffer(segment.Array, segment.Offset, segment.Count);
	}

	public static int Send([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] this Socket socket, ReadOnlyMemory<byte> data, SocketFlags flags)
	{
		MemoryMarshal.TryGetArray(data, out var segment);
		return socket.Send(segment.Array, segment.Offset, segment.Count, flags);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static void SetKeepAlive(this Socket socket, uint keepAliveTimeSeconds)
	{
		socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, optionValue: true);
		if (keepAliveTimeSeconds != 0 && Utility.IsWindows())
		{
			uint num = ((keepAliveTimeSeconds > 4294967) ? uint.MaxValue : (keepAliveTimeSeconds * 1000));
			socket.IOControl(IOControlCode.KeepAliveValues, new byte[12]
			{
				1,
				0,
				0,
				0,
				(byte)(num & 0xFF),
				(byte)((num >> 8) & 0xFF),
				(byte)((num >> 16) & 0xFF),
				(byte)((num >> 24) & 0xFF),
				232,
				3,
				0,
				0
			}, null);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class TimerQueue
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private readonly struct Data
	{
		public uint Id { get; }

		public int Time { get; }

		public Action Action { get; }

		public Data(uint id, int time, Action action)
		{
			Id = id;
			Time = time;
			Action = action;
		}
	}

	private readonly object m_lock;

	private readonly Timer m_timer;

	private readonly List<Data> m_timeoutActions;

	private uint m_counter;

	private bool m_isTimerEnabled;

	private int m_nextTimerTick;

	public static TimerQueue Instance { get; } = new TimerQueue();

	public uint Add(int delay, Action action)
	{
		if (delay < 0)
		{
			throw new ArgumentOutOfRangeException("delay", $"delay must not be negative: {delay}");
		}
		int tickCount = Environment.TickCount;
		lock (m_lock)
		{
			uint num = ++m_counter;
			if (num == 0)
			{
				num = ++m_counter;
			}
			int num2 = m_timeoutActions.Count;
			while (num2 > 0 && delay < m_timeoutActions[num2 - 1].Time - tickCount)
			{
				num2--;
			}
			int time = tickCount + delay;
			m_timeoutActions.Insert(num2, new Data(num, time, action));
			if (!m_isTimerEnabled || (num2 == 0 && m_nextTimerTick - tickCount > delay))
			{
				UnsafeSetTimer(delay);
			}
			return num;
		}
	}

	public bool Remove(uint id)
	{
		lock (m_lock)
		{
			for (int i = 0; i < m_timeoutActions.Count; i++)
			{
				if (m_timeoutActions[i].Id == id)
				{
					m_timeoutActions.RemoveAt(i);
					return true;
				}
			}
		}
		return false;
	}

	private TimerQueue()
	{
		m_lock = new object();
		m_timer = new Timer(Callback, this, -1, -1);
		m_timeoutActions = new List<Data>();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	private void Callback(object obj)
	{
		List<Action> list = new List<Action>();
		lock (m_lock)
		{
			while (m_timeoutActions.Count > 0 && m_timeoutActions[0].Time - Environment.TickCount < 15)
			{
				list.Add(m_timeoutActions[0].Action);
				m_timeoutActions.RemoveAt(0);
			}
			if (m_timeoutActions.Count == 0)
			{
				UnsafeClearTimer();
			}
			else
			{
				int delay = Math.Max(250, m_timeoutActions[0].Time - Environment.TickCount);
				UnsafeSetTimer(delay);
			}
		}
		foreach (Action item in list)
		{
			item();
		}
	}

	private void UnsafeSetTimer(int delay)
	{
		m_nextTimerTick = Environment.TickCount + delay;
		m_isTimerEnabled = true;
		m_timer.Change(delay, -1);
	}

	private void UnsafeClearTimer()
	{
		m_nextTimerTick = 0;
		m_isTimerEnabled = false;
		m_timer.Change(-1, -1);
	}
}


using System;
using System.Runtime.CompilerServices;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
private readonly struct Data
{
	public uint Id { get; }

	public int Time { get; }

	public Action Action { get; }

	public Data(uint id, int time, Action action)
	{
		Id = id;
		Time = time;
		Action = action;
	}
}


using System;
using System.Buffers.Text;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Authentication;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using MySqlConnector.Utilities;

internal static class Utility
{
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static void Dispose<T>([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] ref T disposable) where T : class, IDisposable
	{
		if (disposable != null)
		{
			disposable.Dispose();
			disposable = null;
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public unsafe static string GetString(this Encoding encoding, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> span)
	{
		if (span.Length == 0)
		{
			return "";
		}
		fixed (byte* reference = &MemoryMarshal.GetReference(span))
		{
			return encoding.GetString(reference, span.Length);
		}
	}

	public unsafe static int GetByteCount([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] this Encoding encoding, ReadOnlySpan<char> chars)
	{
		if (chars.Length == 0)
		{
			return 0;
		}
		fixed (char* reference = &MemoryMarshal.GetReference(chars))
		{
			return encoding.GetByteCount(reference, chars.Length);
		}
	}

	public unsafe static int GetBytes([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] this Encoding encoding, ReadOnlySpan<char> chars, Span<byte> bytes)
	{
		fixed (char* reference = &MemoryMarshal.GetReference(chars))
		{
			fixed (byte* reference2 = &MemoryMarshal.GetReference(bytes))
			{
				return encoding.GetBytes(reference, chars.Length, reference2, bytes.Length);
			}
		}
	}

	public unsafe static void Convert([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] this Encoder encoder, ReadOnlySpan<char> chars, Span<byte> bytes, bool flush, out int charsUsed, out int bytesUsed, out bool completed)
	{
		fixed (char* reference = &MemoryMarshal.GetReference(chars))
		{
			fixed (byte* reference2 = &MemoryMarshal.GetReference(bytes))
			{
				encoder.Convert(reference, chars.Length, (reference2 == null) ? ((byte*)1) : reference2, bytes.Length, flush, out charsUsed, out bytesUsed, out completed);
			}
		}
	}

	public unsafe static int GetByteCount([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] this Encoder encoder, ReadOnlySpan<char> chars, bool flush)
	{
		fixed (char* reference = &MemoryMarshal.GetReference(chars))
		{
			return encoder.GetByteCount(reference, chars.Length, flush);
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static RSAParameters GetRsaParameters(string key)
	{
		string text;
		bool isPrivate;
		int num;
		if ((num = key.IndexOf("-----BEGIN RSA PRIVATE KEY-----", StringComparison.Ordinal)) > -1)
		{
			num += "-----BEGIN RSA PRIVATE KEY-----".Length;
			text = "-----END RSA PRIVATE KEY-----";
			isPrivate = true;
		}
		else
		{
			if ((num = key.IndexOf("-----BEGIN PUBLIC KEY-----", StringComparison.Ordinal)) <= -1)
			{
				throw new FormatException("Unrecognized PEM header: " + key.Substring(0, Math.Min(key.Length, 80)));
			}
			num += "-----BEGIN PUBLIC KEY-----".Length;
			text = "-----END PUBLIC KEY-----";
			isPrivate = false;
		}
		int num2 = key.IndexOf(text, num, StringComparison.Ordinal);
		int num3;
		if (num2 <= -1)
		{
			string text2 = text;
			string text3 = key;
			num3 = Math.Max(key.Length - 80, 0);
			throw new FormatException("Missing expected '" + text2 + "' PEM footer: " + text3.Substring(num3, text3.Length - num3));
		}
		string text4 = key;
		num3 = num;
		key = text4.Substring(num3, num2 - num3);
		return GetRsaParameters(System.Convert.FromBase64String(key), isPrivate);
	}

	private static RSAParameters GetRsaParameters(ReadOnlySpan<byte> data, bool isPrivate)
	{
		if (data[0] != 48)
		{
			throw new FormatException($"Expected 0x30 but read 0x{data[0]:X2}");
		}
		ref ReadOnlySpan<byte> reference = ref data;
		data = reference.Slice(1, reference.Length - 1);
		if (!TryReadAsnLength(data, out var length, out var bytesConsumed))
		{
			throw new FormatException("Couldn't read key length");
		}
		reference = ref data;
		int num = bytesConsumed;
		data = reference.Slice(num, reference.Length - num);
		if (!isPrivate)
		{
			ReadOnlySpan<byte> other = new byte[15]
			{
				48, 13, 6, 9, 42, 134, 72, 134, 247, 13,
				1, 1, 1, 5, 0
			};
			if (!data.Slice(0, other.Length).SequenceEqual(other))
			{
				throw new FormatException("Expected RSA OID but read " + BitConverter.ToString(data.Slice(0, 15).ToArray()));
			}
			reference = ref data;
			num = other.Length;
			data = reference.Slice(num, reference.Length - num);
			if (data[0] != 3)
			{
				throw new FormatException($"Expected 0x03 but read 0x{data[0]:X2}");
			}
			reference = ref data;
			data = reference.Slice(1, reference.Length - 1);
			if (!TryReadAsnLength(data, out length, out bytesConsumed))
			{
				throw new FormatException("Couldn't read length");
			}
			reference = ref data;
			num = bytesConsumed;
			data = reference.Slice(num, reference.Length - num);
			if (data[0] != 0)
			{
				throw new FormatException($"Expected 0x00 but read 0x{data[0]:X2}");
			}
			reference = ref data;
			data = reference.Slice(1, reference.Length - 1);
			if (data[0] != 48)
			{
				throw new FormatException($"Expected 0x30 but read 0x{data[0]:X2}");
			}
			reference = ref data;
			data = reference.Slice(1, reference.Length - 1);
			if (!TryReadAsnLength(data, out length, out bytesConsumed))
			{
				throw new FormatException("Couldn't read length");
			}
			reference = ref data;
			num = bytesConsumed;
			data = reference.Slice(num, reference.Length - num);
		}
		else
		{
			if (!TryReadAsnInteger(data, out var number, out bytesConsumed) || number.Length != 1 || number[0] != 0)
			{
				throw new FormatException("Couldn't read zero.");
			}
			reference = ref data;
			num = bytesConsumed;
			data = reference.Slice(num, reference.Length - num);
		}
		if (!TryReadAsnInteger(data, out var number2, out bytesConsumed))
		{
			throw new FormatException("Couldn't read modulus");
		}
		reference = ref data;
		num = bytesConsumed;
		data = reference.Slice(num, reference.Length - num);
		if (!TryReadAsnInteger(data, out var number3, out bytesConsumed))
		{
			throw new FormatException("Couldn't read exponent");
		}
		reference = ref data;
		num = bytesConsumed;
		data = reference.Slice(num, reference.Length - num);
		RSAParameters result;
		if (!isPrivate)
		{
			result = default(RSAParameters);
			result.Modulus = number2.ToArray();
			result.Exponent = number3.ToArray();
			return result;
		}
		if (!TryReadAsnInteger(data, out var number4, out bytesConsumed))
		{
			throw new FormatException("Couldn't read D");
		}
		reference = ref data;
		num = bytesConsumed;
		data = reference.Slice(num, reference.Length - num);
		if (!TryReadAsnInteger(data, out var number5, out bytesConsumed))
		{
			throw new FormatException("Couldn't read P");
		}
		reference = ref data;
		num = bytesConsumed;
		data = reference.Slice(num, reference.Length - num);
		if (!TryReadAsnInteger(data, out var number6, out bytesConsumed))
		{
			throw new FormatException("Couldn't read Q");
		}
		reference = ref data;
		num = bytesConsumed;
		data = reference.Slice(num, reference.Length - num);
		if (!TryReadAsnInteger(data, out var number7, out bytesConsumed))
		{
			throw new FormatException("Couldn't read DP");
		}
		reference = ref data;
		num = bytesConsumed;
		data = reference.Slice(num, reference.Length - num);
		if (!TryReadAsnInteger(data, out var number8, out bytesConsumed))
		{
			throw new FormatException("Couldn't read DQ");
		}
		reference = ref data;
		num = bytesConsumed;
		data = reference.Slice(num, reference.Length - num);
		if (!TryReadAsnInteger(data, out var number9, out bytesConsumed))
		{
			throw new FormatException("Couldn't read IQ");
		}
		reference = ref data;
		num = bytesConsumed;
		data = reference.Slice(num, reference.Length - num);
		result = default(RSAParameters);
		result.Modulus = number2.ToArray();
		result.Exponent = number3.ToArray();
		result.D = number4.ToArray();
		result.P = number5.ToArray();
		result.Q = number6.ToArray();
		result.DP = number7.ToArray();
		result.DQ = number8.ToArray();
		result.InverseQ = number9.ToArray();
		return result;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public static ArraySegment<T> Slice<T>([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })] this ArraySegment<T> arraySegment, int index)
	{
		return new ArraySegment<T>(arraySegment.Array, arraySegment.Offset + index, arraySegment.Count - index);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public static ArraySegment<T> Slice<T>([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })] this ArraySegment<T> arraySegment, int index, int length)
	{
		return new ArraySegment<T>(arraySegment.Array, arraySegment.Offset + index, length);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static byte[] ArraySlice(byte[] input, int offset, int length)
	{
		if (offset == 0 && length == input.Length)
		{
			return input;
		}
		byte[] array = new byte[length];
		Array.Copy(input, offset, array, 0, array.Length);
		return array;
	}

	public static int FindNextIndex(ReadOnlySpan<byte> data, int offset, ReadOnlySpan<byte> pattern)
	{
		int num = data.Slice(offset, data.Length - offset).IndexOf(pattern);
		if (num != -1)
		{
			return offset + num;
		}
		return -1;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static void Resize<T>([<0fcba684-b16b-492b-b6ee-61db96fb7cb1>NotNull][<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })] ref ResizableArray<T> resizableArray, int newLength)
	{
		if (resizableArray == null)
		{
			resizableArray = new ResizableArray<T>();
		}
		resizableArray.DoResize(newLength);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static bool TryParseRedirectionHeader(string header, out string host, out int port, out string user)
	{
		host = "";
		port = 0;
		user = "";
		if (!header.StartsWith("Location: mysql://", StringComparison.Ordinal) || header.Length < 22)
		{
			return false;
		}
		bool flag;
		int num4;
		int num3;
		if (header[18] == '[')
		{
			flag = true;
			int num = 19;
			int num2 = header.IndexOf(']', num);
			if (num2 == -1)
			{
				return false;
			}
			num3 = num;
			host = header.Substring(num3, num2 - num3);
			if (header.Length <= num2 + 2)
			{
				return false;
			}
			if (header[num2 + 1] != ':')
			{
				return false;
			}
			num4 = num2 + 2;
		}
		else
		{
			flag = false;
			int num5 = 18;
			int num6 = header.IndexOf(':', num5);
			if (num6 == -1)
			{
				return false;
			}
			num3 = num5;
			host = header.Substring(num3, num6 - num3);
			num4 = num6 + 1;
		}
		int num7 = header.IndexOf(flag ? "/?user=" : "/user=", StringComparison.Ordinal);
		if (num7 == -1)
		{
			return false;
		}
		num3 = num4;
		if (!int.TryParse(header.Substring(num3, num7 - num3), out port) || port <= 0)
		{
			return false;
		}
		num7 += (flag ? 7 : 6);
		int num8 = header.IndexOf('&', num7);
		int num9 = header.IndexOf('\n', num7);
		int num10 = ((num8 != -1) ? ((num9 == -1) ? num8 : Math.Min(num8, num9)) : ((num9 == -1) ? header.Length : num9));
		num3 = num7;
		user = header.Substring(num3, num10 - num3);
		return user.Length != 0;
	}

	public static TimeSpan ParseTimeSpan(ReadOnlySpan<byte> value)
	{
		ReadOnlySpan<byte> span = value;
		bool flag = false;
		if (value.Length >= 1 && value[0] == 45)
		{
			flag = true;
			ref ReadOnlySpan<byte> reference = ref value;
			value = reference.Slice(1, reference.Length - 1);
		}
		int value3;
		int value4;
		int value5;
		if (Utf8Parser.TryParse(value, out int value2, out int i, '\0') && value2 >= 0 && value2 <= 838 && value.Length != i && value[i] == 58)
		{
			ref ReadOnlySpan<byte> reference = ref value;
			int num = i + 1;
			value = reference.Slice(num, reference.Length - num);
			if (Utf8Parser.TryParse(value, out value3, out i, '\0') && i == 2 && value3 >= 0 && value3 <= 59 && value.Length >= 3 && value[2] == 58)
			{
				reference = ref value;
				value = reference.Slice(3, reference.Length - 3);
				if (Utf8Parser.TryParse(value, out value4, out i, '\0') && i == 2 && value4 >= 0 && value4 <= 59)
				{
					if (value.Length == 2)
					{
						value5 = 0;
						goto IL_0181;
					}
					if (value[2] == 46)
					{
						reference = ref value;
						value = reference.Slice(3, reference.Length - 3);
						if (Utf8Parser.TryParse(value, out value5, out i, '\0') && i == value.Length && value5 >= 0 && value5 <= 999999)
						{
							for (; i < 6; i++)
							{
								value5 *= 10;
							}
							goto IL_0181;
						}
					}
				}
			}
		}
		throw new FormatException("Couldn't interpret value as a valid TimeSpan: " + Encoding.UTF8.GetString(span));
		IL_0181:
		if (flag)
		{
			value2 = -value2;
			value3 = -value3;
			value4 = -value4;
			value5 = -value5;
		}
		return new TimeSpan(0, value2, value3, value4, value5 / 1000) + TimeSpan.FromTicks(value5 % 1000 * 10);
	}

	public static bool TryComputeHash([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] this HashAlgorithm hashAlgorithm, ReadOnlySpan<byte> source, Span<byte> destination, out int bytesWritten)
	{
		byte[] array = hashAlgorithm.ComputeHash(source.ToArray());
		MemoryExtensions.AsSpan(array).CopyTo(destination);
		bytesWritten = array.Length;
		return true;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static byte[] TrimZeroByte(byte[] value)
	{
		if (value != null)
		{
			int num = value.Length;
			if (num >= 1 && value[num - 1] == 0)
			{
				Array.Resize(ref value, value.Length - 1);
			}
		}
		return value;
	}

	public static ReadOnlySpan<byte> TrimZeroByte(ReadOnlySpan<byte> value)
	{
		int length = value.Length;
		if (length < 1 || value[length - 1] != 0)
		{
			return value;
		}
		return value.Slice(0, value.Length - 1);
	}

	public static int Read([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] this Stream stream, Memory<byte> buffer)
	{
		MemoryMarshal.TryGetArray((ReadOnlyMemory<byte>)buffer, out ArraySegment<byte> segment);
		return stream.Read(segment.Array, segment.Offset, segment.Count);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static Task<int> ReadAsync(this Stream stream, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] Memory<byte> buffer)
	{
		MemoryMarshal.TryGetArray((ReadOnlyMemory<byte>)buffer, out ArraySegment<byte> segment);
		return stream.ReadAsync(segment.Array, segment.Offset, segment.Count);
	}

	public static void Write([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] this Stream stream, ReadOnlyMemory<byte> data)
	{
		MemoryMarshal.TryGetArray(data, out var segment);
		stream.Write(segment.Array, segment.Offset, segment.Count);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static Task WriteAsync(this Stream stream, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlyMemory<byte> data)
	{
		MemoryMarshal.TryGetArray(data, out var segment);
		return stream.WriteAsync(segment.Array, segment.Offset, segment.Count);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static bool StartsWith(this string str, char value)
	{
		if (!string.IsNullOrEmpty(str))
		{
			return str[0] == value;
		}
		return false;
	}

	public static void SwapBytes(Span<byte> bytes, int offset1, int offset2)
	{
		ref byte source = ref Unsafe.AsRef(ref bytes[0]);
		ref byte reference = ref Unsafe.Add(ref source, offset2);
		ref byte reference2 = ref Unsafe.Add(ref source, offset1);
		byte b = Unsafe.Add(ref source, offset1);
		byte b2 = Unsafe.Add(ref source, offset2);
		reference = b;
		reference2 = b2;
	}

	public static bool IsWindows()
	{
		try
		{
			return RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
		}
		catch (PlatformNotSupportedException)
		{
			return false;
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static void GetOSDetails([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] out string os, out string osDescription, out string architecture)
	{
		os = (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "Windows" : (RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? "Linux" : (RuntimeInformation.IsOSPlatform(OSPlatform.OSX) ? "macOS" : null)));
		osDescription = RuntimeInformation.OSDescription;
		architecture = RuntimeInformation.ProcessArchitecture.ToString();
	}

	public static int GetElapsedMilliseconds(long startingTimestamp)
	{
		return (int)((Stopwatch.GetTimestamp() - startingTimestamp) * 1000 / Stopwatch.Frequency);
	}

	public static double GetElapsedSeconds(long startingTimestamp, long endingTimestamp)
	{
		return (double)(endingTimestamp - startingTimestamp) / (double)Stopwatch.Frequency;
	}

	public static SslProtocols GetDefaultSslProtocols()
	{
		return SslProtocols.None;
	}

	private static bool TryReadAsnLength(ReadOnlySpan<byte> data, out int length, out int bytesConsumed)
	{
		byte b = data[0];
		if (b < 128)
		{
			length = b;
			bytesConsumed = 1;
			return true;
		}
		switch (b)
		{
		case 129:
			length = data[1];
			bytesConsumed = 2;
			return true;
		case 130:
			length = data[1] * 256 + data[2];
			bytesConsumed = 3;
			return true;
		default:
			length = 0;
			bytesConsumed = 0;
			return false;
		}
	}

	private static bool TryReadAsnInteger(ReadOnlySpan<byte> data, out ReadOnlySpan<byte> number, out int bytesConsumed)
	{
		if (data.Length < 1 || data[0] != 2)
		{
			number = default(ReadOnlySpan<byte>);
			bytesConsumed = 0;
			return false;
		}
		ref ReadOnlySpan<byte> reference = ref data;
		data = reference.Slice(1, reference.Length - 1);
		if (!TryReadAsnLength(data, out var length, out var bytesConsumed2))
		{
			number = default(ReadOnlySpan<byte>);
			bytesConsumed = 0;
			return false;
		}
		number = data.Slice(bytesConsumed2, length);
		bytesConsumed = bytesConsumed2 + length + 1;
		while (true)
		{
			ReadOnlySpan<byte> readOnlySpan = number;
			if (readOnlySpan.Length < 2 || readOnlySpan[0] != 0)
			{
				break;
			}
			reference = ref number;
			number = reference.Slice(1, reference.Length - 1);
		}
		return true;
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal static class ValueTaskExtensions
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ValueTask FromException(Exception exception)
	{
		return new ValueTask(Task.FromException(exception));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public static ValueTask<T> FromException<[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] T>(Exception exception)
	{
		return new ValueTask<T>(Task.FromException<T>(exception));
	}
}


internal enum CharacterSet : ushort
{
	None = 0,
	Big5ChineseCaseInsensitive = 1,
	Latin2CzechCaseSensitive = 2,
	Dec8SwedishCaseInsensitive = 3,
	Cp850GeneralCaseInsensitive = 4,
	Latin1German1CaseInsensitive = 5,
	Hp8EnglishCaseInsensitive = 6,
	Koi8rGeneralCaseInsensitive = 7,
	Latin1SwedishCaseInsensitive = 8,
	Latin2GeneralCaseInsensitive = 9,
	Swe7SwedishCaseInsensitive = 10,
	AsciiGeneralCaseInsensitive = 11,
	UjisJapaneseCaseInsensitive = 12,
	SjisJapaneseCaseInsensitive = 13,
	Cp1251BulgarianCaseInsensitive = 14,
	Latin1DanishCaseInsensitive = 15,
	HebrewGeneralCaseInsensitive = 16,
	Tis620ThaiCaseInsensitive = 18,
	EuckrKoreanCaseInsensitive = 19,
	Latin7EstonianCaseSensitive = 20,
	Latin2HungarianCaseInsensitive = 21,
	Koi8uGeneralCaseInsensitive = 22,
	Cp1251UkrainianCaseInsensitive = 23,
	Gb2312ChineseCaseInsensitive = 24,
	GreekGeneralCaseInsensitive = 25,
	Cp1250GeneralCaseInsensitive = 26,
	Latin2CroatianCaseInsensitive = 27,
	GbkChineseCaseInsensitive = 28,
	Cp1257LithuanianCaseInsensitive = 29,
	Latin5TurkishCaseInsensitive = 30,
	Latin1German2CaseInsensitive = 31,
	Armscii8GeneralCaseInsensitive = 32,
	Utf8Mb3GeneralCaseInsensitive = 33,
	Cp1250CzechCaseSensitive = 34,
	Ucs2GeneralCaseInsensitive = 35,
	Cp866GeneralCaseInsensitive = 36,
	Keybcs2GeneralCaseInsensitive = 37,
	MacceGeneralCaseInsensitive = 38,
	MacromanGeneralCaseInsensitive = 39,
	Cp852GeneralCaseInsensitive = 40,
	Latin7GeneralCaseInsensitive = 41,
	Latin7GeneralCaseSensitive = 42,
	MacceBinary = 43,
	Cp1250CroatianCaseInsensitive = 44,
	Utf8Mb4GeneralCaseInsensitive = 45,
	Utf8Mb4Binary = 46,
	Latin1Binary = 47,
	Latin1GeneralCaseInsensitive = 48,
	Latin1GeneralCaseSensitive = 49,
	Cp1251Binary = 50,
	Cp1251GeneralCaseInsensitive = 51,
	Cp1251GeneralCaseSensitive = 52,
	MacromanBinary = 53,
	Utf16GeneralCaseInsensitive = 54,
	Utf16Binary = 55,
	Utf16leGeneralCaseInsensitive = 56,
	Cp1256GeneralCaseInsensitive = 57,
	Cp1257Binary = 58,
	Cp1257GeneralCaseInsensitive = 59,
	Utf32GeneralCaseInsensitive = 60,
	Utf32Binary = 61,
	Utf16leBinary = 62,
	Binary = 63,
	Armscii8Binary = 64,
	AsciiBinary = 65,
	Cp1250Binary = 66,
	Cp1256Binary = 67,
	Cp866Binary = 68,
	Dec8Binary = 69,
	GreekBinary = 70,
	HebrewBinary = 71,
	Hp8Binary = 72,
	Keybcs2Binary = 73,
	Koi8rBinary = 74,
	Koi8uBinary = 75,
	Utf8Mb3ToLowerCaseInsensitive = 76,
	Latin2Binary = 77,
	Latin5Binary = 78,
	Latin7Binary = 79,
	Cp850Binary = 80,
	Cp852Binary = 81,
	Swe7Binary = 82,
	Utf8Mb3Binary = 83,
	Big5Binary = 84,
	EuckrBinary = 85,
	Gb2312Binary = 86,
	GbkBinary = 87,
	SjisBinary = 88,
	Tis620Binary = 89,
	Ucs2Binary = 90,
	UjisBinary = 91,
	Geostd8GeneralCaseInsensitive = 92,
	Geostd8Binary = 93,
	Latin1SpanishCaseInsensitive = 94,
	Cp932JapaneseCaseInsensitive = 95,
	Cp932Binary = 96,
	EucjpmsJapaneseCaseInsensitive = 97,
	EucjpmsBinary = 98,
	Cp1250PolishCaseInsensitive = 99,
	Utf16UnicodeCaseInsensitive = 101,
	Utf16IcelandicCaseInsensitive = 102,
	Utf16LatvianCaseInsensitive = 103,
	Utf16RomanianCaseInsensitive = 104,
	Utf16SlovenianCaseInsensitive = 105,
	Utf16PolishCaseInsensitive = 106,
	Utf16EstonianCaseInsensitive = 107,
	Utf16SpanishCaseInsensitive = 108,
	Utf16SwedishCaseInsensitive = 109,
	Utf16TurkishCaseInsensitive = 110,
	Utf16CzechCaseInsensitive = 111,
	Utf16DanishCaseInsensitive = 112,
	Utf16LithuanianCaseInsensitive = 113,
	Utf16SlovakCaseInsensitive = 114,
	Utf16Spanish2CaseInsensitive = 115,
	Utf16RomanCaseInsensitive = 116,
	Utf16PersianCaseInsensitive = 117,
	Utf16EsperantoCaseInsensitive = 118,
	Utf16HungarianCaseInsensitive = 119,
	Utf16SinhalaCaseInsensitive = 120,
	Utf16German2CaseInsensitive = 121,
	Utf16CroatianCaseInsensitive = 122,
	Utf16Unicode520CaseInsensitive = 123,
	Utf16VietnameseCaseInsensitive = 124,
	Ucs2UnicodeCaseInsensitive = 128,
	Ucs2IcelandicCaseInsensitive = 129,
	Ucs2LatvianCaseInsensitive = 130,
	Ucs2RomanianCaseInsensitive = 131,
	Ucs2SlovenianCaseInsensitive = 132,
	Ucs2PolishCaseInsensitive = 133,
	Ucs2EstonianCaseInsensitive = 134,
	Ucs2SpanishCaseInsensitive = 135,
	Ucs2SwedishCaseInsensitive = 136,
	Ucs2TurkishCaseInsensitive = 137,
	Ucs2CzechCaseInsensitive = 138,
	Ucs2DanishCaseInsensitive = 139,
	Ucs2LithuanianCaseInsensitive = 140,
	Ucs2SlovakCaseInsensitive = 141,
	Ucs2Spanish2CaseInsensitive = 142,
	Ucs2RomanCaseInsensitive = 143,
	Ucs2PersianCaseInsensitive = 144,
	Ucs2EsperantoCaseInsensitive = 145,
	Ucs2HungarianCaseInsensitive = 146,
	Ucs2SinhalaCaseInsensitive = 147,
	Ucs2German2CaseInsensitive = 148,
	Ucs2CroatianCaseInsensitive = 149,
	Ucs2Unicode520CaseInsensitive = 150,
	Ucs2VietnameseCaseInsensitive = 151,
	Ucs2GeneralMySql500CaseInsensitive = 159,
	Utf32UnicodeCaseInsensitive = 160,
	Utf32IcelandicCaseInsensitive = 161,
	Utf32LatvianCaseInsensitive = 162,
	Utf32RomanianCaseInsensitive = 163,
	Utf32SlovenianCaseInsensitive = 164,
	Utf32PolishCaseInsensitive = 165,
	Utf32EstonianCaseInsensitive = 166,
	Utf32SpanishCaseInsensitive = 167,
	Utf32SwedishCaseInsensitive = 168,
	Utf32TurkishCaseInsensitive = 169,
	Utf32CzechCaseInsensitive = 170,
	Utf32DanishCaseInsensitive = 171,
	Utf32LithuanianCaseInsensitive = 172,
	Utf32SlovakCaseInsensitive = 173,
	Utf32Spanish2CaseInsensitive = 174,
	Utf32RomanCaseInsensitive = 175,
	Utf32PersianCaseInsensitive = 176,
	Utf32EsperantoCaseInsensitive = 177,
	Utf32HungarianCaseInsensitive = 178,
	Utf32SinhalaCaseInsensitive = 179,
	Utf32German2CaseInsensitive = 180,
	Utf32CroatianCaseInsensitive = 181,
	Utf32Unicode520CaseInsensitive = 182,
	Utf32VietnameseCaseInsensitive = 183,
	Utf8Mb3UnicodeCaseInsensitive = 192,
	Utf8Mb3IcelandicCaseInsensitive = 193,
	Utf8Mb3LatvianCaseInsensitive = 194,
	Utf8Mb3RomanianCaseInsensitive = 195,
	Utf8Mb3SlovenianCaseInsensitive = 196,
	Utf8Mb3PolishCaseInsensitive = 197,
	Utf8Mb3EstonianCaseInsensitive = 198,
	Utf8Mb3SpanishCaseInsensitive = 199,
	Utf8Mb3SwedishCaseInsensitive = 200,
	Utf8Mb3TurkishCaseInsensitive = 201,
	Utf8Mb3CzechCaseInsensitive = 202,
	Utf8Mb3DanishCaseInsensitive = 203,
	Utf8Mb3LithuanianCaseInsensitive = 204,
	Utf8Mb3SlovakCaseInsensitive = 205,
	Utf8Mb3Spanish2CaseInsensitive = 206,
	Utf8Mb3RomanCaseInsensitive = 207,
	Utf8Mb3PersianCaseInsensitive = 208,
	Utf8Mb3EsperantoCaseInsensitive = 209,
	Utf8Mb3HungarianCaseInsensitive = 210,
	Utf8Mb3SinhalaCaseInsensitive = 211,
	Utf8Mb3German2CaseInsensitive = 212,
	Utf8Mb3CroatianCaseInsensitive = 213,
	Utf8Mb3Unicode520CaseInsensitive = 214,
	Utf8Mb3VietnameseCaseInsensitive = 215,
	Utf8Mb3GeneralMySql500CaseInsensitive = 223,
	Utf8Mb4UnicodeCaseInsensitive = 224,
	Utf8Mb4IcelandicCaseInsensitive = 225,
	Utf8Mb4LatvianCaseInsensitive = 226,
	Utf8Mb4RomanianCaseInsensitive = 227,
	Utf8Mb4SlovenianCaseInsensitive = 228,
	Utf8Mb4PolishCaseInsensitive = 229,
	Utf8Mb4EstonianCaseInsensitive = 230,
	Utf8Mb4SpanishCaseInsensitive = 231,
	Utf8Mb4SwedishCaseInsensitive = 232,
	Utf8Mb4TurkishCaseInsensitive = 233,
	Utf8Mb4CzechCaseInsensitive = 234,
	Utf8Mb4DanishCaseInsensitive = 235,
	Utf8Mb4LithuanianCaseInsensitive = 236,
	Utf8Mb4SlovakCaseInsensitive = 237,
	Utf8Mb4Spanish2CaseInsensitive = 238,
	Utf8Mb4RomanCaseInsensitive = 239,
	Utf8Mb4PersianCaseInsensitive = 240,
	Utf8Mb4EsperantoCaseInsensitive = 241,
	Utf8Mb4HungarianCaseInsensitive = 242,
	Utf8Mb4SinhalaCaseInsensitive = 243,
	Utf8Mb4German2CaseInsensitive = 244,
	Utf8Mb4CroatianCaseInsensitive = 245,
	Utf8Mb4Unicode520CaseInsensitive = 246,
	Utf8Mb4VietnameseCaseInsensitive = 247,
	Gb18030ChineseCaseInsensitive = 248,
	Gb18030Binary = 249,
	Gb18030Unicode520CaseInsensitive = 250,
	Utf8Mb4Uca900AccentInsensitiveCaseInsensitive = 255,
	Utf8Mb4GermanPhonebookUca900AccentInsensitiveCaseInsensitive = 256,
	Utf8Mb4IcelandicUca900AccentInsensitiveCaseInsensitive = 257,
	Utf8Mb4LatvianUca900AccentInsensitiveCaseInsensitive = 258,
	Utf8Mb4RomanianUca900AccentInsensitiveCaseInsensitive = 259,
	Utf8Mb4SlovenianUca900AccentInsensitiveCaseInsensitive = 260,
	Utf8Mb4PolishUca900AccentInsensitiveCaseInsensitive = 261,
	Utf8Mb4EstonianUca900AccentInsensitiveCaseInsensitive = 262,
	Utf8Mb4SpanishUca900AccentInsensitiveCaseInsensitive = 263,
	Utf8Mb4SwedishUca900AccentInsensitiveCaseInsensitive = 264,
	Utf8Mb4TurkishUca900AccentInsensitiveCaseInsensitive = 265,
	Utf8Mb4CaseSensitiveUca900AccentInsensitiveCaseInsensitive = 266,
	Utf8Mb4DanishUca900AccentInsensitiveCaseInsensitive = 267,
	Utf8Mb4LithuanianUca900AccentInsensitiveCaseInsensitive = 268,
	Utf8Mb4SlovakUca900AccentInsensitiveCaseInsensitive = 269,
	Utf8Mb4TraditionalSpanishUca900AccentInsensitiveCaseInsensitive = 270,
	Utf8Mb4LatinUca900AccentInsensitiveCaseInsensitive = 271,
	Utf8Mb4EsperantoUca900AccentInsensitiveCaseInsensitive = 273,
	Utf8Mb4HungarianUca900AccentInsensitiveCaseInsensitive = 274,
	Utf8Mb4CroatianUca900AccentInsensitiveCaseInsensitive = 275,
	Utf8Mb4VietnameseUca900AccentInsensitiveCaseInsensitive = 277,
	Utf8Mb4Uca900AccentSensitiveCaseSensitive = 278,
	Utf8Mb4GermanPhonebookUca900AccentSensitiveCaseSensitive = 279,
	Utf8Mb4IcelandicUca900AccentSensitiveCaseSensitive = 280,
	Utf8Mb4LatvianUca900AccentSensitiveCaseSensitive = 281,
	Utf8Mb4RomanianUca900AccentSensitiveCaseSensitive = 282,
	Utf8Mb4SlovenianUca900AccentSensitiveCaseSensitive = 283,
	Utf8Mb4PolishUca900AccentSensitiveCaseSensitive = 284,
	Utf8Mb4EstonianUca900AccentSensitiveCaseSensitive = 285,
	Utf8Mb4SpanishUca900AccentSensitiveCaseSensitive = 286,
	Utf8Mb4SwedishUca900AccentSensitiveCaseSensitive = 287,
	Utf8Mb4TurkishUca900AccentSensitiveCaseSensitive = 288,
	Utf8Mb4CaseSensitiveUca900AccentSensitiveCaseSensitive = 289,
	Utf8Mb4DanishUca900AccentSensitiveCaseSensitive = 290,
	Utf8Mb4LithuanianUca900AccentSensitiveCaseSensitive = 291,
	Utf8Mb4SlovakUca900AccentSensitiveCaseSensitive = 292,
	Utf8Mb4TraditionalSpanishUca900AccentSensitiveCaseSensitive = 293,
	Utf8Mb4LatinUca900AccentSensitiveCaseSensitive = 294,
	Utf8Mb4EsperantoUca900AccentSensitiveCaseSensitive = 296,
	Utf8Mb4HungarianUca900AccentSensitiveCaseSensitive = 297,
	Utf8Mb4CroatianUca900AccentSensitiveCaseSensitive = 298,
	Utf8Mb4VietnameseUca900AccentSensitiveCaseSensitive = 300,
	Utf8Mb4JapaneseUca900AccentSensitiveCaseSensitive = 303,
	Utf8Mb4JapaneseUca900AccentSensitiveCaseSensitiveKanaSensitive = 304,
	Utf8Mb4Uca900AccentSensitiveCaseInsensitive = 305,
	Utf8Mb4RussianUca900AccentInsensitiveCaseInsensitive = 306,
	Utf8Mb4RussianUca900AccentSensitiveCaseSensitive = 307,
	Utf8Mb4ChineseUca900AccentSensitiveCaseSensitive = 308,
	Utf8Mb4Uca900Binary = 309,
	Utf8Mb4NorwegianBokmal0900AccentInsensitiveCaseInsensitive = 310,
	Utf8Mb4NorwegianBokmal0900AccentSensitiveCaseSensitive = 311,
	Utf8Mb4NorwegianNynorsk0900AccentInsensitiveCaseInsensitive = 312,
	Utf8Mb4NorwegianNynorsk0900AccentSensitiveCaseSensitive = 313,
	Utf8Mb4SerbianLatin0900AccentInsensitiveCaseInsensitive = 314,
	Utf8Mb4SerbianLatin0900AccentSensitiveCaseSensitive = 315,
	Utf8Mb4Bosnian0900AccentInsensitiveCaseInsensitive = 316,
	Utf8Mb4Bosnian0900AccentSensitiveCaseSensitive = 317,
	Utf8Mb4Bulgarian0900AccentInsensitiveCaseInsensitive = 318,
	Utf8Mb4Bulgarian0900AccentSensitiveCaseSensitive = 319,
	Utf8Mb4Galician0900AccentInsensitiveCaseInsensitive = 320,
	Utf8Mb4Galician0900AccentSensitiveCaseSensitive = 321,
	Utf8Mb4MongolianCyrillic0900AccentInsensitiveCaseInsensitive = 322,
	Utf8Mb4MongolianCyrillic0900AccentSensitiveCaseSensitive = 323,
	Utf8Mb3CroatianCaseInsensitiveMariaDb = 576,
	Utf8Mb3MyanmarCaseInsensitive = 577,
	Utf8Mb3ThaiUnicode520Weight2 = 578,
	Utf8Mb4CroatianCaseInsensitiveMariaDb = 608,
	Utf8Mb4MyanmarCaseInsensitive = 609,
	Utf8Mb4ThaiUnicode520Weight2 = 610,
	Ucs2CroatianCaseInsensitiveMariaDb = 640,
	Ucs2MyanmarCaseInsensitive = 641,
	Ucs2ThaiUnicode520Weight2 = 642,
	Utf16CroatianCaseInsensitiveMariaDb = 672,
	Utf16MyanmarCaseInsensitive = 673,
	Utf16ThaiUnicode520Weight2 = 674,
	Utf32CroatianCaseInsensitiveMariaDb = 736,
	Utf32MyanmarCaseInsensitive = 737,
	Utf32ThaiUnicode520Weight2 = 738,
	Big5ChineseNoPadCaseInsensitive = 1025,
	Dec8SwedishNoPadCaseInsensitive = 1027,
	Cp850GeneralNoPadCaseInsensitive = 1028,
	Hp8EnglishNoPadCaseInsensitive = 1030,
	Koi8rGeneralNoPadCaseInsensitive = 1031,
	Latin1SwedishNoPadCaseInsensitive = 1032,
	Latin2GeneralNoPadCaseInsensitive = 1033,
	Swe7SwedishNoPadCaseInsensitive = 1034,
	AsciiGeneralNoPadCaseInsensitive = 1035,
	UjisJapaneseNoPadCaseInsensitive = 1036,
	SjisJapaneseNoPadCaseInsensitive = 1037,
	HebrewGeneralNoPadCaseInsensitive = 1040,
	Tis620ThaiNoPadCaseInsensitive = 1042,
	EuckrKoreanNoPadCaseInsensitive = 1043,
	Koi8uGeneralNoPadCaseInsensitive = 1046,
	Gb2312ChineseNoPadCaseInsensitive = 1048,
	GreekGeneralNoPadCaseInsensitive = 1049,
	Cp1250GeneralNoPadCaseInsensitive = 1050,
	GbkChineseNoPadCaseInsensitive = 1052,
	Latin5TurkishNoPadCaseInsensitive = 1054,
	Armscii8GeneralNoPadCaseInsensitive = 1056,
	Utf8Mb3GeneralNoPadCaseInsensitive = 1057,
	Ucs2GeneralNoPadCaseInsensitive = 1059,
	Cp866GeneralNoPadCaseInsensitive = 1060,
	Keybcs2GeneralNoPadCaseInsensitive = 1061,
	MacCentralEuropeanGeneralNoPadCaseInsensitive = 1062,
	MacRomanGeneralNoPadCaseInsensitive = 1063,
	Cp852GeneralNoPadCaseInsensitive = 1064,
	Latin7GeneralNoPadCaseInsensitive = 1065,
	MacCentralEuropeanNoPadBinary = 1067,
	Utf8Mb4GeneralNoPadCaseInsensitive = 1069,
	Utf8Mb4NoPadBinary = 1070,
	Latin1NoPadBinary = 1071,
	Cp1251NoPadBinary = 1074,
	Cp1251GeneralNoPadCaseInsensitive = 1075,
	MacRomanNoPadBinary = 1077,
	Utf16GeneralNoPadCaseInsensitive = 1078,
	Utf16NoPadBinary = 1079,
	Utf16leGeneralNoPadCaseInsensitive = 1080,
	Cp1256GeneralNoPadCaseInsensitive = 1081,
	Cp1257NoPadBinary = 1082,
	Cp1257GeneralNoPadCaseInsensitive = 1083,
	Utf32GeneralNoPadCaseInsensitive = 1084,
	Utf32NoPadBinary = 1085,
	Utf16leNoPadBinary = 1086,
	Armscii8NoPadBinary = 1088,
	AsciiNoPadBinary = 1089,
	Cp1250NoPadBinary = 1090,
	Cp1256NoPadBinary = 1091,
	Cp866NoPadBinary = 1092,
	Dec8NoPadBinary = 1093,
	GreekNoPadBinary = 1094,
	HebrewNoPadBinary = 1095,
	Hp8NoPadBinary = 1096,
	Keybcs2NoPadBinary = 1097,
	Koi8rNoPadBinary = 1098,
	Koi8uNoPadBinary = 1099,
	Latin2NoPadBinary = 1101,
	Latin5NoPadBinary = 1102,
	Latin7NoPadBinary = 1103,
	Cp850NoPadBinary = 1104,
	Cp852NoPadBinary = 1105,
	Swe7NoPadBinary = 1106,
	Utf8Mb3NoPadBinary = 1107,
	Big5NoPadBinary = 1108,
	EuckrNoPadBinary = 1109,
	Gb2312NoPadBinary = 1110,
	GbkNoPadBinary = 1111,
	SjisNoPadBinary = 1112,
	Tis620NoPadBinary = 1113,
	Ucs2NoPadBinary = 1114,
	UjisNoPadBinary = 1115,
	Geostd8GeneralNoPadCaseInsensitive = 1116,
	Geostd8NoPadBinary = 1117,
	Cp932JapaneseNoPadCaseInsensitive = 1119,
	Cp932NoPadBinary = 1120,
	EucjpmsJapaneseNoPadCaseInsensitive = 1121,
	EucjpmsNoPadBinary = 1122,
	Utf16UnicodeNoPadCaseInsensitive = 1125,
	Utf16Unicode520NoPadCaseInsensitive = 1147,
	Ucs2UnicodeNoPadCaseInsensitive = 1152,
	Ucs2Unicode520NoPadCaseInsensitive = 1174,
	Utf32UnicodeNoPadCaseInsensitive = 1184,
	Utf32Unicode520NoPadCaseInsensitive = 1206,
	Utf8Mb3UnicodeNoPadCaseInsensitive = 1216,
	Utf8Mb3Unicode520NoPadCaseInsensitive = 1238,
	Utf8Mb4UnicodeNoPadCaseInsensitive = 1248,
	Utf8Mb4Unicode520NoPadCaseInsensitive = 1270
}


using System;

[Flags]
internal enum ColumnFlags
{
	NotNull = 1,
	PrimaryKey = 2,
	UniqueKey = 4,
	MultipleKey = 8,
	Blob = 0x10,
	Unsigned = 0x20,
	ZeroFill = 0x40,
	Binary = 0x80,
	Enum = 0x100,
	AutoIncrement = 0x200,
	Timestamp = 0x400,
	Set = 0x800,
	Number = 0x8000
}


internal enum ColumnType
{
	Decimal = 0,
	Tiny = 1,
	Short = 2,
	Long = 3,
	Float = 4,
	Double = 5,
	Null = 6,
	Timestamp = 7,
	Longlong = 8,
	Int24 = 9,
	Date = 10,
	Time = 11,
	DateTime = 12,
	Year = 13,
	NewDate = 14,
	VarChar = 15,
	Bit = 16,
	Timestamp2 = 17,
	DateTime2 = 18,
	Json = 245,
	NewDecimal = 246,
	Enum = 247,
	Set = 248,
	TinyBlob = 249,
	MediumBlob = 250,
	LongBlob = 251,
	Blob = 252,
	VarString = 253,
	String = 254,
	Geometry = 255
}


internal enum CommandKind
{
	Quit = 1,
	InitDatabase = 2,
	Query = 3,
	Ping = 14,
	ChangeUser = 17,
	StatementPrepare = 22,
	StatementExecute = 23,
	ResetConnection = 31
}


using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal readonly struct PayloadData : IDisposable
{
	private readonly bool m_isPooled;

	public ReadOnlyMemory<byte> Memory { get; }

	public ReadOnlySpan<byte> Span => Memory.Span;

	public byte HeaderByte => Span[0];

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public PayloadData(byte[] data)
	{
		m_isPooled = false;
		Memory = data;
	}

	public PayloadData(ReadOnlyMemory<byte> data, bool isPooled = false)
	{
		Memory = data;
		m_isPooled = isPooled;
	}

	public void Dispose()
	{
		if (m_isPooled && MemoryMarshal.TryGetArray(Memory, out var segment))
		{
			ArrayPool<byte>.Shared.Return(segment.Array);
		}
	}
}


using System;

[Flags]
internal enum ProtocolCapabilities : ulong
{
	None = 0uL,
	LongPassword = 1uL,
	FoundRows = 2uL,
	LongFlag = 4uL,
	ConnectWithDatabase = 8uL,
	NoSchema = 0x10uL,
	Compress = 0x20uL,
	Odbc = 0x40uL,
	LocalFiles = 0x80uL,
	IgnoreSpace = 0x100uL,
	Protocol41 = 0x200uL,
	Interactive = 0x400uL,
	Ssl = 0x800uL,
	IgnoreSigpipe = 0x1000uL,
	Transactions = 0x2000uL,
	SecureConnection = 0x8000uL,
	MultiStatements = 0x10000uL,
	MultiResults = 0x20000uL,
	PreparedStatementMultiResults = 0x40000uL,
	PluginAuth = 0x80000uL,
	ConnectionAttributes = 0x100000uL,
	PluginAuthLengthEncodedClientData = 0x200000uL,
	CanHandleExpiredPasswords = 0x400000uL,
	SessionTrack = 0x800000uL,
	DeprecateEof = 0x1000000uL,
	QueryAttributes = 0x8000000uL,
	MariaDbClientProgress = 0x100000000uL,
	MariaDbComMulti = 0x200000000uL,
	MariaDbStatementBulkOperations = 0x400000000uL,
	MariaDbExtendedTypeInfo = 0x800000000uL,
	MariaDbCacheMetadata = 0x1000000000uL
}


using System;

[Flags]
internal enum ServerStatus : ushort
{
	InTransaction = 1,
	AutoCommit = 2,
	MoreResultsExist = 8,
	NoGoodIndexUsed = 0x10,
	NoIndexUsed = 0x20,
	CursorExists = 0x40,
	LastRowSent = 0x80,
	DatabaseDropped = 0x100,
	NoBackslashEscapes = 0x200,
	MetadataChanged = 0x400,
	QueryWasSlow = 0x800,
	PsOutParams = 0x1000,
	InReadOnlyTransaction = 0x2000,
	SessionStateChanged = 0x4000
}


internal enum SessionTrackKind : byte
{
	SystemVariables,
	Schema,
	StateChange,
	Gtids
}


using System;
using System.Runtime.CompilerServices;

internal sealed class ArraySegmentHolder<[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] T>
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public ArraySegment<T> ArraySegment
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
		get;
		[param: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
		set;
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	public T[] Array
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
		get
		{
			return ArraySegment.Array;
		}
	}

	public int Offset => ArraySegment.Offset;

	public int Count => ArraySegment.Count;

	public void Clear()
	{
		if (ArraySegment.Count > 0)
		{
			ArraySegment = new ArraySegment<T>(ArraySegment.Array, 0, 0);
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal static class AuthenticationUtility
{
	public static byte[] GetNullTerminatedPasswordBytes(string password)
	{
		byte[] array = new byte[Encoding.UTF8.GetByteCount(password) + 1];
		Encoding.UTF8.GetBytes(MemoryExtensions.AsSpan(password), array);
		return array;
	}

	public static byte[] CreateAuthenticationResponse([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> challenge, string password)
	{
		if (!string.IsNullOrEmpty(password))
		{
			return HashPassword(challenge, password);
		}
		return Array.Empty<byte>();
	}

	public static byte[] HashPassword([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> challenge, string password)
	{
		using SHA1 hashAlgorithm = SHA1.Create();
		Span<byte> span = stackalloc byte[40];
		challenge.CopyTo(span);
		int bytesWritten = Encoding.UTF8.GetByteCount(password);
		Span<byte> span2 = stackalloc byte[bytesWritten];
		Encoding.UTF8.GetBytes(MemoryExtensions.AsSpan(password), span2);
		Span<byte> span3 = stackalloc byte[20];
		hashAlgorithm.TryComputeHash(span2, span3, out bytesWritten);
		hashAlgorithm.TryComputeHash(span3, span.Slice(20, span.Length - 20), out bytesWritten);
		Span<byte> destination = stackalloc byte[20];
		hashAlgorithm.TryComputeHash(span, destination, out bytesWritten);
		for (int i = 0; i < span3.Length; i++)
		{
			span3[i] ^= destination[i];
		}
		return span3.ToArray();
	}

	public static byte[] CreateScrambleResponse([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> nonce, string password)
	{
		if (!string.IsNullOrEmpty(password))
		{
			return HashPasswordWithNonce(nonce, password);
		}
		return Array.Empty<byte>();
	}

	private static byte[] HashPasswordWithNonce([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> nonce, string password)
	{
		using SHA256 hashAlgorithm = SHA256.Create();
		int bytesWritten = Encoding.UTF8.GetByteCount(password);
		Span<byte> span = stackalloc byte[bytesWritten];
		Encoding.UTF8.GetBytes(MemoryExtensions.AsSpan(password), span);
		Span<byte> span2 = stackalloc byte[32];
		hashAlgorithm.TryComputeHash(span, span2, out bytesWritten);
		bytesWritten = 32 + nonce.Length;
		Span<byte> span3 = stackalloc byte[bytesWritten];
		hashAlgorithm.TryComputeHash(span2, span3, out bytesWritten);
		nonce.CopyTo(span3.Slice(32, span3.Length - 32));
		Span<byte> destination = stackalloc byte[32];
		hashAlgorithm.TryComputeHash(span3, destination, out bytesWritten);
		for (int i = 0; i < span2.Length; i++)
		{
			span2[i] ^= destination[i];
		}
		return span2.ToArray();
	}
}


internal static class NegotiateStreamConstants
{
	public const int HeaderLength = 5;

	public const byte MajorVersion = 1;

	public const byte MinorVersion = 0;

	public const byte HandshakeDone = 20;

	public const byte HandshakeError = 21;

	public const byte HandshakeInProgress = 22;

	public const ushort MaxPayloadLength = ushort.MaxValue;
}


using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using MySqlConnector.Core;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Serialization;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal class NegotiateToMySqlConverterStream : Stream
{
	private readonly MemoryStream m_writeBuffer;

	private readonly ServerSession m_serverSession;

	private readonly IOBehavior m_ioBehavior;

	private readonly CancellationToken m_cancellationToken;

	private MemoryStream m_readBuffer;

	private int m_writePayloadLength;

	private bool m_clientHandshakeDone;

	public PayloadData? MySQLProtocolPayload { get; private set; }

	public override bool CanRead => true;

	public override bool CanSeek => false;

	public override bool CanWrite => true;

	public override long Length
	{
		get
		{
			throw new NotImplementedException();
		}
	}

	public override long Position
	{
		get
		{
			throw new NotImplementedException();
		}
		set
		{
			throw new NotImplementedException();
		}
	}

	public NegotiateToMySqlConverterStream(ServerSession serverSession, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		m_serverSession = serverSession;
		m_readBuffer = new MemoryStream();
		m_writeBuffer = new MemoryStream();
		m_ioBehavior = ioBehavior;
		m_cancellationToken = cancellationToken;
	}

	private static void CreateNegotiateStreamMessageHeader(byte[] buffer, int offset, byte messageId, long payloadLength)
	{
		buffer[offset] = messageId;
		buffer[offset + 1] = 1;
		buffer[offset + 2] = 0;
		buffer[offset + 3] = (byte)(payloadLength >> 8);
		buffer[offset + 4] = (byte)(payloadLength & 0xFF);
	}

	public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
	{
		int num = 0;
		if (m_readBuffer.Length == m_readBuffer.Position)
		{
			if (count < 5)
			{
				throw new InvalidDataException("Unexpected call to read less then NegotiateStream header");
			}
			if (m_clientHandshakeDone)
			{
				CreateNegotiateStreamMessageHeader(buffer, offset, 20, 0L);
				return 5;
			}
			PayloadData value = await m_serverSession.ReceiveReplyAsync(m_ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ReadOnlyMemory<byte> readOnlyMemory = value.Memory;
			if (readOnlyMemory.Length > 65535)
			{
				throw new InvalidDataException($"Payload too big for NegotiateStream - {readOnlyMemory.Length:d} bytes");
			}
			switch (readOnlyMemory.Span[0])
			{
			case 0:
				MySQLProtocolPayload = value;
				CreateNegotiateStreamMessageHeader(buffer, offset, 20, 0L);
				return 5;
			case 1:
				readOnlyMemory = readOnlyMemory.Slice(1, readOnlyMemory.Length - 1);
				break;
			}
			m_readBuffer = new MemoryStream(readOnlyMemory.ToArray());
			CreateNegotiateStreamMessageHeader(buffer, offset, 22, m_readBuffer.Length);
			num = 5;
			offset += num;
			count -= num;
		}
		if (count > 0)
		{
			num += m_readBuffer.Read(buffer, offset, count);
		}
		return num;
	}

	public override int Read(byte[] buffer, int offset, int count)
	{
		return ReadAsync(buffer, offset, count, m_cancellationToken).GetAwaiter().GetResult();
	}

	public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
	{
		if (m_writePayloadLength == 0)
		{
			if (count < 5)
			{
				throw new InvalidDataException("Cannot parse NegotiateStream handshake message header");
			}
			byte b = buffer[offset];
			byte b2 = buffer[offset + 1];
			byte b3 = buffer[offset + 2];
			byte b4 = buffer[offset + 4];
			byte b5 = buffer[offset + 3];
			if (b2 != 1 || b3 != 0)
			{
				throw new FormatException($"Unknown version of NegotiateStream protocol {b2:d}.{b3:d}, expected {(byte)1:d}.{(byte)0:d}");
			}
			if (b != 20 && b != 21 && b != 22)
			{
				throw new FormatException($"Invalid NegotiateStream MessageId 0x{b:X2}");
			}
			m_writePayloadLength = b4 + (b5 << 8);
			if (b == 20)
			{
				m_clientHandshakeDone = true;
			}
			count -= 5;
		}
		if (count == 0)
		{
			return;
		}
		if (count + m_writeBuffer.Length > m_writePayloadLength)
		{
			throw new InvalidDataException("Attempt to write more than a single message");
		}
		PayloadData payload;
		if (count < m_writePayloadLength)
		{
			m_writeBuffer.Write(buffer, offset, count);
			if (m_writeBuffer.Length < m_writePayloadLength)
			{
				return;
			}
			byte[] array = m_writeBuffer.ToArray();
			payload = new PayloadData(new ArraySegment<byte>(array, 0, (int)m_writeBuffer.Length));
			m_writeBuffer.SetLength(0L);
		}
		else
		{
			payload = new PayloadData(new ArraySegment<byte>(buffer, offset, m_writePayloadLength));
		}
		await m_serverSession.SendReplyAsync(payload, m_ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		m_writePayloadLength = 0;
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		WriteAsync(buffer, offset, count, m_cancellationToken).GetAwaiter().GetResult();
	}

	public override void Flush()
	{
	}

	public override long Seek(long offset, SeekOrigin origin)
	{
		throw new NotImplementedException();
	}

	public override void SetLength(long value)
	{
		throw new NotImplementedException();
	}
}


using System;
using System.Net;
using System.Net.Security;
using System.Runtime.CompilerServices;
using System.Security.Authentication;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MySqlConnector.Core;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal static class AuthGSSAPI
{
	private static string GetServicePrincipalName(byte[] switchRequest)
	{
		ByteArrayReader byteArrayReader = new ByteArrayReader(MemoryExtensions.AsSpan(switchRequest));
		return Encoding.UTF8.GetString(byteArrayReader.ReadNullOrEofTerminatedByteString());
	}

	public static async Task<PayloadData> AuthenticateAsync(ConnectionSettings cs, byte[] switchRequestPayloadData, ServerSession session, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		using NegotiateToMySqlConverterStream innerStream = new NegotiateToMySqlConverterStream(session, ioBehavior, cancellationToken);
		using NegotiateStream negotiateStream = new NegotiateStream(innerStream);
		string targetName = ((cs.ServerSPN.Length == 0) ? GetServicePrincipalName(switchRequestPayloadData) : cs.ServerSPN);
		if (ioBehavior != 0)
		{
			await negotiateStream.AuthenticateAsClientAsync(CredentialCache.DefaultNetworkCredentials, targetName).ConfigureAwait(continueOnCapturedContext: false);
		}
		else
		{
			negotiateStream.AuthenticateAsClient(CredentialCache.DefaultNetworkCredentials, targetName);
		}
		if (cs.ServerSPN.Length != 0 && !negotiateStream.IsMutuallyAuthenticated)
		{
			throw new AuthenticationException("GSSAPI : Unable to verify server principal name using authentication type " + negotiateStream.RemoteIdentity?.AuthenticationType);
		}
		return innerStream.MySQLProtocolPayload ?? (await session.ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

internal sealed class BufferedByteReader
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private readonly byte[] m_buffer;

	private ArraySegment<byte> m_remainingData;

	public BufferedByteReader()
	{
		m_buffer = new byte[16384];
	}

	public ValueTask<ArraySegment<byte>> ReadBytesAsync([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] IByteHandler byteHandler, int count, IOBehavior ioBehavior)
	{
		if (m_remainingData.Count >= count)
		{
			ArraySegment<byte> result = Utility.Slice(m_remainingData, 0, count);
			m_remainingData = Utility.Slice(m_remainingData, count);
			return new ValueTask<ArraySegment<byte>>(result);
		}
		byte[] array = ((count > m_buffer.Length) ? new byte[count] : m_buffer);
		if (m_remainingData.Count > 0)
		{
			Buffer.BlockCopy(m_remainingData.Array, m_remainingData.Offset, array, 0, m_remainingData.Count);
			m_remainingData = new ArraySegment<byte>(array, 0, m_remainingData.Count);
		}
		return ReadBytesAsync(byteHandler, new ArraySegment<byte>(array, m_remainingData.Count, array.Length - m_remainingData.Count), count, ioBehavior);
	}

	private async ValueTask<ArraySegment<byte>> ReadBytesAsync([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] IByteHandler byteHandler, ArraySegment<byte> buffer, int totalBytesToRead, IOBehavior ioBehavior)
	{
		int num2;
		while (true)
		{
			int num = await byteHandler.ReadBytesAsync(buffer, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
			if (num == 0)
			{
				ArraySegment<byte> remainingData = m_remainingData;
				m_remainingData = default(ArraySegment<byte>);
				return remainingData;
			}
			num2 = buffer.Offset + num;
			if (num2 >= totalBytesToRead)
			{
				break;
			}
			buffer = Utility.Slice(buffer, num);
		}
		ArraySegment<byte> arraySegment = new ArraySegment<byte>(buffer.Array, 0, num2);
		ArraySegment<byte> result = Utility.Slice(arraySegment, 0, totalBytesToRead);
		m_remainingData = Utility.Slice(arraySegment, totalBytesToRead);
		return result;
	}
}


using System;
using System.Buffers.Binary;

internal ref struct ByteArrayReader
{
	private readonly ReadOnlySpan<byte> m_buffer;

	private readonly int m_maxOffset;

	private int m_offset;

	public int Offset
	{
		readonly get
		{
			return m_offset;
		}
		set
		{
			if (value < 0 || value > m_maxOffset)
			{
				throw new ArgumentOutOfRangeException("value", $"value must be between 0 and {m_maxOffset:d}");
			}
			m_offset = value;
		}
	}

	public readonly int BytesRemaining => m_maxOffset - m_offset;

	public ByteArrayReader(ReadOnlySpan<byte> buffer)
	{
		m_buffer = buffer;
		m_offset = 0;
		m_maxOffset = buffer.Length;
	}

	public byte ReadByte()
	{
		VerifyRead(1);
		return m_buffer[m_offset++];
	}

	public void ReadByte(byte value)
	{
		if (ReadByte() != value)
		{
			throw new FormatException($"Expected to read 0x{value:X2} but got 0x{m_buffer[m_offset - 1]:X2}");
		}
	}

	public short ReadInt16()
	{
		VerifyRead(2);
		ReadOnlySpan<byte> buffer = m_buffer;
		int offset = m_offset;
		short result = BinaryPrimitives.ReadInt16LittleEndian(buffer.Slice(offset, buffer.Length - offset));
		m_offset += 2;
		return result;
	}

	public ushort ReadUInt16()
	{
		VerifyRead(2);
		ReadOnlySpan<byte> buffer = m_buffer;
		int offset = m_offset;
		ushort result = BinaryPrimitives.ReadUInt16LittleEndian(buffer.Slice(offset, buffer.Length - offset));
		m_offset += 2;
		return result;
	}

	public int ReadInt32()
	{
		VerifyRead(4);
		ReadOnlySpan<byte> buffer = m_buffer;
		int offset = m_offset;
		int result = BinaryPrimitives.ReadInt32LittleEndian(buffer.Slice(offset, buffer.Length - offset));
		m_offset += 4;
		return result;
	}

	public uint ReadUInt32()
	{
		VerifyRead(4);
		ReadOnlySpan<byte> buffer = m_buffer;
		int offset = m_offset;
		uint result = BinaryPrimitives.ReadUInt32LittleEndian(buffer.Slice(offset, buffer.Length - offset));
		m_offset += 4;
		return result;
	}

	public uint ReadFixedLengthUInt32(int length)
	{
		if ((length <= 0 || length > 4) ? true : false)
		{
			throw new ArgumentOutOfRangeException("length");
		}
		VerifyRead(length);
		uint num = 0u;
		for (int i = 0; i < length; i++)
		{
			num |= (uint)(m_buffer[m_offset + i] << 8 * i);
		}
		m_offset += length;
		return num;
	}

	public ulong ReadFixedLengthUInt64(int length)
	{
		if ((length <= 0 || length > 8) ? true : false)
		{
			throw new ArgumentOutOfRangeException("length");
		}
		VerifyRead(length);
		ulong num = 0uL;
		for (int i = 0; i < length; i++)
		{
			num |= (ulong)m_buffer[m_offset + i] << 8 * i;
		}
		m_offset += length;
		return num;
	}

	public ReadOnlySpan<byte> ReadNullTerminatedByteString()
	{
		int i;
		for (i = m_offset; i < m_maxOffset && m_buffer[i] != 0; i++)
		{
		}
		if (i == m_maxOffset)
		{
			throw new FormatException("Read past end of buffer looking for NUL.");
		}
		ReadOnlySpan<byte> buffer = m_buffer;
		int offset = m_offset;
		ReadOnlySpan<byte> result = buffer.Slice(offset, i - offset);
		m_offset = i + 1;
		return result;
	}

	public ReadOnlySpan<byte> ReadNullOrEofTerminatedByteString()
	{
		int i;
		for (i = m_offset; i < m_maxOffset && m_buffer[i] != 0; i++)
		{
		}
		ReadOnlySpan<byte> buffer = m_buffer;
		int offset = m_offset;
		ReadOnlySpan<byte> result = buffer.Slice(offset, i - offset);
		if (i < m_maxOffset && m_buffer[i] == 0)
		{
			i++;
		}
		m_offset = i;
		return result;
	}

	public ReadOnlySpan<byte> ReadByteString(int length)
	{
		VerifyRead(length);
		ReadOnlySpan<byte> result = m_buffer.Slice(m_offset, length);
		m_offset += length;
		return result;
	}

	public ulong ReadLengthEncodedInteger()
	{
		byte b = m_buffer[m_offset++];
		return b switch
		{
			251 => throw new FormatException("Length-encoded integer cannot have 0xFB prefix byte."), 
			252 => ReadFixedLengthUInt32(2), 
			253 => ReadFixedLengthUInt32(3), 
			254 => ReadFixedLengthUInt64(8), 
			byte.MaxValue => throw new FormatException("Length-encoded integer cannot have 0xFF prefix byte."), 
			_ => b, 
		};
	}

	public int ReadLengthEncodedIntegerOrNull()
	{
		if (m_buffer[m_offset] == 251)
		{
			m_offset++;
			return -1;
		}
		return checked((int)ReadLengthEncodedInteger());
	}

	public ReadOnlySpan<byte> ReadLengthEncodedByteString()
	{
		int num = checked((int)ReadLengthEncodedInteger());
		ReadOnlySpan<byte> result = m_buffer.Slice(m_offset, num);
		m_offset += num;
		return result;
	}

	private readonly void VerifyRead(int length)
	{
		if (m_offset + length > m_maxOffset)
		{
			throw new InvalidOperationException("Read past end of buffer.");
		}
	}
}


using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

internal sealed class ByteBufferWriter : IBufferWriter<byte>
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private Encoder m_encoder;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private byte[] m_buffer;

	private Memory<byte> m_output;

	public int Position => m_buffer.Length - m_output.Length;

	public ArraySegment<byte> ArraySegment => new ArraySegment<byte>(m_buffer, 0, Position);

	public ByteBufferWriter(int capacity = 0)
	{
		m_buffer = ArrayPool<byte>.Shared.Rent(Math.Max(capacity, 128));
		m_output = m_buffer;
	}

	public PayloadData ToPayloadData()
	{
		return new PayloadData(ArraySegment, isPooled: true);
	}

	public Memory<byte> GetMemory(int sizeHint = 0)
	{
		if (sizeHint > m_output.Length)
		{
			Reallocate(sizeHint);
		}
		return m_output;
	}

	public Span<byte> GetSpan(int sizeHint = 0)
	{
		if (sizeHint > m_output.Length)
		{
			Reallocate(sizeHint);
		}
		return m_output.Span;
	}

	public void Advance(int count)
	{
		ref Memory<byte> output = ref m_output;
		m_output = output.Slice(count, output.Length - count);
	}

	public void TrimEnd(int byteCount)
	{
		m_output = MemoryExtensions.AsMemory(m_buffer, Position - byteCount);
	}

	public void Write(byte value)
	{
		if (m_output.Length < 1)
		{
			Reallocate();
		}
		m_output.Span[0] = value;
		ref Memory<byte> output = ref m_output;
		m_output = output.Slice(1, output.Length - 1);
	}

	public void Write(ushort value)
	{
		if (m_output.Length < 2)
		{
			Reallocate(2);
		}
		BinaryPrimitives.WriteUInt16LittleEndian(m_output.Span, value);
		ref Memory<byte> output = ref m_output;
		m_output = output.Slice(2, output.Length - 2);
	}

	public void Write(int value)
	{
		if (m_output.Length < 4)
		{
			Reallocate(4);
		}
		BinaryPrimitives.WriteInt32LittleEndian(m_output.Span, value);
		ref Memory<byte> output = ref m_output;
		m_output = output.Slice(4, output.Length - 4);
	}

	public void Write(uint value)
	{
		if (m_output.Length < 4)
		{
			Reallocate(4);
		}
		BinaryPrimitives.WriteUInt32LittleEndian(m_output.Span, value);
		ref Memory<byte> output = ref m_output;
		m_output = output.Slice(4, output.Length - 4);
	}

	public void Write(ulong value)
	{
		if (m_output.Length < 8)
		{
			Reallocate(8);
		}
		BinaryPrimitives.WriteUInt64LittleEndian(m_output.Span, value);
		ref Memory<byte> output = ref m_output;
		m_output = output.Slice(8, output.Length - 8);
	}

	public void Write(ArraySegment<byte> arraySegment)
	{
		Write(MemoryExtensions.AsSpan(arraySegment));
	}

	public void Write(ReadOnlySpan<byte> span)
	{
		if (m_output.Length < span.Length)
		{
			Reallocate(span.Length);
		}
		span.CopyTo(m_output.Span);
		ref Memory<byte> output = ref m_output;
		int length = span.Length;
		m_output = output.Slice(length, output.Length - length);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public void Write(string value)
	{
		Write(MemoryExtensions.AsSpan(value));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public void WriteAscii(string value)
	{
		WriteAscii(MemoryExtensions.AsSpan(value));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public void Write(string value, int offset, int length)
	{
		Write(MemoryExtensions.AsSpan(value, offset, length));
	}

	public void Write(ReadOnlySpan<char> chars)
	{
		if (m_output.Length < chars.Length * 3)
		{
			int byteCount = Encoding.UTF8.GetByteCount(chars);
			if (m_output.Length < byteCount)
			{
				Reallocate(byteCount);
			}
		}
		ref Memory<byte> output = ref m_output;
		int bytes = Encoding.UTF8.GetBytes(chars, m_output.Span);
		m_output = output.Slice(bytes, output.Length - bytes);
	}

	public void Write(ReadOnlySpan<char> chars, bool flush)
	{
		if (m_encoder == null)
		{
			m_encoder = Encoding.UTF8.GetEncoder();
		}
		int num;
		while (chars.Length > 0)
		{
			if (m_output.Length < 4)
			{
				Reallocate();
			}
			m_encoder.Convert(chars, m_output.Span, flush: false, out var charsUsed, out var bytesUsed, out var completed);
			num = charsUsed;
			chars = chars.Slice(num, chars.Length - num);
			ref Memory<byte> output = ref m_output;
			num = bytesUsed;
			m_output = output.Slice(num, output.Length - num);
			if (!completed)
			{
				Reallocate();
			}
		}
		if (flush && m_encoder != null)
		{
			if (m_output.Length < 4)
			{
				Reallocate();
			}
			m_encoder.Convert(MemoryExtensions.AsSpan(""), m_output.Span, flush: true, out num, out var bytesUsed2, out var _);
			ref Memory<byte> output = ref m_output;
			num = bytesUsed2;
			m_output = output.Slice(num, output.Length - num);
		}
	}

	public void WriteAscii(ReadOnlySpan<char> chars)
	{
		if (m_output.Length < chars.Length)
		{
			Reallocate(chars.Length);
		}
		ref Memory<byte> output = ref m_output;
		int bytes = Encoding.ASCII.GetBytes(chars, m_output.Span);
		m_output = output.Slice(bytes, output.Length - bytes);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public void WriteLengthEncodedString(StringBuilder stringBuilder)
	{
		this.WriteLengthEncodedString(stringBuilder.ToString());
	}

	public void WriteString(short value)
	{
		Utf8Formatter.TryFormat(value, GetSpan(6), out var bytesWritten);
		ref Memory<byte> output = ref m_output;
		int num = bytesWritten;
		m_output = output.Slice(num, output.Length - num);
	}

	public void WriteString(ushort value)
	{
		Utf8Formatter.TryFormat(value, GetSpan(5), out var bytesWritten);
		ref Memory<byte> output = ref m_output;
		int num = bytesWritten;
		m_output = output.Slice(num, output.Length - num);
	}

	public void WriteString(int value)
	{
		Utf8Formatter.TryFormat(value, GetSpan(11), out var bytesWritten);
		ref Memory<byte> output = ref m_output;
		int num = bytesWritten;
		m_output = output.Slice(num, output.Length - num);
	}

	public void WriteString(uint value)
	{
		Utf8Formatter.TryFormat(value, GetSpan(10), out var bytesWritten);
		ref Memory<byte> output = ref m_output;
		int num = bytesWritten;
		m_output = output.Slice(num, output.Length - num);
	}

	public void WriteString(long value)
	{
		Utf8Formatter.TryFormat(value, GetSpan(20), out var bytesWritten);
		ref Memory<byte> output = ref m_output;
		int num = bytesWritten;
		m_output = output.Slice(num, output.Length - num);
	}

	public void WriteString(ulong value)
	{
		Utf8Formatter.TryFormat(value, GetSpan(20), out var bytesWritten);
		ref Memory<byte> output = ref m_output;
		int num = bytesWritten;
		m_output = output.Slice(num, output.Length - num);
	}

	private void Reallocate(int additional = 0)
	{
		int position = Position;
		byte[] array = ArrayPool<byte>.Shared.Rent(Math.Max(position + additional, m_buffer.Length * 2));
		MemoryExtensions.AsSpan(m_buffer, 0, position).CopyTo(array);
		ArrayPool<byte>.Shared.Return(m_buffer);
		m_buffer = array;
		m_output = new Memory<byte>(m_buffer, position, m_buffer.Length - position);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal static class ByteBufferWriterExtensions
{
	public static void WriteLengthEncodedInteger(this ByteBufferWriter writer, ulong value)
	{
		if (value < 65536)
		{
			if (value < 251)
			{
				writer.Write((byte)value);
				return;
			}
			writer.Write((byte)252);
			writer.Write((ushort)value);
		}
		else if (value < 16777216)
		{
			writer.Write((uint)((value << 8) | 0xFD));
		}
		else
		{
			writer.Write((byte)254);
			writer.Write(value);
		}
	}

	public static void WriteLengthEncodedString(this ByteBufferWriter writer, string value)
	{
		writer.WriteLengthEncodedString(MemoryExtensions.AsSpan(value));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public static void WriteLengthEncodedString([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] this ByteBufferWriter writer, ReadOnlySpan<char> value)
	{
		int byteCount = Encoding.UTF8.GetByteCount(value);
		writer.WriteLengthEncodedInteger((ulong)byteCount);
		writer.Write(value);
	}

	public static void WriteLengthEncodedAsciiString(this ByteBufferWriter writer, string value)
	{
		writer.WriteLengthEncodedInteger((ulong)value.Length);
		writer.WriteAscii(MemoryExtensions.AsSpan(value));
	}

	public static void WriteNullTerminatedString(this ByteBufferWriter writer, string value)
	{
		writer.Write(value);
		writer.Write((byte)0);
	}
}


using System;
using System.IO;
using System.IO.Compression;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using MySqlConnector;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

internal sealed class CompressedPayloadHandler : IPayloadHandler, IDisposable
{
	private sealed class CompressedByteHandler : IByteHandler, IDisposable
	{
		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
		private readonly CompressedPayloadHandler m_compressedPayloadHandler;

		private readonly ProtocolErrorBehavior m_protocolErrorBehavior;

		public int RemainingTimeout
		{
			get
			{
				return m_compressedPayloadHandler.ByteHandler.RemainingTimeout;
			}
			set
			{
				m_compressedPayloadHandler.ByteHandler.RemainingTimeout = value;
			}
		}

		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		public CompressedByteHandler(CompressedPayloadHandler compressedPayloadHandler, ProtocolErrorBehavior protocolErrorBehavior)
		{
			m_compressedPayloadHandler = compressedPayloadHandler;
			m_protocolErrorBehavior = protocolErrorBehavior;
		}

		public void Dispose()
		{
		}

		public ValueTask<int> ReadBytesAsync(Memory<byte> buffer, IOBehavior ioBehavior)
		{
			return m_compressedPayloadHandler.ReadBytesAsync(buffer, m_protocolErrorBehavior, ioBehavior);
		}

		public ValueTask WriteBytesAsync(ReadOnlyMemory<byte> data, IOBehavior ioBehavior)
		{
			throw new NotSupportedException();
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private readonly BufferedByteReader m_bufferedByteReader;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private readonly BufferedByteReader m_compressedBufferedByteReader;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private MemoryStream m_uncompressedStream;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private IByteHandler m_uncompressedStreamByteHandler;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private IByteHandler m_byteHandler;

	private byte m_compressedSequenceNumber;

	private byte m_uncompressedSequenceNumber;

	private ArraySegment<byte> m_remainingData;

	private bool m_isContinuationPacket;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public IByteHandler ByteHandler
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get
		{
			return m_byteHandler;
		}
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		set
		{
			throw new NotSupportedException();
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public CompressedPayloadHandler(IByteHandler byteHandler)
	{
		m_uncompressedStream = new MemoryStream();
		m_uncompressedStreamByteHandler = new StreamByteHandler(m_uncompressedStream);
		m_byteHandler = byteHandler;
		m_bufferedByteReader = new BufferedByteReader();
		m_compressedBufferedByteReader = new BufferedByteReader();
	}

	public void Dispose()
	{
		Utility.Dispose(ref m_byteHandler);
		Utility.Dispose(ref m_uncompressedStreamByteHandler);
		Utility.Dispose(ref m_uncompressedStream);
	}

	public void StartNewConversation()
	{
		m_compressedSequenceNumber = (m_uncompressedSequenceNumber = 0);
	}

	public void SetNextSequenceNumber(int sequenceNumber)
	{
		throw new NotSupportedException();
	}

	public ValueTask<ArraySegment<byte>> ReadPayloadAsync([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ArraySegmentHolder<byte> cache, ProtocolErrorBehavior protocolErrorBehavior, IOBehavior ioBehavior)
	{
		using CompressedByteHandler byteHandler = new CompressedByteHandler(this, protocolErrorBehavior);
		return ProtocolUtility.ReadPayloadAsync(m_bufferedByteReader, byteHandler, () => -1, cache, protocolErrorBehavior, ioBehavior);
	}

	public async ValueTask WritePayloadAsync(ReadOnlyMemory<byte> payload, IOBehavior ioBehavior)
	{
		await ProtocolUtility.WritePayloadAsync(m_uncompressedStreamByteHandler, GetNextUncompressedSequenceNumber, payload, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
		if (m_uncompressedStream.Length != 0L)
		{
			if (!m_uncompressedStream.TryGetBuffer(out var buffer))
			{
				throw new InvalidOperationException("Couldn't get uncompressed stream buffer.");
			}
			await CompressAndWrite(buffer, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
			m_uncompressedStream.SetLength(0L);
		}
	}

	private async ValueTask<int> ReadBytesAsync(Memory<byte> buffer, ProtocolErrorBehavior protocolErrorBehavior, IOBehavior ioBehavior)
	{
		int num;
		if (m_remainingData.Count > 0)
		{
			num = Math.Min(m_remainingData.Count, buffer.Length);
			MemoryExtensions.AsSpan(m_remainingData, 0, num).CopyTo(buffer.Span);
			m_remainingData = Utility.Slice(m_remainingData, num);
			return num;
		}
		ArraySegment<byte> segment = await m_compressedBufferedByteReader.ReadBytesAsync(m_byteHandler, 7, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
		if (segment.Count < 7)
		{
			if (protocolErrorBehavior == ProtocolErrorBehavior.Ignore)
			{
				return 0;
			}
			throw new EndOfStreamException($"Wanted to read 7 bytes but only read {segment.Count:d} when reading compressed packet header");
		}
		int payloadLength = (int)SerializationUtility.ReadUInt32(MemoryExtensions.AsSpan(segment, 0, 3));
		byte b = segment.Array[segment.Offset + 3];
		int uncompressedLength = (int)SerializationUtility.ReadUInt32(MemoryExtensions.AsSpan(segment, 4, 3));
		byte nextCompressedSequenceNumber = GetNextCompressedSequenceNumber();
		if (b != nextCompressedSequenceNumber)
		{
			if (protocolErrorBehavior == ProtocolErrorBehavior.Ignore)
			{
				return 0;
			}
			throw MySqlProtocolException.CreateForPacketOutOfOrder(nextCompressedSequenceNumber, b);
		}
		if (!m_isContinuationPacket)
		{
			m_uncompressedSequenceNumber = b;
		}
		m_isContinuationPacket = payloadLength == 16777215 || uncompressedLength == 16777215;
		ArraySegment<byte> remainingData = await m_compressedBufferedByteReader.ReadBytesAsync(m_byteHandler, payloadLength, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
		if (remainingData.Count < payloadLength)
		{
			if (protocolErrorBehavior == ProtocolErrorBehavior.Ignore)
			{
				return 0;
			}
			throw new EndOfStreamException($"Wanted to read {payloadLength:d} bytes but only read {remainingData.Count:d} when reading compressed payload");
		}
		if (uncompressedLength == 0)
		{
			m_remainingData = remainingData;
		}
		else
		{
			byte b2 = remainingData.Array[remainingData.Offset];
			byte b3 = remainingData.Array[remainingData.Offset + 1];
			if (b2 != 120 || (b3 & 0x20) == 32 || (b2 * 256 + b3) % 31 != 0)
			{
				if (protocolErrorBehavior == ProtocolErrorBehavior.Ignore)
				{
					return 0;
				}
				throw new NotSupportedException($"Unsupported zlib header: {b2:X2}{b3:X2}");
			}
			byte[] array = new byte[uncompressedLength];
			using MemoryStream stream = new MemoryStream(remainingData.Array, remainingData.Offset + 2, remainingData.Count - 2 - 4);
			using DeflateStream deflateStream = new DeflateStream(stream, CompressionMode.Decompress);
			int num2 = 0;
			int num3;
			do
			{
				num3 = deflateStream.Read(array, num2, uncompressedLength - num2);
				num2 += num3;
			}
			while (num3 > 0);
			if (num2 != uncompressedLength && protocolErrorBehavior == ProtocolErrorBehavior.Throw)
			{
				throw new MySqlEndOfStreamException(uncompressedLength, num2);
			}
			m_remainingData = new ArraySegment<byte>(array, 0, num2);
			uint num4 = Adler32.Calculate(MemoryExtensions.AsSpan(array, 0, num2));
			int num5 = remainingData.Offset + remainingData.Count - 4;
			if (remainingData.Array[num5] != ((num4 >> 24) & 0xFF) || remainingData.Array[num5 + 1] != ((num4 >> 16) & 0xFF) || remainingData.Array[num5 + 2] != ((num4 >> 8) & 0xFF) || remainingData.Array[num5 + 3] != (num4 & 0xFF))
			{
				if (protocolErrorBehavior == ProtocolErrorBehavior.Ignore)
				{
					return 0;
				}
				throw new NotSupportedException("Invalid Adler-32 checksum of uncompressed data.");
			}
		}
		num = Math.Min(m_remainingData.Count, buffer.Length);
		MemoryExtensions.AsSpan(m_remainingData, 0, num).CopyTo(buffer.Span);
		m_remainingData = Utility.Slice(m_remainingData, num);
		return num;
	}

	private byte GetNextCompressedSequenceNumber()
	{
		return m_compressedSequenceNumber++;
	}

	private int GetNextUncompressedSequenceNumber()
	{
		return m_uncompressedSequenceNumber++;
	}

	private async ValueTask CompressAndWrite(ArraySegment<byte> remainingUncompressedData, IOBehavior ioBehavior)
	{
		int num = Math.Min(remainingUncompressedData.Count, 16777215);
		ArraySegment<byte> buffer = default(ArraySegment<byte>);
		if (num > 80)
		{
			using MemoryStream memoryStream = new MemoryStream();
			memoryStream.WriteByte(120);
			memoryStream.WriteByte(218);
			using (DeflateStream deflateStream = new DeflateStream(memoryStream, CompressionLevel.Optimal, leaveOpen: true))
			{
				deflateStream.Write(remainingUncompressedData.Array, remainingUncompressedData.Offset, num);
			}
			uint num2 = Adler32.Calculate(MemoryExtensions.AsSpan(remainingUncompressedData, 0, num));
			memoryStream.WriteByte((byte)((num2 >> 24) & 0xFF));
			memoryStream.WriteByte((byte)((num2 >> 16) & 0xFF));
			memoryStream.WriteByte((byte)((num2 >> 8) & 0xFF));
			memoryStream.WriteByte((byte)(num2 & 0xFF));
			if (!memoryStream.TryGetBuffer(out buffer))
			{
				throw new InvalidOperationException("Couldn't get compressed stream buffer.");
			}
		}
		uint value = (uint)num;
		if (buffer.Array == null || buffer.Count >= num)
		{
			value = 0u;
			buffer = Utility.Slice(remainingUncompressedData, 0, num);
		}
		byte[] array = new byte[buffer.Count + 7];
		SerializationUtility.WriteUInt32((uint)buffer.Count, array, 0, 3);
		array[3] = GetNextCompressedSequenceNumber();
		SerializationUtility.WriteUInt32(value, array, 4, 3);
		Buffer.BlockCopy(buffer.Array, buffer.Offset, array, 7, buffer.Count);
		remainingUncompressedData = Utility.Slice(remainingUncompressedData, num);
		await m_byteHandler.WriteBytesAsync(new ArraySegment<byte>(array, 0, array.Length), ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
		if (remainingUncompressedData.Count != 0)
		{
			await CompressAndWrite(remainingUncompressedData, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

private sealed class CompressedByteHandler : IByteHandler, IDisposable
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private readonly CompressedPayloadHandler m_compressedPayloadHandler;

	private readonly ProtocolErrorBehavior m_protocolErrorBehavior;

	public int RemainingTimeout
	{
		get
		{
			return m_compressedPayloadHandler.ByteHandler.RemainingTimeout;
		}
		set
		{
			m_compressedPayloadHandler.ByteHandler.RemainingTimeout = value;
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public CompressedByteHandler(CompressedPayloadHandler compressedPayloadHandler, ProtocolErrorBehavior protocolErrorBehavior)
	{
		m_compressedPayloadHandler = compressedPayloadHandler;
		m_protocolErrorBehavior = protocolErrorBehavior;
	}

	public void Dispose()
	{
	}

	public ValueTask<int> ReadBytesAsync(Memory<byte> buffer, IOBehavior ioBehavior)
	{
		return m_compressedPayloadHandler.ReadBytesAsync(buffer, m_protocolErrorBehavior, ioBehavior);
	}

	public ValueTask WriteBytesAsync(ReadOnlyMemory<byte> data, IOBehavior ioBehavior)
	{
		throw new NotSupportedException();
	}
}


using System;
using System.Threading.Tasks;
using MySqlConnector.Protocol.Serialization;

internal interface IByteHandler : IDisposable
{
	int RemainingTimeout { get; set; }

	ValueTask<int> ReadBytesAsync(Memory<byte> buffer, IOBehavior ioBehavior);

	ValueTask WriteBytesAsync(ReadOnlyMemory<byte> data, IOBehavior ioBehavior);
}


internal enum IOBehavior
{
	Synchronous,
	Asynchronous
}


using System;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using MySqlConnector.Protocol.Serialization;

internal interface IPayloadHandler : IDisposable
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	IByteHandler ByteHandler
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		set;
	}

	void StartNewConversation();

	void SetNextSequenceNumber(int sequenceNumber);

	ValueTask<ArraySegment<byte>> ReadPayloadAsync([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ArraySegmentHolder<byte> cache, ProtocolErrorBehavior protocolErrorBehavior, IOBehavior ioBehavior);

	ValueTask WritePayloadAsync(ReadOnlyMemory<byte> payload, IOBehavior ioBehavior);
}


using System;

internal readonly struct Packet
{
	public ArraySegment<byte> Contents { get; }

	public Packet(ArraySegment<byte> contents)
	{
		Contents = contents;
	}
}


internal enum ProtocolErrorBehavior
{
	Throw,
	Ignore
}


using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using MySqlConnector;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Serialization;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal static class ProtocolUtility
{
	public const int MaxPacketSize = 16777215;

	public static int GetBytesPerCharacter(CharacterSet characterSet)
	{
		if (characterSet <= CharacterSet.Utf32ThaiUnicode520Weight2)
		{
			if (characterSet > CharacterSet.Utf8Mb4ThaiUnicode520Weight2)
			{
				if (characterSet - 640 <= CharacterSet.Latin2CzechCaseSensitive)
				{
					goto IL_083a;
				}
				if (characterSet - 672 <= CharacterSet.Latin2CzechCaseSensitive || characterSet - 736 <= CharacterSet.Latin2CzechCaseSensitive)
				{
					goto IL_083e;
				}
				goto IL_0840;
			}
			switch (characterSet)
			{
			default:
				if (characterSet - 576 <= CharacterSet.Latin2CzechCaseSensitive)
				{
					goto IL_083c;
				}
				if (characterSet - 608 <= CharacterSet.Latin2CzechCaseSensitive)
				{
					goto IL_083e;
				}
				goto IL_0840;
			case CharacterSet.Latin2CzechCaseSensitive:
			case CharacterSet.Dec8SwedishCaseInsensitive:
			case CharacterSet.Cp850GeneralCaseInsensitive:
			case CharacterSet.Latin1German1CaseInsensitive:
			case CharacterSet.Hp8EnglishCaseInsensitive:
			case CharacterSet.Koi8rGeneralCaseInsensitive:
			case CharacterSet.Latin1SwedishCaseInsensitive:
			case CharacterSet.Latin2GeneralCaseInsensitive:
			case CharacterSet.Swe7SwedishCaseInsensitive:
			case CharacterSet.AsciiGeneralCaseInsensitive:
			case CharacterSet.Cp1251BulgarianCaseInsensitive:
			case CharacterSet.Latin1DanishCaseInsensitive:
			case CharacterSet.HebrewGeneralCaseInsensitive:
			case CharacterSet.Tis620ThaiCaseInsensitive:
			case CharacterSet.Latin7EstonianCaseSensitive:
			case CharacterSet.Latin2HungarianCaseInsensitive:
			case CharacterSet.Koi8uGeneralCaseInsensitive:
			case CharacterSet.Cp1251UkrainianCaseInsensitive:
			case CharacterSet.GreekGeneralCaseInsensitive:
			case CharacterSet.Cp1250GeneralCaseInsensitive:
			case CharacterSet.Latin2CroatianCaseInsensitive:
			case CharacterSet.Cp1257LithuanianCaseInsensitive:
			case CharacterSet.Latin5TurkishCaseInsensitive:
			case CharacterSet.Latin1German2CaseInsensitive:
			case CharacterSet.Armscii8GeneralCaseInsensitive:
			case CharacterSet.Cp1250CzechCaseSensitive:
			case CharacterSet.Cp866GeneralCaseInsensitive:
			case CharacterSet.Keybcs2GeneralCaseInsensitive:
			case CharacterSet.MacceGeneralCaseInsensitive:
			case CharacterSet.MacromanGeneralCaseInsensitive:
			case CharacterSet.Cp852GeneralCaseInsensitive:
			case CharacterSet.Latin7GeneralCaseInsensitive:
			case CharacterSet.Latin7GeneralCaseSensitive:
			case CharacterSet.MacceBinary:
			case CharacterSet.Cp1250CroatianCaseInsensitive:
			case CharacterSet.Latin1Binary:
			case CharacterSet.Latin1GeneralCaseInsensitive:
			case CharacterSet.Latin1GeneralCaseSensitive:
			case CharacterSet.Cp1251Binary:
			case CharacterSet.Cp1251GeneralCaseInsensitive:
			case CharacterSet.Cp1251GeneralCaseSensitive:
			case CharacterSet.MacromanBinary:
			case CharacterSet.Cp1256GeneralCaseInsensitive:
			case CharacterSet.Cp1257Binary:
			case CharacterSet.Cp1257GeneralCaseInsensitive:
			case CharacterSet.Binary:
			case CharacterSet.Armscii8Binary:
			case CharacterSet.AsciiBinary:
			case CharacterSet.Cp1250Binary:
			case CharacterSet.Cp1256Binary:
			case CharacterSet.Cp866Binary:
			case CharacterSet.Dec8Binary:
			case CharacterSet.GreekBinary:
			case CharacterSet.HebrewBinary:
			case CharacterSet.Hp8Binary:
			case CharacterSet.Keybcs2Binary:
			case CharacterSet.Koi8rBinary:
			case CharacterSet.Koi8uBinary:
			case CharacterSet.Latin2Binary:
			case CharacterSet.Latin5Binary:
			case CharacterSet.Latin7Binary:
			case CharacterSet.Cp850Binary:
			case CharacterSet.Cp852Binary:
			case CharacterSet.Swe7Binary:
			case CharacterSet.Tis620Binary:
			case CharacterSet.Geostd8GeneralCaseInsensitive:
			case CharacterSet.Geostd8Binary:
			case CharacterSet.Latin1SpanishCaseInsensitive:
			case CharacterSet.Cp1250PolishCaseInsensitive:
				break;
			case CharacterSet.Big5ChineseCaseInsensitive:
			case CharacterSet.SjisJapaneseCaseInsensitive:
			case CharacterSet.EuckrKoreanCaseInsensitive:
			case CharacterSet.Gb2312ChineseCaseInsensitive:
			case CharacterSet.GbkChineseCaseInsensitive:
			case CharacterSet.Ucs2GeneralCaseInsensitive:
			case CharacterSet.Big5Binary:
			case CharacterSet.EuckrBinary:
			case CharacterSet.Gb2312Binary:
			case CharacterSet.GbkBinary:
			case CharacterSet.SjisBinary:
			case CharacterSet.Ucs2Binary:
			case CharacterSet.Cp932JapaneseCaseInsensitive:
			case CharacterSet.Cp932Binary:
			case CharacterSet.Ucs2UnicodeCaseInsensitive:
			case CharacterSet.Ucs2IcelandicCaseInsensitive:
			case CharacterSet.Ucs2LatvianCaseInsensitive:
			case CharacterSet.Ucs2RomanianCaseInsensitive:
			case CharacterSet.Ucs2SlovenianCaseInsensitive:
			case CharacterSet.Ucs2PolishCaseInsensitive:
			case CharacterSet.Ucs2EstonianCaseInsensitive:
			case CharacterSet.Ucs2SpanishCaseInsensitive:
			case CharacterSet.Ucs2SwedishCaseInsensitive:
			case CharacterSet.Ucs2TurkishCaseInsensitive:
			case CharacterSet.Ucs2CzechCaseInsensitive:
			case CharacterSet.Ucs2DanishCaseInsensitive:
			case CharacterSet.Ucs2LithuanianCaseInsensitive:
			case CharacterSet.Ucs2SlovakCaseInsensitive:
			case CharacterSet.Ucs2Spanish2CaseInsensitive:
			case CharacterSet.Ucs2RomanCaseInsensitive:
			case CharacterSet.Ucs2PersianCaseInsensitive:
			case CharacterSet.Ucs2EsperantoCaseInsensitive:
			case CharacterSet.Ucs2HungarianCaseInsensitive:
			case CharacterSet.Ucs2SinhalaCaseInsensitive:
			case CharacterSet.Ucs2German2CaseInsensitive:
			case CharacterSet.Ucs2CroatianCaseInsensitive:
			case CharacterSet.Ucs2Unicode520CaseInsensitive:
			case CharacterSet.Ucs2VietnameseCaseInsensitive:
			case CharacterSet.Ucs2GeneralMySql500CaseInsensitive:
				goto IL_083a;
			case CharacterSet.UjisJapaneseCaseInsensitive:
			case CharacterSet.Utf8Mb3GeneralCaseInsensitive:
			case CharacterSet.Utf8Mb3ToLowerCaseInsensitive:
			case CharacterSet.Utf8Mb3Binary:
			case CharacterSet.UjisBinary:
			case CharacterSet.EucjpmsJapaneseCaseInsensitive:
			case CharacterSet.EucjpmsBinary:
			case CharacterSet.Utf8Mb3UnicodeCaseInsensitive:
			case CharacterSet.Utf8Mb3IcelandicCaseInsensitive:
			case CharacterSet.Utf8Mb3LatvianCaseInsensitive:
			case CharacterSet.Utf8Mb3RomanianCaseInsensitive:
			case CharacterSet.Utf8Mb3SlovenianCaseInsensitive:
			case CharacterSet.Utf8Mb3PolishCaseInsensitive:
			case CharacterSet.Utf8Mb3EstonianCaseInsensitive:
			case CharacterSet.Utf8Mb3SpanishCaseInsensitive:
			case CharacterSet.Utf8Mb3SwedishCaseInsensitive:
			case CharacterSet.Utf8Mb3TurkishCaseInsensitive:
			case CharacterSet.Utf8Mb3CzechCaseInsensitive:
			case CharacterSet.Utf8Mb3DanishCaseInsensitive:
			case CharacterSet.Utf8Mb3LithuanianCaseInsensitive:
			case CharacterSet.Utf8Mb3SlovakCaseInsensitive:
			case CharacterSet.Utf8Mb3Spanish2CaseInsensitive:
			case CharacterSet.Utf8Mb3RomanCaseInsensitive:
			case CharacterSet.Utf8Mb3PersianCaseInsensitive:
			case CharacterSet.Utf8Mb3EsperantoCaseInsensitive:
			case CharacterSet.Utf8Mb3HungarianCaseInsensitive:
			case CharacterSet.Utf8Mb3SinhalaCaseInsensitive:
			case CharacterSet.Utf8Mb3German2CaseInsensitive:
			case CharacterSet.Utf8Mb3CroatianCaseInsensitive:
			case CharacterSet.Utf8Mb3Unicode520CaseInsensitive:
			case CharacterSet.Utf8Mb3VietnameseCaseInsensitive:
			case CharacterSet.Utf8Mb3GeneralMySql500CaseInsensitive:
				goto IL_083c;
			case CharacterSet.Utf8Mb4GeneralCaseInsensitive:
			case CharacterSet.Utf8Mb4Binary:
			case CharacterSet.Utf16GeneralCaseInsensitive:
			case CharacterSet.Utf16Binary:
			case CharacterSet.Utf16leGeneralCaseInsensitive:
			case CharacterSet.Utf32GeneralCaseInsensitive:
			case CharacterSet.Utf32Binary:
			case CharacterSet.Utf16leBinary:
			case CharacterSet.Utf16UnicodeCaseInsensitive:
			case CharacterSet.Utf16IcelandicCaseInsensitive:
			case CharacterSet.Utf16LatvianCaseInsensitive:
			case CharacterSet.Utf16RomanianCaseInsensitive:
			case CharacterSet.Utf16SlovenianCaseInsensitive:
			case CharacterSet.Utf16PolishCaseInsensitive:
			case CharacterSet.Utf16EstonianCaseInsensitive:
			case CharacterSet.Utf16SpanishCaseInsensitive:
			case CharacterSet.Utf16SwedishCaseInsensitive:
			case CharacterSet.Utf16TurkishCaseInsensitive:
			case CharacterSet.Utf16CzechCaseInsensitive:
			case CharacterSet.Utf16DanishCaseInsensitive:
			case CharacterSet.Utf16LithuanianCaseInsensitive:
			case CharacterSet.Utf16SlovakCaseInsensitive:
			case CharacterSet.Utf16Spanish2CaseInsensitive:
			case CharacterSet.Utf16RomanCaseInsensitive:
			case CharacterSet.Utf16PersianCaseInsensitive:
			case CharacterSet.Utf16EsperantoCaseInsensitive:
			case CharacterSet.Utf16HungarianCaseInsensitive:
			case CharacterSet.Utf16SinhalaCaseInsensitive:
			case CharacterSet.Utf16German2CaseInsensitive:
			case CharacterSet.Utf16CroatianCaseInsensitive:
			case CharacterSet.Utf16Unicode520CaseInsensitive:
			case CharacterSet.Utf16VietnameseCaseInsensitive:
			case CharacterSet.Utf32UnicodeCaseInsensitive:
			case CharacterSet.Utf32IcelandicCaseInsensitive:
			case CharacterSet.Utf32LatvianCaseInsensitive:
			case CharacterSet.Utf32RomanianCaseInsensitive:
			case CharacterSet.Utf32SlovenianCaseInsensitive:
			case CharacterSet.Utf32PolishCaseInsensitive:
			case CharacterSet.Utf32EstonianCaseInsensitive:
			case CharacterSet.Utf32SpanishCaseInsensitive:
			case CharacterSet.Utf32SwedishCaseInsensitive:
			case CharacterSet.Utf32TurkishCaseInsensitive:
			case CharacterSet.Utf32CzechCaseInsensitive:
			case CharacterSet.Utf32DanishCaseInsensitive:
			case CharacterSet.Utf32LithuanianCaseInsensitive:
			case CharacterSet.Utf32SlovakCaseInsensitive:
			case CharacterSet.Utf32Spanish2CaseInsensitive:
			case CharacterSet.Utf32RomanCaseInsensitive:
			case CharacterSet.Utf32PersianCaseInsensitive:
			case CharacterSet.Utf32EsperantoCaseInsensitive:
			case CharacterSet.Utf32HungarianCaseInsensitive:
			case CharacterSet.Utf32SinhalaCaseInsensitive:
			case CharacterSet.Utf32German2CaseInsensitive:
			case CharacterSet.Utf32CroatianCaseInsensitive:
			case CharacterSet.Utf32Unicode520CaseInsensitive:
			case CharacterSet.Utf32VietnameseCaseInsensitive:
			case CharacterSet.Utf8Mb4UnicodeCaseInsensitive:
			case CharacterSet.Utf8Mb4IcelandicCaseInsensitive:
			case CharacterSet.Utf8Mb4LatvianCaseInsensitive:
			case CharacterSet.Utf8Mb4RomanianCaseInsensitive:
			case CharacterSet.Utf8Mb4SlovenianCaseInsensitive:
			case CharacterSet.Utf8Mb4PolishCaseInsensitive:
			case CharacterSet.Utf8Mb4EstonianCaseInsensitive:
			case CharacterSet.Utf8Mb4SpanishCaseInsensitive:
			case CharacterSet.Utf8Mb4SwedishCaseInsensitive:
			case CharacterSet.Utf8Mb4TurkishCaseInsensitive:
			case CharacterSet.Utf8Mb4CzechCaseInsensitive:
			case CharacterSet.Utf8Mb4DanishCaseInsensitive:
			case CharacterSet.Utf8Mb4LithuanianCaseInsensitive:
			case CharacterSet.Utf8Mb4SlovakCaseInsensitive:
			case CharacterSet.Utf8Mb4Spanish2CaseInsensitive:
			case CharacterSet.Utf8Mb4RomanCaseInsensitive:
			case CharacterSet.Utf8Mb4PersianCaseInsensitive:
			case CharacterSet.Utf8Mb4EsperantoCaseInsensitive:
			case CharacterSet.Utf8Mb4HungarianCaseInsensitive:
			case CharacterSet.Utf8Mb4SinhalaCaseInsensitive:
			case CharacterSet.Utf8Mb4German2CaseInsensitive:
			case CharacterSet.Utf8Mb4CroatianCaseInsensitive:
			case CharacterSet.Utf8Mb4Unicode520CaseInsensitive:
			case CharacterSet.Utf8Mb4VietnameseCaseInsensitive:
			case CharacterSet.Gb18030ChineseCaseInsensitive:
			case CharacterSet.Gb18030Binary:
			case CharacterSet.Gb18030Unicode520CaseInsensitive:
			case CharacterSet.Utf8Mb4Uca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4GermanPhonebookUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4IcelandicUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4LatvianUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4RomanianUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4SlovenianUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4PolishUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4EstonianUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4SpanishUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4SwedishUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4TurkishUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4CaseSensitiveUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4DanishUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4LithuanianUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4SlovakUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4TraditionalSpanishUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4LatinUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4EsperantoUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4HungarianUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4CroatianUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4VietnameseUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4Uca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4GermanPhonebookUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4IcelandicUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4LatvianUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4RomanianUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4SlovenianUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4PolishUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4EstonianUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4SpanishUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4SwedishUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4TurkishUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4CaseSensitiveUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4DanishUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4LithuanianUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4SlovakUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4TraditionalSpanishUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4LatinUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4EsperantoUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4HungarianUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4CroatianUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4VietnameseUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4JapaneseUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4JapaneseUca900AccentSensitiveCaseSensitiveKanaSensitive:
			case CharacterSet.Utf8Mb4Uca900AccentSensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4RussianUca900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4RussianUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4ChineseUca900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4Uca900Binary:
			case CharacterSet.Utf8Mb4NorwegianBokmal0900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4NorwegianBokmal0900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4NorwegianNynorsk0900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4NorwegianNynorsk0900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4SerbianLatin0900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4SerbianLatin0900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4Bosnian0900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4Bosnian0900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4Bulgarian0900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4Bulgarian0900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4Galician0900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4Galician0900AccentSensitiveCaseSensitive:
			case CharacterSet.Utf8Mb4MongolianCyrillic0900AccentInsensitiveCaseInsensitive:
			case CharacterSet.Utf8Mb4MongolianCyrillic0900AccentSensitiveCaseSensitive:
				goto IL_083e;
			case (CharacterSet)17:
			case (CharacterSet)100:
			case (CharacterSet)125:
			case (CharacterSet)126:
			case (CharacterSet)127:
			case (CharacterSet)152:
			case (CharacterSet)153:
			case (CharacterSet)154:
			case (CharacterSet)155:
			case (CharacterSet)156:
			case (CharacterSet)157:
			case (CharacterSet)158:
			case (CharacterSet)184:
			case (CharacterSet)185:
			case (CharacterSet)186:
			case (CharacterSet)187:
			case (CharacterSet)188:
			case (CharacterSet)189:
			case (CharacterSet)190:
			case (CharacterSet)191:
			case (CharacterSet)216:
			case (CharacterSet)217:
			case (CharacterSet)218:
			case (CharacterSet)219:
			case (CharacterSet)220:
			case (CharacterSet)221:
			case (CharacterSet)222:
			case (CharacterSet)251:
			case (CharacterSet)252:
			case (CharacterSet)253:
			case (CharacterSet)254:
			case (CharacterSet)272:
			case (CharacterSet)276:
			case (CharacterSet)295:
			case (CharacterSet)299:
			case (CharacterSet)301:
			case (CharacterSet)302:
				goto IL_0840;
			}
		}
		else
		{
			switch (characterSet)
			{
			case CharacterSet.Dec8SwedishNoPadCaseInsensitive:
			case CharacterSet.Cp850GeneralNoPadCaseInsensitive:
			case CharacterSet.Hp8EnglishNoPadCaseInsensitive:
			case CharacterSet.Koi8rGeneralNoPadCaseInsensitive:
			case CharacterSet.Latin1SwedishNoPadCaseInsensitive:
			case CharacterSet.Latin2GeneralNoPadCaseInsensitive:
			case CharacterSet.Swe7SwedishNoPadCaseInsensitive:
			case CharacterSet.AsciiGeneralNoPadCaseInsensitive:
			case CharacterSet.HebrewGeneralNoPadCaseInsensitive:
			case CharacterSet.Tis620ThaiNoPadCaseInsensitive:
			case CharacterSet.Koi8uGeneralNoPadCaseInsensitive:
			case CharacterSet.GreekGeneralNoPadCaseInsensitive:
			case CharacterSet.Cp1250GeneralNoPadCaseInsensitive:
			case CharacterSet.Latin5TurkishNoPadCaseInsensitive:
			case CharacterSet.Armscii8GeneralNoPadCaseInsensitive:
			case CharacterSet.Cp866GeneralNoPadCaseInsensitive:
			case CharacterSet.Keybcs2GeneralNoPadCaseInsensitive:
			case CharacterSet.MacCentralEuropeanGeneralNoPadCaseInsensitive:
			case CharacterSet.MacRomanGeneralNoPadCaseInsensitive:
			case CharacterSet.Cp852GeneralNoPadCaseInsensitive:
			case CharacterSet.Latin7GeneralNoPadCaseInsensitive:
			case CharacterSet.MacCentralEuropeanNoPadBinary:
			case CharacterSet.Latin1NoPadBinary:
			case CharacterSet.Cp1251NoPadBinary:
			case CharacterSet.Cp1251GeneralNoPadCaseInsensitive:
			case CharacterSet.MacRomanNoPadBinary:
			case CharacterSet.Cp1256GeneralNoPadCaseInsensitive:
			case CharacterSet.Cp1257NoPadBinary:
			case CharacterSet.Cp1257GeneralNoPadCaseInsensitive:
			case CharacterSet.Armscii8NoPadBinary:
			case CharacterSet.AsciiNoPadBinary:
			case CharacterSet.Cp1250NoPadBinary:
			case CharacterSet.Cp1256NoPadBinary:
			case CharacterSet.Cp866NoPadBinary:
			case CharacterSet.Dec8NoPadBinary:
			case CharacterSet.GreekNoPadBinary:
			case CharacterSet.HebrewNoPadBinary:
			case CharacterSet.Hp8NoPadBinary:
			case CharacterSet.Keybcs2NoPadBinary:
			case CharacterSet.Koi8rNoPadBinary:
			case CharacterSet.Koi8uNoPadBinary:
			case CharacterSet.Latin2NoPadBinary:
			case CharacterSet.Latin5NoPadBinary:
			case CharacterSet.Latin7NoPadBinary:
			case CharacterSet.Cp850NoPadBinary:
			case CharacterSet.Cp852NoPadBinary:
			case CharacterSet.Swe7NoPadBinary:
			case CharacterSet.Tis620NoPadBinary:
			case CharacterSet.Geostd8GeneralNoPadCaseInsensitive:
			case CharacterSet.Geostd8NoPadBinary:
				break;
			case CharacterSet.Big5ChineseNoPadCaseInsensitive:
			case CharacterSet.SjisJapaneseNoPadCaseInsensitive:
			case CharacterSet.EuckrKoreanNoPadCaseInsensitive:
			case CharacterSet.Gb2312ChineseNoPadCaseInsensitive:
			case CharacterSet.GbkChineseNoPadCaseInsensitive:
			case CharacterSet.Ucs2GeneralNoPadCaseInsensitive:
			case CharacterSet.Big5NoPadBinary:
			case CharacterSet.EuckrNoPadBinary:
			case CharacterSet.Gb2312NoPadBinary:
			case CharacterSet.GbkNoPadBinary:
			case CharacterSet.SjisNoPadBinary:
			case CharacterSet.Ucs2NoPadBinary:
			case CharacterSet.Cp932JapaneseNoPadCaseInsensitive:
			case CharacterSet.Cp932NoPadBinary:
			case CharacterSet.Ucs2UnicodeNoPadCaseInsensitive:
			case CharacterSet.Ucs2Unicode520NoPadCaseInsensitive:
				goto IL_083a;
			case CharacterSet.UjisJapaneseNoPadCaseInsensitive:
			case CharacterSet.Utf8Mb3GeneralNoPadCaseInsensitive:
			case CharacterSet.Utf8Mb3NoPadBinary:
			case CharacterSet.UjisNoPadBinary:
			case CharacterSet.EucjpmsJapaneseNoPadCaseInsensitive:
			case CharacterSet.EucjpmsNoPadBinary:
			case CharacterSet.Utf8Mb3UnicodeNoPadCaseInsensitive:
			case CharacterSet.Utf8Mb3Unicode520NoPadCaseInsensitive:
				goto IL_083c;
			case CharacterSet.Utf8Mb4GeneralNoPadCaseInsensitive:
			case CharacterSet.Utf8Mb4NoPadBinary:
			case CharacterSet.Utf16GeneralNoPadCaseInsensitive:
			case CharacterSet.Utf16NoPadBinary:
			case CharacterSet.Utf16leGeneralNoPadCaseInsensitive:
			case CharacterSet.Utf32GeneralNoPadCaseInsensitive:
			case CharacterSet.Utf32NoPadBinary:
			case CharacterSet.Utf16leNoPadBinary:
			case CharacterSet.Utf16UnicodeNoPadCaseInsensitive:
			case CharacterSet.Utf16Unicode520NoPadCaseInsensitive:
			case CharacterSet.Utf32UnicodeNoPadCaseInsensitive:
			case CharacterSet.Utf32Unicode520NoPadCaseInsensitive:
			case CharacterSet.Utf8Mb4UnicodeNoPadCaseInsensitive:
			case CharacterSet.Utf8Mb4Unicode520NoPadCaseInsensitive:
				goto IL_083e;
			default:
				goto IL_0840;
			}
		}
		return 1;
		IL_083e:
		return 4;
		IL_083a:
		return 2;
		IL_0840:
		throw new NotSupportedException($"Maximum byte length of character set {characterSet} is unknown.");
		IL_083c:
		return 3;
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	public static async ValueTask<ArraySegment<byte>> ReadPayloadAsync(BufferedByteReader bufferedByteReader, IByteHandler byteHandler, Func<int> getNextSequenceNumber, ArraySegmentHolder<byte> previousPayloads, ProtocolErrorBehavior protocolErrorBehavior, IOBehavior ioBehavior)
	{
		previousPayloads.Clear();
		Packet packet;
		do
		{
			ArraySegment<byte> segment = await bufferedByteReader.ReadBytesAsync(byteHandler, 4, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
			if (segment.Count < 4)
			{
				if (protocolErrorBehavior != ProtocolErrorBehavior.Ignore)
				{
					throw new MySqlEndOfStreamException(4, segment.Count);
				}
				return default(ArraySegment<byte>);
			}
			int payloadLength = (int)SerializationUtility.ReadUInt32(MemoryExtensions.AsSpan(segment).Slice(0, 3));
			int packetSequenceNumber = MemoryExtensions.AsSpan(segment)[3];
			int expectedSequenceNumber = getNextSequenceNumber() % 256;
			ArraySegment<byte> arraySegment = await bufferedByteReader.ReadBytesAsync(byteHandler, payloadLength, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
			if (expectedSequenceNumber != -1 && packetSequenceNumber != expectedSequenceNumber)
			{
				if (protocolErrorBehavior == ProtocolErrorBehavior.Ignore)
				{
					packet = default(Packet);
				}
				else
				{
					if (arraySegment.Count <= 0 || MemoryExtensions.AsSpan(arraySegment)[0] != byte.MaxValue)
					{
						throw MySqlProtocolException.CreateForPacketOutOfOrder(expectedSequenceNumber, packetSequenceNumber);
					}
					packet = new Packet(arraySegment);
				}
			}
			else
			{
				Packet obj;
				if (arraySegment.Count < payloadLength)
				{
					if (protocolErrorBehavior == ProtocolErrorBehavior.Throw)
					{
						throw new MySqlEndOfStreamException(payloadLength, arraySegment.Count);
					}
					obj = default(Packet);
				}
				else
				{
					obj = new Packet(arraySegment);
				}
				packet = obj;
			}
			if (previousPayloads.Count == 0 && packet.Contents.Count < 16777215)
			{
				return packet.Contents;
			}
			byte[] array = previousPayloads.Array;
			if (array == null)
			{
				array = new byte[16777216];
			}
			else if (previousPayloads.Offset + previousPayloads.Count + packet.Contents.Count > array.Length)
			{
				Array.Resize(ref array, array.Length * 2);
			}
			MemoryExtensions.AsSpan(packet.Contents).CopyTo(MemoryExtensions.AsSpan(array, previousPayloads.Offset + previousPayloads.Count));
			previousPayloads.ArraySegment = new ArraySegment<byte>(array, previousPayloads.Offset, previousPayloads.Count + packet.Contents.Count);
		}
		while (packet.Contents.Count >= 16777215);
		return previousPayloads.ArraySegment;
	}

	public static async ValueTask WritePayloadAsync(IByteHandler byteHandler, Func<int> getNextSequenceNumber, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlyMemory<byte> payload, IOBehavior ioBehavior)
	{
		byte[] buffer = ArrayPool<byte>.Shared.Rent(Math.Min(16777215, payload.Length) + 4);
		try
		{
			int bytesSent = 0;
			do
			{
				ReadOnlyMemory<byte> contents = payload.Slice(bytesSent, Math.Min(16777215, payload.Length - bytesSent));
				int count = contents.Length + 4;
				SerializationUtility.WriteUInt32((uint)contents.Length, buffer, 0, 3);
				buffer[3] = (byte)getNextSequenceNumber();
				contents.CopyTo(MemoryExtensions.AsMemory(buffer, 4));
				await byteHandler.WriteBytesAsync(new ArraySegment<byte>(buffer, 0, count), ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
				bytesSent += contents.Length;
			}
			while (bytesSent < payload.Length);
		}
		finally
		{
			ArrayPool<byte>.Shared.Return(buffer);
		}
	}
}


using System;
using System.Runtime.CompilerServices;

internal static class SerializationUtility
{
	public static uint ReadUInt32(ReadOnlySpan<byte> span)
	{
		uint num = 0u;
		for (int i = 0; i < span.Length; i++)
		{
			num |= (uint)(span[i] << 8 * i);
		}
		return num;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static void WriteUInt32(uint value, byte[] buffer, int offset, int count)
	{
		for (int i = 0; i < count; i++)
		{
			buffer[offset + i] = (byte)(value & 0xFF);
			value >>= 8;
		}
	}
}


using System;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using MySqlConnector;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

internal sealed class SocketByteHandler : IByteHandler, IDisposable
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private readonly Socket m_socket;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private readonly SocketAwaitable m_socketAwaitable;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private readonly Action m_closeSocket;

	public int RemainingTimeout { get; set; }

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public SocketByteHandler(Socket socket)
	{
		m_socket = socket;
		m_socketAwaitable = new SocketAwaitable(new SocketAsyncEventArgs());
		m_closeSocket = socket.Dispose;
		RemainingTimeout = int.MaxValue;
	}

	public void Dispose()
	{
		m_socketAwaitable.EventArgs.Dispose();
	}

	public ValueTask<int> ReadBytesAsync(Memory<byte> buffer, IOBehavior ioBehavior)
	{
		if (ioBehavior != IOBehavior.Asynchronous)
		{
			return DoReadBytesSync(buffer);
		}
		return DoReadBytesAsync(buffer);
	}

	private ValueTask<int> DoReadBytesSync(Memory<byte> buffer)
	{
		MemoryMarshal.TryGetArray((ReadOnlyMemory<byte>)buffer, out ArraySegment<byte> segment);
		try
		{
			if (RemainingTimeout == int.MaxValue)
			{
				return new ValueTask<int>(m_socket.Receive(segment.Array, segment.Offset, segment.Count, SocketFlags.None));
			}
			while (RemainingTimeout > 0)
			{
				int tickCount = Environment.TickCount;
				if (m_socket.Poll(Math.Min(2147483, RemainingTimeout) * 1000, SelectMode.SelectRead))
				{
					int result = m_socket.Receive(segment.Array, segment.Offset, segment.Count, SocketFlags.None);
					RemainingTimeout -= Environment.TickCount - tickCount;
					return new ValueTask<int>(result);
				}
				RemainingTimeout -= Environment.TickCount - tickCount;
			}
			return ValueTaskExtensions.FromException<int>(MySqlException.CreateForTimeout());
		}
		catch (Exception exception)
		{
			return ValueTaskExtensions.FromException<int>(exception);
		}
	}

	private async ValueTask<int> DoReadBytesAsync(Memory<byte> buffer)
	{
		int startTime = ((RemainingTimeout != int.MaxValue) ? Environment.TickCount : 0);
		int remainingTimeout = RemainingTimeout;
		if (remainingTimeout <= 0)
		{
			throw MySqlException.CreateForTimeout();
		}
		uint num = ((remainingTimeout != int.MaxValue) ? TimerQueue.Instance.Add(RemainingTimeout, m_closeSocket) : 0u);
		uint timerId = num;
		m_socketAwaitable.EventArgs.SetBuffer(buffer);
		int bytesTransferred;
		try
		{
			await m_socket.ReceiveAsync(m_socketAwaitable);
			bytesTransferred = m_socketAwaitable.EventArgs.BytesTransferred;
		}
		catch (SocketException innerException)
		{
			if (RemainingTimeout != int.MaxValue)
			{
				RemainingTimeout -= Environment.TickCount - startTime;
				if (!TimerQueue.Instance.Remove(timerId))
				{
					throw MySqlException.CreateForTimeout(innerException);
				}
			}
			throw;
		}
		if (RemainingTimeout != int.MaxValue)
		{
			RemainingTimeout -= Environment.TickCount - startTime;
			if (!TimerQueue.Instance.Remove(timerId))
			{
				throw MySqlException.CreateForTimeout();
			}
		}
		return bytesTransferred;
	}

	public ValueTask WriteBytesAsync(ReadOnlyMemory<byte> data, IOBehavior ioBehavior)
	{
		if (ioBehavior == IOBehavior.Asynchronous)
		{
			return DoWriteBytesAsync(data);
		}
		try
		{
			m_socket.Send(data, SocketFlags.None);
			return default(ValueTask);
		}
		catch (Exception exception)
		{
			return ValueTaskExtensions.FromException(exception);
		}
	}

	private async ValueTask DoWriteBytesAsync(ReadOnlyMemory<byte> data)
	{
		m_socketAwaitable.EventArgs.SetBuffer(MemoryMarshal.AsMemory(data));
		await m_socket.SendAsync(m_socketAwaitable);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

internal sealed class StandardPayloadHandler : IPayloadHandler, IDisposable
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private readonly Func<int> m_getNextSequenceNumber;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private IByteHandler m_byteHandler;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private BufferedByteReader m_bufferedByteReader;

	private byte m_sequenceNumber;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public IByteHandler ByteHandler
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get
		{
			if (m_byteHandler == null)
			{
				throw new ObjectDisposedException("StandardPayloadHandler");
			}
			return m_byteHandler;
		}
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		set
		{
			IByteHandler byteHandler = m_byteHandler;
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			m_byteHandler = value;
			byteHandler?.Dispose();
			m_bufferedByteReader = new BufferedByteReader();
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public StandardPayloadHandler(IByteHandler byteHandler)
	{
		ByteHandler = byteHandler;
		m_getNextSequenceNumber = () => m_sequenceNumber++;
	}

	public void Dispose()
	{
		m_bufferedByteReader = null;
		Utility.Dispose(ref m_byteHandler);
	}

	public void StartNewConversation()
	{
		m_sequenceNumber = 0;
	}

	public void SetNextSequenceNumber(int sequenceNumber)
	{
		m_sequenceNumber = (byte)sequenceNumber;
	}

	public ValueTask<ArraySegment<byte>> ReadPayloadAsync([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ArraySegmentHolder<byte> cache, ProtocolErrorBehavior protocolErrorBehavior, IOBehavior ioBehavior)
	{
		return ProtocolUtility.ReadPayloadAsync(m_bufferedByteReader, m_byteHandler, m_getNextSequenceNumber, cache, protocolErrorBehavior, ioBehavior);
	}

	public ValueTask WritePayloadAsync(ReadOnlyMemory<byte> payload, IOBehavior ioBehavior)
	{
		return ProtocolUtility.WritePayloadAsync(m_byteHandler, m_getNextSequenceNumber, payload, ioBehavior);
	}
}


using System;
using System.IO;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using MySqlConnector;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

internal sealed class StreamByteHandler : IByteHandler, IDisposable
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private readonly Stream m_stream;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private readonly Action m_closeStream;

	public int RemainingTimeout { get; set; }

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public StreamByteHandler(Stream stream)
	{
		m_stream = stream;
		m_closeStream = m_stream.Dispose;
		RemainingTimeout = int.MaxValue;
	}

	public void Dispose()
	{
		m_stream.Dispose();
	}

	public ValueTask<int> ReadBytesAsync(Memory<byte> buffer, IOBehavior ioBehavior)
	{
		if (RemainingTimeout > 0)
		{
			if (ioBehavior != IOBehavior.Asynchronous)
			{
				if (!m_stream.CanTimeout)
				{
					return DoReadBytesSyncOverAsync(buffer);
				}
				return DoReadBytesSync(buffer);
			}
			return new ValueTask<int>(DoReadBytesAsync(buffer));
		}
		return ValueTaskExtensions.FromException<int>(MySqlException.CreateForTimeout());
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
		async Task<int> DoReadBytesAsync(Memory<byte> buffer)
		{
			int startTime = ((RemainingTimeout != int.MaxValue) ? Environment.TickCount : 0);
			uint timerId = ((RemainingTimeout != int.MaxValue) ? TimerQueue.Instance.Add(RemainingTimeout, m_closeStream) : 0u);
			int result;
			try
			{
				result = await m_stream.ReadAsync(buffer).ConfigureAwait(continueOnCapturedContext: false);
			}
			catch (Exception ex) when (((ex is ObjectDisposedException || ex is IOException) ? 1 : 0) != 0)
			{
				if (RemainingTimeout != int.MaxValue)
				{
					RemainingTimeout -= Environment.TickCount - startTime;
					if (!TimerQueue.Instance.Remove(timerId))
					{
						throw MySqlException.CreateForTimeout(ex);
					}
				}
				throw;
			}
			if (RemainingTimeout != int.MaxValue)
			{
				RemainingTimeout -= Environment.TickCount - startTime;
				if (!TimerQueue.Instance.Remove(timerId))
				{
					throw MySqlException.CreateForTimeout();
				}
			}
			return result;
		}
		ValueTask<int> DoReadBytesSync(Memory<byte> buffer)
		{
			m_stream.ReadTimeout = ((RemainingTimeout == int.MaxValue) ? (-1) : RemainingTimeout);
			int num = ((RemainingTimeout != int.MaxValue) ? Environment.TickCount : 0);
			int result2;
			try
			{
				result2 = m_stream.Read(buffer);
			}
			catch (Exception ex2)
			{
				return (RemainingTimeout != int.MaxValue && ex2 is IOException && ex2.InnerException is SocketException { SocketErrorCode: SocketError.TimedOut }) ? ValueTaskExtensions.FromException<int>(MySqlException.CreateForTimeout(ex2)) : ValueTaskExtensions.FromException<int>(ex2);
			}
			if (RemainingTimeout != int.MaxValue)
			{
				RemainingTimeout -= Environment.TickCount - num;
			}
			return new ValueTask<int>(result2);
		}
		ValueTask<int> DoReadBytesSyncOverAsync(Memory<byte> buffer)
		{
			try
			{
				return new ValueTask<int>(DoReadBytesAsync(buffer).GetAwaiter().GetResult());
			}
			catch (Exception exception)
			{
				return ValueTaskExtensions.FromException<int>(exception);
			}
		}
	}

	public ValueTask WriteBytesAsync(ReadOnlyMemory<byte> data, IOBehavior ioBehavior)
	{
		if (ioBehavior == IOBehavior.Asynchronous)
		{
			return DoWriteBytesAsync(data);
		}
		try
		{
			m_stream.Write(data);
			return default(ValueTask);
		}
		catch (Exception exception)
		{
			return ValueTaskExtensions.FromException(exception);
		}
		async ValueTask DoWriteBytesAsync(ReadOnlyMemory<byte> data)
		{
			await m_stream.WriteAsync(data).ConfigureAwait(continueOnCapturedContext: false);
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal readonly struct AuthenticationMethodSwitchRequestPayload
{
	public const byte Signature = 254;

	public string Name { get; }

	public byte[] Data { get; }

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public static AuthenticationMethodSwitchRequestPayload Create(ReadOnlySpan<byte> span)
	{
		ByteArrayReader byteArrayReader = new ByteArrayReader(span);
		byteArrayReader.ReadByte(254);
		string name;
		byte[] data;
		if (span.Length == 1)
		{
			name = "mysql_old_password";
			data = Array.Empty<byte>();
		}
		else
		{
			name = Encoding.UTF8.GetString(byteArrayReader.ReadNullTerminatedByteString());
			data = byteArrayReader.ReadByteString(byteArrayReader.BytesRemaining).ToArray();
		}
		return new AuthenticationMethodSwitchRequestPayload(name, data);
	}

	private AuthenticationMethodSwitchRequestPayload(string name, byte[] data)
	{
		Name = name;
		Data = data;
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal readonly struct AuthenticationMoreDataPayload
{
	public const byte Signature = 1;

	public byte[] Data { get; }

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public static AuthenticationMoreDataPayload Create(ReadOnlySpan<byte> span)
	{
		ByteArrayReader byteArrayReader = new ByteArrayReader(span);
		byteArrayReader.ReadByte(1);
		return new AuthenticationMoreDataPayload(byteArrayReader.ReadByteString(byteArrayReader.BytesRemaining).ToArray());
	}

	private AuthenticationMoreDataPayload(byte[] data)
	{
		Data = data;
	}
}


using System;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;

internal readonly struct CachingSha2ServerResponsePayload
{
	public const byte Signature = 1;

	public const byte SuccessSignature = 3;

	public const byte FullAuthRequiredSignature = 4;

	public bool Succeeded { get; }

	public bool FullAuthRequired { get; }

	private CachingSha2ServerResponsePayload(bool succeeded, bool fullAuthRequired)
	{
		Succeeded = succeeded;
		FullAuthRequired = fullAuthRequired;
	}

	public static CachingSha2ServerResponsePayload Create(ReadOnlySpan<byte> span)
	{
		ByteArrayReader byteArrayReader = new ByteArrayReader(span);
		byteArrayReader.ReadByte(1);
		byte b = byteArrayReader.ReadByte();
		return new CachingSha2ServerResponsePayload(b == 3, b == 4);
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Serialization;

internal static class ChangeUserPayload
{
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public static PayloadData Create([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] string user, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> authResponse, string schemaName, CharacterSet characterSet, byte[] connectionAttributes)
	{
		ByteBufferWriter byteBufferWriter = new ByteBufferWriter();
		byteBufferWriter.Write((byte)17);
		byteBufferWriter.WriteNullTerminatedString(user);
		byteBufferWriter.Write(checked((byte)authResponse.Length));
		byteBufferWriter.Write(authResponse);
		byteBufferWriter.WriteNullTerminatedString(schemaName ?? "");
		byteBufferWriter.Write((byte)characterSet);
		byteBufferWriter.Write((byte)0);
		byteBufferWriter.Write((ReadOnlySpan<byte>)new byte[22]
		{
			109, 121, 115, 113, 108, 95, 110, 97, 116, 105,
			118, 101, 95, 112, 97, 115, 115, 119, 111, 114,
			100, 0
		});
		if (connectionAttributes != null)
		{
			byteBufferWriter.Write((ReadOnlySpan<byte>)connectionAttributes);
		}
		return byteBufferWriter.ToPayloadData();
	}
}


using System;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;

internal readonly struct ColumnCountPayload
{
	public int ColumnCount { get; }

	public bool MetadataFollows { get; }

	private ColumnCountPayload(int columnCount, bool metadataFollows)
	{
		ColumnCount = columnCount;
		MetadataFollows = metadataFollows;
	}

	public static ColumnCountPayload Create(ReadOnlySpan<byte> span, bool supportsOptionalMetadata)
	{
		ByteArrayReader byteArrayReader = new ByteArrayReader(span);
		int columnCount = (int)byteArrayReader.ReadLengthEncodedInteger();
		bool metadataFollows = !supportsOptionalMetadata || byteArrayReader.BytesRemaining == 0 || byteArrayReader.ReadByte() == 1;
		return new ColumnCountPayload(columnCount, metadataFollows);
	}
}


using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class ColumnDefinitionPayload
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private ResizableArraySegment<byte> m_originalData;

	private bool m_readNames;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private string m_name;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private string m_schemaName;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private string m_catalogName;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private string m_table;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private string m_physicalTable;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private string m_physicalName;

	public string Name
	{
		get
		{
			if (!m_readNames)
			{
				ReadNames();
			}
			return m_name;
		}
	}

	public CharacterSet CharacterSet { get; private set; }

	public uint ColumnLength { get; private set; }

	public ColumnType ColumnType { get; private set; }

	public ColumnFlags ColumnFlags { get; private set; }

	public string SchemaName
	{
		get
		{
			if (!m_readNames)
			{
				ReadNames();
			}
			return m_schemaName;
		}
	}

	public string CatalogName
	{
		get
		{
			if (!m_readNames)
			{
				ReadNames();
			}
			return m_catalogName;
		}
	}

	public string Table
	{
		get
		{
			if (!m_readNames)
			{
				ReadNames();
			}
			return m_table;
		}
	}

	public string PhysicalTable
	{
		get
		{
			if (!m_readNames)
			{
				ReadNames();
			}
			return m_physicalTable;
		}
	}

	public string PhysicalName
	{
		get
		{
			if (!m_readNames)
			{
				ReadNames();
			}
			return m_physicalName;
		}
	}

	public byte Decimals { get; private set; }

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public static void Initialize([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ref ColumnDefinitionPayload payload, ResizableArraySegment<byte> arraySegment)
	{
		if (payload == null)
		{
			payload = new ColumnDefinitionPayload();
		}
		payload.Initialize(arraySegment);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private void Initialize(ResizableArraySegment<byte> originalData)
	{
		m_originalData = originalData;
		ByteArrayReader reader = new ByteArrayReader(originalData);
		SkipLengthEncodedByteString(ref reader);
		SkipLengthEncodedByteString(ref reader);
		SkipLengthEncodedByteString(ref reader);
		SkipLengthEncodedByteString(ref reader);
		SkipLengthEncodedByteString(ref reader);
		SkipLengthEncodedByteString(ref reader);
		reader.ReadByte(12);
		CharacterSet = (CharacterSet)reader.ReadUInt16();
		ColumnLength = reader.ReadUInt32();
		ColumnType = (ColumnType)reader.ReadByte();
		ColumnFlags = (ColumnFlags)reader.ReadUInt16();
		Decimals = reader.ReadByte();
		reader.ReadByte(0);
		reader.ReadByte(0);
		if (m_readNames)
		{
			m_catalogName = null;
			m_schemaName = null;
			m_table = null;
			m_physicalTable = null;
			m_name = null;
			m_physicalName = null;
			m_readNames = false;
		}
	}

	private static void SkipLengthEncodedByteString(ref ByteArrayReader reader)
	{
		int num = checked((int)reader.ReadLengthEncodedInteger());
		reader.Offset += num;
	}

	private ColumnDefinitionPayload()
	{
	}

	private void ReadNames()
	{
		ByteArrayReader byteArrayReader = new ByteArrayReader(m_originalData);
		m_catalogName = Encoding.UTF8.GetString(byteArrayReader.ReadLengthEncodedByteString());
		m_schemaName = Encoding.UTF8.GetString(byteArrayReader.ReadLengthEncodedByteString());
		m_table = Encoding.UTF8.GetString(byteArrayReader.ReadLengthEncodedByteString());
		m_physicalTable = Encoding.UTF8.GetString(byteArrayReader.ReadLengthEncodedByteString());
		m_name = Encoding.UTF8.GetString(byteArrayReader.ReadLengthEncodedByteString());
		m_physicalName = Encoding.UTF8.GetString(byteArrayReader.ReadLengthEncodedByteString());
		m_readNames = true;
	}
}


using System;
using MySqlConnector.Protocol;

internal static class EmptyPayload
{
	public static PayloadData Instance { get; } = new PayloadData(Array.Empty<byte>());
}


using System;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;

internal readonly struct EofPayload
{
	public const byte Signature = 254;

	public int WarningCount { get; }

	public ServerStatus ServerStatus { get; }

	public static EofPayload Create(ReadOnlySpan<byte> span)
	{
		ByteArrayReader byteArrayReader = new ByteArrayReader(span);
		byteArrayReader.ReadByte(254);
		if (span.Length > 5)
		{
			throw new FormatException("Not an EOF packet");
		}
		ushort warningCount = byteArrayReader.ReadUInt16();
		ServerStatus status = (ServerStatus)byteArrayReader.ReadUInt16();
		if (byteArrayReader.BytesRemaining != 0)
		{
			throw new FormatException("Extra bytes at end of payload.");
		}
		return new EofPayload(warningCount, status);
	}

	public static bool IsEof(PayloadData payload)
	{
		int length = payload.Span.Length;
		if (length > 0 && length < 9)
		{
			return payload.HeaderByte == 254;
		}
		return false;
	}

	private EofPayload(int warningCount, ServerStatus status)
	{
		WarningCount = warningCount;
		ServerStatus = status;
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal readonly struct ErrorPayload
{
	public const byte Signature = byte.MaxValue;

	public int ErrorCode { get; }

	public string State { get; }

	public string Message { get; }

	public MySqlException ToException()
	{
		return new MySqlException((MySqlErrorCode)ErrorCode, State, Message);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public static ErrorPayload Create(ReadOnlySpan<byte> span)
	{
		ByteArrayReader byteArrayReader = new ByteArrayReader(span);
		byteArrayReader.ReadByte(byte.MaxValue);
		ushort errorCode = byteArrayReader.ReadUInt16();
		string @string = Encoding.ASCII.GetString(byteArrayReader.ReadByteString(1));
		string state;
		string message;
		if (@string == "#")
		{
			state = Encoding.ASCII.GetString(byteArrayReader.ReadByteString(5));
			message = Encoding.UTF8.GetString(byteArrayReader.ReadByteString(span.Length - 9));
		}
		else
		{
			state = "HY000";
			message = @string + Encoding.UTF8.GetString(byteArrayReader.ReadByteString(span.Length - 4));
		}
		return new ErrorPayload(errorCode, state, message);
	}

	private ErrorPayload(int errorCode, string state, string message)
	{
		ErrorCode = errorCode;
		State = state;
		Message = message;
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.Core;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal static class HandshakeResponse41Payload
{
	private static ByteBufferWriter CreateCapabilitiesPayload(ProtocolCapabilities serverCapabilities, ConnectionSettings cs, bool useCompression, CharacterSet characterSet, ProtocolCapabilities additionalCapabilities = ProtocolCapabilities.None)
	{
		ByteBufferWriter byteBufferWriter = new ByteBufferWriter();
		ProtocolCapabilities protocolCapabilities = (ProtocolCapabilities)((ulong)(ProtocolCapabilities.Protocol41 | (cs.InteractiveSession ? (serverCapabilities & ProtocolCapabilities.Interactive) : ProtocolCapabilities.None) | (serverCapabilities & ProtocolCapabilities.LongPassword) | (serverCapabilities & ProtocolCapabilities.Transactions) | ProtocolCapabilities.SecureConnection | (serverCapabilities & ProtocolCapabilities.PluginAuth) | (serverCapabilities & ProtocolCapabilities.PluginAuthLengthEncodedClientData) | ProtocolCapabilities.MultiStatements | ProtocolCapabilities.MultiResults) | (ulong)(cs.AllowLoadLocalInfile ? 128 : 0) | (ulong)(string.IsNullOrWhiteSpace(cs.Database) ? 0 : 8) | (ulong)(cs.UseAffectedRows ? 0 : 2) | (ulong)(useCompression ? 32 : 0) | (ulong)(serverCapabilities & ProtocolCapabilities.ConnectionAttributes) | (ulong)(serverCapabilities & ProtocolCapabilities.SessionTrack) | (ulong)(serverCapabilities & ProtocolCapabilities.DeprecateEof) | (ulong)(serverCapabilities & ProtocolCapabilities.QueryAttributes) | (ulong)(serverCapabilities & ProtocolCapabilities.MariaDbCacheMetadata) | (ulong)additionalCapabilities);
		byteBufferWriter.Write((int)protocolCapabilities);
		byteBufferWriter.Write(1073741824);
		byteBufferWriter.Write((byte)characterSet);
		ReadOnlySpan<byte> span = new byte[19]
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0
		};
		byteBufferWriter.Write(span);
		if ((serverCapabilities & ProtocolCapabilities.LongPassword) == ProtocolCapabilities.None)
		{
			byteBufferWriter.Write((int)((ulong)protocolCapabilities >> 32));
		}
		else
		{
			byteBufferWriter.Write(0u);
		}
		return byteBufferWriter;
	}

	public static PayloadData CreateWithSsl(ProtocolCapabilities serverCapabilities, ConnectionSettings cs, bool useCompression, CharacterSet characterSet)
	{
		return CreateCapabilitiesPayload(serverCapabilities, cs, useCompression, characterSet, ProtocolCapabilities.Ssl).ToPayloadData();
	}

	public static PayloadData Create(InitialHandshakePayload handshake, ConnectionSettings cs, string password, bool useCompression, CharacterSet characterSet, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] byte[] connectionAttributes)
	{
		ByteBufferWriter byteBufferWriter = CreateCapabilitiesPayload(handshake.ProtocolCapabilities, cs, useCompression, characterSet, ProtocolCapabilities.None);
		byteBufferWriter.WriteNullTerminatedString(cs.UserID);
		byte[] array = AuthenticationUtility.CreateAuthenticationResponse(handshake.AuthPluginData, password);
		byteBufferWriter.Write((byte)array.Length);
		byteBufferWriter.Write((ReadOnlySpan<byte>)array);
		if (!string.IsNullOrWhiteSpace(cs.Database))
		{
			byteBufferWriter.WriteNullTerminatedString(cs.Database);
		}
		if ((handshake.ProtocolCapabilities & ProtocolCapabilities.PluginAuth) != ProtocolCapabilities.None)
		{
			byteBufferWriter.Write((ReadOnlySpan<byte>)new byte[22]
			{
				109, 121, 115, 113, 108, 95, 110, 97, 116, 105,
				118, 101, 95, 112, 97, 115, 115, 119, 111, 114,
				100, 0
			});
		}
		if (connectionAttributes != null)
		{
			byteBufferWriter.Write((ReadOnlySpan<byte>)connectionAttributes);
		}
		return byteBufferWriter.ToPayloadData();
	}
}


using System.Runtime.CompilerServices;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Serialization;

internal static class InitDatabasePayload
{
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static PayloadData Create(string databaseName)
	{
		ByteBufferWriter byteBufferWriter = new ByteBufferWriter();
		byteBufferWriter.Write((byte)2);
		byteBufferWriter.Write(databaseName);
		return byteBufferWriter.ToPayloadData();
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class InitialHandshakePayload
{
	private const byte c_protocolVersion = 10;

	public ProtocolCapabilities ProtocolCapabilities { get; }

	public byte[] ServerVersion { get; }

	public int ConnectionId { get; }

	public byte[] AuthPluginData { get; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public string AuthPluginName
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public static InitialHandshakePayload Create(ReadOnlySpan<byte> span)
	{
		ByteArrayReader byteArrayReader = new ByteArrayReader(span);
		byteArrayReader.ReadByte(10);
		ReadOnlySpan<byte> readOnlySpan = byteArrayReader.ReadNullTerminatedByteString();
		int connectionId = byteArrayReader.ReadInt32();
		byte[] array = null;
		ReadOnlySpan<byte> readOnlySpan2 = byteArrayReader.ReadByteString(8);
		string authPluginName = null;
		byteArrayReader.ReadByte(0);
		ProtocolCapabilities protocolCapabilities = (ProtocolCapabilities)byteArrayReader.ReadUInt16();
		if (byteArrayReader.BytesRemaining > 0)
		{
			byteArrayReader.ReadByte();
			_ = (ushort)byteArrayReader.ReadInt16();
			ushort num = byteArrayReader.ReadUInt16();
			protocolCapabilities = (ProtocolCapabilities)((ulong)protocolCapabilities | ((ulong)num << 16));
			byte b = byteArrayReader.ReadByte();
			byteArrayReader.Offset += 6;
			long num2 = byteArrayReader.ReadInt32();
			if ((protocolCapabilities & ProtocolCapabilities.LongPassword) == ProtocolCapabilities.None)
			{
				protocolCapabilities = (ProtocolCapabilities)((ulong)protocolCapabilities | (ulong)(num2 << 32));
			}
			if ((protocolCapabilities & ProtocolCapabilities.SecureConnection) != ProtocolCapabilities.None)
			{
				ReadOnlySpan<byte> readOnlySpan3 = byteArrayReader.ReadByteString(Math.Max(13, b - 8));
				array = new byte[readOnlySpan2.Length + readOnlySpan3.Length];
				readOnlySpan2.CopyTo(array);
				readOnlySpan3.CopyTo(MemoryExtensions.AsSpan(array, readOnlySpan2.Length));
			}
			if ((protocolCapabilities & ProtocolCapabilities.PluginAuth) != ProtocolCapabilities.None)
			{
				authPluginName = Encoding.UTF8.GetString(byteArrayReader.ReadNullOrEofTerminatedByteString());
			}
		}
		if (array == null)
		{
			array = readOnlySpan2.ToArray();
		}
		if (byteArrayReader.BytesRemaining != 0)
		{
			throw new FormatException("Extra bytes at end of payload.");
		}
		return new InitialHandshakePayload(protocolCapabilities, readOnlySpan.ToArray(), connectionId, array, authPluginName);
	}

	private InitialHandshakePayload(ProtocolCapabilities protocolCapabilities, byte[] serverVersion, int connectionId, byte[] authPluginData, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string authPluginName)
	{
		ProtocolCapabilities = protocolCapabilities;
		ServerVersion = serverVersion;
		ConnectionId = connectionId;
		AuthPluginData = authPluginData;
		AuthPluginName = authPluginName;
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal readonly struct LocalInfilePayload
{
	public const byte Signature = 251;

	public string FileName { get; }

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public static LocalInfilePayload Create(ReadOnlySpan<byte> span)
	{
		ByteArrayReader byteArrayReader = new ByteArrayReader(span);
		byteArrayReader.ReadByte(251);
		return new LocalInfilePayload(Encoding.UTF8.GetString(byteArrayReader.ReadByteString(byteArrayReader.BytesRemaining)));
	}

	private LocalInfilePayload(string fileName)
	{
		FileName = fileName;
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
internal sealed class OkPayload
{
	public const byte Signature = 0;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private static readonly OkPayload s_autoCommitOk = new OkPayload(0uL, 0uL, ServerStatus.AutoCommit, 0, null, null);

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private static readonly OkPayload s_autoCommitSessionStateChangedOk = new OkPayload(0uL, 0uL, ServerStatus.AutoCommit | ServerStatus.SessionStateChanged, 0, null, null);

	public ulong AffectedRowCount { get; }

	public ulong LastInsertId { get; }

	public ServerStatus ServerStatus { get; }

	public int WarningCount { get; }

	public string StatusInfo { get; }

	public string NewSchema { get; }

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public static bool IsOk(ReadOnlySpan<byte> span, bool deprecateEof)
	{
		if (span.Length > 0)
		{
			if (span.Length <= 6 || span[0] != 0)
			{
				if (deprecateEof && span.Length < 16777215)
				{
					return span[0] == 254;
				}
				return false;
			}
			return true;
		}
		return false;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public static OkPayload Create(ReadOnlySpan<byte> span, bool deprecateEof, bool clientSessionTrack)
	{
		return Read(span, deprecateEof, clientSessionTrack, createPayload: true);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public static void Verify(ReadOnlySpan<byte> span, bool deprecateEof, bool clientSessionTrack)
	{
		Read(span, deprecateEof, clientSessionTrack, createPayload: false);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private static OkPayload Read(ReadOnlySpan<byte> span, bool deprecateEof, bool clientSessionTrack, bool createPayload)
	{
		ByteArrayReader byteArrayReader = new ByteArrayReader(span);
		byte b = byteArrayReader.ReadByte();
		if (b != 0 && (!deprecateEof || b != 254))
		{
			throw new FormatException($"Expected to read 0x00 or 0xFE but got 0x{b:X2}");
		}
		ulong num = byteArrayReader.ReadLengthEncodedInteger();
		ulong num2 = byteArrayReader.ReadLengthEncodedInteger();
		ServerStatus serverStatus = (ServerStatus)byteArrayReader.ReadUInt16();
		int num3 = byteArrayReader.ReadUInt16();
		string text = null;
		ReadOnlySpan<byte> span2;
		if (clientSessionTrack)
		{
			if (byteArrayReader.BytesRemaining > 0)
			{
				span2 = byteArrayReader.ReadLengthEncodedByteString();
				if ((serverStatus & ServerStatus.SessionStateChanged) == ServerStatus.SessionStateChanged && byteArrayReader.BytesRemaining > 0)
				{
					int num4 = checked((int)byteArrayReader.ReadLengthEncodedInteger());
					int num5 = byteArrayReader.Offset + num4;
					while (byteArrayReader.Offset < num5)
					{
						byte num6 = byteArrayReader.ReadByte();
						int num7 = (int)byteArrayReader.ReadLengthEncodedInteger();
						if (num6 == 1)
						{
							text = Encoding.UTF8.GetString(byteArrayReader.ReadLengthEncodedByteString());
						}
						else
						{
							byteArrayReader.Offset += num7;
						}
					}
				}
			}
			else
			{
				span2 = default(ReadOnlySpan<byte>);
			}
		}
		else
		{
			span2 = byteArrayReader.ReadByteString(byteArrayReader.BytesRemaining);
			if (span2.Length != 0 && span2[0] == span2.Length - 1)
			{
				span2 = span2.Slice(1, span2.Length - 1);
			}
		}
		if (createPayload)
		{
			string text2 = ((span2.Length == 0) ? null : Encoding.UTF8.GetString(span2));
			if (num == 0L && num2 == 0L && num3 == 0 && text2 == null && text == null)
			{
				switch (serverStatus)
				{
				case ServerStatus.AutoCommit:
					return s_autoCommitOk;
				case ServerStatus.AutoCommit | ServerStatus.SessionStateChanged:
					return s_autoCommitSessionStateChangedOk;
				}
			}
			return new OkPayload(num, num2, serverStatus, num3, text2, text);
		}
		return null;
	}

	private OkPayload(ulong affectedRowCount, ulong lastInsertId, ServerStatus serverStatus, int warningCount, string statusInfo, string newSchema)
	{
		AffectedRowCount = affectedRowCount;
		LastInsertId = lastInsertId;
		ServerStatus = serverStatus;
		WarningCount = warningCount;
		StatusInfo = statusInfo;
		NewSchema = newSchema;
	}
}


using MySqlConnector.Protocol;

internal static class PingPayload
{
	public static PayloadData Instance { get; } = new PayloadData(new byte[1] { 14 });
}


using System;
using MySqlConnector.Protocol;

internal static class QueryPayload
{
	public static PayloadData Create(bool supportsQueryAttributes, ReadOnlySpan<byte> query)
	{
		byte[] array = new byte[query.Length + 1 + (supportsQueryAttributes ? 2 : 0)];
		array[0] = 3;
		if (supportsQueryAttributes)
		{
			array[2] = 1;
		}
		query.CopyTo(MemoryExtensions.AsSpan(array, (!supportsQueryAttributes) ? 1 : 3));
		return new PayloadData(array);
	}
}


using MySqlConnector.Protocol;

internal static class QuitPayload
{
	public static PayloadData Instance { get; } = new PayloadData(new byte[1] { 1 });
}


using MySqlConnector.Protocol;

internal static class ResetConnectionPayload
{
	public static PayloadData Instance { get; } = new PayloadData(new byte[1] { 31 });
}


using System;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;

internal readonly struct StatementPrepareResponsePayload
{
	public int StatementId { get; }

	public int ColumnCount { get; }

	public int ParameterCount { get; }

	public static StatementPrepareResponsePayload Create(ReadOnlySpan<byte> span)
	{
		ByteArrayReader byteArrayReader = new ByteArrayReader(span);
		byteArrayReader.ReadByte(0);
		int statementId = byteArrayReader.ReadInt32();
		int columnCount = byteArrayReader.ReadUInt16();
		int parameterCount = byteArrayReader.ReadUInt16();
		byteArrayReader.ReadByte(0);
		byteArrayReader.ReadInt16();
		return new StatementPrepareResponsePayload(statementId, columnCount, parameterCount);
	}

	private StatementPrepareResponsePayload(int statementId, int columnCount, int parameterCount)
	{
		StatementId = statementId;
		ColumnCount = columnCount;
		ParameterCount = parameterCount;
	}
}


using System;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.Logging;

public class ConsoleLoggerProvider : IMySqlConnectorLoggerProvider
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	private sealed class ConsoleLogger(ConsoleLoggerProvider provider, string name) : IMySqlConnectorLogger
	{
		private static readonly string[] s_levels = new string[7] { "", "[TRACE]", "[DEBUG]", "[INFO]", "[WARN]", "[ERROR]", "[FATAL]" };

		private static readonly ConsoleColor[] s_colors = new ConsoleColor[7]
		{
			ConsoleColor.Black,
			ConsoleColor.DarkGray,
			ConsoleColor.Gray,
			ConsoleColor.White,
			ConsoleColor.Yellow,
			ConsoleColor.Red,
			ConsoleColor.Red
		};

		private ConsoleLoggerProvider Provider { get; } = provider;

		private string Name { get; } = name;

		public bool IsEnabled(MySqlConnectorLogLevel level)
		{
			if (level >= Provider.m_minimumLevel)
			{
				return level <= MySqlConnectorLogLevel.Fatal;
			}
			return false;
		}

		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		public void Log(MySqlConnectorLogLevel level, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] string message, object[] args = null, Exception exception = null)
		{
			if (!IsEnabled(level))
			{
				return;
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(s_levels[(int)level]);
			stringBuilder.Append('\t');
			stringBuilder.Append(Name);
			stringBuilder.Append('\t');
			if (args == null || args.Length == 0)
			{
				stringBuilder.Append(message);
			}
			else
			{
				stringBuilder.AppendFormat(CultureInfo.InvariantCulture, message, args);
			}
			stringBuilder.AppendLine();
			if (exception != null)
			{
				stringBuilder.AppendLine(exception.ToString());
			}
			if (Provider.m_isColored)
			{
				lock (Provider)
				{
					ConsoleColor foregroundColor = Console.ForegroundColor;
					Console.ForegroundColor = s_colors[(int)level];
					Console.Error.Write(stringBuilder.ToString());
					Console.ForegroundColor = foregroundColor;
					return;
				}
			}
			Console.Error.Write(stringBuilder.ToString());
		}
	}

	private readonly MySqlConnectorLogLevel m_minimumLevel;

	private readonly bool m_isColored;

	public ConsoleLoggerProvider(MySqlConnectorLogLevel minimumLevel = MySqlConnectorLogLevel.Info, bool isColored = true)
	{
		if ((minimumLevel < MySqlConnectorLogLevel.Trace || minimumLevel > MySqlConnectorLogLevel.Fatal) ? true : false)
		{
			throw new ArgumentOutOfRangeException("minimumLevel", "minimumLevel must be between Trace and Fatal");
		}
		m_minimumLevel = minimumLevel;
		m_isColored = isColored;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public IMySqlConnectorLogger CreateLogger(string name)
	{
		return new ConsoleLogger(this, name);
	}
}


using System;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
private sealed class ConsoleLogger(ConsoleLoggerProvider provider, string name) : IMySqlConnectorLogger
{
	private static readonly string[] s_levels = new string[7] { "", "[TRACE]", "[DEBUG]", "[INFO]", "[WARN]", "[ERROR]", "[FATAL]" };

	private static readonly ConsoleColor[] s_colors = new ConsoleColor[7]
	{
		ConsoleColor.Black,
		ConsoleColor.DarkGray,
		ConsoleColor.Gray,
		ConsoleColor.White,
		ConsoleColor.Yellow,
		ConsoleColor.Red,
		ConsoleColor.Red
	};

	private ConsoleLoggerProvider Provider { get; } = provider;

	private string Name { get; } = name;

	public bool IsEnabled(MySqlConnectorLogLevel level)
	{
		if (level >= Provider.m_minimumLevel)
		{
			return level <= MySqlConnectorLogLevel.Fatal;
		}
		return false;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public void Log(MySqlConnectorLogLevel level, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] string message, object[] args = null, Exception exception = null)
	{
		if (!IsEnabled(level))
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append(s_levels[(int)level]);
		stringBuilder.Append('\t');
		stringBuilder.Append(Name);
		stringBuilder.Append('\t');
		if (args == null || args.Length == 0)
		{
			stringBuilder.Append(message);
		}
		else
		{
			stringBuilder.AppendFormat(CultureInfo.InvariantCulture, message, args);
		}
		stringBuilder.AppendLine();
		if (exception != null)
		{
			stringBuilder.AppendLine(exception.ToString());
		}
		if (Provider.m_isColored)
		{
			lock (Provider)
			{
				ConsoleColor foregroundColor = Console.ForegroundColor;
				Console.ForegroundColor = s_colors[(int)level];
				Console.Error.Write(stringBuilder.ToString());
				Console.ForegroundColor = foregroundColor;
				return;
			}
		}
		Console.Error.Write(stringBuilder.ToString());
	}
}


internal static class EventIds
{
	public const int DataSourceCreatedWithPoolWithName = 1000;

	public const int DataSourceCreatedWithoutPoolWithName = 1001;

	public const int DataSourceCreatedWithPoolWithoutName = 1002;

	public const int DataSourceCreatedWithoutPoolWithoutName = 1003;

	public const int PeriodicPasswordProviderFailed = 1100;

	public const int CreatedNewSession = 2000;

	public const int CreatedNonPooledSession = 2001;

	public const int ResettingConnection = 2002;

	public const int ReturningToPool = 2003;

	public const int SendingQuitCommand = 2004;

	public const int ClosingStreamSocket = 2005;

	public const int ErrorPayload = 2006;

	public const int FailedInSendReplyAsync = 2007;

	public const int FailedInReceiveReplyAsync = 2008;

	public const int SettingStateToFailed = 2009;

	public const int ExpectedToReadMoreBytes = 2010;

	public const int ExpectedSessionState1 = 2011;

	public const int ExpectedSessionState6 = 2016;

	public const int ConnectingFailed = 2100;

	public const int ServerSentAuthPluginName = 2101;

	public const int UnsupportedAuthenticationMethod = 2102;

	public const int AutoDetectedAurora57 = 2103;

	public const int SessionMadeConnection = 2104;

	public const int ServerDoesNotSupportSsl = 2105;

	public const int CouldNotConnectToServer = 2108;

	public const int SendingPipelinedResetConnectionRequest = 2109;

	public const int SendingResetConnectionRequest = 2110;

	public const int SendingChangeUserRequest = 2111;

	public const int SendingChangeUserRequestDueToChangedDatabase = 2112;

	public const int OptimisticReauthenticationFailed = 2113;

	public const int IgnoringFailureInTryResetConnectionAsync = 2114;

	public const int SwitchingToAuthenticationMethod = 2115;

	public const int NeedsSecureConnection = 2116;

	public const int AuthenticationMethodNotSupported = 2117;

	public const int CouldNotLoadServerRsaPublicKey = 2118;

	public const int CouldNotLoadServerRsaPublicKeyFromFile = 2119;

	public const int CouldNotUseAuthenticationMethodForRsa = 2120;

	public const int FailedToResolveHostName = 2121;

	public const int ConnectingToIpAddress = 2122;

	public const int ConnectTimeoutExpired = 2123;

	public const int FailedToConnectToSingleIpAddress = 2124;

	public const int FailedToConnectToIpAddress = 2125;

	public const int ConnectedToIpAddress = 2126;

	public const int ConnectingToUnixSocket = 2127;

	public const int ConnectTimeoutExpiredForUnixSocket = 2128;

	public const int ConnectingToNamedPipe = 2129;

	public const int ConnectTimeoutExpiredForNamedPipe = 2130;

	public const int InitializingTlsConnection = 2131;

	public const int NoCertificatesFound = 2132;

	public const int CertificateNotFoundInStore = 2133;

	public const int CouldNotLoadCertificate = 2134;

	public const int NoPrivateKeyIncludedWithCertificateFile = 2135;

	public const int CouldNotLoadCertificateFromFile = 2136;

	public const int FailedToObtainClientCertificates = 2137;

	public const int LoadingCaCertificatesFromFile = 2138;

	public const int CouldNotLoadCaCertificateFromFile = 2139;

	public const int LoadingCaCertificate = 2140;

	public const int LoadedCaCertificatesFromFile = 2141;

	public const int NotUsingRemoteCertificateValidationCallbackDueToSslCa = 2142;

	public const int NotUsingRemoteCertificateValidationCallbackDueToSslMode = 2143;

	public const int UsingRemoteCertificateValidationCallback = 2144;

	public const int ConnectedTlsBasic = 2145;

	public const int ConnectedTlsDetailed = 2146;

	public const int CouldNotInitializeTlsConnection = 2147;

	public const int LoadingClientKeyFromKeyFile = 2148;

	public const int CouldNotLoadClientKeyFromKeyFile = 2149;

	public const int DetectedProxy = 2150;

	public const int ChangingConnectionId = 2151;

	public const int FailedToGetConnectionId = 2152;

	public const int CreatingConnectionAttributes = 2153;

	public const int ObtainingPasswordViaProvidePasswordCallback = 2154;

	public const int FailedToObtainPassword = 2155;

	public const int CannotExecuteNewCommandInState = 2200;

	public const int EnteringFinishQuerying = 2201;

	public const int CommandExecutorExecuteReader = 2202;

	public const int QueryWasInterrupted = 2203;

	public const int PreparingCommandPayload = 2204;

	public const int PreparingCommandPayloadWithId = 2205;

	public const int QueryAttributesNotSupported = 2206;

	public const int QueryAttributesNotSupportedWithId = 2207;

	public const int IgnoringExceptionInDisposeAsync = 2208;

	public const int IgnoringCancellationForCommand = 2300;

	public const int CommandHasBeenCanceled = 2301;

	public const int IgnoringCancellationForClosedConnection = 2302;

	public const int CancelingCommandFailed = 2303;

	public const int WillCancelCommand = 2304;

	public const int CancelingCommandFromSession = 2305;

	public const int IgnoringCancellationForInactiveCommand = 2306;

	public const int CancelingCommand = 2307;

	public const int SendingSleepToClearPendingCancellation = 2308;

	public const int GettingCachedProcedure = 2400;

	public const int PoolDoesNotHaveSharedProcedureCache = 2401;

	public const int CouldNotNormalizeDatabaseAndName = 2402;

	public const int FailedToCacheProcedure = 2403;

	public const int CachingProcedure = 2404;

	public const int ProcedureCacheCount = 2405;

	public const int DidNotFindCachedProcedure = 2406;

	public const int ReturningCachedProcedure = 2407;

	public const int FailedToRetrieveProcedureMetadata = 2408;

	public const int ServerDoesNotSupportCachedProcedures = 2409;

	public const int ProcedureHasRoutineCount = 2410;

	public const int PingingServer = 2500;

	public const int SuccessfullyPingedServer = 2501;

	public const int PingFailed = 2502;

	public const int StartingBulkCopy = 2503;

	public const int AddingDefaultColumnMapping = 2504;

	public const int IgnoringColumn = 2505;

	public const int FinishedBulkCopy = 2506;

	public const int BulkCopyFailed = 2507;

	public const int ColumnMappingAlreadyHasExpression = 2508;

	public const int SettingExpressionToMapColumn = 2509;

	public const int StartingTransaction = 2700;

	public const int StartedTransaction = 2701;

	public const int CommittingTransaction = 2702;

	public const int CommittedTransaction = 2703;

	public const int RollingBackTransaction = 2704;

	public const int RolledBackTransaction = 2705;

	public const int WaitingForAvailableSession = 3000;

	public const int CreatingNewConnectionPool = 3001;

	public const int ScanningForLeakedSessions = 3002;

	public const int FoundExistingSession = 3003;

	public const int DiscardingSessionDueToWrongGeneration = 3004;

	public const int SessionIsUnusable = 3005;

	public const int ReturningPooledSession = 3006;

	public const int ReturningNewSession = 3007;

	public const int DisposingCreatedSessionDueToException = 3008;

	public const int UnexpectedErrorInGetSessionAsync = 3009;

	public const int ReceivingSessionBack = 3010;

	public const int ReceivedInvalidSession = 3011;

	public const int ReceivedExpiredSession = 3012;

	public const int ClearingConnectionPool = 3013;

	public const int DisposingConnectionPool = 3014;

	public const int RecoveredNoSessions = 3015;

	public const int RecoveredSessionCount = 3016;

	public const int FoundSessionToCleanUp = 3017;

	public const int PoolCreatedNewSession = 3018;

	public const int CreatedSessionToReachMinimumPoolCount = 3019;

	public const int CreatedPoolWillNotBeUsed = 3020;

	public const int ReapingConnectionPool = 3100;

	public const int CheckingForDnsChanges = 3101;

	public const int DetectedDnsChange = 3102;

	public const int DnsCheckFailed = 3103;

	public const int ClearingPoolDueToDnsChanges = 3104;

	public const int HasServerRedirectionHeader = 3200;

	public const int ServerRedirectionIsDisabled = 3201;

	public const int OpeningNewConnection = 3202;

	public const int FailedToConnectRedirectedSession = 3203;

	public const int ClosingSessionToUseRedirectedSession = 3204;

	public const int SessionAlreadyConnectedToServer = 3205;

	public const int RequiresServerRedirection = 3206;
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.Logging;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
public interface IMySqlConnectorLogger
{
	bool IsEnabled(MySqlConnectorLogLevel level);

	void Log(MySqlConnectorLogLevel level, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] string message, object[] args = null, Exception exception = null);
}


using System.Runtime.CompilerServices;
using MySqlConnector.Logging;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public interface IMySqlConnectorLoggerProvider
{
	IMySqlConnectorLogger CreateLogger(string name);
}


using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Security.Authentication;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using MySqlConnector.Logging;
using MySqlConnector.Protocol.Serialization;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal static class Log
{
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	private readonly struct __SessionMadeConnectionStruct : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		private readonly string _sessionId;

		private readonly string _serverVersion;

		private readonly int _connectionId;

		private readonly bool _supportsCompression;

		private readonly bool _supportsAttributes;

		private readonly bool _supportsDeprecateEof;

		private readonly bool _supportsCachedMetadata;

		private readonly bool _supportsSsl;

		private readonly bool _supportsSessionTrack;

		private readonly bool _supportsPipelining;

		private readonly bool _supportsQueryAttributes;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2, 1 })]
		public static readonly Func<__SessionMadeConnectionStruct, Exception, string> Format = (__SessionMadeConnectionStruct state, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception ex) => state.ToString();

		public int Count => 12;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
		public KeyValuePair<string, object> this[int index]
		{
			[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
			get
			{
				return index switch
				{
					0 => new KeyValuePair<string, object>("SessionId", _sessionId), 
					1 => new KeyValuePair<string, object>("ServerVersion", _serverVersion), 
					2 => new KeyValuePair<string, object>("ConnectionId", _connectionId), 
					3 => new KeyValuePair<string, object>("SupportsCompression", _supportsCompression), 
					4 => new KeyValuePair<string, object>("SupportsAttributes", _supportsAttributes), 
					5 => new KeyValuePair<string, object>("SupportsDeprecateEof", _supportsDeprecateEof), 
					6 => new KeyValuePair<string, object>("SupportsCachedMetadata", _supportsCachedMetadata), 
					7 => new KeyValuePair<string, object>("SupportsSsl", _supportsSsl), 
					8 => new KeyValuePair<string, object>("SupportsSessionTrack", _supportsSessionTrack), 
					9 => new KeyValuePair<string, object>("SupportsPipelining", _supportsPipelining), 
					10 => new KeyValuePair<string, object>("SupportsQueryAttributes", _supportsQueryAttributes), 
					11 => new KeyValuePair<string, object>("{OriginalFormat}", "Session {SessionId} made connection; server version {ServerVersion}; connection ID {ConnectionId}; supports: compression {SupportsCompression}, attributes {SupportsAttributes}, deprecate EOF {SupportsDeprecateEof}, cached metadata {SupportsCachedMetadata}, SSL {SupportsSsl}, session track {SupportsSessionTrack}, pipelining {SupportsPipelining}, query attributes {SupportsQueryAttributes}"), 
					_ => throw new IndexOutOfRangeException("index"), 
				};
			}
		}

		public __SessionMadeConnectionStruct(string sessionId, string serverVersion, int connectionId, bool supportsCompression, bool supportsAttributes, bool supportsDeprecateEof, bool supportsCachedMetadata, bool supportsSsl, bool supportsSessionTrack, bool supportsPipelining, bool supportsQueryAttributes)
		{
			_sessionId = sessionId;
			_serverVersion = serverVersion;
			_connectionId = connectionId;
			_supportsCompression = supportsCompression;
			_supportsAttributes = supportsAttributes;
			_supportsDeprecateEof = supportsDeprecateEof;
			_supportsCachedMetadata = supportsCachedMetadata;
			_supportsSsl = supportsSsl;
			_supportsSessionTrack = supportsSessionTrack;
			_supportsPipelining = supportsPipelining;
			_supportsQueryAttributes = supportsQueryAttributes;
		}

		public override string ToString()
		{
			string sessionId = _sessionId;
			string serverVersion = _serverVersion;
			int connectionId = _connectionId;
			bool supportsCompression = _supportsCompression;
			bool supportsAttributes = _supportsAttributes;
			bool supportsDeprecateEof = _supportsDeprecateEof;
			bool supportsCachedMetadata = _supportsCachedMetadata;
			bool supportsSsl = _supportsSsl;
			bool supportsSessionTrack = _supportsSessionTrack;
			bool supportsPipelining = _supportsPipelining;
			bool supportsQueryAttributes = _supportsQueryAttributes;
			return $"Session {sessionId} made connection; server version {serverVersion}; connection ID {connectionId}; supports: compression {supportsCompression}, attributes {supportsAttributes}, deprecate EOF {supportsDeprecateEof}, cached metadata {supportsCachedMetadata}, SSL {supportsSsl}, session track {supportsSessionTrack}, pipelining {supportsPipelining}, query attributes {supportsQueryAttributes}";
		}

		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			for (int i = 0; i < 12; i++)
			{
				yield return this[i];
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private readonly struct __ConnectingToIpAddressStruct : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		private readonly string _sessionId;

		private readonly string _ipAddress;

		private readonly int _ipAddressIndex;

		private readonly int _ipAddressCount;

		private readonly string _hostName;

		private readonly int _hostNameIndex;

		private readonly int _hostNameCount;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2, 1 })]
		public static readonly Func<__ConnectingToIpAddressStruct, Exception, string> Format = (__ConnectingToIpAddressStruct state, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception ex) => state.ToString();

		public int Count => 8;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
		public KeyValuePair<string, object> this[int index]
		{
			[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
			get
			{
				return index switch
				{
					0 => new KeyValuePair<string, object>("SessionId", _sessionId), 
					1 => new KeyValuePair<string, object>("IpAddress", _ipAddress), 
					2 => new KeyValuePair<string, object>("IpAddressIndex", _ipAddressIndex), 
					3 => new KeyValuePair<string, object>("IpAddressCount", _ipAddressCount), 
					4 => new KeyValuePair<string, object>("HostName", _hostName), 
					5 => new KeyValuePair<string, object>("HostNameIndex", _hostNameIndex), 
					6 => new KeyValuePair<string, object>("HostNameCount", _hostNameCount), 
					7 => new KeyValuePair<string, object>("{OriginalFormat}", "Session {SessionId} connecting to IP address {IpAddress} ({IpAddressIndex} of {IpAddressCount}) for host name {HostName} ({HostNameIndex} of {HostNameCount})"), 
					_ => throw new IndexOutOfRangeException("index"), 
				};
			}
		}

		public __ConnectingToIpAddressStruct(string sessionId, string ipAddress, int ipAddressIndex, int ipAddressCount, string hostName, int hostNameIndex, int hostNameCount)
		{
			_sessionId = sessionId;
			_ipAddress = ipAddress;
			_ipAddressIndex = ipAddressIndex;
			_ipAddressCount = ipAddressCount;
			_hostName = hostName;
			_hostNameIndex = hostNameIndex;
			_hostNameCount = hostNameCount;
		}

		public override string ToString()
		{
			string sessionId = _sessionId;
			string ipAddress = _ipAddress;
			int ipAddressIndex = _ipAddressIndex;
			int ipAddressCount = _ipAddressCount;
			string hostName = _hostName;
			int hostNameIndex = _hostNameIndex;
			int hostNameCount = _hostNameCount;
			return $"Session {sessionId} connecting to IP address {ipAddress} ({ipAddressIndex} of {ipAddressCount}) for host name {hostName} ({hostNameIndex} of {hostNameCount})";
		}

		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			for (int i = 0; i < 8; i++)
			{
				yield return this[i];
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	private readonly struct __FailedToConnectToIpAddressStruct : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		private readonly string _sessionId;

		private readonly string _ipAddress;

		private readonly int _ipAddressIndex;

		private readonly int _ipAddressCount;

		private readonly string _hostName;

		private readonly int _hostNameIndex;

		private readonly int _hostNameCount;

		private readonly string _exceptionMessage;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2, 1 })]
		public static readonly Func<__FailedToConnectToIpAddressStruct, Exception, string> Format = (__FailedToConnectToIpAddressStruct state, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception ex) => state.ToString();

		public int Count => 9;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
		public KeyValuePair<string, object> this[int index]
		{
			[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
			get
			{
				return index switch
				{
					0 => new KeyValuePair<string, object>("SessionId", _sessionId), 
					1 => new KeyValuePair<string, object>("IpAddress", _ipAddress), 
					2 => new KeyValuePair<string, object>("IpAddressIndex", _ipAddressIndex), 
					3 => new KeyValuePair<string, object>("IpAddressCount", _ipAddressCount), 
					4 => new KeyValuePair<string, object>("HostName", _hostName), 
					5 => new KeyValuePair<string, object>("HostNameIndex", _hostNameIndex), 
					6 => new KeyValuePair<string, object>("HostNameCount", _hostNameCount), 
					7 => new KeyValuePair<string, object>("ExceptionMessage", _exceptionMessage), 
					8 => new KeyValuePair<string, object>("{OriginalFormat}", "Session {SessionId} failed to connect to IP address {IpAddress} ({IpAddressIndex} of {IpAddressCount}) for host name {HostName} ({HostNameIndex} of {HostNameCount}): {ExceptionMessage}"), 
					_ => throw new IndexOutOfRangeException("index"), 
				};
			}
		}

		public __FailedToConnectToIpAddressStruct(string sessionId, string ipAddress, int ipAddressIndex, int ipAddressCount, string hostName, int hostNameIndex, int hostNameCount, string exceptionMessage)
		{
			_sessionId = sessionId;
			_ipAddress = ipAddress;
			_ipAddressIndex = ipAddressIndex;
			_ipAddressCount = ipAddressCount;
			_hostName = hostName;
			_hostNameIndex = hostNameIndex;
			_hostNameCount = hostNameCount;
			_exceptionMessage = exceptionMessage;
		}

		public override string ToString()
		{
			string sessionId = _sessionId;
			string ipAddress = _ipAddress;
			int ipAddressIndex = _ipAddressIndex;
			int ipAddressCount = _ipAddressCount;
			string hostName = _hostName;
			int hostNameIndex = _hostNameIndex;
			int hostNameCount = _hostNameCount;
			string exceptionMessage = _exceptionMessage;
			return $"Session {sessionId} failed to connect to IP address {ipAddress} ({ipAddressIndex} of {ipAddressCount}) for host name {hostName} ({hostNameIndex} of {hostNameCount}): {exceptionMessage}";
		}

		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			for (int i = 0; i < 9; i++)
			{
				yield return this[i];
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private readonly struct __CouldNotLoadCaCertificateFromFileStruct : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		private readonly string _sessionId;

		private readonly string _caCertificateFile;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2, 1 })]
		public static readonly Func<__CouldNotLoadCaCertificateFromFileStruct, Exception, string> Format = (__CouldNotLoadCaCertificateFromFileStruct state, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception ex) => state.ToString();

		public int Count => 3;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
		public KeyValuePair<string, object> this[int index]
		{
			[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
			get
			{
				return index switch
				{
					0 => new KeyValuePair<string, object>("SessionId", _sessionId), 
					1 => new KeyValuePair<string, object>("CACertificateFile", _caCertificateFile), 
					2 => new KeyValuePair<string, object>("{OriginalFormat}", "Session {SessionId} couldn't load CA certificate from '{CACertificateFile}'"), 
					_ => throw new IndexOutOfRangeException("index"), 
				};
			}
		}

		public __CouldNotLoadCaCertificateFromFileStruct(string sessionId, string caCertificateFile)
		{
			_sessionId = sessionId;
			_caCertificateFile = caCertificateFile;
		}

		public override string ToString()
		{
			string sessionId = _sessionId;
			string caCertificateFile = _caCertificateFile;
			return "Session " + sessionId + " couldn't load CA certificate from '" + caCertificateFile + "'";
		}

		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			for (int i = 0; i < 3; i++)
			{
				yield return this[i];
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private readonly struct __SuccessfullyPingedServerStruct : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		private readonly string _sessionId;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2, 1 })]
		public static readonly Func<__SuccessfullyPingedServerStruct, Exception, string> Format = (__SuccessfullyPingedServerStruct state, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception ex) => state.ToString();

		public int Count => 2;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
		public KeyValuePair<string, object> this[int index]
		{
			[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
			get
			{
				return index switch
				{
					0 => new KeyValuePair<string, object>("SessionId", _sessionId), 
					1 => new KeyValuePair<string, object>("{OriginalFormat}", "Session {SessionId} successfully pinged server"), 
					_ => throw new IndexOutOfRangeException("index"), 
				};
			}
		}

		public __SuccessfullyPingedServerStruct(string sessionId)
		{
			_sessionId = sessionId;
		}

		public override string ToString()
		{
			string sessionId = _sessionId;
			return "Session " + sessionId + " successfully pinged server";
		}

		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			for (int i = 0; i < 2; i++)
			{
				yield return this[i];
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, int, int, string, Exception> __DataSourceCreatedWithPoolWithNameCallback = LoggerMessage.Define<int, int, string>(LogLevel.Information, new EventId(1000, "DataSourceCreatedWithPoolWithName"), "Data source {DataSourceId} created with pool {PoolId} and name {DataSourceName}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, Exception> __DataSourceCreatedWithoutPoolWithNameCallback = LoggerMessage.Define<int, string>(LogLevel.Information, new EventId(1001, "DataSourceCreatedWithoutPoolWithName"), "Data source {DataSourceId} created with name {DataSourceName} and no pool", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, int, Exception> __DataSourceCreatedWithPoolWithoutNameCallback = LoggerMessage.Define<int, int>(LogLevel.Information, new EventId(1002, "DataSourceCreatedWithPoolWithoutName"), "Data source {DataSourceId} created with pool {PoolId} and no name", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	private static readonly Action<ILogger, int, Exception> __DataSourceCreatedWithoutPoolWithoutNameCallback = LoggerMessage.Define<int>(LogLevel.Information, new EventId(1003, "DataSourceCreatedWithoutPoolWithoutName"), "Data source {DataSourceId} created with no pool and no name", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, int, string, Exception> __PeriodicPasswordProviderFailedCallback = LoggerMessage.Define<int, string>(LogLevel.Error, new EventId(1100, "PeriodicPasswordProviderFailed"), "Periodic password provider for data source {DataSourceId} failed: {ExceptionMessage}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __CreatedNonPooledSessionCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2001, "CreatedNonPooledSession"), "Created new non-pooled session {SessionId}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __ResettingConnectionCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2002, "ResettingConnection"), "Session {SessionId} resetting connection", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, int, Exception> __ReturningToPoolCallback = LoggerMessage.Define<string, int>(LogLevel.Trace, new EventId(2003, "ReturningToPool"), "Session {SessionId} returning to pool {PoolId}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __SendingQuitCommandCallback = LoggerMessage.Define<string>(LogLevel.Trace, new EventId(2004, "SendingQuitCommand"), "Session {SessionId} sending QUIT command", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __ConnectingFailedCallback = LoggerMessage.Define<string>(LogLevel.Error, new EventId(2100, "ConnectingFailed"), "Session {SessionId} connecting failed", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __ServerSentAuthPluginNameCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(2101, "ServerSentAuthPluginName"), "Session {SessionId} server sent auth plugin name {AuthPluginName}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __UnsupportedAuthenticationMethodCallback = LoggerMessage.Define<string, string>(LogLevel.Error, new EventId(2102, "UnsupportedAuthenticationMethod"), "Session {SessionId} unsupported authentication method {AuthPluginName}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __AutoDetectedAurora57Callback = LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2103, "AutoDetectedAurora57"), "Session {SessionId} auto-detected Aurora 5.7 at '{HostName}'; disabling pipelining", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __ServerDoesNotSupportSslCallback = LoggerMessage.Define<string>(LogLevel.Error, new EventId(2105, "ServerDoesNotSupportSsl"), "Session {SessionId} requires SSL but server doesn't support it", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __CouldNotConnectToServerCallback = LoggerMessage.Define<string>(LogLevel.Error, new EventId(2108, "CouldNotConnectToServer"), "Session {SessionId} couldn't connect to server", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __SendingPipelinedResetConnectionRequestCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(2109, "SendingPipelinedResetConnectionRequest"), "Session {SessionId} server version {ServerVersion} supports reset connection and pipelining; sending pipelined reset connection request", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __SendingResetConnectionRequestCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(2110, "SendingResetConnectionRequest"), "Session {SessionId} server version {ServerVersion} supports reset connection; sending reset connection request", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __SendingChangeUserRequestCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(2111, "SendingChangeUserRequest"), "Session {SessionId} server version {ServerVersion} doesn't support reset connection; sending change user request", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __SendingChangeUserRequestDueToChangedDatabaseCallback = LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2112, "SendingChangeUserRequestDueToChangedDatabase"), "Session {SessionId} sending change user request due to changed database {Database}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __OptimisticReauthenticationFailedCallback = LoggerMessage.Define<string>(LogLevel.Trace, new EventId(2113, "OptimisticReauthenticationFailed"), "Session {SessionId} optimistic reauthentication failed; logging in again", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __IgnoringFailureInTryResetConnectionAsyncCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(2114, "IgnoringFailureInTryResetConnectionAsync"), "Session {SessionId} ignoring {Failure} in TryResetConnectionAsync", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __SwitchingToAuthenticationMethodCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(2115, "SwitchingToAuthenticationMethod"), "Session {SessionId} switching to authentication method {AuthenticationMethod}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __NeedsSecureConnectionCallback = LoggerMessage.Define<string, string>(LogLevel.Error, new EventId(2116, "NeedsSecureConnection"), "Session {SessionId} needs a secure connection to use authentication method {AuthenticationMethod}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __AuthenticationMethodNotSupportedCallback = LoggerMessage.Define<string, string>(LogLevel.Error, new EventId(2117, "AuthenticationMethodNotSupported"), "Session {SessionId} is requesting authentication method {AuthenticationMethod} which is not supported", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __CouldNotLoadServerRsaPublicKeyCallback = LoggerMessage.Define<string>(LogLevel.Error, new EventId(2118, "CouldNotLoadServerRsaPublicKey"), "Session {SessionId} couldn't load server's RSA public key", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __CouldNotLoadServerRsaPublicKeyFromFileCallback = LoggerMessage.Define<string, string>(LogLevel.Error, new EventId(2119, "CouldNotLoadServerRsaPublicKeyFromFile"), "Session {SessionId} couldn't load server's RSA public key from '{PublicKeyFilePath}'", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __CouldNotUseAuthenticationMethodForRsaCallback = LoggerMessage.Define<string, string>(LogLevel.Error, new EventId(2120, "CouldNotUseAuthenticationMethodForRsa"), "Session {SessionId} couldn't use authentication method {AuthenticationMethod} because RSA key wasn't specified or couldn't be retrieved", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, int, int, string, Exception> __FailedToResolveHostNameCallback = LoggerMessage.Define<string, string, int, int, string>(LogLevel.Warning, new EventId(2121, "FailedToResolveHostName"), "Session {SessionId} failed to resolve host name {HostName} ({HostNameIndex} of {HostNameCount}): {ExceptionMessage}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, string, Exception> __ConnectTimeoutExpiredCallback = LoggerMessage.Define<string, string, string>(LogLevel.Information, new EventId(2123, "ConnectTimeoutExpired"), "Session {SessionId} connect timeout expired connecting to IP address {IpAddress} for host name {HostName}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, string, string, Exception> __FailedToConnectToSingleIpAddressCallback = LoggerMessage.Define<string, string, string, string>(LogLevel.Information, new EventId(2124, "FailedToConnectToSingleIpAddress"), "Session {SessionId} failed to connect to IP address {IpAddress} for host name {HostName}: {ExceptionMessage}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, string, int?, Exception> __ConnectedToIpAddressCallback = LoggerMessage.Define<string, string, string, int?>(LogLevel.Trace, new EventId(2126, "ConnectedToIpAddress"), "Session {SessionId} connected to IP address {IpAddress} for host name {HostName} with local port {LocalPort}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __ConnectingToUnixSocketCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(2127, "ConnectingToUnixSocket"), "Session {SessionId} connecting to UNIX socket {SocketPath}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __ConnectTimeoutExpiredForUnixSocketCallback = LoggerMessage.Define<string, string>(LogLevel.Information, new EventId(2128, "ConnectTimeoutExpiredForUnixSocket"), "Session {SessionId} connect timeout expired connecting to UNIX socket {SocketPath}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, string, Exception> __ConnectingToNamedPipeCallback = LoggerMessage.Define<string, string, string>(LogLevel.Trace, new EventId(2129, "ConnectingToNamedPipe"), "Session {SessionId} connecting to named pipe {PipeName} on server {HostName}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, string, Exception> __ConnectTimeoutExpiredForNamedPipeCallback = LoggerMessage.Define<string, string, string>(LogLevel.Information, new EventId(2130, "ConnectTimeoutExpiredForNamedPipe"), "Session {SessionId} connect timeout expired connecting to named pipe {PipeName} on server {HostName}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __InitializingTlsConnectionCallback = LoggerMessage.Define<string>(LogLevel.Trace, new EventId(2131, "InitializingTlsConnection"), "Session {SessionId} initializing TLS connection", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __NoCertificatesFoundCallback = LoggerMessage.Define<string>(LogLevel.Error, new EventId(2132, "NoCertificatesFound"), "Session {SessionId} found no certificates in the certificate store", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __CertificateNotFoundInStoreCallback = LoggerMessage.Define<string, string>(LogLevel.Error, new EventId(2133, "CertificateNotFoundInStore"), "Session {SessionId} certificate with thumbprint {Thumbprint} not found in store", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, MySqlCertificateStoreLocation, Exception> __CouldNotLoadCertificateCallback = LoggerMessage.Define<string, MySqlCertificateStoreLocation>(LogLevel.Error, new EventId(2134, "CouldNotLoadCertificate"), "Session {SessionId} couldn't load certificate from {CertificateStoreLocation}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __NoPrivateKeyIncludedWithCertificateFileCallback = LoggerMessage.Define<string, string>(LogLevel.Error, new EventId(2135, "NoPrivateKeyIncludedWithCertificateFile"), "Session {SessionId} no private key included with certificate file '{CertificateFile}'", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __CouldNotLoadCertificateFromFileCallback = LoggerMessage.Define<string, string>(LogLevel.Error, new EventId(2136, "CouldNotLoadCertificateFromFile"), "Session {SessionId} couldn't load certificate from '{CertificateFile}'", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __FailedToObtainClientCertificatesCallback = LoggerMessage.Define<string, string>(LogLevel.Error, new EventId(2137, "FailedToObtainClientCertificates"), "Session {SessionId} failed to obtain client certificates via ProvideClientCertificatesCallback: {ExceptionMessage}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __LoadingCaCertificatesFromFileCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(2138, "LoadingCaCertificatesFromFile"), "Session {SessionId} loading CA certificate(s) from '{CACertificateFile}'", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, int, Exception> __LoadingCaCertificateCallback = LoggerMessage.Define<string, int>(LogLevel.Trace, new EventId(2140, "LoadingCaCertificate"), "Session {SessionId} loading certificate at index {Index} in the CA certificate file.", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, int, string, Exception> __LoadedCaCertificatesFromFileCallback = LoggerMessage.Define<string, int, string>(LogLevel.Trace, new EventId(2141, "LoadedCaCertificatesFromFile"), "Session {SessionId} loaded {CertificateCount} certificate(s) from '{CACertificateFile}'", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __NotUsingRemoteCertificateValidationCallbackDueToSslCaCallback = LoggerMessage.Define<string>(LogLevel.Warning, new EventId(2142, "NotUsingRemoteCertificateValidationCallbackDueToSslCa"), "Session {SessionId} not using client-provided RemoteCertificateValidationCallback because SslCA is specified", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, MySqlSslMode, Exception> __NotUsingRemoteCertificateValidationCallbackDueToSslModeCallback = LoggerMessage.Define<string, MySqlSslMode>(LogLevel.Warning, new EventId(2143, "NotUsingRemoteCertificateValidationCallbackDueToSslMode"), "Session {SessionId} not using client-provided RemoteCertificateValidationCallback because SslMode is {SslMode}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __UsingRemoteCertificateValidationCallbackCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2144, "UsingRemoteCertificateValidationCallback"), "Session {SessionId} using client-provided RemoteCertificateValidationCallback", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, SslProtocols, CipherAlgorithmType, HashAlgorithmType, ExchangeAlgorithmType, int, Exception> __ConnectedTlsDetailedCallback = LoggerMessage.Define<string, SslProtocols, CipherAlgorithmType, HashAlgorithmType, ExchangeAlgorithmType, int>(LogLevel.Debug, new EventId(2146, "ConnectedTlsDetailed"), "Session {SessionId} connected TLS using {SslProtocol}, {CipherAlgorithm}, {HashAlgorithm}, {KeyExchangeAlgorithm}, {KeyExchangeStrength}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __CouldNotInitializeTlsConnectionCallback = LoggerMessage.Define<string>(LogLevel.Error, new EventId(2147, "CouldNotInitializeTlsConnection"), "Session {SessionId} couldn't initialize TLS connection", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __LoadingClientKeyFromKeyFileCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(2148, "LoadingClientKeyFromKeyFile"), "Session {SessionId} loading client key from '{ClientKeyFilePath}'", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __CouldNotLoadClientKeyFromKeyFileCallback = LoggerMessage.Define<string, string>(LogLevel.Error, new EventId(2149, "CouldNotLoadClientKeyFromKeyFile"), "Session {SessionId} couldn't load client key from '{ClientKeyFilePath}'", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __DetectedProxyCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2150, "DetectedProxy"), "Session {SessionId} detected proxy; getting CONNECTION_ID(), VERSION() from server", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, int, int, string, string, Exception> __ChangingConnectionIdCallback = LoggerMessage.Define<string, int, int, string, string>(LogLevel.Debug, new EventId(2151, "ChangingConnectionId"), "Session {SessionId} changing connection id from {OldConnectionId} to {ConnectionId} and server version from {OldServerVersion} to {ServerVersion}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __FailedToGetConnectionIdCallback = LoggerMessage.Define<string>(LogLevel.Information, new EventId(2152, "FailedToGetConnectionId"), "Session {SessionId} failed to get CONNECTION_ID(), VERSION()", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __ClosingStreamSocketCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2005, "ClosingStreamSocket"), "Session {SessionId} closing stream/socket", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __CreatingConnectionAttributesCallback = LoggerMessage.Define<string>(LogLevel.Trace, new EventId(2153, "CreatingConnectionAttributes"), "Session {SessionId} creating connection attributes", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __ObtainingPasswordViaProvidePasswordCallbackCallback = LoggerMessage.Define<string>(LogLevel.Trace, new EventId(2154, "ObtainingPasswordViaProvidePasswordCallback"), "Session {SessionId} obtaining password via ProvidePasswordCallback", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __FailedToObtainPasswordCallback = LoggerMessage.Define<string, string>(LogLevel.Error, new EventId(2155, "FailedToObtainPassword"), "Session {SessionId} failed to obtain password via ProvidePasswordCallback: {ExceptionMessage}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	private static readonly Action<ILogger, int, Exception> __IgnoringCancellationForCommandCallback = LoggerMessage.Define<int>(LogLevel.Trace, new EventId(2300, "IgnoringCancellationForCommand"), "Ignoring cancellation for closed connection or invalid command {CommandId}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, string, Exception> __CommandHasBeenCanceledCallback = LoggerMessage.Define<int, string, string>(LogLevel.Debug, new EventId(2301, "CommandHasBeenCanceled"), "Command {CommandId} for session {SessionId} has been canceled via {CancellationSource}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __IgnoringCancellationForClosedConnectionCallback = LoggerMessage.Define<string>(LogLevel.Information, new EventId(2302, "IgnoringCancellationForClosedConnection"), "Session {SessionId} ignoring cancellation for closed connection", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, int, Exception> __CancelingCommandFailedCallback = LoggerMessage.Define<string, int>(LogLevel.Information, new EventId(2303, "CancelingCommandFailed"), "Session {SessionId} cancelling command {CommandId} failed", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2, 2 })]
	private static readonly Action<ILogger, string, int, int, string, Exception> __WillCancelCommandCallback = LoggerMessage.Define<string, int, int, string>(LogLevel.Debug, new EventId(2304, "WillCancelCommand"), "Session {SessionId} will cancel command {CommandId} ({CancelAttemptCount} attempts); CommandText: {CommandText}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, int, string, string, Exception> __CancelingCommandFromSessionCallback = LoggerMessage.Define<string, int, string, string>(LogLevel.Information, new EventId(2305, "CancelingCommandFromSession"), "Session {SessionId} canceling command {CommandId} from session {CancelingSessionId}; CommandText: {CommandText}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, int, int, Exception> __IgnoringCancellationForInactiveCommandCallback = LoggerMessage.Define<string, int, int>(LogLevel.Debug, new EventId(2306, "IgnoringCancellationForInactiveCommand"), "Session {SessionId} active command {ActiveCommandId} is not the command {CommandId} being canceled; ignoring cancellation.", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, int, string, Exception> __CancelingCommandCallback = LoggerMessage.Define<string, int, string>(LogLevel.Debug, new EventId(2307, "CancelingCommand"), "Session {SessionId} canceling command {CommandId} with text {CommandText}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __SendingSleepToClearPendingCancellationCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2308, "SendingSleepToClearPendingCancellation"), "Session {SessionId} sending 'SLEEP(0)' command to clear pending cancellation", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __GettingCachedProcedureCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(2400, "GettingCachedProcedure"), "Session {SessionId} getting cached procedure named {ProcedureName}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, int?, Exception> __PoolDoesNotHaveSharedProcedureCacheCallback = LoggerMessage.Define<string, int?>(LogLevel.Information, new EventId(2401, "PoolDoesNotHaveSharedProcedureCache"), "Session {SessionId} pool {PoolId} doesn't have a shared procedure cache; procedure will only be cached on this connection", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, string, Exception> __CouldNotNormalizeDatabaseAndNameCallback = LoggerMessage.Define<string, string, string>(LogLevel.Information, new EventId(2402, "CouldNotNormalizeDatabaseAndName"), "Session {SessionId} couldn't normalize the name '{ProcedureName}' in database {Database}; not caching procedure", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, string, Exception> __FailedToCacheProcedureCallback = LoggerMessage.Define<string, string, string>(LogLevel.Information, new EventId(2403, "FailedToCacheProcedure"), "Session {SessionId} failed to cache procedure {Schema}.{Component}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, string, Exception> __CachingProcedureCallback = LoggerMessage.Define<string, string, string>(LogLevel.Trace, new EventId(2404, "CachingProcedure"), "Session {SessionId} caching procedure {Schema}.{Component}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, int, Exception> __ProcedureCacheCountCallback = LoggerMessage.Define<string, int>(LogLevel.Trace, new EventId(2405, "ProcedureCacheCount"), "Session {SessionId} procedure cache count is {ProcedureCacheCount}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, string, Exception> __DidNotFindCachedProcedureCallback = LoggerMessage.Define<string, string, string>(LogLevel.Information, new EventId(2406, "DidNotFindCachedProcedure"), "Session {SessionId} did not find cached procedure {Schema}.{Component}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, string, Exception> __ReturningCachedProcedureCallback = LoggerMessage.Define<string, string, string>(LogLevel.Trace, new EventId(2407, "ReturningCachedProcedure"), "Session {SessionId} returning cached procedure {Schema}.{Component}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, string, string, Exception> __FailedToRetrieveProcedureMetadataCallback = LoggerMessage.Define<string, string, string, string>(LogLevel.Information, new EventId(2408, "FailedToRetrieveProcedureMetadata"), "Session {SessionId} failed to retrieve metadata for {Schema}.{Component}; falling back to INFORMATION_SCHEMA: {ExceptionMessage}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __ServerDoesNotSupportCachedProceduresCallback = LoggerMessage.Define<string, string>(LogLevel.Information, new EventId(2409, "ServerDoesNotSupportCachedProcedures"), "Session {SessionId} server version {ServerVersion} does not support cached procedures", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, int, int, Exception> __ProcedureHasRoutineCountCallback = LoggerMessage.Define<string, string, int, int>(LogLevel.Trace, new EventId(2410, "ProcedureHasRoutineCount"), "Procedure for {Schema}.{Component} has {RoutineCount} routines and {ParameterCount} parameters", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __CreatedNewSessionCallback = LoggerMessage.Define<string>(LogLevel.Trace, new EventId(2000, "CreatedNewSession"), "Created new session {SessionId}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __PingingServerCallback = LoggerMessage.Define<string>(LogLevel.Trace, new EventId(2500, "PingingServer"), "Session {SessionId} pinging server", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, Exception> __PingFailedCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(2502, "PingFailed"), "Session {SessionId} ping failed due to {Failure}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __SettingStateToFailedCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2009, "SettingStateToFailed"), "Session {SessionId} setting state to Failed", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, int, int, Exception> __ExpectedToReadMoreBytesCallback = LoggerMessage.Define<string, int, int>(LogLevel.Error, new EventId(2010, "ExpectedToReadMoreBytes"), "Session {SessionId} expected to read {ExpectedByteCount} bytes but only read {ReadByteCount}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, int, string, string, Exception> __ErrorPayloadCallback = LoggerMessage.Define<string, int, string, string>(LogLevel.Debug, new EventId(2006, "ErrorPayload"), "Session {SessionId} got error payload: {ErrorCode}, {State}, {Message}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, IOBehavior, int, Exception> __CommandExecutorExecuteReaderCallback = LoggerMessage.Define<string, IOBehavior, int>(LogLevel.Trace, new EventId(2202, "CommandExecutorExecuteReader"), "Session {SessionId} ExecuteReader {IOBehavior} for {CommandCount} command(s)", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __QueryWasInterruptedCallback = LoggerMessage.Define<string>(LogLevel.Information, new EventId(2203, "QueryWasInterrupted"), "Session {SessionId} query was interrupted", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __PreparingCommandPayloadCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(2204, "PreparingCommandPayload"), "Session {SessionId} preparing command payload for: {CommandText}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, int, string, Exception> __PreparingCommandPayloadWithIdCallback = LoggerMessage.Define<string, int, string>(LogLevel.Trace, new EventId(2205, "PreparingCommandPayloadWithId"), "Session {SessionId} preparing statement payload with ID {StatementId} for: {CommandText}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __QueryAttributesNotSupportedCallback = LoggerMessage.Define<string, string>(LogLevel.Warning, new EventId(2206, "QueryAttributesNotSupported"), "Session {SessionId} has query attributes but server doesn't support them; CommandText: {CommandText}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, int, Exception> __QueryAttributesNotSupportedWithIdCallback = LoggerMessage.Define<string, int>(LogLevel.Warning, new EventId(2207, "QueryAttributesNotSupportedWithId"), "Session {SessionId} has attributes for statement {StatementId} but the server does not support them", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, string, string, Exception> __IgnoringExceptionInDisposeAsyncCallback = LoggerMessage.Define<string, string, string>(LogLevel.Warning, new EventId(2208, "IgnoringExceptionInDisposeAsync"), "Session {SessionId} ignoring exception in MySqlDataReader.DisposeAsync. Message: {ExceptionMessage}. CommandText: {CommandText}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __StartingBulkCopyCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2503, "StartingBulkCopy"), "Starting bulk copy to {TableName}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, Exception> __AddingDefaultColumnMappingCallback = LoggerMessage.Define<int, string>(LogLevel.Debug, new EventId(2504, "AddingDefaultColumnMapping"), "Adding default column mapping from {SourceOrdinal} to {DestinationColumn}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	private static readonly Action<ILogger, int, Exception> __IgnoringColumnCallback = LoggerMessage.Define<int>(LogLevel.Debug, new EventId(2505, "IgnoringColumn"), "Ignoring column with source ordinal {SourceOrdinal}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __FinishedBulkCopyCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2506, "FinishedBulkCopy"), "Finished bulk copy to {TableName}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, int, int, Exception> __BulkCopyFailedCallback = LoggerMessage.Define<string, int, int>(LogLevel.Error, new EventId(2507, "BulkCopyFailed"), "Bulk copy to {TableName} failed: {RowsCopied} row(s) copied; {RowsInserted} row(s) inserted", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, string, Exception> __ColumnMappingAlreadyHasExpressionCallback = LoggerMessage.Define<int, string, string>(LogLevel.Information, new EventId(2508, "ColumnMappingAlreadyHasExpression"), "Column mapping for {SourceOrdinal} to {DestinationColumn} already has expression {Expression}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, int, string, string, Exception> __SettingExpressionToMapColumnCallback = LoggerMessage.Define<int, string, string>(LogLevel.Trace, new EventId(2509, "SettingExpressionToMapColumn"), "Setting expression to map column {SourceOrdinal} to {DestinationColumn}: {Expression}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __StartingTransactionCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2700, "StartingTransaction"), "Session {SessionId} starting transaction", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __StartedTransactionCallback = LoggerMessage.Define<string>(LogLevel.Trace, new EventId(2701, "StartedTransaction"), "Session {SessionId} started transaction", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __CommittingTransactionCallback = LoggerMessage.Define<string>(LogLevel.Trace, new EventId(2702, "CommittingTransaction"), "Session {SessionId} committing transaction", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __CommittedTransactionCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2703, "CommittedTransaction"), "Session {SessionId} committed transaction", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __RollingBackTransactionCallback = LoggerMessage.Define<string>(LogLevel.Trace, new EventId(2704, "RollingBackTransaction"), "Session {SessionId} rolling back transaction", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __RolledBackTransactionCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2705, "RolledBackTransaction"), "Session {SessionId} rolled back transaction", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, Exception> __WaitingForAvailableSessionCallback = LoggerMessage.Define<int>(LogLevel.Trace, new EventId(3000, "WaitingForAvailableSession"), "Pool {PoolId} waiting for an available session", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, Exception> __FailedInReceiveReplyAsyncCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2008, "FailedInReceiveReplyAsync"), "Session {SessionId} failed in ReceiveReplyAsync", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __FailedInSendReplyAsyncCallback = LoggerMessage.Define<string>(LogLevel.Debug, new EventId(2007, "FailedInSendReplyAsync"), "Session {SessionId} failed in SendReplyAsync", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, int, string, Exception> __CreatingNewConnectionPoolCallback = LoggerMessage.Define<int, string>(LogLevel.Information, new EventId(3001, "CreatingNewConnectionPool"), "Creating new connection pool {PoolId} for {ConnectionString}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, Exception> __ScanningForLeakedSessionsCallback = LoggerMessage.Define<int>(LogLevel.Debug, new EventId(3002, "ScanningForLeakedSessions"), "Pool {PoolId} is empty; scanning for any leaked sessions", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, Exception> __FoundExistingSessionCallback = LoggerMessage.Define<int>(LogLevel.Trace, new EventId(3003, "FoundExistingSession"), "Pool {PoolId} found an existing session; checking it for validity", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	private static readonly Action<ILogger, int, Exception> __DiscardingSessionDueToWrongGenerationCallback = LoggerMessage.Define<int>(LogLevel.Trace, new EventId(3004, "DiscardingSessionDueToWrongGeneration"), "Pool {PoolId} discarding session due to wrong generation", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, Exception> __SessionIsUnusableCallback = LoggerMessage.Define<int, string>(LogLevel.Information, new EventId(3005, "SessionIsUnusable"), "Pool {PoolId} session {SessionId} is unusable; destroying it", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, int, string, int, Exception> __ReturningPooledSessionCallback = LoggerMessage.Define<int, string, int>(LogLevel.Trace, new EventId(3006, "ReturningPooledSession"), "Pool {PoolId} returning pooled session {SessionId} to caller; {LeasedSessionCount} leased session(s)", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, int, string, int, Exception> __ReturningNewSessionCallback = LoggerMessage.Define<int, string, int>(LogLevel.Trace, new EventId(3007, "ReturningNewSession"), "Pool {PoolId} returning new session {SessionId} to caller; {LeasedSessionCount} leased session(s)", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, string, Exception> __DisposingCreatedSessionDueToExceptionCallback = LoggerMessage.Define<int, string, string>(LogLevel.Debug, new EventId(3008, "DisposingCreatedSessionDueToException"), "Pool {PoolId} disposing created session {SessionId} due to exception: {ExceptionMessage}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, Exception> __UnexpectedErrorInGetSessionAsyncCallback = LoggerMessage.Define<int, string>(LogLevel.Warning, new EventId(3009, "UnexpectedErrorInGetSessionAsync"), "Pool {PoolId} unexpected error in GetSessionAsync: {ExceptionMessage}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, Exception> __ReceivingSessionBackCallback = LoggerMessage.Define<int, string>(LogLevel.Trace, new EventId(3010, "ReceivingSessionBack"), "Pool {PoolId} receiving session {SessionId} back", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, Exception> __ReceivedInvalidSessionCallback = LoggerMessage.Define<int, string>(LogLevel.Information, new EventId(3011, "ReceivedInvalidSession"), "Pool {PoolId} received invalid session {SessionId}; destroying it", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, Exception> __ReceivedExpiredSessionCallback = LoggerMessage.Define<int, string>(LogLevel.Debug, new EventId(3012, "ReceivedExpiredSession"), "Pool {PoolId} received expired session {SessionId}; destroying it", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, Exception> __ClearingConnectionPoolCallback = LoggerMessage.Define<int>(LogLevel.Information, new EventId(3013, "ClearingConnectionPool"), "Pool {PoolId} clearing connection pool", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	private static readonly Action<ILogger, int, Exception> __DisposingConnectionPoolCallback = LoggerMessage.Define<int>(LogLevel.Debug, new EventId(3014, "DisposingConnectionPool"), "Pool {PoolId} disposing connection pool", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	private static readonly Action<ILogger, int, Exception> __RecoveredNoSessionsCallback = LoggerMessage.Define<int>(LogLevel.Trace, new EventId(3015, "RecoveredNoSessions"), "Pool {PoolId} recovered no sessions", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	private static readonly Action<ILogger, int, int, Exception> __RecoveredSessionCountCallback = LoggerMessage.Define<int, int>(LogLevel.Warning, new EventId(3016, "RecoveredSessionCount"), "Pool {PoolId} recovered {SessionCount} sessions", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, Exception> __FoundSessionToCleanUpCallback = LoggerMessage.Define<int, string>(LogLevel.Debug, new EventId(3017, "FoundSessionToCleanUp"), "Pool {PoolId} found session {SessionId} to clean up", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, string, Exception> __HasServerRedirectionHeaderCallback = LoggerMessage.Define<string, string>(LogLevel.Trace, new EventId(3200, "HasServerRedirectionHeader"), "Session {SessionId} has server redirection header {Header}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, Exception> __ServerRedirectionIsDisabledCallback = LoggerMessage.Define<int>(LogLevel.Trace, new EventId(3201, "ServerRedirectionIsDisabled"), "Pool {PoolId} server redirection is disabled; ignoring redirection", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, int, string, Exception> __OpeningNewConnectionCallback = LoggerMessage.Define<int, string, int, string>(LogLevel.Debug, new EventId(3202, "OpeningNewConnection"), "Pool {PoolId} opening new connection to {Host}:{Port} as {User}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, int, string, Exception> __FailedToConnectRedirectedSessionCallback = LoggerMessage.Define<int, string>(LogLevel.Information, new EventId(3203, "FailedToConnectRedirectedSession"), "Pool {PoolId} failed to connect redirected session {SessionId}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, string, Exception> __ClosingSessionToUseRedirectedSessionCallback = LoggerMessage.Define<int, string, string>(LogLevel.Trace, new EventId(3204, "ClosingSessionToUseRedirectedSession"), "Pool {PoolId} closing session {SessionId} to use redirected session {RedirectedSessionId} instead", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, Exception> __SessionAlreadyConnectedToServerCallback = LoggerMessage.Define<string>(LogLevel.Trace, new EventId(3205, "SessionAlreadyConnectedToServer"), "Session {SessionId} is already connected to this server; ignoring redirection", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	private static readonly Action<ILogger, int, Exception> __RequiresServerRedirectionCallback = LoggerMessage.Define<int>(LogLevel.Error, new EventId(3206, "RequiresServerRedirection"), "Pool {PoolId} requires server redirection but server doesn't support it", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, Exception> __CreatedPoolWillNotBeUsedCallback = LoggerMessage.Define<int>(LogLevel.Debug, new EventId(3020, "CreatedPoolWillNotBeUsed"), "Pool {PoolId} was created but will not be used (due to race)", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	private static readonly Action<ILogger, int, Exception> __ReapingConnectionPoolCallback = LoggerMessage.Define<int>(LogLevel.Trace, new EventId(3100, "ReapingConnectionPool"), "Pool {PoolId} reaping connection pool", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, Exception> __CheckingForDnsChangesCallback = LoggerMessage.Define<int>(LogLevel.Trace, new EventId(3101, "CheckingForDnsChanges"), "Pool {PoolId} checking for DNS changes", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, string, string, string, Exception> __DetectedDnsChangeCallback = LoggerMessage.Define<int, string, string, string>(LogLevel.Debug, new EventId(3102, "DetectedDnsChange"), "Pool {PoolId} detected DNS change for '{HostName}': {OldAddresses} to {NewAddresses}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 1, 2 })]
	private static readonly Action<ILogger, int, string, string, Exception> __DnsCheckFailedCallback = LoggerMessage.Define<int, string, string>(LogLevel.Debug, new EventId(3103, "DnsCheckFailed"), "Pool {PoolId} DNS check failed; ignoring '{HostName}': {ExceptionMessage}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, int, Exception> __ClearingPoolDueToDnsChangesCallback = LoggerMessage.Define<int>(LogLevel.Information, new EventId(3104, "ClearingPoolDueToDnsChanges"), "Pool {PoolId} clearing pool due to DNS changes", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[LoggerMessage(1000, LogLevel.Information, "Data source {DataSourceId} created with pool {PoolId} and name {DataSourceName}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void DataSourceCreatedWithPoolWithName(ILogger logger, int dataSourceId, int poolId, string dataSourceName)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__DataSourceCreatedWithPoolWithNameCallback(logger, dataSourceId, poolId, dataSourceName, null);
		}
	}

	[LoggerMessage(1001, LogLevel.Information, "Data source {DataSourceId} created with name {DataSourceName} and no pool")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void DataSourceCreatedWithoutPoolWithName(ILogger logger, int dataSourceId, string dataSourceName)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__DataSourceCreatedWithoutPoolWithNameCallback(logger, dataSourceId, dataSourceName, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(1002, LogLevel.Information, "Data source {DataSourceId} created with pool {PoolId} and no name")]
	public static void DataSourceCreatedWithPoolWithoutName(ILogger logger, int dataSourceId, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__DataSourceCreatedWithPoolWithoutNameCallback(logger, dataSourceId, poolId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(1003, LogLevel.Information, "Data source {DataSourceId} created with no pool and no name")]
	public static void DataSourceCreatedWithoutPoolWithoutName(ILogger logger, int dataSourceId)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__DataSourceCreatedWithoutPoolWithoutNameCallback(logger, dataSourceId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(1100, LogLevel.Error, "Periodic password provider for data source {DataSourceId} failed: {ExceptionMessage}")]
	public static void PeriodicPasswordProviderFailed(ILogger logger, Exception exception, int dataSourceId, string exceptionMessage)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__PeriodicPasswordProviderFailedCallback(logger, dataSourceId, exceptionMessage, exception);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2001, LogLevel.Debug, "Created new non-pooled session {SessionId}")]
	public static void CreatedNonPooledSession(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__CreatedNonPooledSessionCallback(logger, sessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2002, LogLevel.Debug, "Session {SessionId} resetting connection")]
	public static void ResettingConnection(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__ResettingConnectionCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2003, LogLevel.Trace, "Session {SessionId} returning to pool {PoolId}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ReturningToPool(ILogger logger, string sessionId, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ReturningToPoolCallback(logger, sessionId, poolId, null);
		}
	}

	[LoggerMessage(2004, LogLevel.Trace, "Session {SessionId} sending QUIT command")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void SendingQuitCommand(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__SendingQuitCommandCallback(logger, sessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2100, LogLevel.Error, "Session {SessionId} connecting failed")]
	public static void ConnectingFailed(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__ConnectingFailedCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2101, LogLevel.Trace, "Session {SessionId} server sent auth plugin name {AuthPluginName}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ServerSentAuthPluginName(ILogger logger, string sessionId, string authPluginName)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ServerSentAuthPluginNameCallback(logger, sessionId, authPluginName, null);
		}
	}

	[LoggerMessage(2102, LogLevel.Error, "Session {SessionId} unsupported authentication method {AuthPluginName}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void UnsupportedAuthenticationMethod(ILogger logger, string sessionId, string authPluginName)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__UnsupportedAuthenticationMethodCallback(logger, sessionId, authPluginName, null);
		}
	}

	[LoggerMessage(2103, LogLevel.Debug, "Session {SessionId} auto-detected Aurora 5.7 at '{HostName}'; disabling pipelining")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void AutoDetectedAurora57(ILogger logger, string sessionId, string hostName)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__AutoDetectedAurora57Callback(logger, sessionId, hostName, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2104, LogLevel.Debug, "Session {SessionId} made connection; server version {ServerVersion}; connection ID {ConnectionId}; supports: compression {SupportsCompression}, attributes {SupportsAttributes}, deprecate EOF {SupportsDeprecateEof}, cached metadata {SupportsCachedMetadata}, SSL {SupportsSsl}, session track {SupportsSessionTrack}, pipelining {SupportsPipelining}, query attributes {SupportsQueryAttributes}")]
	public static void SessionMadeConnection(ILogger logger, string sessionId, string serverVersion, int connectionId, bool supportsCompression, bool supportsAttributes, bool supportsDeprecateEof, bool supportsCachedMetadata, bool supportsSsl, bool supportsSessionTrack, bool supportsPipelining, bool supportsQueryAttributes)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			logger.Log(LogLevel.Debug, new EventId(2104, "SessionMadeConnection"), new __SessionMadeConnectionStruct(sessionId, serverVersion, connectionId, supportsCompression, supportsAttributes, supportsDeprecateEof, supportsCachedMetadata, supportsSsl, supportsSessionTrack, supportsPipelining, supportsQueryAttributes), null, __SessionMadeConnectionStruct.Format);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2105, LogLevel.Error, "Session {SessionId} requires SSL but server doesn't support it")]
	public static void ServerDoesNotSupportSsl(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__ServerDoesNotSupportSslCallback(logger, sessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2108, LogLevel.Error, "Session {SessionId} couldn't connect to server")]
	public static void CouldNotConnectToServer(ILogger logger, Exception exception, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__CouldNotConnectToServerCallback(logger, sessionId, exception);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2109, LogLevel.Trace, "Session {SessionId} server version {ServerVersion} supports reset connection and pipelining; sending pipelined reset connection request")]
	public static void SendingPipelinedResetConnectionRequest(ILogger logger, string sessionId, string serverVersion)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__SendingPipelinedResetConnectionRequestCallback(logger, sessionId, serverVersion, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2110, LogLevel.Trace, "Session {SessionId} server version {ServerVersion} supports reset connection; sending reset connection request")]
	public static void SendingResetConnectionRequest(ILogger logger, string sessionId, string serverVersion)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__SendingResetConnectionRequestCallback(logger, sessionId, serverVersion, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2111, LogLevel.Trace, "Session {SessionId} server version {ServerVersion} doesn't support reset connection; sending change user request")]
	public static void SendingChangeUserRequest(ILogger logger, string sessionId, string serverVersion)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__SendingChangeUserRequestCallback(logger, sessionId, serverVersion, null);
		}
	}

	[LoggerMessage(2112, LogLevel.Debug, "Session {SessionId} sending change user request due to changed database {Database}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void SendingChangeUserRequestDueToChangedDatabase(ILogger logger, string sessionId, string database)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__SendingChangeUserRequestDueToChangedDatabaseCallback(logger, sessionId, database, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2113, LogLevel.Trace, "Session {SessionId} optimistic reauthentication failed; logging in again")]
	public static void OptimisticReauthenticationFailed(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__OptimisticReauthenticationFailedCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2114, LogLevel.Trace, "Session {SessionId} ignoring {Failure} in TryResetConnectionAsync")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void IgnoringFailureInTryResetConnectionAsync(ILogger logger, Exception exception, string sessionId, string failure)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__IgnoringFailureInTryResetConnectionAsyncCallback(logger, sessionId, failure, exception);
		}
	}

	[LoggerMessage(2115, LogLevel.Trace, "Session {SessionId} switching to authentication method {AuthenticationMethod}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void SwitchingToAuthenticationMethod(ILogger logger, string sessionId, string authenticationMethod)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__SwitchingToAuthenticationMethodCallback(logger, sessionId, authenticationMethod, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2116, LogLevel.Error, "Session {SessionId} needs a secure connection to use authentication method {AuthenticationMethod}")]
	public static void NeedsSecureConnection(ILogger logger, string sessionId, string authenticationMethod)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__NeedsSecureConnectionCallback(logger, sessionId, authenticationMethod, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2117, LogLevel.Error, "Session {SessionId} is requesting authentication method {AuthenticationMethod} which is not supported")]
	public static void AuthenticationMethodNotSupported(ILogger logger, string sessionId, string authenticationMethod)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__AuthenticationMethodNotSupportedCallback(logger, sessionId, authenticationMethod, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2118, LogLevel.Error, "Session {SessionId} couldn't load server's RSA public key")]
	public static void CouldNotLoadServerRsaPublicKey(ILogger logger, Exception exception, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__CouldNotLoadServerRsaPublicKeyCallback(logger, sessionId, exception);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2119, LogLevel.Error, "Session {SessionId} couldn't load server's RSA public key from '{PublicKeyFilePath}'")]
	public static void CouldNotLoadServerRsaPublicKeyFromFile(ILogger logger, Exception exception, string sessionId, string publicKeyFilePath)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__CouldNotLoadServerRsaPublicKeyFromFileCallback(logger, sessionId, publicKeyFilePath, exception);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2120, LogLevel.Error, "Session {SessionId} couldn't use authentication method {AuthenticationMethod} because RSA key wasn't specified or couldn't be retrieved")]
	public static void CouldNotUseAuthenticationMethodForRsa(ILogger logger, string sessionId, string authenticationMethod)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__CouldNotUseAuthenticationMethodForRsaCallback(logger, sessionId, authenticationMethod, null);
		}
	}

	[LoggerMessage(2121, LogLevel.Warning, "Session {SessionId} failed to resolve host name {HostName} ({HostNameIndex} of {HostNameCount}): {ExceptionMessage}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void FailedToResolveHostName(ILogger logger, Exception exception, string sessionId, string hostName, int hostNameIndex, int hostNameCount, string exceptionMessage)
	{
		if (logger.IsEnabled(LogLevel.Warning))
		{
			__FailedToResolveHostNameCallback(logger, sessionId, hostName, hostNameIndex, hostNameCount, exceptionMessage, exception);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2122, LogLevel.Trace, "Session {SessionId} connecting to IP address {IpAddress} ({IpAddressIndex} of {IpAddressCount}) for host name {HostName} ({HostNameIndex} of {HostNameCount})")]
	public static void ConnectingToIpAddress(ILogger logger, string sessionId, string ipAddress, int ipAddressIndex, int ipAddressCount, string hostName, int hostNameIndex, int hostNameCount)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			logger.Log(LogLevel.Trace, new EventId(2122, "ConnectingToIpAddress"), new __ConnectingToIpAddressStruct(sessionId, ipAddress, ipAddressIndex, ipAddressCount, hostName, hostNameIndex, hostNameCount), null, __ConnectingToIpAddressStruct.Format);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2123, LogLevel.Information, "Session {SessionId} connect timeout expired connecting to IP address {IpAddress} for host name {HostName}")]
	public static void ConnectTimeoutExpired(ILogger logger, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception exception, string sessionId, string ipAddress, string hostName)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__ConnectTimeoutExpiredCallback(logger, sessionId, ipAddress, hostName, exception);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2124, LogLevel.Information, "Session {SessionId} failed to connect to IP address {IpAddress} for host name {HostName}: {ExceptionMessage}")]
	public static void FailedToConnectToSingleIpAddress(ILogger logger, Exception exception, string sessionId, string ipAddress, string hostName, string exceptionMessage)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__FailedToConnectToSingleIpAddressCallback(logger, sessionId, ipAddress, hostName, exceptionMessage, exception);
		}
	}

	[LoggerMessage(EventId = 2125, Message = "Session {SessionId} failed to connect to IP address {IpAddress} ({IpAddressIndex} of {IpAddressCount}) for host name {HostName} ({HostNameIndex} of {HostNameCount}): {ExceptionMessage}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void FailedToConnectToIpAddress(ILogger logger, Exception exception, LogLevel logLevel, string sessionId, string ipAddress, int ipAddressIndex, int ipAddressCount, string hostName, int hostNameIndex, int hostNameCount, string exceptionMessage)
	{
		if (logger.IsEnabled(logLevel))
		{
			logger.Log(logLevel, new EventId(2125, "FailedToConnectToIpAddress"), new __FailedToConnectToIpAddressStruct(sessionId, ipAddress, ipAddressIndex, ipAddressCount, hostName, hostNameIndex, hostNameCount, exceptionMessage), exception, __FailedToConnectToIpAddressStruct.Format);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2126, LogLevel.Trace, "Session {SessionId} connected to IP address {IpAddress} for host name {HostName} with local port {LocalPort}")]
	public static void ConnectedToIpAddress(ILogger logger, string sessionId, string ipAddress, string hostName, int? localPort)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ConnectedToIpAddressCallback(logger, sessionId, ipAddress, hostName, localPort, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2127, LogLevel.Trace, "Session {SessionId} connecting to UNIX socket {SocketPath}")]
	public static void ConnectingToUnixSocket(ILogger logger, string sessionId, string socketPath)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ConnectingToUnixSocketCallback(logger, sessionId, socketPath, null);
		}
	}

	[LoggerMessage(2128, LogLevel.Information, "Session {SessionId} connect timeout expired connecting to UNIX socket {SocketPath}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ConnectTimeoutExpiredForUnixSocket(ILogger logger, string sessionId, string socketPath)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__ConnectTimeoutExpiredForUnixSocketCallback(logger, sessionId, socketPath, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2129, LogLevel.Trace, "Session {SessionId} connecting to named pipe {PipeName} on server {HostName}")]
	public static void ConnectingToNamedPipe(ILogger logger, string sessionId, string pipeName, string hostName)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ConnectingToNamedPipeCallback(logger, sessionId, pipeName, hostName, null);
		}
	}

	[LoggerMessage(2130, LogLevel.Information, "Session {SessionId} connect timeout expired connecting to named pipe {PipeName} on server {HostName}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ConnectTimeoutExpiredForNamedPipe(ILogger logger, Exception exception, string sessionId, string pipeName, string hostName)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__ConnectTimeoutExpiredForNamedPipeCallback(logger, sessionId, pipeName, hostName, exception);
		}
	}

	[LoggerMessage(2131, LogLevel.Trace, "Session {SessionId} initializing TLS connection")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void InitializingTlsConnection(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__InitializingTlsConnectionCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2132, LogLevel.Error, "Session {SessionId} found no certificates in the certificate store")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void NoCertificatesFound(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__NoCertificatesFoundCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2133, LogLevel.Error, "Session {SessionId} certificate with thumbprint {Thumbprint} not found in store")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void CertificateNotFoundInStore(ILogger logger, string sessionId, string thumbprint)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__CertificateNotFoundInStoreCallback(logger, sessionId, thumbprint, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2134, LogLevel.Error, "Session {SessionId} couldn't load certificate from {CertificateStoreLocation}")]
	public static void CouldNotLoadCertificate(ILogger logger, Exception exception, string sessionId, MySqlCertificateStoreLocation certificateStoreLocation)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__CouldNotLoadCertificateCallback(logger, sessionId, certificateStoreLocation, exception);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2135, LogLevel.Error, "Session {SessionId} no private key included with certificate file '{CertificateFile}'")]
	public static void NoPrivateKeyIncludedWithCertificateFile(ILogger logger, string sessionId, string certificateFile)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__NoPrivateKeyIncludedWithCertificateFileCallback(logger, sessionId, certificateFile, null);
		}
	}

	[LoggerMessage(2136, LogLevel.Error, "Session {SessionId} couldn't load certificate from '{CertificateFile}'")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void CouldNotLoadCertificateFromFile(ILogger logger, Exception exception, string sessionId, string certificateFile)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__CouldNotLoadCertificateFromFileCallback(logger, sessionId, certificateFile, exception);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2137, LogLevel.Error, "Session {SessionId} failed to obtain client certificates via ProvideClientCertificatesCallback: {ExceptionMessage}")]
	public static void FailedToObtainClientCertificates(ILogger logger, Exception exception, string sessionId, string exceptionMessage)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__FailedToObtainClientCertificatesCallback(logger, sessionId, exceptionMessage, exception);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2138, LogLevel.Trace, "Session {SessionId} loading CA certificate(s) from '{CACertificateFile}'")]
	public static void LoadingCaCertificatesFromFile(ILogger logger, string sessionId, string caCertificateFile)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__LoadingCaCertificatesFromFileCallback(logger, sessionId, caCertificateFile, null);
		}
	}

	[LoggerMessage(EventId = 2139, Message = "Session {SessionId} couldn't load CA certificate from '{CACertificateFile}'")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void CouldNotLoadCaCertificateFromFile(ILogger logger, Exception exception, LogLevel logLevel, string sessionId, string caCertificateFile)
	{
		if (logger.IsEnabled(logLevel))
		{
			logger.Log(logLevel, new EventId(2139, "CouldNotLoadCaCertificateFromFile"), new __CouldNotLoadCaCertificateFromFileStruct(sessionId, caCertificateFile), exception, __CouldNotLoadCaCertificateFromFileStruct.Format);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2140, LogLevel.Trace, "Session {SessionId} loading certificate at index {Index} in the CA certificate file.")]
	public static void LoadingCaCertificate(ILogger logger, string sessionId, int index)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__LoadingCaCertificateCallback(logger, sessionId, index, null);
		}
	}

	[LoggerMessage(2141, LogLevel.Trace, "Session {SessionId} loaded {CertificateCount} certificate(s) from '{CACertificateFile}'")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void LoadedCaCertificatesFromFile(ILogger logger, string sessionId, int certificateCount, string caCertificateFile)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__LoadedCaCertificatesFromFileCallback(logger, sessionId, certificateCount, caCertificateFile, null);
		}
	}

	[LoggerMessage(2142, LogLevel.Warning, "Session {SessionId} not using client-provided RemoteCertificateValidationCallback because SslCA is specified")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void NotUsingRemoteCertificateValidationCallbackDueToSslCa(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Warning))
		{
			__NotUsingRemoteCertificateValidationCallbackDueToSslCaCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2143, LogLevel.Warning, "Session {SessionId} not using client-provided RemoteCertificateValidationCallback because SslMode is {SslMode}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void NotUsingRemoteCertificateValidationCallbackDueToSslMode(ILogger logger, string sessionId, MySqlSslMode sslMode)
	{
		if (logger.IsEnabled(LogLevel.Warning))
		{
			__NotUsingRemoteCertificateValidationCallbackDueToSslModeCallback(logger, sessionId, sslMode, null);
		}
	}

	[LoggerMessage(2144, LogLevel.Debug, "Session {SessionId} using client-provided RemoteCertificateValidationCallback")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void UsingRemoteCertificateValidationCallback(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__UsingRemoteCertificateValidationCallbackCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2146, LogLevel.Debug, "Session {SessionId} connected TLS using {SslProtocol}, {CipherAlgorithm}, {HashAlgorithm}, {KeyExchangeAlgorithm}, {KeyExchangeStrength}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ConnectedTlsDetailed(ILogger logger, string sessionId, SslProtocols sslProtocol, CipherAlgorithmType cipherAlgorithm, HashAlgorithmType hashAlgorithm, ExchangeAlgorithmType keyExchangeAlgorithm, int keyExchangeStrength)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__ConnectedTlsDetailedCallback(logger, sessionId, sslProtocol, cipherAlgorithm, hashAlgorithm, keyExchangeAlgorithm, keyExchangeStrength, null);
		}
	}

	[LoggerMessage(2147, LogLevel.Error, "Session {SessionId} couldn't initialize TLS connection")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void CouldNotInitializeTlsConnection(ILogger logger, Exception exception, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__CouldNotInitializeTlsConnectionCallback(logger, sessionId, exception);
		}
	}

	[LoggerMessage(2148, LogLevel.Trace, "Session {SessionId} loading client key from '{ClientKeyFilePath}'")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void LoadingClientKeyFromKeyFile(ILogger logger, string sessionId, string clientKeyFilePath)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__LoadingClientKeyFromKeyFileCallback(logger, sessionId, clientKeyFilePath, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2149, LogLevel.Error, "Session {SessionId} couldn't load client key from '{ClientKeyFilePath}'")]
	public static void CouldNotLoadClientKeyFromKeyFile(ILogger logger, Exception exception, string sessionId, string clientKeyFilePath)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__CouldNotLoadClientKeyFromKeyFileCallback(logger, sessionId, clientKeyFilePath, exception);
		}
	}

	[LoggerMessage(2150, LogLevel.Debug, "Session {SessionId} detected proxy; getting CONNECTION_ID(), VERSION() from server")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void DetectedProxy(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__DetectedProxyCallback(logger, sessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2151, LogLevel.Debug, "Session {SessionId} changing connection id from {OldConnectionId} to {ConnectionId} and server version from {OldServerVersion} to {ServerVersion}")]
	public static void ChangingConnectionId(ILogger logger, string sessionId, int oldConnectionId, int connectionId, string oldServerVersion, string serverVersion)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__ChangingConnectionIdCallback(logger, sessionId, oldConnectionId, connectionId, oldServerVersion, serverVersion, null);
		}
	}

	[LoggerMessage(2152, LogLevel.Information, "Session {SessionId} failed to get CONNECTION_ID(), VERSION()")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void FailedToGetConnectionId(ILogger logger, Exception exception, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__FailedToGetConnectionIdCallback(logger, sessionId, exception);
		}
	}

	[LoggerMessage(2005, LogLevel.Debug, "Session {SessionId} closing stream/socket")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ClosingStreamSocket(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__ClosingStreamSocketCallback(logger, sessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2153, LogLevel.Trace, "Session {SessionId} creating connection attributes")]
	public static void CreatingConnectionAttributes(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__CreatingConnectionAttributesCallback(logger, sessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2154, LogLevel.Trace, "Session {SessionId} obtaining password via ProvidePasswordCallback")]
	public static void ObtainingPasswordViaProvidePasswordCallback(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ObtainingPasswordViaProvidePasswordCallbackCallback(logger, sessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2155, LogLevel.Error, "Session {SessionId} failed to obtain password via ProvidePasswordCallback: {ExceptionMessage}")]
	public static void FailedToObtainPassword(ILogger logger, Exception exception, string sessionId, string exceptionMessage)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__FailedToObtainPasswordCallback(logger, sessionId, exceptionMessage, exception);
		}
	}

	[LoggerMessage(2300, LogLevel.Trace, "Ignoring cancellation for closed connection or invalid command {CommandId}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void IgnoringCancellationForCommand(ILogger logger, int commandId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__IgnoringCancellationForCommandCallback(logger, commandId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2301, LogLevel.Debug, "Command {CommandId} for session {SessionId} has been canceled via {CancellationSource}")]
	public static void CommandHasBeenCanceled(ILogger logger, int commandId, string sessionId, string cancellationSource)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__CommandHasBeenCanceledCallback(logger, commandId, sessionId, cancellationSource, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2302, LogLevel.Information, "Session {SessionId} ignoring cancellation for closed connection")]
	public static void IgnoringCancellationForClosedConnection(ILogger logger, Exception exception, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__IgnoringCancellationForClosedConnectionCallback(logger, sessionId, exception);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2303, LogLevel.Information, "Session {SessionId} cancelling command {CommandId} failed")]
	public static void CancelingCommandFailed(ILogger logger, Exception exception, string sessionId, int commandId)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__CancelingCommandFailedCallback(logger, sessionId, commandId, exception);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2304, LogLevel.Debug, "Session {SessionId} will cancel command {CommandId} ({CancelAttemptCount} attempts); CommandText: {CommandText}")]
	public static void WillCancelCommand(ILogger logger, string sessionId, int commandId, int cancelAttemptCount, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string commandText)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__WillCancelCommandCallback(logger, sessionId, commandId, cancelAttemptCount, commandText, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2305, LogLevel.Information, "Session {SessionId} canceling command {CommandId} from session {CancelingSessionId}; CommandText: {CommandText}")]
	public static void CancelingCommandFromSession(ILogger logger, string sessionId, int commandId, string cancelingSessionId, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string commandText)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__CancelingCommandFromSessionCallback(logger, sessionId, commandId, cancelingSessionId, commandText, null);
		}
	}

	[LoggerMessage(2306, LogLevel.Debug, "Session {SessionId} active command {ActiveCommandId} is not the command {CommandId} being canceled; ignoring cancellation.")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void IgnoringCancellationForInactiveCommand(ILogger logger, string sessionId, int activeCommandId, int commandId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__IgnoringCancellationForInactiveCommandCallback(logger, sessionId, activeCommandId, commandId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2307, LogLevel.Debug, "Session {SessionId} canceling command {CommandId} with text {CommandText}")]
	public static void CancelingCommand(ILogger logger, string sessionId, int commandId, string commandText)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__CancelingCommandCallback(logger, sessionId, commandId, commandText, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2308, LogLevel.Debug, "Session {SessionId} sending 'SLEEP(0)' command to clear pending cancellation")]
	public static void SendingSleepToClearPendingCancellation(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__SendingSleepToClearPendingCancellationCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2400, LogLevel.Trace, "Session {SessionId} getting cached procedure named {ProcedureName}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void GettingCachedProcedure(ILogger logger, string sessionId, string procedureName)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__GettingCachedProcedureCallback(logger, sessionId, procedureName, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2401, LogLevel.Information, "Session {SessionId} pool {PoolId} doesn't have a shared procedure cache; procedure will only be cached on this connection")]
	public static void PoolDoesNotHaveSharedProcedureCache(ILogger logger, string sessionId, int? poolId)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__PoolDoesNotHaveSharedProcedureCacheCallback(logger, sessionId, poolId, null);
		}
	}

	[LoggerMessage(2402, LogLevel.Information, "Session {SessionId} couldn't normalize the name '{ProcedureName}' in database {Database}; not caching procedure")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void CouldNotNormalizeDatabaseAndName(ILogger logger, string sessionId, string procedureName, string database)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__CouldNotNormalizeDatabaseAndNameCallback(logger, sessionId, procedureName, database, null);
		}
	}

	[LoggerMessage(2403, LogLevel.Information, "Session {SessionId} failed to cache procedure {Schema}.{Component}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void FailedToCacheProcedure(ILogger logger, string sessionId, string schema, string component)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__FailedToCacheProcedureCallback(logger, sessionId, schema, component, null);
		}
	}

	[LoggerMessage(2404, LogLevel.Trace, "Session {SessionId} caching procedure {Schema}.{Component}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void CachingProcedure(ILogger logger, string sessionId, string schema, string component)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__CachingProcedureCallback(logger, sessionId, schema, component, null);
		}
	}

	[LoggerMessage(2405, LogLevel.Trace, "Session {SessionId} procedure cache count is {ProcedureCacheCount}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ProcedureCacheCount(ILogger logger, string sessionId, int procedureCacheCount)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ProcedureCacheCountCallback(logger, sessionId, procedureCacheCount, null);
		}
	}

	[LoggerMessage(2406, LogLevel.Information, "Session {SessionId} did not find cached procedure {Schema}.{Component}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void DidNotFindCachedProcedure(ILogger logger, string sessionId, string schema, string component)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__DidNotFindCachedProcedureCallback(logger, sessionId, schema, component, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2407, LogLevel.Trace, "Session {SessionId} returning cached procedure {Schema}.{Component}")]
	public static void ReturningCachedProcedure(ILogger logger, string sessionId, string schema, string component)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ReturningCachedProcedureCallback(logger, sessionId, schema, component, null);
		}
	}

	[LoggerMessage(2408, LogLevel.Information, "Session {SessionId} failed to retrieve metadata for {Schema}.{Component}; falling back to INFORMATION_SCHEMA: {ExceptionMessage}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void FailedToRetrieveProcedureMetadata(ILogger logger, Exception exception, string sessionId, string schema, string component, string exceptionMessage)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__FailedToRetrieveProcedureMetadataCallback(logger, sessionId, schema, component, exceptionMessage, exception);
		}
	}

	[LoggerMessage(2409, LogLevel.Information, "Session {SessionId} server version {ServerVersion} does not support cached procedures")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ServerDoesNotSupportCachedProcedures(ILogger logger, string sessionId, string serverVersion)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__ServerDoesNotSupportCachedProceduresCallback(logger, sessionId, serverVersion, null);
		}
	}

	[LoggerMessage(2410, LogLevel.Trace, "Procedure for {Schema}.{Component} has {RoutineCount} routines and {ParameterCount} parameters")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ProcedureHasRoutineCount(ILogger logger, string schema, string component, int routineCount, int parameterCount)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ProcedureHasRoutineCountCallback(logger, schema, component, routineCount, parameterCount, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2000, LogLevel.Trace, "Created new session {SessionId}")]
	public static void CreatedNewSession(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__CreatedNewSessionCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2500, LogLevel.Trace, "Session {SessionId} pinging server")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void PingingServer(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__PingingServerCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(EventId = 2501, Message = "Session {SessionId} successfully pinged server")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void SuccessfullyPingedServer(ILogger logger, LogLevel logLevel, string sessionId)
	{
		if (logger.IsEnabled(logLevel))
		{
			logger.Log(logLevel, new EventId(2501, "SuccessfullyPingedServer"), new __SuccessfullyPingedServerStruct(sessionId), null, __SuccessfullyPingedServerStruct.Format);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2502, LogLevel.Trace, "Session {SessionId} ping failed due to {Failure}")]
	public static void PingFailed(ILogger logger, Exception exception, string sessionId, string failure)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__PingFailedCallback(logger, sessionId, failure, exception);
		}
	}

	[LoggerMessage(2009, LogLevel.Debug, "Session {SessionId} setting state to Failed")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void SettingStateToFailed(ILogger logger, Exception exception, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__SettingStateToFailedCallback(logger, sessionId, exception);
		}
	}

	[LoggerMessage(2010, LogLevel.Error, "Session {SessionId} expected to read {ExpectedByteCount} bytes but only read {ReadByteCount}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ExpectedToReadMoreBytes(ILogger logger, string sessionId, int expectedByteCount, int readByteCount)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__ExpectedToReadMoreBytesCallback(logger, sessionId, expectedByteCount, readByteCount, null);
		}
	}

	[LoggerMessage(2006, LogLevel.Debug, "Session {SessionId} got error payload: {ErrorCode}, {State}, {Message}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ErrorPayload(ILogger logger, string sessionId, int errorCode, string state, string message)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__ErrorPayloadCallback(logger, sessionId, errorCode, state, message, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2202, LogLevel.Trace, "Session {SessionId} ExecuteReader {IOBehavior} for {CommandCount} command(s)")]
	public static void CommandExecutorExecuteReader(ILogger logger, string sessionId, IOBehavior ioBehavior, int commandCount)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__CommandExecutorExecuteReaderCallback(logger, sessionId, ioBehavior, commandCount, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2203, LogLevel.Information, "Session {SessionId} query was interrupted")]
	public static void QueryWasInterrupted(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__QueryWasInterruptedCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2204, LogLevel.Trace, "Session {SessionId} preparing command payload for: {CommandText}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void PreparingCommandPayload(ILogger logger, string sessionId, string commandText)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__PreparingCommandPayloadCallback(logger, sessionId, commandText, null);
		}
	}

	[LoggerMessage(2205, LogLevel.Trace, "Session {SessionId} preparing statement payload with ID {StatementId} for: {CommandText}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void PreparingCommandPayloadWithId(ILogger logger, string sessionId, int statementId, string commandText)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__PreparingCommandPayloadWithIdCallback(logger, sessionId, statementId, commandText, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2206, LogLevel.Warning, "Session {SessionId} has query attributes but server doesn't support them; CommandText: {CommandText}")]
	public static void QueryAttributesNotSupported(ILogger logger, string sessionId, string commandText)
	{
		if (logger.IsEnabled(LogLevel.Warning))
		{
			__QueryAttributesNotSupportedCallback(logger, sessionId, commandText, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2207, LogLevel.Warning, "Session {SessionId} has attributes for statement {StatementId} but the server does not support them")]
	public static void QueryAttributesNotSupportedWithId(ILogger logger, string sessionId, int statementId)
	{
		if (logger.IsEnabled(LogLevel.Warning))
		{
			__QueryAttributesNotSupportedWithIdCallback(logger, sessionId, statementId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2208, LogLevel.Warning, "Session {SessionId} ignoring exception in MySqlDataReader.DisposeAsync. Message: {ExceptionMessage}. CommandText: {CommandText}")]
	public static void IgnoringExceptionInDisposeAsync(ILogger logger, Exception exception, string sessionId, string exceptionMessage, string commandText)
	{
		if (logger.IsEnabled(LogLevel.Warning))
		{
			__IgnoringExceptionInDisposeAsyncCallback(logger, sessionId, exceptionMessage, commandText, exception);
		}
	}

	[LoggerMessage(2503, LogLevel.Debug, "Starting bulk copy to {TableName}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void StartingBulkCopy(ILogger logger, string tableName)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__StartingBulkCopyCallback(logger, tableName, null);
		}
	}

	[LoggerMessage(2504, LogLevel.Debug, "Adding default column mapping from {SourceOrdinal} to {DestinationColumn}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void AddingDefaultColumnMapping(ILogger logger, int sourceOrdinal, string destinationColumn)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__AddingDefaultColumnMappingCallback(logger, sourceOrdinal, destinationColumn, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2505, LogLevel.Debug, "Ignoring column with source ordinal {SourceOrdinal}")]
	public static void IgnoringColumn(ILogger logger, int sourceOrdinal)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__IgnoringColumnCallback(logger, sourceOrdinal, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2506, LogLevel.Debug, "Finished bulk copy to {TableName}")]
	public static void FinishedBulkCopy(ILogger logger, string tableName)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__FinishedBulkCopyCallback(logger, tableName, null);
		}
	}

	[LoggerMessage(2507, LogLevel.Error, "Bulk copy to {TableName} failed: {RowsCopied} row(s) copied; {RowsInserted} row(s) inserted")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void BulkCopyFailed(ILogger logger, string tableName, int rowsCopied, int rowsInserted)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__BulkCopyFailedCallback(logger, tableName, rowsCopied, rowsInserted, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2508, LogLevel.Information, "Column mapping for {SourceOrdinal} to {DestinationColumn} already has expression {Expression}")]
	public static void ColumnMappingAlreadyHasExpression(ILogger logger, int sourceOrdinal, string destinationColumn, string expression)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__ColumnMappingAlreadyHasExpressionCallback(logger, sourceOrdinal, destinationColumn, expression, null);
		}
	}

	[LoggerMessage(2509, LogLevel.Trace, "Setting expression to map column {SourceOrdinal} to {DestinationColumn}: {Expression}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void SettingExpressionToMapColumn(ILogger logger, int sourceOrdinal, string destinationColumn, string expression)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__SettingExpressionToMapColumnCallback(logger, sourceOrdinal, destinationColumn, expression, null);
		}
	}

	[LoggerMessage(2700, LogLevel.Debug, "Session {SessionId} starting transaction")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void StartingTransaction(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__StartingTransactionCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2701, LogLevel.Trace, "Session {SessionId} started transaction")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void StartedTransaction(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__StartedTransactionCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2702, LogLevel.Trace, "Session {SessionId} committing transaction")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void CommittingTransaction(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__CommittingTransactionCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2703, LogLevel.Debug, "Session {SessionId} committed transaction")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void CommittedTransaction(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__CommittedTransactionCallback(logger, sessionId, null);
		}
	}

	[LoggerMessage(2704, LogLevel.Trace, "Session {SessionId} rolling back transaction")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void RollingBackTransaction(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__RollingBackTransactionCallback(logger, sessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2705, LogLevel.Debug, "Session {SessionId} rolled back transaction")]
	public static void RolledBackTransaction(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__RolledBackTransactionCallback(logger, sessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3000, LogLevel.Trace, "Pool {PoolId} waiting for an available session")]
	public static void WaitingForAvailableSession(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__WaitingForAvailableSessionCallback(logger, poolId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2008, LogLevel.Debug, "Session {SessionId} failed in ReceiveReplyAsync")]
	public static void FailedInReceiveReplyAsync(ILogger logger, Exception exception, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__FailedInReceiveReplyAsyncCallback(logger, sessionId, exception);
		}
	}

	[LoggerMessage(2007, LogLevel.Debug, "Session {SessionId} failed in SendReplyAsync")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void FailedInSendReplyAsync(ILogger logger, Exception exception, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__FailedInSendReplyAsyncCallback(logger, sessionId, exception);
		}
	}

	[LoggerMessage(3001, LogLevel.Information, "Creating new connection pool {PoolId} for {ConnectionString}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void CreatingNewConnectionPool(ILogger logger, int poolId, string connectionString)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__CreatingNewConnectionPoolCallback(logger, poolId, connectionString, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3002, LogLevel.Debug, "Pool {PoolId} is empty; scanning for any leaked sessions")]
	public static void ScanningForLeakedSessions(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__ScanningForLeakedSessionsCallback(logger, poolId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3003, LogLevel.Trace, "Pool {PoolId} found an existing session; checking it for validity")]
	public static void FoundExistingSession(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__FoundExistingSessionCallback(logger, poolId, null);
		}
	}

	[LoggerMessage(3004, LogLevel.Trace, "Pool {PoolId} discarding session due to wrong generation")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void DiscardingSessionDueToWrongGeneration(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__DiscardingSessionDueToWrongGenerationCallback(logger, poolId, null);
		}
	}

	[LoggerMessage(3005, LogLevel.Information, "Pool {PoolId} session {SessionId} is unusable; destroying it")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void SessionIsUnusable(ILogger logger, int poolId, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__SessionIsUnusableCallback(logger, poolId, sessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3006, LogLevel.Trace, "Pool {PoolId} returning pooled session {SessionId} to caller; {LeasedSessionCount} leased session(s)")]
	public static void ReturningPooledSession(ILogger logger, int poolId, string sessionId, int leasedSessionCount)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ReturningPooledSessionCallback(logger, poolId, sessionId, leasedSessionCount, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3007, LogLevel.Trace, "Pool {PoolId} returning new session {SessionId} to caller; {LeasedSessionCount} leased session(s)")]
	public static void ReturningNewSession(ILogger logger, int poolId, string sessionId, int leasedSessionCount)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ReturningNewSessionCallback(logger, poolId, sessionId, leasedSessionCount, null);
		}
	}

	[LoggerMessage(3008, LogLevel.Debug, "Pool {PoolId} disposing created session {SessionId} due to exception: {ExceptionMessage}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void DisposingCreatedSessionDueToException(ILogger logger, Exception exception, int poolId, string sessionId, string exceptionMessage)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__DisposingCreatedSessionDueToExceptionCallback(logger, poolId, sessionId, exceptionMessage, exception);
		}
	}

	[LoggerMessage(3009, LogLevel.Warning, "Pool {PoolId} unexpected error in GetSessionAsync: {ExceptionMessage}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void UnexpectedErrorInGetSessionAsync(ILogger logger, Exception exception, int poolId, string exceptionMessage)
	{
		if (logger.IsEnabled(LogLevel.Warning))
		{
			__UnexpectedErrorInGetSessionAsyncCallback(logger, poolId, exceptionMessage, exception);
		}
	}

	[LoggerMessage(3010, LogLevel.Trace, "Pool {PoolId} receiving session {SessionId} back")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ReceivingSessionBack(ILogger logger, int poolId, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ReceivingSessionBackCallback(logger, poolId, sessionId, null);
		}
	}

	[LoggerMessage(3011, LogLevel.Information, "Pool {PoolId} received invalid session {SessionId}; destroying it")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ReceivedInvalidSession(ILogger logger, int poolId, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__ReceivedInvalidSessionCallback(logger, poolId, sessionId, null);
		}
	}

	[LoggerMessage(3012, LogLevel.Debug, "Pool {PoolId} received expired session {SessionId}; destroying it")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ReceivedExpiredSession(ILogger logger, int poolId, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__ReceivedExpiredSessionCallback(logger, poolId, sessionId, null);
		}
	}

	[LoggerMessage(3013, LogLevel.Information, "Pool {PoolId} clearing connection pool")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void ClearingConnectionPool(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__ClearingConnectionPoolCallback(logger, poolId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3014, LogLevel.Debug, "Pool {PoolId} disposing connection pool")]
	public static void DisposingConnectionPool(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__DisposingConnectionPoolCallback(logger, poolId, null);
		}
	}

	[LoggerMessage(3015, LogLevel.Trace, "Pool {PoolId} recovered no sessions")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	public static void RecoveredNoSessions(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__RecoveredNoSessionsCallback(logger, poolId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3016, LogLevel.Warning, "Pool {PoolId} recovered {SessionCount} sessions")]
	public static void RecoveredSessionCount(ILogger logger, int poolId, int sessionCount)
	{
		if (logger.IsEnabled(LogLevel.Warning))
		{
			__RecoveredSessionCountCallback(logger, poolId, sessionCount, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3017, LogLevel.Debug, "Pool {PoolId} found session {SessionId} to clean up")]
	public static void FoundSessionToCleanUp(ILogger logger, int poolId, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__FoundSessionToCleanUpCallback(logger, poolId, sessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3200, LogLevel.Trace, "Session {SessionId} has server redirection header {Header}")]
	public static void HasServerRedirectionHeader(ILogger logger, string sessionId, string header)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__HasServerRedirectionHeaderCallback(logger, sessionId, header, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3201, LogLevel.Trace, "Pool {PoolId} server redirection is disabled; ignoring redirection")]
	public static void ServerRedirectionIsDisabled(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ServerRedirectionIsDisabledCallback(logger, poolId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3202, LogLevel.Debug, "Pool {PoolId} opening new connection to {Host}:{Port} as {User}")]
	public static void OpeningNewConnection(ILogger logger, int poolId, string host, int port, string user)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__OpeningNewConnectionCallback(logger, poolId, host, port, user, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3203, LogLevel.Information, "Pool {PoolId} failed to connect redirected session {SessionId}")]
	public static void FailedToConnectRedirectedSession(ILogger logger, Exception ex, int poolId, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__FailedToConnectRedirectedSessionCallback(logger, poolId, sessionId, ex);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3204, LogLevel.Trace, "Pool {PoolId} closing session {SessionId} to use redirected session {RedirectedSessionId} instead")]
	public static void ClosingSessionToUseRedirectedSession(ILogger logger, int poolId, string sessionId, string redirectedSessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ClosingSessionToUseRedirectedSessionCallback(logger, poolId, sessionId, redirectedSessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3205, LogLevel.Trace, "Session {SessionId} is already connected to this server; ignoring redirection")]
	public static void SessionAlreadyConnectedToServer(ILogger logger, string sessionId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__SessionAlreadyConnectedToServerCallback(logger, sessionId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3206, LogLevel.Error, "Pool {PoolId} requires server redirection but server doesn't support it")]
	public static void RequiresServerRedirection(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__RequiresServerRedirectionCallback(logger, poolId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3020, LogLevel.Debug, "Pool {PoolId} was created but will not be used (due to race)")]
	public static void CreatedPoolWillNotBeUsed(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__CreatedPoolWillNotBeUsedCallback(logger, poolId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3100, LogLevel.Trace, "Pool {PoolId} reaping connection pool")]
	public static void ReapingConnectionPool(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__ReapingConnectionPoolCallback(logger, poolId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3101, LogLevel.Trace, "Pool {PoolId} checking for DNS changes")]
	public static void CheckingForDnsChanges(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__CheckingForDnsChangesCallback(logger, poolId, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3102, LogLevel.Debug, "Pool {PoolId} detected DNS change for '{HostName}': {OldAddresses} to {NewAddresses}")]
	public static void DetectedDnsChange(ILogger logger, int poolId, string hostName, string oldAddresses, string newAddresses)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__DetectedDnsChangeCallback(logger, poolId, hostName, oldAddresses, newAddresses, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3103, LogLevel.Debug, "Pool {PoolId} DNS check failed; ignoring '{HostName}': {ExceptionMessage}")]
	public static void DnsCheckFailed(ILogger logger, Exception exception, int poolId, string hostName, string exceptionMessage)
	{
		if (logger.IsEnabled(LogLevel.Debug))
		{
			__DnsCheckFailedCallback(logger, poolId, hostName, exceptionMessage, exception);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(3104, LogLevel.Information, "Pool {PoolId} clearing pool due to DNS changes")]
	public static void ClearingPoolDueToDnsChanges(ILogger logger, int poolId)
	{
		if (logger.IsEnabled(LogLevel.Information))
		{
			__ClearingPoolDueToDnsChangesCallback(logger, poolId, null);
		}
	}
}


using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[EditorBrowsable(EditorBrowsableState.Never)]
private readonly struct __SessionMadeConnectionStruct : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	private readonly string _sessionId;

	private readonly string _serverVersion;

	private readonly int _connectionId;

	private readonly bool _supportsCompression;

	private readonly bool _supportsAttributes;

	private readonly bool _supportsDeprecateEof;

	private readonly bool _supportsCachedMetadata;

	private readonly bool _supportsSsl;

	private readonly bool _supportsSessionTrack;

	private readonly bool _supportsPipelining;

	private readonly bool _supportsQueryAttributes;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2, 1 })]
	public static readonly Func<__SessionMadeConnectionStruct, Exception, string> Format = (__SessionMadeConnectionStruct state, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception ex) => state.ToString();

	public int Count => 12;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
	public KeyValuePair<string, object> this[int index]
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
		get
		{
			return index switch
			{
				0 => new KeyValuePair<string, object>("SessionId", _sessionId), 
				1 => new KeyValuePair<string, object>("ServerVersion", _serverVersion), 
				2 => new KeyValuePair<string, object>("ConnectionId", _connectionId), 
				3 => new KeyValuePair<string, object>("SupportsCompression", _supportsCompression), 
				4 => new KeyValuePair<string, object>("SupportsAttributes", _supportsAttributes), 
				5 => new KeyValuePair<string, object>("SupportsDeprecateEof", _supportsDeprecateEof), 
				6 => new KeyValuePair<string, object>("SupportsCachedMetadata", _supportsCachedMetadata), 
				7 => new KeyValuePair<string, object>("SupportsSsl", _supportsSsl), 
				8 => new KeyValuePair<string, object>("SupportsSessionTrack", _supportsSessionTrack), 
				9 => new KeyValuePair<string, object>("SupportsPipelining", _supportsPipelining), 
				10 => new KeyValuePair<string, object>("SupportsQueryAttributes", _supportsQueryAttributes), 
				11 => new KeyValuePair<string, object>("{OriginalFormat}", "Session {SessionId} made connection; server version {ServerVersion}; connection ID {ConnectionId}; supports: compression {SupportsCompression}, attributes {SupportsAttributes}, deprecate EOF {SupportsDeprecateEof}, cached metadata {SupportsCachedMetadata}, SSL {SupportsSsl}, session track {SupportsSessionTrack}, pipelining {SupportsPipelining}, query attributes {SupportsQueryAttributes}"), 
				_ => throw new IndexOutOfRangeException("index"), 
			};
		}
	}

	public __SessionMadeConnectionStruct(string sessionId, string serverVersion, int connectionId, bool supportsCompression, bool supportsAttributes, bool supportsDeprecateEof, bool supportsCachedMetadata, bool supportsSsl, bool supportsSessionTrack, bool supportsPipelining, bool supportsQueryAttributes)
	{
		_sessionId = sessionId;
		_serverVersion = serverVersion;
		_connectionId = connectionId;
		_supportsCompression = supportsCompression;
		_supportsAttributes = supportsAttributes;
		_supportsDeprecateEof = supportsDeprecateEof;
		_supportsCachedMetadata = supportsCachedMetadata;
		_supportsSsl = supportsSsl;
		_supportsSessionTrack = supportsSessionTrack;
		_supportsPipelining = supportsPipelining;
		_supportsQueryAttributes = supportsQueryAttributes;
	}

	public override string ToString()
	{
		string sessionId = _sessionId;
		string serverVersion = _serverVersion;
		int connectionId = _connectionId;
		bool supportsCompression = _supportsCompression;
		bool supportsAttributes = _supportsAttributes;
		bool supportsDeprecateEof = _supportsDeprecateEof;
		bool supportsCachedMetadata = _supportsCachedMetadata;
		bool supportsSsl = _supportsSsl;
		bool supportsSessionTrack = _supportsSessionTrack;
		bool supportsPipelining = _supportsPipelining;
		bool supportsQueryAttributes = _supportsQueryAttributes;
		return $"Session {sessionId} made connection; server version {serverVersion}; connection ID {connectionId}; supports: compression {supportsCompression}, attributes {supportsAttributes}, deprecate EOF {supportsDeprecateEof}, cached metadata {supportsCachedMetadata}, SSL {supportsSsl}, session track {supportsSessionTrack}, pipelining {supportsPipelining}, query attributes {supportsQueryAttributes}";
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		for (int i = 0; i < 12; i++)
		{
			yield return this[i];
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[EditorBrowsable(EditorBrowsableState.Never)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
private readonly struct __ConnectingToIpAddressStruct : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	private readonly string _sessionId;

	private readonly string _ipAddress;

	private readonly int _ipAddressIndex;

	private readonly int _ipAddressCount;

	private readonly string _hostName;

	private readonly int _hostNameIndex;

	private readonly int _hostNameCount;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2, 1 })]
	public static readonly Func<__ConnectingToIpAddressStruct, Exception, string> Format = (__ConnectingToIpAddressStruct state, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception ex) => state.ToString();

	public int Count => 8;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
	public KeyValuePair<string, object> this[int index]
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
		get
		{
			return index switch
			{
				0 => new KeyValuePair<string, object>("SessionId", _sessionId), 
				1 => new KeyValuePair<string, object>("IpAddress", _ipAddress), 
				2 => new KeyValuePair<string, object>("IpAddressIndex", _ipAddressIndex), 
				3 => new KeyValuePair<string, object>("IpAddressCount", _ipAddressCount), 
				4 => new KeyValuePair<string, object>("HostName", _hostName), 
				5 => new KeyValuePair<string, object>("HostNameIndex", _hostNameIndex), 
				6 => new KeyValuePair<string, object>("HostNameCount", _hostNameCount), 
				7 => new KeyValuePair<string, object>("{OriginalFormat}", "Session {SessionId} connecting to IP address {IpAddress} ({IpAddressIndex} of {IpAddressCount}) for host name {HostName} ({HostNameIndex} of {HostNameCount})"), 
				_ => throw new IndexOutOfRangeException("index"), 
			};
		}
	}

	public __ConnectingToIpAddressStruct(string sessionId, string ipAddress, int ipAddressIndex, int ipAddressCount, string hostName, int hostNameIndex, int hostNameCount)
	{
		_sessionId = sessionId;
		_ipAddress = ipAddress;
		_ipAddressIndex = ipAddressIndex;
		_ipAddressCount = ipAddressCount;
		_hostName = hostName;
		_hostNameIndex = hostNameIndex;
		_hostNameCount = hostNameCount;
	}

	public override string ToString()
	{
		string sessionId = _sessionId;
		string ipAddress = _ipAddress;
		int ipAddressIndex = _ipAddressIndex;
		int ipAddressCount = _ipAddressCount;
		string hostName = _hostName;
		int hostNameIndex = _hostNameIndex;
		int hostNameCount = _hostNameCount;
		return $"Session {sessionId} connecting to IP address {ipAddress} ({ipAddressIndex} of {ipAddressCount}) for host name {hostName} ({hostNameIndex} of {hostNameCount})";
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		for (int i = 0; i < 8; i++)
		{
			yield return this[i];
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
[EditorBrowsable(EditorBrowsableState.Never)]
private readonly struct __FailedToConnectToIpAddressStruct : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	private readonly string _sessionId;

	private readonly string _ipAddress;

	private readonly int _ipAddressIndex;

	private readonly int _ipAddressCount;

	private readonly string _hostName;

	private readonly int _hostNameIndex;

	private readonly int _hostNameCount;

	private readonly string _exceptionMessage;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2, 1 })]
	public static readonly Func<__FailedToConnectToIpAddressStruct, Exception, string> Format = (__FailedToConnectToIpAddressStruct state, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception ex) => state.ToString();

	public int Count => 9;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
	public KeyValuePair<string, object> this[int index]
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
		get
		{
			return index switch
			{
				0 => new KeyValuePair<string, object>("SessionId", _sessionId), 
				1 => new KeyValuePair<string, object>("IpAddress", _ipAddress), 
				2 => new KeyValuePair<string, object>("IpAddressIndex", _ipAddressIndex), 
				3 => new KeyValuePair<string, object>("IpAddressCount", _ipAddressCount), 
				4 => new KeyValuePair<string, object>("HostName", _hostName), 
				5 => new KeyValuePair<string, object>("HostNameIndex", _hostNameIndex), 
				6 => new KeyValuePair<string, object>("HostNameCount", _hostNameCount), 
				7 => new KeyValuePair<string, object>("ExceptionMessage", _exceptionMessage), 
				8 => new KeyValuePair<string, object>("{OriginalFormat}", "Session {SessionId} failed to connect to IP address {IpAddress} ({IpAddressIndex} of {IpAddressCount}) for host name {HostName} ({HostNameIndex} of {HostNameCount}): {ExceptionMessage}"), 
				_ => throw new IndexOutOfRangeException("index"), 
			};
		}
	}

	public __FailedToConnectToIpAddressStruct(string sessionId, string ipAddress, int ipAddressIndex, int ipAddressCount, string hostName, int hostNameIndex, int hostNameCount, string exceptionMessage)
	{
		_sessionId = sessionId;
		_ipAddress = ipAddress;
		_ipAddressIndex = ipAddressIndex;
		_ipAddressCount = ipAddressCount;
		_hostName = hostName;
		_hostNameIndex = hostNameIndex;
		_hostNameCount = hostNameCount;
		_exceptionMessage = exceptionMessage;
	}

	public override string ToString()
	{
		string sessionId = _sessionId;
		string ipAddress = _ipAddress;
		int ipAddressIndex = _ipAddressIndex;
		int ipAddressCount = _ipAddressCount;
		string hostName = _hostName;
		int hostNameIndex = _hostNameIndex;
		int hostNameCount = _hostNameCount;
		string exceptionMessage = _exceptionMessage;
		return $"Session {sessionId} failed to connect to IP address {ipAddress} ({ipAddressIndex} of {ipAddressCount}) for host name {hostName} ({hostNameIndex} of {hostNameCount}): {exceptionMessage}";
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		for (int i = 0; i < 9; i++)
		{
			yield return this[i];
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
private readonly struct __CouldNotLoadCaCertificateFromFileStruct : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	private readonly string _sessionId;

	private readonly string _caCertificateFile;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2, 1 })]
	public static readonly Func<__CouldNotLoadCaCertificateFromFileStruct, Exception, string> Format = (__CouldNotLoadCaCertificateFromFileStruct state, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception ex) => state.ToString();

	public int Count => 3;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
	public KeyValuePair<string, object> this[int index]
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
		get
		{
			return index switch
			{
				0 => new KeyValuePair<string, object>("SessionId", _sessionId), 
				1 => new KeyValuePair<string, object>("CACertificateFile", _caCertificateFile), 
				2 => new KeyValuePair<string, object>("{OriginalFormat}", "Session {SessionId} couldn't load CA certificate from '{CACertificateFile}'"), 
				_ => throw new IndexOutOfRangeException("index"), 
			};
		}
	}

	public __CouldNotLoadCaCertificateFromFileStruct(string sessionId, string caCertificateFile)
	{
		_sessionId = sessionId;
		_caCertificateFile = caCertificateFile;
	}

	public override string ToString()
	{
		string sessionId = _sessionId;
		string caCertificateFile = _caCertificateFile;
		return "Session " + sessionId + " couldn't load CA certificate from '" + caCertificateFile + "'";
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		for (int i = 0; i < 3; i++)
		{
			yield return this[i];
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
[EditorBrowsable(EditorBrowsableState.Never)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
private readonly struct __SuccessfullyPingedServerStruct : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	private readonly string _sessionId;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2, 1 })]
	public static readonly Func<__SuccessfullyPingedServerStruct, Exception, string> Format = (__SuccessfullyPingedServerStruct state, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception ex) => state.ToString();

	public int Count => 2;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
	public KeyValuePair<string, object> this[int index]
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
		get
		{
			return index switch
			{
				0 => new KeyValuePair<string, object>("SessionId", _sessionId), 
				1 => new KeyValuePair<string, object>("{OriginalFormat}", "Session {SessionId} successfully pinged server"), 
				_ => throw new IndexOutOfRangeException("index"), 
			};
		}
	}

	public __SuccessfullyPingedServerStruct(string sessionId)
	{
		_sessionId = sessionId;
	}

	public override string ToString()
	{
		string sessionId = _sessionId;
		return "Session " + sessionId + " successfully pinged server";
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		for (int i = 0; i < 2; i++)
		{
			yield return this[i];
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System.Runtime.CompilerServices;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using MySqlConnector.Logging;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class MySqlConnectorLoggingConfiguration
{
	public ILogger DataSourceLogger { get; } = loggerFactory.CreateLogger("MySqlConnector.MySqlDataSource");

	public ILogger ConnectionLogger { get; } = loggerFactory.CreateLogger("MySqlConnector.MySqlConnection");

	public ILogger CommandLogger { get; } = loggerFactory.CreateLogger("MySqlConnector.MySqlCommand");

	public ILogger PoolLogger { get; } = loggerFactory.CreateLogger("MySqlConnector.ConnectionPool");

	public ILogger BulkCopyLogger { get; } = loggerFactory.CreateLogger("MySqlConnector.MySqlBulkCopy");

	public ILogger TransactionLogger { get; } = loggerFactory.CreateLogger("MySqlConnector.Transaction");

	public static MySqlConnectorLoggingConfiguration NullConfiguration { get; } = new MySqlConnectorLoggingConfiguration(NullLoggerFactory.Instance);

	public static MySqlConnectorLoggingConfiguration GlobalConfiguration { get; set; } = NullConfiguration;

	public MySqlConnectorLoggingConfiguration(ILoggerFactory loggerFactory)
	{
	}
}


public enum MySqlConnectorLogLevel
{
	Trace = 1,
	Debug,
	Info,
	Warn,
	Error,
	Fatal
}


using System;
using System.Runtime.CompilerServices;
using Microsoft.Extensions.Logging;
using MySqlConnector.Logging;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public static class MySqlConnectorLogManager
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private sealed class MySqlConnectorLoggerFactory(IMySqlConnectorLoggerProvider loggerProvider) : ILoggerFactory, IDisposable
	{
		public void AddProvider(ILoggerProvider provider)
		{
			throw new NotSupportedException();
		}

		public ILogger CreateLogger(string categoryName)
		{
			return new MySqlConnectorLogger(loggerProvider.CreateLogger(categoryName.Substring(15, categoryName.Length - 15)));
		}

		public void Dispose()
		{
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private sealed class MySqlConnectorLogger(IMySqlConnectorLogger logger) : ILogger
	{
		public IDisposable BeginScope<TState>(TState state)
		{
			throw new NotSupportedException();
		}

		public bool IsEnabled(LogLevel logLevel)
		{
			return logger.IsEnabled(ConvertLogLevel(logLevel));
		}

		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		public void Log<TState>(LogLevel logLevel, EventId eventId, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] TState state, Exception exception, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2, 1 })] Func<TState, Exception, string> formatter)
		{
			logger.Log(ConvertLogLevel(logLevel), formatter(state, exception), null, exception);
		}

		private static MySqlConnectorLogLevel ConvertLogLevel(LogLevel logLevel)
		{
			return logLevel switch
			{
				LogLevel.Trace => MySqlConnectorLogLevel.Trace, 
				LogLevel.Debug => MySqlConnectorLogLevel.Debug, 
				LogLevel.Information => MySqlConnectorLogLevel.Info, 
				LogLevel.Warning => MySqlConnectorLogLevel.Warn, 
				LogLevel.Error => MySqlConnectorLogLevel.Error, 
				LogLevel.Critical => MySqlConnectorLogLevel.Fatal, 
				_ => MySqlConnectorLogLevel.Info, 
			};
		}
	}

	public static IMySqlConnectorLoggerProvider Provider
	{
		set
		{
			MySqlConnectorLoggingConfiguration.GlobalConfiguration = new MySqlConnectorLoggingConfiguration(new MySqlConnectorLoggerFactory(value));
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using Microsoft.Extensions.Logging;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
private sealed class MySqlConnectorLoggerFactory(IMySqlConnectorLoggerProvider loggerProvider) : ILoggerFactory, IDisposable
{
	public void AddProvider(ILoggerProvider provider)
	{
		throw new NotSupportedException();
	}

	public ILogger CreateLogger(string categoryName)
	{
		return new MySqlConnectorLogger(loggerProvider.CreateLogger(categoryName.Substring(15, categoryName.Length - 15)));
	}

	public void Dispose()
	{
	}
}


using System;
using System.Runtime.CompilerServices;
using Microsoft.Extensions.Logging;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
private sealed class MySqlConnectorLogger(IMySqlConnectorLogger logger) : ILogger
{
	public IDisposable BeginScope<TState>(TState state)
	{
		throw new NotSupportedException();
	}

	public bool IsEnabled(LogLevel logLevel)
	{
		return logger.IsEnabled(ConvertLogLevel(logLevel));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public void Log<TState>(LogLevel logLevel, EventId eventId, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] TState state, Exception exception, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2, 1 })] Func<TState, Exception, string> formatter)
	{
		logger.Log(ConvertLogLevel(logLevel), formatter(state, exception), null, exception);
	}

	private static MySqlConnectorLogLevel ConvertLogLevel(LogLevel logLevel)
	{
		return logLevel switch
		{
			LogLevel.Trace => MySqlConnectorLogLevel.Trace, 
			LogLevel.Debug => MySqlConnectorLogLevel.Debug, 
			LogLevel.Information => MySqlConnectorLogLevel.Info, 
			LogLevel.Warning => MySqlConnectorLogLevel.Warn, 
			LogLevel.Error => MySqlConnectorLogLevel.Error, 
			LogLevel.Critical => MySqlConnectorLogLevel.Fatal, 
			_ => MySqlConnectorLogLevel.Info, 
		};
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.Logging;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public sealed class NoOpLogger : IMySqlConnectorLogger
{
	public static IMySqlConnectorLogger Instance { get; } = new NoOpLogger();

	public bool IsEnabled(MySqlConnectorLogLevel level)
	{
		return false;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public void Log(MySqlConnectorLogLevel level, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] string message, object[] args = null, Exception exception = null)
	{
	}
}


using System.Runtime.CompilerServices;
using MySqlConnector.Logging;

public sealed class NoOpLoggerProvider : IMySqlConnectorLoggerProvider
{
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public IMySqlConnectorLogger CreateLogger(string name)
	{
		return NoOpLogger.Instance;
	}
}


using System;
using System.Data;
using System.Runtime.CompilerServices;
using MySqlConnector;
using MySqlConnector.Core;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class CachedParameter
{
	public int Position { get; }

	public ParameterDirection Direction { get; }

	public string Name { get; }

	public MySqlDbType MySqlDbType { get; }

	public int Length { get; }

	public CachedParameter(int ordinalPosition, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string mode, string name, string dataType, bool unsigned, int length)
	{
		Position = ordinalPosition;
		if (Position == 0)
		{
			Direction = ParameterDirection.ReturnValue;
		}
		else if (string.Equals(mode, "in", StringComparison.OrdinalIgnoreCase))
		{
			Direction = ParameterDirection.Input;
		}
		else if (string.Equals(mode, "inout", StringComparison.OrdinalIgnoreCase))
		{
			Direction = ParameterDirection.InputOutput;
		}
		else if (string.Equals(mode, "out", StringComparison.OrdinalIgnoreCase))
		{
			Direction = ParameterDirection.Output;
		}
		Name = name;
		MySqlDbType = TypeMapper.Instance.GetMySqlDbType(dataType, unsigned, length);
		Length = length;
	}
}


using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Logging;
using MySqlConnector.Protocol.Serialization;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class CachedProcedure
{
	private static readonly IReadOnlyDictionary<string, string> s_typeMapping = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
	{
		{ "BOOL", "TINYINT" },
		{ "BOOLEAN", "TINYINT" },
		{ "INTEGER", "INT" },
		{ "NUMERIC", "DECIMAL" },
		{ "FIXED", "DECIMAL" },
		{ "REAL", "DOUBLE" },
		{ "DOUBLE PRECISION", "DOUBLE" },
		{ "NVARCHAR", "VARCHAR" },
		{ "CHARACTER VARYING", "VARCHAR" },
		{ "NATIONAL VARCHAR", "VARCHAR" },
		{ "NCHAR", "CHAR" },
		{ "CHARACTER", "CHAR" },
		{ "NATIONAL CHAR", "CHAR" },
		{ "CHAR BYTE", "BINARY" }
	};

	private static readonly Regex s_cStyleComments = new Regex("/\\*.*?\\*/", RegexOptions.Singleline);

	private static readonly Regex s_singleLineComments = new Regex("(^|\\s)--.*?$", RegexOptions.Multiline);

	private static readonly Regex s_multipleSpaces = new Regex("\\s+");

	private static readonly Regex s_numericTypes = new Regex("(DECIMAL|DEC|FIXED|NUMERIC|FLOAT|DOUBLE PRECISION|DOUBLE|REAL)\\s*\\([0-9]+(,\\s*[0-9]+)\\)", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);

	private static readonly Regex s_enum = new Regex("ENUM\\s*\\([^)]+\\)", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);

	private static readonly Regex s_parameterName = new Regex("^(?:`((?:[\\u0001-\\u005F\\u0061-\\uFFFF]+|``)+)`|([A-Za-z0-9$_\\u0080-\\uFFFF]+)) (.*)$");

	private static readonly Regex s_characterSet = new Regex(" (CHARSET|CHARACTER SET) [A-Za-z0-9_]+", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);

	private static readonly Regex s_collate = new Regex(" (COLLATE) [A-Za-z0-9_]+", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);

	private static readonly Regex s_length = new Regex("\\s*\\(\\s*([0-9]+)\\s*(?:,\\s*[0-9]+\\s*)?\\)");

	private readonly string m_schema;

	private readonly string m_component;

	public IReadOnlyList<CachedParameter> Parameters { get; }

	private string FullyQualified => "`" + m_schema + "`.`" + m_component + "`";

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
	public static async Task<CachedProcedure> FillAsync(IOBehavior ioBehavior, MySqlConnection connection, string schema, string component, ILogger logger, CancellationToken cancellationToken)
	{
		if (!connection.Session.ServerVersion.IsMariaDb && connection.Session.ServerVersion.Version < ServerVersions.RemovesMySqlProcTable && !connection.Session.ProcAccessDenied)
		{
			try
			{
				using MySqlCommand cmd = connection.CreateCommand();
				cmd.Transaction = connection.CurrentTransaction;
				cmd.CommandText = "SELECT param_list, returns FROM mysql.proc WHERE db = @schema AND name = @component";
				cmd.Parameters.AddWithValue("@schema", schema);
				cmd.Parameters.AddWithValue("@component", component);
				using MySqlDataReader reader = await cmd.ExecuteReaderNoResetTimeoutAsync(CommandBehavior.Default, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (!(await reader.ReadAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
				{
					return null;
				}
				byte[] bytes = (byte[])reader.GetValue(0);
				string @string = Encoding.UTF8.GetString(bytes);
				object value = reader.GetValue(1);
				string text2 = default(string);
				if (!(value is string text))
				{
					if (value != null)
					{
						text2 = Encoding.UTF8.GetString((byte[])value);
					}
					else
					{
						<54935a9f-04ec-42f0-b2db-de3406f234de><PrivateImplementationDetails>.ThrowInvalidOperationException();
					}
				}
				else
				{
					text2 = text;
				}
				string text3 = text2;
				List<CachedParameter> list = ParseParameters(@string);
				if (text3.Length != 0)
				{
					bool unsigned;
					int length;
					string dataType = ParseDataType(text3, out unsigned, out length);
					list.Insert(0, CreateCachedParameter(0, null, "", dataType, unsigned, length, text3));
				}
				return new CachedProcedure(schema, component, list);
			}
			catch (MySqlException ex)
			{
				Log.FailedToRetrieveProcedureMetadata(logger, ex, connection.Session.Id, schema, component, ex.Message);
				if (ex.ErrorCode == MySqlErrorCode.TableAccessDenied)
				{
					connection.Session.ProcAccessDenied = true;
				}
			}
		}
		if (connection.Session.ServerVersion.Version < ServerVersions.SupportsProcedureCache)
		{
			Log.ServerDoesNotSupportCachedProcedures(logger, connection.Session.Id, connection.Session.ServerVersion.OriginalString);
			return null;
		}
		List<CachedParameter> parameters = new List<CachedParameter>();
		int routineCount;
		using (MySqlCommand cmd = connection.CreateCommand())
		{
			cmd.Transaction = connection.CurrentTransaction;
			cmd.CommandText = "SELECT COUNT(*)\n\t\t\t\tFROM information_schema.routines\n\t\t\t\tWHERE ROUTINE_SCHEMA = @schema AND ROUTINE_NAME = @component;\n\t\t\t\tSELECT ORDINAL_POSITION, PARAMETER_MODE, PARAMETER_NAME, DTD_IDENTIFIER\n\t\t\t\tFROM information_schema.parameters\n\t\t\t\tWHERE SPECIFIC_SCHEMA = @schema AND SPECIFIC_NAME = @component\n\t\t\t\tORDER BY ORDINAL_POSITION";
			cmd.Parameters.AddWithValue("@schema", schema);
			cmd.Parameters.AddWithValue("@component", component);
			using MySqlDataReader reader = await cmd.ExecuteReaderNoResetTimeoutAsync(CommandBehavior.Default, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await reader.ReadAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			routineCount = reader.GetInt32(0);
			await reader.NextResultAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			while (await reader.ReadAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
			{
				bool unsigned2;
				int length2;
				string dataType2 = ParseDataType(reader.GetString(3), out unsigned2, out length2);
				parameters.Add(new CachedParameter(reader.GetInt32(0), (!reader.IsDBNull(1)) ? reader.GetString(1) : null, (!reader.IsDBNull(2)) ? reader.GetString(2) : "", dataType2, unsigned2, length2));
			}
		}
		Log.ProcedureHasRoutineCount(logger, schema, component, routineCount, parameters.Count);
		return (routineCount == 0) ? null : new CachedProcedure(schema, component, parameters);
	}

	private CachedProcedure(string schema, string component, IReadOnlyList<CachedParameter> parameters)
	{
		m_schema = schema;
		m_component = component;
		Parameters = parameters;
	}

	internal MySqlParameterCollection AlignParamsWithDb([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] MySqlParameterCollection parameterCollection)
	{
		MySqlParameterCollection mySqlParameterCollection = new MySqlParameterCollection();
		MySqlParameter mySqlParameter = parameterCollection?.FirstOrDefault([<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)] (MySqlParameter x) => x.Direction == ParameterDirection.ReturnValue);
		foreach (CachedParameter parameter in Parameters)
		{
			MySqlParameter mySqlParameter2;
			if (parameter.Direction == ParameterDirection.ReturnValue)
			{
				mySqlParameter2 = mySqlParameter ?? throw new InvalidOperationException("Attempt to call stored function " + FullyQualified + " without specifying a return parameter");
			}
			else
			{
				int num = parameterCollection?.NormalizedIndexOf(parameter.Name) ?? (-1);
				if (num < 0)
				{
					throw new ArgumentException("Parameter '" + parameter.Name + "' not found in the collection.");
				}
				mySqlParameter2 = parameterCollection[num];
			}
			if (!mySqlParameter2.HasSetDirection)
			{
				mySqlParameter2.Direction = parameter.Direction;
			}
			if (!mySqlParameter2.HasSetDbType)
			{
				mySqlParameter2.MySqlDbType = parameter.MySqlDbType;
			}
			mySqlParameterCollection.Add(mySqlParameter2);
		}
		return mySqlParameterCollection;
	}

	internal static List<CachedParameter> ParseParameters(string parametersSql)
	{
		parametersSql = s_cStyleComments.Replace(parametersSql, "");
		parametersSql = s_singleLineComments.Replace(parametersSql, "");
		parametersSql = s_multipleSpaces.Replace(parametersSql, " ");
		if (string.IsNullOrWhiteSpace(parametersSql))
		{
			return new List<CachedParameter>();
		}
		parametersSql = s_numericTypes.Replace(parametersSql, "$1");
		parametersSql = s_enum.Replace(parametersSql, "ENUM");
		string[] array = parametersSql.Split(new char[1] { ',' });
		List<CachedParameter> list = new List<CachedParameter>(array.Length);
		for (int i = 0; i < array.Length; i++)
		{
			string text = array[i].Trim();
			string originalSql = text;
			string direction = "IN";
			if (text.StartsWith("INOUT ", StringComparison.OrdinalIgnoreCase))
			{
				direction = "INOUT";
				string text2 = text;
				text = text2.Substring(6, text2.Length - 6);
			}
			else if (text.StartsWith("OUT ", StringComparison.OrdinalIgnoreCase))
			{
				direction = "OUT";
				string text2 = text;
				text = text2.Substring(4, text2.Length - 4);
			}
			else if (text.StartsWith("IN ", StringComparison.OrdinalIgnoreCase))
			{
				direction = "IN";
				string text2 = text;
				text = text2.Substring(3, text2.Length - 3);
			}
			Match match = s_parameterName.Match(text);
			string name = (match.Groups[1].Success ? match.Groups[1].Value.Replace("``", "`") : match.Groups[2].Value);
			bool unsigned;
			int length;
			string dataType = ParseDataType(match.Groups[3].Value, out unsigned, out length);
			list.Add(CreateCachedParameter(i + 1, direction, name, dataType, unsigned, length, originalSql));
		}
		return list;
	}

	internal static string ParseDataType(string sql, out bool unsigned, out int length)
	{
		sql = s_characterSet.Replace(sql, "");
		sql = s_collate.Replace(sql, "");
		sql = s_enum.Replace(sql, "ENUM");
		length = 0;
		Match match = s_length.Match(sql);
		if (match.Success)
		{
			length = int.Parse(match.Groups[1].Value, CultureInfo.InvariantCulture);
			sql = s_length.Replace(sql, "");
		}
		string[] array = sql.Trim().Split(new char[1] { ' ' });
		if ((array.Length < 2 || !s_typeMapping.TryGetValue(array[0] + " " + array[1], out var value)) && s_typeMapping.TryGetValue(array[0], out value) && array[0].StartsWith("BOOL", StringComparison.OrdinalIgnoreCase))
		{
			length = 1;
		}
		unsigned = array.Contains<string>("UNSIGNED", StringComparer.OrdinalIgnoreCase);
		return value ?? array[0];
	}

	private static CachedParameter CreateCachedParameter(int ordinal, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string direction, string name, string dataType, bool unsigned, int length, string originalSql)
	{
		try
		{
			return new CachedParameter(ordinal, direction, name, dataType, unsigned, length);
		}
		catch (NullReferenceException innerException)
		{
			throw new MySqlException("Failed to parse stored procedure parameter '" + originalSql + "'; extracted data type was " + dataType, innerException);
		}
	}
}


using System.Runtime.CompilerServices;
using MySqlConnector;
using MySqlConnector.Core;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class ColumnTypeMetadata
{
	public string DataTypeName { get; }

	public string SimpleDataTypeName { get; }

	public string CreateFormat { get; }

	public DbTypeMapping DbTypeMapping { get; }

	public MySqlDbType MySqlDbType { get; }

	public bool Binary { get; }

	public long ColumnSize { get; }

	public bool IsUnsigned { get; }

	public int Length { get; }

	public ColumnTypeMetadata(string dataTypeName, DbTypeMapping dbTypeMapping, MySqlDbType mySqlDbType, bool isUnsigned = false, bool binary = false, int length = 0, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string simpleDataTypeName = null, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string createFormat = null, long columnSize = 0L)
	{
		DataTypeName = dataTypeName;
		SimpleDataTypeName = simpleDataTypeName ?? dataTypeName;
		CreateFormat = createFormat ?? (dataTypeName + (isUnsigned ? " UNSIGNED" : ""));
		DbTypeMapping = dbTypeMapping;
		MySqlDbType = mySqlDbType;
		Binary = binary;
		ColumnSize = columnSize;
		IsUnsigned = isUnsigned;
		Length = length;
		base..ctor();
	}

	public static string CreateLookupKey(string columnTypeName, bool isUnsigned, int length)
	{
		return string.Format("{0}|{1}|{2}", columnTypeName, isUnsigned ? "u" : "s", length);
	}

	public string CreateLookupKey()
	{
		return CreateLookupKey(DataTypeName, IsUnsigned, Length);
	}
}


using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Logging;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

internal static class CommandExecutor
{
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public static async ValueTask<MySqlDataReader> ExecuteReaderAsync(CommandListPosition commandListPosition, ICommandPayloadCreator payloadCreator, CommandBehavior behavior, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Activity activity, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		_ = 2;
		try
		{
			cancellationToken.ThrowIfCancellationRequested();
			IMySqlCommand command = commandListPosition.CommandAt(0);
			MySqlConnection connection = command.Connection;
			Log.CommandExecutorExecuteReader(command.Logger, connection.Session.Id, ioBehavior, commandListPosition.CommandCount);
			Dictionary<string, CachedProcedure> cachedProcedures = null;
			for (int commandIndex = 0; commandIndex < commandListPosition.CommandCount; commandIndex++)
			{
				IMySqlCommand mySqlCommand = commandListPosition.CommandAt(commandIndex);
				if (mySqlCommand.CommandType == CommandType.StoredProcedure)
				{
					if (cachedProcedures == null)
					{
						cachedProcedures = new Dictionary<string, CachedProcedure>();
					}
					string commandText = mySqlCommand.CommandText;
					if (!cachedProcedures.ContainsKey(commandText))
					{
						Dictionary<string, CachedProcedure> dictionary = cachedProcedures;
						string key = commandText;
						dictionary.Add(key, await connection.GetCachedProcedure(commandText, revalidateMissing: false, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
						command.CancellableCommand.ResetCommandTimeout();
					}
				}
			}
			ByteBufferWriter byteBufferWriter = new ByteBufferWriter();
			if (!payloadCreator.WriteQueryCommand(ref commandListPosition, cachedProcedures, byteBufferWriter, appendSemicolon: false))
			{
				throw new InvalidOperationException("ICommandPayloadCreator failed to write query payload");
			}
			cancellationToken.ThrowIfCancellationRequested();
			using PayloadData payload = byteBufferWriter.ToPayloadData();
			ServerSession session = connection.Session;
			session.StartQuerying(command.CancellableCommand);
			command.SetLastInsertedId(0L);
			try
			{
				await session.SendAsync(payload, ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
				await session.DataReader.InitAsync(commandListPosition, payloadCreator, cachedProcedures, command, behavior, activity, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				return session.DataReader;
			}
			catch (MySqlException ex) when (ex.ErrorCode == MySqlErrorCode.QueryInterrupted && cancellationToken.IsCancellationRequested)
			{
				Log.QueryWasInterrupted(command.Logger, session.Id);
				throw new OperationCanceledException(ex.Message, ex, cancellationToken);
			}
			catch (Exception ex2) when (((Func<bool>)delegate
			{
				// Could not convert BlockContainer to single expression
				bool flag = payload.Span.Length > 4194304;
				if (flag)
				{
					flag = ((ex2 is SocketException || ex2 is IOException || ex2 is MySqlProtocolException) ? true : false);
				}
				return flag;
			}).Invoke())
			{
				int num = payload.Span.Length / 1000000;
				throw new MySqlException($"Error submitting {num}MB packet; ensure 'max_allowed_packet' is greater than {num}MB.", ex2);
			}
		}
		catch (Exception exception) when (activity?.IsAllDataRequested ?? false)
		{
			activity.SetException(exception);
			activity.Stop();
			throw;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector;
using MySqlConnector.Core;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal struct CommandListPosition
{
	private readonly object m_commands;

	public readonly int CommandCount;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public PreparedStatements PreparedStatements;

	public int CommandIndex;

	public int PreparedStatementIndex;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public PreparedStatement LastUsedPreparedStatement;

	public CommandListPosition(object commands)
	{
		LastUsedPreparedStatement = null;
		m_commands = commands;
		int commandCount = ((commands is MySqlCommand) ? 1 : ((commands is IReadOnlyList<MySqlBatchCommand> readOnlyList) ? readOnlyList.Count : 0));
		CommandCount = commandCount;
		PreparedStatements = null;
		CommandIndex = 0;
		PreparedStatementIndex = 0;
	}

	public readonly IMySqlCommand CommandAt(int index)
	{
		object commands = m_commands;
		if (!(commands is MySqlCommand result))
		{
			if (commands is IReadOnlyList<MySqlBatchCommand> readOnlyList)
			{
				return readOnlyList[index];
			}
		}
		else if (index == 0)
		{
			return result;
		}
		throw new ArgumentOutOfRangeException("index");
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector.Core;
using MySqlConnector.Logging;
using MySqlConnector.Protocol.Serialization;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class ConcatenatedCommandPayloadCreator : ICommandPayloadCreator
{
	public static ICommandPayloadCreator Instance { get; } = new ConcatenatedCommandPayloadCreator();

	public bool WriteQueryCommand(ref CommandListPosition commandListPosition, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })] IDictionary<string, CachedProcedure> cachedProcedures, ByteBufferWriter writer, bool appendSemicolon)
	{
		if (commandListPosition.CommandIndex == commandListPosition.CommandCount)
		{
			return false;
		}
		writer.Write((byte)3);
		if (commandListPosition.CommandAt(commandListPosition.CommandIndex).Connection.Session.SupportsQueryAttributes)
		{
			writer.WriteLengthEncodedInteger(0uL);
			writer.Write((byte)1);
		}
		bool flag;
		do
		{
			IMySqlCommand mySqlCommand = commandListPosition.CommandAt(commandListPosition.CommandIndex);
			Log.PreparingCommandPayload(mySqlCommand.Logger, mySqlCommand.Connection.Session.Id, mySqlCommand.CommandText);
			flag = SingleCommandPayloadCreator.WriteQueryPayload(mySqlCommand, cachedProcedures, writer, commandListPosition.CommandIndex < commandListPosition.CommandCount - 1 || appendSemicolon, commandListPosition.CommandIndex == 0, commandListPosition.CommandIndex == commandListPosition.CommandCount - 1);
			commandListPosition.CommandIndex++;
		}
		while (commandListPosition.CommandIndex < commandListPosition.CommandCount && flag);
		return true;
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Logging;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class ConnectionPool : IDisposable
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private sealed class LeastConnectionsLoadBalancer(Dictionary<string, int> hostSessions) : ILoadBalancer
	{
		public IReadOnlyList<string> LoadBalance(IReadOnlyList<string> hosts)
		{
			lock (hostSessions)
			{
				return (from x in hostSessions
					orderby x.Value
					select x.Key).ToList();
			}
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private sealed class ConnectionStringPool(string connectionString, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] [property: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] ConnectionPool pool)
	{
		public string ConnectionString { get; } = connectionString;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
		[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
		public ConnectionPool Pool
		{
			[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
			get;
		} = pool;
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	private static readonly ConcurrentDictionary<string, ConnectionPool> s_pools;

	private static readonly List<ConnectionPool> s_allPools;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, int, string, Exception> s_createdNewSession;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, int, string, Exception> s_createdToReachMinimumPoolSize;

	private static int s_poolId;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private static ConnectionStringPool s_mruCache;

	private readonly ILogger m_logger;

	private readonly ILogger m_connectionLogger;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
	private readonly KeyValuePair<string, object>[] m_stateTagList;

	private readonly SemaphoreSlim m_cleanSemaphore;

	private readonly SemaphoreSlim m_sessionSemaphore;

	private readonly LinkedList<ServerSession> m_sessions;

	private readonly Dictionary<string, ServerSession> m_leasedSessions;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private readonly ILoadBalancer m_loadBalancer;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	private readonly Dictionary<string, int> m_hostSessions;

	private int m_generation;

	private uint m_lastRecoveryTime;

	private int m_lastSessionId;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 2 })]
	private Dictionary<string, CachedProcedure> m_procedureCache;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private Timer m_dnsCheckTimer;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private Timer m_reaperTimer;

	public int Id { get; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public string Name
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
	}

	public ConnectionSettings ConnectionSettings { get; }

	internal bool IsEmpty => m_sessionSemaphore.CurrentCount == 0;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 0, 1, 2 })]
	public ReadOnlySpan<KeyValuePair<string, object>> IdleStateTagList
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 0, 1, 2 })]
		get
		{
			return MemoryExtensions.AsSpan(m_stateTagList, 0, 2);
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 0, 1, 2 })]
	public ReadOnlySpan<KeyValuePair<string, object>> UsedStateTagList
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 0, 1, 2 })]
		get
		{
			return MemoryExtensions.AsSpan(m_stateTagList, 1, 2);
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 0, 1, 2 })]
	public ReadOnlySpan<KeyValuePair<string, object>> PoolNameTagList
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 0, 1, 2 })]
		get
		{
			return MemoryExtensions.AsSpan(m_stateTagList, 1, 1);
		}
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public async ValueTask<ServerSession> GetSessionAsync(MySqlConnection connection, long startingTimestamp, int timeoutMilliseconds, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Activity activity, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		cancellationToken.ThrowIfCancellationRequested();
		if (IsEmpty && (uint)(Environment.TickCount - (int)m_lastRecoveryTime) >= 1000u)
		{
			Log.ScanningForLeakedSessions(m_logger, Id);
			await RecoverLeakedSessionsAsync(ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
		}
		if (ConnectionSettings.MinimumPoolSize > 0)
		{
			await CreateMinimumPooledSessions(connection, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		Log.WaitingForAvailableSession(m_logger, Id);
		if (ioBehavior == IOBehavior.Asynchronous)
		{
			await m_sessionSemaphore.WaitAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else
		{
			m_sessionSemaphore.Wait(cancellationToken);
		}
		ServerSession session = null;
		try
		{
			lock (m_sessions)
			{
				if (m_sessions.Count > 0)
				{
					session = m_sessions.First.Value;
					m_sessions.RemoveFirst();
				}
			}
			if (session != null)
			{
				MetricsReporter.RemoveIdle(this);
				Log.FoundExistingSession(m_logger, Id);
				bool flag;
				if (session.PoolGeneration != m_generation)
				{
					Log.DiscardingSessionDueToWrongGeneration(m_logger, Id);
					flag = false;
				}
				else if (ConnectionSettings.ConnectionReset || session.DatabaseOverride != null)
				{
					if (timeoutMilliseconds != 0)
					{
						session.SetTimeout(Math.Max(1, timeoutMilliseconds - Utility.GetElapsedMilliseconds(startingTimestamp)));
					}
					flag = await session.TryResetConnectionAsync(ConnectionSettings, connection, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					session.SetTimeout(int.MaxValue);
				}
				else
				{
					flag = true;
				}
				if (flag)
				{
					session.OwningConnection = new WeakReference<MySqlConnection>(connection);
					int count;
					lock (m_leasedSessions)
					{
						m_leasedSessions.Add(session.Id, session);
						count = m_leasedSessions.Count;
					}
					MetricsReporter.AddUsed(this);
					ActivitySourceHelper.CopyTags(session.ActivityTags, activity);
					Log.ReturningPooledSession(m_logger, Id, session.Id, count);
					session.LastLeasedTimestamp = Stopwatch.GetTimestamp();
					MetricsReporter.RecordWaitTime(this, Utility.GetElapsedSeconds(startingTimestamp, session.LastLeasedTimestamp));
					return session;
				}
				Log.SessionIsUnusable(m_logger, Id, session.Id);
				AdjustHostConnectionCount(session, -1);
				await session.DisposeAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			session = await ConnectSessionAsync(connection, s_createdNewSession, startingTimestamp, activity, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			AdjustHostConnectionCount(session, 1);
			session.OwningConnection = new WeakReference<MySqlConnection>(connection);
			int count2;
			lock (m_leasedSessions)
			{
				m_leasedSessions.Add(session.Id, session);
				count2 = m_leasedSessions.Count;
			}
			MetricsReporter.AddUsed(this);
			Log.ReturningNewSession(m_logger, Id, session.Id, count2);
			session.LastLeasedTimestamp = Stopwatch.GetTimestamp();
			MetricsReporter.RecordCreateTime(this, Utility.GetElapsedSeconds(startingTimestamp, session.LastLeasedTimestamp));
			return session;
		}
		catch (Exception ex)
		{
			if (session != null)
			{
				try
				{
					Log.DisposingCreatedSessionDueToException(m_logger, ex, Id, session.Id, ex.Message);
					AdjustHostConnectionCount(session, -1);
					await session.DisposeAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (Exception ex2)
				{
					Log.UnexpectedErrorInGetSessionAsync(m_logger, ex2, Id, ex2.Message);
				}
			}
			m_sessionSemaphore.Release();
			throw;
		}
	}

	private int GetSessionHealth(ServerSession session)
	{
		if (!session.IsConnected)
		{
			return 1;
		}
		if (session.PoolGeneration != m_generation)
		{
			return 2;
		}
		if (ConnectionSettings.ConnectionLifeTime != 0 && Utility.GetElapsedMilliseconds(session.CreatedTimestamp) >= ConnectionSettings.ConnectionLifeTime)
		{
			return 3;
		}
		return 0;
	}

	public async ValueTask ReturnAsync(IOBehavior ioBehavior, ServerSession session)
	{
		Log.ReceivingSessionBack(m_logger, Id, session.Id);
		try
		{
			lock (m_leasedSessions)
			{
				m_leasedSessions.Remove(session.Id);
			}
			MetricsReporter.RemoveUsed(this);
			session.OwningConnection = null;
			session.DataReader = new MySqlDataReader();
			switch (GetSessionHealth(session))
			{
			case 0:
				lock (m_sessions)
				{
					m_sessions.AddFirst(session);
				}
				MetricsReporter.AddIdle(this);
				return;
			case 1:
				Log.ReceivedInvalidSession(m_logger, Id, session.Id);
				break;
			default:
				Log.ReceivedExpiredSession(m_logger, Id, session.Id);
				break;
			}
			AdjustHostConnectionCount(session, -1);
			await session.DisposeAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
		}
		finally
		{
			m_sessionSemaphore.Release();
		}
	}

	public async Task ClearAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		Log.ClearingConnectionPool(m_logger, Id);
		Interlocked.Increment(ref m_generation);
		m_procedureCache = null;
		await RecoverLeakedSessionsAsync(ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
		await CleanPoolAsync(ioBehavior, (ServerSession session) => session.PoolGeneration != m_generation, respectMinPoolSize: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	public async Task ReapAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		Log.ReapingConnectionPool(m_logger, Id);
		await RecoverLeakedSessionsAsync(ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
		await CleanPoolAsync(ioBehavior, (ServerSession session) => Utility.GetElapsedMilliseconds(session.LastReturnedTimestamp) / 1000 >= ConnectionSettings.ConnectionIdleTimeout, respectMinPoolSize: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })]
	public Dictionary<string, CachedProcedure> GetProcedureCache()
	{
		Dictionary<string, CachedProcedure> dictionary = m_procedureCache;
		if (dictionary == null)
		{
			Dictionary<string, CachedProcedure> dictionary2 = new Dictionary<string, CachedProcedure>();
			dictionary = Interlocked.CompareExchange(ref m_procedureCache, dictionary2, null) ?? dictionary2;
		}
		return dictionary;
	}

	public void Dispose()
	{
		Log.DisposingConnectionPool(m_logger, Id);
		lock (s_allPools)
		{
			s_allPools.Remove(this);
		}
		if (m_dnsCheckTimer != null)
		{
			using ManualResetEvent manualResetEvent = new ManualResetEvent(initialState: false);
			m_dnsCheckTimer.Dispose(manualResetEvent);
			manualResetEvent.WaitOne();
			m_dnsCheckTimer = null;
		}
		if (m_reaperTimer != null)
		{
			using (ManualResetEvent manualResetEvent2 = new ManualResetEvent(initialState: false))
			{
				m_reaperTimer.Dispose(manualResetEvent2);
				manualResetEvent2.WaitOne();
				m_reaperTimer = null;
			}
		}
	}

	private async Task RecoverLeakedSessionsAsync(IOBehavior ioBehavior)
	{
		List<(ServerSession, MySqlConnection)> list = new List<(ServerSession, MySqlConnection)>();
		lock (m_leasedSessions)
		{
			m_lastRecoveryTime = (uint)Environment.TickCount;
			foreach (ServerSession value in m_leasedSessions.Values)
			{
				if (!value.OwningConnection.TryGetTarget(out var _))
				{
					MySqlConnection mySqlConnection = new MySqlConnection();
					value.OwningConnection = new WeakReference<MySqlConnection>(mySqlConnection);
					list.Add((value, mySqlConnection));
				}
			}
		}
		if (list.Count == 0)
		{
			Log.RecoveredNoSessions(m_logger, Id);
		}
		else
		{
			Log.RecoveredSessionCount(m_logger, Id, list.Count);
		}
		foreach (var (serverSession, connection) in list)
		{
			await serverSession.ReturnToPoolAsync(ioBehavior, null).ConfigureAwait(continueOnCapturedContext: false);
			GC.KeepAlive(connection);
		}
	}

	private async Task CleanPoolAsync(IOBehavior ioBehavior, Func<ServerSession, bool> shouldCleanFn, bool respectMinPoolSize, CancellationToken cancellationToken)
	{
		if (ioBehavior == IOBehavior.Asynchronous)
		{
			await m_cleanSemaphore.WaitAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else
		{
			m_cleanSemaphore.Wait(cancellationToken);
		}
		try
		{
			TimeSpan waitTimeout = TimeSpan.FromMilliseconds(10.0);
			while (true)
			{
				if (respectMinPoolSize)
				{
					lock (m_sessions)
					{
						if (ConnectionSettings.MaximumPoolSize - m_sessionSemaphore.CurrentCount + m_sessions.Count <= ConnectionSettings.MinimumPoolSize)
						{
							break;
						}
					}
				}
				if (ioBehavior == IOBehavior.Asynchronous)
				{
					if (!(await m_sessionSemaphore.WaitAsync(waitTimeout, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
					{
						break;
					}
				}
				else if (!m_sessionSemaphore.Wait(waitTimeout, cancellationToken))
				{
					break;
				}
				try
				{
					ServerSession serverSession = null;
					lock (m_sessions)
					{
						if (m_sessions.Count > 0)
						{
							serverSession = m_sessions.Last.Value;
							m_sessions.RemoveLast();
						}
					}
					if (serverSession == null)
					{
						break;
					}
					MetricsReporter.RemoveIdle(this);
					if (shouldCleanFn(serverSession))
					{
						Log.FoundSessionToCleanUp(m_logger, Id, serverSession.Id);
						await serverSession.DisposeAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						continue;
					}
					lock (m_sessions)
					{
						m_sessions.AddLast(serverSession);
					}
					MetricsReporter.AddIdle(this);
					break;
				}
				finally
				{
					m_sessionSemaphore.Release();
				}
			}
		}
		finally
		{
			m_cleanSemaphore.Release();
		}
	}

	private async Task CreateMinimumPooledSessions(MySqlConnection connection, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		while (true)
		{
			lock (m_sessions)
			{
				if (ConnectionSettings.MaximumPoolSize - m_sessionSemaphore.CurrentCount + m_sessions.Count >= ConnectionSettings.MinimumPoolSize)
				{
					break;
				}
			}
			if (ioBehavior == IOBehavior.Asynchronous)
			{
				if (!(await m_sessionSemaphore.WaitAsync(0, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
				{
					break;
				}
			}
			else if (!m_sessionSemaphore.Wait(0, cancellationToken))
			{
				break;
			}
			try
			{
				ServerSession serverSession = await ConnectSessionAsync(connection, s_createdToReachMinimumPoolSize, Stopwatch.GetTimestamp(), null, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				AdjustHostConnectionCount(serverSession, 1);
				lock (m_sessions)
				{
					m_sessions.AddFirst(serverSession);
				}
				MetricsReporter.AddIdle(this);
			}
			finally
			{
				m_sessionSemaphore.Release();
			}
		}
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	private async ValueTask<ServerSession> ConnectSessionAsync(MySqlConnection connection, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })] Action<ILogger, int, string, Exception> logMessage, long startingTimestamp, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Activity activity, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		ServerSession session = new ServerSession(m_connectionLogger, this, m_generation, Interlocked.Increment(ref m_lastSessionId));
		if (m_logger.IsEnabled(LogLevel.Debug))
		{
			logMessage(m_logger, Id, session.Id, null);
		}
		string statusInfo;
		try
		{
			statusInfo = await session.ConnectAsync(ConnectionSettings, connection, startingTimestamp, m_loadBalancer, activity, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		catch (Exception)
		{
			await session.DisposeAsync(ioBehavior, default(CancellationToken)).ConfigureAwait(continueOnCapturedContext: false);
			throw;
		}
		Exception redirectionException = null;
		if (statusInfo != null && statusInfo.StartsWith("Location: mysql://", StringComparison.Ordinal))
		{
			Log.HasServerRedirectionHeader(m_logger, session.Id, statusInfo);
			string host;
			int port;
			string user;
			if (ConnectionSettings.ServerRedirectionMode == MySqlServerRedirectionMode.Disabled)
			{
				Log.ServerRedirectionIsDisabled(m_logger, Id);
			}
			else if (Utility.TryParseRedirectionHeader(statusInfo, out host, out port, out user))
			{
				if (host != ConnectionSettings.HostNames[0] || port != ConnectionSettings.Port || user != ConnectionSettings.UserID)
				{
					ConnectionSettings cs = ConnectionSettings.CloneWith(host, port, user);
					Log.OpeningNewConnection(m_logger, Id, host, port, user);
					ServerSession redirectedSession = new ServerSession(m_connectionLogger, this, m_generation, Interlocked.Increment(ref m_lastSessionId));
					try
					{
						await redirectedSession.ConnectAsync(cs, connection, startingTimestamp, m_loadBalancer, activity, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					catch (Exception ex2)
					{
						Log.FailedToConnectRedirectedSession(m_logger, ex2, Id, redirectedSession.Id);
						redirectionException = ex2;
					}
					if (redirectionException == null)
					{
						Log.ClosingSessionToUseRedirectedSession(m_logger, Id, session.Id, redirectedSession.Id);
						await session.DisposeAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return redirectedSession;
					}
					try
					{
						await redirectedSession.DisposeAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					catch (Exception)
					{
					}
				}
				else
				{
					Log.SessionAlreadyConnectedToServer(m_logger, session.Id);
				}
			}
		}
		if (ConnectionSettings.ServerRedirectionMode == MySqlServerRedirectionMode.Required)
		{
			Log.RequiresServerRedirection(m_logger, Id);
			throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Server does not support redirection", redirectionException);
		}
		return session;
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public static ConnectionPool CreatePool(string connectionString, MySqlConnectorLoggingConfiguration loggingConfiguration, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string name)
	{
		MySqlConnectionStringBuilder mySqlConnectionStringBuilder = new MySqlConnectionStringBuilder(connectionString);
		if (!mySqlConnectionStringBuilder.Pooling)
		{
			return null;
		}
		if (name != null)
		{
			mySqlConnectionStringBuilder.ApplicationName = name;
		}
		ConnectionSettings cs = new ConnectionSettings(mySqlConnectionStringBuilder);
		ConnectionPool connectionPool = new ConnectionPool(loggingConfiguration, cs);
		connectionPool.StartReaperTask();
		connectionPool.StartDnsCheckTimer();
		return connectionPool;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public static ConnectionPool GetPool([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] string connectionString, MySqlConnectorLoggingConfiguration loggingConfiguration, bool createIfNotFound = true)
	{
		ConnectionStringPool connectionStringPool = s_mruCache;
		if (connectionStringPool?.ConnectionString == connectionString)
		{
			return connectionStringPool.Pool;
		}
		if (s_pools.TryGetValue(connectionString, out var value))
		{
			s_mruCache = new ConnectionStringPool(connectionString, value);
			return value;
		}
		MySqlConnectionStringBuilder mySqlConnectionStringBuilder = new MySqlConnectionStringBuilder(connectionString);
		if (!mySqlConnectionStringBuilder.Pooling)
		{
			s_pools.GetOrAdd(connectionString, (ConnectionPool)null);
			s_mruCache = new ConnectionStringPool(connectionString, null);
			return null;
		}
		string connectionString2 = mySqlConnectionStringBuilder.ConnectionString;
		if (connectionString2 != connectionString && s_pools.TryGetValue(connectionString2, out value))
		{
			value = s_pools.GetOrAdd(connectionString, value);
			s_mruCache = new ConnectionStringPool(connectionString, value);
			return value;
		}
		if (!createIfNotFound)
		{
			return null;
		}
		ConnectionSettings cs = new ConnectionSettings(mySqlConnectionStringBuilder);
		ConnectionPool connectionPool = new ConnectionPool(loggingConfiguration, cs);
		value = s_pools.GetOrAdd(connectionString2, connectionPool);
		if (value == connectionPool)
		{
			s_mruCache = new ConnectionStringPool(connectionString, value);
			value.StartReaperTask();
			value.StartDnsCheckTimer();
			if (connectionString != connectionString2)
			{
				s_pools.GetOrAdd(connectionString, value);
			}
		}
		else if (value != connectionPool)
		{
			Log.CreatedPoolWillNotBeUsed(connectionPool.m_logger, connectionPool.Id);
			connectionPool.Dispose();
		}
		return value;
	}

	public static async Task ClearPoolsAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		foreach (ConnectionPool item in GetCachedPools())
		{
			await item.ClearAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		static List<ConnectionPool> GetCachedPools()
		{
			List<ConnectionPool> list = new List<ConnectionPool>(s_pools.Count);
			HashSet<ConnectionPool> hashSet = new HashSet<ConnectionPool>();
			foreach (ConnectionPool value in s_pools.Values)
			{
				if (value != null && hashSet.Add(value))
				{
					list.Add(value);
				}
			}
			return list;
		}
	}

	private ConnectionPool(MySqlConnectorLoggingConfiguration loggingConfiguration, ConnectionSettings cs)
	{
		m_logger = loggingConfiguration.PoolLogger;
		m_connectionLogger = loggingConfiguration.ConnectionLogger;
		ConnectionSettings = cs;
		Name = cs.ApplicationName;
		m_generation = 0;
		m_cleanSemaphore = new SemaphoreSlim(1);
		m_sessionSemaphore = new SemaphoreSlim(cs.MaximumPoolSize);
		m_sessions = new LinkedList<ServerSession>();
		m_leasedSessions = new Dictionary<string, ServerSession>();
		if (cs.ConnectionProtocol == MySqlConnectionProtocol.Sockets && cs.LoadBalance == MySqlLoadBalance.LeastConnections)
		{
			m_hostSessions = new Dictionary<string, int>();
			foreach (string hostName in cs.HostNames)
			{
				m_hostSessions[hostName] = 0;
			}
		}
		object loadBalancer2;
		if (cs.ConnectionProtocol == MySqlConnectionProtocol.Sockets)
		{
			if (cs.HostNames.Count != 1 && cs.LoadBalance != MySqlLoadBalance.FailOver)
			{
				if (cs.LoadBalance != MySqlLoadBalance.Random)
				{
					if (cs.LoadBalance != MySqlLoadBalance.LeastConnections)
					{
						ILoadBalancer loadBalancer = new RoundRobinLoadBalancer();
						loadBalancer2 = loadBalancer;
					}
					else
					{
						ILoadBalancer loadBalancer = new LeastConnectionsLoadBalancer(m_hostSessions);
						loadBalancer2 = loadBalancer;
					}
				}
				else
				{
					loadBalancer2 = RandomLoadBalancer.Instance;
				}
			}
			else
			{
				loadBalancer2 = FailOverLoadBalancer.Instance;
			}
		}
		else
		{
			loadBalancer2 = null;
		}
		m_loadBalancer = (ILoadBalancer)loadBalancer2;
		string connectionString = cs.ConnectionStringBuilder.GetConnectionString(includePassword: false);
		m_stateTagList = new KeyValuePair<string, object>[3]
		{
			new KeyValuePair<string, object>("state", "idle"),
			new KeyValuePair<string, object>("pool.name", Name ?? connectionString),
			new KeyValuePair<string, object>("state", "used")
		};
		Id = Interlocked.Increment(ref s_poolId);
		lock (s_allPools)
		{
			s_allPools.Add(this);
		}
		Log.CreatingNewConnectionPool(m_logger, Id, connectionString);
	}

	private void StartReaperTask()
	{
		if (ConnectionSettings.ConnectionIdleTimeout <= 0)
		{
			return;
		}
		TimeSpan reaperInterval = TimeSpan.FromSeconds(Math.Max(1, Math.Min(60, ConnectionSettings.ConnectionIdleTimeout / 2)));
		m_reaperTimer = new Timer([<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)] (object t) =>
		{
			Stopwatch stopwatch = Stopwatch.StartNew();
			try
			{
				using CancellationTokenSource cancellationTokenSource = new CancellationTokenSource(reaperInterval);
				ReapAsync(IOBehavior.Synchronous, cancellationTokenSource.Token).GetAwaiter().GetResult();
			}
			catch
			{
			}
			TimeSpan timeSpan = reaperInterval - stopwatch.Elapsed;
			((Timer)t).Change((timeSpan < TimeSpan.Zero) ? TimeSpan.Zero : timeSpan, TimeSpan.FromMilliseconds(-1.0));
		});
		m_reaperTimer.Change(reaperInterval, TimeSpan.FromMilliseconds(-1.0));
	}

	private void StartDnsCheckTimer()
	{
		if (ConnectionSettings.ConnectionProtocol != MySqlConnectionProtocol.Sockets || ConnectionSettings.DnsCheckInterval <= 0)
		{
			return;
		}
		IReadOnlyList<string> hostNames = ConnectionSettings.HostNames;
		IPAddress[][] hostAddresses = new IPAddress[hostNames.Count][];
		int interval = Math.Min(2147483, ConnectionSettings.DnsCheckInterval) * 1000;
		m_dnsCheckTimer = new Timer([<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)] (object t) =>
		{
			Log.CheckingForDnsChanges(m_logger, Id);
			bool flag = false;
			for (int i = 0; i < hostNames.Count; i++)
			{
				try
				{
					IPAddress[] hostAddresses2 = Dns.GetHostAddresses(hostNames[i]);
					if (hostAddresses[i] == null)
					{
						hostAddresses[i] = hostAddresses2;
					}
					else if (hostAddresses[i].Except(hostAddresses2).Any())
					{
						Log.DetectedDnsChange(m_logger, Id, hostNames[i], string.Join(",", (IEnumerable<IPAddress>)hostAddresses[i]), string.Join(",", (IEnumerable<IPAddress>)hostAddresses2));
						hostAddresses[i] = hostAddresses2;
						flag = true;
					}
				}
				catch (Exception ex)
				{
					Log.DnsCheckFailed(m_logger, ex, Id, hostNames[i], ex.Message);
				}
			}
			if (flag)
			{
				Log.ClearingPoolDueToDnsChanges(m_logger, Id);
				ClearAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
			}
			((Timer)t).Change(interval, -1);
		});
		m_dnsCheckTimer.Change(interval, -1);
	}

	private void AdjustHostConnectionCount(ServerSession session, int delta)
	{
		if (m_hostSessions != null)
		{
			lock (m_hostSessions)
			{
				m_hostSessions[session.HostName] += delta;
			}
		}
	}

	public static List<ConnectionPool> GetAllPools()
	{
		lock (s_allPools)
		{
			return new List<ConnectionPool>(s_allPools);
		}
	}

	static ConnectionPool()
	{
		s_pools = new ConcurrentDictionary<string, ConnectionPool>();
		s_allPools = new List<ConnectionPool>();
		s_createdNewSession = LoggerMessage.Define<int, string>(LogLevel.Debug, new EventId(3018, "PoolCreatedNewSession"), "Pool {PoolId} has no pooled session available; created new session {SessionId}");
		s_createdToReachMinimumPoolSize = LoggerMessage.Define<int, string>(LogLevel.Debug, new EventId(3019, "CreatedSessionToReachMinimumPoolCount"), "Pool {PoolId} created session {SessionId} to reach minimum pool size");
		AppDomain.CurrentDomain.DomainUnload += OnAppDomainShutDown;
		AppDomain.CurrentDomain.ProcessExit += OnAppDomainShutDown;
	}

	private static void OnAppDomainShutDown([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] object sender, EventArgs e)
	{
		ClearPoolsAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}
}


using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
private sealed class LeastConnectionsLoadBalancer(Dictionary<string, int> hostSessions) : ILoadBalancer
{
	public IReadOnlyList<string> LoadBalance(IReadOnlyList<string> hosts)
	{
		lock (hostSessions)
		{
			return (from x in hostSessions
				orderby x.Value
				select x.Key).ToList();
		}
	}
}


using System.Runtime.CompilerServices;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
private sealed class ConnectionStringPool(string connectionString, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] [property: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] ConnectionPool pool)
{
	public string ConnectionString { get; } = connectionString;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public ConnectionPool Pool
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
	} = pool;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Security.Authentication;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class ConnectionSettings
{
	private int? m_connectionTimeoutMilliseconds;

	private static readonly string[] s_localhostPipeServer = new string[1] { "." };

	public MySqlConnectionStringBuilder ConnectionStringBuilder { get; }

	public string ConnectionString { get; }

	public MySqlConnectionProtocol ConnectionProtocol { get; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	public IReadOnlyList<string> HostNames
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
		get;
	}

	public MySqlLoadBalance LoadBalance { get; }

	public int Port { get; }

	public string PipeName { get; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public string UnixSocket
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
	}

	public string UserID { get; }

	public string Password { get; }

	public string Database { get; }

	public MySqlSslMode SslMode { get; }

	public string CertificateFile { get; }

	public string CertificatePassword { get; }

	public string CACertificateFile { get; }

	public string SslCertificateFile { get; }

	public string SslKeyFile { get; }

	public MySqlCertificateStoreLocation CertificateStoreLocation { get; }

	public string CertificateThumbprint { get; }

	public SslProtocols TlsVersions { get; }

	public bool Pooling { get; }

	public uint ConnectionLifeTime { get; }

	public bool ConnectionReset { get; }

	public int ConnectionIdleTimeout { get; }

	public int MinimumPoolSize { get; }

	public int MaximumPoolSize { get; }

	public int DnsCheckInterval { get; }

	public bool AllowLoadLocalInfile { get; }

	public bool AllowPublicKeyRetrieval { get; }

	public bool AllowUserVariables { get; }

	public bool AllowZeroDateTime { get; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public string ApplicationName
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
	}

	public bool AutoEnlist { get; }

	public int CancellationTimeout { get; }

	public int ConnectionTimeout { get; }

	public bool ConvertZeroDateTime { get; }

	public DateTimeKind DateTimeKind { get; }

	public int DefaultCommandTimeout { get; }

	public bool ForceSynchronous { get; }

	public MySqlGuidFormat GuidFormat { get; }

	public bool IgnoreCommandTransaction { get; }

	public bool IgnorePrepare { get; }

	public bool InteractiveSession { get; }

	public uint Keepalive { get; }

	public bool NoBackslashEscapes { get; }

	public bool PersistSecurityInfo { get; }

	public bool? Pipelining { get; }

	public MySqlServerRedirectionMode ServerRedirectionMode { get; }

	public string ServerRsaPublicKeyFile { get; }

	public string ServerSPN { get; }

	public bool TreatTinyAsBoolean { get; }

	public bool UseAffectedRows { get; }

	public bool UseCompression { get; }

	public bool UseXaTransactions { get; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public byte[] ConnectionAttributes
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		set;
	}

	public int ConnectionTimeoutMilliseconds
	{
		get
		{
			if (!m_connectionTimeoutMilliseconds.HasValue)
			{
				try
				{
					m_connectionTimeoutMilliseconds = checked(ConnectionTimeout * 1000);
				}
				catch (OverflowException)
				{
					m_connectionTimeoutMilliseconds = int.MaxValue;
				}
			}
			return m_connectionTimeoutMilliseconds.Value;
		}
	}

	public ConnectionSettings(MySqlConnectionStringBuilder csb)
	{
		ConnectionStringBuilder = csb;
		ConnectionString = csb.ConnectionString;
		if (csb.ConnectionProtocol == MySqlConnectionProtocol.UnixSocket || (!Utility.IsWindows() && (Utility.StartsWith(csb.Server, '/') || csb.Server.StartsWith("./", StringComparison.Ordinal))))
		{
			if (csb.LoadBalance != 0)
			{
				throw new NotSupportedException("LoadBalance not supported when ConnectionProtocol=UnixSocket");
			}
			if (!File.Exists(csb.Server))
			{
				throw new MySqlException("Cannot find Unix Socket at " + csb.Server);
			}
			ConnectionProtocol = MySqlConnectionProtocol.UnixSocket;
			UnixSocket = Path.GetFullPath(csb.Server);
			PipeName = "";
		}
		else if (csb.ConnectionProtocol == MySqlConnectionProtocol.Pipe)
		{
			if (csb.LoadBalance != 0)
			{
				throw new NotSupportedException("LoadBalance not supported when ConnectionProtocol=NamedPipe");
			}
			ConnectionProtocol = MySqlConnectionProtocol.Pipe;
			HostNames = ((csb.Server == "." || string.Equals(csb.Server, "localhost", StringComparison.OrdinalIgnoreCase)) ? s_localhostPipeServer : new string[1] { csb.Server });
			PipeName = csb.PipeName;
		}
		else
		{
			if (csb.ConnectionProtocol == MySqlConnectionProtocol.SharedMemory)
			{
				throw new NotSupportedException("Shared Memory connections are not supported");
			}
			ConnectionProtocol = MySqlConnectionProtocol.Sockets;
			HostNames = csb.Server.Split(new char[1] { ',' });
			LoadBalance = csb.LoadBalance;
			Port = (int)csb.Port;
			PipeName = "";
		}
		UserID = csb.UserID;
		Password = csb.Password;
		Database = csb.Database;
		SslMode = csb.SslMode;
		CertificateFile = csb.CertificateFile;
		CertificatePassword = csb.CertificatePassword;
		SslCertificateFile = csb.SslCert;
		SslKeyFile = csb.SslKey;
		CACertificateFile = csb.SslCa;
		CertificateStoreLocation = csb.CertificateStoreLocation;
		CertificateThumbprint = csb.CertificateThumbprint;
		if (csb.TlsVersion.Length == 0)
		{
			TlsVersions = Utility.GetDefaultSslProtocols();
		}
		else
		{
			TlsVersions = SslProtocols.None;
			for (int i = 6; i < csb.TlsVersion.Length; i += 9)
			{
				char c = csb.TlsVersion[i];
				switch (c)
				{
				case '0':
					TlsVersions |= SslProtocols.Tls;
					break;
				case '1':
					TlsVersions |= SslProtocols.Tls11;
					break;
				case '2':
					TlsVersions |= SslProtocols.Tls12;
					break;
				case '3':
					TlsVersions |= SslProtocols.Tls13;
					break;
				default:
					throw new InvalidOperationException($"Unexpected character '{c}' for TLS minor version.");
				}
			}
			if (TlsVersions == SslProtocols.None)
			{
				throw new NotSupportedException("All specified TLS versions are incompatible with this platform.");
			}
		}
		if (csb.TlsCipherSuites.Length != 0)
		{
			throw new PlatformNotSupportedException("The TlsCipherSuites connection string option is only supported on .NET Core 3.1 (or later) on Linux.");
		}
		Pooling = csb.Pooling;
		ConnectionLifeTime = Math.Min(csb.ConnectionLifeTime, 4294967u) * 1000;
		ConnectionReset = csb.ConnectionReset;
		ConnectionIdleTimeout = (int)csb.ConnectionIdleTimeout;
		if (csb.MinimumPoolSize > csb.MaximumPoolSize)
		{
			throw new MySqlException("MaximumPoolSize must be greater than or equal to MinimumPoolSize");
		}
		MinimumPoolSize = ToSigned(csb.MinimumPoolSize);
		MaximumPoolSize = ToSigned(csb.MaximumPoolSize);
		DnsCheckInterval = ToSigned(csb.DnsCheckInterval);
		AllowLoadLocalInfile = csb.AllowLoadLocalInfile;
		AllowPublicKeyRetrieval = csb.AllowPublicKeyRetrieval;
		AllowUserVariables = csb.AllowUserVariables;
		AllowZeroDateTime = csb.AllowZeroDateTime;
		string applicationName = csb.ApplicationName;
		ApplicationName = ((applicationName != null && applicationName.Length == 0) ? null : csb.ApplicationName);
		AutoEnlist = csb.AutoEnlist;
		CancellationTimeout = csb.CancellationTimeout;
		ConnectionTimeout = ToSigned(csb.ConnectionTimeout);
		ConvertZeroDateTime = csb.ConvertZeroDateTime;
		DateTimeKind = (DateTimeKind)csb.DateTimeKind;
		DefaultCommandTimeout = ToSigned(csb.DefaultCommandTimeout);
		ForceSynchronous = csb.ForceSynchronous;
		IgnoreCommandTransaction = csb.IgnoreCommandTransaction;
		IgnorePrepare = csb.IgnorePrepare;
		InteractiveSession = csb.InteractiveSession;
		GuidFormat = GetEffectiveGuidFormat(csb.GuidFormat, csb.OldGuids);
		Keepalive = csb.Keepalive;
		NoBackslashEscapes = csb.NoBackslashEscapes;
		PersistSecurityInfo = csb.PersistSecurityInfo;
		Pipelining = (csb.ContainsKey("Pipelining") ? new bool?(csb.Pipelining) : ((bool?)null));
		ServerRedirectionMode = csb.ServerRedirectionMode;
		ServerRsaPublicKeyFile = csb.ServerRsaPublicKeyFile;
		ServerSPN = csb.ServerSPN;
		TreatTinyAsBoolean = csb.TreatTinyAsBoolean;
		UseAffectedRows = csb.UseAffectedRows;
		UseCompression = csb.UseCompression;
		UseXaTransactions = csb.UseXaTransactions;
		static int ToSigned(uint value)
		{
			if (value < int.MaxValue)
			{
				return (int)value;
			}
			return int.MaxValue;
		}
	}

	public ConnectionSettings CloneWith(string host, int port, string userId)
	{
		return new ConnectionSettings(this, host, port, userId);
	}

	private static MySqlGuidFormat GetEffectiveGuidFormat(MySqlGuidFormat guidFormat, bool oldGuids)
	{
		switch (guidFormat)
		{
		case MySqlGuidFormat.Default:
			if (!oldGuids)
			{
				return MySqlGuidFormat.Char36;
			}
			return MySqlGuidFormat.LittleEndianBinary16;
		case MySqlGuidFormat.None:
		case MySqlGuidFormat.Char36:
		case MySqlGuidFormat.Char32:
		case MySqlGuidFormat.Binary16:
		case MySqlGuidFormat.TimeSwapBinary16:
		case MySqlGuidFormat.LittleEndianBinary16:
			if (oldGuids)
			{
				throw new MySqlException("OldGuids cannot be used with GuidFormat");
			}
			return guidFormat;
		default:
			throw new MySqlException("Unknown GuidFormat");
		}
	}

	private ConnectionSettings(ConnectionSettings other, string host, int port, string userId)
	{
		ConnectionStringBuilder = other.ConnectionStringBuilder;
		ConnectionString = other.ConnectionString;
		ConnectionProtocol = MySqlConnectionProtocol.Sockets;
		HostNames = new <>z__ReadOnlyArray<string>(new string[1] { host });
		LoadBalance = other.LoadBalance;
		Port = port;
		PipeName = other.PipeName;
		UserID = userId;
		Password = other.Password;
		Database = other.Database;
		SslMode = other.SslMode;
		CertificateFile = other.CertificateFile;
		CertificatePassword = other.CertificatePassword;
		SslCertificateFile = other.SslCertificateFile;
		SslKeyFile = other.SslKeyFile;
		CACertificateFile = other.CACertificateFile;
		CertificateStoreLocation = other.CertificateStoreLocation;
		CertificateThumbprint = other.CertificateThumbprint;
		Pooling = other.Pooling;
		ConnectionLifeTime = other.ConnectionLifeTime;
		ConnectionReset = other.ConnectionReset;
		ConnectionIdleTimeout = other.ConnectionIdleTimeout;
		MinimumPoolSize = other.MinimumPoolSize;
		MaximumPoolSize = other.MaximumPoolSize;
		DnsCheckInterval = other.DnsCheckInterval;
		AllowLoadLocalInfile = other.AllowLoadLocalInfile;
		AllowPublicKeyRetrieval = other.AllowPublicKeyRetrieval;
		AllowUserVariables = other.AllowUserVariables;
		AllowZeroDateTime = other.AllowZeroDateTime;
		ApplicationName = other.ApplicationName;
		AutoEnlist = other.AutoEnlist;
		ConnectionTimeout = other.ConnectionTimeout;
		ConvertZeroDateTime = other.ConvertZeroDateTime;
		DateTimeKind = other.DateTimeKind;
		DefaultCommandTimeout = other.DefaultCommandTimeout;
		ForceSynchronous = other.ForceSynchronous;
		IgnoreCommandTransaction = other.IgnoreCommandTransaction;
		IgnorePrepare = other.IgnorePrepare;
		InteractiveSession = other.InteractiveSession;
		GuidFormat = other.GuidFormat;
		Keepalive = other.Keepalive;
		NoBackslashEscapes = other.NoBackslashEscapes;
		PersistSecurityInfo = other.PersistSecurityInfo;
		Pipelining = other.Pipelining;
		ServerRedirectionMode = other.ServerRedirectionMode;
		ServerRsaPublicKeyFile = other.ServerRsaPublicKeyFile;
		ServerSPN = other.ServerSPN;
		TreatTinyAsBoolean = other.TreatTinyAsBoolean;
		UseAffectedRows = other.UseAffectedRows;
		UseCompression = other.UseCompression;
		UseXaTransactions = other.UseXaTransactions;
	}
}


using System;
using System.Data;
using System.Globalization;
using System.Runtime.CompilerServices;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class DbTypeMapping
{
	public Type ClrType { get; }

	public DbType[] DbTypes { get; }

	public DbTypeMapping(Type clrType, DbType[] dbTypes, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 1 })] Func<object, object> convert = null)
	{
		ClrType = clrType;
		DbTypes = dbTypes;
		base..ctor();
	}

	public object DoConversion(object obj)
	{
		if (obj.GetType() == ClrType)
		{
			return obj;
		}
		if (convert != null)
		{
			return convert(obj);
		}
		return Convert.ChangeType(obj, ClrType, CultureInfo.InvariantCulture);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Transactions;
using MySqlConnector;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal abstract class EnlistedTransactionBase : IEnlistmentNotification
{
	public MySqlConnection Connection { get; set; }

	public bool IsIdle { get; set; }

	public bool IsPrepared { get; private set; }

	public Transaction Transaction { get; private set; }

	protected EnlistedTransactionBase(Transaction transaction, MySqlConnection connection)
	{
		Connection = connection;
		Transaction = transaction;
		base..ctor();
	}

	public void Start()
	{
		OnStart();
		Transaction.EnlistVolatile(this, EnlistmentOptions.None);
	}

	void IEnlistmentNotification.Prepare(PreparingEnlistment preparingEnlistment)
	{
		try
		{
			OnPrepare(preparingEnlistment);
			IsPrepared = true;
			preparingEnlistment.Prepared();
		}
		catch (Exception e)
		{
			preparingEnlistment.ForceRollback(e);
		}
	}

	void IEnlistmentNotification.Commit(Enlistment enlistment)
	{
		OnCommit(enlistment);
		enlistment.Done();
		Connection.UnenlistTransaction();
	}

	void IEnlistmentNotification.Rollback(Enlistment enlistment)
	{
		OnRollback(enlistment);
		enlistment.Done();
		Connection.UnenlistTransaction();
	}

	public void InDoubt(Enlistment enlistment)
	{
		throw new NotImplementedException();
	}

	protected abstract void OnStart();

	protected abstract void OnPrepare(PreparingEnlistment enlistment);

	protected abstract void OnCommit(Enlistment enlistment);

	protected abstract void OnRollback(Enlistment enlistment);
}


using System.Runtime.CompilerServices;
using System.Threading;
using MySqlConnector;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
internal interface ICancellableCommand
{
	int CommandId { get; }

	int CommandTimeout { get; }

	int? EffectiveCommandTimeout { get; set; }

	int CancelAttemptCount { get; set; }

	MySqlConnection Connection { get; }

	bool IsTimedOut { get; }

	CancellationTokenRegistration RegisterCancel(CancellationToken cancellationToken);

	void SetTimeout(int milliseconds);
}


using System;
using System.Runtime.CompilerServices;
using System.Threading;
using MySqlConnector.Core;

internal static class ICancellableCommandExtensions
{
	private static int s_id = 1;

	public static int GetNextId()
	{
		return Interlocked.Increment(ref s_id);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static void ResetCommandTimeout(this ICancellableCommand command)
	{
		int? num = command.EffectiveCommandTimeout;
		if (num == int.MaxValue)
		{
			return;
		}
		ServerSession serverSession = command.Connection?.Session;
		if (serverSession != null)
		{
			if (!num.HasValue)
			{
				int commandTimeout = command.CommandTimeout;
				int cancellationTimeout = serverSession.CancellationTimeout;
				num = (command.EffectiveCommandTimeout = ((commandTimeout != 0 && cancellationTimeout != 0) ? new int?(Math.Min(commandTimeout, Math.Max(1, 2147483 - Math.Max(0, serverSession.CancellationTimeout))) * 1000) : new int?(int.MaxValue)));
			}
			if (num == int.MaxValue)
			{
				serverSession.SetTimeout(int.MaxValue);
			}
			else if (serverSession.CancellationTimeout > 0)
			{
				command.SetTimeout(num.Value);
				serverSession.SetTimeout(num.Value + serverSession.CancellationTimeout * 1000);
			}
			else
			{
				serverSession.SetTimeout(num.Value);
			}
		}
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector.Core;
using MySqlConnector.Protocol.Serialization;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal interface ICommandPayloadCreator
{
	bool WriteQueryCommand(ref CommandListPosition commandListPosition, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })] IDictionary<string, CachedProcedure> cachedProcedures, ByteBufferWriter writer, bool appendSemicolon);
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal interface ILoadBalancer
{
	IReadOnlyList<string> LoadBalance(IReadOnlyList<string> hosts);
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector.Core;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class FailOverLoadBalancer : ILoadBalancer
{
	public static ILoadBalancer Instance { get; } = new FailOverLoadBalancer();

	public IReadOnlyList<string> LoadBalance(IReadOnlyList<string> hosts)
	{
		return hosts;
	}

	private FailOverLoadBalancer()
	{
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector.Core;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class RandomLoadBalancer : ILoadBalancer
{
	private readonly Random m_random;

	public static ILoadBalancer Instance { get; } = new RandomLoadBalancer();

	public IReadOnlyList<string> LoadBalance(IReadOnlyList<string> hosts)
	{
		List<string> list = new List<string>(hosts);
		for (int num = hosts.Count - 1; num >= 1; num--)
		{
			int num2;
			lock (m_random)
			{
				num2 = m_random.Next(num + 1);
			}
			if (num != num2)
			{
				List<string> list2 = list;
				int index = num2;
				List<string> list3 = list;
				int index2 = num;
				string value = list[num];
				string value2 = list[num2];
				list2[index] = value;
				list3[index2] = value2;
			}
		}
		return list;
	}

	private RandomLoadBalancer()
	{
		m_random = new Random();
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector.Core;

internal sealed class RoundRobinLoadBalancer : ILoadBalancer
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private readonly object m_lock;

	private uint m_counter;

	public RoundRobinLoadBalancer()
	{
		m_lock = new object();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public IReadOnlyList<string> LoadBalance(IReadOnlyList<string> hosts)
	{
		int num;
		lock (m_lock)
		{
			num = (int)(m_counter++ % hosts.Count);
		}
		List<string> list = new List<string>(hosts.Count);
		for (int i = num; i < hosts.Count; i++)
		{
			list.Add(hosts[i]);
		}
		for (int j = 0; j < num; j++)
		{
			list.Add(hosts[j]);
		}
		return list;
	}
}


using System.Data;
using System.Runtime.CompilerServices;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using MySqlConnector.Core;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
internal interface IMySqlCommand
{
	string CommandText { get; }

	CommandType CommandType { get; }

	bool AllowUserVariables { get; }

	CommandBehavior CommandBehavior { get; }

	MySqlParameterCollection RawParameters { get; }

	MySqlAttributeCollection RawAttributes { get; }

	MySqlConnection Connection { get; }

	long LastInsertedId { get; }

	MySqlParameterCollection OutParameters { get; set; }

	MySqlParameter ReturnParameter { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	ICancellableCommand CancellableCommand
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get;
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	ILogger Logger
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get;
	}

	PreparedStatements TryGetPreparedStatements();

	void SetLastInsertedId(long lastInsertedId);
}


using System;
using System.Data;
using System.Runtime.CompilerServices;
using MySqlConnector;
using MySqlConnector.Core;

internal static class IMySqlCommandExtensions
{
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static StatementPreparerOptions CreateStatementPreparerOptions(this IMySqlCommand command)
	{
		MySqlConnection connection = command.Connection;
		StatementPreparerOptions statementPreparerOptions = StatementPreparerOptions.None;
		if (connection.AllowUserVariables || command.CommandType == CommandType.StoredProcedure || command.AllowUserVariables)
		{
			statementPreparerOptions |= StatementPreparerOptions.AllowUserVariables;
		}
		if (connection.DateTimeKind == DateTimeKind.Utc)
		{
			statementPreparerOptions |= StatementPreparerOptions.DateTimeUtc;
		}
		else if (connection.DateTimeKind == DateTimeKind.Local)
		{
			statementPreparerOptions |= StatementPreparerOptions.DateTimeLocal;
		}
		if (command.CommandType == CommandType.StoredProcedure)
		{
			statementPreparerOptions |= StatementPreparerOptions.AllowOutputParameters;
		}
		if (connection.NoBackslashEscapes)
		{
			statementPreparerOptions |= StatementPreparerOptions.NoBackslashEscapes;
		}
		StatementPreparerOptions statementPreparerOptions2 = statementPreparerOptions;
		return (StatementPreparerOptions)((int)statementPreparerOptions2 | (connection.GuidFormat switch
		{
			MySqlGuidFormat.Char36 => 32, 
			MySqlGuidFormat.Char32 => 64, 
			MySqlGuidFormat.Binary16 => 96, 
			MySqlGuidFormat.TimeSwapBinary16 => 128, 
			MySqlGuidFormat.LittleEndianBinary16 => 160, 
			_ => 0, 
		}));
	}
}


using System.Runtime.CompilerServices;
using System.Threading.Tasks;

internal interface IValuesEnumerator
{
	int FieldCount { get; }

	ValueTask<bool> MoveNextAsync();

	bool MoveNext();

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	void GetValues(object[] values);
}


using System.Data.Common;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using MySqlConnector.Core;

internal sealed class DbDataReaderValuesEnumerator([field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] DbDataReader dataReader) : IValuesEnumerator
{
	public int FieldCount => dataReader.FieldCount;

	public ValueTask<bool> MoveNextAsync()
	{
		return new ValueTask<bool>(dataReader.ReadAsync());
	}

	public bool MoveNext()
	{
		return dataReader.Read();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public void GetValues(object[] values)
	{
		dataReader.GetValues(values);
	}
}


using System.Data;
using System.Data.Common;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using MySqlConnector.Core;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class DataReaderValuesEnumerator(IDataReader dataReader) : IValuesEnumerator
{
	public int FieldCount => dataReader.FieldCount;

	public static IValuesEnumerator Create(IDataReader dataReader)
	{
		if (!(dataReader is DbDataReader dataReader2))
		{
			return new DataReaderValuesEnumerator(dataReader);
		}
		return new DbDataReaderValuesEnumerator(dataReader2);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public ValueTask<bool> MoveNextAsync()
	{
		return new ValueTask<bool>(MoveNext());
	}

	public bool MoveNext()
	{
		return dataReader.Read();
	}

	public void GetValues(object[] values)
	{
		dataReader.GetValues(values);
	}
}


using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using MySqlConnector.Core;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class DataRowsValuesEnumerator : IValuesEnumerator
{
	private readonly IEnumerator<DataRow> m_dataRows;

	public int FieldCount { get; }

	public DataRowsValuesEnumerator(IEnumerable<DataRow> dataRows, int columnCount)
	{
		FieldCount = columnCount;
		m_dataRows = dataRows.GetEnumerator();
		base..ctor();
	}

	public static IValuesEnumerator Create(DataTable dataTable)
	{
		return new DataRowsValuesEnumerator(from DataRow x in dataTable.Rows
			where x != null
			select (x), dataTable.Columns.Count);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public ValueTask<bool> MoveNextAsync()
	{
		return new ValueTask<bool>(MoveNext());
	}

	public bool MoveNext()
	{
		if (m_dataRows.MoveNext())
		{
			return true;
		}
		m_dataRows.Dispose();
		return false;
	}

	public void GetValues(object[] values)
	{
		DataRow current = m_dataRows.Current;
		for (int i = 0; i < FieldCount; i++)
		{
			values[i] = current[i];
		}
	}
}


using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Linq;
using System.Runtime.CompilerServices;
using MySqlConnector.Core;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal static class MetricsReporter
{
	private static readonly UpDownCounter<int> s_connectionsUsageCounter;

	private static readonly UpDownCounter<int> s_pendingRequestsCounter;

	private static readonly Counter<int> s_connectionTimeouts;

	private static readonly Histogram<double> s_createTimeHistory;

	private static readonly Histogram<double> s_useTimeHistory;

	private static readonly Histogram<double> s_waitTimeHistory;

	public static void AddIdle(ConnectionPool pool)
	{
		s_connectionsUsageCounter.Add(1, pool.IdleStateTagList);
	}

	public static void RemoveIdle(ConnectionPool pool)
	{
		s_connectionsUsageCounter.Add(-1, pool.IdleStateTagList);
	}

	public static void AddUsed(ConnectionPool pool)
	{
		s_connectionsUsageCounter.Add(1, pool.UsedStateTagList);
	}

	public static void RemoveUsed(ConnectionPool pool)
	{
		s_connectionsUsageCounter.Add(-1, pool.UsedStateTagList);
	}

	public static void AddTimeout([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] ConnectionPool pool, ConnectionSettings connectionSettings)
	{
		s_connectionTimeouts.Add(1, new KeyValuePair<string, object>("pool.name", pool?.Name ?? connectionSettings.ApplicationName ?? connectionSettings.ConnectionStringBuilder.GetConnectionString(includePassword: false)));
	}

	public static void RecordCreateTime(ConnectionPool pool, double seconds)
	{
		s_createTimeHistory.Record(seconds, pool.PoolNameTagList);
	}

	public static void RecordUseTime(ConnectionPool pool, double seconds)
	{
		s_useTimeHistory.Record(seconds, pool.PoolNameTagList);
	}

	public static void RecordWaitTime(ConnectionPool pool, double seconds)
	{
		s_waitTimeHistory.Record(seconds, pool.PoolNameTagList);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public static void AddPendingRequest(ConnectionPool pool)
	{
		if (pool != null)
		{
			s_pendingRequestsCounter.Add(1, pool.PoolNameTagList);
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public static void RemovePendingRequest(ConnectionPool pool)
	{
		if (pool != null)
		{
			s_pendingRequestsCounter.Add(-1, pool.PoolNameTagList);
		}
	}

	static MetricsReporter()
	{
		s_connectionsUsageCounter = ActivitySourceHelper.Meter.CreateUpDownCounter<int>("db.client.connections.usage", "{connection}", "The number of connections that are currently in the state described by the state tag.");
		s_pendingRequestsCounter = ActivitySourceHelper.Meter.CreateUpDownCounter<int>("db.client.connections.pending_requests", "{request}", "The number of pending requests for an open connection, cumulative for the entire pool.");
		s_connectionTimeouts = ActivitySourceHelper.Meter.CreateCounter<int>("db.client.connections.timeouts", "{timeout}", "The number of connection timeouts that have occurred trying to obtain a connection from the pool.");
		s_createTimeHistory = ActivitySourceHelper.Meter.CreateHistogram<double>("db.client.connections.create_time", "s", "The time it took to create a new connection.");
		s_useTimeHistory = ActivitySourceHelper.Meter.CreateHistogram<double>("db.client.connections.use_time", "s", "The time between borrowing a connection and returning it to the pool.");
		s_waitTimeHistory = ActivitySourceHelper.Meter.CreateHistogram<double>("db.client.connections.wait_time", "s", "The time it took to obtain an open connection from the pool.");
		ActivitySourceHelper.Meter.CreateObservableUpDownCounter("db.client.connections.idle.max", GetMaximumConnections, "{connection}", "The maximum number of idle open connections allowed; this corresponds to MaximumPoolSize in the connection string.");
		ActivitySourceHelper.Meter.CreateObservableUpDownCounter("db.client.connections.idle.min", GetMinimumConnections, "{connection}", "The minimum number of idle open connections allowed; this corresponds to MinimumPoolSize in the connection string.");
		ActivitySourceHelper.Meter.CreateObservableUpDownCounter("db.client.connections.max", GetMaximumConnections, "{connection}", "The maximum number of open connections allowed; this corresponds to MaximumPoolSize in the connection string.");
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0 })]
		static IEnumerable<Measurement<int>> GetMaximumConnections()
		{
			return from x in ConnectionPool.GetAllPools()
				select new Measurement<int>(x.ConnectionSettings.MaximumPoolSize, x.PoolNameTagList);
		}
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0 })]
		static IEnumerable<Measurement<int>> GetMinimumConnections()
		{
			return from x in ConnectionPool.GetAllPools()
				select new Measurement<int>(x.ConnectionSettings.MinimumPoolSize, x.PoolNameTagList);
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using MySqlConnector.Core;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class NormalizedSchema
{
	private const string ReQuoted = "`((?:[^`]|``)+)`";

	private const string ReUnQuoted = "([^\\.`]+)";

	private const string ReEither = "(?:`((?:[^`]|``)+)`|([^\\.`]+))";

	private const string ReName = "^\\s*(?:`((?:[^`]|``)+)`|([^\\.`]+))\\s*(?:\\.\\s*(?:`((?:[^`]|``)+)`|([^\\.`]+))\\s*)?$";

	private static readonly Regex s_nameRegex = new Regex("^\\s*(?:`((?:[^`]|``)+)`|([^\\.`]+))\\s*(?:\\.\\s*(?:`((?:[^`]|``)+)`|([^\\.`]+))\\s*)?$", RegexOptions.Compiled);

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public string Schema
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public string Component
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
	}

	public string FullyQualified => "`" + Schema + "`.`" + Component + "`";

	private static Regex NameRegex()
	{
		return s_nameRegex;
	}

	public static NormalizedSchema MustNormalize(string name, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string defaultSchema = null)
	{
		NormalizedSchema normalizedSchema = new NormalizedSchema(name, defaultSchema);
		if (normalizedSchema != null)
		{
			if (normalizedSchema.Component != null)
			{
				if (normalizedSchema.Schema == null)
				{
					throw new ArgumentException("Could not determine schema", "defaultSchema");
				}
				return normalizedSchema;
			}
			throw new ArgumentException("Could not determine function/procedure name", "name");
		}
		<54935a9f-04ec-42f0-b2db-de3406f234de><PrivateImplementationDetails>.ThrowInvalidOperationException();
		NormalizedSchema result = default(NormalizedSchema);
		return result;
	}

	public NormalizedSchema(string name, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string defaultSchema = null)
	{
		Match match = NameRegex().Match(name);
		if (match.Success)
		{
			if (match.Groups[3].Success)
			{
				Component = match.Groups[3].Value.Replace("``", "`").Trim();
			}
			else if (match.Groups[4].Success)
			{
				Component = match.Groups[4].Value.Trim();
			}
			string text = "";
			if (match.Groups[1].Success)
			{
				text = match.Groups[1].Value.Replace("``", "`").Trim();
			}
			else if (match.Groups[2].Success)
			{
				text = match.Groups[2].Value.Trim();
			}
			if (Component == null)
			{
				Component = text.Trim();
			}
			else
			{
				Schema = text.Trim();
			}
			if (Schema == null)
			{
				Schema = defaultSchema;
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

internal sealed class ParsedStatement
{
	public ArraySegment<byte> StatementBytes { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
	public List<string> ParameterNames
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
		get;
	} = new List<string>();

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
	public List<string> NormalizedParameterNames
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
		get;
	} = new List<string>();

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public List<int> ParameterIndexes
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
		get;
	} = new List<int>();
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector.Core;
using MySqlConnector.Protocol;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class ParsedStatements(List<ParsedStatement> statements, PayloadData payloadData) : IDisposable
{
	public IReadOnlyList<ParsedStatement> Statements => statements;

	public void Dispose()
	{
		statements.Clear();
		payloadData.Dispose();
		payloadData = default(PayloadData);
	}
}


using System.Runtime.CompilerServices;
using MySqlConnector.Core;
using MySqlConnector.Protocol.Payloads;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class PreparedStatement(int statementId, ParsedStatement statement, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })] [property: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })] ColumnDefinitionPayload[] columns, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })] [property: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })] ColumnDefinitionPayload[] parameters)
{
	public int StatementId { get; } = statementId;

	public ParsedStatement Statement { get; } = statement;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	public ColumnDefinitionPayload[] Columns
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
		get;
		[param: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
		set;
	} = columns;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	public ColumnDefinitionPayload[] Parameters
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
		get;
	} = parameters;
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector.Core;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class PreparedStatements : IDisposable
{
	public IReadOnlyList<PreparedStatement> Statements { get; }

	public PreparedStatements(IReadOnlyList<PreparedStatement> preparedStatements, ParsedStatements parsedStatements)
	{
		Statements = preparedStatements;
		base..ctor();
	}

	public void Dispose()
	{
		parsedStatements?.Dispose();
		parsedStatements = null;
	}
}


using System;
using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Threading;
using System.Threading.Tasks;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class ResultSet(MySqlDataReader dataReader)
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private ResizableArray<byte> m_columnDefinitionPayloadBytes;

	private int m_columnDefinitionPayloadUsedBytes;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	private Queue<Row> m_readBuffer;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private Row m_row;

	private bool m_hasRows;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	private ReadOnlyMemory<ColumnDefinitionPayload> m_columnDefinitions;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	private ColumnDefinitionPayload[] m_columnDefinitionPayloadCache;

	public int Depth => 0;

	public int FieldCount => ColumnDefinitions.Length;

	public bool HasRows
	{
		get
		{
			if (BufferState == ResultSetState.ReadResultSetHeader)
			{
				return BufferReadAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult() != null;
			}
			return m_hasRows;
		}
	}

	public MySqlDataReader DataReader { get; } = dataReader;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public ExceptionDispatchInfo ReadResultSetHeaderException
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		private set;
	}

	public IMySqlCommand Command => DataReader.Command;

	public MySqlConnection Connection => DataReader.Connection;

	public ServerSession Session => DataReader.Session;

	public ResultSetState BufferState { get; private set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public ReadOnlySpan<ColumnDefinitionPayload> ColumnDefinitions
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
		get
		{
			return m_columnDefinitions.Span;
		}
	}

	public int WarningCount { get; private set; }

	public ResultSetState State { get; private set; }

	public bool HasResultSet
	{
		get
		{
			if (State != 0)
			{
				return ColumnDefinitions.Length != 0;
			}
			return false;
		}
	}

	public bool ContainsCommandParameters { get; private set; }

	public void Reset()
	{
		BufferState = ResultSetState.None;
		m_columnDefinitions = default(ReadOnlyMemory<ColumnDefinitionPayload>);
		WarningCount = 0;
		State = ResultSetState.None;
		ContainsCommandParameters = false;
		m_columnDefinitionPayloadUsedBytes = 0;
		m_readBuffer?.Clear();
		m_row = null;
		m_hasRows = false;
		ReadResultSetHeaderException = null;
	}

	public async Task ReadResultSetHeaderAsync(IOBehavior ioBehavior)
	{
		Reset();
		try
		{
			while (true)
			{
				PayloadData payloadData = await Session.ReceiveReplyAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
				switch (payloadData.HeaderByte)
				{
				case 0:
				{
					OkPayload okPayload = OkPayload.Create(payloadData.Span, Session.SupportsDeprecateEof, Session.SupportsSessionTrack);
					if (State != ResultSetState.ReadResultSetHeader || okPayload.AffectedRowCount != 0L)
					{
						DataReader.RealRecordsAffected = DataReader.RealRecordsAffected.GetValueOrDefault() + okPayload.AffectedRowCount;
					}
					if (okPayload.LastInsertId != 0L)
					{
						Command?.SetLastInsertedId((long)okPayload.LastInsertId);
					}
					WarningCount = okPayload.WarningCount;
					if (okPayload.NewSchema != null)
					{
						Connection.Session.DatabaseOverride = okPayload.NewSchema;
					}
					m_columnDefinitions = default(ReadOnlyMemory<ColumnDefinitionPayload>);
					State = (((okPayload.ServerStatus & ServerStatus.MoreResultsExist) == 0) ? ResultSetState.NoMoreData : ResultSetState.HasMoreData);
					if (State == ResultSetState.NoMoreData)
					{
						return;
					}
					continue;
				}
				case 251:
					try
					{
						if (!Connection.AllowLoadLocalInfile)
						{
							throw new NotSupportedException("To use LOAD DATA LOCAL INFILE, set AllowLoadLocalInfile=true in the connection string. See https://fl.vu/mysql-load-data");
						}
						LocalInfilePayload localInfilePayload = LocalInfilePayload.Create(payloadData.Span);
						bool flag = localInfilePayload.FileName.StartsWith(":SOURCE:", StringComparison.Ordinal);
						if (!IsHostVerified(Connection) && !flag)
						{
							throw new NotSupportedException("Use SourceStream or SslMode >= VerifyCA for LOAD DATA LOCAL INFILE. See https://fl.vu/mysql-load-data");
						}
						object obj = (flag ? MySqlBulkLoader.GetAndRemoveSource(localInfilePayload.FileName) : File.OpenRead(localInfilePayload.FileName));
						if (!(obj is Stream stream))
						{
							if (!(obj is MySqlBulkCopy mySqlBulkCopy))
							{
								throw new InvalidOperationException("Unsupported Source type: " + obj.GetType().Name);
							}
							await mySqlBulkCopy.SendDataReaderAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
						}
						else
						{
							byte[] buffer = ArrayPool<byte>.Shared.Rent(1048576);
							try
							{
								int count;
								while ((count = await stream.ReadAsync(buffer, 0, buffer.Length, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false)) > 0)
								{
									payloadData = new PayloadData(new ArraySegment<byte>(buffer, 0, count));
									await Session.SendReplyAsync(payloadData, ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
								}
							}
							finally
							{
								ArrayPool<byte>.Shared.Return(buffer);
								stream.Dispose();
							}
						}
					}
					catch (Exception innerException)
					{
						ReadResultSetHeaderException = ExceptionDispatchInfo.Capture(new MySqlException("Error during LOAD DATA LOCAL INFILE", innerException));
					}
					await Session.SendReplyAsync(EmptyPayload.Instance, ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
					continue;
				}
				ColumnCountPayload columnCountPayload = ColumnCountPayload.Create(payloadData.Span, Session.SupportsCachedPreparedMetadata);
				int columnCount = columnCountPayload.ColumnCount;
				if (!columnCountPayload.MetadataFollows)
				{
					m_columnDefinitions = DataReader.LastUsedPreparedStatement.Columns;
					if (m_columnDefinitions.Length != columnCount)
					{
						throw new InvalidOperationException($"Expected result set to have {m_columnDefinitions.Length} columns, but it contains {columnCount} columns");
					}
				}
				else
				{
					Utility.Resize(ref m_columnDefinitionPayloadBytes, columnCount * 96);
					if (m_columnDefinitionPayloadCache == null)
					{
						m_columnDefinitionPayloadCache = new ColumnDefinitionPayload[columnCount];
					}
					else if (m_columnDefinitionPayloadCache.Length < columnCount)
					{
						Array.Resize(ref m_columnDefinitionPayloadCache, Math.Max(columnCount, m_columnDefinitionPayloadCache.Length * 2));
					}
					m_columnDefinitions = MemoryExtensions.AsMemory(m_columnDefinitionPayloadCache, 0, columnCount);
					ColumnDefinitionPayload[] preparedColumns = ((!Session.SupportsCachedPreparedMetadata) ? null : DataReader.LastUsedPreparedStatement?.Columns);
					for (int column = 0; column < columnCount; column++)
					{
						payloadData = await Session.ReceiveReplyAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
						int length = payloadData.Span.Length;
						if (m_columnDefinitionPayloadUsedBytes + length > m_columnDefinitionPayloadBytes.Count)
						{
							Utility.Resize(ref m_columnDefinitionPayloadBytes, m_columnDefinitionPayloadUsedBytes + length);
						}
						payloadData.Span.CopyTo(m_columnDefinitionPayloadBytes.AsSpan(m_columnDefinitionPayloadUsedBytes));
						ResizableArraySegment<byte> arraySegment = new ResizableArraySegment<byte>(m_columnDefinitionPayloadBytes, m_columnDefinitionPayloadUsedBytes, length);
						ColumnDefinitionPayload.Initialize(ref m_columnDefinitionPayloadCache[column], arraySegment);
						if (preparedColumns != null)
						{
							ColumnDefinitionPayload.Initialize(ref preparedColumns[column], arraySegment);
						}
						m_columnDefinitionPayloadUsedBytes += length;
					}
				}
				if (!Session.SupportsDeprecateEof)
				{
					EofPayload.Create((await Session.ReceiveReplyAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false)).Span);
				}
				int length2 = ColumnDefinitions.Length;
				IMySqlCommand command = Command;
				if (length2 == ((command == null) ? ((int?)null) : (command.OutParameters?.Count + 1)) && ColumnDefinitions[0].Name == SingleCommandPayloadCreator.OutParameterSentinelColumnName)
				{
					ContainsCommandParameters = true;
				}
				WarningCount = 0;
				State = ResultSetState.ReadResultSetHeader;
				Activity activity = DataReader.Activity;
				if (activity != null && activity.IsAllDataRequested)
				{
					DataReader.Activity.AddEvent(new ActivityEvent("read-result-set-header"));
				}
				return;
			}
		}
		catch (Exception source)
		{
			ReadResultSetHeaderException = ExceptionDispatchInfo.Capture(source);
		}
		finally
		{
			BufferState = State;
		}
	}

	private static bool IsHostVerified(MySqlConnection connection)
	{
		MySqlSslMode sslMode = connection.SslMode;
		if ((uint)(sslMode - 3) <= 1u)
		{
			return true;
		}
		return false;
	}

	public async Task ReadEntireAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		while (true)
		{
			ResultSetState state = State;
			if ((uint)(state - 1) > 1u)
			{
				break;
			}
			await ReadAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
	}

	public bool Read()
	{
		return ReadAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
	}

	public Task<bool> ReadAsync(CancellationToken cancellationToken)
	{
		return ReadAsync(Connection.AsyncIOBehavior, cancellationToken);
	}

	public async Task<bool> ReadAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		Queue<Row> readBuffer = m_readBuffer;
		Row row = ((readBuffer == null || readBuffer.Count <= 0) ? (await ScanRowAsync(ioBehavior, m_row, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)) : m_readBuffer.Dequeue());
		m_row = row;
		if (Command.ReturnParameter != null && m_row != null)
		{
			Command.ReturnParameter.Value = m_row.GetValue(0);
			Command.ReturnParameter = null;
		}
		if (m_row == null)
		{
			State = BufferState;
			return false;
		}
		State = ResultSetState.ReadingRows;
		return true;
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
	public async Task<Row> BufferReadAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		Row row = await ScanRowAsync(ioBehavior, null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		if (row == null)
		{
			return null;
		}
		if (m_readBuffer == null)
		{
			m_readBuffer = new Queue<Row>();
		}
		m_readBuffer.Enqueue(row);
		return row;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 2 })]
	private async ValueTask<Row> ScanRowAsync(IOBehavior ioBehavior, Row row, CancellationToken cancellationToken)
	{
		ResultSetState bufferState = BufferState;
		if ((bufferState == ResultSetState.None || (uint)(bufferState - 3) <= 1u) ? true : false)
		{
			return null;
		}
		PayloadData payload;
		try
		{
			payload = await Session.ReceiveReplyAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
		}
		catch (MySqlException ex)
		{
			ResultSet resultSet = this;
			bufferState = (State = ResultSetState.NoMoreData);
			resultSet.BufferState = bufferState;
			if (ex.ErrorCode == MySqlErrorCode.QueryInterrupted && cancellationToken.IsCancellationRequested)
			{
				throw new OperationCanceledException(ex.Message, ex, cancellationToken);
			}
			if (ex.ErrorCode == MySqlErrorCode.QueryInterrupted && Command.CancellableCommand.IsTimedOut)
			{
				throw MySqlException.CreateForTimeout(ex);
			}
			throw;
		}
		if (payload.HeaderByte == 254)
		{
			if (Session.SupportsDeprecateEof && OkPayload.IsOk(payload.Span, Session.SupportsDeprecateEof))
			{
				OkPayload okPayload = OkPayload.Create(payload.Span, Session.SupportsDeprecateEof, Session.SupportsSessionTrack);
				BufferState = (((okPayload.ServerStatus & ServerStatus.MoreResultsExist) == 0) ? ResultSetState.NoMoreData : ResultSetState.HasMoreData);
				return null;
			}
			if (!Session.SupportsDeprecateEof && EofPayload.IsEof(payload))
			{
				BufferState = (((EofPayload.Create(payload.Span).ServerStatus & ServerStatus.MoreResultsExist) == 0) ? ResultSetState.NoMoreData : ResultSetState.HasMoreData);
				return null;
			}
		}
		if (row == null)
		{
			row = new Row(Command.TryGetPreparedStatements() != null, this);
		}
		row.SetData(payload.Memory);
		m_hasRows = true;
		BufferState = ResultSetState.ReadingRows;
		return row;
	}

	public string GetName(int ordinal)
	{
		if (!HasResultSet)
		{
			throw new InvalidOperationException("There is no current result set.");
		}
		if (ordinal < 0 || ordinal >= ColumnDefinitions.Length)
		{
			throw new IndexOutOfRangeException($"value must be between 0 and {ColumnDefinitions.Length - 1}");
		}
		return ColumnDefinitions[ordinal].Name;
	}

	public string GetDataTypeName(int ordinal)
	{
		if (!HasResultSet)
		{
			throw new InvalidOperationException("There is no current result set.");
		}
		if (ordinal < 0 || ordinal >= ColumnDefinitions.Length)
		{
			throw new IndexOutOfRangeException($"value must be between 0 and {ColumnDefinitions.Length - 1}");
		}
		MySqlDbType columnType = GetColumnType(ordinal);
		if (columnType == MySqlDbType.String)
		{
			return string.Format(CultureInfo.InvariantCulture, "CHAR({0})", ColumnDefinitions[ordinal].ColumnLength / ProtocolUtility.GetBytesPerCharacter(ColumnDefinitions[ordinal].CharacterSet));
		}
		return TypeMapper.Instance.GetColumnTypeMetadata(columnType).SimpleDataTypeName;
	}

	public Type GetFieldType(int ordinal)
	{
		if (!HasResultSet)
		{
			throw new InvalidOperationException("There is no current result set.");
		}
		if (ordinal < 0 || ordinal >= ColumnDefinitions.Length)
		{
			throw new IndexOutOfRangeException($"value must be between 0 and {ColumnDefinitions.Length - 1}");
		}
		Type type = TypeMapper.Instance.GetColumnTypeMetadata(GetColumnType(ordinal)).DbTypeMapping.ClrType;
		if (Connection.AllowZeroDateTime && type == typeof(DateTime))
		{
			type = typeof(MySqlDateTime);
		}
		return type;
	}

	public MySqlDbType GetColumnType(int ordinal)
	{
		return TypeMapper.ConvertToMySqlDbType(ColumnDefinitions[ordinal], Connection.TreatTinyAsBoolean, Connection.GuidFormat);
	}

	public int GetOrdinal(string name)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		if (!HasResultSet)
		{
			throw new InvalidOperationException("There is no current result set.");
		}
		for (int i = 0; i < ColumnDefinitions.Length; i++)
		{
			if (name.Equals(ColumnDefinitions[i].Name, StringComparison.OrdinalIgnoreCase))
			{
				return i;
			}
		}
		throw new IndexOutOfRangeException("The column name '" + name + "' does not exist in the result set.");
	}

	public Row GetCurrentRow()
	{
		if (State != ResultSetState.ReadingRows)
		{
			throw new InvalidOperationException("Read must be called first.");
		}
		return m_row ?? throw new InvalidOperationException("There is no current row.");
	}
}


internal enum ResultSetState
{
	None,
	ReadResultSetHeader,
	ReadingRows,
	HasMoreData,
	NoMoreData
}


using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using MySqlConnector;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Core;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class Row
{
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private readonly struct OffsetLength
	{
		public int Offset { get; }

		public int Length { get; }

		public OffsetLength(int offset, int length)
		{
			Offset = offset;
			Length = length;
		}

		public static implicit operator OffsetLength((int Offset, int Length) x)
		{
			return new OffsetLength(x.Offset, x.Length);
		}

		public void Deconstruct(out int offset, out int length)
		{
			offset = Offset;
			length = Length;
		}
	}

	private readonly bool m_isBinary;

	private readonly OffsetLength[] m_dataOffsetLengths;

	private readonly ColumnReader[] m_columnReaders;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private ReadOnlyMemory<byte> m_data;

	public object this[int ordinal] => GetValue(ordinal);

	public object this[string name] => GetValue(ResultSet.GetOrdinal(name));

	private ResultSet ResultSet { get; }

	private MySqlConnection Connection => ResultSet.Connection;

	public Row(bool isBinary, ResultSet resultSet)
	{
		m_isBinary = isBinary;
		ResultSet = resultSet;
		ReadOnlySpan<ColumnDefinitionPayload> columnDefinitions = ResultSet.ColumnDefinitions;
		m_dataOffsetLengths = new OffsetLength[columnDefinitions.Length];
		m_columnReaders = new ColumnReader[columnDefinitions.Length];
		for (int i = 0; i < m_columnReaders.Length; i++)
		{
			m_columnReaders[i] = ColumnReader.Create(isBinary, columnDefinitions[i], resultSet.Connection);
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public void SetData(ReadOnlyMemory<byte> data)
	{
		m_data = data;
		if (m_isBinary)
		{
			Array.Clear(m_dataOffsetLengths, 0, m_dataOffsetLengths.Length);
			for (int i = 0; i < m_dataOffsetLengths.Length; i++)
			{
				if ((data.Span[(i + 2) / 8 + 1] & (1 << (i + 2) % 8)) != 0)
				{
					m_dataOffsetLengths[i] = (Offset: -1, Length: 0);
				}
			}
			ByteArrayReader byteArrayReader = new ByteArrayReader(data.Span);
			byteArrayReader.Offset += 1 + (m_dataOffsetLengths.Length + 7 + 2) / 8;
			for (int j = 0; j < m_dataOffsetLengths.Length; j++)
			{
				if (m_dataOffsetLengths[j].Offset != -1)
				{
					ColumnDefinitionPayload columnDefinitionPayload = ResultSet.ColumnDefinitions[j];
					int num;
					switch (columnDefinitionPayload.ColumnType)
					{
					case ColumnType.Double:
					case ColumnType.Longlong:
						num = 8;
						break;
					case ColumnType.Long:
					case ColumnType.Float:
					case ColumnType.Int24:
						num = 4;
						break;
					case ColumnType.Short:
					case ColumnType.Year:
						num = 2;
						break;
					case ColumnType.Tiny:
						num = 1;
						break;
					case ColumnType.Timestamp:
					case ColumnType.Date:
					case ColumnType.Time:
					case ColumnType.DateTime:
					case ColumnType.NewDate:
						num = byteArrayReader.ReadByte();
						break;
					case ColumnType.Timestamp2:
					case ColumnType.DateTime2:
						throw new NotSupportedException($"ColumnType {columnDefinitionPayload.ColumnType} is not supported");
					default:
						num = checked((int)byteArrayReader.ReadLengthEncodedInteger());
						break;
					}
					int num2 = num;
					m_dataOffsetLengths[j] = (Offset: byteArrayReader.Offset, Length: num2);
					byteArrayReader.Offset += num2;
				}
			}
		}
		else
		{
			ByteArrayReader byteArrayReader2 = new ByteArrayReader(data.Span);
			for (int k = 0; k < m_dataOffsetLengths.Length; k++)
			{
				int num3 = byteArrayReader2.ReadLengthEncodedIntegerOrNull();
				m_dataOffsetLengths[k] = ((num3 == -1) ? (Offset: -1, Length: 0) : (Offset: byteArrayReader2.Offset, Length: num3));
				byteArrayReader2.Offset += m_dataOffsetLengths[k].Length;
			}
		}
	}

	public object GetValue(int ordinal)
	{
		if (ordinal < 0 || ordinal >= ResultSet.ColumnDefinitions.Length)
		{
			throw new ArgumentOutOfRangeException("ordinal", $"value must be between 0 and {ResultSet.ColumnDefinitions.Length - 1}");
		}
		if (m_dataOffsetLengths[ordinal].Offset == -1)
		{
			return DBNull.Value;
		}
		OffsetLength offsetLength = m_dataOffsetLengths[ordinal];
		offsetLength.Deconstruct(out var offset, out var length);
		int start = offset;
		int length2 = length;
		ReadOnlySpan<byte> span = m_data.Slice(start, length2).Span;
		ColumnDefinitionPayload columnDefinition = ResultSet.ColumnDefinitions[ordinal];
		return m_columnReaders[ordinal].ReadValue(span, columnDefinition);
	}

	public bool GetBoolean(int ordinal)
	{
		object value = GetValue(ordinal);
		if (!(value is bool result))
		{
			if (!(value is sbyte b))
			{
				if (!(value is byte b2))
				{
					if (!(value is short num))
					{
						if (!(value is ushort num2))
						{
							if (!(value is int num3))
							{
								if (!(value is uint num4))
								{
									if (!(value is long num5))
									{
										if (!(value is ulong num6))
										{
											if (value is decimal num7)
											{
												return num7 != 0m;
											}
											return (bool)value;
										}
										return num6 != 0;
									}
									return num5 != 0;
								}
								return num4 != 0;
							}
							return num3 != 0;
						}
						return num2 != 0;
					}
					return num != 0;
				}
				return b2 != 0;
			}
			return b != 0;
		}
		return result;
	}

	public sbyte GetSByte(int ordinal)
	{
		object value = GetValue(ordinal);
		checked
		{
			if (!(value is sbyte result))
			{
				if (!(value is byte b))
				{
					if (!(value is short num))
					{
						if (!(value is ushort num2))
						{
							if (!(value is int num3))
							{
								if (!(value is uint num4))
								{
									if (!(value is long num5))
									{
										if (!(value is ulong num6))
										{
											if (!(value is decimal num7))
											{
												if (value is bool flag)
												{
													return flag ? ((sbyte)1) : ((sbyte)0);
												}
												return (sbyte)value;
											}
											return (sbyte)num7;
										}
										return (sbyte)num6;
									}
									return (sbyte)num5;
								}
								return (sbyte)num4;
							}
							return (sbyte)num3;
						}
						return (sbyte)num2;
					}
					return (sbyte)num;
				}
				return (sbyte)b;
			}
			return result;
		}
	}

	public byte GetByte(int ordinal)
	{
		object value = GetValue(ordinal);
		checked
		{
			if (!(value is byte result))
			{
				if (!(value is sbyte b))
				{
					if (!(value is short num))
					{
						if (!(value is ushort num2))
						{
							if (!(value is int num3))
							{
								if (!(value is uint num4))
								{
									if (!(value is long num5))
									{
										if (!(value is ulong num6))
										{
											if (!(value is decimal num7))
											{
												if (value is bool flag)
												{
													return flag ? ((byte)1) : ((byte)0);
												}
												return (byte)value;
											}
											return (byte)num7;
										}
										return (byte)num6;
									}
									return (byte)num5;
								}
								return (byte)num4;
							}
							return (byte)num3;
						}
						return (byte)num2;
					}
					return (byte)num;
				}
				return (byte)b;
			}
			return result;
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public long GetBytes(int ordinal, long dataOffset, byte[] buffer, int bufferOffset, int length)
	{
		CheckBinaryColumn(ordinal);
		if (buffer == null)
		{
			return m_dataOffsetLengths[ordinal].Length;
		}
		CheckBufferArguments(dataOffset, buffer, bufferOffset, length);
		int num = (int)dataOffset;
		int num2 = Math.Max(0, Math.Min(m_dataOffsetLengths[ordinal].Length - num, length));
		if (num2 > 0)
		{
			m_data.Slice(m_dataOffsetLengths[ordinal].Offset + num, num2).Span.CopyTo(MemoryExtensions.AsSpan(buffer, bufferOffset));
		}
		return num2;
	}

	public char GetChar(int ordinal)
	{
		string text = (string)GetValue(ordinal);
		if (text.Length <= 0)
		{
			throw new InvalidCastException();
		}
		return text[0];
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public long GetChars(int ordinal, long dataOffset, char[] buffer, int bufferOffset, int length)
	{
		string @string = GetString(ordinal);
		if (buffer == null)
		{
			return @string.Length;
		}
		CheckBufferArguments(dataOffset, buffer, bufferOffset, length);
		int num = (int)dataOffset;
		int num2 = Math.Max(0, Math.Min(@string.Length - num, length));
		if (num2 > 0)
		{
			@string.CopyTo(num, buffer, bufferOffset, num2);
		}
		return num2;
	}

	public Guid GetGuid(int ordinal)
	{
		object value = GetValue(ordinal);
		if (value is Guid)
		{
			return (Guid)value;
		}
		if (value is string input && Guid.TryParse(input, out var result))
		{
			return result;
		}
		if (value is byte[] array && array.Length == 16)
		{
			return Connection.GuidFormat switch
			{
				MySqlGuidFormat.Binary16 => GuidBinary16ColumnReader.ReadGuid(array), 
				MySqlGuidFormat.TimeSwapBinary16 => GuidTimeSwapBinary16ColumnReader.ReadGuid(array), 
				_ => GuidLittleEndianBinary16ColumnReader.ReadGuid(array), 
			};
		}
		return (Guid)value;
	}

	public short GetInt16(int ordinal)
	{
		object value = GetValue(ordinal);
		checked
		{
			if (!(value is short result))
			{
				if (!(value is sbyte result2))
				{
					if (!(value is byte result3))
					{
						if (!(value is ushort num))
						{
							if (!(value is int num2))
							{
								if (!(value is uint num3))
								{
									if (!(value is long num4))
									{
										if (!(value is ulong num5))
										{
											if (!(value is decimal num6))
											{
												if (value is bool flag)
												{
													return flag ? ((short)1) : ((short)0);
												}
												return (short)value;
											}
											return (short)num6;
										}
										return (short)num5;
									}
									return (short)num4;
								}
								return (short)num3;
							}
							return (short)num2;
						}
						return (short)num;
					}
					return result3;
				}
				return result2;
			}
			return result;
		}
	}

	public int GetInt32(int ordinal)
	{
		if (ordinal < 0 || ordinal >= ResultSet.ColumnDefinitions.Length)
		{
			throw new ArgumentOutOfRangeException("ordinal", $"value must be between 0 and {ResultSet.ColumnDefinitions.Length - 1}");
		}
		if (m_dataOffsetLengths[ordinal].Offset == -1)
		{
			throw new InvalidCastException("Can't convert NULL to Int32");
		}
		OffsetLength offsetLength = m_dataOffsetLengths[ordinal];
		offsetLength.Deconstruct(out var offset, out var length);
		int start = offset;
		int length2 = length;
		ReadOnlySpan<byte> span = m_data.Slice(start, length2).Span;
		ColumnDefinitionPayload columnDefinition = ResultSet.ColumnDefinitions[ordinal];
		int? num = m_columnReaders[ordinal].TryReadInt32(span, columnDefinition);
		if (num.HasValue)
		{
			return num.GetValueOrDefault();
		}
		throw new InvalidCastException($"Can't convert {ResultSet.GetColumnType(ordinal)} to Int32");
	}

	public long GetInt64(int ordinal)
	{
		object value = GetValue(ordinal);
		if (!(value is long result))
		{
			if (!(value is sbyte b))
			{
				if (!(value is byte b2))
				{
					if (!(value is short num))
					{
						if (!(value is ushort num2))
						{
							if (!(value is int num3))
							{
								if (!(value is uint num4))
								{
									if (!(value is ulong num5))
									{
										if (!(value is decimal num6))
										{
											if (value is bool flag)
											{
												return flag ? 1 : 0;
											}
											return (long)value;
										}
										return (long)num6;
									}
									return checked((long)num5);
								}
								return num4;
							}
							return num3;
						}
						return num2;
					}
					return num;
				}
				return b2;
			}
			return b;
		}
		return result;
	}

	public ushort GetUInt16(int ordinal)
	{
		object value = GetValue(ordinal);
		checked
		{
			if (!(value is ushort result))
			{
				if (!(value is sbyte b))
				{
					if (!(value is byte result2))
					{
						if (!(value is short num))
						{
							if (!(value is int num2))
							{
								if (!(value is uint num3))
								{
									if (!(value is long num4))
									{
										if (!(value is ulong num5))
										{
											if (!(value is decimal num6))
											{
												if (value is bool flag)
												{
													return flag ? ((ushort)1) : ((ushort)0);
												}
												return (ushort)value;
											}
											return (ushort)num6;
										}
										return (ushort)num5;
									}
									return (ushort)num4;
								}
								return (ushort)num3;
							}
							return (ushort)num2;
						}
						return (ushort)num;
					}
					return result2;
				}
				return (ushort)b;
			}
			return result;
		}
	}

	public uint GetUInt32(int ordinal)
	{
		object value = GetValue(ordinal);
		checked
		{
			if (!(value is uint result))
			{
				if (!(value is sbyte b))
				{
					if (!(value is byte result2))
					{
						if (!(value is short num))
						{
							if (!(value is ushort result3))
							{
								if (!(value is int num2))
								{
									if (!(value is long num3))
									{
										if (!(value is ulong num4))
										{
											if (!(value is decimal num5))
											{
												if (value is bool flag)
												{
													return flag ? 1u : 0u;
												}
												return (uint)value;
											}
											return (uint)num5;
										}
										return (uint)num4;
									}
									return (uint)num3;
								}
								return (uint)num2;
							}
							return result3;
						}
						return (uint)num;
					}
					return result2;
				}
				return (uint)b;
			}
			return result;
		}
	}

	public ulong GetUInt64(int ordinal)
	{
		object value = GetValue(ordinal);
		checked
		{
			if (!(value is ulong result))
			{
				if (!(value is sbyte b))
				{
					if (!(value is byte b2))
					{
						if (!(value is short num))
						{
							if (!(value is ushort num2))
							{
								if (!(value is int num3))
								{
									if (!(value is uint num4))
									{
										if (!(value is long num5))
										{
											if (!(value is decimal num6))
											{
												if (value is bool flag)
												{
													return unchecked((ulong)(flag ? 1 : 0));
												}
												return (ulong)value;
											}
											return (ulong)num6;
										}
										return (ulong)num5;
									}
									return num4;
								}
								return (ulong)num3;
							}
							return num2;
						}
						return (ulong)num;
					}
					return b2;
				}
				return (ulong)b;
			}
			return result;
		}
	}

	public DateTime GetDateTime(int ordinal)
	{
		object obj = GetValue(ordinal);
		if (obj is string { Length: var length } text)
		{
			if (length < 10 || length > 26)
			{
				throw new FormatException($"Couldn't interpret value as a valid DateTime: {obj}");
			}
			obj = TextDateTimeColumnReader.ParseDateTime(Encoding.UTF8.GetBytes(text), Connection.ConvertZeroDateTime, Connection.AllowZeroDateTime, Connection.DateTimeKind);
		}
		if (obj is MySqlDateTime mySqlDateTime)
		{
			return mySqlDateTime.GetDateTime();
		}
		return (DateTime)obj;
	}

	public DateTimeOffset GetDateTimeOffset(int ordinal)
	{
		return new DateTimeOffset(DateTime.SpecifyKind(GetDateTime(ordinal), DateTimeKind.Utc));
	}

	public Stream GetStream(int ordinal)
	{
		CheckBinaryColumn(ordinal);
		OffsetLength offsetLength = m_dataOffsetLengths[ordinal];
		var (num3, count) = (OffsetLength)(ref offsetLength);
		if (!MemoryMarshal.TryGetArray(m_data, out var segment))
		{
			throw new InvalidOperationException("Can't get underlying array.");
		}
		return new MemoryStream(segment.Array, segment.Offset + num3, count, writable: false);
	}

	public string GetString(int ordinal)
	{
		return (string)GetValue(ordinal);
	}

	public decimal GetDecimal(int ordinal)
	{
		object value = GetValue(ordinal);
		if (!(value is decimal result))
		{
			if (!(value is double num))
			{
				if (value is float num2)
				{
					return (decimal)num2;
				}
				return (decimal)value;
			}
			return (decimal)num;
		}
		return result;
	}

	public double GetDouble(int ordinal)
	{
		object value = GetValue(ordinal);
		if (!(value is double result))
		{
			if (!(value is float num))
			{
				if (value is decimal num2)
				{
					return (double)num2;
				}
				return (double)value;
			}
			return num;
		}
		return result;
	}

	public float GetFloat(int ordinal)
	{
		object value = GetValue(ordinal);
		object obj = value;
		if (!(obj is float result))
		{
			if (!(obj is double num))
			{
				if (obj is decimal num2)
				{
					return (float)num2;
				}
				return (float)value;
			}
			if (num >= -3.4028234663852886E+38 && num <= 3.4028234663852886E+38)
			{
				return (float)num;
			}
			throw new InvalidCastException("The value cannot be safely cast to Single.");
		}
		return result;
	}

	public MySqlDateTime GetMySqlDateTime(int ordinal)
	{
		object value = GetValue(ordinal);
		if (value is DateTime dt)
		{
			return new MySqlDateTime(dt);
		}
		return (MySqlDateTime)value;
	}

	public MySqlGeometry GetMySqlGeometry(int ordinal)
	{
		if (GetValue(ordinal) is byte[] bytes && ResultSet.ColumnDefinitions[ordinal].ColumnType == ColumnType.Geometry)
		{
			return new MySqlGeometry(bytes);
		}
		throw new InvalidCastException($"Can't convert {ResultSet.ColumnDefinitions[ordinal].ColumnType} to MySqlGeometry.");
	}

	public MySqlDecimal GetMySqlDecimal(int ordinal)
	{
		if (IsDBNull(ordinal))
		{
			return (MySqlDecimal)GetValue(ordinal);
		}
		OffsetLength offsetLength = m_dataOffsetLengths[ordinal];
		offsetLength.Deconstruct(out var offset, out var length);
		int start = offset;
		int length2 = length;
		ReadOnlySpan<byte> span = m_data.Slice(start, length2).Span;
		ColumnType columnType = ResultSet.ColumnDefinitions[ordinal].ColumnType;
		if ((columnType == ColumnType.Decimal || columnType == ColumnType.NewDecimal) ? true : false)
		{
			return new MySqlDecimal(Encoding.UTF8.GetString(span));
		}
		throw new InvalidCastException($"Can't convert {ResultSet.ColumnDefinitions[ordinal].ColumnType} to MySqlDecimal.");
	}

	public int GetValues(object[] values)
	{
		if (values == null)
		{
			throw new ArgumentNullException("values");
		}
		int num = Math.Min(values.Length, ResultSet.ColumnDefinitions.Length);
		for (int i = 0; i < num; i++)
		{
			values[i] = GetValue(i);
		}
		return num;
	}

	public bool IsDBNull(int ordinal)
	{
		return m_dataOffsetLengths[ordinal].Offset == -1;
	}

	private void CheckBinaryColumn(int ordinal)
	{
		if (m_dataOffsetLengths[ordinal].Offset == -1)
		{
			throw new InvalidCastException("Column is NULL.");
		}
		ColumnDefinitionPayload obj = ResultSet.ColumnDefinitions[ordinal];
		ColumnType columnType = obj.ColumnType;
		if ((obj.ColumnFlags & ColumnFlags.Binary) == 0 || (columnType != ColumnType.String && columnType != ColumnType.VarString && columnType != ColumnType.TinyBlob && columnType != ColumnType.Blob && columnType != ColumnType.MediumBlob && columnType != ColumnType.LongBlob && columnType != ColumnType.Geometry))
		{
			throw new InvalidCastException($"Can't convert {columnType} to bytes.");
		}
	}

	private static void CheckBufferArguments<[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] T>(long dataOffset, T[] buffer, int bufferOffset, int length)
	{
		if (dataOffset < 0)
		{
			throw new ArgumentOutOfRangeException("dataOffset", dataOffset, "dataOffset must be non-negative");
		}
		if (dataOffset > int.MaxValue)
		{
			throw new ArgumentOutOfRangeException("dataOffset", dataOffset, "dataOffset must be a 32-bit integer");
		}
		if (length < 0)
		{
			throw new ArgumentOutOfRangeException("length", length, "length must be non-negative");
		}
		if (bufferOffset < 0)
		{
			throw new ArgumentOutOfRangeException("bufferOffset", bufferOffset, "bufferOffset must be non-negative");
		}
		if (bufferOffset > buffer.Length)
		{
			throw new ArgumentOutOfRangeException("bufferOffset", bufferOffset, "bufferOffset must be within the buffer");
		}
		if (checked(bufferOffset + length) > buffer.Length)
		{
			throw new ArgumentException("bufferOffset + length cannot exceed buffer.Length", "length");
		}
	}
}


using System.Runtime.CompilerServices;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
private readonly struct OffsetLength
{
	public int Offset { get; }

	public int Length { get; }

	public OffsetLength(int offset, int length)
	{
		Offset = offset;
		Length = length;
	}

	public static implicit operator OffsetLength((int Offset, int Length) x)
	{
		return new OffsetLength(x.Offset, x.Length);
	}

	public void Deconstruct(out int offset, out int length)
	{
		offset = Offset;
		length = Length;
	}
}


using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Protocol.Serialization;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class SchemaProvider(MySqlConnection connection)
{
	private void DoFillDataSourceInformation(DataTable dataTable)
	{
		DataRow dataRow = dataTable.NewRow();
		dataRow["CompositeIdentifierSeparatorPattern"] = "\\.";
		dataRow["DataSourceProductName"] = "MySQL";
		dataRow["DataSourceProductVersion"] = connection.ServerVersion;
		dataRow["DataSourceProductVersionNormalized"] = GetVersion(connection.Session.ServerVersion.Version);
		dataRow["GroupByBehavior"] = GroupByBehavior.Unrelated;
		dataRow["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\\[[^\\]\\0]|\\]\\]+\\]$)|(^\\\"[^\\\"\\0]|\\\"\\\"+\\\"$)";
		dataRow["IdentifierCase"] = IdentifierCase.Insensitive;
		dataRow["OrderByColumnsInSelect"] = false;
		dataRow["ParameterMarkerFormat"] = "{0}";
		dataRow["ParameterMarkerPattern"] = "(@[A-Za-z0-9_$#]*)";
		dataRow["ParameterNameMaxLength"] = 128;
		dataRow["QuotedIdentifierPattern"] = "(([^\\`]|\\`\\`)*)";
		dataRow["QuotedIdentifierCase"] = IdentifierCase.Sensitive;
		dataRow["ParameterNamePattern"] = "^[\\p{Lo}\\p{Lu}\\p{Ll}\\p{Lm}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Lm}\\p{Nd}\\uff3f_@#\\$]*(?=\\s+|$)";
		dataRow["StatementSeparatorPattern"] = ";";
		dataRow["StringLiteralPattern"] = "'(([^']|'')*)'";
		dataRow["SupportedJoinOperators"] = SupportedJoinOperators.Inner | SupportedJoinOperators.LeftOuter | SupportedJoinOperators.RightOuter | SupportedJoinOperators.FullOuter;
		dataTable.Rows.Add(dataRow);
		static string GetVersion(Version v)
		{
			return FormattableString.Invariant($"{v.Major:00}.{v.Minor:00}.{v.Build:0000}");
		}
	}

	private static void DoFillDataTypes(DataTable dataTable)
	{
		HashSet<string> hashSet = new HashSet<string>();
		foreach (ColumnTypeMetadata columnTypeMetadatum in TypeMapper.Instance.GetColumnTypeMetadata())
		{
			MySqlDbType mySqlDbType = columnTypeMetadatum.MySqlDbType;
			bool flag = ((mySqlDbType == MySqlDbType.Decimal || mySqlDbType == MySqlDbType.Null || (uint)(mySqlDbType - 14) <= 1u) ? true : false);
			if (flag || (columnTypeMetadatum != null && columnTypeMetadatum.MySqlDbType == MySqlDbType.Bool && columnTypeMetadatum.IsUnsigned))
			{
				continue;
			}
			Type clrType = columnTypeMetadatum.DbTypeMapping.ClrType;
			string text = clrType.ToString();
			MySqlDbType mySqlDbType2 = columnTypeMetadatum.MySqlDbType;
			string text2 = mySqlDbType2 switch
			{
				MySqlDbType.Bool => "BOOL", 
				MySqlDbType.Guid => "GUID", 
				_ => columnTypeMetadatum.DataTypeName, 
			};
			switch (mySqlDbType2)
			{
			case MySqlDbType.Byte:
			case MySqlDbType.Int16:
			case MySqlDbType.Int32:
			case MySqlDbType.Int64:
			case MySqlDbType.Int24:
			case MySqlDbType.UByte:
			case MySqlDbType.UInt16:
			case MySqlDbType.UInt32:
			case MySqlDbType.UInt64:
			case MySqlDbType.UInt24:
				flag = true;
				break;
			default:
				flag = false;
				break;
			}
			bool flag2 = flag;
			bool flag3 = hashSet.Add(text);
			flag = flag2;
			if (!flag)
			{
				bool flag4;
				switch (mySqlDbType2)
				{
				case MySqlDbType.Bool:
				case MySqlDbType.Float:
				case MySqlDbType.Double:
				case MySqlDbType.Timestamp:
				case MySqlDbType.Date:
				case MySqlDbType.Time:
				case MySqlDbType.DateTime:
				case MySqlDbType.Year:
				case MySqlDbType.Guid:
					flag4 = true;
					break;
				default:
					flag4 = false;
					break;
				}
				flag = flag4;
			}
			bool flag5 = flag;
			flag = flag5;
			if (!flag)
			{
				bool flag4 = ((mySqlDbType2 == MySqlDbType.Bit || mySqlDbType2 == MySqlDbType.NewDecimal) ? true : false);
				flag = flag4;
			}
			bool flag6 = flag;
			flag = (uint)(mySqlDbType2 - 250) <= 2u;
			bool flag7 = flag;
			string[] array = columnTypeMetadatum.CreateFormat.Split(new char[1] { ';' });
			dataTable.Rows.Add(text2, (int)mySqlDbType2, columnTypeMetadatum.ColumnSize, array[0], (array.Length == 1) ? null : array[1], text, flag2, flag3, false, flag5, flag6, flag7, true, clrType != typeof(byte[]), clrType == typeof(string), columnTypeMetadatum.IsUnsigned, DBNull.Value, DBNull.Value, DBNull.Value, true, DBNull.Value, DBNull.Value, null);
		}
	}

	private static void DoFillReservedWords(DataTable dataTable)
	{
		string[] array = new string[262]
		{
			"ACCESSIBLE", "ADD", "ALL", "ALTER", "ANALYZE", "AND", "AS", "ASC", "ASENSITIVE", "BEFORE",
			"BETWEEN", "BIGINT", "BINARY", "BLOB", "BOTH", "BY", "CALL", "CASCADE", "CASE", "CHANGE",
			"CHAR", "CHARACTER", "CHECK", "COLLATE", "COLUMN", "CONDITION", "CONSTRAINT", "CONTINUE", "CONVERT", "CREATE",
			"CROSS", "CUBE", "CUME_DIST", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATABASE", "DATABASES",
			"DAY_HOUR", "DAY_MICROSECOND", "DAY_MINUTE", "DAY_SECOND", "DEC", "DECIMAL", "DECLARE", "DEFAULT", "DELAYED", "DELETE",
			"DENSE_RANK", "DESC", "DESCRIBE", "DETERMINISTIC", "DISTINCT", "DISTINCTROW", "DIV", "DOUBLE", "DROP", "DUAL",
			"EACH", "ELSE", "ELSEIF", "EMPTY", "ENCLOSED", "ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN",
			"FALSE", "FETCH", "FIRST_VALUE", "FLOAT", "FLOAT4", "FLOAT8", "FOR", "FORCE", "FOREIGN", "FROM",
			"FULLTEXT", "FUNCTION", "GENERATED", "GET", "GRANT", "GROUP", "GROUPING", "GROUPS", "HAVING", "HIGH_PRIORITY",
			"HOUR_MICROSECOND", "HOUR_MINUTE", "HOUR_SECOND", "IF", "IGNORE", "IN", "INDEX", "INFILE", "INNER", "INOUT",
			"INSENSITIVE", "INSERT", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", "INTERVAL",
			"INTO", "IO_AFTER_GTIDS", "IO_BEFORE_GTIDS", "IS", "ITERATE", "JOIN", "JSON_TABLE", "KEY", "KEYS", "KILL",
			"LAG", "LAST_VALUE", "LATERAL", "LEAD", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR",
			"LINES", "LOAD", "LOCALTIME", "LOCALTIMESTAMP", "LOCK", "LONG", "LONGBLOB", "LONGTEXT", "LOOP", "LOW_PRIORITY",
			"MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT", "MATCH", "MAXVALUE", "MEDIUMBLOB", "MEDIUMINT", "MEDIUMTEXT", "MEMBER", "MIDDLEINT", "MINUTE_MICROSECOND",
			"MINUTE_SECOND", "MOD", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG", "NTH_VALUE", "NTILE", "NULL", "NUMERIC",
			"OF", "ON", "OPTIMIZE", "OPTIMIZER_COSTS", "OPTION", "OPTIONALLY", "OR", "ORDER", "OUT", "OUTER",
			"OUTFILE", "OVER", "PARTITION", "PERCENT_RANK", "PRECISION", "PRIMARY", "PROCEDURE", "PURGE", "RANGE", "RANK",
			"READ", "READS", "READ_WRITE", "REAL", "RECURSIVE", "REFERENCES", "REGEXP", "RELEASE", "RENAME", "REPEAT",
			"REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT", "RETURN", "REVOKE", "RIGHT", "RLIKE", "ROW", "ROWS",
			"ROW_NUMBER", "SCHEMA", "SCHEMAS", "SECOND_MICROSECOND", "SELECT", "SENSITIVE", "SEPARATOR", "SET", "SHOW", "SIGNAL",
			"SMALLINT", "SPATIAL", "SPECIFIC", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT",
			"SSL", "STARTING", "STORED", "STRAIGHT_JOIN", "SYSTEM", "TABLE", "TERMINATED", "THEN", "TINYBLOB", "TINYINT",
			"TINYTEXT", "TO", "TRAILING", "TRIGGER", "TRUE", "UNDO", "UNION", "UNIQUE", "UNLOCK", "UNSIGNED",
			"UPDATE", "USAGE", "USE", "USING", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "VALUES", "VARBINARY", "VARCHAR",
			"VARCHARACTER", "VARYING", "VIRTUAL", "WHEN", "WHERE", "WHILE", "WINDOW", "WITH", "WRITE", "XOR",
			"YEAR_MONTH", "ZEROFILL"
		};
		foreach (string text in array)
		{
			dataTable.Rows.Add(text);
		}
	}

	private async Task FillDataTableAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 0, 1, 1 })] List<KeyValuePair<string, string>> columns, CancellationToken cancellationToken)
	{
		await FillDataTableAsync(ioBehavior, dataTable, delegate(MySqlCommand command)
		{
			command.CommandText = "SELECT " + string.Join(", ", from DataColumn x in dataTable.Columns
				select x.ColumnName) + " FROM INFORMATION_SCHEMA." + tableName;
			if (columns != null && columns.Count > 0)
			{
				command.CommandText = command.CommandText + " WHERE " + string.Join(" AND ", columns.Select([<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)] (KeyValuePair<string, string> x) => x.Key + " = @" + x.Key));
				foreach (KeyValuePair<string, string> column in columns)
				{
					command.Parameters.AddWithValue("@" + column.Key, column.Value);
				}
			}
		}, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillDataTableAsync(IOBehavior ioBehavior, DataTable dataTable, Action<MySqlCommand> configureCommand, CancellationToken cancellationToken)
	{
		Action close = null;
		if (connection.State != ConnectionState.Open)
		{
			await connection.OpenAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			close = connection.Close;
		}
		if (dataTable.TableName == "Columns")
		{
			using (MySqlCommand command = new MySqlCommand("SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE table_schema = 'information_schema' AND table_name = 'COLUMNS' AND column_name = 'GENERATION_EXPRESSION';", connection))
			{
				if (await command.ExecuteScalarAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == null)
				{
					dataTable.Columns.Remove("GENERATION_EXPRESSION");
				}
			}
			using MySqlCommand command = new MySqlCommand("SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE table_schema = 'information_schema' AND table_name = 'COLUMNS' AND column_name = 'SRS_ID';", connection);
			if (await command.ExecuteScalarAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == null)
			{
				dataTable.Columns.Remove("SRS_ID");
			}
		}
		using (MySqlCommand command = connection.CreateCommand())
		{
			configureCommand(command);
			using MySqlDataReader reader = await command.ExecuteReaderAsync(CommandBehavior.Default, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			while (await reader.ReadAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
			{
				object[] values = new object[dataTable.Columns.Count];
				reader.GetValues(values);
				dataTable.Rows.Add(values);
			}
		}
		close?.Invoke();
	}

	private Task DoFillForeignKeysAsync(IOBehavior ioBehavior, DataTable dataTable, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		return FillDataTableAsync(ioBehavior, dataTable, delegate(MySqlCommand command)
		{
			command.CommandText = "SELECT rc.constraint_catalog, rc.constraint_schema, rc.constraint_name,\n\tkcu.table_catalog, kcu.table_schema,\n\trc.table_name, rc.match_option, rc.update_rule, rc.delete_rule, \n\tNULL as referenced_table_catalog, kcu.referenced_table_schema, rc.referenced_table_name \nFROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc\n\tLEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON \n\t(\n\t\t(kcu.constraint_catalog = rc.constraint_catalog OR (kcu.constraint_catalog IS NULL AND rc.constraint_catalog IS NULL)) AND\n\t\t(kcu.constraint_schema = rc.constraint_schema OR (kcu.constraint_schema IS NULL AND rc.constraint_schema IS NULL)) AND\n\t\t(kcu.constraint_name = rc.constraint_name OR (kcu.constraint_name IS NULL AND rc.constraint_name IS NULL))\n\t)\nWHERE kcu.ORDINAL_POSITION = 1";
			if (restrictionValues != null && restrictionValues.Length >= 2)
			{
				string text = restrictionValues[1];
				if (text != null && text.Length > 0)
				{
					command.CommandText += " AND rc.constraint_schema LIKE @schema";
					command.Parameters.AddWithValue("@schema", text);
				}
			}
			if (restrictionValues != null && restrictionValues.Length >= 3)
			{
				string text2 = restrictionValues[2];
				if (text2 != null && text2.Length > 0)
				{
					command.CommandText += " AND rc.table_name LIKE @table";
					command.Parameters.AddWithValue("@table", text2);
				}
			}
			if (restrictionValues != null && restrictionValues.Length >= 4)
			{
				string text3 = restrictionValues[3];
				if (text3 != null && text3.Length > 0)
				{
					command.CommandText += " AND rc.constraint_name LIKE @constraint";
					command.Parameters.AddWithValue("@constraint", text3);
				}
			}
		}, cancellationToken);
	}

	private Task DoFillIndexesAsync(IOBehavior ioBehavior, DataTable dataTable, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		return FillDataTableAsync(ioBehavior, dataTable, delegate(MySqlCommand command)
		{
			command.CommandText = "SELECT null AS INDEX_CATALOG, INDEX_SCHEMA,\n\tINDEX_NAME, TABLE_NAME,\n\t!NON_UNIQUE as `UNIQUE`, \n\tINDEX_NAME='PRIMARY' as `PRIMARY`,\n\tINDEX_TYPE as TYPE, COMMENT \nFROM INFORMATION_SCHEMA.STATISTICS\nWHERE SEQ_IN_INDEX=1";
			if (restrictionValues != null && restrictionValues.Length >= 2)
			{
				string text = restrictionValues[1];
				if (text != null && text.Length > 0)
				{
					command.CommandText += " AND INDEX_SCHEMA LIKE @schema";
					command.Parameters.AddWithValue("@schema", text);
				}
			}
			if (restrictionValues != null && restrictionValues.Length >= 3)
			{
				string text2 = restrictionValues[2];
				if (text2 != null && text2.Length > 0)
				{
					command.CommandText += " AND TABLE_NAME LIKE @table";
					command.Parameters.AddWithValue("@table", text2);
				}
			}
			if (restrictionValues != null && restrictionValues.Length >= 4)
			{
				string text3 = restrictionValues[3];
				if (text3 != null && text3.Length > 0)
				{
					command.CommandText += " AND INDEX_NAME LIKE @index";
					command.Parameters.AddWithValue("@index", text3);
				}
			}
		}, cancellationToken);
	}

	private Task DoFillIndexColumnsAsync(IOBehavior ioBehavior, DataTable dataTable, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		return FillDataTableAsync(ioBehavior, dataTable, delegate(MySqlCommand command)
		{
			command.CommandText = "SELECT null AS INDEX_CATALOG, INDEX_SCHEMA,\n\tINDEX_NAME, TABLE_NAME,\n\tCOLUMN_NAME,\n\tSEQ_IN_INDEX as `ORDINAL_POSITION`,\n\tCOLLATION as SORT_ORDER\nFROM INFORMATION_SCHEMA.STATISTICS\nWHERE 1=1";
			if (restrictionValues != null && restrictionValues.Length >= 2)
			{
				string text = restrictionValues[1];
				if (text != null && text.Length > 0)
				{
					command.CommandText += " AND INDEX_SCHEMA LIKE @schema";
					command.Parameters.AddWithValue("@schema", text);
				}
			}
			if (restrictionValues != null && restrictionValues.Length >= 3)
			{
				string text2 = restrictionValues[2];
				if (text2 != null && text2.Length > 0)
				{
					command.CommandText += " AND TABLE_NAME LIKE @table";
					command.Parameters.AddWithValue("@table", text2);
				}
			}
			if (restrictionValues != null && restrictionValues.Length >= 4)
			{
				string text3 = restrictionValues[3];
				if (text3 != null && text3.Length > 0)
				{
					command.CommandText += " AND INDEX_NAME LIKE @index";
					command.Parameters.AddWithValue("@index", text3);
				}
			}
			if (restrictionValues != null && restrictionValues.Length >= 5)
			{
				string text4 = restrictionValues[4];
				if (text4 != null && text4.Length > 0)
				{
					command.CommandText += " AND COLUMN_NAME LIKE @column";
					command.Parameters.AddWithValue("@column", text4);
				}
			}
		}, cancellationToken);
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1 })]
	public async ValueTask<DataTable> GetSchemaAsync(IOBehavior ioBehavior, string collectionName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (collectionName == null)
		{
			throw new ArgumentNullException("collectionName");
		}
		DataTable dataTable = new DataTable();
		if (string.Equals(collectionName, "MetaDataCollections", StringComparison.OrdinalIgnoreCase))
		{
			await FillMetaDataCollectionsAsync(ioBehavior, dataTable, "MetaDataCollections", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "CharacterSets", StringComparison.OrdinalIgnoreCase))
		{
			await FillCharacterSetsAsync(ioBehavior, dataTable, "CharacterSets", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Collations", StringComparison.OrdinalIgnoreCase))
		{
			await FillCollationsAsync(ioBehavior, dataTable, "Collations", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "CollationCharacterSetApplicability", StringComparison.OrdinalIgnoreCase))
		{
			await FillCollationCharacterSetApplicabilityAsync(ioBehavior, dataTable, "CollationCharacterSetApplicability", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Columns", StringComparison.OrdinalIgnoreCase))
		{
			await FillColumnsAsync(ioBehavior, dataTable, "Columns", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Databases", StringComparison.OrdinalIgnoreCase))
		{
			await FillDatabasesAsync(ioBehavior, dataTable, "Databases", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "DataSourceInformation", StringComparison.OrdinalIgnoreCase))
		{
			await FillDataSourceInformationAsync(ioBehavior, dataTable, "DataSourceInformation", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "DataTypes", StringComparison.OrdinalIgnoreCase))
		{
			await FillDataTypesAsync(ioBehavior, dataTable, "DataTypes", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Engines", StringComparison.OrdinalIgnoreCase))
		{
			await FillEnginesAsync(ioBehavior, dataTable, "Engines", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "KeyColumnUsage", StringComparison.OrdinalIgnoreCase))
		{
			await FillKeyColumnUsageAsync(ioBehavior, dataTable, "KeyColumnUsage", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "KeyWords", StringComparison.OrdinalIgnoreCase))
		{
			await FillKeyWordsAsync(ioBehavior, dataTable, "KeyWords", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Parameters", StringComparison.OrdinalIgnoreCase))
		{
			await FillParametersAsync(ioBehavior, dataTable, "Parameters", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Partitions", StringComparison.OrdinalIgnoreCase))
		{
			await FillPartitionsAsync(ioBehavior, dataTable, "Partitions", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Plugins", StringComparison.OrdinalIgnoreCase))
		{
			await FillPluginsAsync(ioBehavior, dataTable, "Plugins", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Procedures", StringComparison.OrdinalIgnoreCase))
		{
			await FillProceduresAsync(ioBehavior, dataTable, "Procedures", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "ProcessList", StringComparison.OrdinalIgnoreCase))
		{
			await FillProcessListAsync(ioBehavior, dataTable, "ProcessList", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Profiling", StringComparison.OrdinalIgnoreCase))
		{
			await FillProfilingAsync(ioBehavior, dataTable, "Profiling", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "ReferentialConstraints", StringComparison.OrdinalIgnoreCase))
		{
			await FillReferentialConstraintsAsync(ioBehavior, dataTable, "ReferentialConstraints", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "ReservedWords", StringComparison.OrdinalIgnoreCase))
		{
			await FillReservedWordsAsync(ioBehavior, dataTable, "ReservedWords", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "ResourceGroups", StringComparison.OrdinalIgnoreCase))
		{
			await FillResourceGroupsAsync(ioBehavior, dataTable, "ResourceGroups", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Restrictions", StringComparison.OrdinalIgnoreCase))
		{
			await FillRestrictionsAsync(ioBehavior, dataTable, "Restrictions", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "SchemaPrivileges", StringComparison.OrdinalIgnoreCase))
		{
			await FillSchemaPrivilegesAsync(ioBehavior, dataTable, "SchemaPrivileges", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Tables", StringComparison.OrdinalIgnoreCase))
		{
			await FillTablesAsync(ioBehavior, dataTable, "Tables", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "TableConstraints", StringComparison.OrdinalIgnoreCase))
		{
			await FillTableConstraintsAsync(ioBehavior, dataTable, "TableConstraints", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "TablePrivileges", StringComparison.OrdinalIgnoreCase))
		{
			await FillTablePrivilegesAsync(ioBehavior, dataTable, "TablePrivileges", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "TableSpaces", StringComparison.OrdinalIgnoreCase))
		{
			await FillTableSpacesAsync(ioBehavior, dataTable, "TableSpaces", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Triggers", StringComparison.OrdinalIgnoreCase))
		{
			await FillTriggersAsync(ioBehavior, dataTable, "Triggers", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "UserPrivileges", StringComparison.OrdinalIgnoreCase))
		{
			await FillUserPrivilegesAsync(ioBehavior, dataTable, "UserPrivileges", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Views", StringComparison.OrdinalIgnoreCase))
		{
			await FillViewsAsync(ioBehavior, dataTable, "Views", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Foreign Keys", StringComparison.OrdinalIgnoreCase))
		{
			await FillForeignKeysAsync(ioBehavior, dataTable, "Foreign Keys", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else if (string.Equals(collectionName, "Indexes", StringComparison.OrdinalIgnoreCase))
		{
			await FillIndexesAsync(ioBehavior, dataTable, "Indexes", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		else
		{
			if (!string.Equals(collectionName, "IndexColumns", StringComparison.OrdinalIgnoreCase))
			{
				throw new ArgumentException("Invalid collection name: '" + collectionName + "'.", "collectionName");
			}
			await FillIndexColumnsAsync(ioBehavior, dataTable, "IndexColumns", restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		return dataTable;
	}

	private Task FillMetaDataCollectionsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'MetaDataCollections'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[3]
		{
			new DataColumn("CollectionName", typeof(string)),
			new DataColumn("NumberOfRestrictions", typeof(int)),
			new DataColumn("NumberOfIdentifierParts", typeof(int))
		});
		dataTable.Rows.Add("MetaDataCollections", 0, 0);
		dataTable.Rows.Add("CharacterSets", 0, 0);
		dataTable.Rows.Add("Collations", 0, 0);
		dataTable.Rows.Add("CollationCharacterSetApplicability", 0, 0);
		dataTable.Rows.Add("Columns", 4, 4);
		dataTable.Rows.Add("Databases", 0, 2);
		dataTable.Rows.Add("DataSourceInformation", 0, 0);
		dataTable.Rows.Add("DataTypes", 0, 0);
		dataTable.Rows.Add("Engines", 0, 0);
		dataTable.Rows.Add("KeyColumnUsage", 0, 0);
		dataTable.Rows.Add("KeyWords", 0, 0);
		dataTable.Rows.Add("Parameters", 0, 0);
		dataTable.Rows.Add("Partitions", 0, 0);
		dataTable.Rows.Add("Plugins", 0, 0);
		dataTable.Rows.Add("Procedures", 0, 3);
		dataTable.Rows.Add("ProcessList", 0, 0);
		dataTable.Rows.Add("Profiling", 0, 0);
		dataTable.Rows.Add("ReferentialConstraints", 0, 3);
		dataTable.Rows.Add("ReservedWords", 0, 0);
		dataTable.Rows.Add("ResourceGroups", 0, 0);
		dataTable.Rows.Add("Restrictions", 0, 0);
		dataTable.Rows.Add("SchemaPrivileges", 0, 0);
		dataTable.Rows.Add("Tables", 4, 3);
		dataTable.Rows.Add("TableConstraints", 0, 3);
		dataTable.Rows.Add("TablePrivileges", 0, 0);
		dataTable.Rows.Add("TableSpaces", 0, 0);
		dataTable.Rows.Add("Triggers", 0, 3);
		dataTable.Rows.Add("UserPrivileges", 0, 0);
		dataTable.Rows.Add("Views", 0, 3);
		dataTable.Rows.Add("Foreign Keys", 4, 0);
		dataTable.Rows.Add("Indexes", 4, 0);
		dataTable.Rows.Add("IndexColumns", 5, 0);
		return Task.CompletedTask;
	}

	private async Task FillCharacterSetsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'CharacterSets'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[4]
		{
			new DataColumn("CHARACTER_SET_NAME", typeof(string)),
			new DataColumn("DEFAULT_COLLATE_NAME", typeof(string)),
			new DataColumn("DESCRIPTION", typeof(string)),
			new DataColumn("MAXLEN", typeof(int))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "CHARACTER_SETS", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillCollationsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'Collations'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[6]
		{
			new DataColumn("COLLATION_NAME", typeof(string)),
			new DataColumn("CHARACTER_SET_NAME", typeof(string)),
			new DataColumn("ID", typeof(int)),
			new DataColumn("IS_DEFAULT", typeof(string)),
			new DataColumn("IS_COMPILED", typeof(string)),
			new DataColumn("SORTLEN", typeof(int))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "COLLATIONS", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillCollationCharacterSetApplicabilityAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'CollationCharacterSetApplicability'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[2]
		{
			new DataColumn("COLLATION_NAME", typeof(string)),
			new DataColumn("CHARACTER_SET_NAME", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "COLLATION_CHARACTER_SET_APPLICABILITY", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillColumnsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length > 4)
		{
			throw new ArgumentException("More than 4 restrictionValues are not supported for schema 'Columns'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[21]
		{
			new DataColumn("TABLE_CATALOG", typeof(string)),
			new DataColumn("TABLE_SCHEMA", typeof(string)),
			new DataColumn("TABLE_NAME", typeof(string)),
			new DataColumn("COLUMN_NAME", typeof(string)),
			new DataColumn("ORDINAL_POSITION", typeof(uint)),
			new DataColumn("COLUMN_DEFAULT", typeof(string)),
			new DataColumn("IS_NULLABLE", typeof(string)),
			new DataColumn("DATA_TYPE", typeof(string)),
			new DataColumn("CHARACTER_MAXIMUM_LENGTH", typeof(long)),
			new DataColumn("NUMERIC_PRECISION", typeof(ulong)),
			new DataColumn("NUMERIC_SCALE", typeof(ulong)),
			new DataColumn("DATETIME_PRECISION", typeof(uint)),
			new DataColumn("CHARACTER_SET_NAME", typeof(string)),
			new DataColumn("COLLATION_NAME", typeof(string)),
			new DataColumn("COLUMN_TYPE", typeof(string)),
			new DataColumn("COLUMN_KEY", typeof(string)),
			new DataColumn("EXTRA", typeof(string)),
			new DataColumn("PRIVILEGES", typeof(string)),
			new DataColumn("COLUMN_COMMENT", typeof(string)),
			new DataColumn("GENERATION_EXPRESSION", typeof(string)),
			new DataColumn("SRS_ID", typeof(string))
		});
		List<KeyValuePair<string, string>> list = new List<KeyValuePair<string, string>>();
		if (restrictionValues != null)
		{
			if (restrictionValues.Length != 0 && !string.IsNullOrEmpty(restrictionValues[0]))
			{
				list.Add(new KeyValuePair<string, string>("TABLE_CATALOG", restrictionValues[0]));
			}
			if (restrictionValues.Length > 1 && !string.IsNullOrEmpty(restrictionValues[1]))
			{
				list.Add(new KeyValuePair<string, string>("TABLE_SCHEMA", restrictionValues[1]));
			}
			if (restrictionValues.Length > 2 && !string.IsNullOrEmpty(restrictionValues[2]))
			{
				list.Add(new KeyValuePair<string, string>("TABLE_NAME", restrictionValues[2]));
			}
			if (restrictionValues.Length > 3 && !string.IsNullOrEmpty(restrictionValues[3]))
			{
				list.Add(new KeyValuePair<string, string>("COLUMN_NAME", restrictionValues[3]));
			}
		}
		await FillDataTableAsync(ioBehavior, dataTable, "COLUMNS", list, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillDatabasesAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'Databases'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[5]
		{
			new DataColumn("CATALOG_NAME", typeof(string)),
			new DataColumn("SCHEMA_NAME", typeof(string)),
			new DataColumn("DEFAULT_CHARACTER_SET_NAME", typeof(string)),
			new DataColumn("DEFAULT_COLLATION_NAME", typeof(string)),
			new DataColumn("SQL_PATH", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "SCHEMATA", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private Task FillDataSourceInformationAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'DataSourceInformation'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[17]
		{
			new DataColumn("CompositeIdentifierSeparatorPattern", typeof(string)),
			new DataColumn("DataSourceProductName", typeof(string)),
			new DataColumn("DataSourceProductVersion", typeof(string)),
			new DataColumn("DataSourceProductVersionNormalized", typeof(string)),
			new DataColumn("GroupByBehavior", typeof(GroupByBehavior)),
			new DataColumn("IdentifierPattern", typeof(string)),
			new DataColumn("IdentifierCase", typeof(IdentifierCase)),
			new DataColumn("OrderByColumnsInSelect", typeof(bool)),
			new DataColumn("ParameterMarkerFormat", typeof(string)),
			new DataColumn("ParameterMarkerPattern", typeof(string)),
			new DataColumn("ParameterNameMaxLength", typeof(int)),
			new DataColumn("QuotedIdentifierPattern", typeof(string)),
			new DataColumn("QuotedIdentifierCase", typeof(IdentifierCase)),
			new DataColumn("ParameterNamePattern", typeof(string)),
			new DataColumn("StatementSeparatorPattern", typeof(string)),
			new DataColumn("StringLiteralPattern", typeof(string)),
			new DataColumn("SupportedJoinOperators", typeof(SupportedJoinOperators))
		});
		DoFillDataSourceInformation(dataTable);
		return Task.CompletedTask;
	}

	private Task FillDataTypesAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'DataTypes'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[23]
		{
			new DataColumn("TypeName", typeof(string)),
			new DataColumn("ProviderDbType", typeof(int)),
			new DataColumn("ColumnSize", typeof(long)),
			new DataColumn("CreateFormat", typeof(string)),
			new DataColumn("CreateParameters", typeof(string)),
			new DataColumn("DataType", typeof(string)),
			new DataColumn("IsAutoIncrementable", typeof(bool)),
			new DataColumn("IsBestMatch", typeof(bool)),
			new DataColumn("IsCaseSensitive", typeof(bool)),
			new DataColumn("IsFixedLength", typeof(bool)),
			new DataColumn("IsFixedPrecisionScale", typeof(bool)),
			new DataColumn("IsLong", typeof(bool)),
			new DataColumn("IsNullable", typeof(bool)),
			new DataColumn("IsSearchable", typeof(bool)),
			new DataColumn("IsSearchableWithLike", typeof(bool)),
			new DataColumn("IsUnsigned", typeof(bool)),
			new DataColumn("MaximumScale", typeof(short)),
			new DataColumn("MinimumScale", typeof(short)),
			new DataColumn("IsConcurrencyType", typeof(bool)),
			new DataColumn("IsLiteralSupported", typeof(bool)),
			new DataColumn("LiteralPrefix", typeof(string)),
			new DataColumn("LiteralSuffix", typeof(string)),
			new DataColumn("NativeDataType", typeof(string))
		});
		DoFillDataTypes(dataTable);
		return Task.CompletedTask;
	}

	private async Task FillEnginesAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'Engines'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[6]
		{
			new DataColumn("ENGINE", typeof(string)),
			new DataColumn("SUPPORT", typeof(string)),
			new DataColumn("COMMENT", typeof(string)),
			new DataColumn("TRANSACTIONS", typeof(string)),
			new DataColumn("XA", typeof(string)),
			new DataColumn("SAVEPOINTS", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "ENGINES", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillKeyColumnUsageAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'KeyColumnUsage'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[12]
		{
			new DataColumn("CONSTRAINT_CATALOG", typeof(string)),
			new DataColumn("CONSTRAINT_SCHEMA", typeof(string)),
			new DataColumn("CONSTRAINT_NAME", typeof(string)),
			new DataColumn("TABLE_CATALOG", typeof(string)),
			new DataColumn("TABLE_SCHEMA", typeof(string)),
			new DataColumn("TABLE_NAME", typeof(string)),
			new DataColumn("COLUMN_NAME", typeof(string)),
			new DataColumn("ORDINAL_POSITION", typeof(int)),
			new DataColumn("POSITION_IN_UNIQUE_CONSTRAINT", typeof(string)),
			new DataColumn("REFERENCED_TABLE_SCHEMA", typeof(string)),
			new DataColumn("REFERENCED_TABLE_NAME", typeof(string)),
			new DataColumn("REFERENCED_COLUMN_NAME", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "KEY_COLUMN_USAGE", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillKeyWordsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'KeyWords'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[2]
		{
			new DataColumn("WORD", typeof(string)),
			new DataColumn("RESERVED", typeof(int))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "KEYWORDS", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillParametersAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'Parameters'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[16]
		{
			new DataColumn("SPECIFIC_CATALOG", typeof(string)),
			new DataColumn("SPECIFIC_SCHEMA", typeof(string)),
			new DataColumn("SPECIFIC_NAME", typeof(string)),
			new DataColumn("ORDINAL_POSITION", typeof(int)),
			new DataColumn("PARAMETER_MODE", typeof(string)),
			new DataColumn("PARAMETER_NAME", typeof(string)),
			new DataColumn("DATA_TYPE", typeof(string)),
			new DataColumn("CHARACTER_MAXIMUM_LENGTH", typeof(long)),
			new DataColumn("CHARACTER_OCTET_LENGTH", typeof(long)),
			new DataColumn("NUMERIC_PRECISION", typeof(int)),
			new DataColumn("NUMERIC_SCALE", typeof(int)),
			new DataColumn("DATETIME_PRECISION", typeof(int)),
			new DataColumn("CHARACTER_SET_NAME", typeof(string)),
			new DataColumn("COLLATION_NAME", typeof(string)),
			new DataColumn("DTD_IDENTIFIER", typeof(string)),
			new DataColumn("ROUTINE_TYPE", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "PARAMETERS", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillPartitionsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'Partitions'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[25]
		{
			new DataColumn("TABLE_CATALOG", typeof(string)),
			new DataColumn("TABLE_SCHEMA", typeof(string)),
			new DataColumn("TABLE_NAME", typeof(string)),
			new DataColumn("PARTITION_NAME", typeof(string)),
			new DataColumn("SUBPARTITION_NAME", typeof(string)),
			new DataColumn("PARTITION_ORDINAL_POSITION", typeof(int)),
			new DataColumn("SUBPARTITION_ORDINAL_POSITION", typeof(int)),
			new DataColumn("PARTITION_METHOD", typeof(string)),
			new DataColumn("SUBPARTITION_METHOD", typeof(string)),
			new DataColumn("PARTITION_EXPRESSION", typeof(string)),
			new DataColumn("SUBPARTITION_EXPRESSION", typeof(string)),
			new DataColumn("PARTITION_DESCRIPTION", typeof(string)),
			new DataColumn("TABLE_ROWS", typeof(long)),
			new DataColumn("AVG_ROW_LENGTH", typeof(long)),
			new DataColumn("DATA_LENGTH", typeof(long)),
			new DataColumn("MAX_DATA_LENGTH", typeof(long)),
			new DataColumn("INDEX_LENGTH", typeof(long)),
			new DataColumn("DATA_FREE", typeof(long)),
			new DataColumn("CREATE_TIME", typeof(DateTime)),
			new DataColumn("UPDATE_TIME", typeof(DateTime)),
			new DataColumn("CHECK_TIME", typeof(DateTime)),
			new DataColumn("CHECKSUM", typeof(long)),
			new DataColumn("PARTITION_COMMENT", typeof(string)),
			new DataColumn("NODEGROUP", typeof(string)),
			new DataColumn("TABLESPACE_NAME", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "PARTITIONS", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillPluginsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'Plugins'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[11]
		{
			new DataColumn("PLUGIN_NAME", typeof(string)),
			new DataColumn("PLUGIN_VERSION", typeof(string)),
			new DataColumn("PLUGIN_STATUS", typeof(string)),
			new DataColumn("PLUGIN_TYPE", typeof(string)),
			new DataColumn("PLUGIN_TYPE_VERSION", typeof(string)),
			new DataColumn("PLUGIN_LIBRARY", typeof(string)),
			new DataColumn("PLUGIN_LIBRARY_VERSION", typeof(string)),
			new DataColumn("PLUGIN_AUTHOR", typeof(string)),
			new DataColumn("PLUGIN_DESCRIPTION", typeof(string)),
			new DataColumn("PLUGIN_LICENSE", typeof(string)),
			new DataColumn("LOAD_OPTION", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "PLUGINS", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillProceduresAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'Procedures'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[20]
		{
			new DataColumn("SPECIFIC_NAME", typeof(string)),
			new DataColumn("ROUTINE_CATALOG", typeof(string)),
			new DataColumn("ROUTINE_SCHEMA", typeof(string)),
			new DataColumn("ROUTINE_NAME", typeof(string)),
			new DataColumn("ROUTINE_TYPE", typeof(string)),
			new DataColumn("DTD_IDENTIFIER", typeof(string)),
			new DataColumn("ROUTINE_BODY", typeof(string)),
			new DataColumn("ROUTINE_DEFINITION", typeof(string)),
			new DataColumn("EXTERNAL_NAME", typeof(string)),
			new DataColumn("EXTERNAL_LANGUAGE", typeof(string)),
			new DataColumn("PARAMETER_STYLE", typeof(string)),
			new DataColumn("IS_DETERMINISTIC", typeof(string)),
			new DataColumn("SQL_DATA_ACCESS", typeof(string)),
			new DataColumn("SQL_PATH", typeof(string)),
			new DataColumn("SECURITY_TYPE", typeof(string)),
			new DataColumn("CREATED", typeof(DateTime)),
			new DataColumn("LAST_ALTERED", typeof(DateTime)),
			new DataColumn("SQL_MODE", typeof(string)),
			new DataColumn("ROUTINE_COMMENT", typeof(string)),
			new DataColumn("DEFINER", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "ROUTINES", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillProcessListAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'ProcessList'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[8]
		{
			new DataColumn("ID", typeof(long)),
			new DataColumn("USER", typeof(string)),
			new DataColumn("HOST", typeof(string)),
			new DataColumn("DB", typeof(string)),
			new DataColumn("COMMAND", typeof(string)),
			new DataColumn("TIME", typeof(int)),
			new DataColumn("STATE", typeof(string)),
			new DataColumn("INFO", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "PROCESSLIST", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillProfilingAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'Profiling'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[18]
		{
			new DataColumn("QUERY_ID", typeof(int)),
			new DataColumn("SEQ", typeof(int)),
			new DataColumn("STATE", typeof(string)),
			new DataColumn("DURATION", typeof(decimal)),
			new DataColumn("CPU_USER", typeof(decimal)),
			new DataColumn("CPU_SYSTEM", typeof(decimal)),
			new DataColumn("CONTEXT_VOLUNTARY", typeof(int)),
			new DataColumn("CONTEXT_INVOLUNTARY", typeof(int)),
			new DataColumn("BLOCK_OPS_IN", typeof(int)),
			new DataColumn("BLOCK_OPS_OUT", typeof(int)),
			new DataColumn("MESSAGES_SENT", typeof(int)),
			new DataColumn("MESSAGES_RECEIVED", typeof(int)),
			new DataColumn("PAGE_FAULTS_MAJOR", typeof(int)),
			new DataColumn("PAGE_FAULTS_MINOR", typeof(int)),
			new DataColumn("SWAPS", typeof(int)),
			new DataColumn("SOURCE_FUNCTION", typeof(string)),
			new DataColumn("SOURCE_FILE", typeof(string)),
			new DataColumn("SOURCE_LINE", typeof(int))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "PROFILING", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillReferentialConstraintsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'ReferentialConstraints'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[11]
		{
			new DataColumn("CONSTRAINT_CATALOG", typeof(string)),
			new DataColumn("CONSTRAINT_SCHEMA", typeof(string)),
			new DataColumn("CONSTRAINT_NAME", typeof(string)),
			new DataColumn("UNIQUE_CONSTRAINT_CATALOG", typeof(string)),
			new DataColumn("UNIQUE_CONSTRAINT_SCHEMA", typeof(string)),
			new DataColumn("UNIQUE_CONSTRAINT_NAME", typeof(string)),
			new DataColumn("MATCH_OPTION", typeof(string)),
			new DataColumn("UPDATE_RULE", typeof(string)),
			new DataColumn("DELETE_RULE", typeof(string)),
			new DataColumn("TABLE_NAME", typeof(string)),
			new DataColumn("REFERENCED_TABLE_NAME", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "REFERENTIAL_CONSTRAINTS", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private Task FillReservedWordsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'ReservedWords'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[1]
		{
			new DataColumn("ReservedWord", typeof(string))
		});
		DoFillReservedWords(dataTable);
		return Task.CompletedTask;
	}

	private async Task FillResourceGroupsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'ResourceGroups'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[5]
		{
			new DataColumn("RESOURCE_GROUP_NAME", typeof(string)),
			new DataColumn("RESOURCE_GROUP_TYPE", typeof(string)),
			new DataColumn("RESOURCE_GROUP_ENABLED", typeof(int)),
			new DataColumn("VCPU_IDS", typeof(string)),
			new DataColumn("THREAD_PRIORITY", typeof(int))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "RESOURCE_GROUPS", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private Task FillRestrictionsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'Restrictions'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[4]
		{
			new DataColumn("CollectionName", typeof(string)),
			new DataColumn("RestrictionName", typeof(string)),
			new DataColumn("RestrictionDefault", typeof(string)),
			new DataColumn("RestrictionNumber", typeof(int))
		});
		dataTable.Rows.Add("Columns", "Catalog", "TABLE_CATALOG", 1);
		dataTable.Rows.Add("Columns", "Schema", "TABLE_SCHEMA", 2);
		dataTable.Rows.Add("Columns", "Table", "TABLE_NAME", 3);
		dataTable.Rows.Add("Columns", "Column", "COLUMN_NAME", 4);
		dataTable.Rows.Add("Tables", "Catalog", "TABLE_CATALOG", 1);
		dataTable.Rows.Add("Tables", "Schema", "TABLE_SCHEMA", 2);
		dataTable.Rows.Add("Tables", "Table", "TABLE_NAME", 3);
		dataTable.Rows.Add("Tables", "TableType", "TABLE_TYPE", 4);
		dataTable.Rows.Add("Foreign Keys", "Catalog", "TABLE_CATALOG", 1);
		dataTable.Rows.Add("Foreign Keys", "Schema", "TABLE_SCHEMA", 2);
		dataTable.Rows.Add("Foreign Keys", "Table", "TABLE_NAME", 3);
		dataTable.Rows.Add("Foreign Keys", "Constraint Name", "CONSTRAINT_NAME", 4);
		dataTable.Rows.Add("Indexes", "Catalog", "TABLE_CATALOG", 1);
		dataTable.Rows.Add("Indexes", "Schema", "TABLE_SCHEMA", 2);
		dataTable.Rows.Add("Indexes", "Table", "TABLE_NAME", 3);
		dataTable.Rows.Add("Indexes", "Name", "INDEX_NAME", 4);
		dataTable.Rows.Add("IndexColumns", "Catalog", "TABLE_CATALOG", 1);
		dataTable.Rows.Add("IndexColumns", "Schema", "TABLE_SCHEMA", 2);
		dataTable.Rows.Add("IndexColumns", "Table", "TABLE_NAME", 3);
		dataTable.Rows.Add("IndexColumns", "Name", "INDEX_NAME", 4);
		dataTable.Rows.Add("IndexColumns", "Column", "COLUMN_NAME", 5);
		return Task.CompletedTask;
	}

	private async Task FillSchemaPrivilegesAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'SchemaPrivileges'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[5]
		{
			new DataColumn("GRANTEE", typeof(string)),
			new DataColumn("TABLE_CATALOG", typeof(string)),
			new DataColumn("TABLE_SCHEMA", typeof(string)),
			new DataColumn("PRIVILEGE_TYPE", typeof(string)),
			new DataColumn("IS_GRANTABLE", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "SCHEMA_PRIVILEGES", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillTablesAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length > 4)
		{
			throw new ArgumentException("More than 4 restrictionValues are not supported for schema 'Tables'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[21]
		{
			new DataColumn("TABLE_CATALOG", typeof(string)),
			new DataColumn("TABLE_SCHEMA", typeof(string)),
			new DataColumn("TABLE_NAME", typeof(string)),
			new DataColumn("TABLE_TYPE", typeof(string)),
			new DataColumn("ENGINE", typeof(string)),
			new DataColumn("VERSION", typeof(string)),
			new DataColumn("ROW_FORMAT", typeof(string)),
			new DataColumn("TABLE_ROWS", typeof(long)),
			new DataColumn("AVG_ROW_LENGTH", typeof(long)),
			new DataColumn("DATA_LENGTH", typeof(long)),
			new DataColumn("MAX_DATA_LENGTH", typeof(long)),
			new DataColumn("INDEX_LENGTH", typeof(long)),
			new DataColumn("DATA_FREE", typeof(long)),
			new DataColumn("AUTO_INCREMENT", typeof(long)),
			new DataColumn("CREATE_TIME", typeof(DateTime)),
			new DataColumn("UPDATE_TIME", typeof(DateTime)),
			new DataColumn("CHECK_TIME", typeof(DateTime)),
			new DataColumn("TABLE_COLLATION", typeof(string)),
			new DataColumn("CHECKSUM", typeof(string)),
			new DataColumn("CREATE_OPTIONS", typeof(string)),
			new DataColumn("TABLE_COMMENT", typeof(string))
		});
		List<KeyValuePair<string, string>> list = new List<KeyValuePair<string, string>>();
		if (restrictionValues != null)
		{
			if (restrictionValues.Length != 0 && !string.IsNullOrEmpty(restrictionValues[0]))
			{
				list.Add(new KeyValuePair<string, string>("TABLE_CATALOG", restrictionValues[0]));
			}
			if (restrictionValues.Length > 1 && !string.IsNullOrEmpty(restrictionValues[1]))
			{
				list.Add(new KeyValuePair<string, string>("TABLE_SCHEMA", restrictionValues[1]));
			}
			if (restrictionValues.Length > 2 && !string.IsNullOrEmpty(restrictionValues[2]))
			{
				list.Add(new KeyValuePair<string, string>("TABLE_NAME", restrictionValues[2]));
			}
			if (restrictionValues.Length > 3 && !string.IsNullOrEmpty(restrictionValues[3]))
			{
				list.Add(new KeyValuePair<string, string>("TABLE_TYPE", restrictionValues[3]));
			}
		}
		await FillDataTableAsync(ioBehavior, dataTable, "TABLES", list, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillTableConstraintsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'TableConstraints'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[6]
		{
			new DataColumn("CONSTRAINT_CATALOG", typeof(string)),
			new DataColumn("CONSTRAINT_SCHEMA", typeof(string)),
			new DataColumn("CONSTRAINT_NAME", typeof(string)),
			new DataColumn("TABLE_SCHEMA", typeof(string)),
			new DataColumn("TABLE_NAME", typeof(string)),
			new DataColumn("CONSTRAINT_TYPE", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "TABLE_CONSTRAINTS", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillTablePrivilegesAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'TablePrivileges'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[6]
		{
			new DataColumn("GRANTEE", typeof(string)),
			new DataColumn("TABLE_CATALOG", typeof(string)),
			new DataColumn("TABLE_SCHEMA", typeof(string)),
			new DataColumn("TABLE_NAME", typeof(string)),
			new DataColumn("PRIVILEGE_TYPE", typeof(string)),
			new DataColumn("IS_GRANTABLE", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "TABLE_PRIVILEGES", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillTableSpacesAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'TableSpaces'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[9]
		{
			new DataColumn("TABLESPACE_NAME", typeof(string)),
			new DataColumn("ENGINE", typeof(string)),
			new DataColumn("TABLESPACE_TYPE", typeof(string)),
			new DataColumn("LOGFILE_GROUP_NAME", typeof(string)),
			new DataColumn("EXTENT_SIZE", typeof(long)),
			new DataColumn("AUTOEXTEND_SIZE", typeof(long)),
			new DataColumn("MAXIMUM_SIZE", typeof(long)),
			new DataColumn("NODEGROUP_ID", typeof(long)),
			new DataColumn("TABLESPACE_COMMENT", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "TABLESPACES", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillTriggersAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'Triggers'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[22]
		{
			new DataColumn("TRIGGER_CATALOG", typeof(string)),
			new DataColumn("TRIGGER_SCHEMA", typeof(string)),
			new DataColumn("TRIGGER_NAME", typeof(string)),
			new DataColumn("EVENT_MANIPULATION", typeof(string)),
			new DataColumn("EVENT_OBJECT_CATALOG", typeof(string)),
			new DataColumn("EVENT_OBJECT_SCHEMA", typeof(string)),
			new DataColumn("EVENT_OBJECT_TABLE", typeof(string)),
			new DataColumn("ACTION_ORDER", typeof(long)),
			new DataColumn("ACTION_CONDITION", typeof(string)),
			new DataColumn("ACTION_STATEMENT", typeof(string)),
			new DataColumn("ACTION_ORIENTATION", typeof(string)),
			new DataColumn("ACTION_TIMING", typeof(string)),
			new DataColumn("ACTION_REFERENCE_OLD_TABLE", typeof(string)),
			new DataColumn("ACTION_REFERENCE_NEW_TABLE", typeof(string)),
			new DataColumn("ACTION_REFERENCE_OLD_ROW", typeof(string)),
			new DataColumn("ACTION_REFERENCE_NEW_ROW", typeof(string)),
			new DataColumn("CREATED", typeof(DateTime)),
			new DataColumn("SQL_MODE", typeof(string)),
			new DataColumn("DEFINER", typeof(string)),
			new DataColumn("CHARACTER_SET_CLIENT", typeof(string)),
			new DataColumn("COLLATION_CONNECTION", typeof(string)),
			new DataColumn("DATABASE_COLLATION", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "TRIGGERS", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillUserPrivilegesAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'UserPrivileges'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[4]
		{
			new DataColumn("GRANTEE", typeof(string)),
			new DataColumn("TABLE_CATALOG", typeof(string)),
			new DataColumn("PRIVILEGE_TYPE", typeof(string)),
			new DataColumn("IS_GRANTABLE", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "USER_PRIVILEGES", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillViewsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length != 0)
		{
			throw new ArgumentException("restrictionValues is not supported for schema 'Views'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[10]
		{
			new DataColumn("TABLE_CATALOG", typeof(string)),
			new DataColumn("TABLE_SCHEMA", typeof(string)),
			new DataColumn("TABLE_NAME", typeof(string)),
			new DataColumn("VIEW_DEFINITION", typeof(string)),
			new DataColumn("CHECK_OPTION", typeof(string)),
			new DataColumn("IS_UPDATABLE", typeof(string)),
			new DataColumn("DEFINER", typeof(string)),
			new DataColumn("SECURITY_TYPE", typeof(string)),
			new DataColumn("CHARACTER_SET_CLIENT", typeof(string)),
			new DataColumn("COLLATION_CONNECTION", typeof(string))
		});
		await FillDataTableAsync(ioBehavior, dataTable, "VIEWS", null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillForeignKeysAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length > 4)
		{
			throw new ArgumentException("More than 4 restrictionValues are not supported for schema 'Foreign Keys'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[12]
		{
			new DataColumn("CONSTRAINT_CATALOG", typeof(string)),
			new DataColumn("CONSTRAINT_SCHEMA", typeof(string)),
			new DataColumn("CONSTRAINT_NAME", typeof(string)),
			new DataColumn("TABLE_CATALOG", typeof(string)),
			new DataColumn("TABLE_SCHEMA", typeof(string)),
			new DataColumn("TABLE_NAME", typeof(string)),
			new DataColumn("MATCH_OPTION", typeof(string)),
			new DataColumn("UPDATE_RULE", typeof(string)),
			new DataColumn("DELETE_RULE", typeof(string)),
			new DataColumn("REFERENCED_TABLE_CATALOG", typeof(string)),
			new DataColumn("REFERENCED_TABLE_SCHEMA", typeof(string)),
			new DataColumn("REFERENCED_TABLE_NAME", typeof(string))
		});
		await DoFillForeignKeysAsync(ioBehavior, dataTable, restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillIndexesAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length > 4)
		{
			throw new ArgumentException("More than 4 restrictionValues are not supported for schema 'Indexes'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[8]
		{
			new DataColumn("INDEX_CATALOG", typeof(string)),
			new DataColumn("INDEX_SCHEMA", typeof(string)),
			new DataColumn("INDEX_NAME", typeof(string)),
			new DataColumn("TABLE_NAME", typeof(string)),
			new DataColumn("UNIQUE", typeof(bool)),
			new DataColumn("PRIMARY", typeof(bool)),
			new DataColumn("TYPE", typeof(string)),
			new DataColumn("COMMENT", typeof(string))
		});
		await DoFillIndexesAsync(ioBehavior, dataTable, restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task FillIndexColumnsAsync(IOBehavior ioBehavior, DataTable dataTable, string tableName, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string[] restrictionValues, CancellationToken cancellationToken)
	{
		if (restrictionValues != null && restrictionValues.Length > 5)
		{
			throw new ArgumentException("More than 5 restrictionValues are not supported for schema 'IndexColumns'.", "restrictionValues");
		}
		dataTable.TableName = tableName;
		dataTable.Columns.AddRange(new DataColumn[7]
		{
			new DataColumn("INDEX_CATALOG", typeof(string)),
			new DataColumn("INDEX_SCHEMA", typeof(string)),
			new DataColumn("INDEX_NAME", typeof(string)),
			new DataColumn("TABLE_NAME", typeof(string)),
			new DataColumn("COLUMN_NAME", typeof(string)),
			new DataColumn("ORDINAL_POSITION", typeof(int)),
			new DataColumn("SORT_ORDER", typeof(string))
		});
		await DoFillIndexColumnsAsync(ioBehavior, dataTable, restrictionValues, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}
}


using System;
using System.Buffers.Text;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.Pipes;
using System.Linq;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security.Authentication;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using MySqlConnector.Authentication;
using MySqlConnector.Core;
using MySqlConnector.Logging;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class ServerSession
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	internal sealed class SslClientAuthenticationOptions
	{
		public X509RevocationMode CertificateRevocationCheckMode { get; set; }

		public X509CertificateCollection ClientCertificates { get; set; }

		public SslProtocols EnabledSslProtocols { get; set; }

		public string TargetHost { get; set; }
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private enum State
	{
		Created,
		Connecting,
		Connected,
		Querying,
		CancelingQuery,
		ClearingPendingCancellation,
		Closing,
		Closed,
		Failed
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private sealed class DelimiterSqlParser : SqlParser
	{
		public bool HasDelimiter { get; private set; }

		private string Sql { get; } = command.CommandText;

		public DelimiterSqlParser(IMySqlCommand command)
			: base(new StatementPreparer(command.CommandText, null, command.CreateStatementPreparerOptions()))
		{
		}

		protected override void OnStatementBegin(int index)
		{
			if (index + 10 < Sql.Length && MemoryExtensions.Equals(MemoryExtensions.AsSpan(Sql, index, 10), MemoryExtensions.AsSpan("delimiter "), StringComparison.OrdinalIgnoreCase))
			{
				HasDelimiter = true;
			}
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private readonly struct __ExpectedSessionState6Struct : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		private readonly string _sessionId;

		private readonly State _expectedState1;

		private readonly State _expectedState2;

		private readonly State _expectedState3;

		private readonly State _expectedState4;

		private readonly State _expectedState5;

		private readonly State _expectedState6;

		private readonly State _sessionState;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2, 1 })]
		public static readonly Func<__ExpectedSessionState6Struct, Exception, string> Format = (__ExpectedSessionState6Struct state, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception ex) => state.ToString();

		public int Count => 9;

		[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
		public KeyValuePair<string, object> this[int index]
		{
			[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
			get
			{
				return index switch
				{
					0 => new KeyValuePair<string, object>("SessionId", _sessionId), 
					1 => new KeyValuePair<string, object>("ExpectedState1", _expectedState1), 
					2 => new KeyValuePair<string, object>("ExpectedState2", _expectedState2), 
					3 => new KeyValuePair<string, object>("ExpectedState3", _expectedState3), 
					4 => new KeyValuePair<string, object>("ExpectedState4", _expectedState4), 
					5 => new KeyValuePair<string, object>("ExpectedState5", _expectedState5), 
					6 => new KeyValuePair<string, object>("ExpectedState6", _expectedState6), 
					7 => new KeyValuePair<string, object>("SessionState", _sessionState), 
					8 => new KeyValuePair<string, object>("{OriginalFormat}", "Session {SessionId} should have state {ExpectedState1} or {ExpectedState2} or {ExpectedState3} or {ExpectedState4} or {ExpectedState5} or {ExpectedState6} but was {SessionState}"), 
					_ => throw new IndexOutOfRangeException("index"), 
				};
			}
		}

		public __ExpectedSessionState6Struct(string sessionId, State expectedState1, State expectedState2, State expectedState3, State expectedState4, State expectedState5, State expectedState6, State sessionState)
		{
			_sessionId = sessionId;
			_expectedState1 = expectedState1;
			_expectedState2 = expectedState2;
			_expectedState3 = expectedState3;
			_expectedState4 = expectedState4;
			_expectedState5 = expectedState5;
			_expectedState6 = expectedState6;
			_sessionState = sessionState;
		}

		public override string ToString()
		{
			string sessionId = _sessionId;
			State expectedState = _expectedState1;
			State expectedState2 = _expectedState2;
			State expectedState3 = _expectedState3;
			State expectedState4 = _expectedState4;
			State expectedState5 = _expectedState5;
			State expectedState6 = _expectedState6;
			State sessionState = _sessionState;
			return $"Session {sessionId} should have state {expectedState} or {expectedState2} or {expectedState3} or {expectedState4} or {expectedState5} or {expectedState6} but was {sessionState}";
		}

		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			for (int i = 0; i < 9; i++)
			{
				yield return this[i];
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	private static readonly PayloadData s_setNamesUtf8NoAttributesPayload = QueryPayload.Create(supportsQueryAttributes: false, "SET NAMES utf8;"u8);

	private static readonly PayloadData s_setNamesUtf8mb4NoAttributesPayload = QueryPayload.Create(supportsQueryAttributes: false, "SET NAMES utf8mb4;"u8);

	private static readonly PayloadData s_setNamesUtf8WithAttributesPayload = QueryPayload.Create(supportsQueryAttributes: true, "SET NAMES utf8;"u8);

	private static readonly PayloadData s_setNamesUtf8mb4WithAttributesPayload = QueryPayload.Create(supportsQueryAttributes: true, "SET NAMES utf8mb4;"u8);

	private static readonly PayloadData s_sleepNoAttributesPayload = QueryPayload.Create(supportsQueryAttributes: false, "SELECT SLEEP(0) INTO @\ue001MySqlConnector\ue001Sleep;"u8);

	private static readonly PayloadData s_sleepWithAttributesPayload = QueryPayload.Create(supportsQueryAttributes: true, "SELECT SLEEP(0) INTO @\ue001MySqlConnector\ue001Sleep;"u8);

	private static readonly PayloadData s_selectConnectionIdVersionNoAttributesPayload = QueryPayload.Create(supportsQueryAttributes: false, "SELECT CONNECTION_ID(), VERSION();"u8);

	private static readonly PayloadData s_selectConnectionIdVersionWithAttributesPayload = QueryPayload.Create(supportsQueryAttributes: true, "SELECT CONNECTION_ID(), VERSION();"u8);

	private static int s_lastId;

	private readonly ILogger m_logger;

	private readonly object m_lock;

	private readonly ArraySegmentHolder<byte> m_payloadCache;

	private readonly ActivityTagsCollection m_activityTags;

	private State m_state;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private TcpClient m_tcpClient;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private Socket m_socket;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private Stream m_stream;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private SslStream m_sslStream;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private X509Certificate2 m_clientCertificate;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private IPayloadHandler m_payloadHandler;

	private bool m_useCompression;

	private bool m_isSecureConnection;

	private bool m_supportsConnectionAttributes;

	private bool m_supportsPipelining;

	private CharacterSet m_characterSet;

	private PayloadData m_setNamesPayload;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private byte[] m_pipelinedResetConnectionBytes;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1, 1 })]
	private Dictionary<string, PreparedStatements> m_preparedStatements;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, State, Exception> __CannotExecuteNewCommandInStateCallback = LoggerMessage.Define<string, State>(LogLevel.Error, new EventId(2200, "CannotExecuteNewCommandInState"), "Session {SessionId} can't execute new command when in state {SessionState}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static readonly Action<ILogger, string, State, Exception> __EnteringFinishQueryingCallback = LoggerMessage.Define<string, State>(LogLevel.Trace, new EventId(2201, "EnteringFinishQuerying"), "Session {SessionId} entering FinishQuerying; state is {SessionState}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 1, 2 })]
	private static readonly Action<ILogger, string, State, State, Exception> __ExpectedSessionState1Callback = LoggerMessage.Define<string, State, State>(LogLevel.Error, new EventId(2011, "ExpectedSessionState1"), "Session {SessionId} should have state {ExpectedState1} but was {SessionState}", new LogDefineOptions
	{
		SkipEnabledCheck = true
	});

	public string Id { get; }

	public ServerVersion ServerVersion { get; set; }

	public bool SupportsPerQueryVariables
	{
		get
		{
			if (ServerVersion.IsMariaDb)
			{
				return ServerVersion.Version >= ServerVersions.MariaDbSupportsPerQueryVariables;
			}
			return false;
		}
	}

	public int ActiveCommandId { get; private set; }

	public int CancellationTimeout { get; private set; }

	public int ConnectionId { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public byte[] AuthPluginData
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		set;
	}

	public long CreatedTimestamp { get; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public ConnectionPool Pool
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
	}

	public int PoolGeneration { get; }

	public long LastLeasedTimestamp { get; set; }

	public long LastReturnedTimestamp { get; private set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public string DatabaseOverride
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		set;
	}

	public string HostName { get; private set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public IPEndPoint IPEndPoint
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get
		{
			return m_tcpClient?.Client.RemoteEndPoint as IPEndPoint;
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public string UserID
	{
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		get;
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		private set;
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	[field: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
	public WeakReference<MySqlConnection> OwningConnection
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
		get;
		[param: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 2, 1 })]
		set;
	}

	public bool SupportsDeprecateEof { get; private set; }

	public bool SupportsCachedPreparedMetadata { get; private set; }

	public bool SupportsQueryAttributes { get; private set; }

	public bool SupportsSessionTrack { get; private set; }

	public bool ProcAccessDenied { get; set; }

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
	public ICollection<KeyValuePair<string, object>> ActivityTags
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
		get
		{
			return m_activityTags;
		}
	}

	public MySqlDataReader DataReader { get; set; }

	public bool IsConnected
	{
		get
		{
			lock (m_lock)
			{
				return m_state == State.Connected;
			}
		}
	}

	public bool IsCancelingQuery => m_state == State.CancelingQuery;

	internal bool SslIsEncrypted => m_sslStream?.IsEncrypted ?? false;

	internal bool SslIsSigned => m_sslStream?.IsSigned ?? false;

	internal bool SslIsAuthenticated => m_sslStream?.IsAuthenticated ?? false;

	internal bool SslIsMutuallyAuthenticated => m_sslStream?.IsMutuallyAuthenticated ?? false;

	internal SslProtocols SslProtocol => m_sslStream?.SslProtocol ?? SslProtocols.None;

	public ServerSession(ILogger logger)
		: this(logger, null, 0, Interlocked.Increment(ref s_lastId))
	{
	}

	public ServerSession(ILogger logger, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] ConnectionPool pool, int poolGeneration, int id)
	{
		m_logger = logger;
		m_lock = new object();
		m_payloadCache = new ArraySegmentHolder<byte>();
		Id = (pool?.Id ?? 0) + "." + id;
		ServerVersion = ServerVersion.Empty;
		CreatedTimestamp = Stopwatch.GetTimestamp();
		Pool = pool;
		PoolGeneration = poolGeneration;
		HostName = "";
		m_activityTags = new ActivityTagsCollection();
		DataReader = new MySqlDataReader();
		Log.CreatedNewSession(m_logger, Id);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public ValueTask ReturnToPoolAsync(IOBehavior ioBehavior, MySqlConnection owningConnection)
	{
		Log.ReturningToPool(m_logger, Id, Pool?.Id ?? 0);
		LastReturnedTimestamp = Stopwatch.GetTimestamp();
		if (Pool == null)
		{
			return default(ValueTask);
		}
		MetricsReporter.RecordUseTime(Pool, Utility.GetElapsedSeconds(LastLeasedTimestamp, LastReturnedTimestamp));
		LastLeasedTimestamp = 0L;
		return Pool.ReturnAsync(ioBehavior, this);
	}

	public bool TryStartCancel(ICancellableCommand command)
	{
		lock (m_lock)
		{
			if (ActiveCommandId != command.CommandId)
			{
				return false;
			}
			VerifyState(State.Querying, State.CancelingQuery, State.ClearingPendingCancellation, State.Closing, State.Closed, State.Failed);
			if (m_state != State.Querying)
			{
				return false;
			}
			if (command.CancelAttemptCount++ >= 10)
			{
				return false;
			}
			m_state = State.CancelingQuery;
		}
		Log.WillCancelCommand(m_logger, Id, command.CommandId, command.CancelAttemptCount, (command as MySqlCommand)?.CommandText);
		return true;
	}

	public void DoCancel(ICancellableCommand commandToCancel, MySqlCommand killCommand)
	{
		Log.CancelingCommandFromSession(m_logger, Id, commandToCancel.CommandId, killCommand.Connection.Session.Id, (commandToCancel as MySqlCommand)?.CommandText);
		lock (m_lock)
		{
			if (ActiveCommandId != commandToCancel.CommandId)
			{
				Log.IgnoringCancellationForInactiveCommand(m_logger, Id, ActiveCommandId, commandToCancel.CommandId);
				return;
			}
			Log.CancelingCommand(m_logger, killCommand.Connection.Session.Id, commandToCancel.CommandId, killCommand.CommandText);
			killCommand.ExecuteNonQuery();
		}
	}

	public void AbortCancel(ICancellableCommand command)
	{
		lock (m_lock)
		{
			if (ActiveCommandId == command.CommandId && m_state == State.CancelingQuery)
			{
				m_state = State.Querying;
			}
		}
	}

	public async Task PrepareAsync(IMySqlCommand command, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		string commandText = command.CommandText;
		string commandText2;
		if (command.CommandType == CommandType.StoredProcedure)
		{
			CachedProcedure cachedProcedure = await command.Connection.GetCachedProcedure(commandText, revalidateMissing: false, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (cachedProcedure == null)
			{
				NormalizedSchema normalizedSchema = NormalizedSchema.MustNormalize(command.CommandText, command.Connection.Database);
				throw new MySqlException("Procedure or function '" + normalizedSchema.Component + "' cannot be found in database '" + normalizedSchema.Schema + "'.");
			}
			int count = cachedProcedure.Parameters.Count;
			StringBuilder stringBuilder = new StringBuilder("CALL ", commandText.Length + 8 + count * 2);
			stringBuilder.Append(commandText);
			stringBuilder.Append('(');
			for (int i = 0; i < count; i++)
			{
				stringBuilder.Append("?,");
			}
			if (count == 0)
			{
				stringBuilder.Append(')');
			}
			else
			{
				stringBuilder[stringBuilder.Length - 1] = ')';
			}
			stringBuilder.Append(';');
			commandText2 = stringBuilder.ToString();
		}
		else
		{
			commandText2 = commandText;
		}
		StatementPreparer statementPreparer = new StatementPreparer(commandText2, command.RawParameters, command.CreateStatementPreparerOptions());
		ParsedStatements parsedStatements = statementPreparer.SplitStatements();
		ResizableArray<byte> columnsAndParameters = new ResizableArray<byte>();
		int columnsAndParametersSize = 0;
		List<PreparedStatement> preparedStatements = new List<PreparedStatement>(parsedStatements.Statements.Count);
		foreach (ParsedStatement statement in parsedStatements.Statements)
		{
			await SendAsync(new PayloadData(statement.StatementBytes), ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			PayloadData payloadData;
			try
			{
				payloadData = await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			catch (MySqlException exception)
			{
				ThrowIfStatementContainsDelimiter(exception, command);
				throw;
			}
			StatementPrepareResponsePayload response = StatementPrepareResponsePayload.Create(payloadData.Span);
			ColumnDefinitionPayload[] parameters = null;
			if (response.ParameterCount > 0)
			{
				parameters = new ColumnDefinitionPayload[response.ParameterCount];
				for (int j = 0; j < response.ParameterCount; j++)
				{
					payloadData = await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					int length = payloadData.Span.Length;
					Utility.Resize(ref columnsAndParameters, columnsAndParametersSize + length);
					payloadData.Span.CopyTo(columnsAndParameters.AsSpan(columnsAndParametersSize));
					ColumnDefinitionPayload.Initialize(ref parameters[j], new ResizableArraySegment<byte>(columnsAndParameters, columnsAndParametersSize, length));
					columnsAndParametersSize += length;
				}
				if (!SupportsDeprecateEof)
				{
					EofPayload.Create((await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span);
				}
			}
			ColumnDefinitionPayload[] columns = null;
			if (response.ColumnCount > 0)
			{
				columns = new ColumnDefinitionPayload[response.ColumnCount];
				for (int j = 0; j < response.ColumnCount; j++)
				{
					payloadData = await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					int length2 = payloadData.Span.Length;
					Utility.Resize(ref columnsAndParameters, columnsAndParametersSize + length2);
					payloadData.Span.CopyTo(columnsAndParameters.AsSpan(columnsAndParametersSize));
					ColumnDefinitionPayload.Initialize(ref columns[j], new ResizableArraySegment<byte>(columnsAndParameters, columnsAndParametersSize, length2));
					columnsAndParametersSize += length2;
				}
				if (!SupportsDeprecateEof)
				{
					EofPayload.Create((await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span);
				}
			}
			preparedStatements.Add(new PreparedStatement(response.StatementId, statement, columns, parameters));
		}
		if (m_preparedStatements == null)
		{
			m_preparedStatements = new Dictionary<string, PreparedStatements>();
		}
		m_preparedStatements.Add(commandText, new PreparedStatements(preparedStatements, parsedStatements));
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public PreparedStatements TryGetPreparedStatement(string commandText)
	{
		if (m_preparedStatements == null || !m_preparedStatements.TryGetValue(commandText, out var value))
		{
			return null;
		}
		return value;
	}

	public void StartQuerying(ICancellableCommand command)
	{
		lock (m_lock)
		{
			State state = m_state;
			if ((uint)(state - 3) <= 1u)
			{
				CannotExecuteNewCommandInState(m_logger, Id, m_state);
				throw new InvalidOperationException("This MySqlConnection is already in use. See https://fl.vu/mysql-conn-reuse");
			}
			VerifyState(State.Connected);
			m_state = State.Querying;
			command.CancelAttemptCount = 0;
			ActiveCommandId = command.CommandId;
		}
	}

	public void FinishQuerying()
	{
		EnteringFinishQuerying(m_logger, Id, m_state);
		bool flag = false;
		lock (m_lock)
		{
			if (m_state == State.CancelingQuery)
			{
				m_state = State.ClearingPendingCancellation;
				flag = true;
			}
		}
		if (flag)
		{
			Log.SendingSleepToClearPendingCancellation(m_logger, Id);
			PayloadData payload = (SupportsQueryAttributes ? s_sleepWithAttributesPayload : s_sleepNoAttributesPayload);
			SendAsync(payload, IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult();
			OkPayload.Verify(ReceiveReplyAsync(IOBehavior.Synchronous, CancellationToken.None).GetAwaiter().GetResult().Span, SupportsDeprecateEof, SupportsSessionTrack);
		}
		lock (m_lock)
		{
			State state = m_state;
			if ((state == State.Querying || state == State.ClearingPendingCancellation) ? true : false)
			{
				m_state = State.Connected;
			}
			else
			{
				VerifyState(State.Failed);
			}
			ActiveCommandId = 0;
		}
	}

	public void SetTimeout(int timeoutMilliseconds)
	{
		m_payloadHandler.ByteHandler.RemainingTimeout = timeoutMilliseconds;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	public Activity StartActivity([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] string name, string tagName1 = null, object tagValue1 = null)
	{
		Activity activity = ActivitySourceHelper.StartActivity(name, m_activityTags);
		if (activity != null && activity.IsAllDataRequested)
		{
			if (DatabaseOverride != null)
			{
				activity.SetTag("db.name", DatabaseOverride);
			}
			if (tagName1 != null)
			{
				activity.SetTag(tagName1, tagValue1);
			}
		}
		return activity;
	}

	public async Task DisposeAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (m_payloadHandler != null)
		{
			State state2;
			lock (m_lock)
			{
				State state = m_state;
				if ((state == State.Connected || state == State.Failed) ? true : false)
				{
					m_state = State.Closing;
				}
				state2 = m_state;
			}
			if (state2 == State.Closing)
			{
				try
				{
					Log.SendingQuitCommand(m_logger, Id);
					m_payloadHandler.StartNewConversation();
					await m_payloadHandler.WritePayloadAsync(QuitPayload.Instance.Memory, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (IOException)
				{
				}
				catch (NotSupportedException)
				{
				}
				catch (ObjectDisposedException)
				{
				}
				catch (SocketException)
				{
				}
			}
		}
		ClearPreparedStatements();
		ShutdownSocket();
		lock (m_lock)
		{
			m_state = State.Closed;
		}
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2 })]
	public async Task<string> ConnectAsync(ConnectionSettings cs, MySqlConnection connection, long startingTimestamp, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] ILoadBalancer loadBalancer, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Activity activity, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		_ = 10;
		try
		{
			lock (m_lock)
			{
				VerifyState(State.Created);
				m_state = State.Connecting;
			}
			string connectionString = cs.ConnectionStringBuilder.GetConnectionString(cs.ConnectionStringBuilder.PersistSecurityInfo);
			m_activityTags.Add("db.system", "mysql");
			m_activityTags.Add("db.connection_string", connectionString);
			m_activityTags.Add("db.user", cs.UserID);
			if (cs.Database.Length != 0)
			{
				m_activityTags.Add("db.name", cs.Database);
			}
			if (activity != null && activity.IsAllDataRequested)
			{
				activity.SetTag("db.system", "mysql").SetTag("db.connection_string", connectionString).SetTag("db.user", cs.UserID);
				if (cs.Database.Length != 0)
				{
					activity.SetTag("db.name", cs.Database);
				}
			}
			if (cs.ConnectionProtocol switch
			{
				MySqlConnectionProtocol.Sockets => (await OpenTcpSocketAsync(cs, loadBalancer ?? throw new ArgumentNullException("loadBalancer"), activity, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)) ? 1 : 0, 
				MySqlConnectionProtocol.UnixSocket => (await OpenUnixSocketAsync(cs, activity, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)) ? 1 : 0, 
				MySqlConnectionProtocol.Pipe => (await OpenNamedPipeAsync(cs, startingTimestamp, activity, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)) ? 1 : 0, 
				_ => 0, 
			} == 0)
			{
				lock (m_lock)
				{
					m_state = State.Failed;
				}
				Log.ConnectingFailed(m_logger, Id);
				throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Unable to connect to any of the specified MySQL hosts.");
			}
			IByteHandler byteHandler2;
			if (m_socket != null)
			{
				IByteHandler byteHandler = new SocketByteHandler(m_socket);
				byteHandler2 = byteHandler;
			}
			else
			{
				IByteHandler byteHandler = new StreamByteHandler(m_stream);
				byteHandler2 = byteHandler;
			}
			IByteHandler byteHandler3 = byteHandler2;
			if (cs.ConnectionTimeout != 0)
			{
				byteHandler3.RemainingTimeout = Math.Max(1, cs.ConnectionTimeoutMilliseconds - Utility.GetElapsedMilliseconds(startingTimestamp));
			}
			m_payloadHandler = new StandardPayloadHandler(byteHandler3);
			InitialHandshakePayload initialHandshake = InitialHandshakePayload.Create((await ReceiveAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span);
			string text = (((initialHandshake.ProtocolCapabilities & ProtocolCapabilities.PluginAuth) != ProtocolCapabilities.None) ? initialHandshake.AuthPluginName : (((initialHandshake.ProtocolCapabilities & ProtocolCapabilities.SecureConnection) == ProtocolCapabilities.None) ? "mysql_old_password" : "mysql_native_password"));
			Log.ServerSentAuthPluginName(m_logger, Id, text);
			switch (text)
			{
			default:
				Log.UnsupportedAuthenticationMethod(m_logger, Id, text);
				throw new NotSupportedException("Authentication method '" + initialHandshake.AuthPluginName + "' is not supported.");
			case "mysql_native_password":
			case "sha256_password":
			case "caching_sha2_password":
			{
				ServerVersion = new ServerVersion(initialHandshake.ServerVersion);
				ConnectionId = initialHandshake.ConnectionId;
				AuthPluginData = initialHandshake.AuthPluginData;
				m_useCompression = cs.UseCompression && (initialHandshake.ProtocolCapabilities & ProtocolCapabilities.Compress) != 0;
				CancellationTimeout = cs.CancellationTimeout;
				UserID = cs.UserID;
				string value = ConnectionId.ToString(CultureInfo.InvariantCulture);
				m_activityTags["db.connection_id"] = value;
				if (activity != null && activity.IsAllDataRequested)
				{
					activity.SetTag("db.connection_id", value);
				}
				m_supportsConnectionAttributes = (initialHandshake.ProtocolCapabilities & ProtocolCapabilities.ConnectionAttributes) != 0;
				SupportsDeprecateEof = (initialHandshake.ProtocolCapabilities & ProtocolCapabilities.DeprecateEof) != 0;
				SupportsCachedPreparedMetadata = (initialHandshake.ProtocolCapabilities & ProtocolCapabilities.MariaDbCacheMetadata) != 0;
				SupportsQueryAttributes = (initialHandshake.ProtocolCapabilities & ProtocolCapabilities.QueryAttributes) != 0;
				SupportsSessionTrack = (initialHandshake.ProtocolCapabilities & ProtocolCapabilities.SessionTrack) != 0;
				bool flag = (initialHandshake.ProtocolCapabilities & ProtocolCapabilities.Ssl) != 0;
				m_characterSet = ((ServerVersion.Version >= ServerVersions.SupportsUtf8Mb4) ? CharacterSet.Utf8Mb4GeneralCaseInsensitive : CharacterSet.Utf8Mb3GeneralCaseInsensitive);
				m_setNamesPayload = ((!(ServerVersion.Version >= ServerVersions.SupportsUtf8Mb4)) ? (SupportsQueryAttributes ? s_setNamesUtf8WithAttributesPayload : s_setNamesUtf8NoAttributesPayload) : (SupportsQueryAttributes ? s_setNamesUtf8mb4WithAttributesPayload : s_setNamesUtf8mb4NoAttributesPayload));
				if (!cs.Pipelining.HasValue && ServerVersion.Version.Major == 5 && ServerVersion.Version.Minor == 7 && HostName.EndsWith(".rds.amazonaws.com", StringComparison.OrdinalIgnoreCase))
				{
					Log.AutoDetectedAurora57(m_logger, Id, HostName);
					m_supportsPipelining = false;
				}
				else
				{
					m_supportsPipelining = !cs.UseCompression && !((!cs.Pipelining) ?? false);
					if (m_supportsPipelining)
					{
						m_pipelinedResetConnectionBytes = new byte[m_setNamesPayload.Span.Length + 9];
						m_pipelinedResetConnectionBytes[0] = 1;
						m_pipelinedResetConnectionBytes[4] = 31;
						m_pipelinedResetConnectionBytes[5] = (byte)m_setNamesPayload.Span.Length;
						ReadOnlySpan<byte> span = m_setNamesPayload.Span;
						Span<byte> span2 = MemoryExtensions.AsSpan(m_pipelinedResetConnectionBytes);
						span.CopyTo(span2.Slice(9, span2.Length - 9));
					}
				}
				Log.SessionMadeConnection(m_logger, Id, ServerVersion.OriginalString, ConnectionId, m_useCompression, m_supportsConnectionAttributes, SupportsDeprecateEof, SupportsCachedPreparedMetadata, flag, SupportsSessionTrack, m_supportsPipelining, SupportsQueryAttributes);
				if (cs.SslMode != 0 && (cs.SslMode != MySqlSslMode.Preferred || flag))
				{
					if (!flag)
					{
						Log.ServerDoesNotSupportSsl(m_logger, Id);
						throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Server does not support SSL");
					}
					await InitSslAsync(initialHandshake.ProtocolCapabilities, cs, connection, cs.TlsVersions, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				if (m_supportsConnectionAttributes && cs.ConnectionAttributes == null)
				{
					cs.ConnectionAttributes = CreateConnectionAttributes(cs.ApplicationName);
				}
				string password = GetPassword(cs, connection);
				using (PayloadData handshakeResponsePayload = HandshakeResponse41Payload.Create(initialHandshake, cs, password, m_useCompression, m_characterSet, m_supportsConnectionAttributes ? cs.ConnectionAttributes : null))
				{
					await SendReplyAsync(handshakeResponsePayload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				PayloadData payload = await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				while (payload.HeaderByte == 254)
				{
					payload = await SwitchAuthenticationAsync(cs, password, payload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				OkPayload okPayload = OkPayload.Create(payload.Span, SupportsDeprecateEof, SupportsSessionTrack);
				string statusInfo = okPayload.StatusInfo;
				if (m_useCompression)
				{
					m_payloadHandler = new CompressedPayloadHandler(m_payloadHandler.ByteHandler);
				}
				await SendAsync(m_setNamesPayload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				OkPayload.Verify((await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span, SupportsDeprecateEof, SupportsSessionTrack);
				if (ShouldGetRealServerDetails(cs))
				{
					await GetRealServerDetailsAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
				}
				m_payloadHandler.ByteHandler.RemainingTimeout = int.MaxValue;
				return statusInfo;
			}
			}
		}
		catch (ArgumentException ex)
		{
			Log.CouldNotConnectToServer(m_logger, ex, Id);
			throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Couldn't connect to server", ex);
		}
		catch (IOException ex2)
		{
			Log.CouldNotConnectToServer(m_logger, ex2, Id);
			throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Couldn't connect to server", ex2);
		}
	}

	public async Task<bool> TryResetConnectionAsync(ConnectionSettings cs, MySqlConnection connection, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		VerifyState(State.Connected);
		try
		{
			ClearPreparedStatements();
			if (DatabaseOverride == null && ((!ServerVersion.IsMariaDb && ServerVersion.Version.CompareTo(ServerVersions.SupportsResetConnection) >= 0) || (ServerVersion.IsMariaDb && ServerVersion.Version.CompareTo(ServerVersions.MariaDbSupportsResetConnection) >= 0)))
			{
				if (m_supportsPipelining)
				{
					Log.SendingPipelinedResetConnectionRequest(m_logger, Id, ServerVersion.OriginalString);
					await SendRawAsync(m_pipelinedResetConnectionBytes, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					OkPayload.Verify((await ReceiveReplyAsync(1, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span, SupportsDeprecateEof, SupportsSessionTrack);
					OkPayload.Verify((await ReceiveReplyAsync(1, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span, SupportsDeprecateEof, SupportsSessionTrack);
					return true;
				}
				Log.SendingResetConnectionRequest(m_logger, Id, ServerVersion.OriginalString);
				await SendAsync(ResetConnectionPayload.Instance, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				OkPayload.Verify((await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span, SupportsDeprecateEof, SupportsSessionTrack);
			}
			else
			{
				if (DatabaseOverride == null)
				{
					Log.SendingChangeUserRequest(m_logger, Id, ServerVersion.OriginalString);
				}
				else
				{
					Log.SendingChangeUserRequestDueToChangedDatabase(m_logger, Id, DatabaseOverride);
					DatabaseOverride = null;
				}
				string password = GetPassword(cs, connection);
				byte[] array = AuthenticationUtility.CreateAuthenticationResponse(AuthPluginData, password);
				using (PayloadData changeUserPayload = ChangeUserPayload.Create(cs.UserID, array, cs.Database, m_characterSet, m_supportsConnectionAttributes ? cs.ConnectionAttributes : null))
				{
					await SendAsync(changeUserPayload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				PayloadData payload = await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (payload.HeaderByte == 254)
				{
					Log.OptimisticReauthenticationFailed(m_logger, Id);
					payload = await SwitchAuthenticationAsync(cs, password, payload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				OkPayload.Verify(payload.Span, SupportsDeprecateEof, SupportsSessionTrack);
			}
			await SendAsync(m_setNamesPayload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			OkPayload.Verify((await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span, SupportsDeprecateEof, SupportsSessionTrack);
			return true;
		}
		catch (IOException exception)
		{
			Log.IgnoringFailureInTryResetConnectionAsync(m_logger, exception, Id, "IOException");
		}
		catch (MySqlException ex) when (ex.ErrorCode == MySqlErrorCode.ClientInteractionTimeout)
		{
			Log.IgnoringFailureInTryResetConnectionAsync(m_logger, ex, Id, "ClientInteractionTimeout MySqlException");
		}
		catch (ObjectDisposedException exception2)
		{
			Log.IgnoringFailureInTryResetConnectionAsync(m_logger, exception2, Id, "ObjectDisposedException");
		}
		catch (SocketException exception3)
		{
			Log.IgnoringFailureInTryResetConnectionAsync(m_logger, exception3, Id, "SocketException");
		}
		return false;
	}

	private async Task<PayloadData> SwitchAuthenticationAsync(ConnectionSettings cs, string password, PayloadData payload, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		AuthenticationMethodSwitchRequestPayload switchRequest = AuthenticationMethodSwitchRequestPayload.Create(payload.Span);
		Log.SwitchingToAuthenticationMethod(m_logger, Id, switchRequest.Name);
		switch (switchRequest.Name)
		{
		case "mysql_native_password":
		{
			AuthPluginData = switchRequest.Data;
			byte[] data = AuthenticationUtility.CreateAuthenticationResponse(AuthPluginData, password);
			payload = new PayloadData(data);
			await SendReplyAsync(payload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		case "mysql_clear_password":
		{
			if (!m_isSecureConnection)
			{
				Log.NeedsSecureConnection(m_logger, Id, switchRequest.Name);
				throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Authentication method '" + switchRequest.Name + "' requires a secure connection.");
			}
			byte[] nullTerminatedPasswordBytes = AuthenticationUtility.GetNullTerminatedPasswordBytes(password);
			payload = new PayloadData(nullTerminatedPasswordBytes);
			await SendReplyAsync(payload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		case "caching_sha2_password":
		{
			byte[] data2 = AuthenticationUtility.CreateScrambleResponse(Utility.TrimZeroByte(MemoryExtensions.AsSpan(switchRequest.Data)), password);
			payload = new PayloadData(data2);
			await SendReplyAsync(payload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			payload = await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (OkPayload.IsOk(payload.Span, SupportsDeprecateEof))
			{
				return payload;
			}
			if (CachingSha2ServerResponsePayload.Create(payload.Span).Succeeded)
			{
				return await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			goto case "sha256_password";
		}
		case "sha256_password":
			if (!m_isSecureConnection && password.Length != 0)
			{
				string rsaPublicKey = await GetRsaPublicKeyAsync(switchRequest.Name, cs, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				return await SendEncryptedPasswordAsync(switchRequest.Data, rsaPublicKey, password, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return await SendClearPasswordAsync(password, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		case "auth_gssapi_client":
			return await AuthGSSAPI.AuthenticateAsync(cs, switchRequest.Data, this, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		case "mysql_old_password":
			Log.AuthenticationMethodNotSupported(m_logger, Id, switchRequest.Name);
			throw new NotSupportedException("'MySQL Server is requesting the insecure pre-4.1 auth mechanism (mysql_old_password). The user password must be upgraded; see https://dev.mysql.com/doc/refman/5.7/en/account-upgrades.html.");
		case "client_ed25519":
		{
			if (!AuthenticationPlugins.TryGetPlugin(switchRequest.Name, out var plugin))
			{
				throw new NotSupportedException("You must install the MySqlConnector.Authentication.Ed25519 package and call Ed25519AuthenticationPlugin.Install to use client_ed25519 authentication.");
			}
			payload = new PayloadData(plugin.CreateResponse(password, switchRequest.Data));
			await SendReplyAsync(payload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		default:
			Log.AuthenticationMethodNotSupported(m_logger, Id, switchRequest.Name);
			throw new NotSupportedException("Authentication method '" + switchRequest.Name + "' is not supported.");
		}
	}

	private async Task<PayloadData> SendClearPasswordAsync(string password, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		byte[] nullTerminatedPasswordBytes = AuthenticationUtility.GetNullTerminatedPasswordBytes(password);
		PayloadData payload = new PayloadData(nullTerminatedPasswordBytes);
		await SendReplyAsync(payload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		return await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task<PayloadData> SendEncryptedPasswordAsync(byte[] switchRequestData, string rsaPublicKey, string password, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		using RSA rsa = RSA.Create();
		RSAParameters rsaParameters;
		try
		{
			rsaParameters = Utility.GetRsaParameters(rsaPublicKey);
		}
		catch (Exception ex)
		{
			Log.CouldNotLoadServerRsaPublicKey(m_logger, ex, Id);
			throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Couldn't load server's RSA public key; try using a secure connection instead.", ex);
		}
		rsa.ImportParameters(rsaParameters);
		byte[] nullTerminatedPasswordBytes = AuthenticationUtility.GetNullTerminatedPasswordBytes(password);
		AuthPluginData = Utility.TrimZeroByte(switchRequestData);
		for (int i = 0; i < nullTerminatedPasswordBytes.Length; i++)
		{
			nullTerminatedPasswordBytes[i] ^= AuthPluginData[i % AuthPluginData.Length];
		}
		RSAEncryptionPadding oaepSHA = RSAEncryptionPadding.OaepSHA1;
		byte[] data = rsa.Encrypt(nullTerminatedPasswordBytes, oaepSHA);
		PayloadData payload = new PayloadData(data);
		await SendReplyAsync(payload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		return await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	}

	private async Task<string> GetRsaPublicKeyAsync(string switchRequestName, ConnectionSettings cs, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		if (cs.ServerRsaPublicKeyFile.Length != 0)
		{
			try
			{
				return File.ReadAllText(cs.ServerRsaPublicKeyFile);
			}
			catch (IOException ex)
			{
				Log.CouldNotLoadServerRsaPublicKeyFromFile(m_logger, ex, Id, cs.ServerRsaPublicKeyFile);
				throw new MySqlException("Couldn't load server's RSA public key from '" + cs.ServerRsaPublicKeyFile + "'", ex);
			}
		}
		if (cs.AllowPublicKeyRetrieval)
		{
			byte b = (byte)((!(switchRequestName == "caching_sha2_password")) ? 1 : 2);
			await SendReplyAsync(new PayloadData(new byte[1] { b }), ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			AuthenticationMoreDataPayload authenticationMoreDataPayload = AuthenticationMoreDataPayload.Create((await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span);
			return Encoding.ASCII.GetString(authenticationMoreDataPayload.Data);
		}
		Log.CouldNotUseAuthenticationMethodForRsa(m_logger, Id, switchRequestName);
		throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Authentication method '" + switchRequestName + "' failed. Either use a secure connection, specify the server's RSA public key with ServerRSAPublicKeyFile, or set AllowPublicKeyRetrieval=True.");
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public async ValueTask<bool> TryPingAsync(bool logInfo, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		VerifyState(State.Connected);
		try
		{
			Log.PingingServer(m_logger, Id);
			await SendAsync(PingPayload.Instance, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			OkPayload.Verify((await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Span, SupportsDeprecateEof, SupportsSessionTrack);
			Log.SuccessfullyPingedServer(m_logger, logInfo ? LogLevel.Information : LogLevel.Trace, Id);
			return true;
		}
		catch (IOException exception)
		{
			Log.PingFailed(m_logger, exception, Id, "IOException");
		}
		catch (MySqlException ex) when (ex.ErrorCode == MySqlErrorCode.ClientInteractionTimeout)
		{
			Log.PingFailed(m_logger, ex, Id, "ClientInteractionTimeout MySqlException");
		}
		catch (SocketException exception2)
		{
			Log.PingFailed(m_logger, exception2, Id, "SocketException");
		}
		VerifyState(State.Failed);
		return false;
	}

	public ValueTask SendAsync(PayloadData payload, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		m_payloadHandler.StartNewConversation();
		return SendReplyAsync(payload, ioBehavior, cancellationToken);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public ValueTask<PayloadData> ReceiveAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		m_payloadHandler.StartNewConversation();
		return ReceiveReplyAsync(ioBehavior, cancellationToken);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public async ValueTask<PayloadData> ReceiveReplyAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		InvalidOperationException ex = CreateExceptionForInvalidState();
		if (ex != null)
		{
			Log.FailedInReceiveReplyAsync(m_logger, ex, Id);
			throw ex;
		}
		ArraySegment<byte> arraySegment;
		try
		{
			arraySegment = await m_payloadHandler.ReadPayloadAsync(m_payloadCache, ProtocolErrorBehavior.Throw, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
		}
		catch (Exception ex2)
		{
			if (ex2 is MySqlEndOfStreamException ex3)
			{
				Log.ExpectedToReadMoreBytes(m_logger, Id, ex3.ExpectedByteCount, ex3.ReadByteCount);
			}
			SetFailed(ex2);
			throw;
		}
		PayloadData result = new PayloadData(arraySegment);
		if (result.HeaderByte != byte.MaxValue)
		{
			return result;
		}
		throw CreateExceptionForErrorPayload(result.Span);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public ValueTask<PayloadData> ReceiveReplyAsync(int expectedSequenceNumber, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		m_payloadHandler.SetNextSequenceNumber(expectedSequenceNumber);
		return ReceiveReplyAsync(ioBehavior, cancellationToken);
	}

	public async ValueTask SendReplyAsync(PayloadData payload, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		InvalidOperationException ex = CreateExceptionForInvalidState();
		if (ex != null)
		{
			Log.FailedInSendReplyAsync(m_logger, ex, Id);
			throw ex;
		}
		try
		{
			await m_payloadHandler.WritePayloadAsync(payload.Memory, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
		}
		catch (Exception failed)
		{
			SetFailed(failed);
			throw;
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public async ValueTask SendRawAsync(ReadOnlyMemory<byte> data, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		InvalidOperationException ex = CreateExceptionForInvalidState();
		if (ex != null)
		{
			Log.FailedInSendReplyAsync(m_logger, ex, Id);
			throw ex;
		}
		try
		{
			await m_payloadHandler.ByteHandler.WriteBytesAsync(data, ioBehavior).ConfigureAwait(continueOnCapturedContext: false);
		}
		catch (Exception failed)
		{
			SetFailed(failed);
			throw;
		}
	}

	public static void ThrowIfStatementContainsDelimiter(MySqlException exception, IMySqlCommand command)
	{
		if (exception.ErrorCode != MySqlErrorCode.ParseError)
		{
			return;
		}
		string commandText = command.CommandText;
		if (commandText != null && commandText.IndexOf("delimiter", StringComparison.OrdinalIgnoreCase) >= 0)
		{
			DelimiterSqlParser delimiterSqlParser = new DelimiterSqlParser(command);
			delimiterSqlParser.Parse(command.CommandText);
			if (delimiterSqlParser.HasDelimiter)
			{
				throw new MySqlException(MySqlErrorCode.DelimiterNotSupported, "'DELIMITER' should not be used with MySqlConnector. See https://fl.vu/mysql-delimiter", exception);
			}
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	private InvalidOperationException CreateExceptionForInvalidState()
	{
		lock (m_lock)
		{
			switch (m_state)
			{
			case State.Closed:
				return new ObjectDisposedException("ServerSession");
			case State.Connected:
			case State.Querying:
			case State.CancelingQuery:
			case State.ClearingPendingCancellation:
			case State.Closing:
				return null;
			default:
				return new InvalidOperationException("ServerSession is not connected.");
			}
		}
	}

	private async Task<bool> OpenTcpSocketAsync(ConnectionSettings cs, ILoadBalancer loadBalancer, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Activity activity, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		m_activityTags.Add("net.transport", "ip_tcp");
		string text = ((cs.Port == 3306) ? null : cs.Port.ToString(CultureInfo.InvariantCulture));
		if (text != null)
		{
			m_activityTags.Add("net.peer.port", text);
		}
		if (activity != null && activity.IsAllDataRequested)
		{
			activity.SetTag("net.transport", "ip_tcp");
			if (text != null)
			{
				activity.SetTag("net.peer.port", text);
			}
		}
		IReadOnlyList<string> hostNames = loadBalancer.LoadBalance(cs.HostNames);
		bool flag = default(bool);
		for (int hostNameIndex = 0; hostNameIndex < hostNames.Count; hostNameIndex++)
		{
			string hostName = hostNames[hostNameIndex];
			IPAddress[] ipAddresses;
			try
			{
				IPAddress[] array = ((ioBehavior != IOBehavior.Asynchronous) ? Dns.GetHostAddresses(hostName) : (await Dns.GetHostAddressesAsync(hostName).ConfigureAwait(continueOnCapturedContext: false)));
				ipAddresses = array;
			}
			catch (SocketException ex)
			{
				Log.FailedToResolveHostName(m_logger, ex, Id, hostName, hostNameIndex + 1, hostNames.Count, ex.Message);
				continue;
			}
			for (int ipAddressIndex = 0; ipAddressIndex < ipAddresses.Length; ipAddressIndex++)
			{
				IPAddress iPAddress = ipAddresses[ipAddressIndex];
				string ipAddressString = iPAddress.ToString();
				Log.ConnectingToIpAddress(m_logger, Id, ipAddressString, ipAddressIndex + 1, ipAddresses.Length, hostName, hostNameIndex + 1, hostNames.Count);
				m_activityTags["net.peer.ip"] = ipAddressString;
				if (ipAddressString != hostName)
				{
					m_activityTags["net.peer.name"] = hostName;
				}
				else
				{
					m_activityTags.Remove("net.peer.name");
				}
				if (activity != null && activity.IsAllDataRequested)
				{
					activity.SetTag("net.peer.ip", ipAddressString);
					if (ipAddressString != hostName)
					{
						activity.SetTag("net.peer.name", hostName);
					}
					else
					{
						activity.SetTag("net.peer.name", null);
					}
				}
				TcpClient tcpClient = null;
				try
				{
					tcpClient = new TcpClient(iPAddress.AddressFamily);
					using (cancellationToken.Register(delegate
					{
						tcpClient?.Client?.Dispose();
					}))
					{
						_ = 1;
						try
						{
							if (ioBehavior == IOBehavior.Asynchronous)
							{
								await tcpClient.ConnectAsync(iPAddress, cs.Port).ConfigureAwait(continueOnCapturedContext: false);
							}
							else if (Utility.IsWindows())
							{
								tcpClient.Connect(iPAddress, cs.Port);
							}
							else
							{
								int sendTimeout = tcpClient.Client.SendTimeout;
								int receiveTimeout = tcpClient.Client.ReceiveTimeout;
								tcpClient.Client.SendTimeout = cs.ConnectionTimeoutMilliseconds;
								tcpClient.Client.ReceiveTimeout = cs.ConnectionTimeoutMilliseconds;
								tcpClient.Connect(iPAddress, cs.Port);
								tcpClient.Client.SendTimeout = sendTimeout;
								tcpClient.Client.ReceiveTimeout = receiveTimeout;
							}
						}
						catch (Exception ex2) when (((Func<bool>)delegate
						{
							// Could not convert BlockContainer to single expression
							flag = cancellationToken.IsCancellationRequested;
							if (flag)
							{
								flag = ((ex2 is ObjectDisposedException || ex2 is SocketException) ? true : false);
							}
							return flag;
						}).Invoke())
						{
							SafeDispose(ref tcpClient);
							Log.ConnectTimeoutExpired(m_logger, ex2, Id, ipAddressString, hostName);
							throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Connect Timeout expired.");
						}
					}
				}
				catch (SocketException ex3)
				{
					SafeDispose(ref tcpClient);
					if (hostNameIndex == hostNames.Count - 1 && ipAddressIndex == ipAddresses.Length - 1)
					{
						lock (m_lock)
						{
							m_state = State.Failed;
						}
						if (hostNames.Count == 1 && ipAddresses.Length == 1)
						{
							Log.FailedToConnectToSingleIpAddress(m_logger, ex3, Id, ipAddressString, hostName, ex3.Message);
						}
						else
						{
							Log.FailedToConnectToIpAddress(m_logger, ex3, LogLevel.Information, Id, ipAddressString, ipAddressIndex + 1, ipAddresses.Length, hostName, hostNameIndex + 1, hostNames.Count, ex3.Message);
						}
						throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Unable to connect to any of the specified MySQL hosts.");
					}
					Log.FailedToConnectToIpAddress(m_logger, ex3, LogLevel.Trace, Id, ipAddressString, ipAddressIndex + 1, ipAddresses.Length, hostName, hostNameIndex + 1, hostNames.Count, ex3.Message);
					continue;
				}
				if (!tcpClient.Connected && cancellationToken.IsCancellationRequested)
				{
					SafeDispose(ref tcpClient);
					Log.ConnectTimeoutExpired(m_logger, null, Id, ipAddressString, hostName);
					throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Connect Timeout expired.");
				}
				try
				{
					HostName = hostName;
					m_tcpClient = tcpClient;
					m_socket = m_tcpClient.Client;
					m_socket.NoDelay = true;
					m_stream = m_tcpClient.GetStream();
					m_socket.SetKeepAlive(cs.Keepalive);
				}
				catch (ObjectDisposedException) when (cancellationToken.IsCancellationRequested)
				{
					Utility.Dispose(ref m_stream);
					SafeDispose(ref m_tcpClient);
					SafeDispose(ref m_socket);
					Log.ConnectTimeoutExpired(m_logger, null, Id, ipAddressString, hostName);
					throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Connect Timeout expired.");
				}
				lock (m_lock)
				{
					m_state = State.Connected;
				}
				Log.ConnectedToIpAddress(m_logger, Id, ipAddressString, hostName, (m_socket.LocalEndPoint as IPEndPoint)?.Port);
				return true;
			}
		}
		return false;
	}

	private async Task<bool> OpenUnixSocketAsync(ConnectionSettings cs, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Activity activity, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		Log.ConnectingToUnixSocket(m_logger, Id, cs.UnixSocket);
		m_activityTags.Add("net.transport", "unix");
		m_activityTags.Add("net.peer.name", cs.UnixSocket);
		if (activity != null && activity.IsAllDataRequested)
		{
			activity.SetTag("net.transport", "unix").SetTag("net.peer.name", cs.UnixSocket);
		}
		Socket socket = new Socket(AddressFamily.Unix, SocketType.Stream, ProtocolType.IP);
		UnixDomainSocketEndPoint unixDomainSocketEndPoint = new UnixDomainSocketEndPoint(cs.UnixSocket);
		try
		{
			using (cancellationToken.Register(socket.Dispose))
			{
				try
				{
					if (ioBehavior == IOBehavior.Asynchronous)
					{
						await Task.Factory.FromAsync(socket.BeginConnect, socket.EndConnect, unixDomainSocketEndPoint, null).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						socket.Connect(unixDomainSocketEndPoint);
					}
				}
				catch (ObjectDisposedException) when (cancellationToken.IsCancellationRequested)
				{
					Log.ConnectTimeoutExpiredForUnixSocket(m_logger, Id, cs.UnixSocket);
					throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Connect Timeout expired.");
				}
			}
		}
		catch (SocketException)
		{
			socket.Dispose();
		}
		if (socket.Connected)
		{
			m_socket = socket;
			m_stream = new NetworkStream(socket);
			lock (m_lock)
			{
				m_state = State.Connected;
			}
			return true;
		}
		return false;
	}

	private async Task<bool> OpenNamedPipeAsync(ConnectionSettings cs, long startingTimestamp, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Activity activity, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		Log.ConnectingToNamedPipe(m_logger, Id, cs.PipeName, cs.HostNames[0]);
		string value = "\\\\" + cs.HostNames[0] + "\\pipe\\" + cs.PipeName;
		m_activityTags.Add("net.transport", "pipe");
		m_activityTags.Add("net.peer.name", value);
		if (activity != null && activity.IsAllDataRequested)
		{
			activity.SetTag("net.transport", "pipe");
			activity.SetTag("net.peer.name", value);
		}
		NamedPipeClientStream namedPipeStream = new NamedPipeClientStream(cs.HostNames[0], cs.PipeName, PipeDirection.InOut, PipeOptions.Asynchronous);
		int timeout = Math.Max(1, cs.ConnectionTimeoutMilliseconds - Utility.GetElapsedMilliseconds(startingTimestamp));
		try
		{
			using (cancellationToken.Register(namedPipeStream.Dispose))
			{
				try
				{
					if (ioBehavior == IOBehavior.Asynchronous)
					{
						await namedPipeStream.ConnectAsync(timeout, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						namedPipeStream.Connect(timeout);
					}
				}
				catch (Exception ex) when ((ex is ObjectDisposedException && cancellationToken.IsCancellationRequested) || ex is TimeoutException)
				{
					Log.ConnectTimeoutExpiredForNamedPipe(m_logger, ex, Id, cs.PipeName, cs.HostNames[0]);
					throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "Connect Timeout expired.");
				}
			}
		}
		catch (IOException)
		{
			namedPipeStream.Dispose();
		}
		if (namedPipeStream.IsConnected)
		{
			m_stream = namedPipeStream;
			lock (m_lock)
			{
				m_state = State.Connected;
			}
			return true;
		}
		return false;
	}

	private async Task InitSslAsync(ProtocolCapabilities serverCapabilities, ConnectionSettings cs, MySqlConnection connection, SslProtocols sslProtocols, IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		Log.InitializingTlsConnection(m_logger, Id);
		X509CertificateCollection clientCertificates = null;
		if (cs.CertificateStoreLocation != 0)
		{
			try
			{
				StoreLocation storeLocation = ((cs.CertificateStoreLocation == MySqlCertificateStoreLocation.CurrentUser) ? StoreLocation.CurrentUser : StoreLocation.LocalMachine);
				using X509Store x509Store = new X509Store(StoreName.My, storeLocation);
				x509Store.Open(OpenFlags.OpenExistingOnly);
				if (cs.CertificateThumbprint.Length == 0)
				{
					if (x509Store.Certificates.Count == 0)
					{
						Log.NoCertificatesFound(m_logger, Id);
						throw new MySqlException("No certificates were found in the certificate store");
					}
					clientCertificates = new X509CertificateCollection(x509Store.Certificates);
				}
				else
				{
					MySqlSslMode sslMode = cs.SslMode;
					bool flag = (uint)(sslMode - 3) <= 1u;
					bool validOnly = flag;
					X509Certificate2Collection x509Certificate2Collection = x509Store.Certificates.Find(X509FindType.FindByThumbprint, cs.CertificateThumbprint, validOnly);
					if (x509Certificate2Collection.Count == 0)
					{
						Log.CertificateNotFoundInStore(m_logger, Id, cs.CertificateThumbprint);
						throw new MySqlException("Certificate with Thumbprint " + cs.CertificateThumbprint + " not found");
					}
					clientCertificates = new X509CertificateCollection(x509Certificate2Collection);
				}
			}
			catch (CryptographicException ex)
			{
				Log.CouldNotLoadCertificate(m_logger, ex, Id, cs.CertificateStoreLocation);
				throw new MySqlException("Certificate couldn't be loaded from the CertificateStoreLocation", ex);
			}
		}
		if (cs.SslKeyFile.Length != 0 && cs.SslCertificateFile.Length != 0)
		{
			clientCertificates = LoadCertificate(cs.SslKeyFile, cs.SslCertificateFile);
		}
		else if (cs.CertificateFile.Length != 0)
		{
			try
			{
				X509Certificate2 x509Certificate = new X509Certificate2(cs.CertificateFile, cs.CertificatePassword, X509KeyStorageFlags.MachineKeySet);
				if (!x509Certificate.HasPrivateKey)
				{
					x509Certificate.Dispose();
					Log.NoPrivateKeyIncludedWithCertificateFile(m_logger, Id, cs.CertificateFile);
					throw new MySqlException("CertificateFile does not contain a private key. CertificateFile should be in PKCS #12 (.pfx) format and contain both a Certificate and Private Key");
				}
				m_clientCertificate = x509Certificate;
				clientCertificates = new X509CertificateCollection { x509Certificate };
			}
			catch (CryptographicException ex2)
			{
				Log.CouldNotLoadCertificateFromFile(m_logger, ex2, Id, cs.CertificateFile);
				if (!File.Exists(cs.CertificateFile))
				{
					throw new MySqlException("Cannot find Certificate File", ex2);
				}
				throw new MySqlException("Either the Certificate Password is incorrect or the Certificate File is invalid", ex2);
			}
		}
		if (clientCertificates == null)
		{
			Func<X509CertificateCollection, ValueTask> provideClientCertificatesCallback = connection.ProvideClientCertificatesCallback;
			if (provideClientCertificatesCallback != null)
			{
				clientCertificates = new X509CertificateCollection();
				try
				{
					await provideClientCertificatesCallback(clientCertificates).ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (Exception ex3)
				{
					Log.FailedToObtainClientCertificates(m_logger, ex3, Id, ex3.Message);
					throw new MySqlException("Failed to obtain client certificates via ProvideClientCertificatesCallback", ex3);
				}
			}
		}
		X509Chain caCertificateChain = null;
		if (cs.CACertificateFile.Length != 0)
		{
			X509Chain x509Chain = new X509Chain
			{
				ChainPolicy = 
				{
					RevocationMode = X509RevocationMode.NoCheck,
					VerificationFlags = X509VerificationFlags.AllowUnknownCertificateAuthority
				}
			};
			try
			{
				Log.LoadingCaCertificatesFromFile(m_logger, Id, cs.CACertificateFile);
				byte[] array;
				try
				{
					array = File.ReadAllBytes(cs.CACertificateFile);
				}
				catch (Exception ex4)
				{
					Log.CouldNotLoadCaCertificateFromFile(m_logger, ex4, LogLevel.Error, Id, cs.CACertificateFile);
					if (!File.Exists(cs.CACertificateFile))
					{
						throw new MySqlException("Cannot find CA Certificate File: " + cs.CACertificateFile, ex4);
					}
					throw new MySqlException("Could not load CA Certificate File: " + cs.CACertificateFile, ex4);
				}
				int num = 0;
				while (num != -1)
				{
					int num2 = Utility.FindNextIndex(array, num + 1, "-----BEGIN CERTIFICATE-----"u8);
					try
					{
						Log.LoadingCaCertificate(m_logger, Id, num);
						X509Certificate2 certificate = new X509Certificate2(Utility.ArraySlice(array, num, ((num2 == -1) ? array.Length : num2) - num), (string?)null, X509KeyStorageFlags.MachineKeySet);
						x509Chain.ChainPolicy.ExtraStore.Add(certificate);
					}
					catch (CryptographicException exception)
					{
						Log.CouldNotLoadCaCertificateFromFile(m_logger, exception, LogLevel.Warning, Id, cs.CACertificateFile);
					}
					num = num2;
				}
				Log.LoadedCaCertificatesFromFile(m_logger, Id, x509Chain.ChainPolicy.ExtraStore.Count, cs.CACertificateFile);
				caCertificateChain = x509Chain;
				x509Chain = null;
			}
			finally
			{
				x509Chain?.Dispose();
			}
		}
		RemoteCertificateValidationCallback userCertificateValidationCallback = ValidateRemoteCertificate;
		if (connection.RemoteCertificateValidationCallback != null)
		{
			if (caCertificateChain != null)
			{
				Log.NotUsingRemoteCertificateValidationCallbackDueToSslCa(m_logger, Id);
			}
			else
			{
				MySqlSslMode sslMode = cs.SslMode;
				if (sslMode != MySqlSslMode.Preferred && sslMode != MySqlSslMode.Required)
				{
					Log.NotUsingRemoteCertificateValidationCallbackDueToSslMode(m_logger, Id, cs.SslMode);
				}
				else
				{
					Log.UsingRemoteCertificateValidationCallback(m_logger, Id);
					userCertificateValidationCallback = connection.RemoteCertificateValidationCallback;
				}
			}
		}
		SslStream sslStream = ((clientCertificates == null) ? new SslStream(m_stream, leaveInnerStreamOpen: false, userCertificateValidationCallback) : new SslStream(m_stream, leaveInnerStreamOpen: false, userCertificateValidationCallback, ValidateLocalCertificate));
		bool checkCertificateRevocation = cs.SslMode == MySqlSslMode.VerifyFull;
		using (PayloadData initSsl = HandshakeResponse41Payload.CreateWithSsl(serverCapabilities, cs, m_useCompression, m_characterSet))
		{
			await SendReplyAsync(initSsl, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
		SslClientAuthenticationOptions sslClientAuthenticationOptions = new SslClientAuthenticationOptions
		{
			EnabledSslProtocols = sslProtocols,
			ClientCertificates = clientCertificates,
			TargetHost = HostName,
			CertificateRevocationCheckMode = (checkCertificateRevocation ? X509RevocationMode.Online : X509RevocationMode.NoCheck)
		};
		try
		{
			if (ioBehavior == IOBehavior.Asynchronous)
			{
				await sslStream.AuthenticateAsClientAsync(sslClientAuthenticationOptions.TargetHost, sslClientAuthenticationOptions.ClientCertificates, sslClientAuthenticationOptions.EnabledSslProtocols, checkCertificateRevocation).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				sslStream.AuthenticateAsClient(sslClientAuthenticationOptions.TargetHost, sslClientAuthenticationOptions.ClientCertificates, sslClientAuthenticationOptions.EnabledSslProtocols, checkCertificateRevocation);
			}
			StreamByteHandler byteHandler = new StreamByteHandler(sslStream);
			m_payloadHandler.ByteHandler = byteHandler;
			m_isSecureConnection = true;
			m_sslStream = sslStream;
			Log.ConnectedTlsDetailed(m_logger, Id, sslStream.SslProtocol, sslStream.CipherAlgorithm, sslStream.HashAlgorithm, sslStream.KeyExchangeAlgorithm, sslStream.KeyExchangeStrength);
		}
		catch (Exception ex5)
		{
			Log.CouldNotInitializeTlsConnection(m_logger, ex5, Id);
			sslStream.Dispose();
			ShutdownSocket();
			HostName = "";
			lock (m_lock)
			{
				m_state = State.Failed;
			}
			if (ex5 is AuthenticationException)
			{
				throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "SSL Authentication Error", ex5);
			}
			if (ex5 is IOException && clientCertificates != null)
			{
				throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "MySQL Server rejected client certificate", ex5);
			}
			if (ex5 is Win32Exception { NativeErrorCode: -2146893007 })
			{
				throw new MySqlException(MySqlErrorCode.UnableToConnectToHost, "The server doesn't support the client's specified TLS versions.", ex5);
			}
			throw;
		}
		finally
		{
			caCertificateChain?.Dispose();
		}
		X509CertificateCollection LoadCertificate(string sslKeyFile, string sslCertificateFile)
		{
			Log.LoadingClientKeyFromKeyFile(m_logger, Id, sslKeyFile);
			string key;
			try
			{
				key = File.ReadAllText(sslKeyFile);
			}
			catch (Exception ex7)
			{
				Log.CouldNotLoadClientKeyFromKeyFile(m_logger, ex7, Id, sslKeyFile);
				throw new MySqlException("Could not load the client key from '" + sslKeyFile + "'", ex7);
			}
			RSAParameters rsaParameters;
			try
			{
				rsaParameters = Utility.GetRsaParameters(key);
			}
			catch (FormatException ex8)
			{
				Log.CouldNotLoadClientKeyFromKeyFile(m_logger, ex8, Id, sslKeyFile);
				throw new MySqlException("Could not load the client key from '" + sslKeyFile + "'", ex8);
			}
			try
			{
				RSA rSA;
				try
				{
					rSA = new RSACryptoServiceProvider(new CspParameters
					{
						KeyContainerName = Guid.NewGuid().ToString()
					})
					{
						PersistKeyInCsp = true
					};
				}
				catch (PlatformNotSupportedException)
				{
					rSA = RSA.Create();
				}
				rSA.ImportParameters(rsaParameters);
				X509Certificate2 x509Certificate2;
				using (X509Certificate2 certificate2 = new X509Certificate2(sslCertificateFile))
				{
					x509Certificate2 = certificate2.CopyWithPrivateKey(rSA);
				}
				m_clientCertificate = x509Certificate2;
				return new X509CertificateCollection { x509Certificate2 };
			}
			catch (CryptographicException ex10)
			{
				Log.CouldNotLoadClientKeyFromKeyFile(m_logger, ex10, Id, sslCertificateFile);
				if (!File.Exists(sslCertificateFile))
				{
					throw new MySqlException("Cannot find client certificate file: " + sslCertificateFile, ex10);
				}
				throw new MySqlException("Could not load the client key from " + sslCertificateFile, ex10);
			}
		}
		static X509Certificate ValidateLocalCertificate(object lcbSender, string lcbTargetHost, X509CertificateCollection lcbLocalCertificates, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] X509Certificate lcbRemoteCertificate, string[] lcbAcceptableIssuers)
		{
			return lcbLocalCertificates[0];
		}
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		bool ValidateRemoteCertificate([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] object rcbSender, X509Certificate rcbCertificate, X509Chain rcbChain, SslPolicyErrors rcbPolicyErrors)
		{
			MySqlSslMode sslMode2 = cs.SslMode;
			if ((uint)(sslMode2 - 1) <= 1u)
			{
				return true;
			}
			if ((rcbPolicyErrors & SslPolicyErrors.RemoteCertificateChainErrors) != 0 && rcbChain != null && caCertificateChain != null)
			{
				X509Chain x509Chain2 = caCertificateChain;
				X509ChainElementCollection chainElements = rcbChain.ChainElements;
				if (x509Chain2.Build(chainElements[chainElements.Count - 1].Certificate) && caCertificateChain.ChainStatus.Length != 0 && caCertificateChain.ChainStatus[0].Status == X509ChainStatusFlags.UntrustedRoot)
				{
					X509ChainElementCollection chainElements2 = caCertificateChain.ChainElements;
					X509Certificate2 certificate3 = chainElements2[chainElements2.Count - 1].Certificate;
					X509Certificate2Enumerator enumerator = caCertificateChain.ChainPolicy.ExtraStore.GetEnumerator();
					while (enumerator.MoveNext())
					{
						X509Certificate2 current = enumerator.Current;
						if (MemoryExtensions.AsSpan(certificate3.RawData).SequenceEqual(current.RawData))
						{
							rcbPolicyErrors &= ~SslPolicyErrors.RemoteCertificateChainErrors;
							break;
						}
					}
				}
			}
			if (cs.SslMode == MySqlSslMode.VerifyCA)
			{
				rcbPolicyErrors &= ~SslPolicyErrors.RemoteCertificateNameMismatch;
			}
			return rcbPolicyErrors == SslPolicyErrors.None;
		}
	}

	private bool ShouldGetRealServerDetails(ConnectionSettings cs)
	{
		bool flag;
		switch (ServerVersion.OriginalString)
		{
		case "5.6.47.0":
		case "5.6.42.0":
		case "5.6.39.0":
			flag = true;
			break;
		default:
			flag = false;
			break;
		}
		if (flag)
		{
			return true;
		}
		if (cs.ConnectionProtocol == MySqlConnectionProtocol.Sockets && Enumerable.Contains(cs.UserID, '@'))
		{
			if (!HostName.EndsWith(".mysql.database.azure.com", StringComparison.OrdinalIgnoreCase) && !HostName.EndsWith(".database.windows.net", StringComparison.OrdinalIgnoreCase))
			{
				return HostName.EndsWith(".mysql.database.chinacloudapi.cn", StringComparison.OrdinalIgnoreCase);
			}
			return true;
		}
		return false;
	}

	private async Task GetRealServerDetailsAsync(IOBehavior ioBehavior, CancellationToken cancellationToken)
	{
		Log.DetectedProxy(m_logger, Id);
		try
		{
			PayloadData payload = (SupportsQueryAttributes ? s_selectConnectionIdVersionWithAttributesPayload : s_selectConnectionIdVersionNoAttributesPayload);
			await SendAsync(payload, ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await ReceiveReplyAsync(ioBehavior, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await ReceiveReplyAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
			await ReceiveReplyAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
			if (!SupportsDeprecateEof)
			{
				EofPayload.Create((await ReceiveReplyAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false)).Span);
			}
			ReadRow((await ReceiveReplyAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false)).Span, out var connectionId2, out var serverVersion2);
			payload = await ReceiveReplyAsync(ioBehavior, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
			if (OkPayload.IsOk(payload.Span, SupportsDeprecateEof))
			{
				OkPayload.Verify(payload.Span, SupportsDeprecateEof, SupportsSessionTrack);
			}
			else
			{
				EofPayload.Create(payload.Span);
			}
			if (connectionId2.HasValue)
			{
				int valueOrDefault = connectionId2.GetValueOrDefault();
				if (serverVersion2 != null)
				{
					Log.ChangingConnectionId(m_logger, Id, ConnectionId, valueOrDefault, ServerVersion.OriginalString, serverVersion2.OriginalString);
					ConnectionId = valueOrDefault;
					ServerVersion = serverVersion2;
				}
			}
		}
		catch (MySqlException exception)
		{
			Log.FailedToGetConnectionId(m_logger, exception, Id);
		}
		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
		static void ReadRow(ReadOnlySpan<byte> span, out int? connectionId, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] out ServerVersion serverVersion)
		{
			ByteArrayReader byteArrayReader = new ByteArrayReader(span);
			int num = byteArrayReader.ReadLengthEncodedIntegerOrNull();
			connectionId = ((num != -1 && Utf8Parser.TryParse(byteArrayReader.ReadByteString(num), out int value, out int _, '\0')) ? new int?(value) : ((int?)null));
			num = byteArrayReader.ReadLengthEncodedIntegerOrNull();
			serverVersion = ((num != -1) ? new ServerVersion(byteArrayReader.ReadByteString(num)) : null);
		}
	}

	private void ShutdownSocket()
	{
		Log.ClosingStreamSocket(m_logger, Id);
		Utility.Dispose(ref m_payloadHandler);
		Utility.Dispose(ref m_stream);
		SafeDispose(ref m_tcpClient);
		SafeDispose(ref m_socket);
		Utility.Dispose(ref m_clientCertificate);
		m_activityTags.Clear();
	}

	private static void SafeDispose<T>([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] ref T disposable) where T : class, IDisposable
	{
		if (disposable != null)
		{
			try
			{
				disposable.Dispose();
			}
			catch (IOException)
			{
			}
			catch (SocketException)
			{
			}
			disposable = null;
		}
	}

	internal void SetFailed(Exception exception)
	{
		Log.SettingStateToFailed(m_logger, exception, Id);
		lock (m_lock)
		{
			m_state = State.Failed;
		}
		if (OwningConnection != null && OwningConnection.TryGetTarget(out var target))
		{
			target.SetState(ConnectionState.Closed);
		}
	}

	private void VerifyState(State state)
	{
		if (m_state != state)
		{
			ExpectedSessionState1(m_logger, Id, state, m_state);
			throw new InvalidOperationException($"Expected state to be {state} but was {m_state}.");
		}
	}

	private void VerifyState(State state1, State state2, State state3, State state4, State state5, State state6)
	{
		if (m_state != state1 && m_state != state2 && m_state != state3 && m_state != state4 && m_state != state5 && m_state != state6)
		{
			ExpectedSessionState6(m_logger, Id, state1, state2, state3, state4, state5, state6, m_state);
			throw new InvalidOperationException($"Expected state to be ({state1}|{state2}|{state3}|{state4}|{state5}|{state6}) but was {m_state}.");
		}
	}

	private byte[] CreateConnectionAttributes([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] string programName)
	{
		Log.CreatingConnectionAttributes(m_logger, Id);
		ByteBufferWriter byteBufferWriter = new ByteBufferWriter();
		byteBufferWriter.WriteLengthEncodedString("_client_name");
		byteBufferWriter.WriteLengthEncodedString("MySqlConnector");
		byteBufferWriter.WriteLengthEncodedString("_client_version");
		string text = typeof(ServerSession).GetTypeInfo().Assembly.GetCustomAttribute<AssemblyInformationalVersionAttribute>().InformationalVersion;
		int num = text.IndexOf('+');
		if (num != -1)
		{
			text = text.Substring(0, num);
		}
		byteBufferWriter.WriteLengthEncodedString(text);
		try
		{
			Utility.GetOSDetails(out var os, out var osDescription, out var architecture);
			if (os != null)
			{
				byteBufferWriter.WriteLengthEncodedString("_os");
				byteBufferWriter.WriteLengthEncodedString(os);
			}
			byteBufferWriter.WriteLengthEncodedString("_os_details");
			byteBufferWriter.WriteLengthEncodedString(osDescription);
			byteBufferWriter.WriteLengthEncodedString("_platform");
			byteBufferWriter.WriteLengthEncodedString(architecture);
		}
		catch (PlatformNotSupportedException)
		{
		}
		using Process process = Process.GetCurrentProcess();
		int id = process.Id;
		byteBufferWriter.WriteLengthEncodedString("_pid");
		byteBufferWriter.WriteLengthEncodedString(id.ToString(CultureInfo.InvariantCulture));
		if (!string.IsNullOrEmpty(programName))
		{
			byteBufferWriter.WriteLengthEncodedString("program_name");
			byteBufferWriter.WriteLengthEncodedString(programName);
		}
		using PayloadData payloadData = byteBufferWriter.ToPayloadData();
		ReadOnlySpan<byte> span = payloadData.Span;
		ByteBufferWriter byteBufferWriter2 = new ByteBufferWriter(span.Length + 9);
		byteBufferWriter2.WriteLengthEncodedInteger((ulong)span.Length);
		byteBufferWriter2.Write(span);
		using PayloadData payloadData2 = byteBufferWriter2.ToPayloadData();
		return payloadData2.Memory.ToArray();
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	private MySqlException CreateExceptionForErrorPayload(ReadOnlySpan<byte> span)
	{
		ErrorPayload errorPayload = ErrorPayload.Create(span);
		Log.ErrorPayload(m_logger, Id, errorPayload.ErrorCode, errorPayload.State, errorPayload.Message);
		MySqlException ex = errorPayload.ToException();
		if (ex.ErrorCode == MySqlErrorCode.ClientInteractionTimeout)
		{
			SetFailed(ex);
		}
		return ex;
	}

	private void ClearPreparedStatements()
	{
		if (m_preparedStatements == null)
		{
			return;
		}
		foreach (KeyValuePair<string, PreparedStatements> preparedStatement in m_preparedStatements)
		{
			preparedStatement.Value.Dispose();
		}
		m_preparedStatements.Clear();
	}

	private string GetPassword(ConnectionSettings cs, MySqlConnection connection)
	{
		if (cs.Password.Length != 0)
		{
			return cs.Password;
		}
		Func<MySqlProvidePasswordContext, string> providePasswordCallback = connection.ProvidePasswordCallback;
		if (providePasswordCallback != null)
		{
			try
			{
				Log.ObtainingPasswordViaProvidePasswordCallback(m_logger, Id);
				return providePasswordCallback(new MySqlProvidePasswordContext(HostName, cs.Port, cs.UserID, cs.Database));
			}
			catch (Exception ex)
			{
				Log.FailedToObtainPassword(m_logger, ex, Id, ex.Message);
				throw new MySqlException(MySqlErrorCode.ProvidePasswordCallbackFailed, "Failed to obtain password via ProvidePasswordCallback", ex);
			}
		}
		return "";
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2200, LogLevel.Error, "Session {SessionId} can't execute new command when in state {SessionState}")]
	private static void CannotExecuteNewCommandInState(ILogger logger, string sessionId, State sessionState)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__CannotExecuteNewCommandInStateCallback(logger, sessionId, sessionState, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2201, LogLevel.Trace, "Session {SessionId} entering FinishQuerying; state is {SessionState}")]
	private static void EnteringFinishQuerying(ILogger logger, string sessionId, State sessionState)
	{
		if (logger.IsEnabled(LogLevel.Trace))
		{
			__EnteringFinishQueryingCallback(logger, sessionId, sessionState, null);
		}
	}

	[LoggerMessage(2011, LogLevel.Error, "Session {SessionId} should have state {ExpectedState1} but was {SessionState}")]
	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	private static void ExpectedSessionState1(ILogger logger, string sessionId, State expectedState1, State sessionState)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			__ExpectedSessionState1Callback(logger, sessionId, expectedState1, sessionState, null);
		}
	}

	[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
	[LoggerMessage(2016, LogLevel.Error, "Session {SessionId} should have state {ExpectedState1} or {ExpectedState2} or {ExpectedState3} or {ExpectedState4} or {ExpectedState5} or {ExpectedState6} but was {SessionState}")]
	private static void ExpectedSessionState6(ILogger logger, string sessionId, State expectedState1, State expectedState2, State expectedState3, State expectedState4, State expectedState5, State expectedState6, State sessionState)
	{
		if (logger.IsEnabled(LogLevel.Error))
		{
			logger.Log(LogLevel.Error, new EventId(2016, "ExpectedSessionState6"), new __ExpectedSessionState6Struct(sessionId, expectedState1, expectedState2, expectedState3, expectedState4, expectedState5, expectedState6, sessionState), null, __ExpectedSessionState6Struct.Format);
		}
	}
}


using System.Runtime.CompilerServices;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
internal sealed class SslClientAuthenticationOptions
{
	public X509RevocationMode CertificateRevocationCheckMode { get; set; }

	public X509CertificateCollection ClientCertificates { get; set; }

	public SslProtocols EnabledSslProtocols { get; set; }

	public string TargetHost { get; set; }
}


using System.Runtime.CompilerServices;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
private enum State
{
	Created,
	Connecting,
	Connected,
	Querying,
	CancelingQuery,
	ClearingPendingCancellation,
	Closing,
	Closed,
	Failed
}


using System;
using System.Runtime.CompilerServices;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
private sealed class DelimiterSqlParser : SqlParser
{
	public bool HasDelimiter { get; private set; }

	private string Sql { get; } = command.CommandText;

	public DelimiterSqlParser(IMySqlCommand command)
		: base(new StatementPreparer(command.CommandText, null, command.CreateStatementPreparerOptions()))
	{
	}

	protected override void OnStatementBegin(int index)
	{
		if (index + 10 < Sql.Length && MemoryExtensions.Equals(MemoryExtensions.AsSpan(Sql, index, 10), MemoryExtensions.AsSpan("delimiter "), StringComparison.OrdinalIgnoreCase))
		{
			HasDelimiter = true;
		}
	}
}


using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Microsoft.Extensions.Logging.Generators", "7.0.8.27404")]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
private readonly struct __ExpectedSessionState6Struct : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	private readonly string _sessionId;

	private readonly State _expectedState1;

	private readonly State _expectedState2;

	private readonly State _expectedState3;

	private readonly State _expectedState4;

	private readonly State _expectedState5;

	private readonly State _expectedState6;

	private readonly State _sessionState;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 2, 1 })]
	public static readonly Func<__ExpectedSessionState6Struct, Exception, string> Format = (__ExpectedSessionState6Struct state, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] Exception ex) => state.ToString();

	public int Count => 9;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
	public KeyValuePair<string, object> this[int index]
	{
		[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 0, 1, 2 })]
		get
		{
			return index switch
			{
				0 => new KeyValuePair<string, object>("SessionId", _sessionId), 
				1 => new KeyValuePair<string, object>("ExpectedState1", _expectedState1), 
				2 => new KeyValuePair<string, object>("ExpectedState2", _expectedState2), 
				3 => new KeyValuePair<string, object>("ExpectedState3", _expectedState3), 
				4 => new KeyValuePair<string, object>("ExpectedState4", _expectedState4), 
				5 => new KeyValuePair<string, object>("ExpectedState5", _expectedState5), 
				6 => new KeyValuePair<string, object>("ExpectedState6", _expectedState6), 
				7 => new KeyValuePair<string, object>("SessionState", _sessionState), 
				8 => new KeyValuePair<string, object>("{OriginalFormat}", "Session {SessionId} should have state {ExpectedState1} or {ExpectedState2} or {ExpectedState3} or {ExpectedState4} or {ExpectedState5} or {ExpectedState6} but was {SessionState}"), 
				_ => throw new IndexOutOfRangeException("index"), 
			};
		}
	}

	public __ExpectedSessionState6Struct(string sessionId, State expectedState1, State expectedState2, State expectedState3, State expectedState4, State expectedState5, State expectedState6, State sessionState)
	{
		_sessionId = sessionId;
		_expectedState1 = expectedState1;
		_expectedState2 = expectedState2;
		_expectedState3 = expectedState3;
		_expectedState4 = expectedState4;
		_expectedState5 = expectedState5;
		_expectedState6 = expectedState6;
		_sessionState = sessionState;
	}

	public override string ToString()
	{
		string sessionId = _sessionId;
		State expectedState = _expectedState1;
		State expectedState2 = _expectedState2;
		State expectedState3 = _expectedState3;
		State expectedState4 = _expectedState4;
		State expectedState5 = _expectedState5;
		State expectedState6 = _expectedState6;
		State sessionState = _sessionState;
		return $"Session {sessionId} should have state {expectedState} or {expectedState2} or {expectedState3} or {expectedState4} or {expectedState5} or {expectedState6} but was {sessionState}";
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 0, 1, 2 })]
	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		for (int i = 0; i < 9; i++)
		{
			yield return this[i];
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.Core;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class ServerVersion
{
	public string OriginalString { get; }

	public Version Version { get; }

	public bool IsMariaDb { get; }

	public static ServerVersion Empty { get; } = new ServerVersion();

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public ServerVersion(ReadOnlySpan<byte> versionString)
	{
		OriginalString = Encoding.ASCII.GetString(versionString);
		if (versionString.StartsWith("5.5.5-"u8))
		{
			ref ReadOnlySpan<byte> reference = ref versionString;
			versionString = reference.Slice(6, reference.Length - 6);
			IsMariaDb = true;
		}
		else if (versionString.IndexOf("MariaDB"u8) != -1)
		{
			IsMariaDb = true;
		}
		int value = 0;
		int value2 = 0;
		if (Utf8Parser.TryParse(versionString, out int value3, out int bytesConsumed, '\0'))
		{
			ref ReadOnlySpan<byte> reference = ref versionString;
			int num = bytesConsumed;
			versionString = reference.Slice(num, reference.Length - num);
			if (versionString.Length >= 1 && versionString[0] == 46)
			{
				reference = ref versionString;
				versionString = reference.Slice(1, reference.Length - 1);
				if (Utf8Parser.TryParse(versionString, out value, out bytesConsumed, '\0'))
				{
					reference = ref versionString;
					num = bytesConsumed;
					versionString = reference.Slice(num, reference.Length - num);
					if (versionString.Length >= 1 && versionString[0] == 46)
					{
						reference = ref versionString;
						versionString = reference.Slice(1, reference.Length - 1);
						if (Utf8Parser.TryParse(versionString, out value2, out bytesConsumed, '\0'))
						{
							reference = ref versionString;
							num = bytesConsumed;
							versionString = reference.Slice(num, reference.Length - num);
						}
					}
				}
			}
		}
		Version = new Version(value3, value, value2);
	}

	private ServerVersion()
	{
		OriginalString = "";
		Version = new Version();
	}
}


using System;
using System.Runtime.CompilerServices;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal static class ServerVersions
{
	public static readonly Version SupportsUtf8Mb4 = new Version(5, 5, 3);

	public static readonly Version SupportsResetConnection = new Version(5, 7, 3);

	public static readonly Version MariaDbSupportsResetConnection = new Version(10, 2, 4);

	public static readonly Version SupportsProcedureCache = new Version(5, 5, 3);

	public static readonly Version RemovesMySqlProcTable = new Version(8, 0, 0);

	public static readonly Version MariaDbSupportsPerQueryVariables = new Version(10, 1, 2);
}


using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Runtime.CompilerServices;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Logging;
using MySqlConnector.Protocol.Serialization;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class SingleCommandPayloadCreator : ICommandPayloadCreator
{
	public static ICommandPayloadCreator Instance { get; } = new SingleCommandPayloadCreator();

	public static string OutParameterSentinelColumnName => "\ue001\b\v";

	public bool WriteQueryCommand(ref CommandListPosition commandListPosition, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })] IDictionary<string, CachedProcedure> cachedProcedures, ByteBufferWriter writer, bool appendSemicolon)
	{
		if (commandListPosition.CommandIndex == commandListPosition.CommandCount)
		{
			return false;
		}
		IMySqlCommand mySqlCommand = commandListPosition.CommandAt(commandListPosition.CommandIndex);
		commandListPosition.PreparedStatements = mySqlCommand.TryGetPreparedStatements();
		if (commandListPosition.PreparedStatements == null)
		{
			Log.PreparingCommandPayload(mySqlCommand.Logger, mySqlCommand.Connection.Session.Id, mySqlCommand.CommandText);
			writer.Write((byte)3);
			if (mySqlCommand.Connection.Session.SupportsQueryAttributes)
			{
				MySqlAttributeCollection rawAttributes = mySqlCommand.RawAttributes;
				writer.WriteLengthEncodedInteger((uint)(rawAttributes?.Count ?? 0));
				writer.Write((byte)1);
				if (rawAttributes != null && rawAttributes.Count > 0)
				{
					WriteBinaryParameters(writer, rawAttributes.Select([<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)] (MySqlAttribute x) => x.ToParameter()).ToArray(), mySqlCommand, supportsQueryAttributes: true, 0);
				}
			}
			else
			{
				MySqlAttributeCollection rawAttributes2 = mySqlCommand.RawAttributes;
				if (rawAttributes2 != null && rawAttributes2.Count > 0)
				{
					Log.QueryAttributesNotSupported(mySqlCommand.Logger, mySqlCommand.Connection.Session.Id, mySqlCommand.CommandText);
				}
			}
			WriteQueryPayload(mySqlCommand, cachedProcedures, writer, appendSemicolon, isFirstCommand: true, isLastCommand: true);
			commandListPosition.LastUsedPreparedStatement = null;
			commandListPosition.CommandIndex++;
		}
		else
		{
			writer.Write((byte)23);
			commandListPosition.LastUsedPreparedStatement = commandListPosition.PreparedStatements.Statements[commandListPosition.PreparedStatementIndex];
			WritePreparedStatement(mySqlCommand, commandListPosition.LastUsedPreparedStatement, writer);
			if (++commandListPosition.PreparedStatementIndex == commandListPosition.PreparedStatements.Statements.Count)
			{
				commandListPosition.CommandIndex++;
				commandListPosition.PreparedStatementIndex = 0;
			}
		}
		return true;
	}

	public static bool WriteQueryPayload(IMySqlCommand command, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })] IDictionary<string, CachedProcedure> cachedProcedures, ByteBufferWriter writer, bool appendSemicolon, bool isFirstCommand, bool isLastCommand)
	{
		if (command.CommandType != CommandType.StoredProcedure)
		{
			return WriteCommand(command, writer, appendSemicolon, isFirstCommand, isLastCommand);
		}
		return WriteStoredProcedure(command, cachedProcedures, writer);
	}

	private static void WritePreparedStatement(IMySqlCommand command, PreparedStatement preparedStatement, ByteBufferWriter writer)
	{
		MySqlParameterCollection rawParameters = command.RawParameters;
		Log.PreparingCommandPayloadWithId(command.Logger, command.Connection.Session.Id, preparedStatement.StatementId, command.CommandText);
		MySqlAttributeCollection rawAttributes = command.RawAttributes;
		bool supportsQueryAttributes = command.Connection.Session.SupportsQueryAttributes;
		writer.Write(preparedStatement.StatementId);
		int num;
		if (supportsQueryAttributes)
		{
			Version version = command.Connection.Session.ServerVersion.Version;
			if ((object)version != null && version.Major == 8 && version.Minor == 0)
			{
				int build = version.Build;
				if (build >= 23)
				{
					num = ((build <= 25) ? 1 : 0);
					goto IL_009e;
				}
			}
			num = 0;
			goto IL_009e;
		}
		int num2 = 0;
		goto IL_00a4;
		IL_00a4:
		bool flag = (byte)num2 != 0;
		writer.Write((byte)(flag ? 8u : 0u));
		writer.Write(1);
		int num3 = preparedStatement.Statement.ParameterNames?.Count ?? 0;
		int num4 = rawAttributes?.Count ?? 0;
		if (flag)
		{
			writer.WriteLengthEncodedInteger((uint)(num3 + num4));
		}
		else
		{
			if (supportsQueryAttributes && num3 > 0)
			{
				writer.WriteLengthEncodedInteger((uint)num3);
			}
			if (num4 > 0)
			{
				Log.QueryAttributesNotSupportedWithId(command.Logger, command.Connection.Session.Id, preparedStatement.StatementId);
				num4 = 0;
			}
		}
		if (num3 <= 0 && num4 <= 0)
		{
			return;
		}
		MySqlParameter[] array = new MySqlParameter[num3 + num4];
		for (int i = 0; i < num3; i++)
		{
			string text = preparedStatement.Statement.NormalizedParameterNames[i];
			int num5 = ((text == null) ? preparedStatement.Statement.ParameterIndexes[i] : (rawParameters?.UnsafeIndexOf(text) ?? (-1)));
			if (num5 == -1 && text != null)
			{
				throw new MySqlException("Parameter '" + preparedStatement.Statement.ParameterNames[i] + "' must be defined.");
			}
			if (num5 < 0 || num5 >= (rawParameters?.Count ?? 0))
			{
				throw new MySqlException(string.Format("Parameter index {0} is invalid when only {1} parameter{2} defined.", num5, rawParameters?.Count ?? 0, (rawParameters != null && rawParameters.Count == 1) ? " is" : "s are"));
			}
			array[i] = rawParameters[num5];
		}
		for (int j = 0; j < num4; j++)
		{
			array[num3 + j] = rawAttributes[j].ToParameter();
		}
		WriteBinaryParameters(writer, array, command, supportsQueryAttributes, num3);
		return;
		IL_009e:
		num2 = ((num == 0) ? 1 : 0);
		goto IL_00a4;
	}

	private static void WriteBinaryParameters(ByteBufferWriter writer, MySqlParameter[] parameters, IMySqlCommand command, bool supportsQueryAttributes, int parameterCount)
	{
		byte b = 0;
		for (int i = 0; i < parameters.Length; i++)
		{
			MySqlParameter mySqlParameter = parameters[i];
			if (mySqlParameter.Value == null || mySqlParameter.Value == DBNull.Value)
			{
				b |= (byte)(1 << i % 8);
			}
			if (i % 8 == 7)
			{
				writer.Write(b);
				b = 0;
			}
		}
		if (parameters.Length % 8 != 0)
		{
			writer.Write(b);
		}
		writer.Write((byte)1);
		for (int j = 0; j < parameters.Length; j++)
		{
			MySqlParameter mySqlParameter2 = parameters[j];
			MySqlDbType dbType = mySqlParameter2.MySqlDbType;
			DbTypeMapping dbTypeMapping = ((mySqlParameter2.Value == null || mySqlParameter2.Value == DBNull.Value) ? null : TypeMapper.Instance.GetDbTypeMapping(mySqlParameter2.Value.GetType()));
			if (dbTypeMapping != null)
			{
				DbType dbType2 = dbTypeMapping.DbTypes[0];
				dbType = TypeMapper.Instance.GetMySqlDbTypeForDbType(dbType2);
			}
			writer.Write(TypeMapper.ConvertToColumnTypeAndFlags(dbType, command.Connection.GuidFormat));
			if (supportsQueryAttributes)
			{
				if (j < parameterCount)
				{
					writer.Write((byte)0);
				}
				else
				{
					writer.WriteLengthEncodedString(mySqlParameter2.ParameterName);
				}
			}
		}
		StatementPreparerOptions options = command.CreateStatementPreparerOptions();
		for (int k = 0; k < parameters.Length; k++)
		{
			parameters[k].AppendBinary(writer, options);
		}
	}

	private static bool WriteStoredProcedure(IMySqlCommand command, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(new byte[] { 1, 1, 2 })] IDictionary<string, CachedProcedure> cachedProcedures, ByteBufferWriter writer)
	{
		MySqlParameterCollection mySqlParameterCollection = command.RawParameters;
		CachedProcedure cachedProcedure = cachedProcedures[command.CommandText];
		if (cachedProcedure != null)
		{
			mySqlParameterCollection = cachedProcedure.AlignParamsWithDb(mySqlParameterCollection);
		}
		MySqlParameter mySqlParameter = null;
		MySqlParameterCollection mySqlParameterCollection2 = new MySqlParameterCollection();
		List<string> list = new List<string>();
		MySqlParameterCollection mySqlParameterCollection3 = new MySqlParameterCollection();
		List<string> list2 = new List<string>();
		string text = "";
		for (int i = 0; i < (mySqlParameterCollection?.Count ?? 0); i++)
		{
			MySqlParameter mySqlParameter2 = mySqlParameterCollection[i];
			string text2 = "@inParam" + i;
			string text3 = "@outParam" + i;
			switch (mySqlParameter2.Direction)
			{
			case ParameterDirection.Input:
			case ParameterDirection.InputOutput:
			{
				MySqlParameter parameter = mySqlParameter2.WithParameterName(text2);
				mySqlParameterCollection3.Add(parameter);
				if (mySqlParameter2.Direction == ParameterDirection.InputOutput)
				{
					text = text + "SET " + text3 + "=" + text2 + "; ";
					goto case ParameterDirection.Output;
				}
				list2.Add(text2);
				break;
			}
			case ParameterDirection.Output:
				mySqlParameterCollection2.Add(mySqlParameter2);
				list.Add(text3);
				list2.Add(text3);
				break;
			case ParameterDirection.ReturnValue:
				mySqlParameter = mySqlParameter2;
				break;
			}
		}
		string text4 = command.CommandText + "(" + string.Join(", ", list2) + ");";
		if (mySqlParameter == null)
		{
			text4 = text + "CALL " + text4;
			if (mySqlParameterCollection2.Count > 0 && (command.CommandBehavior & CommandBehavior.SchemaOnly) == 0)
			{
				text4 = text4 + "SELECT '" + OutParameterSentinelColumnName + "' AS '" + OutParameterSentinelColumnName + "', " + string.Join(", ", list);
			}
		}
		else
		{
			text4 = "SELECT " + text4;
		}
		command.OutParameters = mySqlParameterCollection2;
		command.ReturnParameter = mySqlParameter;
		return new StatementPreparer(text4, mySqlParameterCollection3, command.CreateStatementPreparerOptions()).ParseAndBindParameters(writer);
	}

	private static bool WriteCommand(IMySqlCommand command, ByteBufferWriter writer, bool appendSemicolon, bool isFirstCommand, bool isLastCommand)
	{
		bool flag = (command.CommandBehavior & CommandBehavior.SchemaOnly) != 0;
		bool flag2 = (command.CommandBehavior & CommandBehavior.SingleRow) != 0;
		if ((flag || flag2) && isFirstCommand)
		{
			ReadOnlySpan<byte> span = ((!command.Connection.SupportsPerQueryVariables) ? (flag2 ? "SET sql_select_limit=1;\n"u8 : "SET sql_select_limit=0;\n"u8) : (flag2 ? "SET STATEMENT sql_select_limit=1 FOR "u8 : "SET STATEMENT sql_select_limit=0 FOR "u8));
			writer.Write(span);
		}
		bool flag3 = new StatementPreparer(command.CommandText, command.RawParameters, (StatementPreparerOptions)((int)command.CreateStatementPreparerOptions() | ((appendSemicolon || flag || flag2) ? 512 : 0))).ParseAndBindParameters(writer);
		if ((flag || flag2) && isLastCommand && flag3 && !command.Connection.SupportsPerQueryVariables)
		{
			writer.Write("\nSET sql_select_limit=default;"u8);
		}
		return flag3;
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.Core;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal abstract class SqlParser(StatementPreparer preparer)
{
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	[Flags]
	protected enum FinalParseStates
	{
		None = 0,
		Complete = 1,
		NeedsNewline = 2,
		NeedsSemicolon = 4
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private enum State
	{
		Beginning,
		Statement,
		SingleQuotedString,
		SingleQuotedStringBackslash,
		SingleQuotedStringSingleQuote,
		DoubleQuotedString,
		DoubleQuotedStringBackslash,
		DoubleQuotedStringDoubleQuote,
		BacktickQuotedString,
		BacktickQuotedStringBacktick,
		EndOfLineComment,
		Hyphen,
		SecondHyphen,
		ForwardSlash,
		CStyleComment,
		CStyleCommentAsterisk,
		QuestionMark,
		AtSign,
		NamedParameter
	}

	protected StatementPreparer Preparer { get; } = preparer;

	public void Parse(string sql)
	{
		if (sql == null)
		{
			throw new ArgumentNullException("sql");
		}
		OnBeforeParse(sql);
		int num = -1;
		bool flag = (Preparer.Options & StatementPreparerOptions.NoBackslashEscapes) == StatementPreparerOptions.NoBackslashEscapes;
		State state = State.Beginning;
		State state2 = State.Beginning;
		bool flag2 = false;
		for (int i = 0; i < sql.Length; i++)
		{
			char c = sql[i];
			switch (state)
			{
			case State.EndOfLineComment:
				if (c == '\n')
				{
					state = state2;
				}
				break;
			case State.CStyleComment:
				if (c == '*')
				{
					state = State.CStyleCommentAsterisk;
				}
				break;
			case State.CStyleCommentAsterisk:
				state = ((c == '/') ? state2 : State.CStyleComment);
				break;
			case State.SingleQuotedString:
				switch (c)
				{
				case '\'':
					state = State.SingleQuotedStringSingleQuote;
					break;
				case '\\':
					if (!flag)
					{
						state = State.SingleQuotedStringBackslash;
					}
					break;
				}
				break;
			case State.SingleQuotedStringBackslash:
				state = State.SingleQuotedString;
				break;
			case State.DoubleQuotedString:
				switch (c)
				{
				case '"':
					state = State.DoubleQuotedStringDoubleQuote;
					break;
				case '\\':
					if (!flag)
					{
						state = State.DoubleQuotedStringBackslash;
					}
					break;
				}
				break;
			case State.DoubleQuotedStringBackslash:
				state = State.DoubleQuotedString;
				break;
			case State.BacktickQuotedString:
				if (c == '`')
				{
					state = State.BacktickQuotedStringBacktick;
				}
				break;
			case State.SingleQuotedStringSingleQuote:
				if (c == '\'')
				{
					state = State.SingleQuotedString;
					break;
				}
				if (flag2)
				{
					OnNamedParameter(num, i - num);
				}
				if (c == ';')
				{
					OnStatementEnd(i);
					state = State.Beginning;
				}
				else
				{
					state = State.Statement;
				}
				break;
			case State.DoubleQuotedStringDoubleQuote:
				if (c == '"')
				{
					state = State.DoubleQuotedString;
					break;
				}
				if (flag2)
				{
					OnNamedParameter(num, i - num);
				}
				if (c == ';')
				{
					OnStatementEnd(i);
					state = State.Beginning;
				}
				else
				{
					state = State.Statement;
				}
				break;
			case State.BacktickQuotedStringBacktick:
				if (c == '`')
				{
					state = State.BacktickQuotedString;
					break;
				}
				if (flag2)
				{
					OnNamedParameter(num, i - num);
				}
				if (c == ';')
				{
					OnStatementEnd(i);
					state = State.Beginning;
				}
				else
				{
					state = State.Statement;
				}
				break;
			case State.SecondHyphen:
				state = ((c != ' ') ? State.Statement : State.EndOfLineComment);
				break;
			case State.Hyphen:
				state = ((c != '-') ? State.Statement : State.SecondHyphen);
				break;
			case State.ForwardSlash:
				state = ((c != '*') ? State.Statement : State.CStyleComment);
				break;
			case State.QuestionMark:
				if (IsVariableName(c))
				{
					state = State.NamedParameter;
					break;
				}
				OnPositionalParameter(num);
				if (c == ';')
				{
					OnStatementEnd(i);
					state = State.Beginning;
				}
				else
				{
					state = State.Statement;
				}
				break;
			case State.AtSign:
				if (IsVariableName(c))
				{
					state = State.NamedParameter;
					break;
				}
				switch (c)
				{
				case '`':
					state = State.BacktickQuotedString;
					flag2 = true;
					break;
				case '"':
					state = State.DoubleQuotedString;
					flag2 = true;
					break;
				case '\'':
					state = State.SingleQuotedString;
					flag2 = true;
					break;
				default:
					state = State.Statement;
					break;
				}
				break;
			case State.NamedParameter:
				if (!IsVariableName(c))
				{
					OnNamedParameter(num, i - num);
					if (c == ';')
					{
						OnStatementEnd(i);
						state = State.Beginning;
					}
					else
					{
						state = State.Statement;
					}
				}
				break;
			default:
				throw new InvalidOperationException($"Unexpected state: {state}");
			case State.Beginning:
			case State.Statement:
				if (c == '-' && i < sql.Length - 2 && sql[i + 1] == '-' && sql[i + 2] == ' ')
				{
					state2 = state;
					state = State.Hyphen;
					break;
				}
				if (c == '/' && i < sql.Length - 1 && sql[i + 1] == '*')
				{
					state2 = state;
					state = State.ForwardSlash;
					break;
				}
				switch (c)
				{
				case '\'':
					state = State.SingleQuotedString;
					break;
				case '"':
					state = State.DoubleQuotedString;
					break;
				case '`':
					state = State.BacktickQuotedString;
					break;
				case '?':
					state = State.QuestionMark;
					num = i;
					break;
				case '@':
					state = State.AtSign;
					num = i;
					break;
				case '#':
					state2 = state;
					state = State.EndOfLineComment;
					break;
				case ';':
					if (state != 0)
					{
						OnStatementEnd(i);
					}
					state = State.Beginning;
					break;
				default:
					if (!IsWhitespace(c) && state == State.Beginning)
					{
						state = State.Statement;
						OnStatementBegin(i);
					}
					break;
				}
				break;
			}
		}
		FinalParseStates finalParseStates = FinalParseStates.None;
		if (state == State.NamedParameter)
		{
			OnNamedParameter(num, sql.Length - num);
			state = State.Statement;
		}
		else if (state == State.QuestionMark)
		{
			OnPositionalParameter(num);
			state = State.Statement;
		}
		else if (state == State.EndOfLineComment)
		{
			finalParseStates |= FinalParseStates.NeedsNewline;
			state = state2;
		}
		else if ((state == State.SingleQuotedStringSingleQuote || state == State.DoubleQuotedStringDoubleQuote || state == State.BacktickQuotedStringBacktick) ? true : false)
		{
			state = State.Statement;
		}
		if (state == State.Statement)
		{
			OnStatementEnd(sql.Length);
			finalParseStates |= FinalParseStates.NeedsSemicolon;
			state = State.Beginning;
		}
		if (state == State.Beginning)
		{
			finalParseStates |= FinalParseStates.Complete;
		}
		OnParsed(finalParseStates);
	}

	protected virtual void OnBeforeParse(string sql)
	{
	}

	protected virtual void OnStatementBegin(int index)
	{
	}

	protected virtual void OnPositionalParameter(int index)
	{
	}

	protected virtual void OnNamedParameter(int index, int length)
	{
	}

	protected virtual void OnStatementEnd(int index)
	{
	}

	protected virtual void OnParsed(FinalParseStates states)
	{
	}

	private static bool IsWhitespace(char ch)
	{
		switch (ch)
		{
		case '\t':
		case '\n':
		case '\r':
		case ' ':
			return true;
		default:
			return false;
		}
	}

	private static bool IsVariableName(char ch)
	{
		if (ch >= 'a')
		{
			if (ch <= 'z' || ch >= '\u0080')
			{
				goto IL_003b;
			}
		}
		else if (ch >= 'A')
		{
			if (ch <= 'Z' || ch == '_')
			{
				goto IL_003b;
			}
		}
		else if (ch >= '0')
		{
			if (ch <= '9')
			{
				goto IL_003b;
			}
		}
		else if (ch == '$' || ch == '.')
		{
			goto IL_003b;
		}
		return false;
		IL_003b:
		return true;
	}
}


using System;
using System.Runtime.CompilerServices;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
[Flags]
protected enum FinalParseStates
{
	None = 0,
	Complete = 1,
	NeedsNewline = 2,
	NeedsSemicolon = 4
}


using System.Runtime.CompilerServices;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
private enum State
{
	Beginning,
	Statement,
	SingleQuotedString,
	SingleQuotedStringBackslash,
	SingleQuotedStringSingleQuote,
	DoubleQuotedString,
	DoubleQuotedStringBackslash,
	DoubleQuotedStringDoubleQuote,
	BacktickQuotedString,
	BacktickQuotedStringBacktick,
	EndOfLineComment,
	Hyphen,
	SecondHyphen,
	ForwardSlash,
	CStyleComment,
	CStyleCommentAsterisk,
	QuestionMark,
	AtSign,
	NamedParameter
}


using System;
using System.Runtime.CompilerServices;
using System.Transactions;
using MySqlConnector;
using MySqlConnector.Core;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class StandardEnlistedTransaction : EnlistedTransactionBase
{
	public StandardEnlistedTransaction(Transaction transaction, MySqlConnection connection)
		: base(transaction, connection)
	{
	}

	protected override void OnStart()
	{
		using MySqlCommand mySqlCommand = new MySqlCommand("set session transaction isolation level " + base.Transaction.IsolationLevel switch
		{
			IsolationLevel.Serializable => "serializable", 
			IsolationLevel.ReadCommitted => "read committed", 
			IsolationLevel.ReadUncommitted => "read uncommitted", 
			IsolationLevel.RepeatableRead => "repeatable read", 
			IsolationLevel.Snapshot => "repeatable read", 
			IsolationLevel.Chaos => throw new NotSupportedException($"IsolationLevel.{base.Transaction.IsolationLevel} is not supported."), 
			IsolationLevel.Unspecified => "repeatable read", 
			_ => "repeatable read", 
		} + ";", base.Connection);
		mySqlCommand.ExecuteNonQuery();
		string text = ((base.Transaction.IsolationLevel == IsolationLevel.Snapshot) ? " with consistent snapshot" : "");
		mySqlCommand.CommandText = "start transaction" + text + ";";
		mySqlCommand.ExecuteNonQuery();
	}

	protected override void OnPrepare(PreparingEnlistment enlistment)
	{
	}

	protected override void OnCommit(Enlistment enlistment)
	{
		using MySqlCommand mySqlCommand = new MySqlCommand("commit;", base.Connection);
		mySqlCommand.ExecuteNonQuery();
	}

	protected override void OnRollback(Enlistment enlistment)
	{
		using MySqlCommand mySqlCommand = new MySqlCommand("rollback;", base.Connection);
		mySqlCommand.ExecuteNonQuery();
	}
}


