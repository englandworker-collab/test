using System.Collections.Generic;
using System.Data;
using System.Runtime.CompilerServices;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class StatementPreparer
{
	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private sealed class ParameterSqlParser : SqlParser
	{
		private int m_currentParameterIndex;

		private int m_lastIndex;

		public bool IsComplete { get; private set; }

		private ByteBufferWriter Writer { get; }

		public ParameterSqlParser(StatementPreparer preparer, ByteBufferWriter writer)
		{
			Writer = writer;
			base..ctor(preparer);
		}

		protected override void OnNamedParameter(int index, int length)
		{
			int parameterIndex = base.Preparer.GetParameterIndex(base.Preparer.CommandText.Substring(index, length));
			if (parameterIndex != -1)
			{
				DoAppendParameter(parameterIndex, index, length);
			}
		}

		protected override void OnPositionalParameter(int index)
		{
			DoAppendParameter(m_currentParameterIndex, index, 1);
			m_currentParameterIndex++;
		}

		private void DoAppendParameter(int parameterIndex, int textIndex, int textLength)
		{
			Writer.Write(base.Preparer.CommandText, m_lastIndex, textIndex - m_lastIndex);
			base.Preparer.GetInputParameter(parameterIndex).AppendSqlString(Writer, base.Preparer.Options);
			m_lastIndex = textIndex + textLength;
		}

		protected override void OnParsed(FinalParseStates states)
		{
			Writer.Write(base.Preparer.CommandText, m_lastIndex, base.Preparer.CommandText.Length - m_lastIndex);
			if ((states & FinalParseStates.NeedsNewline) == FinalParseStates.NeedsNewline)
			{
				Writer.Write((byte)10);
			}
			if ((states & FinalParseStates.NeedsSemicolon) == FinalParseStates.NeedsSemicolon && (base.Preparer.Options & StatementPreparerOptions.AppendSemicolon) == StatementPreparerOptions.AppendSemicolon)
			{
				Writer.Write((byte)59);
			}
			IsComplete = (states & FinalParseStates.Complete) == FinalParseStates.Complete;
		}
	}

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
	private sealed class PreparedCommandSqlParser : SqlParser
	{
		private int m_currentParameterIndex;

		private int m_lastIndex;

		private List<ParsedStatement> Statements { get; }

		private List<int> StatementStartEndIndexes { get; }

		private ByteBufferWriter Writer { get; }

		public PreparedCommandSqlParser(StatementPreparer preparer, List<ParsedStatement> statements, List<int> statementStartEndIndexes, ByteBufferWriter writer)
		{
			Statements = statements;
			StatementStartEndIndexes = statementStartEndIndexes;
			Writer = writer;
			base..ctor(preparer);
		}

		protected override void OnStatementBegin(int index)
		{
			Statements.Add(new ParsedStatement());
			StatementStartEndIndexes.Add(Writer.Position);
			Writer.Write((byte)22);
			m_lastIndex = index;
		}

		protected override void OnNamedParameter(int index, int length)
		{
			string parameterName = base.Preparer.CommandText.Substring(index, length);
			DoAppendParameter(parameterName, -1, index, length);
		}

		protected override void OnPositionalParameter(int index)
		{
			DoAppendParameter(null, m_currentParameterIndex, index, 1);
			m_currentParameterIndex++;
		}

		[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
		private void DoAppendParameter(string parameterName, int parameterIndex, int textIndex, int textLength)
		{
			Writer.Write(base.Preparer.CommandText, m_lastIndex, textIndex - m_lastIndex);
			m_lastIndex = textIndex + textLength;
			Writer.Write((byte)63);
			List<ParsedStatement> statements = Statements;
			statements[statements.Count - 1].ParameterNames.Add(parameterName);
			List<ParsedStatement> statements2 = Statements;
			statements2[statements2.Count - 1].NormalizedParameterNames.Add((parameterName == null) ? null : MySqlParameter.NormalizeParameterName(parameterName));
			List<ParsedStatement> statements3 = Statements;
			statements3[statements3.Count - 1].ParameterIndexes.Add(parameterIndex);
		}

		protected override void OnStatementEnd(int index)
		{
			Writer.Write(base.Preparer.CommandText, m_lastIndex, index - m_lastIndex);
			m_lastIndex = index;
			StatementStartEndIndexes.Add(Writer.Position);
		}
	}

	public StatementPreparerOptions Options { get; }

	private string CommandText { get; }

	public StatementPreparer(string commandText, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)] MySqlParameterCollection parameters, StatementPreparerOptions options)
	{
		Options = options;
		CommandText = commandText;
		base..ctor();
	}

	public ParsedStatements SplitStatements()
	{
		List<ParsedStatement> list = new List<ParsedStatement>();
		List<int> list2 = new List<int>();
		ByteBufferWriter byteBufferWriter = new ByteBufferWriter(CommandText.Length + 1);
		new PreparedCommandSqlParser(this, list, list2, byteBufferWriter).Parse(CommandText);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].StatementBytes = Utility.Slice(byteBufferWriter.ArraySegment, list2[i * 2], list2[i * 2 + 1] - list2[i * 2]);
		}
		return new ParsedStatements(list, byteBufferWriter.ToPayloadData());
	}

	public bool ParseAndBindParameters(ByteBufferWriter writer)
	{
		if (!string.IsNullOrWhiteSpace(CommandText))
		{
			ParameterSqlParser parameterSqlParser = new ParameterSqlParser(this, writer);
			parameterSqlParser.Parse(CommandText);
			return parameterSqlParser.IsComplete;
		}
		return true;
	}

	private int GetParameterIndex(string name)
	{
		int num = parameters?.NormalizedIndexOf(name) ?? (-1);
		if (num == -1 && (Options & StatementPreparerOptions.AllowUserVariables) == 0)
		{
			throw new MySqlException("Parameter '" + name + "' must be defined. To use this as a variable, set 'Allow User Variables=true' in the connection string.");
		}
		return num;
	}

	private MySqlParameter GetInputParameter(int index)
	{
		if (index >= (parameters?.Count ?? 0))
		{
			object arg = index;
			object arg2 = parameters?.Count ?? 0;
			MySqlParameterCollection mySqlParameterCollection = parameters;
			throw new MySqlException(string.Format("Parameter index {0} is invalid when only {1} parameter{2} defined.", arg, arg2, (mySqlParameterCollection != null && mySqlParameterCollection.Count == 1) ? " is" : "s are"));
		}
		MySqlParameter mySqlParameter = parameters[index];
		if (mySqlParameter.Direction != ParameterDirection.Input && (Options & StatementPreparerOptions.AllowOutputParameters) == 0)
		{
			throw new MySqlException("Only ParameterDirection.Input is supported when CommandType is Text (parameter name: " + mySqlParameter.ParameterName + ")");
		}
		return mySqlParameter;
	}
}


using System.Runtime.CompilerServices;
using MySqlConnector.Protocol.Serialization;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
private sealed class ParameterSqlParser : SqlParser
{
	private int m_currentParameterIndex;

	private int m_lastIndex;

	public bool IsComplete { get; private set; }

	private ByteBufferWriter Writer { get; }

	public ParameterSqlParser(StatementPreparer preparer, ByteBufferWriter writer)
	{
		Writer = writer;
		base..ctor(preparer);
	}

	protected override void OnNamedParameter(int index, int length)
	{
		int parameterIndex = base.Preparer.GetParameterIndex(base.Preparer.CommandText.Substring(index, length));
		if (parameterIndex != -1)
		{
			DoAppendParameter(parameterIndex, index, length);
		}
	}

	protected override void OnPositionalParameter(int index)
	{
		DoAppendParameter(m_currentParameterIndex, index, 1);
		m_currentParameterIndex++;
	}

	private void DoAppendParameter(int parameterIndex, int textIndex, int textLength)
	{
		Writer.Write(base.Preparer.CommandText, m_lastIndex, textIndex - m_lastIndex);
		base.Preparer.GetInputParameter(parameterIndex).AppendSqlString(Writer, base.Preparer.Options);
		m_lastIndex = textIndex + textLength;
	}

	protected override void OnParsed(FinalParseStates states)
	{
		Writer.Write(base.Preparer.CommandText, m_lastIndex, base.Preparer.CommandText.Length - m_lastIndex);
		if ((states & FinalParseStates.NeedsNewline) == FinalParseStates.NeedsNewline)
		{
			Writer.Write((byte)10);
		}
		if ((states & FinalParseStates.NeedsSemicolon) == FinalParseStates.NeedsSemicolon && (base.Preparer.Options & StatementPreparerOptions.AppendSemicolon) == StatementPreparerOptions.AppendSemicolon)
		{
			Writer.Write((byte)59);
		}
		IsComplete = (states & FinalParseStates.Complete) == FinalParseStates.Complete;
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;
using MySqlConnector.Protocol.Serialization;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
private sealed class PreparedCommandSqlParser : SqlParser
{
	private int m_currentParameterIndex;

	private int m_lastIndex;

	private List<ParsedStatement> Statements { get; }

	private List<int> StatementStartEndIndexes { get; }

	private ByteBufferWriter Writer { get; }

	public PreparedCommandSqlParser(StatementPreparer preparer, List<ParsedStatement> statements, List<int> statementStartEndIndexes, ByteBufferWriter writer)
	{
		Statements = statements;
		StatementStartEndIndexes = statementStartEndIndexes;
		Writer = writer;
		base..ctor(preparer);
	}

	protected override void OnStatementBegin(int index)
	{
		Statements.Add(new ParsedStatement());
		StatementStartEndIndexes.Add(Writer.Position);
		Writer.Write((byte)22);
		m_lastIndex = index;
	}

	protected override void OnNamedParameter(int index, int length)
	{
		string parameterName = base.Preparer.CommandText.Substring(index, length);
		DoAppendParameter(parameterName, -1, index, length);
	}

	protected override void OnPositionalParameter(int index)
	{
		DoAppendParameter(null, m_currentParameterIndex, index, 1);
		m_currentParameterIndex++;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	private void DoAppendParameter(string parameterName, int parameterIndex, int textIndex, int textLength)
	{
		Writer.Write(base.Preparer.CommandText, m_lastIndex, textIndex - m_lastIndex);
		m_lastIndex = textIndex + textLength;
		Writer.Write((byte)63);
		List<ParsedStatement> statements = Statements;
		statements[statements.Count - 1].ParameterNames.Add(parameterName);
		List<ParsedStatement> statements2 = Statements;
		statements2[statements2.Count - 1].NormalizedParameterNames.Add((parameterName == null) ? null : MySqlParameter.NormalizeParameterName(parameterName));
		List<ParsedStatement> statements3 = Statements;
		statements3[statements3.Count - 1].ParameterIndexes.Add(parameterIndex);
	}

	protected override void OnStatementEnd(int index)
	{
		Writer.Write(base.Preparer.CommandText, m_lastIndex, index - m_lastIndex);
		m_lastIndex = index;
		StatementStartEndIndexes.Add(Writer.Position);
	}
}


using System;

[Flags]
internal enum StatementPreparerOptions
{
	None = 0,
	AllowUserVariables = 1,
	AllowOutputParameters = 4,
	DateTimeUtc = 8,
	DateTimeLocal = 0x10,
	GuidFormatChar36 = 0x20,
	GuidFormatChar32 = 0x40,
	GuidFormatBinary16 = 0x60,
	GuidFormatTimeSwapBinary16 = 0x80,
	GuidFormatLittleEndianBinary16 = 0xA0,
	GuidFormatMask = 0xE0,
	NoBackslashEscapes = 0x100,
	AppendSemicolon = 0x200
}


using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector;
using MySqlConnector.Core;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class TypeMapper
{
	private readonly List<ColumnTypeMetadata> m_columnTypeMetadata;

	private readonly Dictionary<Type, DbTypeMapping> m_dbTypeMappingsByClrType;

	private readonly Dictionary<DbType, DbTypeMapping> m_dbTypeMappingsByDbType;

	private readonly Dictionary<string, ColumnTypeMetadata> m_columnTypeMetadataLookup;

	private readonly Dictionary<MySqlDbType, ColumnTypeMetadata> m_mySqlDbTypeToColumnTypeMetadata;

	public static TypeMapper Instance { get; } = new TypeMapper();

	private TypeMapper()
	{
		m_columnTypeMetadata = new List<ColumnTypeMetadata>();
		m_dbTypeMappingsByClrType = new Dictionary<Type, DbTypeMapping>();
		m_dbTypeMappingsByDbType = new Dictionary<DbType, DbTypeMapping>();
		m_columnTypeMetadataLookup = new Dictionary<string, ColumnTypeMetadata>(StringComparer.OrdinalIgnoreCase);
		m_mySqlDbTypeToColumnTypeMetadata = new Dictionary<MySqlDbType, ColumnTypeMetadata>();
		DbTypeMapping dbTypeMapping = AddDbTypeMapping(new DbTypeMapping(typeof(bool), new DbType[1] { DbType.Boolean }, (object o) => Convert.ToBoolean(o, CultureInfo.InvariantCulture)));
		AddColumnTypeMetadata(new ColumnTypeMetadata("TINYINT", dbTypeMapping, MySqlDbType.Bool, isUnsigned: false, binary: false, 1, "BOOL", "BOOL", 1L));
		DbTypeMapping dbTypeMapping2 = AddDbTypeMapping(new DbTypeMapping(typeof(sbyte), new DbType[1] { DbType.SByte }, (object o) => Convert.ToSByte(o, CultureInfo.InvariantCulture)));
		DbTypeMapping dbTypeMapping3 = AddDbTypeMapping(new DbTypeMapping(typeof(byte), new DbType[1] { DbType.Byte }, (object o) => Convert.ToByte(o, CultureInfo.InvariantCulture)));
		DbTypeMapping dbTypeMapping4 = AddDbTypeMapping(new DbTypeMapping(typeof(short), new DbType[1] { DbType.Int16 }, (object o) => Convert.ToInt16(o, CultureInfo.InvariantCulture)));
		DbTypeMapping dbTypeMapping5 = AddDbTypeMapping(new DbTypeMapping(typeof(ushort), new DbType[1] { DbType.UInt16 }, (object o) => Convert.ToUInt16(o, CultureInfo.InvariantCulture)));
		DbTypeMapping dbTypeMapping6 = AddDbTypeMapping(new DbTypeMapping(typeof(int), new DbType[1] { DbType.Int32 }, (object o) => Convert.ToInt32(o, CultureInfo.InvariantCulture)));
		DbTypeMapping dbTypeMapping7 = AddDbTypeMapping(new DbTypeMapping(typeof(uint), new DbType[1] { DbType.UInt32 }, (object o) => Convert.ToUInt32(o, CultureInfo.InvariantCulture)));
		DbTypeMapping dbTypeMapping8 = AddDbTypeMapping(new DbTypeMapping(typeof(long), new DbType[1] { DbType.Int64 }, (object o) => Convert.ToInt64(o, CultureInfo.InvariantCulture)));
		DbTypeMapping dbTypeMapping9 = AddDbTypeMapping(new DbTypeMapping(typeof(ulong), new DbType[1] { DbType.UInt64 }, (object o) => Convert.ToUInt64(o, CultureInfo.InvariantCulture)));
		AddColumnTypeMetadata(new ColumnTypeMetadata("TINYINT", dbTypeMapping2, MySqlDbType.Byte, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("TINYINT", dbTypeMapping3, MySqlDbType.UByte, isUnsigned: true, binary: false, 1, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("TINYINT", dbTypeMapping3, MySqlDbType.UByte, isUnsigned: true, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("SMALLINT", dbTypeMapping4, MySqlDbType.Int16, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("SMALLINT", dbTypeMapping5, MySqlDbType.UInt16, isUnsigned: true, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("INT", dbTypeMapping6, MySqlDbType.Int32, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("INT", dbTypeMapping7, MySqlDbType.UInt32, isUnsigned: true, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("MEDIUMINT", dbTypeMapping6, MySqlDbType.Int24, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("MEDIUMINT", dbTypeMapping7, MySqlDbType.UInt24, isUnsigned: true, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("BIGINT", dbTypeMapping8, MySqlDbType.Int64, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("BIGINT", dbTypeMapping9, MySqlDbType.UInt64, isUnsigned: true, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("BIT", dbTypeMapping9, MySqlDbType.Bit, isUnsigned: false, binary: false, 0, null, null, 0L));
		DbTypeMapping dbTypeMapping10 = AddDbTypeMapping(new DbTypeMapping(typeof(decimal), new DbType[3]
		{
			DbType.Decimal,
			DbType.Currency,
			DbType.VarNumeric
		}, (object o) => Convert.ToDecimal(o, CultureInfo.InvariantCulture)));
		DbTypeMapping dbTypeMapping11 = AddDbTypeMapping(new DbTypeMapping(typeof(double), new DbType[1] { DbType.Double }, (object o) => Convert.ToDouble(o, CultureInfo.InvariantCulture)));
		DbTypeMapping dbTypeMapping12 = AddDbTypeMapping(new DbTypeMapping(typeof(float), new DbType[1] { DbType.Single }, (object o) => Convert.ToSingle(o, CultureInfo.InvariantCulture)));
		AddColumnTypeMetadata(new ColumnTypeMetadata("DECIMAL", dbTypeMapping10, MySqlDbType.NewDecimal, isUnsigned: false, binary: false, 0, null, "DECIMAL({0},{1});precision,scale", 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("DECIMAL", dbTypeMapping10, MySqlDbType.NewDecimal, isUnsigned: true, binary: false, 0, null, "DECIMAL({0},{1}) UNSIGNED;precision,scale", 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("DECIMAL", dbTypeMapping10, MySqlDbType.Decimal, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("DOUBLE", dbTypeMapping11, MySqlDbType.Double, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("FLOAT", dbTypeMapping12, MySqlDbType.Float, isUnsigned: false, binary: false, 0, null, null, 0L));
		DbTypeMapping dbTypeMapping13 = AddDbTypeMapping(new DbTypeMapping(typeof(string), new DbType[2]
		{
			DbType.StringFixedLength,
			DbType.AnsiStringFixedLength
		}, Convert.ToString));
		DbTypeMapping dbTypeMapping14 = AddDbTypeMapping(new DbTypeMapping(typeof(string), new DbType[3]
		{
			DbType.String,
			DbType.AnsiString,
			DbType.Xml
		}, Convert.ToString));
		AddColumnTypeMetadata(new ColumnTypeMetadata("VARCHAR", dbTypeMapping14, MySqlDbType.VarChar, isUnsigned: false, binary: false, 0, null, "VARCHAR({0});size", 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("VARCHAR", dbTypeMapping14, MySqlDbType.VarString, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("CHAR", dbTypeMapping13, MySqlDbType.String, isUnsigned: false, binary: false, 0, null, "CHAR({0});size", 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("TINYTEXT", dbTypeMapping14, MySqlDbType.TinyText, isUnsigned: false, binary: false, 0, "VARCHAR", null, 255L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("TEXT", dbTypeMapping14, MySqlDbType.Text, isUnsigned: false, binary: false, 0, "VARCHAR", null, 65535L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("MEDIUMTEXT", dbTypeMapping14, MySqlDbType.MediumText, isUnsigned: false, binary: false, 0, "VARCHAR", null, 16777215L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("LONGTEXT", dbTypeMapping14, MySqlDbType.LongText, isUnsigned: false, binary: false, 0, "VARCHAR", null, 4294967295L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("ENUM", dbTypeMapping14, MySqlDbType.Enum, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("SET", dbTypeMapping14, MySqlDbType.Set, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("JSON", dbTypeMapping14, MySqlDbType.JSON, isUnsigned: false, binary: false, 0, null, null, 0L));
		DbTypeMapping dbTypeMapping15 = AddDbTypeMapping(new DbTypeMapping(typeof(byte[]), new DbType[1] { DbType.Binary }));
		AddColumnTypeMetadata(new ColumnTypeMetadata("BLOB", dbTypeMapping15, MySqlDbType.Blob, isUnsigned: false, binary: true, 0, "BLOB", null, 65535L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("BINARY", dbTypeMapping15, MySqlDbType.Binary, isUnsigned: false, binary: true, 0, "BLOB", "BINARY({0});length", 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("VARBINARY", dbTypeMapping15, MySqlDbType.VarBinary, isUnsigned: false, binary: true, 0, "BLOB", "VARBINARY({0});length", 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("TINYBLOB", dbTypeMapping15, MySqlDbType.TinyBlob, isUnsigned: false, binary: true, 0, "BLOB", null, 255L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("MEDIUMBLOB", dbTypeMapping15, MySqlDbType.MediumBlob, isUnsigned: false, binary: true, 0, "BLOB", null, 16777215L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("LONGBLOB", dbTypeMapping15, MySqlDbType.LongBlob, isUnsigned: false, binary: true, 0, "BLOB", null, 4294967295L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("GEOMETRY", dbTypeMapping15, MySqlDbType.Geometry, isUnsigned: false, binary: true, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("POINT", dbTypeMapping15, MySqlDbType.Geometry, isUnsigned: false, binary: true, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("LINESTRING", dbTypeMapping15, MySqlDbType.Geometry, isUnsigned: false, binary: true, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("POLYGON", dbTypeMapping15, MySqlDbType.Geometry, isUnsigned: false, binary: true, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("MULTIPOINT", dbTypeMapping15, MySqlDbType.Geometry, isUnsigned: false, binary: true, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("MULTILINESTRING", dbTypeMapping15, MySqlDbType.Geometry, isUnsigned: false, binary: true, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("MULTIPOLYGON", dbTypeMapping15, MySqlDbType.Geometry, isUnsigned: false, binary: true, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("GEOMETRYCOLLECTION", dbTypeMapping15, MySqlDbType.Geometry, isUnsigned: false, binary: true, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("GEOMCOLLECTION", dbTypeMapping15, MySqlDbType.Geometry, isUnsigned: false, binary: true, 0, null, null, 0L));
		DbTypeMapping dbTypeMapping16 = AddDbTypeMapping(new DbTypeMapping(typeof(DateTime), new DbType[1] { DbType.Date }));
		DbTypeMapping dbTypeMapping17 = AddDbTypeMapping(new DbTypeMapping(typeof(DateTime), new DbType[3]
		{
			DbType.DateTime,
			DbType.DateTime2,
			DbType.DateTimeOffset
		}));
		AddDbTypeMapping(new DbTypeMapping(typeof(DateTimeOffset), new DbType[1] { DbType.DateTimeOffset }));
		DbTypeMapping dbTypeMapping18 = AddDbTypeMapping(new DbTypeMapping(typeof(TimeSpan), new DbType[1] { DbType.Time }, (object o) => (!(o is string s)) ? Convert.ChangeType(o, typeof(TimeSpan), CultureInfo.InvariantCulture) : ((object)Utility.ParseTimeSpan(Encoding.UTF8.GetBytes(s)))));
		AddColumnTypeMetadata(new ColumnTypeMetadata("DATETIME", dbTypeMapping17, MySqlDbType.DateTime, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("DATE", dbTypeMapping16, MySqlDbType.Date, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("DATE", dbTypeMapping16, MySqlDbType.Newdate, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("TIME", dbTypeMapping18, MySqlDbType.Time, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("TIMESTAMP", dbTypeMapping17, MySqlDbType.Timestamp, isUnsigned: false, binary: false, 0, null, null, 0L));
		AddColumnTypeMetadata(new ColumnTypeMetadata("YEAR", dbTypeMapping6, MySqlDbType.Year, isUnsigned: false, binary: false, 0, null, null, 0L));
		Func<object, object> convert = (object o) => Guid.Parse(Convert.ToString(o, CultureInfo.InvariantCulture));
		DbTypeMapping dbTypeMapping19 = AddDbTypeMapping(new DbTypeMapping(typeof(Guid), new DbType[1] { DbType.Guid }, convert));
		AddColumnTypeMetadata(new ColumnTypeMetadata("CHAR", dbTypeMapping19, MySqlDbType.Guid, isUnsigned: false, binary: false, 36, "CHAR(36)", "CHAR(36)", 0L));
		DbTypeMapping dbTypeMapping20 = AddDbTypeMapping(new DbTypeMapping(typeof(object), new DbType[1] { DbType.Object }));
		AddColumnTypeMetadata(new ColumnTypeMetadata("NULL", dbTypeMapping20, MySqlDbType.Null, isUnsigned: false, binary: false, 0, null, null, 0L));
	}

	public IReadOnlyList<ColumnTypeMetadata> GetColumnTypeMetadata()
	{
		return m_columnTypeMetadata.AsReadOnly();
	}

	public ColumnTypeMetadata GetColumnTypeMetadata(MySqlDbType mySqlDbType)
	{
		return m_mySqlDbTypeToColumnTypeMetadata[mySqlDbType];
	}

	public DbType GetDbTypeForMySqlDbType(MySqlDbType mySqlDbType)
	{
		return m_mySqlDbTypeToColumnTypeMetadata[mySqlDbType].DbTypeMapping.DbTypes[0];
	}

	public MySqlDbType GetMySqlDbTypeForDbType(DbType dbType)
	{
		foreach (KeyValuePair<MySqlDbType, ColumnTypeMetadata> mySqlDbTypeToColumnTypeMetadatum in m_mySqlDbTypeToColumnTypeMetadata)
		{
			if (mySqlDbTypeToColumnTypeMetadatum.Value.DbTypeMapping.DbTypes.Contains(dbType))
			{
				return mySqlDbTypeToColumnTypeMetadatum.Key;
			}
		}
		return MySqlDbType.VarChar;
	}

	private DbTypeMapping AddDbTypeMapping(DbTypeMapping dbTypeMapping)
	{
		m_dbTypeMappingsByClrType[dbTypeMapping.ClrType] = dbTypeMapping;
		if (dbTypeMapping.DbTypes != null)
		{
			DbType[] dbTypes = dbTypeMapping.DbTypes;
			foreach (DbType key in dbTypes)
			{
				m_dbTypeMappingsByDbType[key] = dbTypeMapping;
			}
		}
		return dbTypeMapping;
	}

	private void AddColumnTypeMetadata(ColumnTypeMetadata columnTypeMetadata)
	{
		m_columnTypeMetadata.Add(columnTypeMetadata);
		string key = columnTypeMetadata.CreateLookupKey();
		if (!m_columnTypeMetadataLookup.ContainsKey(key))
		{
			m_columnTypeMetadataLookup.Add(key, columnTypeMetadata);
		}
		if (!m_mySqlDbTypeToColumnTypeMetadata.ContainsKey(columnTypeMetadata.MySqlDbType))
		{
			m_mySqlDbTypeToColumnTypeMetadata.Add(columnTypeMetadata.MySqlDbType, columnTypeMetadata);
		}
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	internal DbTypeMapping GetDbTypeMapping(Type clrType)
	{
		if (clrType.IsEnum)
		{
			clrType = Enum.GetUnderlyingType(clrType);
		}
		m_dbTypeMappingsByClrType.TryGetValue(clrType, out var value);
		return value;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(2)]
	internal DbTypeMapping GetDbTypeMapping(DbType dbType)
	{
		m_dbTypeMappingsByDbType.TryGetValue(dbType, out var value);
		return value;
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	public DbTypeMapping GetDbTypeMapping(string columnTypeName, bool unsigned = false, int length = 0)
	{
		return GetColumnTypeMetadata(columnTypeName, unsigned, length)?.DbTypeMapping;
	}

	public MySqlDbType GetMySqlDbType(string typeName, bool unsigned, int length)
	{
		return GetColumnTypeMetadata(typeName, unsigned, length).MySqlDbType;
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private ColumnTypeMetadata GetColumnTypeMetadata(string columnTypeName, bool unsigned, int length)
	{
		if (!m_columnTypeMetadataLookup.TryGetValue(ColumnTypeMetadata.CreateLookupKey(columnTypeName, unsigned, length), out var value) && length != 0)
		{
			m_columnTypeMetadataLookup.TryGetValue(ColumnTypeMetadata.CreateLookupKey(columnTypeName, unsigned, 0), out value);
		}
		return value;
	}

	public static MySqlDbType ConvertToMySqlDbType(ColumnDefinitionPayload columnDefinition, bool treatTinyAsBoolean, MySqlGuidFormat guidFormat)
	{
		bool flag = (columnDefinition.ColumnFlags & ColumnFlags.Unsigned) != 0;
		switch (columnDefinition.ColumnType)
		{
		case ColumnType.Tiny:
			if (!treatTinyAsBoolean || columnDefinition.ColumnLength != 1 || flag)
			{
				if (!flag)
				{
					return MySqlDbType.Byte;
				}
				return MySqlDbType.UByte;
			}
			return MySqlDbType.Bool;
		case ColumnType.Int24:
			if (!flag)
			{
				return MySqlDbType.Int24;
			}
			return MySqlDbType.UInt24;
		case ColumnType.Long:
			if (!flag)
			{
				return MySqlDbType.Int32;
			}
			return MySqlDbType.UInt32;
		case ColumnType.Longlong:
			if (!flag)
			{
				return MySqlDbType.Int64;
			}
			return MySqlDbType.UInt64;
		case ColumnType.Bit:
			return MySqlDbType.Bit;
		case ColumnType.String:
			if (guidFormat == MySqlGuidFormat.Char36 && columnDefinition.ColumnLength / ProtocolUtility.GetBytesPerCharacter(columnDefinition.CharacterSet) == 36)
			{
				return MySqlDbType.Guid;
			}
			if (guidFormat == MySqlGuidFormat.Char32 && columnDefinition.ColumnLength / ProtocolUtility.GetBytesPerCharacter(columnDefinition.CharacterSet) == 32)
			{
				return MySqlDbType.Guid;
			}
			if ((columnDefinition.ColumnFlags & ColumnFlags.Enum) != 0)
			{
				return MySqlDbType.Enum;
			}
			if ((columnDefinition.ColumnFlags & ColumnFlags.Set) != 0)
			{
				return MySqlDbType.Set;
			}
			goto case ColumnType.VarChar;
		case ColumnType.VarChar:
		case ColumnType.TinyBlob:
		case ColumnType.MediumBlob:
		case ColumnType.LongBlob:
		case ColumnType.Blob:
		case ColumnType.VarString:
		{
			ColumnType columnType = columnDefinition.ColumnType;
			if (columnDefinition.CharacterSet == CharacterSet.Binary)
			{
				bool flag2 = (uint)(guidFormat - 4) <= 2u;
				if (flag2 && columnDefinition.ColumnLength == 16)
				{
					return MySqlDbType.Guid;
				}
				return columnType switch
				{
					ColumnType.String => MySqlDbType.Binary, 
					ColumnType.VarString => MySqlDbType.VarBinary, 
					ColumnType.TinyBlob => MySqlDbType.TinyBlob, 
					ColumnType.Blob => MySqlDbType.Blob, 
					ColumnType.MediumBlob => MySqlDbType.MediumBlob, 
					_ => MySqlDbType.LongBlob, 
				};
			}
			return columnType switch
			{
				ColumnType.String => MySqlDbType.String, 
				ColumnType.VarString => MySqlDbType.VarChar, 
				ColumnType.TinyBlob => MySqlDbType.TinyText, 
				ColumnType.Blob => MySqlDbType.Text, 
				ColumnType.MediumBlob => MySqlDbType.MediumText, 
				_ => MySqlDbType.LongText, 
			};
		}
		case ColumnType.Json:
			return MySqlDbType.JSON;
		case ColumnType.Short:
			if (!flag)
			{
				return MySqlDbType.Int16;
			}
			return MySqlDbType.UInt16;
		case ColumnType.Date:
		case ColumnType.NewDate:
			return MySqlDbType.Date;
		case ColumnType.DateTime:
			return MySqlDbType.DateTime;
		case ColumnType.Timestamp:
			return MySqlDbType.Timestamp;
		case ColumnType.Time:
			return MySqlDbType.Time;
		case ColumnType.Year:
			return MySqlDbType.Year;
		case ColumnType.Float:
			return MySqlDbType.Float;
		case ColumnType.Double:
			return MySqlDbType.Double;
		case ColumnType.Decimal:
			return MySqlDbType.Decimal;
		case ColumnType.NewDecimal:
			return MySqlDbType.NewDecimal;
		case ColumnType.Geometry:
			return MySqlDbType.Geometry;
		case ColumnType.Null:
			return MySqlDbType.Null;
		case ColumnType.Enum:
			return MySqlDbType.Enum;
		case ColumnType.Set:
			return MySqlDbType.Set;
		default:
			throw new NotImplementedException($"ConvertToMySqlDbType for {columnDefinition.ColumnType} is not implemented");
		}
	}

	public static ushort ConvertToColumnTypeAndFlags(MySqlDbType dbType, MySqlGuidFormat guidFormat)
	{
		bool flag = (((uint)(dbType - 501) <= 2u || (uint)(dbType - 508) <= 1u) ? true : false);
		bool flag2 = flag;
		ColumnType columnType;
		switch (dbType)
		{
		case MySqlDbType.Bool:
		case MySqlDbType.Byte:
		case MySqlDbType.UByte:
			columnType = ColumnType.Tiny;
			break;
		case MySqlDbType.Int16:
		case MySqlDbType.UInt16:
			columnType = ColumnType.Short;
			break;
		case MySqlDbType.Int24:
		case MySqlDbType.UInt24:
			columnType = ColumnType.Int24;
			break;
		case MySqlDbType.Int32:
		case MySqlDbType.UInt32:
			columnType = ColumnType.Long;
			break;
		case MySqlDbType.Int64:
		case MySqlDbType.UInt64:
			columnType = ColumnType.Longlong;
			break;
		case MySqlDbType.Bit:
			columnType = ColumnType.Bit;
			break;
		case MySqlDbType.Guid:
			flag = (uint)(guidFormat - 2) <= 1u;
			columnType = (flag ? ColumnType.String : ColumnType.Blob);
			break;
		case MySqlDbType.Enum:
		case MySqlDbType.Set:
			columnType = ColumnType.String;
			break;
		case MySqlDbType.String:
		case MySqlDbType.Binary:
			columnType = ColumnType.String;
			break;
		case MySqlDbType.VarString:
		case MySqlDbType.VarChar:
		case MySqlDbType.VarBinary:
			columnType = ColumnType.VarString;
			break;
		case MySqlDbType.TinyBlob:
		case MySqlDbType.TinyText:
			columnType = ColumnType.TinyBlob;
			break;
		case MySqlDbType.Blob:
		case MySqlDbType.Text:
			columnType = ColumnType.Blob;
			break;
		case MySqlDbType.MediumBlob:
		case MySqlDbType.MediumText:
			columnType = ColumnType.MediumBlob;
			break;
		case MySqlDbType.LongBlob:
		case MySqlDbType.LongText:
			columnType = ColumnType.LongBlob;
			break;
		case MySqlDbType.JSON:
			columnType = ColumnType.Json;
			break;
		case MySqlDbType.Date:
		case MySqlDbType.Newdate:
			columnType = ColumnType.Date;
			break;
		case MySqlDbType.DateTime:
			columnType = ColumnType.DateTime;
			break;
		case MySqlDbType.Timestamp:
			columnType = ColumnType.Timestamp;
			break;
		case MySqlDbType.Time:
			columnType = ColumnType.Time;
			break;
		case MySqlDbType.Year:
			columnType = ColumnType.Year;
			break;
		case MySqlDbType.Float:
			columnType = ColumnType.Float;
			break;
		case MySqlDbType.Double:
			columnType = ColumnType.Double;
			break;
		case MySqlDbType.Decimal:
			columnType = ColumnType.Decimal;
			break;
		case MySqlDbType.NewDecimal:
			columnType = ColumnType.NewDecimal;
			break;
		case MySqlDbType.Geometry:
			columnType = ColumnType.Geometry;
			break;
		case MySqlDbType.Null:
			columnType = ColumnType.Null;
			break;
		default:
			throw new NotImplementedException($"ConvertToColumnTypeAndFlags for {dbType} is not implemented");
		}
		return (ushort)((byte)columnType | (flag2 ? 32768 : 0));
	}

	internal IEnumerable<ColumnTypeMetadata> GetColumnMappings()
	{
		return m_columnTypeMetadataLookup.Values.AsEnumerable();
	}
}


using System.Globalization;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Transactions;
using MySqlConnector;
using MySqlConnector.Core;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class XaEnlistedTransaction : EnlistedTransactionBase
{
	private static int s_currentId;

	[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)]
	private string m_xid;

	public XaEnlistedTransaction(Transaction transaction, MySqlConnection connection)
		: base(transaction, connection)
	{
	}

	protected override void OnStart()
	{
		int num = Interlocked.Increment(ref s_currentId);
		m_xid = "'" + base.Transaction.TransactionInformation.LocalIdentifier + "', '" + num.ToString(CultureInfo.InvariantCulture) + "'";
		ExecuteXaCommand("START");
	}

	protected override void OnPrepare(PreparingEnlistment enlistment)
	{
		ExecuteXaCommand("END");
		ExecuteXaCommand("PREPARE");
	}

	protected override void OnCommit(Enlistment enlistment)
	{
		ExecuteXaCommand("COMMIT");
	}

	protected override void OnRollback(Enlistment enlistment)
	{
		try
		{
			if (!base.IsPrepared)
			{
				ExecuteXaCommand("END");
			}
			ExecuteXaCommand("ROLLBACK");
		}
		catch (MySqlException ex) when (ex.ErrorCode == MySqlErrorCode.XARBDeadlock)
		{
		}
	}

	private void ExecuteXaCommand(string statement)
	{
		using MySqlCommand mySqlCommand = base.Connection.CreateCommand();
		mySqlCommand.CommandText = "XA " + statement + " " + m_xid;
		mySqlCommand.ExecuteNonQuery();
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class BinaryBooleanColumnReader : ColumnReader
{
	public static BinaryBooleanColumnReader Instance { get; } = new BinaryBooleanColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data) ? 1 : 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static bool DoReadValue(ReadOnlySpan<byte> data)
	{
		return data[0] != 0;
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using MySqlConnector;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class BinaryDateTimeColumnReader : ColumnReader
{
	private readonly bool m_allowZeroDateTime;

	private readonly bool m_convertZeroDateTime;

	private readonly DateTimeKind m_dateTimeKind;

	public BinaryDateTimeColumnReader(MySqlConnection connection)
	{
		m_allowZeroDateTime = connection.AllowZeroDateTime;
		m_convertZeroDateTime = connection.ConvertZeroDateTime;
		m_dateTimeKind = connection.DateTimeKind;
	}

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		if (data.Length == 0)
		{
			if (m_convertZeroDateTime)
			{
				return DateTime.MinValue;
			}
			if (m_allowZeroDateTime)
			{
				return default(MySqlDateTime);
			}
			throw new InvalidCastException("Unable to convert MySQL date/time to System.DateTime.");
		}
		int year = data[0] + data[1] * 256;
		int month = data[2];
		int day = data[3];
		int hour;
		int minute;
		int second;
		if (data.Length <= 4)
		{
			hour = 0;
			minute = 0;
			second = 0;
		}
		else
		{
			hour = data[4];
			minute = data[5];
			second = data[6];
		}
		int num;
		if (data.Length > 7)
		{
			num = MemoryMarshal.Read<int>(data.Slice(7, data.Length - 7));
		}
		else
		{
			num = 0;
		}
		int num2 = num;
		try
		{
			return m_allowZeroDateTime ? ((object)new MySqlDateTime(year, month, day, hour, minute, second, num2)) : ((object)new DateTime(year, month, day, hour, minute, second, num2 / 1000, m_dateTimeKind).AddTicks(num2 % 1000 * 10));
		}
		catch (Exception innerException)
		{
			throw new FormatException("Couldn't interpret value as a valid DateTime: " + Encoding.UTF8.GetString(data), innerException);
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class BinaryDoubleColumnReader : ColumnReader
{
	public static BinaryDoubleColumnReader Instance { get; } = new BinaryDoubleColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return MemoryMarshal.Read<double>(data);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class BinaryFloatColumnReader : ColumnReader
{
	public static BinaryFloatColumnReader Instance { get; } = new BinaryFloatColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return MemoryMarshal.Read<float>(data);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class BinarySignedInt16ColumnReader : ColumnReader
{
	public static BinarySignedInt16ColumnReader Instance { get; } = new BinarySignedInt16ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static short DoReadValue(ReadOnlySpan<byte> data)
	{
		return MemoryMarshal.Read<short>(data);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class BinarySignedInt32ColumnReader : ColumnReader
{
	public static BinarySignedInt32ColumnReader Instance { get; } = new BinarySignedInt32ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static int DoReadValue(ReadOnlySpan<byte> data)
	{
		return MemoryMarshal.Read<int>(data);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class BinarySignedInt64ColumnReader : ColumnReader
{
	public static BinarySignedInt64ColumnReader Instance { get; } = new BinarySignedInt64ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return checked((int)DoReadValue(data));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static long DoReadValue(ReadOnlySpan<byte> data)
	{
		return MemoryMarshal.Read<long>(data);
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class BinarySignedInt8ColumnReader : ColumnReader
{
	public static BinarySignedInt8ColumnReader Instance { get; } = new BinarySignedInt8ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static sbyte DoReadValue(ReadOnlySpan<byte> data)
	{
		return (sbyte)data[0];
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class BinaryTimeColumnReader : ColumnReader
{
	public static BinaryTimeColumnReader Instance { get; } = new BinaryTimeColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		if (data.Length == 0)
		{
			return TimeSpan.Zero;
		}
		byte num = data[0];
		ref ReadOnlySpan<byte> reference = ref data;
		int num2 = MemoryMarshal.Read<int>(reference.Slice(1, reference.Length - 1));
		int num3 = data[5];
		int num4 = data[6];
		int num5 = data[7];
		int num6;
		if (data.Length != 8)
		{
			reference = ref data;
			num6 = MemoryMarshal.Read<int>(reference.Slice(8, reference.Length - 8));
		}
		else
		{
			num6 = 0;
		}
		int num7 = num6;
		if (num != 0)
		{
			num2 = -num2;
			num3 = -num3;
			num4 = -num4;
			num5 = -num5;
			num7 = -num7;
		}
		return new TimeSpan(num2, num3, num4, num5) + TimeSpan.FromTicks(num7 * 10);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class BinaryUnsignedInt16ColumnReader : ColumnReader
{
	public static BinaryUnsignedInt16ColumnReader Instance { get; } = new BinaryUnsignedInt16ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static ushort DoReadValue(ReadOnlySpan<byte> data)
	{
		return MemoryMarshal.Read<ushort>(data);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class BinaryUnsignedInt32ColumnReader : ColumnReader
{
	public static BinaryUnsignedInt32ColumnReader Instance { get; } = new BinaryUnsignedInt32ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return checked((int)DoReadValue(data));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static uint DoReadValue(ReadOnlySpan<byte> data)
	{
		return MemoryMarshal.Read<uint>(data);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class BinaryUnsignedInt64ColumnReader : ColumnReader
{
	public static BinaryUnsignedInt64ColumnReader Instance { get; } = new BinaryUnsignedInt64ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return checked((int)DoReadValue(data));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static ulong DoReadValue(ReadOnlySpan<byte> data)
	{
		return MemoryMarshal.Read<ulong>(data);
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class BinaryUnsignedInt8ColumnReader : ColumnReader
{
	public static BinaryUnsignedInt8ColumnReader Instance { get; } = new BinaryUnsignedInt8ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static byte DoReadValue(ReadOnlySpan<byte> data)
	{
		return data[0];
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class BinaryYearColumnReader : ColumnReader
{
	public static BinaryYearColumnReader Instance { get; } = new BinaryYearColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static int DoReadValue(ReadOnlySpan<byte> data)
	{
		return MemoryMarshal.Read<short>(data);
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class BitColumnReader : ColumnReader
{
	public static BitColumnReader Instance { get; } = new BitColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data, columnDefinition);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return checked((int)DoReadValue(data, columnDefinition));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static ulong DoReadValue(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		if ((columnDefinition.ColumnFlags & ColumnFlags.Binary) == 0)
		{
			ulong num = 0uL;
			for (int i = 0; i < data.Length; i++)
			{
				num = num * 256 + data[i];
			}
			return num;
		}
		if (columnDefinition.ColumnLength <= 5 && data.Length == 1 && data[0] < (byte)(1 << (int)columnDefinition.ColumnLength))
		{
			return data[0];
		}
		if (Utf8Parser.TryParse(data, out ulong value, out int bytesConsumed, '\0') && bytesConsumed == data.Length)
		{
			return value;
		}
		throw new FormatException();
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class BytesColumnReader : ColumnReader
{
	public static BytesColumnReader Instance { get; } = new BytesColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return data.ToArray();
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Protocol.Serialization;

internal abstract class ColumnReader
{
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public static ColumnReader Create(bool isBinary, ColumnDefinitionPayload columnDefinition, MySqlConnection connection)
	{
		bool flag = (columnDefinition.ColumnFlags & ColumnFlags.Unsigned) != 0;
		switch (columnDefinition.ColumnType)
		{
		case ColumnType.Tiny:
			if (connection.TreatTinyAsBoolean && columnDefinition.ColumnLength == 1 && !flag)
			{
				if (!isBinary)
				{
					return TextBooleanColumnReader.Instance;
				}
				return BinaryBooleanColumnReader.Instance;
			}
			if (!isBinary)
			{
				if (!flag)
				{
					return TextSignedInt8ColumnReader.Instance;
				}
				return TextUnsignedInt8ColumnReader.Instance;
			}
			if (!flag)
			{
				return BinarySignedInt8ColumnReader.Instance;
			}
			return BinaryUnsignedInt8ColumnReader.Instance;
		case ColumnType.Long:
		case ColumnType.Int24:
			if (!isBinary)
			{
				if (!flag)
				{
					return TextSignedInt32ColumnReader.Instance;
				}
				return TextUnsignedInt32ColumnReader.Instance;
			}
			if (!flag)
			{
				return BinarySignedInt32ColumnReader.Instance;
			}
			return BinaryUnsignedInt32ColumnReader.Instance;
		case ColumnType.Longlong:
			if (!isBinary)
			{
				if (!flag)
				{
					return TextSignedInt64ColumnReader.Instance;
				}
				return TextUnsignedInt64ColumnReader.Instance;
			}
			if (!flag)
			{
				return BinarySignedInt64ColumnReader.Instance;
			}
			return BinaryUnsignedInt64ColumnReader.Instance;
		case ColumnType.Bit:
			return BitColumnReader.Instance;
		case ColumnType.String:
			if (connection.GuidFormat == MySqlGuidFormat.Char36 && columnDefinition.ColumnLength / ProtocolUtility.GetBytesPerCharacter(columnDefinition.CharacterSet) == 36)
			{
				return GuidChar36ColumnReader.Instance;
			}
			if (connection.GuidFormat == MySqlGuidFormat.Char32 && columnDefinition.ColumnLength / ProtocolUtility.GetBytesPerCharacter(columnDefinition.CharacterSet) == 32)
			{
				return GuidChar32ColumnReader.Instance;
			}
			goto case ColumnType.VarChar;
		case ColumnType.VarChar:
		case ColumnType.Enum:
		case ColumnType.Set:
		case ColumnType.TinyBlob:
		case ColumnType.MediumBlob:
		case ColumnType.LongBlob:
		case ColumnType.Blob:
		case ColumnType.VarString:
			if (columnDefinition.CharacterSet != CharacterSet.Binary)
			{
				return StringColumnReader.Instance;
			}
			if (columnDefinition.ColumnLength == 16)
			{
				return connection.GuidFormat switch
				{
					MySqlGuidFormat.Binary16 => GuidBinary16ColumnReader.Instance, 
					MySqlGuidFormat.TimeSwapBinary16 => GuidTimeSwapBinary16ColumnReader.Instance, 
					MySqlGuidFormat.LittleEndianBinary16 => GuidLittleEndianBinary16ColumnReader.Instance, 
					_ => BytesColumnReader.Instance, 
				};
			}
			return BytesColumnReader.Instance;
		case ColumnType.Json:
			return StringColumnReader.Instance;
		case ColumnType.Short:
			if (!isBinary)
			{
				if (!flag)
				{
					return TextSignedInt16ColumnReader.Instance;
				}
				return TextUnsignedInt16ColumnReader.Instance;
			}
			if (!flag)
			{
				return BinarySignedInt16ColumnReader.Instance;
			}
			return BinaryUnsignedInt16ColumnReader.Instance;
		case ColumnType.Timestamp:
		case ColumnType.Date:
		case ColumnType.DateTime:
		case ColumnType.NewDate:
			if (!isBinary)
			{
				return new TextDateTimeColumnReader(connection);
			}
			return new BinaryDateTimeColumnReader(connection);
		case ColumnType.Time:
			if (!isBinary)
			{
				return TextTimeColumnReader.Instance;
			}
			return BinaryTimeColumnReader.Instance;
		case ColumnType.Year:
			if (!isBinary)
			{
				return TextSignedInt32ColumnReader.Instance;
			}
			return BinaryYearColumnReader.Instance;
		case ColumnType.Float:
			if (!isBinary)
			{
				return TextFloatColumnReader.Instance;
			}
			return BinaryFloatColumnReader.Instance;
		case ColumnType.Double:
			if (!isBinary)
			{
				return TextDoubleColumnReader.Instance;
			}
			return BinaryDoubleColumnReader.Instance;
		case ColumnType.Decimal:
		case ColumnType.NewDecimal:
			return DecimalColumnReader.Instance;
		case ColumnType.Geometry:
			return BytesColumnReader.Instance;
		case ColumnType.Null:
			return NullColumnReader.Instance;
		default:
			throw new NotImplementedException($"Reading {columnDefinition.ColumnType} not implemented");
		}
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public abstract object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition);

	public virtual int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return null;
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class DecimalColumnReader : ColumnReader
{
	public static DecimalColumnReader Instance { get; } = new DecimalColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return (int)DoReadValue(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static decimal DoReadValue(ReadOnlySpan<byte> data)
	{
		if (Utf8Parser.TryParse(data, out decimal value, out int bytesConsumed, '\0') && bytesConsumed == data.Length)
		{
			return value;
		}
		throw new FormatException();
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class GuidBinary16ColumnReader : ColumnReader
{
	public static GuidBinary16ColumnReader Instance { get; } = new GuidBinary16ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return ReadGuid(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public static Guid ReadGuid(ReadOnlySpan<byte> data)
	{
		return new Guid(new byte[16]
		{
			data[3],
			data[2],
			data[1],
			data[0],
			data[5],
			data[4],
			data[7],
			data[6],
			data[8],
			data[9],
			data[10],
			data[11],
			data[12],
			data[13],
			data[14],
			data[15]
		});
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Utilities;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class GuidChar32ColumnReader : ColumnReader
{
	public static GuidChar32ColumnReader Instance { get; } = new GuidChar32ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		if (!Utf8Parser.TryParse(data, out Guid value, out int bytesConsumed, 'N') || bytesConsumed != 32)
		{
			throw new FormatException("Could not parse CHAR(32) value as Guid: " + Encoding.UTF8.GetString(data));
		}
		return value;
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class GuidChar36ColumnReader : ColumnReader
{
	public static GuidChar36ColumnReader Instance { get; } = new GuidChar36ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		if (!Utf8Parser.TryParse(data, out Guid value, out int bytesConsumed, 'D') || bytesConsumed != 36)
		{
			throw new FormatException("Could not parse CHAR(36) value as Guid: " + Encoding.UTF8.GetString(data));
		}
		return value;
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class GuidLittleEndianBinary16ColumnReader : ColumnReader
{
	public static GuidLittleEndianBinary16ColumnReader Instance { get; } = new GuidLittleEndianBinary16ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return ReadGuid(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public static Guid ReadGuid(ReadOnlySpan<byte> data)
	{
		return new Guid(data.ToArray());
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class GuidTimeSwapBinary16ColumnReader : ColumnReader
{
	public static GuidTimeSwapBinary16ColumnReader Instance { get; } = new GuidTimeSwapBinary16ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return ReadGuid(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public static Guid ReadGuid(ReadOnlySpan<byte> data)
	{
		return new Guid(new byte[16]
		{
			data[7],
			data[6],
			data[5],
			data[4],
			data[3],
			data[2],
			data[1],
			data[0],
			data[8],
			data[9],
			data[10],
			data[11],
			data[12],
			data[13],
			data[14],
			data[15]
		});
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class NullColumnReader : ColumnReader
{
	public static NullColumnReader Instance { get; } = new NullColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DBNull.Value;
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class StringColumnReader : ColumnReader
{
	public static StringColumnReader Instance { get; } = new StringColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return Encoding.UTF8.GetString(data);
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class TextBooleanColumnReader : ColumnReader
{
	public static TextBooleanColumnReader Instance { get; } = new TextBooleanColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data) ? 1 : 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static bool DoReadValue(ReadOnlySpan<byte> data)
	{
		return data[0] != 48;
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Utilities;

internal sealed class TextDateTimeColumnReader : ColumnReader
{
	private readonly bool m_allowZeroDateTime;

	private readonly bool m_convertZeroDateTime;

	private readonly DateTimeKind m_dateTimeKind;

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public TextDateTimeColumnReader(MySqlConnection connection)
	{
		m_allowZeroDateTime = connection.AllowZeroDateTime;
		m_convertZeroDateTime = connection.ConvertZeroDateTime;
		m_dateTimeKind = connection.DateTimeKind;
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return ParseDateTime(data, m_convertZeroDateTime, m_allowZeroDateTime, m_dateTimeKind);
	}

	[return: <63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)]
	public static object ParseDateTime(ReadOnlySpan<byte> data, bool convertZeroDateTime, bool allowZeroDateTime, DateTimeKind dateTimeKind)
	{
		Exception innerException = null;
		int value2;
		int value3;
		int value4;
		int value5;
		int value6;
		int value7;
		if (Utf8Parser.TryParse(data, out int value, out int i, '\0') && i == 4 && data.Length >= 5 && data[4] == 45)
		{
			ref ReadOnlySpan<byte> reference = ref data;
			if (Utf8Parser.TryParse(reference.Slice(5, reference.Length - 5), out value2, out i, '\0') && i == 2 && data.Length >= 8 && data[7] == 45)
			{
				reference = ref data;
				if (Utf8Parser.TryParse(reference.Slice(8, reference.Length - 8), out value3, out i, '\0') && i == 2)
				{
					if (value == 0 && value2 == 0 && value3 == 0)
					{
						if (convertZeroDateTime)
						{
							return DateTime.MinValue;
						}
						if (allowZeroDateTime)
						{
							return default(MySqlDateTime);
						}
						throw new InvalidCastException("Unable to convert MySQL date/time to System.DateTime, set AllowZeroDateTime=True or ConvertZeroDateTime=True in the connection string. See https://mysqlconnector.net/connection-options/");
					}
					if (data.Length == 10)
					{
						value4 = 0;
						value5 = 0;
						value6 = 0;
						value7 = 0;
						goto IL_0238;
					}
					if (data[10] == 32)
					{
						reference = ref data;
						if (Utf8Parser.TryParse(reference.Slice(11, reference.Length - 11), out value4, out i, '\0') && i == 2 && data.Length >= 14 && data[13] == 58)
						{
							reference = ref data;
							if (Utf8Parser.TryParse(reference.Slice(14, reference.Length - 14), out value5, out i, '\0') && i == 2 && data.Length >= 17 && data[16] == 58)
							{
								reference = ref data;
								if (Utf8Parser.TryParse(reference.Slice(17, reference.Length - 17), out value6, out i, '\0') && i == 2)
								{
									if (data.Length == 19)
									{
										value7 = 0;
										goto IL_0238;
									}
									if (data[19] == 46)
									{
										reference = ref data;
										if (Utf8Parser.TryParse(reference.Slice(20, reference.Length - 20), out value7, out i, '\0') && i == data.Length - 20 && i <= 7)
										{
											for (; i < 7; i++)
											{
												value7 *= 10;
											}
											goto IL_0238;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		goto IL_0290;
		IL_0238:
		try
		{
			object result;
			if (!allowZeroDateTime)
			{
				result = new DateTime(value, value2, value3, value4, value5, value6, dateTimeKind).AddTicks(value7);
			}
			else
			{
				if (value7 % 10 != 0)
				{
					throw new NotSupportedException("MySqlDateTime does not support sub-microsecond precision");
				}
				result = new MySqlDateTime(value, value2, value3, value4, value5, value6, value7 / 10);
			}
			return result;
		}
		catch (Exception ex)
		{
			innerException = ex;
		}
		goto IL_0290;
		IL_0290:
		throw new FormatException("Couldn't interpret value as a valid DateTime: " + Encoding.UTF8.GetString(data), innerException);
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class TextDoubleColumnReader : ColumnReader
{
	public static TextDoubleColumnReader Instance { get; } = new TextDoubleColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		if (Utf8Parser.TryParse(data, out double value, out int bytesConsumed, '\0') && bytesConsumed == data.Length)
		{
			return value;
		}
		if (data.SequenceEqual("-inf"u8))
		{
			return double.NegativeInfinity;
		}
		if (data.SequenceEqual("inf"u8))
		{
			return double.PositiveInfinity;
		}
		if (data.SequenceEqual("nan"u8))
		{
			return double.NaN;
		}
		throw new FormatException("Couldn't parse value as double: " + Encoding.UTF8.GetString(data));
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using System.Text;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class TextFloatColumnReader : ColumnReader
{
	public static TextFloatColumnReader Instance { get; } = new TextFloatColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		if (Utf8Parser.TryParse(data, out float value, out int bytesConsumed, '\0') && bytesConsumed == data.Length)
		{
			return value;
		}
		if (data.SequenceEqual("-inf"u8))
		{
			return float.NegativeInfinity;
		}
		if (data.SequenceEqual("inf"u8))
		{
			return float.PositiveInfinity;
		}
		if (data.SequenceEqual("nan"u8))
		{
			return float.NaN;
		}
		throw new FormatException("Couldn't parse value as float: " + Encoding.UTF8.GetString(data));
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class TextSignedInt16ColumnReader : ColumnReader
{
	public static TextSignedInt16ColumnReader Instance { get; } = new TextSignedInt16ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static short DoReadValue(ReadOnlySpan<byte> data)
	{
		if (Utf8Parser.TryParse(data, out short value, out int bytesConsumed, '\0') && bytesConsumed == data.Length)
		{
			return value;
		}
		throw new FormatException();
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class TextSignedInt32ColumnReader : ColumnReader
{
	public static TextSignedInt32ColumnReader Instance { get; } = new TextSignedInt32ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static int DoReadValue(ReadOnlySpan<byte> data)
	{
		if (Utf8Parser.TryParse(data, out int value, out int bytesConsumed, '\0') && bytesConsumed == data.Length)
		{
			return value;
		}
		throw new FormatException();
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class TextSignedInt64ColumnReader : ColumnReader
{
	public static TextSignedInt64ColumnReader Instance { get; } = new TextSignedInt64ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return checked((int)DoReadValue(data));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static long DoReadValue(ReadOnlySpan<byte> data)
	{
		if (Utf8Parser.TryParse(data, out long value, out int bytesConsumed, '\0') && bytesConsumed == data.Length)
		{
			return value;
		}
		throw new FormatException();
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class TextSignedInt8ColumnReader : ColumnReader
{
	public static TextSignedInt8ColumnReader Instance { get; } = new TextSignedInt8ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static sbyte DoReadValue(ReadOnlySpan<byte> data)
	{
		if (Utf8Parser.TryParse(data, out sbyte value, out int bytesConsumed, '\0') && bytesConsumed == data.Length)
		{
			return value;
		}
		throw new FormatException();
	}
}


using System;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;
using MySqlConnector.Utilities;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class TextTimeColumnReader : ColumnReader
{
	public static TextTimeColumnReader Instance { get; } = new TextTimeColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return Utility.ParseTimeSpan(data);
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
internal sealed class TextUnsignedInt16ColumnReader : ColumnReader
{
	public static TextUnsignedInt16ColumnReader Instance { get; } = new TextUnsignedInt16ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static ushort DoReadValue(ReadOnlySpan<byte> data)
	{
		if (Utf8Parser.TryParse(data, out ushort value, out int bytesConsumed, '\0') && bytesConsumed == data.Length)
		{
			return value;
		}
		throw new FormatException();
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class TextUnsignedInt32ColumnReader : ColumnReader
{
	public static TextUnsignedInt32ColumnReader Instance { get; } = new TextUnsignedInt32ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return checked((int)DoReadValue(data));
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static uint DoReadValue(ReadOnlySpan<byte> data)
	{
		if (Utf8Parser.TryParse(data, out uint value, out int bytesConsumed, '\0') && bytesConsumed == data.Length)
		{
			return value;
		}
		throw new FormatException();
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class TextUnsignedInt64ColumnReader : ColumnReader
{
	public static TextUnsignedInt64ColumnReader Instance { get; } = new TextUnsignedInt64ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return checked((int)DoReadValue(data));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static ulong DoReadValue(ReadOnlySpan<byte> data)
	{
		if (Utf8Parser.TryParse(data, out ulong value, out int bytesConsumed, '\0') && bytesConsumed == data.Length)
		{
			return value;
		}
		throw new FormatException();
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using MySqlConnector.ColumnReaders;
using MySqlConnector.Protocol.Payloads;

[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
internal sealed class TextUnsignedInt8ColumnReader : ColumnReader
{
	public static TextUnsignedInt8ColumnReader Instance { get; } = new TextUnsignedInt8ColumnReader();

	public override object ReadValue([<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> data, ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	public override int? TryReadInt32(ReadOnlySpan<byte> data, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(1)] ColumnDefinitionPayload columnDefinition)
	{
		return DoReadValue(data);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(0)]
	private static byte DoReadValue(ReadOnlySpan<byte> data)
	{
		if (Utf8Parser.TryParse(data, out byte value, out int bytesConsumed, '\0') && bytesConsumed == data.Length)
		{
			return value;
		}
		throw new FormatException();
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using MySqlConnector.Authentication;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
[<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)]
public static class AuthenticationPlugins
{
	private static readonly object s_lock = new object();

	private static readonly Dictionary<string, IAuthenticationPlugin> s_plugins = new Dictionary<string, IAuthenticationPlugin>();

	public static void Register(IAuthenticationPlugin plugin)
	{
		if (plugin == null)
		{
			throw new ArgumentNullException("plugin");
		}
		if (string.IsNullOrEmpty(plugin.Name))
		{
			throw new ArgumentException("Invalid plugin name.", "plugin");
		}
		lock (s_lock)
		{
			s_plugins.Add(plugin.Name, plugin);
		}
	}

	internal static bool TryGetPlugin(string name, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(2)][<e940fe46-60b5-4fb7-817f-6effabbc4d82>NotNullWhen(true)] out IAuthenticationPlugin plugin)
	{
		lock (s_lock)
		{
			return s_plugins.TryGetValue(name, out plugin);
		}
	}
}


using System;
using System.Runtime.CompilerServices;

[<31066bf3-0b14-4079-9cb8-cf7631dbb2a9>NullableContext(1)]
public interface IAuthenticationPlugin
{
	string Name { get; }

	byte[] CreateResponse(string password, [<63cbfc6b-8364-4ba4-98c4-143f3fb7bf67>Nullable(0)] ReadOnlySpan<byte> authenticationData);
}


internal static class SR
{
}


using System.Buffers;
using System.Runtime.CompilerServices;
using System.Threading;

internal abstract class ArrayPool<T>
{
	private static ArrayPool<T> s_sharedInstance;

	public static ArrayPool<T> Shared
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return Volatile.Read(in s_sharedInstance) ?? EnsureSharedCreated();
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static ArrayPool<T> EnsureSharedCreated()
	{
		Interlocked.CompareExchange(ref s_sharedInstance, Create(), null);
		return s_sharedInstance;
	}

	public static ArrayPool<T> Create()
	{
		return new DefaultArrayPool<T>();
	}

	public static ArrayPool<T> Create(int maxArrayLength, int maxArraysPerBucket)
	{
		return new DefaultArrayPool<T>(maxArrayLength, maxArraysPerBucket);
	}

	public abstract T[] Rent(int minimumLength);

	public abstract void Return(T[] array, bool clearArray = false);
}


using System;
using System.Buffers;
using System.Diagnostics.Tracing;

[EventSource(Name = "System.Buffers.ArrayPoolEventSource")]
internal sealed class ArrayPoolEventSource : EventSource
{
	internal enum BufferAllocatedReason
	{
		Pooled,
		OverMaximumSize,
		PoolExhausted
	}

	internal static readonly System.Buffers.ArrayPoolEventSource Log = new System.Buffers.ArrayPoolEventSource();

	[Event(1, Level = EventLevel.Verbose)]
	internal unsafe void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId)
	{
		EventData* ptr = stackalloc EventData[4];
		*ptr = new EventData
		{
			Size = 4,
			DataPointer = (IntPtr)(&bufferId)
		};
		ptr[1] = new EventData
		{
			Size = 4,
			DataPointer = (IntPtr)(&bufferSize)
		};
		ptr[2] = new EventData
		{
			Size = 4,
			DataPointer = (IntPtr)(&poolId)
		};
		ptr[3] = new EventData
		{
			Size = 4,
			DataPointer = (IntPtr)(&bucketId)
		};
		WriteEventCore(1, 4, ptr);
	}

	[Event(2, Level = EventLevel.Informational)]
	internal unsafe void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, BufferAllocatedReason reason)
	{
		EventData* ptr = stackalloc EventData[5];
		*ptr = new EventData
		{
			Size = 4,
			DataPointer = (IntPtr)(&bufferId)
		};
		ptr[1] = new EventData
		{
			Size = 4,
			DataPointer = (IntPtr)(&bufferSize)
		};
		ptr[2] = new EventData
		{
			Size = 4,
			DataPointer = (IntPtr)(&poolId)
		};
		ptr[3] = new EventData
		{
			Size = 4,
			DataPointer = (IntPtr)(&bucketId)
		};
		ptr[4] = new EventData
		{
			Size = 4,
			DataPointer = (IntPtr)(&reason)
		};
		WriteEventCore(2, 5, ptr);
	}

	[Event(3, Level = EventLevel.Verbose)]
	internal void BufferReturned(int bufferId, int bufferSize, int poolId)
	{
		WriteEvent(3, bufferId, bufferSize, poolId);
	}
}


internal enum BufferAllocatedReason
{
	Pooled,
	OverMaximumSize,
	PoolExhausted
}


using System;
using System.Buffers;
using System.Diagnostics;
using System.Threading;

internal sealed class DefaultArrayPool<T> : ArrayPool<T>
{
	private sealed class Bucket
	{
		internal readonly int _bufferLength;

		private readonly T[][] _buffers;

		private readonly int _poolId;

		private SpinLock _lock;

		private int _index;

		internal int Id => GetHashCode();

		internal Bucket(int bufferLength, int numberOfBuffers, int poolId)
		{
			_lock = new SpinLock(Debugger.IsAttached);
			_buffers = new T[numberOfBuffers][];
			_bufferLength = bufferLength;
			_poolId = poolId;
		}

		internal T[] Rent()
		{
			T[][] buffers = _buffers;
			T[] array = null;
			bool lockTaken = false;
			bool flag = false;
			try
			{
				_lock.Enter(ref lockTaken);
				if (_index < buffers.Length)
				{
					array = buffers[_index];
					buffers[_index++] = null;
					flag = array == null;
				}
			}
			finally
			{
				if (lockTaken)
				{
					_lock.Exit(useMemoryBarrier: false);
				}
			}
			if (flag)
			{
				array = new T[_bufferLength];
				System.Buffers.ArrayPoolEventSource log = System.Buffers.ArrayPoolEventSource.Log;
				if (log.IsEnabled())
				{
					log.BufferAllocated(array.GetHashCode(), _bufferLength, _poolId, Id, System.Buffers.ArrayPoolEventSource.BufferAllocatedReason.Pooled);
				}
			}
			return array;
		}

		internal void Return(T[] array)
		{
			if (array.Length != _bufferLength)
			{
				throw new ArgumentException(<32c71712-ba18-4036-ac49-fe5f579bce0d>SR.ArgumentException_BufferNotFromPool, "array");
			}
			bool lockTaken = false;
			try
			{
				_lock.Enter(ref lockTaken);
				if (_index != 0)
				{
					_buffers[--_index] = array;
				}
			}
			finally
			{
				if (lockTaken)
				{
					_lock.Exit(useMemoryBarrier: false);
				}
			}
		}
	}

	private const int DefaultMaxArrayLength = 1048576;

	private const int DefaultMaxNumberOfArraysPerBucket = 50;

	private static T[] s_emptyArray;

	private readonly Bucket[] _buckets;

	private int Id => GetHashCode();

	internal DefaultArrayPool()
		: this(1048576, 50)
	{
	}

	internal DefaultArrayPool(int maxArrayLength, int maxArraysPerBucket)
	{
		if (maxArrayLength <= 0)
		{
			throw new ArgumentOutOfRangeException("maxArrayLength");
		}
		if (maxArraysPerBucket <= 0)
		{
			throw new ArgumentOutOfRangeException("maxArraysPerBucket");
		}
		if (maxArrayLength > 1073741824)
		{
			maxArrayLength = 1073741824;
		}
		else if (maxArrayLength < 16)
		{
			maxArrayLength = 16;
		}
		int id = Id;
		int num = System.Buffers.Utilities.SelectBucketIndex(maxArrayLength);
		Bucket[] array = new Bucket[num + 1];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = new Bucket(System.Buffers.Utilities.GetMaxSizeForBucket(i), maxArraysPerBucket, id);
		}
		_buckets = array;
	}

	public override T[] Rent(int minimumLength)
	{
		if (minimumLength < 0)
		{
			throw new ArgumentOutOfRangeException("minimumLength");
		}
		if (minimumLength == 0)
		{
			return s_emptyArray ?? (s_emptyArray = new T[0]);
		}
		System.Buffers.ArrayPoolEventSource log = System.Buffers.ArrayPoolEventSource.Log;
		T[] array = null;
		int num = System.Buffers.Utilities.SelectBucketIndex(minimumLength);
		if (num < _buckets.Length)
		{
			int num2 = num;
			do
			{
				array = _buckets[num2].Rent();
				if (array != null)
				{
					if (log.IsEnabled())
					{
						log.BufferRented(array.GetHashCode(), array.Length, Id, _buckets[num2].Id);
					}
					return array;
				}
			}
			while (++num2 < _buckets.Length && num2 != num + 2);
			array = new T[_buckets[num]._bufferLength];
		}
		else
		{
			array = new T[minimumLength];
		}
		if (log.IsEnabled())
		{
			int hashCode = array.GetHashCode();
			int bucketId = -1;
			log.BufferRented(hashCode, array.Length, Id, bucketId);
			log.BufferAllocated(hashCode, array.Length, Id, bucketId, (num >= _buckets.Length) ? System.Buffers.ArrayPoolEventSource.BufferAllocatedReason.OverMaximumSize : System.Buffers.ArrayPoolEventSource.BufferAllocatedReason.PoolExhausted);
		}
		return array;
	}

	public override void Return(T[] array, bool clearArray = false)
	{
		if (array == null)
		{
			throw new ArgumentNullException("array");
		}
		if (array.Length == 0)
		{
			return;
		}
		int num = System.Buffers.Utilities.SelectBucketIndex(array.Length);
		if (num < _buckets.Length)
		{
			if (clearArray)
			{
				Array.Clear(array, 0, array.Length);
			}
			_buckets[num].Return(array);
		}
		System.Buffers.ArrayPoolEventSource log = System.Buffers.ArrayPoolEventSource.Log;
		if (log.IsEnabled())
		{
			log.BufferReturned(array.GetHashCode(), array.Length, Id);
		}
	}
}


using System.Diagnostics;
using System.Threading;

private sealed class Bucket
{
	internal readonly int _bufferLength;

	private readonly T[][] _buffers;

	private readonly int _poolId;

	private SpinLock _lock;

	private int _index;

	internal int Id => GetHashCode();

	internal Bucket(int bufferLength, int numberOfBuffers, int poolId)
	{
		_lock = new SpinLock(Debugger.IsAttached);
		_buffers = new T[numberOfBuffers][];
		_bufferLength = bufferLength;
		_poolId = poolId;
	}

	internal T[] Rent()
	{
		T[][] buffers = _buffers;
		T[] array = null;
		bool lockTaken = false;
		bool flag = false;
		try
		{
			_lock.Enter(ref lockTaken);
			if (_index < buffers.Length)
			{
				array = buffers[_index];
				buffers[_index++] = null;
				flag = array == null;
			}
		}
		finally
		{
			if (lockTaken)
			{
				_lock.Exit(useMemoryBarrier: false);
			}
		}
		if (flag)
		{
			array = new T[_bufferLength];
			System.Buffers.ArrayPoolEventSource log = System.Buffers.ArrayPoolEventSource.Log;
			if (log.IsEnabled())
			{
				log.BufferAllocated(array.GetHashCode(), _bufferLength, _poolId, Id, System.Buffers.ArrayPoolEventSource.BufferAllocatedReason.Pooled);
			}
		}
		return array;
	}

	internal void Return(T[] array)
	{
		if (array.Length != _bufferLength)
		{
			throw new ArgumentException(<32c71712-ba18-4036-ac49-fe5f579bce0d>SR.ArgumentException_BufferNotFromPool, "array");
		}
		bool lockTaken = false;
		try
		{
			_lock.Enter(ref lockTaken);
			if (_index != 0)
			{
				_buffers[--_index] = array;
			}
		}
		finally
		{
			if (lockTaken)
			{
				_lock.Exit(useMemoryBarrier: false);
			}
		}
	}
}


using System.Runtime.CompilerServices;

internal static class Utilities
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static int SelectBucketIndex(int bufferSize)
	{
		uint num = (uint)(bufferSize - 1) >> 4;
		int num2 = 0;
		if (num > 65535)
		{
			num >>= 16;
			num2 = 16;
		}
		if (num > 255)
		{
			num >>= 8;
			num2 += 8;
		}
		if (num > 15)
		{
			num >>= 4;
			num2 += 4;
		}
		if (num > 3)
		{
			num >>= 2;
			num2 += 2;
		}
		if (num > 1)
		{
			num >>= 1;
			num2++;
		}
		return num2 + (int)num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static int GetMaxSizeForBucket(int binIndex)
	{
		return 16 << binIndex;
	}
}


internal static class SR
{
}


using System;
using System.Runtime.CompilerServices;
using System.Security;

internal static class HexConverter
{
	public enum Casing : uint
	{
		Upper = 0u,
		Lower = 8224u
	}

	public static ReadOnlySpan<byte> CharToHexLookup => new byte[256]
	{
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 0, 1,
		2, 3, 4, 5, 6, 7, 8, 9, 255, 255,
		255, 255, 255, 255, 255, 10, 11, 12, 13, 14,
		15, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 10, 11, 12,
		13, 14, 15, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255
	};

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void ToBytesBuffer(byte value, Span<byte> buffer, int startingIndex = 0, Casing casing = Casing.Upper)
	{
		uint num = (uint)(((value & 0xF0) << 4) + (value & 0xF) - 35209);
		uint num2 = ((((0 - num) & 0x7070) >> 4) + num + 47545) | (uint)casing;
		buffer[startingIndex + 1] = (byte)num2;
		buffer[startingIndex] = (byte)(num2 >> 8);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[SecuritySafeCritical]
	public static void ToCharsBuffer(byte value, Span<char> buffer, int startingIndex = 0, Casing casing = Casing.Upper)
	{
		uint num = (uint)(((value & 0xF0) << 4) + (value & 0xF) - 35209);
		uint num2 = ((((0 - num) & 0x7070) >> 4) + num + 47545) | (uint)casing;
		buffer[startingIndex + 1] = (char)(num2 & 0xFF);
		buffer[startingIndex] = (char)(num2 >> 8);
	}

	public static void EncodeToUtf16(ReadOnlySpan<byte> bytes, Span<char> chars, Casing casing = Casing.Upper)
	{
		for (int i = 0; i < bytes.Length; i++)
		{
			ToCharsBuffer(bytes[i], chars, i * 2, casing);
		}
	}

	[SecuritySafeCritical]
	public static string ToString(ReadOnlySpan<byte> bytes, Casing casing = Casing.Upper)
	{
		Span<char> span = ((bytes.Length <= 16) ? stackalloc char[bytes.Length * 2] : MemoryExtensions.AsSpan(new char[bytes.Length * 2]));
		Span<char> buffer = span;
		int num = 0;
		ReadOnlySpan<byte> readOnlySpan = bytes;
		for (int i = 0; i < readOnlySpan.Length; i++)
		{
			byte value = readOnlySpan[i];
			ToCharsBuffer(value, buffer, num, casing);
			num += 2;
		}
		return buffer.ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static char ToCharUpper(int value)
	{
		value &= 0xF;
		value += 48;
		if (value > 57)
		{
			value += 7;
		}
		return (char)value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static char ToCharLower(int value)
	{
		value &= 0xF;
		value += 48;
		if (value > 57)
		{
			value += 39;
		}
		return (char)value;
	}

	public static bool TryDecodeFromUtf16(ReadOnlySpan<char> chars, Span<byte> bytes)
	{
		int charsProcessed;
		return TryDecodeFromUtf16(chars, bytes, out charsProcessed);
	}

	public static bool TryDecodeFromUtf16(ReadOnlySpan<char> chars, Span<byte> bytes, out int charsProcessed)
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		while (num2 < bytes.Length)
		{
			num3 = FromChar(chars[num + 1]);
			num4 = FromChar(chars[num]);
			if ((num3 | num4) == 255)
			{
				break;
			}
			bytes[num2++] = (byte)((num4 << 4) | num3);
			num += 2;
		}
		if (num3 == 255)
		{
			num++;
		}
		charsProcessed = num;
		return (num3 | num4) != 255;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int FromChar(int c)
	{
		if (c < CharToHexLookup.Length)
		{
			return CharToHexLookup[c];
		}
		return 255;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int FromUpperChar(int c)
	{
		if (c <= 71)
		{
			return CharToHexLookup[c];
		}
		return 255;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int FromLowerChar(int c)
	{
		switch (c)
		{
		case 48:
		case 49:
		case 50:
		case 51:
		case 52:
		case 53:
		case 54:
		case 55:
		case 56:
		case 57:
			return c - 48;
		case 97:
		case 98:
		case 99:
		case 100:
		case 101:
		case 102:
			return c - 97 + 10;
		default:
			return 255;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsHexChar(int c)
	{
		if (IntPtr.Size == 8)
		{
			ulong num = (uint)(c - 48);
			ulong num2 = (ulong)(-17875860044349952L << (int)num);
			ulong num3 = num - 64;
			if ((long)(num2 & num3) >= 0L)
			{
				return false;
			}
			return true;
		}
		return FromChar(c) != 255;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsHexUpperChar(int c)
	{
		if ((uint)(c - 48) > 9u)
		{
			return (uint)(c - 65) <= 5u;
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsHexLowerChar(int c)
	{
		if ((uint)(c - 48) > 9u)
		{
			return (uint)(c - 97) <= 5u;
		}
		return true;
	}
}


public enum Casing : uint
{
	Upper = 0u,
	Lower = 8224u
}


using System;

internal abstract class OSPlatformAttribute : Attribute
{
	public string PlatformName { get; }

	private protected OSPlatformAttribute(string platformName)
	{
		PlatformName = platformName;
	}
}


using System;
using System.Runtime.Versioning;

[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)]
internal sealed class TargetPlatformAttribute : OSPlatformAttribute
{
	public TargetPlatformAttribute(string platformName)
		: base(platformName)
	{
	}
}


using System;
using System.Runtime.Versioning;

[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Module | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface, AllowMultiple = true, Inherited = false)]
internal sealed class SupportedOSPlatformAttribute : OSPlatformAttribute
{
	public SupportedOSPlatformAttribute(string platformName)
		: base(platformName)
	{
	}
}


using System;
using System.Runtime.Versioning;

[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Module | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface, AllowMultiple = true, Inherited = false)]
internal sealed class UnsupportedOSPlatformAttribute : OSPlatformAttribute
{
	public string Message { get; }

	public UnsupportedOSPlatformAttribute(string platformName)
		: base(platformName)
	{
	}

	public UnsupportedOSPlatformAttribute(string platformName, string message)
		: base(platformName)
	{
		Message = message;
	}
}


using System;
using System.Runtime.Versioning;

[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Module | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface, AllowMultiple = true, Inherited = false)]
internal sealed class ObsoletedOSPlatformAttribute : OSPlatformAttribute
{
	public string Message { get; }

	public string Url { get; set; }

	public ObsoletedOSPlatformAttribute(string platformName)
		: base(platformName)
	{
	}

	public ObsoletedOSPlatformAttribute(string platformName, string message)
		: base(platformName)
	{
		Message = message;
	}
}


using System;
using System.Runtime.Versioning;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true, Inherited = false)]
internal sealed class SupportedOSPlatformGuardAttribute : OSPlatformAttribute
{
	public SupportedOSPlatformGuardAttribute(string platformName)
		: base(platformName)
	{
	}
}


using System;
using System.Runtime.Versioning;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true, Inherited = false)]
internal sealed class UnsupportedOSPlatformGuardAttribute : OSPlatformAttribute
{
	public UnsupportedOSPlatformGuardAttribute(string platformName)
		: base(platformName)
	{
	}
}


using System.ComponentModel;

[EditorBrowsable(EditorBrowsableState.Never)]
internal static class IsExternalInit
{
}


using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Security;

[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
[SecuritySafeCritical]
internal struct ActivityChangedEventArgs
{
	public Activity Previous { get; init; }

	public Activity Current { get; init; }

	internal ActivityChangedEventArgs(Activity previous, Activity current)
	{
		Previous = previous;
		Current = current;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Security;
using System.Text;
using System.Threading;

[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
internal class Activity : IDisposable
{
	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
	public struct Enumerator<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] T>
	{
		private static readonly DiagNode<T> s_Empty = new DiagNode<T>(default(T));

		private DiagNode<T> _nextNode;

		private DiagNode<T> _currentNode;

		public ref T Current
		{
			[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
			get
			{
				return ref _currentNode.Value;
			}
		}

		internal Enumerator(DiagNode<T> head)
		{
			_nextNode = head;
			_currentNode = s_Empty;
		}

		[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1 })]
		public Enumerator<T> GetEnumerator()
		{
			return this;
		}

		public bool MoveNext()
		{
			if (_nextNode == null)
			{
				_currentNode = s_Empty;
				return false;
			}
			_currentNode = _nextNode;
			_nextNode = _nextNode.Next;
			return true;
		}
	}

	private sealed class BaggageLinkedList : IEnumerable<KeyValuePair<string, string>>, IEnumerable
	{
		private DiagNode<KeyValuePair<string, string>> _first;

		public DiagNode<KeyValuePair<string, string>> First => _first;

		public BaggageLinkedList(KeyValuePair<string, string> firstValue, bool set = false)
		{
			_first = ((set && firstValue.Value == null) ? null : new DiagNode<KeyValuePair<string, string>>(firstValue));
		}

		public void Add(KeyValuePair<string, string> value)
		{
			DiagNode<KeyValuePair<string, string>> diagNode = new DiagNode<KeyValuePair<string, string>>(value);
			lock (this)
			{
				diagNode.Next = _first;
				_first = diagNode;
			}
		}

		public void Set(KeyValuePair<string, string> value)
		{
			if (value.Value == null)
			{
				Remove(value.Key);
				return;
			}
			lock (this)
			{
				for (DiagNode<KeyValuePair<string, string>> diagNode = _first; diagNode != null; diagNode = diagNode.Next)
				{
					if (diagNode.Value.Key == value.Key)
					{
						diagNode.Value = value;
						return;
					}
				}
				DiagNode<KeyValuePair<string, string>> diagNode2 = new DiagNode<KeyValuePair<string, string>>(value);
				diagNode2.Next = _first;
				_first = diagNode2;
			}
		}

		public void Remove(string key)
		{
			lock (this)
			{
				if (_first == null)
				{
					return;
				}
				if (_first.Value.Key == key)
				{
					_first = _first.Next;
					return;
				}
				DiagNode<KeyValuePair<string, string>> diagNode = _first;
				while (diagNode.Next != null)
				{
					if (diagNode.Next.Value.Key == key)
					{
						diagNode.Next = diagNode.Next.Next;
						break;
					}
					diagNode = diagNode.Next;
				}
			}
		}

		public DiagEnumerator<KeyValuePair<string, string>> GetEnumerator()
		{
			return new DiagEnumerator<KeyValuePair<string, string>>(_first);
		}

		IEnumerator<KeyValuePair<string, string>> IEnumerable<KeyValuePair<string, string>>.GetEnumerator()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	internal sealed class TagsLinkedList : IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		private DiagNode<KeyValuePair<string, object>> _first;

		private DiagNode<KeyValuePair<string, object>> _last;

		private StringBuilder _stringBuilder;

		public DiagNode<KeyValuePair<string, object>> First => _first;

		public TagsLinkedList(KeyValuePair<string, object> firstValue, bool set = false)
		{
			_last = (_first = ((set && firstValue.Value == null) ? null : new DiagNode<KeyValuePair<string, object>>(firstValue)));
		}

		public TagsLinkedList(IEnumerator<KeyValuePair<string, object>> e)
		{
			_last = (_first = new DiagNode<KeyValuePair<string, object>>(e.Current));
			while (e.MoveNext())
			{
				_last.Next = new DiagNode<KeyValuePair<string, object>>(e.Current);
				_last = _last.Next;
			}
		}

		public TagsLinkedList(IEnumerable<KeyValuePair<string, object>> list)
		{
			Add(list);
		}

		public void Add(IEnumerable<KeyValuePair<string, object>> list)
		{
			IEnumerator<KeyValuePair<string, object>> enumerator = list.GetEnumerator();
			if (enumerator.MoveNext())
			{
				if (_first == null)
				{
					_last = (_first = new DiagNode<KeyValuePair<string, object>>(enumerator.Current));
				}
				else
				{
					_last.Next = new DiagNode<KeyValuePair<string, object>>(enumerator.Current);
					_last = _last.Next;
				}
				while (enumerator.MoveNext())
				{
					_last.Next = new DiagNode<KeyValuePair<string, object>>(enumerator.Current);
					_last = _last.Next;
				}
			}
		}

		public void Add(KeyValuePair<string, object> value)
		{
			DiagNode<KeyValuePair<string, object>> diagNode = new DiagNode<KeyValuePair<string, object>>(value);
			lock (this)
			{
				if (_first == null)
				{
					_first = (_last = diagNode);
					return;
				}
				_last.Next = diagNode;
				_last = diagNode;
			}
		}

		public object Get(string key)
		{
			for (DiagNode<KeyValuePair<string, object>> diagNode = _first; diagNode != null; diagNode = diagNode.Next)
			{
				if (diagNode.Value.Key == key)
				{
					return diagNode.Value.Value;
				}
			}
			return null;
		}

		public void Remove(string key)
		{
			lock (this)
			{
				if (_first == null)
				{
					return;
				}
				if (_first.Value.Key == key)
				{
					_first = _first.Next;
					if (_first == null)
					{
						_last = null;
					}
					return;
				}
				DiagNode<KeyValuePair<string, object>> diagNode = _first;
				while (diagNode.Next != null)
				{
					if (diagNode.Next.Value.Key == key)
					{
						if (_last == diagNode.Next)
						{
							_last = diagNode;
						}
						diagNode.Next = diagNode.Next.Next;
						break;
					}
					diagNode = diagNode.Next;
				}
			}
		}

		public void Set(KeyValuePair<string, object> value)
		{
			if (value.Value == null)
			{
				Remove(value.Key);
				return;
			}
			lock (this)
			{
				for (DiagNode<KeyValuePair<string, object>> diagNode = _first; diagNode != null; diagNode = diagNode.Next)
				{
					if (diagNode.Value.Key == value.Key)
					{
						diagNode.Value = value;
						return;
					}
				}
				DiagNode<KeyValuePair<string, object>> diagNode2 = new DiagNode<KeyValuePair<string, object>>(value);
				if (_first == null)
				{
					_first = (_last = diagNode2);
					return;
				}
				_last.Next = diagNode2;
				_last = diagNode2;
			}
		}

		public DiagEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			return new DiagEnumerator<KeyValuePair<string, object>>(_first);
		}

		IEnumerator<KeyValuePair<string, object>> IEnumerable<KeyValuePair<string, object>>.GetEnumerator()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public IEnumerable<KeyValuePair<string, string>> EnumerateStringValues()
		{
			for (DiagNode<KeyValuePair<string, object>> current = _first; current != null; current = current.Next)
			{
				if (current.Value.Value is string || current.Value.Value == null)
				{
					yield return new KeyValuePair<string, string>(current.Value.Key, (string)current.Value.Value);
				}
			}
		}

		public override string ToString()
		{
			lock (this)
			{
				if (_first == null)
				{
					return string.Empty;
				}
				if (_stringBuilder == null)
				{
					_stringBuilder = new StringBuilder();
				}
				_stringBuilder.Append(_first.Value.Key);
				_stringBuilder.Append(':');
				_stringBuilder.Append(_first.Value.Value);
				for (DiagNode<KeyValuePair<string, object>> next = _first.Next; next != null; next = next.Next)
				{
					_stringBuilder.Append(", ");
					_stringBuilder.Append(next.Value.Key);
					_stringBuilder.Append(':');
					_stringBuilder.Append(next.Value.Value);
				}
				string result = _stringBuilder.ToString();
				_stringBuilder.Clear();
				return result;
			}
		}
	}

	[Flags]
	private enum State : byte
	{
		None = 0,
		FormatUnknown = 0,
		FormatHierarchical = 1,
		FormatW3C = 2,
		FormatFlags = 3,
		IsStopped = 0x80
	}

	private sealed class TimeSync
	{
		public readonly DateTime SyncUtcNow = DateTime.UtcNow;

		public readonly long SyncStopwatchTicks = Stopwatch.GetTimestamp();
	}

	private static readonly IEnumerable<KeyValuePair<string, string>> s_emptyBaggageTags = new KeyValuePair<string, string>[0];

	private static readonly IEnumerable<KeyValuePair<string, object>> s_emptyTagObjects = new KeyValuePair<string, object>[0];

	private static readonly IEnumerable<ActivityLink> s_emptyLinks = new ActivityLink[0];

	private static readonly IEnumerable<ActivityEvent> s_emptyEvents = new ActivityEvent[0];

	private static readonly ActivitySource s_defaultSource = new ActivitySource(string.Empty);

	private const byte ActivityTraceFlagsIsSet = 128;

	private const int RequestIdMaxLength = 1024;

	private static readonly string s_uniqSuffix = "-" + GetRandomNumber().ToString("x") + ".";

	private static long s_currentRootId = (uint)GetRandomNumber();

	private static ActivityIdFormat s_defaultIdFormat;

	private string _traceState;

	private State _state;

	private int _currentChildId;

	private string _id;

	private string _rootId;

	private string _parentId;

	private string _parentSpanId;

	private string _traceId;

	private string _spanId;

	private byte _w3CIdFlags;

	private byte _parentTraceFlags;

	private TagsLinkedList _tags;

	private BaggageLinkedList _baggage;

	private DiagLinkedList<ActivityLink> _links;

	private DiagLinkedList<ActivityEvent> _events;

	private Dictionary<string, object> _customProperties;

	private string _displayName;

	private ActivityStatusCode _statusCode;

	private string _statusDescription;

	private Activity _previousActiveActivity;

	private static readonly AsyncLocal<Activity> s_current = new AsyncLocal<Activity>();

	private static TimeSync timeSync = new TimeSync();

	private static readonly Timer syncTimeUpdater = InitializeSyncTimer();

	public static bool ForceDefaultIdFormat { get; set; }

	public ActivityStatusCode Status => _statusCode;

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public string StatusDescription
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		get
		{
			return _statusDescription;
		}
	}

	public bool HasRemoteParent { get; private set; }

	public ActivityKind Kind { get; private set; }

	public string OperationName { get; }

	public string DisplayName
	{
		get
		{
			return _displayName ?? OperationName;
		}
		set
		{
			_displayName = value ?? throw new ArgumentNullException("value");
		}
	}

	public ActivitySource Source { get; private set; }

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public Activity Parent
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		get;
		private set; }

	public TimeSpan Duration { get; private set; }

	public DateTime StartTimeUtc { get; private set; }

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public string Id
	{
		[SecuritySafeCritical]
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		get
		{
			if (_id == null && _spanId != null)
			{
				Span<char> buffer = stackalloc char[2];
				System.HexConverter.ToCharsBuffer((byte)(-129 & _w3CIdFlags), buffer, 0, System.HexConverter.Casing.Lower);
				string value = "00-" + _traceId + "-" + _spanId + "-" + buffer.ToString();
				Interlocked.CompareExchange(ref _id, value, null);
			}
			return _id;
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public string ParentId
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		[SecuritySafeCritical]
		get
		{
			if (_parentId == null)
			{
				if (_parentSpanId != null)
				{
					Span<char> buffer = stackalloc char[2];
					System.HexConverter.ToCharsBuffer((byte)(-129 & _parentTraceFlags), buffer, 0, System.HexConverter.Casing.Lower);
					string value = "00-" + _traceId + "-" + _parentSpanId + "-" + buffer.ToString();
					Interlocked.CompareExchange(ref _parentId, value, null);
				}
				else if (Parent != null)
				{
					Interlocked.CompareExchange(ref _parentId, Parent.Id, null);
				}
			}
			return _parentId;
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public string RootId
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		get
		{
			if (_rootId == null)
			{
				string text = null;
				if (Id != null)
				{
					text = GetRootId(Id);
				}
				else if (ParentId != null)
				{
					text = GetRootId(ParentId);
				}
				if (text != null)
				{
					Interlocked.CompareExchange(ref _rootId, text, null);
				}
			}
			return _rootId;
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })]
	public IEnumerable<KeyValuePair<string, string>> Tags
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })]
		get
		{
			return _tags?.EnumerateStringValues() ?? s_emptyBaggageTags;
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })]
	public IEnumerable<KeyValuePair<string, object>> TagObjects
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })]
		get
		{
			IEnumerable<KeyValuePair<string, object>> tags = _tags;
			return tags ?? s_emptyTagObjects;
		}
	}

	public IEnumerable<ActivityEvent> Events
	{
		get
		{
			IEnumerable<ActivityEvent> events = _events;
			return events ?? s_emptyEvents;
		}
	}

	public IEnumerable<ActivityLink> Links
	{
		get
		{
			IEnumerable<ActivityLink> links = _links;
			return links ?? s_emptyLinks;
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })]
	public IEnumerable<KeyValuePair<string, string>> Baggage
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })]
		get
		{
			for (Activity activity2 = this; activity2 != null; activity2 = activity2.Parent)
			{
				if (activity2._baggage != null)
				{
					return Iterate(activity2);
				}
			}
			return s_emptyBaggageTags;
			static IEnumerable<KeyValuePair<string, string>> Iterate(Activity activity)
			{
				do
				{
					if (activity._baggage != null)
					{
						for (DiagNode<KeyValuePair<string, string>> current = activity._baggage.First; current != null; current = current.Next)
						{
							yield return current.Value;
						}
					}
					activity = activity.Parent;
				}
				while (activity != null);
			}
		}
	}

	public ActivityContext Context => new ActivityContext(TraceId, SpanId, ActivityTraceFlags, TraceStateString);

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public string TraceStateString
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		get
		{
			for (Activity activity = this; activity != null; activity = activity.Parent)
			{
				string traceState = activity._traceState;
				if (traceState != null)
				{
					return traceState;
				}
			}
			return null;
		}
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		set
		{
			_traceState = value;
		}
	}

	public ActivitySpanId SpanId
	{
		[SecuritySafeCritical]
		get
		{
			if (_spanId == null && _id != null && IdFormat == ActivityIdFormat.W3C)
			{
				string value = ActivitySpanId.CreateFromString(MemoryExtensions.AsSpan(_id, 36, 16)).ToHexString();
				Interlocked.CompareExchange(ref _spanId, value, null);
			}
			return new ActivitySpanId(_spanId);
		}
	}

	public ActivityTraceId TraceId
	{
		get
		{
			if (_traceId == null)
			{
				TrySetTraceIdFromParent();
			}
			return new ActivityTraceId(_traceId);
		}
	}

	public bool Recorded => (ActivityTraceFlags & ActivityTraceFlags.Recorded) != 0;

	public bool IsAllDataRequested { get; set; }

	public ActivityTraceFlags ActivityTraceFlags
	{
		get
		{
			if (!W3CIdFlagsSet)
			{
				TrySetTraceFlagsFromParent();
			}
			return (ActivityTraceFlags)(-129 & _w3CIdFlags);
		}
		set
		{
			_w3CIdFlags = (byte)(0x80 | (byte)value);
		}
	}

	public ActivitySpanId ParentSpanId
	{
		[SecuritySafeCritical]
		get
		{
			if (_parentSpanId == null)
			{
				string text = null;
				if (_parentId != null && IsW3CId(_parentId))
				{
					try
					{
						text = ActivitySpanId.CreateFromString(MemoryExtensions.AsSpan(_parentId, 36, 16)).ToHexString();
					}
					catch
					{
					}
				}
				else if (Parent != null && Parent.IdFormat == ActivityIdFormat.W3C)
				{
					text = Parent.SpanId.ToHexString();
				}
				if (text != null)
				{
					Interlocked.CompareExchange(ref _parentSpanId, text, null);
				}
			}
			return new ActivitySpanId(_parentSpanId);
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public static Func<ActivityTraceId> TraceIdGenerator
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		get;
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		set;
	}

	public static ActivityIdFormat DefaultIdFormat
	{
		get
		{
			if (s_defaultIdFormat == ActivityIdFormat.Unknown)
			{
				s_defaultIdFormat = ActivityIdFormat.Hierarchical;
			}
			return s_defaultIdFormat;
		}
		set
		{
			if (ActivityIdFormat.Hierarchical > value || value > ActivityIdFormat.W3C)
			{
				throw new ArgumentException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.ActivityIdFormatInvalid);
			}
			s_defaultIdFormat = value;
		}
	}

	private bool W3CIdFlagsSet => (_w3CIdFlags & 0x80) != 0;

	public bool IsStopped
	{
		get
		{
			return (_state & State.IsStopped) != 0;
		}
		private set
		{
			if (value)
			{
				_state |= State.IsStopped;
			}
			else
			{
				_state &= ~State.IsStopped;
			}
		}
	}

	public ActivityIdFormat IdFormat
	{
		get
		{
			return (ActivityIdFormat)(_state & State.FormatFlags);
		}
		private set
		{
			_state = (State)((uint)(_state & ~State.FormatFlags) | (uint)(byte)((byte)value & 3));
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public static Activity Current
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		get
		{
			return s_current.Value;
		}
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		set
		{
			if (ValidateSetCurrent(value))
			{
				SetCurrent(value);
			}
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	[method: <6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
	public static event EventHandler<ActivityChangedEventArgs> CurrentChanged;

	public Activity SetStatus(ActivityStatusCode code, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string description = null)
	{
		_statusCode = code;
		_statusDescription = ((code == ActivityStatusCode.Error) ? description : null);
		return this;
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })]
	public Enumerator<KeyValuePair<string, object>> EnumerateTagObjects()
	{
		return new Enumerator<KeyValuePair<string, object>>(_tags?.First);
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(0)]
	public Enumerator<ActivityEvent> EnumerateEvents()
	{
		return new Enumerator<ActivityEvent>(_events?.First);
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(0)]
	public Enumerator<ActivityLink> EnumerateLinks()
	{
		return new Enumerator<ActivityLink>(_links?.First);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public string GetBaggageItem(string key)
	{
		foreach (KeyValuePair<string, string> item in Baggage)
		{
			if (key == item.Key)
			{
				return item.Value;
			}
		}
		return null;
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public object GetTagItem(string key)
	{
		return _tags?.Get(key) ?? null;
	}

	public Activity(string operationName)
	{
		Source = s_defaultSource;
		IsAllDataRequested = true;
		if (string.IsNullOrEmpty(operationName))
		{
			NotifyError(new ArgumentException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.OperationNameInvalid));
		}
		OperationName = operationName;
	}

	public Activity AddTag(string key, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string value)
	{
		return AddTag(key, (object)value);
	}

	public Activity AddTag(string key, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object value)
	{
		KeyValuePair<string, object> keyValuePair = new KeyValuePair<string, object>(key, value);
		if (_tags != null || Interlocked.CompareExchange(ref _tags, new TagsLinkedList(keyValuePair), null) != null)
		{
			_tags.Add(keyValuePair);
		}
		return this;
	}

	public Activity SetTag(string key, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object value)
	{
		KeyValuePair<string, object> keyValuePair = new KeyValuePair<string, object>(key, value);
		if (_tags != null || Interlocked.CompareExchange(ref _tags, new TagsLinkedList(keyValuePair, set: true), null) != null)
		{
			_tags.Set(keyValuePair);
		}
		return this;
	}

	public Activity AddEvent(ActivityEvent e)
	{
		if (_events != null || Interlocked.CompareExchange(ref _events, new DiagLinkedList<ActivityEvent>(e), null) != null)
		{
			_events.Add(e);
		}
		return this;
	}

	public Activity AddBaggage(string key, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string value)
	{
		KeyValuePair<string, string> keyValuePair = new KeyValuePair<string, string>(key, value);
		if (_baggage != null || Interlocked.CompareExchange(ref _baggage, new BaggageLinkedList(keyValuePair), null) != null)
		{
			_baggage.Add(keyValuePair);
		}
		return this;
	}

	public Activity SetBaggage(string key, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string value)
	{
		KeyValuePair<string, string> keyValuePair = new KeyValuePair<string, string>(key, value);
		if (_baggage != null || Interlocked.CompareExchange(ref _baggage, new BaggageLinkedList(keyValuePair, set: true), null) != null)
		{
			_baggage.Set(keyValuePair);
		}
		return this;
	}

	public Activity SetParentId(string parentId)
	{
		if (Parent != null)
		{
			NotifyError(new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.SetParentIdOnActivityWithParent));
		}
		else if (ParentId != null || _parentSpanId != null)
		{
			NotifyError(new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.ParentIdAlreadySet));
		}
		else if (string.IsNullOrEmpty(parentId))
		{
			NotifyError(new ArgumentException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.ParentIdInvalid));
		}
		else
		{
			_parentId = parentId;
		}
		return this;
	}

	public Activity SetParentId(ActivityTraceId traceId, ActivitySpanId spanId, ActivityTraceFlags activityTraceFlags = ActivityTraceFlags.None)
	{
		if (Parent != null)
		{
			NotifyError(new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.SetParentIdOnActivityWithParent));
		}
		else if (ParentId != null || _parentSpanId != null)
		{
			NotifyError(new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.ParentIdAlreadySet));
		}
		else
		{
			_traceId = traceId.ToHexString();
			_parentSpanId = spanId.ToHexString();
			ActivityTraceFlags = activityTraceFlags;
			_parentTraceFlags = (byte)activityTraceFlags;
		}
		return this;
	}

	public Activity SetStartTime(DateTime startTimeUtc)
	{
		if (startTimeUtc.Kind != DateTimeKind.Utc)
		{
			NotifyError(new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.StartTimeNotUtc));
		}
		else
		{
			StartTimeUtc = startTimeUtc;
		}
		return this;
	}

	public Activity SetEndTime(DateTime endTimeUtc)
	{
		if (endTimeUtc.Kind != DateTimeKind.Utc)
		{
			NotifyError(new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.EndTimeNotUtc));
		}
		else
		{
			Duration = endTimeUtc - StartTimeUtc;
			if (Duration.Ticks <= 0)
			{
				Duration = new TimeSpan(1L);
			}
		}
		return this;
	}

	public Activity Start()
	{
		if (_id != null || _spanId != null)
		{
			NotifyError(new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.ActivityStartAlreadyStarted));
		}
		else
		{
			_previousActiveActivity = Current;
			if (_parentId == null && _parentSpanId == null && _previousActiveActivity != null)
			{
				Parent = _previousActiveActivity;
			}
			if (StartTimeUtc == default(DateTime))
			{
				StartTimeUtc = GetUtcNow();
			}
			if (IdFormat == ActivityIdFormat.Unknown)
			{
				IdFormat = (ForceDefaultIdFormat ? DefaultIdFormat : ((Parent != null) ? Parent.IdFormat : ((_parentSpanId != null) ? ActivityIdFormat.W3C : ((_parentId == null) ? DefaultIdFormat : ((!IsW3CId(_parentId)) ? ActivityIdFormat.Hierarchical : ActivityIdFormat.W3C)))));
			}
			if (IdFormat == ActivityIdFormat.W3C)
			{
				GenerateW3CId();
			}
			else
			{
				_id = GenerateHierarchicalId();
			}
			SetCurrent(this);
			Source.NotifyActivityStart(this);
		}
		return this;
	}

	public void Stop()
	{
		if (_id == null && _spanId == null)
		{
			NotifyError(new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.ActivityNotStarted));
		}
		else if (!IsStopped)
		{
			IsStopped = true;
			if (Duration == TimeSpan.Zero)
			{
				SetEndTime(GetUtcNow());
			}
			Source.NotifyActivityStop(this);
			SetCurrent(_previousActiveActivity);
		}
	}

	public Activity SetIdFormat(ActivityIdFormat format)
	{
		if (_id != null || _spanId != null)
		{
			NotifyError(new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.SetFormatOnStartedActivity));
		}
		else
		{
			IdFormat = format;
		}
		return this;
	}

	private static bool IsW3CId(string id)
	{
		if (id.Length == 55 && (('0' <= id[0] && id[0] <= '9') || ('a' <= id[0] && id[0] <= 'f')) && (('0' <= id[1] && id[1] <= '9') || ('a' <= id[1] && id[1] <= 'f')))
		{
			if (id[0] == 'f')
			{
				return id[1] != 'f';
			}
			return true;
		}
		return false;
	}

	[SecuritySafeCritical]
	internal static bool TryConvertIdToContext(string traceParent, string traceState, bool isRemote, out ActivityContext context)
	{
		context = default(ActivityContext);
		if (!IsW3CId(traceParent))
		{
			return false;
		}
		ReadOnlySpan<char> idData = MemoryExtensions.AsSpan(traceParent, 3, 32);
		ReadOnlySpan<char> idData2 = MemoryExtensions.AsSpan(traceParent, 36, 16);
		if (!ActivityTraceId.IsLowerCaseHexAndNotAllZeros(idData) || !ActivityTraceId.IsLowerCaseHexAndNotAllZeros(idData2) || !System.HexConverter.IsHexLowerChar(traceParent[53]) || !System.HexConverter.IsHexLowerChar(traceParent[54]))
		{
			return false;
		}
		context = new ActivityContext(new ActivityTraceId(idData.ToString()), new ActivitySpanId(idData2.ToString()), (ActivityTraceFlags)ActivityTraceId.HexByteFromChars(traceParent[53], traceParent[54]), traceState, isRemote);
		return true;
	}

	public void Dispose()
	{
		if (!IsStopped)
		{
			Stop();
		}
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	protected virtual void Dispose(bool disposing)
	{
	}

	public void SetCustomProperty(string propertyName, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object propertyValue)
	{
		if (_customProperties == null)
		{
			Interlocked.CompareExchange(ref _customProperties, new Dictionary<string, object>(), null);
		}
		lock (_customProperties)
		{
			if (propertyValue == null)
			{
				_customProperties.Remove(propertyName);
			}
			else
			{
				_customProperties[propertyName] = propertyValue;
			}
		}
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public object GetCustomProperty(string propertyName)
	{
		if (_customProperties == null)
		{
			return null;
		}
		lock (_customProperties)
		{
			object value;
			return _customProperties.TryGetValue(propertyName, out value) ? value : null;
		}
	}

	internal static Activity Create(ActivitySource source, string name, ActivityKind kind, string parentId, ActivityContext parentContext, IEnumerable<KeyValuePair<string, object>> tags, IEnumerable<ActivityLink> links, DateTimeOffset startTime, ActivityTagsCollection samplerTags, ActivitySamplingResult request, bool startIt, ActivityIdFormat idFormat, string traceState)
	{
		Activity activity = new Activity(name);
		activity.Source = source;
		activity.Kind = kind;
		activity.IdFormat = idFormat;
		activity._traceState = traceState;
		if (links != null)
		{
			using IEnumerator<ActivityLink> enumerator = links.GetEnumerator();
			if (enumerator.MoveNext())
			{
				activity._links = new DiagLinkedList<ActivityLink>(enumerator);
			}
		}
		if (tags != null)
		{
			using IEnumerator<KeyValuePair<string, object>> enumerator2 = tags.GetEnumerator();
			if (enumerator2.MoveNext())
			{
				activity._tags = new TagsLinkedList(enumerator2);
			}
		}
		if (samplerTags != null)
		{
			if (activity._tags == null)
			{
				activity._tags = new TagsLinkedList(samplerTags);
			}
			else
			{
				activity._tags.Add(samplerTags);
			}
		}
		if (parentId != null)
		{
			activity._parentId = parentId;
		}
		else if (parentContext != default(ActivityContext))
		{
			activity._traceId = parentContext.TraceId.ToString();
			if (parentContext.SpanId != default(ActivitySpanId))
			{
				activity._parentSpanId = parentContext.SpanId.ToString();
			}
			activity.ActivityTraceFlags = parentContext.TraceFlags;
			activity._parentTraceFlags = (byte)parentContext.TraceFlags;
			activity.HasRemoteParent = parentContext.IsRemote;
		}
		activity.IsAllDataRequested = request == ActivitySamplingResult.AllData || request == ActivitySamplingResult.AllDataAndRecorded;
		if (request == ActivitySamplingResult.AllDataAndRecorded)
		{
			activity.ActivityTraceFlags |= ActivityTraceFlags.Recorded;
		}
		if (startTime != default(DateTimeOffset))
		{
			activity.StartTimeUtc = startTime.UtcDateTime;
		}
		if (startIt)
		{
			activity.Start();
		}
		return activity;
	}

	private void GenerateW3CId()
	{
		if (_traceId == null && !TrySetTraceIdFromParent())
		{
			_traceId = (TraceIdGenerator?.Invoke() ?? ActivityTraceId.CreateRandom()).ToHexString();
		}
		if (!W3CIdFlagsSet)
		{
			TrySetTraceFlagsFromParent();
		}
		_spanId = ActivitySpanId.CreateRandom().ToHexString();
	}

	private static void NotifyError(Exception exception)
	{
		try
		{
			throw exception;
		}
		catch
		{
		}
	}

	private string GenerateHierarchicalId()
	{
		if (Parent != null)
		{
			return AppendSuffix(Parent.Id, Interlocked.Increment(ref Parent._currentChildId).ToString(), '.');
		}
		if (ParentId != null)
		{
			string text = ((ParentId[0] == '|') ? ParentId : ("|" + ParentId));
			char c = text[text.Length - 1];
			if (c != '.' && c != '_')
			{
				text += ".";
			}
			return AppendSuffix(text, Interlocked.Increment(ref s_currentRootId).ToString("x"), '_');
		}
		return GenerateRootId();
	}

	private string GetRootId(string id)
	{
		if (IdFormat == ActivityIdFormat.W3C)
		{
			return id.Substring(3, 32);
		}
		int num = id.IndexOf('.');
		if (num < 0)
		{
			num = id.Length;
		}
		int num2 = ((id[0] == '|') ? 1 : 0);
		return id.Substring(num2, num - num2);
	}

	private string AppendSuffix(string parentId, string suffix, char delimiter)
	{
		if (parentId.Length + suffix.Length < 1024)
		{
			return parentId + suffix + delimiter;
		}
		int num = 1015;
		while (num > 1 && parentId[num - 1] != '.' && parentId[num - 1] != '_')
		{
			num--;
		}
		if (num == 1)
		{
			return GenerateRootId();
		}
		string text = ((int)GetRandomNumber()).ToString("x8");
		return parentId.Substring(0, num) + text + "#";
	}

	[SecuritySafeCritical]
	private unsafe static long GetRandomNumber()
	{
		Guid guid = Guid.NewGuid();
		return *(long*)(&guid);
	}

	private static bool ValidateSetCurrent(Activity activity)
	{
		bool flag = activity == null || (activity.Id != null && !activity.IsStopped);
		if (!flag)
		{
			NotifyError(new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.ActivityNotRunning));
		}
		return flag;
	}

	[SecuritySafeCritical]
	private bool TrySetTraceIdFromParent()
	{
		if (Parent != null && Parent.IdFormat == ActivityIdFormat.W3C)
		{
			_traceId = Parent.TraceId.ToHexString();
		}
		else if (_parentId != null && IsW3CId(_parentId))
		{
			try
			{
				_traceId = ActivityTraceId.CreateFromString(MemoryExtensions.AsSpan(_parentId, 3, 32)).ToHexString();
			}
			catch
			{
			}
		}
		return _traceId != null;
	}

	[SecuritySafeCritical]
	private void TrySetTraceFlagsFromParent()
	{
		if (W3CIdFlagsSet)
		{
			return;
		}
		if (Parent != null)
		{
			ActivityTraceFlags = Parent.ActivityTraceFlags;
		}
		else if (_parentId != null && IsW3CId(_parentId))
		{
			if (System.HexConverter.IsHexLowerChar(_parentId[53]) && System.HexConverter.IsHexLowerChar(_parentId[54]))
			{
				_w3CIdFlags = (byte)(ActivityTraceId.HexByteFromChars(_parentId[53], _parentId[54]) | 0x80);
			}
			else
			{
				_w3CIdFlags = 128;
			}
		}
	}

	private static void SetCurrent(Activity activity)
	{
		EventHandler<ActivityChangedEventArgs> currentChanged = Activity.CurrentChanged;
		if (currentChanged == null)
		{
			s_current.Value = activity;
			return;
		}
		Activity value = s_current.Value;
		s_current.Value = activity;
		currentChanged(null, new ActivityChangedEventArgs(value, activity));
	}

	private static string GenerateRootId()
	{
		return "|" + Interlocked.Increment(ref s_currentRootId).ToString("x") + s_uniqSuffix;
	}

	internal static DateTime GetUtcNow()
	{
		TimeSync timeSync = Activity.timeSync;
		long value = (long)((double)((Stopwatch.GetTimestamp() - timeSync.SyncStopwatchTicks) * 10000000) / (double)Stopwatch.Frequency);
		DateTime syncUtcNow = timeSync.SyncUtcNow;
		return syncUtcNow.AddTicks(value);
	}

	private static void Sync()
	{
		Thread.Sleep(1);
		timeSync = new TimeSync();
	}

	[SecuritySafeCritical]
	private static Timer InitializeSyncTimer()
	{
		bool flag = false;
		try
		{
			if (!ExecutionContext.IsFlowSuppressed())
			{
				ExecutionContext.SuppressFlow();
				flag = true;
			}
			return new Timer(delegate
			{
				Sync();
			}, null, 0, 7200000);
		}
		finally
		{
			if (flag)
			{
				ExecutionContext.RestoreFlow();
			}
		}
	}
}


using System.ComponentModel;
using System.Runtime.CompilerServices;

[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
public struct Enumerator<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] T>
{
	private static readonly DiagNode<T> s_Empty = new DiagNode<T>(default(T));

	private DiagNode<T> _nextNode;

	private DiagNode<T> _currentNode;

	public ref T Current
	{
		[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
		get
		{
			return ref _currentNode.Value;
		}
	}

	internal Enumerator(DiagNode<T> head)
	{
		_nextNode = head;
		_currentNode = s_Empty;
	}

	[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
	[EditorBrowsable(EditorBrowsableState.Never)]
	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1 })]
	public Enumerator<T> GetEnumerator()
	{
		return this;
	}

	public bool MoveNext()
	{
		if (_nextNode == null)
		{
			_currentNode = s_Empty;
			return false;
		}
		_currentNode = _nextNode;
		_nextNode = _nextNode.Next;
		return true;
	}
}


using System.Collections;
using System.Collections.Generic;

private sealed class BaggageLinkedList : IEnumerable<KeyValuePair<string, string>>, IEnumerable
{
	private DiagNode<KeyValuePair<string, string>> _first;

	public DiagNode<KeyValuePair<string, string>> First => _first;

	public BaggageLinkedList(KeyValuePair<string, string> firstValue, bool set = false)
	{
		_first = ((set && firstValue.Value == null) ? null : new DiagNode<KeyValuePair<string, string>>(firstValue));
	}

	public void Add(KeyValuePair<string, string> value)
	{
		DiagNode<KeyValuePair<string, string>> diagNode = new DiagNode<KeyValuePair<string, string>>(value);
		lock (this)
		{
			diagNode.Next = _first;
			_first = diagNode;
		}
	}

	public void Set(KeyValuePair<string, string> value)
	{
		if (value.Value == null)
		{
			Remove(value.Key);
			return;
		}
		lock (this)
		{
			for (DiagNode<KeyValuePair<string, string>> diagNode = _first; diagNode != null; diagNode = diagNode.Next)
			{
				if (diagNode.Value.Key == value.Key)
				{
					diagNode.Value = value;
					return;
				}
			}
			DiagNode<KeyValuePair<string, string>> diagNode2 = new DiagNode<KeyValuePair<string, string>>(value);
			diagNode2.Next = _first;
			_first = diagNode2;
		}
	}

	public void Remove(string key)
	{
		lock (this)
		{
			if (_first == null)
			{
				return;
			}
			if (_first.Value.Key == key)
			{
				_first = _first.Next;
				return;
			}
			DiagNode<KeyValuePair<string, string>> diagNode = _first;
			while (diagNode.Next != null)
			{
				if (diagNode.Next.Value.Key == key)
				{
					diagNode.Next = diagNode.Next.Next;
					break;
				}
				diagNode = diagNode.Next;
			}
		}
	}

	public DiagEnumerator<KeyValuePair<string, string>> GetEnumerator()
	{
		return new DiagEnumerator<KeyValuePair<string, string>>(_first);
	}

	IEnumerator<KeyValuePair<string, string>> IEnumerable<KeyValuePair<string, string>>.GetEnumerator()
	{
		return GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Text;

internal sealed class TagsLinkedList : IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	private DiagNode<KeyValuePair<string, object>> _first;

	private DiagNode<KeyValuePair<string, object>> _last;

	private StringBuilder _stringBuilder;

	public DiagNode<KeyValuePair<string, object>> First => _first;

	public TagsLinkedList(KeyValuePair<string, object> firstValue, bool set = false)
	{
		_last = (_first = ((set && firstValue.Value == null) ? null : new DiagNode<KeyValuePair<string, object>>(firstValue)));
	}

	public TagsLinkedList(IEnumerator<KeyValuePair<string, object>> e)
	{
		_last = (_first = new DiagNode<KeyValuePair<string, object>>(e.Current));
		while (e.MoveNext())
		{
			_last.Next = new DiagNode<KeyValuePair<string, object>>(e.Current);
			_last = _last.Next;
		}
	}

	public TagsLinkedList(IEnumerable<KeyValuePair<string, object>> list)
	{
		Add(list);
	}

	public void Add(IEnumerable<KeyValuePair<string, object>> list)
	{
		IEnumerator<KeyValuePair<string, object>> enumerator = list.GetEnumerator();
		if (enumerator.MoveNext())
		{
			if (_first == null)
			{
				_last = (_first = new DiagNode<KeyValuePair<string, object>>(enumerator.Current));
			}
			else
			{
				_last.Next = new DiagNode<KeyValuePair<string, object>>(enumerator.Current);
				_last = _last.Next;
			}
			while (enumerator.MoveNext())
			{
				_last.Next = new DiagNode<KeyValuePair<string, object>>(enumerator.Current);
				_last = _last.Next;
			}
		}
	}

	public void Add(KeyValuePair<string, object> value)
	{
		DiagNode<KeyValuePair<string, object>> diagNode = new DiagNode<KeyValuePair<string, object>>(value);
		lock (this)
		{
			if (_first == null)
			{
				_first = (_last = diagNode);
				return;
			}
			_last.Next = diagNode;
			_last = diagNode;
		}
	}

	public object Get(string key)
	{
		for (DiagNode<KeyValuePair<string, object>> diagNode = _first; diagNode != null; diagNode = diagNode.Next)
		{
			if (diagNode.Value.Key == key)
			{
				return diagNode.Value.Value;
			}
		}
		return null;
	}

	public void Remove(string key)
	{
		lock (this)
		{
			if (_first == null)
			{
				return;
			}
			if (_first.Value.Key == key)
			{
				_first = _first.Next;
				if (_first == null)
				{
					_last = null;
				}
				return;
			}
			DiagNode<KeyValuePair<string, object>> diagNode = _first;
			while (diagNode.Next != null)
			{
				if (diagNode.Next.Value.Key == key)
				{
					if (_last == diagNode.Next)
					{
						_last = diagNode;
					}
					diagNode.Next = diagNode.Next.Next;
					break;
				}
				diagNode = diagNode.Next;
			}
		}
	}

	public void Set(KeyValuePair<string, object> value)
	{
		if (value.Value == null)
		{
			Remove(value.Key);
			return;
		}
		lock (this)
		{
			for (DiagNode<KeyValuePair<string, object>> diagNode = _first; diagNode != null; diagNode = diagNode.Next)
			{
				if (diagNode.Value.Key == value.Key)
				{
					diagNode.Value = value;
					return;
				}
			}
			DiagNode<KeyValuePair<string, object>> diagNode2 = new DiagNode<KeyValuePair<string, object>>(value);
			if (_first == null)
			{
				_first = (_last = diagNode2);
				return;
			}
			_last.Next = diagNode2;
			_last = diagNode2;
		}
	}

	public DiagEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		return new DiagEnumerator<KeyValuePair<string, object>>(_first);
	}

	IEnumerator<KeyValuePair<string, object>> IEnumerable<KeyValuePair<string, object>>.GetEnumerator()
	{
		return GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public IEnumerable<KeyValuePair<string, string>> EnumerateStringValues()
	{
		for (DiagNode<KeyValuePair<string, object>> current = _first; current != null; current = current.Next)
		{
			if (current.Value.Value is string || current.Value.Value == null)
			{
				yield return new KeyValuePair<string, string>(current.Value.Key, (string)current.Value.Value);
			}
		}
	}

	public override string ToString()
	{
		lock (this)
		{
			if (_first == null)
			{
				return string.Empty;
			}
			if (_stringBuilder == null)
			{
				_stringBuilder = new StringBuilder();
			}
			_stringBuilder.Append(_first.Value.Key);
			_stringBuilder.Append(':');
			_stringBuilder.Append(_first.Value.Value);
			for (DiagNode<KeyValuePair<string, object>> next = _first.Next; next != null; next = next.Next)
			{
				_stringBuilder.Append(", ");
				_stringBuilder.Append(next.Value.Key);
				_stringBuilder.Append(':');
				_stringBuilder.Append(next.Value.Value);
			}
			string result = _stringBuilder.ToString();
			_stringBuilder.Clear();
			return result;
		}
	}
}


[Flags]
private enum State : byte
{
	None = 0,
	FormatUnknown = 0,
	FormatHierarchical = 1,
	FormatW3C = 2,
	FormatFlags = 3,
	IsStopped = 0x80
}


private sealed class TimeSync
{
	public readonly DateTime SyncUtcNow = DateTime.UtcNow;

	public readonly long SyncStopwatchTicks = Stopwatch.GetTimestamp();
}


using System;

[Flags]
internal enum ActivityTraceFlags
{
	None = 0,
	Recorded = 1
}


internal enum ActivityIdFormat
{
	Unknown,
	Hierarchical,
	W3C
}


using System;
using System.Buffers.Binary;
using System.Buffers.Text;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;

[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
[SecuritySafeCritical]
internal struct ActivityTraceId : IEquatable<ActivityTraceId>
{
	private readonly string _hexString;

	internal ActivityTraceId(string hexString)
	{
		_hexString = hexString;
	}

	public static ActivityTraceId CreateRandom()
	{
		Span<byte> span = stackalloc byte[16];
		SetToRandomBytes(span);
		return CreateFromBytes(span);
	}

	public static ActivityTraceId CreateFromBytes(ReadOnlySpan<byte> idData)
	{
		if (idData.Length != 16)
		{
			throw new ArgumentOutOfRangeException("idData");
		}
		return new ActivityTraceId(System.HexConverter.ToString(idData, System.HexConverter.Casing.Lower));
	}

	public static ActivityTraceId CreateFromUtf8String(ReadOnlySpan<byte> idData)
	{
		return new ActivityTraceId(idData);
	}

	public static ActivityTraceId CreateFromString(ReadOnlySpan<char> idData)
	{
		if (idData.Length != 32 || !IsLowerCaseHexAndNotAllZeros(idData))
		{
			throw new ArgumentOutOfRangeException("idData");
		}
		return new ActivityTraceId(idData.ToString());
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	public string ToHexString()
	{
		return _hexString ?? "00000000000000000000000000000000";
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	public override string ToString()
	{
		return ToHexString();
	}

	public static bool operator ==(ActivityTraceId traceId1, ActivityTraceId traceId2)
	{
		return traceId1._hexString == traceId2._hexString;
	}

	public static bool operator !=(ActivityTraceId traceId1, ActivityTraceId traceId2)
	{
		return traceId1._hexString != traceId2._hexString;
	}

	public bool Equals(ActivityTraceId traceId)
	{
		return _hexString == traceId._hexString;
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
	public override bool Equals([<8138f099-db66-4e8d-a0f5-5476a41f5864>NotNullWhen(true)] object obj)
	{
		if (obj is ActivityTraceId activityTraceId)
		{
			return _hexString == activityTraceId._hexString;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return ToHexString().GetHashCode();
	}

	private ActivityTraceId(ReadOnlySpan<byte> idData)
	{
		if (idData.Length != 32)
		{
			throw new ArgumentOutOfRangeException("idData");
		}
		Span<ulong> span = stackalloc ulong[2];
		if (!Utf8Parser.TryParse(idData.Slice(0, 16), out span[0], out int bytesConsumed, 'x'))
		{
			_hexString = CreateRandom()._hexString;
			return;
		}
		if (!Utf8Parser.TryParse(idData.Slice(16, 16), out span[1], out bytesConsumed, 'x'))
		{
			_hexString = CreateRandom()._hexString;
			return;
		}
		if (BitConverter.IsLittleEndian)
		{
			span[0] = BinaryPrimitives.ReverseEndianness(span[0]);
			span[1] = BinaryPrimitives.ReverseEndianness(span[1]);
		}
		_hexString = System.HexConverter.ToString(MemoryMarshal.AsBytes(span), System.HexConverter.Casing.Lower);
	}

	public void CopyTo(Span<byte> destination)
	{
		SetSpanFromHexChars(MemoryExtensions.AsSpan(ToHexString()), destination);
	}

	internal static void SetToRandomBytes(Span<byte> outBytes)
	{
		RandomNumberGenerator current = RandomNumberGenerator.Current;
		Unsafe.WriteUnaligned(ref outBytes[0], current.Next());
		if (outBytes.Length == 16)
		{
			Unsafe.WriteUnaligned(ref outBytes[8], current.Next());
		}
	}

	internal static void SetSpanFromHexChars(ReadOnlySpan<char> charData, Span<byte> outBytes)
	{
		for (int i = 0; i < outBytes.Length; i++)
		{
			outBytes[i] = HexByteFromChars(charData[i * 2], charData[i * 2 + 1]);
		}
	}

	internal static byte HexByteFromChars(char char1, char char2)
	{
		int num = System.HexConverter.FromLowerChar(char1);
		int num2 = System.HexConverter.FromLowerChar(char2);
		if ((num | num2) == 255)
		{
			throw new ArgumentOutOfRangeException("idData");
		}
		return (byte)((num << 4) | num2);
	}

	internal static bool IsLowerCaseHexAndNotAllZeros(ReadOnlySpan<char> idData)
	{
		bool result = false;
		for (int i = 0; i < idData.Length; i++)
		{
			char c = idData[i];
			if (!System.HexConverter.IsHexLowerChar(c))
			{
				return false;
			}
			if (c != '0')
			{
				result = true;
			}
		}
		return result;
	}
}


using System;
using System.Buffers.Binary;
using System.Buffers.Text;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Security;

[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
[SecuritySafeCritical]
internal struct ActivitySpanId : IEquatable<ActivitySpanId>
{
	private readonly string _hexString;

	internal ActivitySpanId(string hexString)
	{
		_hexString = hexString;
	}

	public unsafe static ActivitySpanId CreateRandom()
	{
		ulong num = default(ulong);
		ActivityTraceId.SetToRandomBytes(new Span<byte>(&num, 8));
		return new ActivitySpanId(System.HexConverter.ToString(new ReadOnlySpan<byte>(&num, 8), System.HexConverter.Casing.Lower));
	}

	public static ActivitySpanId CreateFromBytes(ReadOnlySpan<byte> idData)
	{
		if (idData.Length != 8)
		{
			throw new ArgumentOutOfRangeException("idData");
		}
		return new ActivitySpanId(System.HexConverter.ToString(idData, System.HexConverter.Casing.Lower));
	}

	public static ActivitySpanId CreateFromUtf8String(ReadOnlySpan<byte> idData)
	{
		return new ActivitySpanId(idData);
	}

	public static ActivitySpanId CreateFromString(ReadOnlySpan<char> idData)
	{
		if (idData.Length != 16 || !ActivityTraceId.IsLowerCaseHexAndNotAllZeros(idData))
		{
			throw new ArgumentOutOfRangeException("idData");
		}
		return new ActivitySpanId(idData.ToString());
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	public string ToHexString()
	{
		return _hexString ?? "0000000000000000";
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	public override string ToString()
	{
		return ToHexString();
	}

	public static bool operator ==(ActivitySpanId spanId1, ActivitySpanId spandId2)
	{
		return spanId1._hexString == spandId2._hexString;
	}

	public static bool operator !=(ActivitySpanId spanId1, ActivitySpanId spandId2)
	{
		return spanId1._hexString != spandId2._hexString;
	}

	public bool Equals(ActivitySpanId spanId)
	{
		return _hexString == spanId._hexString;
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
	public override bool Equals([<8138f099-db66-4e8d-a0f5-5476a41f5864>NotNullWhen(true)] object obj)
	{
		if (obj is ActivitySpanId activitySpanId)
		{
			return _hexString == activitySpanId._hexString;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return ToHexString().GetHashCode();
	}

	private unsafe ActivitySpanId(ReadOnlySpan<byte> idData)
	{
		if (idData.Length != 16)
		{
			throw new ArgumentOutOfRangeException("idData");
		}
		if (!Utf8Parser.TryParse(idData, out ulong value, out int _, 'x'))
		{
			_hexString = CreateRandom()._hexString;
			return;
		}
		if (BitConverter.IsLittleEndian)
		{
			value = BinaryPrimitives.ReverseEndianness(value);
		}
		_hexString = System.HexConverter.ToString(new ReadOnlySpan<byte>(&value, 8), System.HexConverter.Casing.Lower);
	}

	public void CopyTo(Span<byte> destination)
	{
		ActivityTraceId.SetSpanFromHexChars(MemoryExtensions.AsSpan(ToHexString()), destination);
	}
}


internal enum ActivityStatusCode
{
	Unset,
	Ok,
	Error
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;

[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
internal class ActivityTagsCollection : IDictionary<string, object>, ICollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(0)]
	public struct Enumerator : IEnumerator<KeyValuePair<string, object>>, IDisposable, IEnumerator
	{
		private List<KeyValuePair<string, object>>.Enumerator _enumerator;

		[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })]
		public KeyValuePair<string, object> Current
		{
			[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })]
			get
			{
				return _enumerator.Current;
			}
		}

		[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)]
		object IEnumerator.Current => ((IEnumerator)_enumerator).Current;

		internal Enumerator(List<KeyValuePair<string, object>> list)
		{
			_enumerator = list.GetEnumerator();
		}

		public void Dispose()
		{
			_enumerator.Dispose();
		}

		public bool MoveNext()
		{
			return _enumerator.MoveNext();
		}

		void IEnumerator.Reset()
		{
			((IEnumerator)_enumerator).Reset();
		}
	}

	private List<KeyValuePair<string, object>> _list = new List<KeyValuePair<string, object>>();

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public object this[string key]
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
		get
		{
			int num = FindIndex(key);
			if (num >= 0)
			{
				return _list[num].Value;
			}
			return null;
		}
		[param: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
		set
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			int num = FindIndex(key);
			if (value == null)
			{
				if (num >= 0)
				{
					_list.RemoveAt(num);
				}
			}
			else if (num >= 0)
			{
				_list[num] = new KeyValuePair<string, object>(key, value);
			}
			else
			{
				_list.Add(new KeyValuePair<string, object>(key, value));
			}
		}
	}

	public ICollection<string> Keys
	{
		get
		{
			List<string> list = new List<string>(_list.Count);
			foreach (KeyValuePair<string, object> item in _list)
			{
				list.Add(item.Key);
			}
			return list;
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 2 })]
	public ICollection<object> Values
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 2 })]
		get
		{
			List<object> list = new List<object>(_list.Count);
			foreach (KeyValuePair<string, object> item in _list)
			{
				list.Add(item.Value);
			}
			return list;
		}
	}

	public bool IsReadOnly => false;

	public int Count => _list.Count;

	public ActivityTagsCollection()
	{
	}

	public ActivityTagsCollection([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })] IEnumerable<KeyValuePair<string, object>> list)
	{
		if (list == null)
		{
			throw new ArgumentNullException("list");
		}
		foreach (KeyValuePair<string, object> item in list)
		{
			if (item.Key != null)
			{
				this[item.Key] = item.Value;
			}
		}
	}

	public void Add(string key, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object value)
	{
		if (key == null)
		{
			throw new ArgumentNullException("key");
		}
		int num = FindIndex(key);
		if (num >= 0)
		{
			throw new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.Format(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.KeyAlreadyExist, key));
		}
		_list.Add(new KeyValuePair<string, object>(key, value));
	}

	public void Add([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> item)
	{
		if (item.Key == null)
		{
			throw new ArgumentNullException("item");
		}
		int num = FindIndex(item.Key);
		if (num >= 0)
		{
			throw new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.Format(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.KeyAlreadyExist, item.Key));
		}
		_list.Add(item);
	}

	public void Clear()
	{
		_list.Clear();
	}

	public bool Contains([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> item)
	{
		return _list.Contains(item);
	}

	public bool ContainsKey(string key)
	{
		return FindIndex(key) >= 0;
	}

	public void CopyTo([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })] KeyValuePair<string, object>[] array, int arrayIndex)
	{
		_list.CopyTo(array, arrayIndex);
	}

	IEnumerator<KeyValuePair<string, object>> IEnumerable<KeyValuePair<string, object>>.GetEnumerator()
	{
		return new Enumerator(_list);
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(_list);
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return new Enumerator(_list);
	}

	public bool Remove(string key)
	{
		if (key == null)
		{
			throw new ArgumentNullException("key");
		}
		int num = FindIndex(key);
		if (num >= 0)
		{
			_list.RemoveAt(num);
			return true;
		}
		return false;
	}

	public bool Remove([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> item)
	{
		return _list.Remove(item);
	}

	public bool TryGetValue(string key, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] out object value)
	{
		int num = FindIndex(key);
		if (num >= 0)
		{
			value = _list[num].Value;
			return true;
		}
		value = null;
		return false;
	}

	private int FindIndex(string key)
	{
		for (int i = 0; i < _list.Count; i++)
		{
			if (_list[i].Key == key)
			{
				return i;
			}
		}
		return -1;
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(0)]
public struct Enumerator : IEnumerator<KeyValuePair<string, object>>, IDisposable, IEnumerator
{
	private List<KeyValuePair<string, object>>.Enumerator _enumerator;

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })]
	public KeyValuePair<string, object> Current
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })]
		get
		{
			return _enumerator.Current;
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)]
	object IEnumerator.Current => ((IEnumerator)_enumerator).Current;

	internal Enumerator(List<KeyValuePair<string, object>> list)
	{
		_enumerator = list.GetEnumerator();
	}

	public void Dispose()
	{
		_enumerator.Dispose();
	}

	public bool MoveNext()
	{
		return _enumerator.MoveNext();
	}

	void IEnumerator.Reset()
	{
		((IEnumerator)_enumerator).Reset();
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
internal struct ActivityContext : IEquatable<ActivityContext>
{
	public ActivityTraceId TraceId { get; }

	public ActivitySpanId SpanId { get; }

	public ActivityTraceFlags TraceFlags { get; }

	public string TraceState { get; }

	public bool IsRemote { get; }

	public ActivityContext(ActivityTraceId traceId, ActivitySpanId spanId, ActivityTraceFlags traceFlags, string traceState = null, bool isRemote = false)
	{
		TraceId = traceId;
		SpanId = spanId;
		TraceFlags = traceFlags;
		TraceState = traceState;
		IsRemote = isRemote;
	}

	public static bool TryParse(string traceParent, string traceState, bool isRemote, out ActivityContext context)
	{
		if (traceParent == null)
		{
			context = default(ActivityContext);
			return false;
		}
		return Activity.TryConvertIdToContext(traceParent, traceState, isRemote, out context);
	}

	public static bool TryParse(string traceParent, string traceState, out ActivityContext context)
	{
		return TryParse(traceParent, traceState, isRemote: false, out context);
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	public static ActivityContext Parse(string traceParent, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string traceState)
	{
		if (traceParent == null)
		{
			throw new ArgumentNullException("traceParent");
		}
		if (!Activity.TryConvertIdToContext(traceParent, traceState, isRemote: false, out var context))
		{
			throw new ArgumentException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.InvalidTraceParent);
		}
		return context;
	}

	public bool Equals(ActivityContext value)
	{
		if (SpanId.Equals(value.SpanId) && TraceId.Equals(value.TraceId) && TraceFlags == value.TraceFlags && TraceState == value.TraceState)
		{
			return IsRemote == value.IsRemote;
		}
		return false;
	}

	public override bool Equals([<8138f099-db66-4e8d-a0f5-5476a41f5864>NotNullWhen(true)] object obj)
	{
		if (!(obj is ActivityContext value))
		{
			return false;
		}
		return Equals(value);
	}

	public static bool operator ==(ActivityContext left, ActivityContext right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(ActivityContext left, ActivityContext right)
	{
		return !(left == right);
	}

	public override int GetHashCode()
	{
		if (this == default(ActivityContext))
		{
			return 0;
		}
		int num = 5381;
		num = (num << 5) + num + TraceId.GetHashCode();
		num = (num << 5) + num + SpanId.GetHashCode();
		num = (int)((num << 5) + num + TraceFlags);
		return (num << 5) + num + ((TraceState != null) ? TraceState.GetHashCode() : 0);
	}
}


using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Security;

[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
internal struct ActivityCreationOptions<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] T>
{
	private readonly ActivityTagsCollection _samplerTags;

	private readonly ActivityContext _context;

	private readonly string _traceState;

	public ActivitySource Source { get; }

	public string Name { get; }

	public ActivityKind Kind { get; }

	public T Parent { get; }

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })]
	public IEnumerable<KeyValuePair<string, object>> Tags
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })]
		get;
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public IEnumerable<ActivityLink> Links
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		get;
	}

	public ActivityTagsCollection SamplingTags
	{
		[SecuritySafeCritical]
		get
		{
			if (_samplerTags == null)
			{
				Unsafe.AsRef(ref _samplerTags) = new ActivityTagsCollection();
			}
			return _samplerTags;
		}
	}

	public ActivityTraceId TraceId
	{
		[SecuritySafeCritical]
		get
		{
			if (Parent is ActivityContext && IdFormat == ActivityIdFormat.W3C && _context == default(ActivityContext))
			{
				ActivityTraceId traceId = Activity.TraceIdGenerator?.Invoke() ?? ActivityTraceId.CreateRandom();
				Unsafe.AsRef(ref _context) = new ActivityContext(traceId, default(ActivitySpanId), ActivityTraceFlags.None);
			}
			return _context.TraceId;
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public string TraceState
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		[SecuritySafeCritical]
		get
		{
			return _traceState;
		}
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		[SecuritySafeCritical]
		init
		{
			_traceState = value;
		}
	}

	internal ActivityIdFormat IdFormat { get; }

	internal ActivityCreationOptions(ActivitySource source, string name, T parent, ActivityKind kind, IEnumerable<KeyValuePair<string, object>> tags, IEnumerable<ActivityLink> links, ActivityIdFormat idFormat)
	{
		Source = source;
		Name = name;
		Kind = kind;
		Parent = parent;
		Tags = tags;
		Links = links;
		IdFormat = idFormat;
		if (IdFormat == ActivityIdFormat.Unknown && Activity.ForceDefaultIdFormat)
		{
			IdFormat = Activity.DefaultIdFormat;
		}
		_samplerTags = null;
		_traceState = null;
		if (parent is ActivityContext activityContext && activityContext != default(ActivityContext))
		{
			_context = activityContext;
			if (IdFormat == ActivityIdFormat.Unknown)
			{
				IdFormat = ActivityIdFormat.W3C;
			}
			_traceState = activityContext.TraceState;
		}
		else if (parent is string text && text != null)
		{
			if (IdFormat != ActivityIdFormat.Hierarchical)
			{
				if (ActivityContext.TryParse(text, null, out _context))
				{
					IdFormat = ActivityIdFormat.W3C;
				}
				if (IdFormat == ActivityIdFormat.Unknown)
				{
					IdFormat = ActivityIdFormat.Hierarchical;
				}
			}
			else
			{
				_context = default(ActivityContext);
			}
		}
		else
		{
			_context = default(ActivityContext);
			if (IdFormat == ActivityIdFormat.Unknown)
			{
				IdFormat = ((Activity.Current != null) ? Activity.Current.IdFormat : Activity.DefaultIdFormat);
			}
		}
	}

	[SecuritySafeCritical]
	internal void SetTraceState(string traceState)
	{
		Unsafe.AsRef(ref _traceState) = traceState;
	}

	internal ActivityTagsCollection GetSamplingTags()
	{
		return _samplerTags;
	}

	internal ActivityContext GetContext()
	{
		return _context;
	}
}


internal enum ActivitySamplingResult
{
	None,
	PropagationData,
	AllData,
	AllDataAndRecorded
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;

[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
internal struct ActivityEvent
{
	private static readonly IEnumerable<KeyValuePair<string, object>> s_emptyTags = Array.Empty<KeyValuePair<string, object>>();

	private readonly Activity.TagsLinkedList _tags;

	public string Name { get; }

	public DateTimeOffset Timestamp { get; }

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })]
	public IEnumerable<KeyValuePair<string, object>> Tags
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })]
		get
		{
			IEnumerable<KeyValuePair<string, object>> tags = _tags;
			return tags ?? s_emptyTags;
		}
	}

	public ActivityEvent(string name)
		: this(name, DateTimeOffset.UtcNow)
	{
	}

	public ActivityEvent(string name, DateTimeOffset timestamp = default(DateTimeOffset), [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] ActivityTagsCollection tags = null)
	{
		Name = name ?? string.Empty;
		Timestamp = ((timestamp != default(DateTimeOffset)) ? timestamp : DateTimeOffset.UtcNow);
		_tags = ((tags != null && tags.Count > 0) ? new Activity.TagsLinkedList(tags) : null);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })]
	public Activity.Enumerator<KeyValuePair<string, object>> EnumerateTagObjects()
	{
		return new Activity.Enumerator<KeyValuePair<string, object>>(_tags?.First);
	}
}


internal enum ActivityKind
{
	Internal,
	Server,
	Client,
	Producer,
	Consumer
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
internal struct ActivityLink : IEquatable<ActivityLink>
{
	private readonly Activity.TagsLinkedList _tags;

	public ActivityContext Context { get; }

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })]
	public IEnumerable<KeyValuePair<string, object>> Tags
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })]
		get
		{
			return _tags;
		}
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
	public ActivityLink(ActivityContext context, ActivityTagsCollection tags = null)
	{
		Context = context;
		_tags = ((tags != null && tags.Count > 0) ? new Activity.TagsLinkedList(tags) : null);
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
	public override bool Equals([<8138f099-db66-4e8d-a0f5-5476a41f5864>NotNullWhen(true)] object obj)
	{
		if (obj is ActivityLink value)
		{
			return Equals(value);
		}
		return false;
	}

	public bool Equals(ActivityLink value)
	{
		if (Context == value.Context)
		{
			return value.Tags == Tags;
		}
		return false;
	}

	public static bool operator ==(ActivityLink left, ActivityLink right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(ActivityLink left, ActivityLink right)
	{
		return !left.Equals(right);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })]
	public Activity.Enumerator<KeyValuePair<string, object>> EnumerateTagObjects()
	{
		return new Activity.Enumerator<KeyValuePair<string, object>>(_tags?.First);
	}

	public override int GetHashCode()
	{
		if (this == default(ActivityLink))
		{
			return 0;
		}
		int num = 5381;
		num = (num << 5) + num + Context.GetHashCode();
		if (Tags != null)
		{
			foreach (KeyValuePair<string, object> tag in Tags)
			{
				num = (num << 5) + num + tag.Key.GetHashCode();
				if (tag.Value != null)
				{
					num = (num << 5) + num + tag.Value.GetHashCode();
				}
			}
		}
		return num;
	}
}


using System.Diagnostics;
using System.Runtime.CompilerServices;

internal delegate ActivitySamplingResult SampleActivity<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1 })] ref ActivityCreationOptions<T> options);


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;

[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
internal sealed class ActivityListener : IDisposable
{
	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })]
	public Action<Activity> ActivityStarted
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })]
		get;
		[param: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })]
		set;
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })]
	public Action<Activity> ActivityStopped
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })]
		get;
		[param: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })]
		set;
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })]
	public Func<ActivitySource, bool> ShouldListenTo
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })]
		get;
		[param: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })]
		set;
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })]
	public SampleActivity<string> SampleUsingParentId
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })]
		get;
		[param: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })]
		set;
	}

	public SampleActivity<ActivityContext> Sample { get; set; }

	public void Dispose()
	{
		ActivitySource.DetachListener(this);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Threading;

[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
internal sealed class ActivitySource : IDisposable
{
	internal delegate void Function<T, TParent>(T item, ref ActivityCreationOptions<TParent> data, ref ActivitySamplingResult samplingResult, ref ActivityCreationOptions<ActivityContext> dataWithContext);

	private static readonly SynchronizedList<ActivitySource> s_activeSources = new SynchronizedList<ActivitySource>();

	private static readonly SynchronizedList<ActivityListener> s_allListeners = new SynchronizedList<ActivityListener>();

	private SynchronizedList<ActivityListener> _listeners;

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)]
	public string Name
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
		get;
	}

	public string Version { get; }

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	public ActivitySource(string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string version = "")
	{
		Name = name ?? throw new ArgumentNullException("name");
		Version = version;
		s_activeSources.Add(this);
		if (s_allListeners.Count > 0)
		{
			s_allListeners.EnumWithAction(delegate(ActivityListener listener, object source)
			{
				Func<ActivitySource, bool> shouldListenTo = listener.ShouldListenTo;
				if (shouldListenTo != null)
				{
					ActivitySource activitySource = (ActivitySource)source;
					if (shouldListenTo(activitySource))
					{
						activitySource.AddListener(listener);
					}
				}
			}, this);
		}
		GC.KeepAlive(DiagnosticSourceEventSource.Log);
	}

	public bool HasListeners()
	{
		SynchronizedList<ActivityListener> listeners = _listeners;
		if (listeners != null)
		{
			return listeners.Count > 0;
		}
		return false;
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public Activity CreateActivity(string name, ActivityKind kind)
	{
		return CreateActivity(name, kind, default(ActivityContext), null, null, null, default(DateTimeOffset), startIt: false);
	}

	public Activity CreateActivity([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, ActivityKind kind, ActivityContext parentContext, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })] IEnumerable<KeyValuePair<string, object>> tags = null, IEnumerable<ActivityLink> links = null, ActivityIdFormat idFormat = ActivityIdFormat.Unknown)
	{
		return CreateActivity(name, kind, parentContext, null, tags, links, default(DateTimeOffset), startIt: false, idFormat);
	}

	public Activity CreateActivity([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, ActivityKind kind, string parentId, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })] IEnumerable<KeyValuePair<string, object>> tags = null, IEnumerable<ActivityLink> links = null, ActivityIdFormat idFormat = ActivityIdFormat.Unknown)
	{
		return CreateActivity(name, kind, default(ActivityContext), parentId, tags, links, default(DateTimeOffset), startIt: false, idFormat);
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public Activity StartActivity([CallerMemberName] string name = "", ActivityKind kind = ActivityKind.Internal)
	{
		return CreateActivity(name, kind, default(ActivityContext), null, null, null, default(DateTimeOffset));
	}

	public Activity StartActivity([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, ActivityKind kind, ActivityContext parentContext, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })] IEnumerable<KeyValuePair<string, object>> tags = null, IEnumerable<ActivityLink> links = null, DateTimeOffset startTime = default(DateTimeOffset))
	{
		return CreateActivity(name, kind, parentContext, null, tags, links, startTime);
	}

	public Activity StartActivity([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, ActivityKind kind, string parentId, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })] IEnumerable<KeyValuePair<string, object>> tags = null, IEnumerable<ActivityLink> links = null, DateTimeOffset startTime = default(DateTimeOffset))
	{
		return CreateActivity(name, kind, default(ActivityContext), parentId, tags, links, startTime);
	}

	public Activity StartActivity(ActivityKind kind, ActivityContext parentContext = default(ActivityContext), [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })] IEnumerable<KeyValuePair<string, object>> tags = null, IEnumerable<ActivityLink> links = null, DateTimeOffset startTime = default(DateTimeOffset), [CallerMemberName][<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name = "")
	{
		return CreateActivity(name, kind, parentContext, null, tags, links, startTime);
	}

	private Activity CreateActivity(string name, ActivityKind kind, ActivityContext context, string parentId, IEnumerable<KeyValuePair<string, object>> tags, IEnumerable<ActivityLink> links, DateTimeOffset startTime, bool startIt = true, ActivityIdFormat idFormat = ActivityIdFormat.Unknown)
	{
		SynchronizedList<ActivityListener> listeners = _listeners;
		if (listeners == null || listeners.Count == 0)
		{
			return null;
		}
		Activity result2 = null;
		ActivitySamplingResult samplingResult = ActivitySamplingResult.None;
		ActivityTagsCollection activityTagsCollection;
		string traceState;
		if (parentId != null)
		{
			ActivityCreationOptions<string> activityCreationOptions = default(ActivityCreationOptions<string>);
			ActivityCreationOptions<ActivityContext> dataWithContext2 = default(ActivityCreationOptions<ActivityContext>);
			activityCreationOptions = new ActivityCreationOptions<string>(this, name, parentId, kind, tags, links, idFormat);
			if (activityCreationOptions.IdFormat == ActivityIdFormat.W3C)
			{
				dataWithContext2 = new ActivityCreationOptions<ActivityContext>(this, name, activityCreationOptions.GetContext(), kind, tags, links, ActivityIdFormat.W3C);
			}
			listeners.EnumWithFunc(delegate(ActivityListener listener, ref ActivityCreationOptions<string> data, ref ActivitySamplingResult result, ref ActivityCreationOptions<ActivityContext> dataWithContext)
			{
				SampleActivity<string> sampleUsingParentId = listener.SampleUsingParentId;
				if (sampleUsingParentId != null)
				{
					ActivitySamplingResult activitySamplingResult = sampleUsingParentId(ref data);
					dataWithContext.SetTraceState(data.TraceState);
					if (activitySamplingResult > result)
					{
						result = activitySamplingResult;
					}
				}
				else if (data.IdFormat == ActivityIdFormat.W3C)
				{
					SampleActivity<ActivityContext> sample = listener.Sample;
					if (sample != null)
					{
						ActivitySamplingResult activitySamplingResult2 = sample(ref dataWithContext);
						data.SetTraceState(dataWithContext.TraceState);
						if (activitySamplingResult2 > result)
						{
							result = activitySamplingResult2;
						}
					}
				}
			}, ref activityCreationOptions, ref samplingResult, ref dataWithContext2);
			if (context == default(ActivityContext))
			{
				if (activityCreationOptions.GetContext() != default(ActivityContext))
				{
					context = activityCreationOptions.GetContext();
					parentId = null;
				}
				else if (dataWithContext2.GetContext() != default(ActivityContext))
				{
					context = dataWithContext2.GetContext();
					parentId = null;
				}
			}
			activityTagsCollection = activityCreationOptions.GetSamplingTags();
			ActivityTagsCollection samplingTags = dataWithContext2.GetSamplingTags();
			if (samplingTags != null)
			{
				if (activityTagsCollection == null)
				{
					activityTagsCollection = samplingTags;
				}
				else
				{
					foreach (KeyValuePair<string, object> item in samplingTags)
					{
						activityTagsCollection.Add(item);
					}
				}
			}
			idFormat = activityCreationOptions.IdFormat;
			traceState = activityCreationOptions.TraceState;
		}
		else
		{
			bool flag = context == default(ActivityContext) && Activity.Current != null;
			ActivityCreationOptions<ActivityContext> data2 = new ActivityCreationOptions<ActivityContext>(this, name, flag ? Activity.Current.Context : context, kind, tags, links, idFormat);
			listeners.EnumWithFunc(delegate(ActivityListener listener, ref ActivityCreationOptions<ActivityContext> data, ref ActivitySamplingResult result, ref ActivityCreationOptions<ActivityContext> unused)
			{
				SampleActivity<ActivityContext> sample2 = listener.Sample;
				if (sample2 != null)
				{
					ActivitySamplingResult activitySamplingResult3 = sample2(ref data);
					if (activitySamplingResult3 > result)
					{
						result = activitySamplingResult3;
					}
				}
			}, ref data2, ref samplingResult, ref data2);
			if (!flag)
			{
				context = data2.GetContext();
			}
			activityTagsCollection = data2.GetSamplingTags();
			idFormat = data2.IdFormat;
			traceState = data2.TraceState;
		}
		if (samplingResult != 0)
		{
			result2 = Activity.Create(this, name, kind, parentId, context, tags, links, startTime, activityTagsCollection, samplingResult, startIt, idFormat, traceState);
		}
		return result2;
	}

	public void Dispose()
	{
		_listeners = null;
		s_activeSources.Remove(this);
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	public static void AddActivityListener(ActivityListener listener)
	{
		if (listener == null)
		{
			throw new ArgumentNullException("listener");
		}
		if (!s_allListeners.AddIfNotExist(listener))
		{
			return;
		}
		s_activeSources.EnumWithAction(delegate(ActivitySource source, object obj)
		{
			Func<ActivitySource, bool> shouldListenTo = ((ActivityListener)obj).ShouldListenTo;
			if (shouldListenTo != null && shouldListenTo(source))
			{
				source.AddListener((ActivityListener)obj);
			}
		}, listener);
	}

	internal void AddListener(ActivityListener listener)
	{
		if (_listeners == null)
		{
			Interlocked.CompareExchange(ref _listeners, new SynchronizedList<ActivityListener>(), null);
		}
		_listeners.AddIfNotExist(listener);
	}

	internal static void DetachListener(ActivityListener listener)
	{
		s_allListeners.Remove(listener);
		s_activeSources.EnumWithAction(delegate(ActivitySource source, object obj)
		{
			source._listeners?.Remove((ActivityListener)obj);
		}, listener);
	}

	internal void NotifyActivityStart(Activity activity)
	{
		SynchronizedList<ActivityListener> listeners = _listeners;
		if (listeners != null && listeners.Count > 0)
		{
			listeners.EnumWithAction(delegate(ActivityListener listener, object obj)
			{
				listener.ActivityStarted?.Invoke((Activity)obj);
			}, activity);
		}
	}

	internal void NotifyActivityStop(Activity activity)
	{
		SynchronizedList<ActivityListener> listeners = _listeners;
		if (listeners != null && listeners.Count > 0)
		{
			listeners.EnumWithAction(delegate(ActivityListener listener, object obj)
			{
				listener.ActivityStopped?.Invoke((Activity)obj);
			}, activity);
		}
	}
}


internal delegate void Function<T, TParent>(T item, ref ActivityCreationOptions<TParent> data, ref ActivitySamplingResult samplingResult, ref ActivityCreationOptions<ActivityContext> dataWithContext);


using System;
using System.Collections.Generic;
using System.Diagnostics;

internal sealed class SynchronizedList<T>
{
	private readonly List<T> _list;

	private uint _version;

	public int Count => _list.Count;

	public SynchronizedList()
	{
		_list = new List<T>();
	}

	public void Add(T item)
	{
		lock (_list)
		{
			_list.Add(item);
			_version++;
		}
	}

	public bool AddIfNotExist(T item)
	{
		lock (_list)
		{
			if (!_list.Contains(item))
			{
				_list.Add(item);
				_version++;
				return true;
			}
			return false;
		}
	}

	public bool Remove(T item)
	{
		lock (_list)
		{
			if (_list.Remove(item))
			{
				_version++;
				return true;
			}
			return false;
		}
	}

	public void EnumWithFunc<TParent>(ActivitySource.Function<T, TParent> func, ref ActivityCreationOptions<TParent> data, ref ActivitySamplingResult samplingResult, ref ActivityCreationOptions<ActivityContext> dataWithContext)
	{
		uint version = _version;
		int num = 0;
		while (num < _list.Count)
		{
			T item;
			lock (_list)
			{
				if (version != _version)
				{
					version = _version;
					num = 0;
					continue;
				}
				item = _list[num];
				num++;
			}
			func(item, ref data, ref samplingResult, ref dataWithContext);
		}
	}

	public void EnumWithAction(Action<T, object> action, object arg)
	{
		uint version = _version;
		int num = 0;
		while (num < _list.Count)
		{
			T arg2;
			lock (_list)
			{
				if (version != _version)
				{
					version = _version;
					num = 0;
					continue;
				}
				arg2 = _list[num];
				num++;
			}
			action(arg2, arg);
		}
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
internal abstract class DiagnosticSource
{
	internal const string WriteRequiresUnreferencedCode = "The type of object being written to DiagnosticSource cannot be discovered statically.";

	[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
	public abstract void Write(string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object value);

	public abstract bool IsEnabled(string name);

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
	public virtual bool IsEnabled([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, object arg1, object arg2 = null)
	{
		return IsEnabled(name);
	}

	[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
	public Activity StartActivity(Activity activity, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object args)
	{
		activity.Start();
		Write(activity.OperationName + ".Start", args);
		return activity;
	}

	[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
	public void StopActivity(Activity activity, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object args)
	{
		if (activity.Duration == TimeSpan.Zero)
		{
			activity.SetEndTime(Activity.GetUtcNow());
		}
		Write(activity.OperationName + ".Stop", args);
		activity.Stop();
	}

	public virtual void OnActivityImport(Activity activity, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object payload)
	{
	}

	public virtual void OnActivityExport(Activity activity, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object payload)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;

[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
internal class DiagnosticListener : DiagnosticSource, IObservable<KeyValuePair<string, object>>, IDisposable
{
	private sealed class DiagnosticSubscription : IDisposable
	{
		internal IObserver<KeyValuePair<string, object>> Observer;

		internal Predicate<string> IsEnabled1Arg;

		internal Func<string, object, object, bool> IsEnabled3Arg;

		internal Action<Activity, object> OnActivityImport;

		internal Action<Activity, object> OnActivityExport;

		internal DiagnosticListener Owner;

		internal DiagnosticSubscription Next;

		public void Dispose()
		{
			DiagnosticSubscription subscriptions;
			DiagnosticSubscription value;
			do
			{
				subscriptions = Owner._subscriptions;
				value = Remove(subscriptions, this);
			}
			while (Interlocked.CompareExchange(ref Owner._subscriptions, value, subscriptions) != subscriptions);
		}

		private static DiagnosticSubscription Remove(DiagnosticSubscription subscriptions, DiagnosticSubscription subscription)
		{
			if (subscriptions == null)
			{
				return null;
			}
			if (subscriptions.Observer == subscription.Observer && subscriptions.IsEnabled1Arg == subscription.IsEnabled1Arg && subscriptions.IsEnabled3Arg == subscription.IsEnabled3Arg)
			{
				return subscriptions.Next;
			}
			return new DiagnosticSubscription
			{
				Observer = subscriptions.Observer,
				Owner = subscriptions.Owner,
				IsEnabled1Arg = subscriptions.IsEnabled1Arg,
				IsEnabled3Arg = subscriptions.IsEnabled3Arg,
				Next = Remove(subscriptions.Next, subscription)
			};
		}
	}

	private sealed class AllListenerObservable : IObservable<DiagnosticListener>
	{
		internal sealed class AllListenerSubscription : IDisposable
		{
			private readonly AllListenerObservable _owner;

			internal readonly IObserver<DiagnosticListener> Subscriber;

			internal AllListenerSubscription Next;

			internal AllListenerSubscription(AllListenerObservable owner, IObserver<DiagnosticListener> subscriber, AllListenerSubscription next)
			{
				_owner = owner;
				Subscriber = subscriber;
				Next = next;
			}

			public void Dispose()
			{
				if (_owner.Remove(this))
				{
					Subscriber.OnCompleted();
				}
			}
		}

		private AllListenerSubscription _subscriptions;

		public IDisposable Subscribe(IObserver<DiagnosticListener> observer)
		{
			lock (s_allListenersLock)
			{
				for (DiagnosticListener diagnosticListener = s_allListeners; diagnosticListener != null; diagnosticListener = diagnosticListener._next)
				{
					observer.OnNext(diagnosticListener);
				}
				_subscriptions = new AllListenerSubscription(this, observer, _subscriptions);
				return _subscriptions;
			}
		}

		internal void OnNewDiagnosticListener(DiagnosticListener diagnosticListener)
		{
			for (AllListenerSubscription allListenerSubscription = _subscriptions; allListenerSubscription != null; allListenerSubscription = allListenerSubscription.Next)
			{
				allListenerSubscription.Subscriber.OnNext(diagnosticListener);
			}
		}

		private bool Remove(AllListenerSubscription subscription)
		{
			lock (s_allListenersLock)
			{
				if (_subscriptions == subscription)
				{
					_subscriptions = subscription.Next;
					return true;
				}
				if (_subscriptions != null)
				{
					AllListenerSubscription allListenerSubscription = _subscriptions;
					while (allListenerSubscription.Next != null)
					{
						if (allListenerSubscription.Next == subscription)
						{
							allListenerSubscription.Next = allListenerSubscription.Next.Next;
							return true;
						}
						allListenerSubscription = allListenerSubscription.Next;
					}
				}
				return false;
			}
		}
	}

	private volatile DiagnosticSubscription _subscriptions;

	private DiagnosticListener _next;

	private bool _disposed;

	private static DiagnosticListener s_allListeners;

	private static volatile AllListenerObservable s_allListenerObservable;

	private static readonly object s_allListenersLock = new object();

	public static IObservable<DiagnosticListener> AllListeners
	{
		get
		{
			GC.KeepAlive(HttpHandlerDiagnosticListener.s_instance);
			return s_allListenerObservable ?? Interlocked.CompareExchange(ref s_allListenerObservable, new AllListenerObservable(), null) ?? s_allListenerObservable;
		}
	}

	public string Name { get; private set; }

	public override void OnActivityImport(Activity activity, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object payload)
	{
		for (DiagnosticSubscription diagnosticSubscription = _subscriptions; diagnosticSubscription != null; diagnosticSubscription = diagnosticSubscription.Next)
		{
			diagnosticSubscription.OnActivityImport?.Invoke(activity, payload);
		}
	}

	public override void OnActivityExport(Activity activity, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object payload)
	{
		for (DiagnosticSubscription diagnosticSubscription = _subscriptions; diagnosticSubscription != null; diagnosticSubscription = diagnosticSubscription.Next)
		{
			diagnosticSubscription.OnActivityExport?.Invoke(activity, payload);
		}
	}

	public virtual IDisposable Subscribe([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })] IObserver<KeyValuePair<string, object>> observer, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1, 2, 2 })] Func<string, object, object, bool> isEnabled, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1, 2 })] Action<Activity, object> onActivityImport = null, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1, 2 })] Action<Activity, object> onActivityExport = null)
	{
		if (isEnabled != null)
		{
			return SubscribeInternal(observer, (string name) => IsEnabled(name, null), isEnabled, onActivityImport, onActivityExport);
		}
		return SubscribeInternal(observer, null, null, onActivityImport, onActivityExport);
	}

	public virtual IDisposable Subscribe([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })] IObserver<KeyValuePair<string, object>> observer, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })] Predicate<string> isEnabled)
	{
		if (isEnabled == null)
		{
			return SubscribeInternal(observer, null, null, null, null);
		}
		Predicate<string> localIsEnabled = isEnabled;
		return SubscribeInternal(observer, isEnabled, (string name, object arg1, object arg2) => localIsEnabled(name), null, null);
	}

	public virtual IDisposable Subscribe([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })] IObserver<KeyValuePair<string, object>> observer, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1, 2, 2 })] Func<string, object, object, bool> isEnabled)
	{
		if (isEnabled != null)
		{
			return SubscribeInternal(observer, (string name) => IsEnabled(name, null), isEnabled, null, null);
		}
		return SubscribeInternal(observer, null, null, null, null);
	}

	public virtual IDisposable Subscribe([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })] IObserver<KeyValuePair<string, object>> observer)
	{
		return SubscribeInternal(observer, null, null, null, null);
	}

	public DiagnosticListener(string name)
	{
		Name = name;
		lock (s_allListenersLock)
		{
			s_allListenerObservable?.OnNewDiagnosticListener(this);
			_next = s_allListeners;
			s_allListeners = this;
		}
		GC.KeepAlive(DiagnosticSourceEventSource.Log);
	}

	public virtual void Dispose()
	{
		lock (s_allListenersLock)
		{
			if (_disposed)
			{
				return;
			}
			_disposed = true;
			if (s_allListeners == this)
			{
				s_allListeners = s_allListeners._next;
			}
			else
			{
				for (DiagnosticListener next = s_allListeners; next != null; next = next._next)
				{
					if (next._next == this)
					{
						next._next = _next;
						break;
					}
				}
			}
			_next = null;
		}
		DiagnosticSubscription location = null;
		Interlocked.Exchange(ref location, _subscriptions);
		while (location != null)
		{
			location.Observer.OnCompleted();
			location = location.Next;
		}
	}

	public override string ToString()
	{
		return Name ?? string.Empty;
	}

	public bool IsEnabled()
	{
		return _subscriptions != null;
	}

	public override bool IsEnabled(string name)
	{
		for (DiagnosticSubscription diagnosticSubscription = _subscriptions; diagnosticSubscription != null; diagnosticSubscription = diagnosticSubscription.Next)
		{
			if (diagnosticSubscription.IsEnabled1Arg == null || diagnosticSubscription.IsEnabled1Arg(name))
			{
				return true;
			}
		}
		return false;
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
	public override bool IsEnabled([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, object arg1, object arg2 = null)
	{
		for (DiagnosticSubscription diagnosticSubscription = _subscriptions; diagnosticSubscription != null; diagnosticSubscription = diagnosticSubscription.Next)
		{
			if (diagnosticSubscription.IsEnabled3Arg == null || diagnosticSubscription.IsEnabled3Arg(name, arg1, arg2))
			{
				return true;
			}
		}
		return false;
	}

	[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
	public override void Write(string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object value)
	{
		for (DiagnosticSubscription diagnosticSubscription = _subscriptions; diagnosticSubscription != null; diagnosticSubscription = diagnosticSubscription.Next)
		{
			diagnosticSubscription.Observer.OnNext(new KeyValuePair<string, object>(name, value));
		}
	}

	private IDisposable SubscribeInternal(IObserver<KeyValuePair<string, object>> observer, Predicate<string> isEnabled1Arg, Func<string, object, object, bool> isEnabled3Arg, Action<Activity, object> onActivityImport, Action<Activity, object> onActivityExport)
	{
		if (_disposed)
		{
			return new DiagnosticSubscription
			{
				Owner = this
			};
		}
		DiagnosticSubscription diagnosticSubscription = new DiagnosticSubscription
		{
			Observer = observer,
			IsEnabled1Arg = isEnabled1Arg,
			IsEnabled3Arg = isEnabled3Arg,
			OnActivityImport = onActivityImport,
			OnActivityExport = onActivityExport,
			Owner = this,
			Next = _subscriptions
		};
		while (Interlocked.CompareExchange(ref _subscriptions, diagnosticSubscription, diagnosticSubscription.Next) != diagnosticSubscription.Next)
		{
			diagnosticSubscription.Next = _subscriptions;
		}
		return diagnosticSubscription;
	}
}


using System.Collections.Generic;
using System.Threading;

private sealed class DiagnosticSubscription : IDisposable
{
	internal IObserver<KeyValuePair<string, object>> Observer;

	internal Predicate<string> IsEnabled1Arg;

	internal Func<string, object, object, bool> IsEnabled3Arg;

	internal Action<Activity, object> OnActivityImport;

	internal Action<Activity, object> OnActivityExport;

	internal DiagnosticListener Owner;

	internal DiagnosticSubscription Next;

	public void Dispose()
	{
		DiagnosticSubscription subscriptions;
		DiagnosticSubscription value;
		do
		{
			subscriptions = Owner._subscriptions;
			value = Remove(subscriptions, this);
		}
		while (Interlocked.CompareExchange(ref Owner._subscriptions, value, subscriptions) != subscriptions);
	}

	private static DiagnosticSubscription Remove(DiagnosticSubscription subscriptions, DiagnosticSubscription subscription)
	{
		if (subscriptions == null)
		{
			return null;
		}
		if (subscriptions.Observer == subscription.Observer && subscriptions.IsEnabled1Arg == subscription.IsEnabled1Arg && subscriptions.IsEnabled3Arg == subscription.IsEnabled3Arg)
		{
			return subscriptions.Next;
		}
		return new DiagnosticSubscription
		{
			Observer = subscriptions.Observer,
			Owner = subscriptions.Owner,
			IsEnabled1Arg = subscriptions.IsEnabled1Arg,
			IsEnabled3Arg = subscriptions.IsEnabled3Arg,
			Next = Remove(subscriptions.Next, subscription)
		};
	}
}


private sealed class AllListenerObservable : IObservable<DiagnosticListener>
{
	internal sealed class AllListenerSubscription : IDisposable
	{
		private readonly AllListenerObservable _owner;

		internal readonly IObserver<DiagnosticListener> Subscriber;

		internal AllListenerSubscription Next;

		internal AllListenerSubscription(AllListenerObservable owner, IObserver<DiagnosticListener> subscriber, AllListenerSubscription next)
		{
			_owner = owner;
			Subscriber = subscriber;
			Next = next;
		}

		public void Dispose()
		{
			if (_owner.Remove(this))
			{
				Subscriber.OnCompleted();
			}
		}
	}

	private AllListenerSubscription _subscriptions;

	public IDisposable Subscribe(IObserver<DiagnosticListener> observer)
	{
		lock (s_allListenersLock)
		{
			for (DiagnosticListener diagnosticListener = s_allListeners; diagnosticListener != null; diagnosticListener = diagnosticListener._next)
			{
				observer.OnNext(diagnosticListener);
			}
			_subscriptions = new AllListenerSubscription(this, observer, _subscriptions);
			return _subscriptions;
		}
	}

	internal void OnNewDiagnosticListener(DiagnosticListener diagnosticListener)
	{
		for (AllListenerSubscription allListenerSubscription = _subscriptions; allListenerSubscription != null; allListenerSubscription = allListenerSubscription.Next)
		{
			allListenerSubscription.Subscriber.OnNext(diagnosticListener);
		}
	}

	private bool Remove(AllListenerSubscription subscription)
	{
		lock (s_allListenersLock)
		{
			if (_subscriptions == subscription)
			{
				_subscriptions = subscription.Next;
				return true;
			}
			if (_subscriptions != null)
			{
				AllListenerSubscription allListenerSubscription = _subscriptions;
				while (allListenerSubscription.Next != null)
				{
					if (allListenerSubscription.Next == subscription)
					{
						allListenerSubscription.Next = allListenerSubscription.Next.Next;
						return true;
					}
					allListenerSubscription = allListenerSubscription.Next;
				}
			}
			return false;
		}
	}
}


internal sealed class AllListenerSubscription : IDisposable
{
	private readonly AllListenerObservable _owner;

	internal readonly IObserver<DiagnosticListener> Subscriber;

	internal AllListenerSubscription Next;

	internal AllListenerSubscription(AllListenerObservable owner, IObserver<DiagnosticListener> subscriber, AllListenerSubscription next)
	{
		_owner = owner;
		Subscriber = subscriber;
		Next = next;
	}

	public void Dispose()
	{
		if (_owner.Remove(this))
		{
			Subscriber.OnCompleted();
		}
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Tracing;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;

[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2113:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves methods on Delegate and MulticastDelegate because the nested type OverrideEventProvider's base type EventProvider defines a delegate. This includes Delegate and MulticastDelegate methods which require unreferenced code, but EnsureDescriptorsInitialized does not access these members and is safe to call.")]
[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2115:ReflectionToDynamicallyAccessedMembers", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves methods on Delegate and MulticastDelegate because the nested type OverrideEventProvider's base type EventProvider defines a delegate. This includes Delegate and MulticastDelegate methods which have dynamically accessed members requirements, but EnsureDescriptorsInitialized does not access these members and is safe to call.")]
[EventSource(Name = "Microsoft-Diagnostics-DiagnosticSource")]
internal sealed class DiagnosticSourceEventSource : EventSource
{
	public static class Keywords
	{
		public const EventKeywords Messages = (EventKeywords)1L;

		public const EventKeywords Events = (EventKeywords)2L;

		public const EventKeywords IgnoreShortCutKeywords = (EventKeywords)2048L;

		public const EventKeywords AspNetCoreHosting = (EventKeywords)4096L;

		public const EventKeywords EntityFrameworkCoreCommands = (EventKeywords)8192L;
	}

	[Flags]
	internal enum ActivityEvents
	{
		None = 0,
		ActivityStart = 1,
		ActivityStop = 2,
		All = 3
	}

	internal sealed class FilterAndTransform
	{
		public FilterAndTransform Next;

		internal const string c_ActivitySourcePrefix = "[AS]";

		private IDisposable _diagnosticsListenersSubscription;

		private Subscriptions _liveSubscriptions;

		private readonly bool _noImplicitTransforms;

		private ImplicitTransformEntry _firstImplicitTransformsEntry;

		private ConcurrentDictionary<Type, TransformSpec> _implicitTransformsTable;

		private readonly TransformSpec _explicitTransforms;

		private readonly DiagnosticSourceEventSource _eventSource;

		internal string SourceName { get; set; }

		internal string ActivityName { get; set; }

		internal ActivityEvents Events { get; set; }

		internal ActivitySamplingResult SamplingResult { get; set; }

		public static void CreateFilterAndTransformList(ref FilterAndTransform specList, string filterAndPayloadSpecs, DiagnosticSourceEventSource eventSource)
		{
			DestroyFilterAndTransformList(ref specList, eventSource);
			if (filterAndPayloadSpecs == null)
			{
				filterAndPayloadSpecs = "";
			}
			int num = filterAndPayloadSpecs.Length;
			while (true)
			{
				if (0 < num && char.IsWhiteSpace(filterAndPayloadSpecs[num - 1]))
				{
					num--;
					continue;
				}
				int num2 = filterAndPayloadSpecs.LastIndexOf('\n', num - 1, num);
				int i = 0;
				if (0 <= num2)
				{
					i = num2 + 1;
				}
				for (; i < num && char.IsWhiteSpace(filterAndPayloadSpecs[i]); i++)
				{
				}
				if (IsActivitySourceEntry(filterAndPayloadSpecs, i, num))
				{
					AddNewActivitySourceTransform(filterAndPayloadSpecs, i, num, eventSource);
				}
				else
				{
					specList = new FilterAndTransform(filterAndPayloadSpecs, i, num, eventSource, specList);
				}
				num = num2;
				if (num < 0)
				{
					break;
				}
			}
			if (eventSource._activitySourceSpecs != null)
			{
				NormalizeActivitySourceSpecsList(eventSource);
				CreateActivityListener(eventSource);
			}
		}

		public static void DestroyFilterAndTransformList(ref FilterAndTransform specList, DiagnosticSourceEventSource eventSource)
		{
			eventSource._activityListener?.Dispose();
			eventSource._activityListener = null;
			eventSource._activitySourceSpecs = null;
			FilterAndTransform filterAndTransform = specList;
			specList = null;
			while (filterAndTransform != null)
			{
				filterAndTransform.Dispose();
				filterAndTransform = filterAndTransform.Next;
			}
		}

		public FilterAndTransform(string filterAndPayloadSpec, int startIdx, int endIdx, DiagnosticSourceEventSource eventSource, FilterAndTransform next)
		{
			FilterAndTransform filterAndTransform = this;
			Next = next;
			_eventSource = eventSource;
			string listenerNameFilter = null;
			string eventNameFilter = null;
			string text = null;
			int num = startIdx;
			int num2 = endIdx;
			int num3 = filterAndPayloadSpec.IndexOf(':', startIdx, endIdx - startIdx);
			if (0 <= num3)
			{
				num2 = num3;
				num = num3 + 1;
			}
			int num4 = filterAndPayloadSpec.IndexOf('/', startIdx, num2 - startIdx);
			if (0 <= num4)
			{
				listenerNameFilter = filterAndPayloadSpec.Substring(startIdx, num4 - startIdx);
				int num5 = filterAndPayloadSpec.IndexOf('@', num4 + 1, num2 - num4 - 1);
				if (0 <= num5)
				{
					text = filterAndPayloadSpec.Substring(num5 + 1, num2 - num5 - 1);
					eventNameFilter = filterAndPayloadSpec.Substring(num4 + 1, num5 - num4 - 1);
				}
				else
				{
					eventNameFilter = filterAndPayloadSpec.Substring(num4 + 1, num2 - num4 - 1);
				}
			}
			else if (startIdx < num2)
			{
				listenerNameFilter = filterAndPayloadSpec.Substring(startIdx, num2 - startIdx);
			}
			_eventSource.Message("DiagnosticSource: Enabling '" + (listenerNameFilter ?? "*") + "/" + (eventNameFilter ?? "*") + "'");
			if (num < endIdx && filterAndPayloadSpec[num] == '-')
			{
				_eventSource.Message("DiagnosticSource: suppressing implicit transforms.");
				_noImplicitTransforms = true;
				num++;
			}
			if (num < endIdx)
			{
				while (true)
				{
					int num6 = num;
					int num7 = filterAndPayloadSpec.LastIndexOf(';', endIdx - 1, endIdx - num);
					if (0 <= num7)
					{
						num6 = num7 + 1;
					}
					if (num6 < endIdx)
					{
						if (_eventSource.IsEnabled(EventLevel.Informational, (EventKeywords)1L))
						{
							_eventSource.Message("DiagnosticSource: Parsing Explicit Transform '" + filterAndPayloadSpec.Substring(num6, endIdx - num6) + "'");
						}
						_explicitTransforms = new TransformSpec(filterAndPayloadSpec, num6, endIdx, _explicitTransforms);
					}
					if (num == num6)
					{
						break;
					}
					endIdx = num7;
				}
			}
			Action<string, string, IEnumerable<KeyValuePair<string, string>>> writeEvent = null;
			if (text != null && text.Contains("Activity"))
			{
				writeEvent = text switch
				{
					"Activity1Start" => _eventSource.Activity1Start, 
					"Activity1Stop" => _eventSource.Activity1Stop, 
					"Activity2Start" => _eventSource.Activity2Start, 
					"Activity2Stop" => _eventSource.Activity2Stop, 
					"RecursiveActivity1Start" => _eventSource.RecursiveActivity1Start, 
					"RecursiveActivity1Stop" => _eventSource.RecursiveActivity1Stop, 
					_ => null, 
				};
				if (writeEvent == null)
				{
					_eventSource.Message("DiagnosticSource: Could not find Event to log Activity " + text);
				}
			}
			if (writeEvent == null)
			{
				writeEvent = _eventSource.Event;
			}
			_diagnosticsListenersSubscription = DiagnosticListener.AllListeners.Subscribe(new CallbackObserver<DiagnosticListener>(delegate(DiagnosticListener newListener)
			{
				if (listenerNameFilter == null || listenerNameFilter == newListener.Name)
				{
					filterAndTransform._eventSource.NewDiagnosticListener(newListener.Name);
					Predicate<string> isEnabled = null;
					if (eventNameFilter != null)
					{
						isEnabled = (string eventName) => eventNameFilter == eventName;
					}
					IDisposable subscription = newListener.Subscribe(new CallbackObserver<KeyValuePair<string, object>>(OnEventWritten), isEnabled);
					filterAndTransform._liveSubscriptions = new Subscriptions(subscription, filterAndTransform._liveSubscriptions);
				}
				[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "DiagnosticSource.Write is marked with RequiresUnreferencedCode.")]
				[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2119", Justification = "DAM on EventSource references this compiler-generated local function which calls a method that requires unreferenced code. EventSource will not access this local function.")]
				void OnEventWritten(KeyValuePair<string, object> evnt)
				{
					if (eventNameFilter == null || !(eventNameFilter != evnt.Key))
					{
						List<KeyValuePair<string, string>> arg = filterAndTransform.Morph(evnt.Value);
						string key = evnt.Key;
						writeEvent(newListener.Name, key, arg);
					}
				}
			}));
		}

		internal FilterAndTransform(string filterAndPayloadSpec, int endIdx, int colonIdx, string activitySourceName, string activityName, ActivityEvents events, ActivitySamplingResult samplingResult, DiagnosticSourceEventSource eventSource)
		{
			_eventSource = eventSource;
			Next = _eventSource._activitySourceSpecs;
			_eventSource._activitySourceSpecs = this;
			SourceName = activitySourceName;
			ActivityName = activityName;
			Events = events;
			SamplingResult = samplingResult;
			if (colonIdx < 0)
			{
				return;
			}
			int num = colonIdx + 1;
			if (num < endIdx && filterAndPayloadSpec[num] == '-')
			{
				_eventSource.Message("DiagnosticSource: suppressing implicit transforms.");
				_noImplicitTransforms = true;
				num++;
			}
			if (num >= endIdx)
			{
				return;
			}
			while (true)
			{
				int num2 = num;
				int num3 = filterAndPayloadSpec.LastIndexOf(';', endIdx - 1, endIdx - num);
				if (0 <= num3)
				{
					num2 = num3 + 1;
				}
				if (num2 < endIdx)
				{
					if (_eventSource.IsEnabled(EventLevel.Informational, (EventKeywords)1L))
					{
						_eventSource.Message("DiagnosticSource: Parsing Explicit Transform '" + filterAndPayloadSpec.Substring(num2, endIdx - num2) + "'");
					}
					_explicitTransforms = new TransformSpec(filterAndPayloadSpec, num2, endIdx, _explicitTransforms);
				}
				if (num != num2)
				{
					endIdx = num3;
					continue;
				}
				break;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool IsActivitySourceEntry(string filterAndPayloadSpec, int startIdx, int endIdx)
		{
			return MemoryExtensions.AsSpan(filterAndPayloadSpec, startIdx, endIdx - startIdx).StartsWith(MemoryExtensions.AsSpan("[AS]"), StringComparison.Ordinal);
		}

		internal static void AddNewActivitySourceTransform(string filterAndPayloadSpec, int startIdx, int endIdx, DiagnosticSourceEventSource eventSource)
		{
			ActivityEvents events = ActivityEvents.All;
			ActivitySamplingResult samplingResult = ActivitySamplingResult.AllDataAndRecorded;
			int num = filterAndPayloadSpec.IndexOf(':', startIdx + "[AS]".Length, endIdx - startIdx - "[AS]".Length);
			ReadOnlySpan<char> readOnlySpan = MemoryExtensions.AsSpan(filterAndPayloadSpec, startIdx + "[AS]".Length, ((num >= 0) ? num : endIdx) - startIdx - "[AS]".Length).Trim();
			int num2 = readOnlySpan.IndexOf('/');
			ReadOnlySpan<char> span;
			if (num2 >= 0)
			{
				span = readOnlySpan.Slice(0, num2).Trim();
				ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(num2 + 1).Trim();
				int num3 = readOnlySpan2.IndexOf('-');
				ReadOnlySpan<char> span2;
				if (num3 >= 0)
				{
					span2 = readOnlySpan2.Slice(0, num3).Trim();
					readOnlySpan2 = readOnlySpan2.Slice(num3 + 1).Trim();
					if (readOnlySpan2.Length > 0)
					{
						if (MemoryExtensions.Equals(readOnlySpan2, MemoryExtensions.AsSpan("Propagate"), StringComparison.OrdinalIgnoreCase))
						{
							samplingResult = ActivitySamplingResult.PropagationData;
						}
						else
						{
							if (!MemoryExtensions.Equals(readOnlySpan2, MemoryExtensions.AsSpan("Record"), StringComparison.OrdinalIgnoreCase))
							{
								return;
							}
							samplingResult = ActivitySamplingResult.AllData;
						}
					}
				}
				else
				{
					span2 = readOnlySpan2;
				}
				if (span2.Length > 0)
				{
					if (MemoryExtensions.Equals(span2, MemoryExtensions.AsSpan("Start"), StringComparison.OrdinalIgnoreCase))
					{
						events = ActivityEvents.ActivityStart;
					}
					else
					{
						if (!MemoryExtensions.Equals(span2, MemoryExtensions.AsSpan("Stop"), StringComparison.OrdinalIgnoreCase))
						{
							return;
						}
						events = ActivityEvents.ActivityStop;
					}
				}
			}
			else
			{
				span = readOnlySpan;
			}
			string activityName = null;
			int num4 = span.IndexOf('+');
			if (num4 >= 0)
			{
				activityName = span.Slice(num4 + 1).Trim().ToString();
				span = span.Slice(0, num4).Trim();
			}
			new FilterAndTransform(filterAndPayloadSpec, endIdx, num, span.ToString(), activityName, events, samplingResult, eventSource);
		}

		private static ActivitySamplingResult Sample(string activitySourceName, string activityName, DiagnosticSourceEventSource eventSource)
		{
			FilterAndTransform filterAndTransform = eventSource._activitySourceSpecs;
			ActivitySamplingResult activitySamplingResult = ActivitySamplingResult.None;
			ActivitySamplingResult activitySamplingResult2 = ActivitySamplingResult.None;
			while (filterAndTransform != null)
			{
				if (filterAndTransform.ActivityName == null || filterAndTransform.ActivityName == activityName)
				{
					if (activitySourceName == filterAndTransform.SourceName)
					{
						if (filterAndTransform.SamplingResult > activitySamplingResult)
						{
							activitySamplingResult = filterAndTransform.SamplingResult;
						}
						if (activitySamplingResult >= ActivitySamplingResult.AllDataAndRecorded)
						{
							return activitySamplingResult;
						}
					}
					else if (filterAndTransform.SourceName == "*")
					{
						if (activitySamplingResult != 0)
						{
							return activitySamplingResult;
						}
						if (filterAndTransform.SamplingResult > activitySamplingResult2)
						{
							activitySamplingResult2 = filterAndTransform.SamplingResult;
						}
					}
				}
				filterAndTransform = filterAndTransform.Next;
			}
			if (activitySamplingResult == ActivitySamplingResult.None)
			{
				return activitySamplingResult2;
			}
			return activitySamplingResult;
		}

		internal static void CreateActivityListener(DiagnosticSourceEventSource eventSource)
		{
			eventSource._activityListener = new ActivityListener();
			eventSource._activityListener.SampleUsingParentId = delegate(ref ActivityCreationOptions<string> activityOptions)
			{
				return Sample(activityOptions.Source.Name, activityOptions.Name, eventSource);
			};
			eventSource._activityListener.Sample = delegate(ref ActivityCreationOptions<ActivityContext> activityOptions)
			{
				return Sample(activityOptions.Source.Name, activityOptions.Name, eventSource);
			};
			eventSource._activityListener.ShouldListenTo = delegate(ActivitySource activitySource)
			{
				for (FilterAndTransform filterAndTransform = eventSource._activitySourceSpecs; filterAndTransform != null; filterAndTransform = filterAndTransform.Next)
				{
					if (activitySource.Name == filterAndTransform.SourceName || filterAndTransform.SourceName == "*")
					{
						return true;
					}
				}
				return false;
			};
			eventSource._activityListener.ActivityStarted = delegate(Activity activity)
			{
				OnActivityStarted(eventSource, activity);
			};
			eventSource._activityListener.ActivityStopped = delegate(Activity activity)
			{
				OnActivityStopped(eventSource, activity);
			};
			ActivitySource.AddActivityListener(eventSource._activityListener);
		}

		[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(ActivityContext))]
		[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(Activity))]
		[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(ActivityLink))]
		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Activity's properties are being preserved with the DynamicDependencies on OnActivityStarted.")]
		[DynamicDependency("Ticks", typeof(TimeSpan))]
		[DynamicDependency("Ticks", typeof(DateTime))]
		[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(ActivityEvent))]
		private static void OnActivityStarted(DiagnosticSourceEventSource eventSource, Activity activity)
		{
			for (FilterAndTransform filterAndTransform = eventSource._activitySourceSpecs; filterAndTransform != null; filterAndTransform = filterAndTransform.Next)
			{
				if ((filterAndTransform.Events & ActivityEvents.ActivityStart) != 0 && (activity.Source.Name == filterAndTransform.SourceName || filterAndTransform.SourceName == "*") && (filterAndTransform.ActivityName == null || filterAndTransform.ActivityName == activity.OperationName))
				{
					eventSource.ActivityStart(activity.Source.Name, activity.OperationName, filterAndTransform.Morph(activity));
					break;
				}
			}
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Activity's properties are being preserved with the DynamicDependencies on OnActivityStarted.")]
		private static void OnActivityStopped(DiagnosticSourceEventSource eventSource, Activity activity)
		{
			for (FilterAndTransform filterAndTransform = eventSource._activitySourceSpecs; filterAndTransform != null; filterAndTransform = filterAndTransform.Next)
			{
				if ((filterAndTransform.Events & ActivityEvents.ActivityStop) != 0 && (activity.Source.Name == filterAndTransform.SourceName || filterAndTransform.SourceName == "*") && (filterAndTransform.ActivityName == null || filterAndTransform.ActivityName == activity.OperationName))
				{
					eventSource.ActivityStop(activity.Source.Name, activity.OperationName, filterAndTransform.Morph(activity));
					break;
				}
			}
		}

		internal static void NormalizeActivitySourceSpecsList(DiagnosticSourceEventSource eventSource)
		{
			FilterAndTransform filterAndTransform = eventSource._activitySourceSpecs;
			FilterAndTransform filterAndTransform2 = null;
			FilterAndTransform filterAndTransform3 = null;
			FilterAndTransform filterAndTransform4 = null;
			FilterAndTransform filterAndTransform5 = null;
			while (filterAndTransform != null)
			{
				if (filterAndTransform.SourceName == "*")
				{
					if (filterAndTransform4 == null)
					{
						filterAndTransform4 = (filterAndTransform5 = filterAndTransform);
					}
					else
					{
						filterAndTransform5.Next = filterAndTransform;
						filterAndTransform5 = filterAndTransform;
					}
				}
				else if (filterAndTransform2 == null)
				{
					filterAndTransform2 = (filterAndTransform3 = filterAndTransform);
				}
				else
				{
					filterAndTransform3.Next = filterAndTransform;
					filterAndTransform3 = filterAndTransform;
				}
				filterAndTransform = filterAndTransform.Next;
			}
			if (filterAndTransform2 != null && filterAndTransform4 != null)
			{
				filterAndTransform3.Next = filterAndTransform4;
				filterAndTransform5.Next = null;
				eventSource._activitySourceSpecs = filterAndTransform2;
			}
		}

		private void Dispose()
		{
			if (_diagnosticsListenersSubscription != null)
			{
				_diagnosticsListenersSubscription.Dispose();
				_diagnosticsListenersSubscription = null;
			}
			if (_liveSubscriptions != null)
			{
				Subscriptions subscriptions = _liveSubscriptions;
				_liveSubscriptions = null;
				while (subscriptions != null)
				{
					subscriptions.Subscription.Dispose();
					subscriptions = subscriptions.Next;
				}
			}
		}

		[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
		public List<KeyValuePair<string, string>> Morph(object args)
		{
			List<KeyValuePair<string, string>> list = new List<KeyValuePair<string, string>>();
			if (args != null)
			{
				if (!_noImplicitTransforms)
				{
					Type type2 = args.GetType();
					ImplicitTransformEntry firstImplicitTransformsEntry = _firstImplicitTransformsEntry;
					TransformSpec transformSpec;
					if (firstImplicitTransformsEntry != null && firstImplicitTransformsEntry.Type == type2)
					{
						transformSpec = firstImplicitTransformsEntry.Transforms;
					}
					else if (firstImplicitTransformsEntry == null)
					{
						transformSpec = MakeImplicitTransforms(type2);
						Interlocked.CompareExchange(ref _firstImplicitTransformsEntry, new ImplicitTransformEntry
						{
							Type = type2,
							Transforms = transformSpec
						}, null);
					}
					else
					{
						if (_implicitTransformsTable == null)
						{
							Interlocked.CompareExchange(ref _implicitTransformsTable, new ConcurrentDictionary<Type, TransformSpec>(1, 8), null);
						}
						transformSpec = _implicitTransformsTable.GetOrAdd(type2, (Type type) => MakeImplicitTransformsWrapper(type));
					}
					if (transformSpec != null)
					{
						for (TransformSpec transformSpec2 = transformSpec; transformSpec2 != null; transformSpec2 = transformSpec2.Next)
						{
							list.Add(transformSpec2.Morph(args));
						}
					}
				}
				if (_explicitTransforms != null)
				{
					for (TransformSpec transformSpec3 = _explicitTransforms; transformSpec3 != null; transformSpec3 = transformSpec3.Next)
					{
						KeyValuePair<string, string> item = transformSpec3.Morph(args);
						if (item.Value != null)
						{
							list.Add(item);
						}
					}
				}
			}
			return list;
			[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The Morph method has RequiresUnreferencedCode, but the trimmer can't see through lamdba calls.")]
			static TransformSpec MakeImplicitTransformsWrapper(Type transformType)
			{
				return MakeImplicitTransforms(transformType);
			}
		}

		[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
		private static TransformSpec MakeImplicitTransforms(Type type)
		{
			TransformSpec transformSpec = null;
			TypeInfo typeInfo = type.GetTypeInfo();
			PropertyInfo[] properties = typeInfo.GetProperties(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (!(propertyInfo.GetMethod == null) && propertyInfo.GetMethod.GetParameters().Length == 0)
				{
					transformSpec = new TransformSpec(propertyInfo.Name, 0, propertyInfo.Name.Length, transformSpec);
				}
			}
			return Reverse(transformSpec);
		}

		private static TransformSpec Reverse(TransformSpec list)
		{
			TransformSpec transformSpec = null;
			while (list != null)
			{
				TransformSpec next = list.Next;
				list.Next = transformSpec;
				transformSpec = list;
				list = next;
			}
			return transformSpec;
		}
	}

	internal sealed class ImplicitTransformEntry
	{
		public Type Type;

		public TransformSpec Transforms;
	}

	internal sealed class TransformSpec
	{
		internal sealed class PropertySpec
		{
			private class PropertyFetch
			{
				private sealed class RefTypedFetchProperty<TObject, TProperty> : PropertyFetch
				{
					private readonly Func<TObject, TProperty> _propertyFetch;

					public RefTypedFetchProperty(Type type, PropertyInfo property)
						: base(type)
					{
						_propertyFetch = (Func<TObject, TProperty>)property.GetMethod.CreateDelegate(typeof(Func<TObject, TProperty>));
					}

					public override object Fetch(object obj)
					{
						return _propertyFetch((TObject)obj);
					}
				}

				private delegate TProperty StructFunc<TStruct, TProperty>(ref TStruct thisArg);

				private sealed class ValueTypedFetchProperty<TStruct, TProperty> : PropertyFetch
				{
					private readonly StructFunc<TStruct, TProperty> _propertyFetch;

					public ValueTypedFetchProperty(Type type, PropertyInfo property)
						: base(type)
					{
						_propertyFetch = (StructFunc<TStruct, TProperty>)property.GetMethod.CreateDelegate(typeof(StructFunc<TStruct, TProperty>));
					}

					public override object Fetch(object obj)
					{
						TStruct thisArg = (TStruct)obj;
						return _propertyFetch(ref thisArg);
					}
				}

				private sealed class CurrentActivityPropertyFetch : PropertyFetch
				{
					public CurrentActivityPropertyFetch()
						: base(null)
					{
					}

					public override object Fetch(object obj)
					{
						return Activity.Current;
					}
				}

				private sealed class EnumeratePropertyFetch<ElementType> : PropertyFetch
				{
					public EnumeratePropertyFetch(Type type)
						: base(type)
					{
					}

					public override object Fetch(object obj)
					{
						return string.Join(",", (IEnumerable<ElementType>)obj);
					}
				}

				internal Type Type { get; }

				public PropertyFetch(Type type)
				{
					Type = type;
				}

				[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
				[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
				public static PropertyFetch FetcherForProperty(Type type, string propertyName)
				{
					if (propertyName == null)
					{
						return new PropertyFetch(type);
					}
					if (propertyName == "*Activity")
					{
						return new CurrentActivityPropertyFetch();
					}
					TypeInfo typeInfo = type.GetTypeInfo();
					if (propertyName == "*Enumerate")
					{
						Type[] interfaces = typeInfo.GetInterfaces();
						foreach (Type type2 in interfaces)
						{
							TypeInfo typeInfo2 = type2.GetTypeInfo();
							if (typeInfo2.IsGenericType && !(typeInfo2.GetGenericTypeDefinition() != typeof(IEnumerable<>)))
							{
								return CreateEnumeratePropertyFetch(type, typeInfo2);
							}
						}
						Log.Message($"*Enumerate applied to non-enumerable type {type}");
						return new PropertyFetch(type);
					}
					PropertyInfo propertyInfo = typeInfo.GetDeclaredProperty(propertyName);
					if (propertyInfo == null)
					{
						PropertyInfo[] properties = typeInfo.GetProperties(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
						foreach (PropertyInfo propertyInfo2 in properties)
						{
							if (propertyInfo2.Name == propertyName)
							{
								propertyInfo = propertyInfo2;
								break;
							}
						}
					}
					if (propertyInfo == null)
					{
						Log.Message($"Property {propertyName} not found on {type}. Ensure the name is spelled correctly. If you published the application with PublishTrimmed=true, ensure the property was not trimmed away.");
						return new PropertyFetch(type);
					}
					MethodInfo? getMethod = propertyInfo.GetMethod;
					if ((object)getMethod == null || !getMethod.IsStatic)
					{
						MethodInfo? setMethod = propertyInfo.SetMethod;
						if ((object)setMethod == null || !setMethod.IsStatic)
						{
							return CreatePropertyFetch(typeInfo, propertyInfo);
						}
					}
					Log.Message("Property " + propertyName + " is static.");
					return new PropertyFetch(type);
				}

				[UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCode", Justification = "MakeGenericType is only called when IsDynamicCodeSupported is true or only with ref types.")]
				private static PropertyFetch CreateEnumeratePropertyFetch(Type type, Type enumerableOfTType)
				{
					Type type2 = enumerableOfTType.GetGenericArguments()[0];
					Type type3 = typeof(EnumeratePropertyFetch<>).GetTypeInfo().MakeGenericType(type2);
					return (PropertyFetch)Activator.CreateInstance(type3, type);
				}

				[UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCode", Justification = "MakeGenericType is only called when IsDynamicCodeSupported is true or only with ref types.")]
				private static PropertyFetch CreatePropertyFetch(Type type, PropertyInfo propertyInfo)
				{
					Type type2 = (type.IsValueType ? typeof(ValueTypedFetchProperty<, >) : typeof(RefTypedFetchProperty<, >));
					Type type3 = type2.GetTypeInfo().MakeGenericType(propertyInfo.DeclaringType, propertyInfo.PropertyType);
					return (PropertyFetch)Activator.CreateInstance(type3, type, propertyInfo);
				}

				public virtual object Fetch(object obj)
				{
					return null;
				}
			}

			private const string CurrentActivityPropertyName = "*Activity";

			private const string EnumeratePropertyName = "*Enumerate";

			public PropertySpec Next;

			private readonly string _propertyName;

			private volatile PropertyFetch _fetchForExpectedType;

			public bool IsStatic { get; private set; }

			public PropertySpec(string propertyName, PropertySpec next)
			{
				Next = next;
				_propertyName = propertyName;
				if (_propertyName == "*Activity")
				{
					IsStatic = true;
				}
			}

			[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
			[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
			public object Fetch(object obj)
			{
				PropertyFetch propertyFetch = _fetchForExpectedType;
				Type type = obj?.GetType();
				if (propertyFetch == null || propertyFetch.Type != type)
				{
					propertyFetch = (_fetchForExpectedType = PropertyFetch.FetcherForProperty(type, _propertyName));
				}
				object result = null;
				try
				{
					result = propertyFetch.Fetch(obj);
				}
				catch (Exception arg)
				{
					Log.Message($"Property {type}.{_propertyName} threw the exception {arg}");
				}
				return result;
			}
		}

		public TransformSpec Next;

		private readonly string _outputName;

		private readonly PropertySpec _fetches;

		public TransformSpec(string transformSpec, int startIdx, int endIdx, TransformSpec next = null)
		{
			Next = next;
			int num = transformSpec.IndexOf('=', startIdx, endIdx - startIdx);
			if (0 <= num)
			{
				_outputName = transformSpec.Substring(startIdx, num - startIdx);
				startIdx = num + 1;
			}
			while (startIdx < endIdx)
			{
				int num2 = transformSpec.LastIndexOf('.', endIdx - 1, endIdx - startIdx);
				int num3 = startIdx;
				if (0 <= num2)
				{
					num3 = num2 + 1;
				}
				string text = transformSpec.Substring(num3, endIdx - num3);
				_fetches = new PropertySpec(text, _fetches);
				if (_outputName == null)
				{
					_outputName = text;
				}
				endIdx = num2;
			}
		}

		[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
		public KeyValuePair<string, string> Morph(object obj)
		{
			for (PropertySpec propertySpec = _fetches; propertySpec != null; propertySpec = propertySpec.Next)
			{
				if (obj != null || propertySpec.IsStatic)
				{
					obj = propertySpec.Fetch(obj);
				}
			}
			return new KeyValuePair<string, string>(_outputName, obj?.ToString());
		}
	}

	internal sealed class CallbackObserver<T> : IObserver<T>
	{
		private readonly Action<T> _callback;

		public CallbackObserver(Action<T> callback)
		{
			_callback = callback;
		}

		public void OnCompleted()
		{
		}

		public void OnError(Exception error)
		{
		}

		public void OnNext(T value)
		{
			_callback(value);
		}
	}

	internal sealed class Subscriptions
	{
		public IDisposable Subscription;

		public Subscriptions Next;

		public Subscriptions(IDisposable subscription, Subscriptions next)
		{
			Subscription = subscription;
			Next = next;
		}
	}

	public static DiagnosticSourceEventSource Log = new DiagnosticSourceEventSource();

	private readonly string AspNetCoreHostingKeywordValue = "Microsoft.AspNetCore/Microsoft.AspNetCore.Hosting.BeginRequest@Activity1Start:-httpContext.Request.Method;httpContext.Request.Host;httpContext.Request.Path;httpContext.Request.QueryString\nMicrosoft.AspNetCore/Microsoft.AspNetCore.Hosting.EndRequest@Activity1Stop:-httpContext.TraceIdentifier;httpContext.Response.StatusCode";

	private readonly string EntityFrameworkCoreCommandsKeywordValue = "Microsoft.EntityFrameworkCore/Microsoft.EntityFrameworkCore.BeforeExecuteCommand@Activity2Start:-Command.Connection.DataSource;Command.Connection.Database;Command.CommandText\nMicrosoft.EntityFrameworkCore/Microsoft.EntityFrameworkCore.AfterExecuteCommand@Activity2Stop:-";

	private volatile bool _false;

	private FilterAndTransform _specs;

	private FilterAndTransform _activitySourceSpecs;

	private ActivityListener _activityListener;

	[Event(1, Keywords = (EventKeywords)1L)]
	public void Message(string Message)
	{
		WriteEvent(1, Message);
	}

	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Arguments parameter is preserved by DynamicDependency")]
	[Event(2, Keywords = (EventKeywords)2L)]
	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(KeyValuePair<, >))]
	private void Event(string SourceName, string EventName, IEnumerable<KeyValuePair<string, string>> Arguments)
	{
		WriteEvent(2, SourceName, EventName, Arguments);
	}

	[Event(3, Keywords = (EventKeywords)2L)]
	private void EventJson(string SourceName, string EventName, string ArgmentsJson)
	{
		WriteEvent(3, SourceName, EventName, ArgmentsJson);
	}

	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(KeyValuePair<, >))]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Arguments parameter is preserved by DynamicDependency")]
	[Event(4, Keywords = (EventKeywords)2L)]
	private void Activity1Start(string SourceName, string EventName, IEnumerable<KeyValuePair<string, string>> Arguments)
	{
		WriteEvent(4, SourceName, EventName, Arguments);
	}

	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Arguments parameter is preserved by DynamicDependency")]
	[Event(5, Keywords = (EventKeywords)2L)]
	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(KeyValuePair<, >))]
	private void Activity1Stop(string SourceName, string EventName, IEnumerable<KeyValuePair<string, string>> Arguments)
	{
		WriteEvent(5, SourceName, EventName, Arguments);
	}

	[Event(6, Keywords = (EventKeywords)2L)]
	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(KeyValuePair<, >))]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Arguments parameter is preserved by DynamicDependency")]
	private void Activity2Start(string SourceName, string EventName, IEnumerable<KeyValuePair<string, string>> Arguments)
	{
		WriteEvent(6, SourceName, EventName, Arguments);
	}

	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(KeyValuePair<, >))]
	[Event(7, Keywords = (EventKeywords)2L)]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Arguments parameter is preserved by DynamicDependency")]
	private void Activity2Stop(string SourceName, string EventName, IEnumerable<KeyValuePair<string, string>> Arguments)
	{
		WriteEvent(7, SourceName, EventName, Arguments);
	}

	[Event(8, Keywords = (EventKeywords)2L, ActivityOptions = EventActivityOptions.Recursive)]
	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(KeyValuePair<, >))]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Arguments parameter is preserved by DynamicDependency")]
	private void RecursiveActivity1Start(string SourceName, string EventName, IEnumerable<KeyValuePair<string, string>> Arguments)
	{
		WriteEvent(8, SourceName, EventName, Arguments);
	}

	[Event(9, Keywords = (EventKeywords)2L, ActivityOptions = EventActivityOptions.Recursive)]
	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(KeyValuePair<, >))]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Arguments parameter is preserved by DynamicDependency")]
	private void RecursiveActivity1Stop(string SourceName, string EventName, IEnumerable<KeyValuePair<string, string>> Arguments)
	{
		WriteEvent(9, SourceName, EventName, Arguments);
	}

	[Event(10, Keywords = (EventKeywords)2L)]
	private void NewDiagnosticListener(string SourceName)
	{
		WriteEvent(10, SourceName);
	}

	[Event(11, Keywords = (EventKeywords)2L, ActivityOptions = EventActivityOptions.Recursive)]
	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(KeyValuePair<, >))]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Arguments parameter is preserved by DynamicDependency")]
	private void ActivityStart(string SourceName, string ActivityName, IEnumerable<KeyValuePair<string, string>> Arguments)
	{
		WriteEvent(11, SourceName, ActivityName, Arguments);
	}

	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Arguments parameter is preserved by DynamicDependency")]
	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(KeyValuePair<, >))]
	[Event(12, Keywords = (EventKeywords)2L, ActivityOptions = EventActivityOptions.Recursive)]
	private void ActivityStop(string SourceName, string ActivityName, IEnumerable<KeyValuePair<string, string>> Arguments)
	{
		WriteEvent(12, SourceName, ActivityName, Arguments);
	}

	private DiagnosticSourceEventSource()
		: base(EventSourceSettings.EtwSelfDescribingEventFormat)
	{
	}

	[NonEvent]
	protected override void OnEventCommand(EventCommandEventArgs command)
	{
		BreakPointWithDebuggerFuncEval();
		lock (this)
		{
			if ((command.Command == EventCommand.Update || command.Command == EventCommand.Enable) && IsEnabled(EventLevel.Informational, (EventKeywords)2L))
			{
				string value = null;
				command.Arguments.TryGetValue("FilterAndPayloadSpecs", out value);
				if (!IsEnabled(EventLevel.Informational, (EventKeywords)2048L))
				{
					if (IsEnabled(EventLevel.Informational, (EventKeywords)4096L))
					{
						value = NewLineSeparate(value, AspNetCoreHostingKeywordValue);
					}
					if (IsEnabled(EventLevel.Informational, (EventKeywords)8192L))
					{
						value = NewLineSeparate(value, EntityFrameworkCoreCommandsKeywordValue);
					}
				}
				FilterAndTransform.CreateFilterAndTransformList(ref _specs, value, this);
			}
			else if (command.Command == EventCommand.Update || command.Command == EventCommand.Disable)
			{
				FilterAndTransform.DestroyFilterAndTransformList(ref _specs, this);
			}
		}
	}

	private static string NewLineSeparate(string str1, string str2)
	{
		if (string.IsNullOrEmpty(str1))
		{
			return str2;
		}
		return str1 + "\n" + str2;
	}

	[MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
	[NonEvent]
	private void BreakPointWithDebuggerFuncEval()
	{
		new object();
		while (_false)
		{
			_false = false;
		}
	}
}


using System.Diagnostics.Tracing;

public static class Keywords
{
	public const EventKeywords Messages = (EventKeywords)1L;

	public const EventKeywords Events = (EventKeywords)2L;

	public const EventKeywords IgnoreShortCutKeywords = (EventKeywords)2048L;

	public const EventKeywords AspNetCoreHosting = (EventKeywords)4096L;

	public const EventKeywords EntityFrameworkCoreCommands = (EventKeywords)8192L;
}


[Flags]
internal enum ActivityEvents
{
	None = 0,
	ActivityStart = 1,
	ActivityStop = 2,
	All = 3
}


using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Tracing;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;

internal sealed class FilterAndTransform
{
	public FilterAndTransform Next;

	internal const string c_ActivitySourcePrefix = "[AS]";

	private IDisposable _diagnosticsListenersSubscription;

	private Subscriptions _liveSubscriptions;

	private readonly bool _noImplicitTransforms;

	private ImplicitTransformEntry _firstImplicitTransformsEntry;

	private ConcurrentDictionary<Type, TransformSpec> _implicitTransformsTable;

	private readonly TransformSpec _explicitTransforms;

	private readonly DiagnosticSourceEventSource _eventSource;

	internal string SourceName { get; set; }

	internal string ActivityName { get; set; }

	internal ActivityEvents Events { get; set; }

	internal ActivitySamplingResult SamplingResult { get; set; }

	public static void CreateFilterAndTransformList(ref FilterAndTransform specList, string filterAndPayloadSpecs, DiagnosticSourceEventSource eventSource)
	{
		DestroyFilterAndTransformList(ref specList, eventSource);
		if (filterAndPayloadSpecs == null)
		{
			filterAndPayloadSpecs = "";
		}
		int num = filterAndPayloadSpecs.Length;
		while (true)
		{
			if (0 < num && char.IsWhiteSpace(filterAndPayloadSpecs[num - 1]))
			{
				num--;
				continue;
			}
			int num2 = filterAndPayloadSpecs.LastIndexOf('\n', num - 1, num);
			int i = 0;
			if (0 <= num2)
			{
				i = num2 + 1;
			}
			for (; i < num && char.IsWhiteSpace(filterAndPayloadSpecs[i]); i++)
			{
			}
			if (IsActivitySourceEntry(filterAndPayloadSpecs, i, num))
			{
				AddNewActivitySourceTransform(filterAndPayloadSpecs, i, num, eventSource);
			}
			else
			{
				specList = new FilterAndTransform(filterAndPayloadSpecs, i, num, eventSource, specList);
			}
			num = num2;
			if (num < 0)
			{
				break;
			}
		}
		if (eventSource._activitySourceSpecs != null)
		{
			NormalizeActivitySourceSpecsList(eventSource);
			CreateActivityListener(eventSource);
		}
	}

	public static void DestroyFilterAndTransformList(ref FilterAndTransform specList, DiagnosticSourceEventSource eventSource)
	{
		eventSource._activityListener?.Dispose();
		eventSource._activityListener = null;
		eventSource._activitySourceSpecs = null;
		FilterAndTransform filterAndTransform = specList;
		specList = null;
		while (filterAndTransform != null)
		{
			filterAndTransform.Dispose();
			filterAndTransform = filterAndTransform.Next;
		}
	}

	public FilterAndTransform(string filterAndPayloadSpec, int startIdx, int endIdx, DiagnosticSourceEventSource eventSource, FilterAndTransform next)
	{
		FilterAndTransform filterAndTransform = this;
		Next = next;
		_eventSource = eventSource;
		string listenerNameFilter = null;
		string eventNameFilter = null;
		string text = null;
		int num = startIdx;
		int num2 = endIdx;
		int num3 = filterAndPayloadSpec.IndexOf(':', startIdx, endIdx - startIdx);
		if (0 <= num3)
		{
			num2 = num3;
			num = num3 + 1;
		}
		int num4 = filterAndPayloadSpec.IndexOf('/', startIdx, num2 - startIdx);
		if (0 <= num4)
		{
			listenerNameFilter = filterAndPayloadSpec.Substring(startIdx, num4 - startIdx);
			int num5 = filterAndPayloadSpec.IndexOf('@', num4 + 1, num2 - num4 - 1);
			if (0 <= num5)
			{
				text = filterAndPayloadSpec.Substring(num5 + 1, num2 - num5 - 1);
				eventNameFilter = filterAndPayloadSpec.Substring(num4 + 1, num5 - num4 - 1);
			}
			else
			{
				eventNameFilter = filterAndPayloadSpec.Substring(num4 + 1, num2 - num4 - 1);
			}
		}
		else if (startIdx < num2)
		{
			listenerNameFilter = filterAndPayloadSpec.Substring(startIdx, num2 - startIdx);
		}
		_eventSource.Message("DiagnosticSource: Enabling '" + (listenerNameFilter ?? "*") + "/" + (eventNameFilter ?? "*") + "'");
		if (num < endIdx && filterAndPayloadSpec[num] == '-')
		{
			_eventSource.Message("DiagnosticSource: suppressing implicit transforms.");
			_noImplicitTransforms = true;
			num++;
		}
		if (num < endIdx)
		{
			while (true)
			{
				int num6 = num;
				int num7 = filterAndPayloadSpec.LastIndexOf(';', endIdx - 1, endIdx - num);
				if (0 <= num7)
				{
					num6 = num7 + 1;
				}
				if (num6 < endIdx)
				{
					if (_eventSource.IsEnabled(EventLevel.Informational, (EventKeywords)1L))
					{
						_eventSource.Message("DiagnosticSource: Parsing Explicit Transform '" + filterAndPayloadSpec.Substring(num6, endIdx - num6) + "'");
					}
					_explicitTransforms = new TransformSpec(filterAndPayloadSpec, num6, endIdx, _explicitTransforms);
				}
				if (num == num6)
				{
					break;
				}
				endIdx = num7;
			}
		}
		Action<string, string, IEnumerable<KeyValuePair<string, string>>> writeEvent = null;
		if (text != null && text.Contains("Activity"))
		{
			writeEvent = text switch
			{
				"Activity1Start" => _eventSource.Activity1Start, 
				"Activity1Stop" => _eventSource.Activity1Stop, 
				"Activity2Start" => _eventSource.Activity2Start, 
				"Activity2Stop" => _eventSource.Activity2Stop, 
				"RecursiveActivity1Start" => _eventSource.RecursiveActivity1Start, 
				"RecursiveActivity1Stop" => _eventSource.RecursiveActivity1Stop, 
				_ => null, 
			};
			if (writeEvent == null)
			{
				_eventSource.Message("DiagnosticSource: Could not find Event to log Activity " + text);
			}
		}
		if (writeEvent == null)
		{
			writeEvent = _eventSource.Event;
		}
		_diagnosticsListenersSubscription = DiagnosticListener.AllListeners.Subscribe(new CallbackObserver<DiagnosticListener>(delegate(DiagnosticListener newListener)
		{
			if (listenerNameFilter == null || listenerNameFilter == newListener.Name)
			{
				filterAndTransform._eventSource.NewDiagnosticListener(newListener.Name);
				Predicate<string> isEnabled = null;
				if (eventNameFilter != null)
				{
					isEnabled = (string eventName) => eventNameFilter == eventName;
				}
				IDisposable subscription = newListener.Subscribe(new CallbackObserver<KeyValuePair<string, object>>(OnEventWritten), isEnabled);
				filterAndTransform._liveSubscriptions = new Subscriptions(subscription, filterAndTransform._liveSubscriptions);
			}
			[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "DiagnosticSource.Write is marked with RequiresUnreferencedCode.")]
			[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2119", Justification = "DAM on EventSource references this compiler-generated local function which calls a method that requires unreferenced code. EventSource will not access this local function.")]
			void OnEventWritten(KeyValuePair<string, object> evnt)
			{
				if (eventNameFilter == null || !(eventNameFilter != evnt.Key))
				{
					List<KeyValuePair<string, string>> arg = filterAndTransform.Morph(evnt.Value);
					string key = evnt.Key;
					writeEvent(newListener.Name, key, arg);
				}
			}
		}));
	}

	internal FilterAndTransform(string filterAndPayloadSpec, int endIdx, int colonIdx, string activitySourceName, string activityName, ActivityEvents events, ActivitySamplingResult samplingResult, DiagnosticSourceEventSource eventSource)
	{
		_eventSource = eventSource;
		Next = _eventSource._activitySourceSpecs;
		_eventSource._activitySourceSpecs = this;
		SourceName = activitySourceName;
		ActivityName = activityName;
		Events = events;
		SamplingResult = samplingResult;
		if (colonIdx < 0)
		{
			return;
		}
		int num = colonIdx + 1;
		if (num < endIdx && filterAndPayloadSpec[num] == '-')
		{
			_eventSource.Message("DiagnosticSource: suppressing implicit transforms.");
			_noImplicitTransforms = true;
			num++;
		}
		if (num >= endIdx)
		{
			return;
		}
		while (true)
		{
			int num2 = num;
			int num3 = filterAndPayloadSpec.LastIndexOf(';', endIdx - 1, endIdx - num);
			if (0 <= num3)
			{
				num2 = num3 + 1;
			}
			if (num2 < endIdx)
			{
				if (_eventSource.IsEnabled(EventLevel.Informational, (EventKeywords)1L))
				{
					_eventSource.Message("DiagnosticSource: Parsing Explicit Transform '" + filterAndPayloadSpec.Substring(num2, endIdx - num2) + "'");
				}
				_explicitTransforms = new TransformSpec(filterAndPayloadSpec, num2, endIdx, _explicitTransforms);
			}
			if (num != num2)
			{
				endIdx = num3;
				continue;
			}
			break;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static bool IsActivitySourceEntry(string filterAndPayloadSpec, int startIdx, int endIdx)
	{
		return MemoryExtensions.AsSpan(filterAndPayloadSpec, startIdx, endIdx - startIdx).StartsWith(MemoryExtensions.AsSpan("[AS]"), StringComparison.Ordinal);
	}

	internal static void AddNewActivitySourceTransform(string filterAndPayloadSpec, int startIdx, int endIdx, DiagnosticSourceEventSource eventSource)
	{
		ActivityEvents events = ActivityEvents.All;
		ActivitySamplingResult samplingResult = ActivitySamplingResult.AllDataAndRecorded;
		int num = filterAndPayloadSpec.IndexOf(':', startIdx + "[AS]".Length, endIdx - startIdx - "[AS]".Length);
		ReadOnlySpan<char> readOnlySpan = MemoryExtensions.AsSpan(filterAndPayloadSpec, startIdx + "[AS]".Length, ((num >= 0) ? num : endIdx) - startIdx - "[AS]".Length).Trim();
		int num2 = readOnlySpan.IndexOf('/');
		ReadOnlySpan<char> span;
		if (num2 >= 0)
		{
			span = readOnlySpan.Slice(0, num2).Trim();
			ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(num2 + 1).Trim();
			int num3 = readOnlySpan2.IndexOf('-');
			ReadOnlySpan<char> span2;
			if (num3 >= 0)
			{
				span2 = readOnlySpan2.Slice(0, num3).Trim();
				readOnlySpan2 = readOnlySpan2.Slice(num3 + 1).Trim();
				if (readOnlySpan2.Length > 0)
				{
					if (MemoryExtensions.Equals(readOnlySpan2, MemoryExtensions.AsSpan("Propagate"), StringComparison.OrdinalIgnoreCase))
					{
						samplingResult = ActivitySamplingResult.PropagationData;
					}
					else
					{
						if (!MemoryExtensions.Equals(readOnlySpan2, MemoryExtensions.AsSpan("Record"), StringComparison.OrdinalIgnoreCase))
						{
							return;
						}
						samplingResult = ActivitySamplingResult.AllData;
					}
				}
			}
			else
			{
				span2 = readOnlySpan2;
			}
			if (span2.Length > 0)
			{
				if (MemoryExtensions.Equals(span2, MemoryExtensions.AsSpan("Start"), StringComparison.OrdinalIgnoreCase))
				{
					events = ActivityEvents.ActivityStart;
				}
				else
				{
					if (!MemoryExtensions.Equals(span2, MemoryExtensions.AsSpan("Stop"), StringComparison.OrdinalIgnoreCase))
					{
						return;
					}
					events = ActivityEvents.ActivityStop;
				}
			}
		}
		else
		{
			span = readOnlySpan;
		}
		string activityName = null;
		int num4 = span.IndexOf('+');
		if (num4 >= 0)
		{
			activityName = span.Slice(num4 + 1).Trim().ToString();
			span = span.Slice(0, num4).Trim();
		}
		new FilterAndTransform(filterAndPayloadSpec, endIdx, num, span.ToString(), activityName, events, samplingResult, eventSource);
	}

	private static ActivitySamplingResult Sample(string activitySourceName, string activityName, DiagnosticSourceEventSource eventSource)
	{
		FilterAndTransform filterAndTransform = eventSource._activitySourceSpecs;
		ActivitySamplingResult activitySamplingResult = ActivitySamplingResult.None;
		ActivitySamplingResult activitySamplingResult2 = ActivitySamplingResult.None;
		while (filterAndTransform != null)
		{
			if (filterAndTransform.ActivityName == null || filterAndTransform.ActivityName == activityName)
			{
				if (activitySourceName == filterAndTransform.SourceName)
				{
					if (filterAndTransform.SamplingResult > activitySamplingResult)
					{
						activitySamplingResult = filterAndTransform.SamplingResult;
					}
					if (activitySamplingResult >= ActivitySamplingResult.AllDataAndRecorded)
					{
						return activitySamplingResult;
					}
				}
				else if (filterAndTransform.SourceName == "*")
				{
					if (activitySamplingResult != 0)
					{
						return activitySamplingResult;
					}
					if (filterAndTransform.SamplingResult > activitySamplingResult2)
					{
						activitySamplingResult2 = filterAndTransform.SamplingResult;
					}
				}
			}
			filterAndTransform = filterAndTransform.Next;
		}
		if (activitySamplingResult == ActivitySamplingResult.None)
		{
			return activitySamplingResult2;
		}
		return activitySamplingResult;
	}

	internal static void CreateActivityListener(DiagnosticSourceEventSource eventSource)
	{
		eventSource._activityListener = new ActivityListener();
		eventSource._activityListener.SampleUsingParentId = delegate(ref ActivityCreationOptions<string> activityOptions)
		{
			return Sample(activityOptions.Source.Name, activityOptions.Name, eventSource);
		};
		eventSource._activityListener.Sample = delegate(ref ActivityCreationOptions<ActivityContext> activityOptions)
		{
			return Sample(activityOptions.Source.Name, activityOptions.Name, eventSource);
		};
		eventSource._activityListener.ShouldListenTo = delegate(ActivitySource activitySource)
		{
			for (FilterAndTransform filterAndTransform = eventSource._activitySourceSpecs; filterAndTransform != null; filterAndTransform = filterAndTransform.Next)
			{
				if (activitySource.Name == filterAndTransform.SourceName || filterAndTransform.SourceName == "*")
				{
					return true;
				}
			}
			return false;
		};
		eventSource._activityListener.ActivityStarted = delegate(Activity activity)
		{
			OnActivityStarted(eventSource, activity);
		};
		eventSource._activityListener.ActivityStopped = delegate(Activity activity)
		{
			OnActivityStopped(eventSource, activity);
		};
		ActivitySource.AddActivityListener(eventSource._activityListener);
	}

	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(ActivityContext))]
	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(Activity))]
	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(ActivityLink))]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Activity's properties are being preserved with the DynamicDependencies on OnActivityStarted.")]
	[DynamicDependency("Ticks", typeof(TimeSpan))]
	[DynamicDependency("Ticks", typeof(DateTime))]
	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(ActivityEvent))]
	private static void OnActivityStarted(DiagnosticSourceEventSource eventSource, Activity activity)
	{
		for (FilterAndTransform filterAndTransform = eventSource._activitySourceSpecs; filterAndTransform != null; filterAndTransform = filterAndTransform.Next)
		{
			if ((filterAndTransform.Events & ActivityEvents.ActivityStart) != 0 && (activity.Source.Name == filterAndTransform.SourceName || filterAndTransform.SourceName == "*") && (filterAndTransform.ActivityName == null || filterAndTransform.ActivityName == activity.OperationName))
			{
				eventSource.ActivityStart(activity.Source.Name, activity.OperationName, filterAndTransform.Morph(activity));
				break;
			}
		}
	}

	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Activity's properties are being preserved with the DynamicDependencies on OnActivityStarted.")]
	private static void OnActivityStopped(DiagnosticSourceEventSource eventSource, Activity activity)
	{
		for (FilterAndTransform filterAndTransform = eventSource._activitySourceSpecs; filterAndTransform != null; filterAndTransform = filterAndTransform.Next)
		{
			if ((filterAndTransform.Events & ActivityEvents.ActivityStop) != 0 && (activity.Source.Name == filterAndTransform.SourceName || filterAndTransform.SourceName == "*") && (filterAndTransform.ActivityName == null || filterAndTransform.ActivityName == activity.OperationName))
			{
				eventSource.ActivityStop(activity.Source.Name, activity.OperationName, filterAndTransform.Morph(activity));
				break;
			}
		}
	}

	internal static void NormalizeActivitySourceSpecsList(DiagnosticSourceEventSource eventSource)
	{
		FilterAndTransform filterAndTransform = eventSource._activitySourceSpecs;
		FilterAndTransform filterAndTransform2 = null;
		FilterAndTransform filterAndTransform3 = null;
		FilterAndTransform filterAndTransform4 = null;
		FilterAndTransform filterAndTransform5 = null;
		while (filterAndTransform != null)
		{
			if (filterAndTransform.SourceName == "*")
			{
				if (filterAndTransform4 == null)
				{
					filterAndTransform4 = (filterAndTransform5 = filterAndTransform);
				}
				else
				{
					filterAndTransform5.Next = filterAndTransform;
					filterAndTransform5 = filterAndTransform;
				}
			}
			else if (filterAndTransform2 == null)
			{
				filterAndTransform2 = (filterAndTransform3 = filterAndTransform);
			}
			else
			{
				filterAndTransform3.Next = filterAndTransform;
				filterAndTransform3 = filterAndTransform;
			}
			filterAndTransform = filterAndTransform.Next;
		}
		if (filterAndTransform2 != null && filterAndTransform4 != null)
		{
			filterAndTransform3.Next = filterAndTransform4;
			filterAndTransform5.Next = null;
			eventSource._activitySourceSpecs = filterAndTransform2;
		}
	}

	private void Dispose()
	{
		if (_diagnosticsListenersSubscription != null)
		{
			_diagnosticsListenersSubscription.Dispose();
			_diagnosticsListenersSubscription = null;
		}
		if (_liveSubscriptions != null)
		{
			Subscriptions subscriptions = _liveSubscriptions;
			_liveSubscriptions = null;
			while (subscriptions != null)
			{
				subscriptions.Subscription.Dispose();
				subscriptions = subscriptions.Next;
			}
		}
	}

	[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
	public List<KeyValuePair<string, string>> Morph(object args)
	{
		List<KeyValuePair<string, string>> list = new List<KeyValuePair<string, string>>();
		if (args != null)
		{
			if (!_noImplicitTransforms)
			{
				Type type2 = args.GetType();
				ImplicitTransformEntry firstImplicitTransformsEntry = _firstImplicitTransformsEntry;
				TransformSpec transformSpec;
				if (firstImplicitTransformsEntry != null && firstImplicitTransformsEntry.Type == type2)
				{
					transformSpec = firstImplicitTransformsEntry.Transforms;
				}
				else if (firstImplicitTransformsEntry == null)
				{
					transformSpec = MakeImplicitTransforms(type2);
					Interlocked.CompareExchange(ref _firstImplicitTransformsEntry, new ImplicitTransformEntry
					{
						Type = type2,
						Transforms = transformSpec
					}, null);
				}
				else
				{
					if (_implicitTransformsTable == null)
					{
						Interlocked.CompareExchange(ref _implicitTransformsTable, new ConcurrentDictionary<Type, TransformSpec>(1, 8), null);
					}
					transformSpec = _implicitTransformsTable.GetOrAdd(type2, (Type type) => MakeImplicitTransformsWrapper(type));
				}
				if (transformSpec != null)
				{
					for (TransformSpec transformSpec2 = transformSpec; transformSpec2 != null; transformSpec2 = transformSpec2.Next)
					{
						list.Add(transformSpec2.Morph(args));
					}
				}
			}
			if (_explicitTransforms != null)
			{
				for (TransformSpec transformSpec3 = _explicitTransforms; transformSpec3 != null; transformSpec3 = transformSpec3.Next)
				{
					KeyValuePair<string, string> item = transformSpec3.Morph(args);
					if (item.Value != null)
					{
						list.Add(item);
					}
				}
			}
		}
		return list;
		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The Morph method has RequiresUnreferencedCode, but the trimmer can't see through lamdba calls.")]
		static TransformSpec MakeImplicitTransformsWrapper(Type transformType)
		{
			return MakeImplicitTransforms(transformType);
		}
	}

	[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
	private static TransformSpec MakeImplicitTransforms(Type type)
	{
		TransformSpec transformSpec = null;
		TypeInfo typeInfo = type.GetTypeInfo();
		PropertyInfo[] properties = typeInfo.GetProperties(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		foreach (PropertyInfo propertyInfo in properties)
		{
			if (!(propertyInfo.GetMethod == null) && propertyInfo.GetMethod.GetParameters().Length == 0)
			{
				transformSpec = new TransformSpec(propertyInfo.Name, 0, propertyInfo.Name.Length, transformSpec);
			}
		}
		return Reverse(transformSpec);
	}

	private static TransformSpec Reverse(TransformSpec list)
	{
		TransformSpec transformSpec = null;
		while (list != null)
		{
			TransformSpec next = list.Next;
			list.Next = transformSpec;
			transformSpec = list;
			list = next;
		}
		return transformSpec;
	}
}


internal sealed class ImplicitTransformEntry
{
	public Type Type;

	public TransformSpec Transforms;
}


using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

internal sealed class TransformSpec
{
	internal sealed class PropertySpec
	{
		private class PropertyFetch
		{
			private sealed class RefTypedFetchProperty<TObject, TProperty> : PropertyFetch
			{
				private readonly Func<TObject, TProperty> _propertyFetch;

				public RefTypedFetchProperty(Type type, PropertyInfo property)
					: base(type)
				{
					_propertyFetch = (Func<TObject, TProperty>)property.GetMethod.CreateDelegate(typeof(Func<TObject, TProperty>));
				}

				public override object Fetch(object obj)
				{
					return _propertyFetch((TObject)obj);
				}
			}

			private delegate TProperty StructFunc<TStruct, TProperty>(ref TStruct thisArg);

			private sealed class ValueTypedFetchProperty<TStruct, TProperty> : PropertyFetch
			{
				private readonly StructFunc<TStruct, TProperty> _propertyFetch;

				public ValueTypedFetchProperty(Type type, PropertyInfo property)
					: base(type)
				{
					_propertyFetch = (StructFunc<TStruct, TProperty>)property.GetMethod.CreateDelegate(typeof(StructFunc<TStruct, TProperty>));
				}

				public override object Fetch(object obj)
				{
					TStruct thisArg = (TStruct)obj;
					return _propertyFetch(ref thisArg);
				}
			}

			private sealed class CurrentActivityPropertyFetch : PropertyFetch
			{
				public CurrentActivityPropertyFetch()
					: base(null)
				{
				}

				public override object Fetch(object obj)
				{
					return Activity.Current;
				}
			}

			private sealed class EnumeratePropertyFetch<ElementType> : PropertyFetch
			{
				public EnumeratePropertyFetch(Type type)
					: base(type)
				{
				}

				public override object Fetch(object obj)
				{
					return string.Join(",", (IEnumerable<ElementType>)obj);
				}
			}

			internal Type Type { get; }

			public PropertyFetch(Type type)
			{
				Type = type;
			}

			[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
			[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
			public static PropertyFetch FetcherForProperty(Type type, string propertyName)
			{
				if (propertyName == null)
				{
					return new PropertyFetch(type);
				}
				if (propertyName == "*Activity")
				{
					return new CurrentActivityPropertyFetch();
				}
				TypeInfo typeInfo = type.GetTypeInfo();
				if (propertyName == "*Enumerate")
				{
					Type[] interfaces = typeInfo.GetInterfaces();
					foreach (Type type2 in interfaces)
					{
						TypeInfo typeInfo2 = type2.GetTypeInfo();
						if (typeInfo2.IsGenericType && !(typeInfo2.GetGenericTypeDefinition() != typeof(IEnumerable<>)))
						{
							return CreateEnumeratePropertyFetch(type, typeInfo2);
						}
					}
					Log.Message($"*Enumerate applied to non-enumerable type {type}");
					return new PropertyFetch(type);
				}
				PropertyInfo propertyInfo = typeInfo.GetDeclaredProperty(propertyName);
				if (propertyInfo == null)
				{
					PropertyInfo[] properties = typeInfo.GetProperties(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
					foreach (PropertyInfo propertyInfo2 in properties)
					{
						if (propertyInfo2.Name == propertyName)
						{
							propertyInfo = propertyInfo2;
							break;
						}
					}
				}
				if (propertyInfo == null)
				{
					Log.Message($"Property {propertyName} not found on {type}. Ensure the name is spelled correctly. If you published the application with PublishTrimmed=true, ensure the property was not trimmed away.");
					return new PropertyFetch(type);
				}
				MethodInfo? getMethod = propertyInfo.GetMethod;
				if ((object)getMethod == null || !getMethod.IsStatic)
				{
					MethodInfo? setMethod = propertyInfo.SetMethod;
					if ((object)setMethod == null || !setMethod.IsStatic)
					{
						return CreatePropertyFetch(typeInfo, propertyInfo);
					}
				}
				Log.Message("Property " + propertyName + " is static.");
				return new PropertyFetch(type);
			}

			[UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCode", Justification = "MakeGenericType is only called when IsDynamicCodeSupported is true or only with ref types.")]
			private static PropertyFetch CreateEnumeratePropertyFetch(Type type, Type enumerableOfTType)
			{
				Type type2 = enumerableOfTType.GetGenericArguments()[0];
				Type type3 = typeof(EnumeratePropertyFetch<>).GetTypeInfo().MakeGenericType(type2);
				return (PropertyFetch)Activator.CreateInstance(type3, type);
			}

			[UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCode", Justification = "MakeGenericType is only called when IsDynamicCodeSupported is true or only with ref types.")]
			private static PropertyFetch CreatePropertyFetch(Type type, PropertyInfo propertyInfo)
			{
				Type type2 = (type.IsValueType ? typeof(ValueTypedFetchProperty<, >) : typeof(RefTypedFetchProperty<, >));
				Type type3 = type2.GetTypeInfo().MakeGenericType(propertyInfo.DeclaringType, propertyInfo.PropertyType);
				return (PropertyFetch)Activator.CreateInstance(type3, type, propertyInfo);
			}

			public virtual object Fetch(object obj)
			{
				return null;
			}
		}

		private const string CurrentActivityPropertyName = "*Activity";

		private const string EnumeratePropertyName = "*Enumerate";

		public PropertySpec Next;

		private readonly string _propertyName;

		private volatile PropertyFetch _fetchForExpectedType;

		public bool IsStatic { get; private set; }

		public PropertySpec(string propertyName, PropertySpec next)
		{
			Next = next;
			_propertyName = propertyName;
			if (_propertyName == "*Activity")
			{
				IsStatic = true;
			}
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
		[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
		public object Fetch(object obj)
		{
			PropertyFetch propertyFetch = _fetchForExpectedType;
			Type type = obj?.GetType();
			if (propertyFetch == null || propertyFetch.Type != type)
			{
				propertyFetch = (_fetchForExpectedType = PropertyFetch.FetcherForProperty(type, _propertyName));
			}
			object result = null;
			try
			{
				result = propertyFetch.Fetch(obj);
			}
			catch (Exception arg)
			{
				Log.Message($"Property {type}.{_propertyName} threw the exception {arg}");
			}
			return result;
		}
	}

	public TransformSpec Next;

	private readonly string _outputName;

	private readonly PropertySpec _fetches;

	public TransformSpec(string transformSpec, int startIdx, int endIdx, TransformSpec next = null)
	{
		Next = next;
		int num = transformSpec.IndexOf('=', startIdx, endIdx - startIdx);
		if (0 <= num)
		{
			_outputName = transformSpec.Substring(startIdx, num - startIdx);
			startIdx = num + 1;
		}
		while (startIdx < endIdx)
		{
			int num2 = transformSpec.LastIndexOf('.', endIdx - 1, endIdx - startIdx);
			int num3 = startIdx;
			if (0 <= num2)
			{
				num3 = num2 + 1;
			}
			string text = transformSpec.Substring(num3, endIdx - num3);
			_fetches = new PropertySpec(text, _fetches);
			if (_outputName == null)
			{
				_outputName = text;
			}
			endIdx = num2;
		}
	}

	[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
	public KeyValuePair<string, string> Morph(object obj)
	{
		for (PropertySpec propertySpec = _fetches; propertySpec != null; propertySpec = propertySpec.Next)
		{
			if (obj != null || propertySpec.IsStatic)
			{
				obj = propertySpec.Fetch(obj);
			}
		}
		return new KeyValuePair<string, string>(_outputName, obj?.ToString());
	}
}


using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

internal sealed class PropertySpec
{
	private class PropertyFetch
	{
		private sealed class RefTypedFetchProperty<TObject, TProperty> : PropertyFetch
		{
			private readonly Func<TObject, TProperty> _propertyFetch;

			public RefTypedFetchProperty(Type type, PropertyInfo property)
				: base(type)
			{
				_propertyFetch = (Func<TObject, TProperty>)property.GetMethod.CreateDelegate(typeof(Func<TObject, TProperty>));
			}

			public override object Fetch(object obj)
			{
				return _propertyFetch((TObject)obj);
			}
		}

		private delegate TProperty StructFunc<TStruct, TProperty>(ref TStruct thisArg);

		private sealed class ValueTypedFetchProperty<TStruct, TProperty> : PropertyFetch
		{
			private readonly StructFunc<TStruct, TProperty> _propertyFetch;

			public ValueTypedFetchProperty(Type type, PropertyInfo property)
				: base(type)
			{
				_propertyFetch = (StructFunc<TStruct, TProperty>)property.GetMethod.CreateDelegate(typeof(StructFunc<TStruct, TProperty>));
			}

			public override object Fetch(object obj)
			{
				TStruct thisArg = (TStruct)obj;
				return _propertyFetch(ref thisArg);
			}
		}

		private sealed class CurrentActivityPropertyFetch : PropertyFetch
		{
			public CurrentActivityPropertyFetch()
				: base(null)
			{
			}

			public override object Fetch(object obj)
			{
				return Activity.Current;
			}
		}

		private sealed class EnumeratePropertyFetch<ElementType> : PropertyFetch
		{
			public EnumeratePropertyFetch(Type type)
				: base(type)
			{
			}

			public override object Fetch(object obj)
			{
				return string.Join(",", (IEnumerable<ElementType>)obj);
			}
		}

		internal Type Type { get; }

		public PropertyFetch(Type type)
		{
			Type = type;
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
		[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
		public static PropertyFetch FetcherForProperty(Type type, string propertyName)
		{
			if (propertyName == null)
			{
				return new PropertyFetch(type);
			}
			if (propertyName == "*Activity")
			{
				return new CurrentActivityPropertyFetch();
			}
			TypeInfo typeInfo = type.GetTypeInfo();
			if (propertyName == "*Enumerate")
			{
				Type[] interfaces = typeInfo.GetInterfaces();
				foreach (Type type2 in interfaces)
				{
					TypeInfo typeInfo2 = type2.GetTypeInfo();
					if (typeInfo2.IsGenericType && !(typeInfo2.GetGenericTypeDefinition() != typeof(IEnumerable<>)))
					{
						return CreateEnumeratePropertyFetch(type, typeInfo2);
					}
				}
				Log.Message($"*Enumerate applied to non-enumerable type {type}");
				return new PropertyFetch(type);
			}
			PropertyInfo propertyInfo = typeInfo.GetDeclaredProperty(propertyName);
			if (propertyInfo == null)
			{
				PropertyInfo[] properties = typeInfo.GetProperties(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (PropertyInfo propertyInfo2 in properties)
				{
					if (propertyInfo2.Name == propertyName)
					{
						propertyInfo = propertyInfo2;
						break;
					}
				}
			}
			if (propertyInfo == null)
			{
				Log.Message($"Property {propertyName} not found on {type}. Ensure the name is spelled correctly. If you published the application with PublishTrimmed=true, ensure the property was not trimmed away.");
				return new PropertyFetch(type);
			}
			MethodInfo? getMethod = propertyInfo.GetMethod;
			if ((object)getMethod == null || !getMethod.IsStatic)
			{
				MethodInfo? setMethod = propertyInfo.SetMethod;
				if ((object)setMethod == null || !setMethod.IsStatic)
				{
					return CreatePropertyFetch(typeInfo, propertyInfo);
				}
			}
			Log.Message("Property " + propertyName + " is static.");
			return new PropertyFetch(type);
		}

		[UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCode", Justification = "MakeGenericType is only called when IsDynamicCodeSupported is true or only with ref types.")]
		private static PropertyFetch CreateEnumeratePropertyFetch(Type type, Type enumerableOfTType)
		{
			Type type2 = enumerableOfTType.GetGenericArguments()[0];
			Type type3 = typeof(EnumeratePropertyFetch<>).GetTypeInfo().MakeGenericType(type2);
			return (PropertyFetch)Activator.CreateInstance(type3, type);
		}

		[UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCode", Justification = "MakeGenericType is only called when IsDynamicCodeSupported is true or only with ref types.")]
		private static PropertyFetch CreatePropertyFetch(Type type, PropertyInfo propertyInfo)
		{
			Type type2 = (type.IsValueType ? typeof(ValueTypedFetchProperty<, >) : typeof(RefTypedFetchProperty<, >));
			Type type3 = type2.GetTypeInfo().MakeGenericType(propertyInfo.DeclaringType, propertyInfo.PropertyType);
			return (PropertyFetch)Activator.CreateInstance(type3, type, propertyInfo);
		}

		public virtual object Fetch(object obj)
		{
			return null;
		}
	}

	private const string CurrentActivityPropertyName = "*Activity";

	private const string EnumeratePropertyName = "*Enumerate";

	public PropertySpec Next;

	private readonly string _propertyName;

	private volatile PropertyFetch _fetchForExpectedType;

	public bool IsStatic { get; private set; }

	public PropertySpec(string propertyName, PropertySpec next)
	{
		Next = next;
		_propertyName = propertyName;
		if (_propertyName == "*Activity")
		{
			IsStatic = true;
		}
	}

	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
	[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
	public object Fetch(object obj)
	{
		PropertyFetch propertyFetch = _fetchForExpectedType;
		Type type = obj?.GetType();
		if (propertyFetch == null || propertyFetch.Type != type)
		{
			propertyFetch = (_fetchForExpectedType = PropertyFetch.FetcherForProperty(type, _propertyName));
		}
		object result = null;
		try
		{
			result = propertyFetch.Fetch(obj);
		}
		catch (Exception arg)
		{
			Log.Message($"Property {type}.{_propertyName} threw the exception {arg}");
		}
		return result;
	}
}


using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

private class PropertyFetch
{
	private sealed class RefTypedFetchProperty<TObject, TProperty> : PropertyFetch
	{
		private readonly Func<TObject, TProperty> _propertyFetch;

		public RefTypedFetchProperty(Type type, PropertyInfo property)
			: base(type)
		{
			_propertyFetch = (Func<TObject, TProperty>)property.GetMethod.CreateDelegate(typeof(Func<TObject, TProperty>));
		}

		public override object Fetch(object obj)
		{
			return _propertyFetch((TObject)obj);
		}
	}

	private delegate TProperty StructFunc<TStruct, TProperty>(ref TStruct thisArg);

	private sealed class ValueTypedFetchProperty<TStruct, TProperty> : PropertyFetch
	{
		private readonly StructFunc<TStruct, TProperty> _propertyFetch;

		public ValueTypedFetchProperty(Type type, PropertyInfo property)
			: base(type)
		{
			_propertyFetch = (StructFunc<TStruct, TProperty>)property.GetMethod.CreateDelegate(typeof(StructFunc<TStruct, TProperty>));
		}

		public override object Fetch(object obj)
		{
			TStruct thisArg = (TStruct)obj;
			return _propertyFetch(ref thisArg);
		}
	}

	private sealed class CurrentActivityPropertyFetch : PropertyFetch
	{
		public CurrentActivityPropertyFetch()
			: base(null)
		{
		}

		public override object Fetch(object obj)
		{
			return Activity.Current;
		}
	}

	private sealed class EnumeratePropertyFetch<ElementType> : PropertyFetch
	{
		public EnumeratePropertyFetch(Type type)
			: base(type)
		{
		}

		public override object Fetch(object obj)
		{
			return string.Join(",", (IEnumerable<ElementType>)obj);
		}
	}

	internal Type Type { get; }

	public PropertyFetch(Type type)
	{
		Type = type;
	}

	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode", Justification = "In EventSource, EnsureDescriptorsInitialized's use of GetType preserves this method which requires unreferenced code, but EnsureDescriptorsInitialized does not access this member and is safe to call.")]
	[RequiresUnreferencedCode("The type of object being written to DiagnosticSource cannot be discovered statically.")]
	public static PropertyFetch FetcherForProperty(Type type, string propertyName)
	{
		if (propertyName == null)
		{
			return new PropertyFetch(type);
		}
		if (propertyName == "*Activity")
		{
			return new CurrentActivityPropertyFetch();
		}
		TypeInfo typeInfo = type.GetTypeInfo();
		if (propertyName == "*Enumerate")
		{
			Type[] interfaces = typeInfo.GetInterfaces();
			foreach (Type type2 in interfaces)
			{
				TypeInfo typeInfo2 = type2.GetTypeInfo();
				if (typeInfo2.IsGenericType && !(typeInfo2.GetGenericTypeDefinition() != typeof(IEnumerable<>)))
				{
					return CreateEnumeratePropertyFetch(type, typeInfo2);
				}
			}
			Log.Message($"*Enumerate applied to non-enumerable type {type}");
			return new PropertyFetch(type);
		}
		PropertyInfo propertyInfo = typeInfo.GetDeclaredProperty(propertyName);
		if (propertyInfo == null)
		{
			PropertyInfo[] properties = typeInfo.GetProperties(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (PropertyInfo propertyInfo2 in properties)
			{
				if (propertyInfo2.Name == propertyName)
				{
					propertyInfo = propertyInfo2;
					break;
				}
			}
		}
		if (propertyInfo == null)
		{
			Log.Message($"Property {propertyName} not found on {type}. Ensure the name is spelled correctly. If you published the application with PublishTrimmed=true, ensure the property was not trimmed away.");
			return new PropertyFetch(type);
		}
		MethodInfo? getMethod = propertyInfo.GetMethod;
		if ((object)getMethod == null || !getMethod.IsStatic)
		{
			MethodInfo? setMethod = propertyInfo.SetMethod;
			if ((object)setMethod == null || !setMethod.IsStatic)
			{
				return CreatePropertyFetch(typeInfo, propertyInfo);
			}
		}
		Log.Message("Property " + propertyName + " is static.");
		return new PropertyFetch(type);
	}

	[UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCode", Justification = "MakeGenericType is only called when IsDynamicCodeSupported is true or only with ref types.")]
	private static PropertyFetch CreateEnumeratePropertyFetch(Type type, Type enumerableOfTType)
	{
		Type type2 = enumerableOfTType.GetGenericArguments()[0];
		Type type3 = typeof(EnumeratePropertyFetch<>).GetTypeInfo().MakeGenericType(type2);
		return (PropertyFetch)Activator.CreateInstance(type3, type);
	}

	[UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCode", Justification = "MakeGenericType is only called when IsDynamicCodeSupported is true or only with ref types.")]
	private static PropertyFetch CreatePropertyFetch(Type type, PropertyInfo propertyInfo)
	{
		Type type2 = (type.IsValueType ? typeof(ValueTypedFetchProperty<, >) : typeof(RefTypedFetchProperty<, >));
		Type type3 = type2.GetTypeInfo().MakeGenericType(propertyInfo.DeclaringType, propertyInfo.PropertyType);
		return (PropertyFetch)Activator.CreateInstance(type3, type, propertyInfo);
	}

	public virtual object Fetch(object obj)
	{
		return null;
	}
}


using System.Reflection;

private sealed class RefTypedFetchProperty<TObject, TProperty> : PropertyFetch
{
	private readonly Func<TObject, TProperty> _propertyFetch;

	public RefTypedFetchProperty(Type type, PropertyInfo property)
		: base(type)
	{
		_propertyFetch = (Func<TObject, TProperty>)property.GetMethod.CreateDelegate(typeof(Func<TObject, TProperty>));
	}

	public override object Fetch(object obj)
	{
		return _propertyFetch((TObject)obj);
	}
}


private delegate TProperty StructFunc<TStruct, TProperty>(ref TStruct thisArg);


using System.Reflection;

private sealed class ValueTypedFetchProperty<TStruct, TProperty> : PropertyFetch
{
	private readonly StructFunc<TStruct, TProperty> _propertyFetch;

	public ValueTypedFetchProperty(Type type, PropertyInfo property)
		: base(type)
	{
		_propertyFetch = (StructFunc<TStruct, TProperty>)property.GetMethod.CreateDelegate(typeof(StructFunc<TStruct, TProperty>));
	}

	public override object Fetch(object obj)
	{
		TStruct thisArg = (TStruct)obj;
		return _propertyFetch(ref thisArg);
	}
}


private sealed class CurrentActivityPropertyFetch : PropertyFetch
{
	public CurrentActivityPropertyFetch()
		: base(null)
	{
	}

	public override object Fetch(object obj)
	{
		return Activity.Current;
	}
}


using System.Collections.Generic;

private sealed class EnumeratePropertyFetch<ElementType> : PropertyFetch
{
	public EnumeratePropertyFetch(Type type)
		: base(type)
	{
	}

	public override object Fetch(object obj)
	{
		return string.Join(",", (IEnumerable<ElementType>)obj);
	}
}


internal sealed class CallbackObserver<T> : IObserver<T>
{
	private readonly Action<T> _callback;

	public CallbackObserver(Action<T> callback)
	{
		_callback = callback;
	}

	public void OnCompleted()
	{
	}

	public void OnError(Exception error)
	{
	}

	public void OnNext(T value)
	{
		_callback(value);
	}
}


internal sealed class Subscriptions
{
	public IDisposable Subscription;

	public Subscriptions Next;

	public Subscriptions(IDisposable subscription, Subscriptions next)
	{
		Subscription = subscription;
		Next = next;
	}
}


using System.Diagnostics;

internal sealed class DiagNode<T>
{
	public T Value;

	public DiagNode<T> Next;

	public DiagNode(T value)
	{
		Value = value;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;

internal sealed class DiagLinkedList<T> : IEnumerable<T>, IEnumerable
{
	private DiagNode<T> _first;

	private DiagNode<T> _last;

	public DiagNode<T> First => _first;

	public DiagLinkedList()
	{
	}

	public DiagLinkedList(T firstValue)
	{
		_last = (_first = new DiagNode<T>(firstValue));
	}

	public DiagLinkedList(IEnumerator<T> e)
	{
		_last = (_first = new DiagNode<T>(e.Current));
		while (e.MoveNext())
		{
			_last.Next = new DiagNode<T>(e.Current);
			_last = _last.Next;
		}
	}

	public void Clear()
	{
		lock (this)
		{
			_first = (_last = null);
		}
	}

	private void UnsafeAdd(DiagNode<T> newNode)
	{
		if (_first == null)
		{
			_first = (_last = newNode);
			return;
		}
		_last.Next = newNode;
		_last = newNode;
	}

	public void Add(T value)
	{
		DiagNode<T> newNode = new DiagNode<T>(value);
		lock (this)
		{
			UnsafeAdd(newNode);
		}
	}

	public bool AddIfNotExist(T value, Func<T, T, bool> compare)
	{
		lock (this)
		{
			for (DiagNode<T> diagNode = _first; diagNode != null; diagNode = diagNode.Next)
			{
				if (compare(value, diagNode.Value))
				{
					return false;
				}
			}
			DiagNode<T> newNode = new DiagNode<T>(value);
			UnsafeAdd(newNode);
			return true;
		}
	}

	public T Remove(T value, Func<T, T, bool> compare)
	{
		lock (this)
		{
			DiagNode<T> diagNode = _first;
			if (diagNode == null)
			{
				return default(T);
			}
			if (compare(diagNode.Value, value))
			{
				_first = diagNode.Next;
				if (_first == null)
				{
					_last = null;
				}
				return diagNode.Value;
			}
			for (DiagNode<T> next = diagNode.Next; next != null; next = next.Next)
			{
				if (compare(next.Value, value))
				{
					diagNode.Next = next.Next;
					if (_last == next)
					{
						_last = diagNode;
					}
					return next.Value;
				}
				diagNode = next;
			}
			return default(T);
		}
	}

	public void AddFront(T value)
	{
		DiagNode<T> diagNode = new DiagNode<T>(value);
		lock (this)
		{
			diagNode.Next = _first;
			_first = diagNode;
		}
	}

	public DiagEnumerator<T> GetEnumerator()
	{
		return new DiagEnumerator<T>(_first);
	}

	IEnumerator<T> IEnumerable<T>.GetEnumerator()
	{
		return GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;

internal struct DiagEnumerator<T> : IEnumerator<T>, IDisposable, IEnumerator
{
	private static readonly DiagNode<T> s_Empty = new DiagNode<T>(default(T));

	private DiagNode<T> _nextNode;

	private DiagNode<T> _currentNode;

	public T Current => _currentNode.Value;

	object IEnumerator.Current => Current;

	public DiagEnumerator(DiagNode<T> head)
	{
		_nextNode = head;
		_currentNode = s_Empty;
	}

	public bool MoveNext()
	{
		if (_nextNode == null)
		{
			_currentNode = s_Empty;
			return false;
		}
		_currentNode = _nextNode;
		_nextNode = _nextNode.Next;
		return true;
	}

	public void Reset()
	{
		throw new NotSupportedException();
	}

	public void Dispose()
	{
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Runtime.CompilerServices;
using System.Text;

[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
internal abstract class DistributedContextPropagator
{
	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(0)]
	public delegate void PropagatorGetterCallback(object carrier, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string fieldName, out string fieldValue, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })] out IEnumerable<string> fieldValues);

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(0)]
	public delegate void PropagatorSetterCallback([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object carrier, string fieldName, string fieldValue);

	private static DistributedContextPropagator s_current = CreateDefaultPropagator();

	internal const string TraceParent = "traceparent";

	internal const string RequestId = "Request-Id";

	internal const string TraceState = "tracestate";

	internal const string Baggage = "baggage";

	internal const string CorrelationContext = "Correlation-Context";

	internal const char Space = ' ';

	internal const char Tab = '\t';

	internal const char Comma = ',';

	internal const char Semicolon = ';';

	internal const string CommaWithSpace = ", ";

	internal static readonly char[] s_trimmingSpaceCharacters = new char[2] { ' ', '\t' };

	public abstract IReadOnlyCollection<string> Fields { get; }

	public static DistributedContextPropagator Current
	{
		get
		{
			return s_current;
		}
		set
		{
			s_current = value ?? throw new ArgumentNullException("value");
		}
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
	public abstract void Inject(Activity activity, object carrier, PropagatorSetterCallback setter);

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
	public abstract void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, out string traceId, out string traceState);

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })]
	public abstract IEnumerable<KeyValuePair<string, string>> ExtractBaggage(object carrier, PropagatorGetterCallback getter);

	public static DistributedContextPropagator CreateDefaultPropagator()
	{
		return LegacyPropagator.Instance;
	}

	public static DistributedContextPropagator CreatePassThroughPropagator()
	{
		return PassThroughPropagator.Instance;
	}

	public static DistributedContextPropagator CreateNoOutputPropagator()
	{
		return NoOutputPropagator.Instance;
	}

	internal static void InjectBaggage(object carrier, IEnumerable<KeyValuePair<string, string>> baggage, PropagatorSetterCallback setter)
	{
		using IEnumerator<KeyValuePair<string, string>> enumerator = baggage.GetEnumerator();
		if (enumerator.MoveNext())
		{
			StringBuilder stringBuilder = new StringBuilder();
			do
			{
				KeyValuePair<string, string> current = enumerator.Current;
				stringBuilder.Append(WebUtility.UrlEncode(current.Key)).Append('=').Append(WebUtility.UrlEncode(current.Value))
					.Append(", ");
			}
			while (enumerator.MoveNext());
			setter(carrier, "Correlation-Context", stringBuilder.ToString(0, stringBuilder.Length - 2));
		}
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;

[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(0)]
public delegate void PropagatorGetterCallback(object carrier, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string fieldName, out string fieldValue, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1 })] out IEnumerable<string> fieldValues);


using System.Runtime.CompilerServices;

[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(0)]
public delegate void PropagatorSetterCallback([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object carrier, string fieldName, string fieldValue);


using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Net;

internal sealed class LegacyPropagator : DistributedContextPropagator
{
	internal static DistributedContextPropagator Instance { get; } = new LegacyPropagator();

	public override IReadOnlyCollection<string> Fields { get; } = new ReadOnlyCollection<string>(new string[5] { "traceparent", "Request-Id", "tracestate", "baggage", "Correlation-Context" });

	public override void Inject(Activity activity, object carrier, PropagatorSetterCallback setter)
	{
		if (activity == null || setter == null)
		{
			return;
		}
		string id = activity.Id;
		if (id == null)
		{
			return;
		}
		if (activity.IdFormat == ActivityIdFormat.W3C)
		{
			setter(carrier, "traceparent", id);
			if (!string.IsNullOrEmpty(activity.TraceStateString))
			{
				setter(carrier, "tracestate", activity.TraceStateString);
			}
		}
		else
		{
			setter(carrier, "Request-Id", id);
		}
		DistributedContextPropagator.InjectBaggage(carrier, activity.Baggage, setter);
	}

	public override void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, out string traceId, out string traceState)
	{
		if (getter == null)
		{
			traceId = null;
			traceState = null;
			return;
		}
		getter(carrier, "traceparent", out traceId, out var fieldValues);
		if (traceId == null)
		{
			getter(carrier, "Request-Id", out traceId, out fieldValues);
		}
		getter(carrier, "tracestate", out traceState, out fieldValues);
	}

	public override IEnumerable<KeyValuePair<string, string>> ExtractBaggage(object carrier, PropagatorGetterCallback getter)
	{
		if (getter == null)
		{
			return null;
		}
		getter(carrier, "baggage", out var fieldValue, out var fieldValues);
		IEnumerable<KeyValuePair<string, string>> baggage = null;
		if (fieldValue == null || !TryExtractBaggage(fieldValue, out baggage))
		{
			getter(carrier, "Correlation-Context", out fieldValue, out fieldValues);
			if (fieldValue != null)
			{
				TryExtractBaggage(fieldValue, out baggage);
			}
		}
		return baggage;
	}

	internal static bool TryExtractBaggage(string baggageString, out IEnumerable<KeyValuePair<string, string>> baggage)
	{
		baggage = null;
		List<KeyValuePair<string, string>> list = null;
		if (string.IsNullOrEmpty(baggageString))
		{
			return true;
		}
		int i = 0;
		while (true)
		{
			if (i < baggageString.Length && (baggageString[i] == ' ' || baggageString[i] == '\t'))
			{
				i++;
				continue;
			}
			if (i >= baggageString.Length)
			{
				break;
			}
			int num = i;
			for (; i < baggageString.Length && baggageString[i] != ' ' && baggageString[i] != '\t' && baggageString[i] != '='; i++)
			{
			}
			if (i >= baggageString.Length)
			{
				break;
			}
			int num2 = i;
			if (baggageString[i] != '=')
			{
				for (; i < baggageString.Length && (baggageString[i] == ' ' || baggageString[i] == '\t'); i++)
				{
				}
				if (i >= baggageString.Length || baggageString[i] != '=')
				{
					break;
				}
			}
			for (i++; i < baggageString.Length && (baggageString[i] == ' ' || baggageString[i] == '\t'); i++)
			{
			}
			if (i >= baggageString.Length)
			{
				break;
			}
			int num3 = i;
			for (; i < baggageString.Length && baggageString[i] != ' ' && baggageString[i] != '\t' && baggageString[i] != ',' && baggageString[i] != ';'; i++)
			{
			}
			if (num < num2 && num3 < i)
			{
				if (list == null)
				{
					list = new List<KeyValuePair<string, string>>();
				}
				list.Insert(0, new KeyValuePair<string, string>(WebUtility.UrlDecode(baggageString.Substring(num, num2 - num)).Trim(DistributedContextPropagator.s_trimmingSpaceCharacters), WebUtility.UrlDecode(baggageString.Substring(num3, i - num3)).Trim(DistributedContextPropagator.s_trimmingSpaceCharacters)));
			}
			for (; i < baggageString.Length && baggageString[i] != ','; i++)
			{
			}
			i++;
			if (i >= baggageString.Length)
			{
				break;
			}
		}
		baggage = list;
		return list != null;
	}
}


using System.Collections.Generic;
using System.Diagnostics;

internal sealed class NoOutputPropagator : DistributedContextPropagator
{
	internal static DistributedContextPropagator Instance { get; } = new NoOutputPropagator();

	public override IReadOnlyCollection<string> Fields { get; } = LegacyPropagator.Instance.Fields;

	public override void Inject(Activity activity, object carrier, PropagatorSetterCallback setter)
	{
	}

	public override void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, out string traceId, out string traceState)
	{
		LegacyPropagator.Instance.ExtractTraceIdAndState(carrier, getter, out traceId, out traceState);
	}

	public override IEnumerable<KeyValuePair<string, string>> ExtractBaggage(object carrier, PropagatorGetterCallback getter)
	{
		return LegacyPropagator.Instance.ExtractBaggage(carrier, getter);
	}
}


using System.Collections.Generic;
using System.Diagnostics;

internal sealed class PassThroughPropagator : DistributedContextPropagator
{
	internal static DistributedContextPropagator Instance { get; } = new PassThroughPropagator();

	public override IReadOnlyCollection<string> Fields { get; } = LegacyPropagator.Instance.Fields;

	public override void Inject(Activity activity, object carrier, PropagatorSetterCallback setter)
	{
		if (setter == null)
		{
			return;
		}
		GetRootId(out var parentId, out var traceState, out var isW3c, out var baggage);
		if (parentId != null)
		{
			setter(carrier, isW3c ? "traceparent" : "Request-Id", parentId);
			if (!string.IsNullOrEmpty(traceState))
			{
				setter(carrier, "tracestate", traceState);
			}
			if (baggage != null)
			{
				DistributedContextPropagator.InjectBaggage(carrier, baggage, setter);
			}
		}
	}

	public override void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, out string traceId, out string traceState)
	{
		LegacyPropagator.Instance.ExtractTraceIdAndState(carrier, getter, out traceId, out traceState);
	}

	public override IEnumerable<KeyValuePair<string, string>> ExtractBaggage(object carrier, PropagatorGetterCallback getter)
	{
		return LegacyPropagator.Instance.ExtractBaggage(carrier, getter);
	}

	private static void GetRootId(out string parentId, out string traceState, out bool isW3c, out IEnumerable<KeyValuePair<string, string>> baggage)
	{
		Activity activity = Activity.Current;
		while (true)
		{
			Activity activity2 = activity?.Parent;
			if (activity2 == null)
			{
				break;
			}
			activity = activity2;
		}
		traceState = activity?.TraceStateString;
		parentId = activity?.ParentId ?? activity?.Id;
		isW3c = parentId != null && Activity.TryConvertIdToContext(parentId, traceState, isRemote: false, out var _);
		baggage = activity?.Baggage;
	}
}


using System;
using System.Diagnostics;
using System.Security;

internal sealed class RandomNumberGenerator
{
	[ThreadStatic]
	private static RandomNumberGenerator t_random;

	private ulong _s0;

	private ulong _s1;

	private ulong _s2;

	private ulong _s3;

	public static RandomNumberGenerator Current => t_random ?? (t_random = new RandomNumberGenerator());

	[SecuritySafeCritical]
	public unsafe RandomNumberGenerator()
	{
		do
		{
			Guid guid = Guid.NewGuid();
			Guid guid2 = Guid.NewGuid();
			ulong* ptr = (ulong*)(&guid);
			ulong* ptr2 = (ulong*)(&guid2);
			_s0 = *ptr;
			_s1 = ptr[1];
			_s2 = *ptr2;
			_s3 = ptr2[1];
			_s0 = (_s0 & 0xFFFFFFFFFFFFFFFL) | (_s1 & 0xF000000000000000uL);
			_s2 = (_s2 & 0xFFFFFFFFFFFFFFFL) | (_s3 & 0xF000000000000000uL);
			_s1 = (_s1 & 0xFFFFFFFFFFFFFF3FuL) | (_s0 & 0xC0);
			_s3 = (_s3 & 0xFFFFFFFFFFFFFF3FuL) | (_s2 & 0xC0);
		}
		while ((_s0 | _s1 | _s2 | _s3) == 0L);
	}

	private static ulong Rol64(ulong x, int k)
	{
		return (x << k) | (x >> 64 - k);
	}

	public long Next()
	{
		ulong result = Rol64(_s1 * 5, 7) * 9;
		ulong num = _s1 << 17;
		_s2 ^= _s0;
		_s3 ^= _s1;
		_s1 ^= _s2;
		_s0 ^= _s3;
		_s2 ^= num;
		_s3 = Rol64(_s3, 45);
		return (long)result;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;

[SecuritySafeCritical]
internal struct TagList : IList<KeyValuePair<string, object>>, ICollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable, IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>
{
	public struct Enumerator : IEnumerator<KeyValuePair<string, object>>, IDisposable, IEnumerator
	{
		private TagList _tagList;

		private int _index;

		[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })]
		public KeyValuePair<string, object> Current
		{
			[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })]
			get
			{
				return _tagList[_index];
			}
		}

		[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)]
		object IEnumerator.Current => _tagList[_index];

		internal Enumerator([In][<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly] ref TagList tagList)
		{
			_index = -1;
			_tagList = tagList;
		}

		public void Dispose()
		{
			_index = _tagList.Count;
		}

		public bool MoveNext()
		{
			_index++;
			return _index < _tagList.Count;
		}

		public void Reset()
		{
			_index = -1;
		}
	}

	internal KeyValuePair<string, object> Tag1;

	internal KeyValuePair<string, object> Tag2;

	internal KeyValuePair<string, object> Tag3;

	internal KeyValuePair<string, object> Tag4;

	internal KeyValuePair<string, object> Tag5;

	internal KeyValuePair<string, object> Tag6;

	internal KeyValuePair<string, object> Tag7;

	internal KeyValuePair<string, object> Tag8;

	private int _tagsCount;

	private KeyValuePair<string, object>[] _overflowTags;

	private const int OverflowAdditionalCapacity = 8;

	public int Count
	{
		[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
		get
		{
			return _tagsCount;
		}
	}

	public bool IsReadOnly
	{
		[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
		get
		{
			return false;
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })]
	public KeyValuePair<string, object> this[int index]
	{
		[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })]
		get
		{
			if ((uint)index >= (uint)_tagsCount)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (_overflowTags != null)
			{
				return _overflowTags[index];
			}
			return index switch
			{
				0 => Tag1, 
				1 => Tag2, 
				2 => Tag3, 
				3 => Tag4, 
				4 => Tag5, 
				5 => Tag6, 
				6 => Tag7, 
				7 => Tag8, 
				_ => default(KeyValuePair<string, object>), 
			};
		}
		[param: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })]
		set
		{
			if ((uint)index >= (uint)_tagsCount)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (_overflowTags != null)
			{
				_overflowTags[index] = value;
				return;
			}
			switch (index)
			{
			case 0:
				Tag1 = value;
				break;
			case 1:
				Tag2 = value;
				break;
			case 2:
				Tag3 = value;
				break;
			case 3:
				Tag4 = value;
				break;
			case 4:
				Tag5 = value;
				break;
			case 5:
				Tag6 = value;
				break;
			case 6:
				Tag7 = value;
				break;
			case 7:
				Tag8 = value;
				break;
			}
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })]
	internal KeyValuePair<string, object>[] Tags
	{
		[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
		get
		{
			return _overflowTags;
		}
	}

	public TagList([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })] ReadOnlySpan<KeyValuePair<string, object>> tagList)
	{
		this = default(TagList);
		_tagsCount = tagList.Length;
		switch (_tagsCount)
		{
		case 8:
			Tag8 = tagList[7];
			goto case 7;
		case 7:
			Tag7 = tagList[6];
			goto case 6;
		case 6:
			Tag6 = tagList[5];
			goto case 5;
		case 5:
			Tag5 = tagList[4];
			goto case 4;
		case 4:
			Tag4 = tagList[3];
			goto case 3;
		case 3:
			Tag3 = tagList[2];
			goto case 2;
		case 2:
			Tag2 = tagList[1];
			goto case 1;
		case 1:
			Tag1 = tagList[0];
			break;
		case 0:
			break;
		default:
			_overflowTags = new KeyValuePair<string, object>[_tagsCount + 8];
			tagList.CopyTo(_overflowTags);
			break;
		}
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	public void Add(string key, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object value)
	{
		Add(new KeyValuePair<string, object>(key, value));
	}

	public void Add([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag)
	{
		if (_overflowTags != null)
		{
			if (_tagsCount == _overflowTags.Length)
			{
				Array.Resize(ref _overflowTags, _tagsCount + 8);
			}
			_overflowTags[_tagsCount++] = tag;
			return;
		}
		switch (_tagsCount)
		{
		default:
			return;
		case 0:
			Tag1 = tag;
			break;
		case 1:
			Tag2 = tag;
			break;
		case 2:
			Tag3 = tag;
			break;
		case 3:
			Tag4 = tag;
			break;
		case 4:
			Tag5 = tag;
			break;
		case 5:
			Tag6 = tag;
			break;
		case 6:
			Tag7 = tag;
			break;
		case 7:
			Tag8 = tag;
			break;
		case 8:
			MoveTagsToTheArray();
			_overflowTags[8] = tag;
			break;
		}
		_tagsCount++;
	}

	[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
	public void CopyTo([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })] Span<KeyValuePair<string, object>> tags)
	{
		if (tags.Length < _tagsCount)
		{
			throw new ArgumentException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.Arg_BufferTooSmall);
		}
		if (_overflowTags != null)
		{
			MemoryExtensions.AsSpan(_overflowTags).Slice(0, _tagsCount).CopyTo(tags);
			return;
		}
		switch (_tagsCount)
		{
		default:
			return;
		case 8:
			tags[7] = Tag8;
			goto case 7;
		case 7:
			tags[6] = Tag7;
			goto case 6;
		case 6:
			tags[5] = Tag6;
			goto case 5;
		case 5:
			tags[4] = Tag5;
			goto case 4;
		case 4:
			tags[3] = Tag4;
			goto case 3;
		case 3:
			tags[2] = Tag3;
			goto case 2;
		case 2:
			tags[1] = Tag2;
			break;
		case 1:
			break;
		case 0:
			return;
		}
		tags[0] = Tag1;
	}

	[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
	public void CopyTo([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })] KeyValuePair<string, object>[] array, int arrayIndex)
	{
		if (array == null)
		{
			throw new ArgumentNullException("array");
		}
		if ((uint)arrayIndex >= array.Length)
		{
			throw new ArgumentOutOfRangeException("arrayIndex");
		}
		CopyTo(MemoryExtensions.AsSpan(array).Slice(arrayIndex));
	}

	public void Insert(int index, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> item)
	{
		if ((uint)index > (uint)_tagsCount)
		{
			throw new ArgumentOutOfRangeException("index");
		}
		if (index == _tagsCount)
		{
			Add(item);
			return;
		}
		if (_tagsCount == 8 && _overflowTags == null)
		{
			MoveTagsToTheArray();
		}
		if (_overflowTags != null)
		{
			if (_tagsCount == _overflowTags.Length)
			{
				Array.Resize(ref _overflowTags, _tagsCount + 8);
			}
			for (int num = _tagsCount; num > index; num--)
			{
				_overflowTags[num] = _overflowTags[num - 1];
			}
			_overflowTags[index] = item;
			_tagsCount++;
			return;
		}
		switch (index)
		{
		default:
			return;
		case 0:
			Tag8 = Tag7;
			Tag7 = Tag6;
			Tag6 = Tag5;
			Tag5 = Tag4;
			Tag4 = Tag3;
			Tag3 = Tag2;
			Tag2 = Tag1;
			Tag1 = item;
			break;
		case 1:
			Tag8 = Tag7;
			Tag7 = Tag6;
			Tag6 = Tag5;
			Tag5 = Tag4;
			Tag4 = Tag3;
			Tag3 = Tag2;
			Tag2 = item;
			break;
		case 2:
			Tag8 = Tag7;
			Tag7 = Tag6;
			Tag6 = Tag5;
			Tag5 = Tag4;
			Tag4 = Tag3;
			Tag3 = item;
			break;
		case 3:
			Tag8 = Tag7;
			Tag7 = Tag6;
			Tag6 = Tag5;
			Tag5 = Tag4;
			Tag4 = item;
			break;
		case 4:
			Tag8 = Tag7;
			Tag7 = Tag6;
			Tag6 = Tag5;
			Tag5 = item;
			break;
		case 5:
			Tag8 = Tag7;
			Tag7 = Tag6;
			Tag6 = item;
			break;
		case 6:
			Tag8 = Tag7;
			Tag7 = item;
			break;
		}
		_tagsCount++;
	}

	public void RemoveAt(int index)
	{
		if ((uint)index >= (uint)_tagsCount)
		{
			throw new ArgumentOutOfRangeException("index");
		}
		if (_overflowTags != null)
		{
			for (int i = index; i < _tagsCount - 1; i++)
			{
				_overflowTags[i] = _overflowTags[i + 1];
			}
			_tagsCount--;
			return;
		}
		switch (index)
		{
		case 0:
			Tag1 = Tag2;
			goto case 1;
		case 1:
			Tag2 = Tag3;
			goto case 2;
		case 2:
			Tag3 = Tag4;
			goto case 3;
		case 3:
			Tag4 = Tag5;
			goto case 4;
		case 4:
			Tag5 = Tag6;
			goto case 5;
		case 5:
			Tag6 = Tag7;
			goto case 6;
		case 6:
			Tag7 = Tag8;
			break;
		}
		_tagsCount--;
	}

	public void Clear()
	{
		_tagsCount = 0;
	}

	[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
	public bool Contains([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> item)
	{
		return IndexOf(item) >= 0;
	}

	public bool Remove([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> item)
	{
		int num = IndexOf(item);
		if (num >= 0)
		{
			RemoveAt(num);
			return true;
		}
		return false;
	}

	[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })]
	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		return new Enumerator(ref this);
	}

	[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
	IEnumerator IEnumerable.GetEnumerator()
	{
		return new Enumerator(ref this);
	}

	[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
	public int IndexOf([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> item)
	{
		if (_overflowTags != null)
		{
			for (int i = 0; i < _tagsCount; i++)
			{
				if (TagsEqual(_overflowTags[i], item))
				{
					return i;
				}
			}
			return -1;
		}
		switch (_tagsCount)
		{
		case 1:
			if (TagsEqual(Tag1, item))
			{
				return 0;
			}
			break;
		case 2:
			if (TagsEqual(Tag1, item))
			{
				return 0;
			}
			if (TagsEqual(Tag2, item))
			{
				return 1;
			}
			break;
		case 3:
			if (TagsEqual(Tag1, item))
			{
				return 0;
			}
			if (TagsEqual(Tag2, item))
			{
				return 1;
			}
			if (TagsEqual(Tag3, item))
			{
				return 2;
			}
			break;
		case 4:
			if (TagsEqual(Tag1, item))
			{
				return 0;
			}
			if (TagsEqual(Tag2, item))
			{
				return 1;
			}
			if (TagsEqual(Tag3, item))
			{
				return 2;
			}
			if (TagsEqual(Tag4, item))
			{
				return 3;
			}
			break;
		case 5:
			if (TagsEqual(Tag1, item))
			{
				return 0;
			}
			if (TagsEqual(Tag2, item))
			{
				return 1;
			}
			if (TagsEqual(Tag3, item))
			{
				return 2;
			}
			if (TagsEqual(Tag4, item))
			{
				return 3;
			}
			if (TagsEqual(Tag5, item))
			{
				return 4;
			}
			break;
		case 6:
			if (TagsEqual(Tag1, item))
			{
				return 0;
			}
			if (TagsEqual(Tag2, item))
			{
				return 1;
			}
			if (TagsEqual(Tag3, item))
			{
				return 2;
			}
			if (TagsEqual(Tag4, item))
			{
				return 3;
			}
			if (TagsEqual(Tag5, item))
			{
				return 4;
			}
			if (TagsEqual(Tag6, item))
			{
				return 5;
			}
			break;
		case 7:
			if (TagsEqual(Tag1, item))
			{
				return 0;
			}
			if (TagsEqual(Tag2, item))
			{
				return 1;
			}
			if (TagsEqual(Tag3, item))
			{
				return 2;
			}
			if (TagsEqual(Tag4, item))
			{
				return 3;
			}
			if (TagsEqual(Tag5, item))
			{
				return 4;
			}
			if (TagsEqual(Tag6, item))
			{
				return 5;
			}
			if (TagsEqual(Tag7, item))
			{
				return 6;
			}
			break;
		case 8:
			if (TagsEqual(Tag1, item))
			{
				return 0;
			}
			if (TagsEqual(Tag2, item))
			{
				return 1;
			}
			if (TagsEqual(Tag3, item))
			{
				return 2;
			}
			if (TagsEqual(Tag4, item))
			{
				return 3;
			}
			if (TagsEqual(Tag5, item))
			{
				return 4;
			}
			if (TagsEqual(Tag6, item))
			{
				return 5;
			}
			if (TagsEqual(Tag7, item))
			{
				return 6;
			}
			if (TagsEqual(Tag8, item))
			{
				return 7;
			}
			break;
		}
		return -1;
	}

	private static bool TagsEqual(KeyValuePair<string, object> tag1, KeyValuePair<string, object> tag2)
	{
		if (tag1.Key != tag2.Key)
		{
			return false;
		}
		if (tag1.Value == null)
		{
			if (tag2.Value != null)
			{
				return false;
			}
		}
		else if (!tag1.Value.Equals(tag2.Value))
		{
			return false;
		}
		return true;
	}

	private void MoveTagsToTheArray()
	{
		_overflowTags = new KeyValuePair<string, object>[16];
		_overflowTags[0] = Tag1;
		_overflowTags[1] = Tag2;
		_overflowTags[2] = Tag3;
		_overflowTags[3] = Tag4;
		_overflowTags[4] = Tag5;
		_overflowTags[5] = Tag6;
		_overflowTags[6] = Tag7;
		_overflowTags[7] = Tag8;
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

public struct Enumerator : IEnumerator<KeyValuePair<string, object>>, IDisposable, IEnumerator
{
	private TagList _tagList;

	private int _index;

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })]
	public KeyValuePair<string, object> Current
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })]
		get
		{
			return _tagList[_index];
		}
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)]
	object IEnumerator.Current => _tagList[_index];

	internal Enumerator([In][<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly] ref TagList tagList)
	{
		_index = -1;
		_tagList = tagList;
	}

	public void Dispose()
	{
		_index = _tagList.Count;
	}

	public bool MoveNext()
	{
		_index++;
		return _index < _tagList.Count;
	}

	public void Reset()
	{
		_index = -1;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

internal sealed class HttpHandlerDiagnosticListener : DiagnosticListener
{
	private class HashtableWrapper : Hashtable, IEnumerable
	{
		protected Hashtable _table;

		public override int Count => _table.Count;

		public override bool IsReadOnly => _table.IsReadOnly;

		public override bool IsFixedSize => _table.IsFixedSize;

		public override bool IsSynchronized => _table.IsSynchronized;

		public override object this[object key]
		{
			get
			{
				return _table[key];
			}
			set
			{
				_table[key] = value;
			}
		}

		public override object SyncRoot => _table.SyncRoot;

		public override ICollection Keys => _table.Keys;

		public override ICollection Values => _table.Values;

		internal HashtableWrapper(Hashtable table)
		{
			_table = table;
		}

		public override void Add(object key, object value)
		{
			_table.Add(key, value);
		}

		public override void Clear()
		{
			_table.Clear();
		}

		public override bool Contains(object key)
		{
			return _table.Contains(key);
		}

		public override bool ContainsKey(object key)
		{
			return _table.ContainsKey(key);
		}

		public override bool ContainsValue(object key)
		{
			return _table.ContainsValue(key);
		}

		public override void CopyTo(Array array, int arrayIndex)
		{
			_table.CopyTo(array, arrayIndex);
		}

		public override object Clone()
		{
			return new HashtableWrapper((Hashtable)_table.Clone());
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return _table.GetEnumerator();
		}

		public override IDictionaryEnumerator GetEnumerator()
		{
			return _table.GetEnumerator();
		}

		public override void Remove(object key)
		{
			_table.Remove(key);
		}
	}

	private sealed class ServicePointHashtable : HashtableWrapper
	{
		public override object this[object key]
		{
			get
			{
				return base[key];
			}
			set
			{
				if (value is WeakReference { IsAlive: not false, Target: ServicePoint target })
				{
					Hashtable hashtable = s_connectionGroupListField.GetValue(target) as Hashtable;
					ConnectionGroupHashtable value2 = new ConnectionGroupHashtable(hashtable ?? new Hashtable());
					s_connectionGroupListField.SetValue(target, value2);
				}
				base[key] = value;
			}
		}

		public ServicePointHashtable(Hashtable table)
			: base(table)
		{
		}
	}

	private sealed class ConnectionGroupHashtable : HashtableWrapper
	{
		public override object this[object key]
		{
			get
			{
				return base[key];
			}
			set
			{
				if (s_connectionGroupType.IsInstanceOfType(value))
				{
					ArrayList arrayList = s_connectionListField.GetValue(value) as ArrayList;
					ConnectionArrayList value2 = new ConnectionArrayList(arrayList ?? new ArrayList());
					s_connectionListField.SetValue(value, value2);
				}
				base[key] = value;
			}
		}

		public ConnectionGroupHashtable(Hashtable table)
			: base(table)
		{
		}
	}

	private class ArrayListWrapper : ArrayList
	{
		private ArrayList _list;

		public override int Capacity
		{
			get
			{
				return _list.Capacity;
			}
			set
			{
				_list.Capacity = value;
			}
		}

		public override int Count => _list.Count;

		public override bool IsReadOnly => _list.IsReadOnly;

		public override bool IsFixedSize => _list.IsFixedSize;

		public override bool IsSynchronized => _list.IsSynchronized;

		public override object this[int index]
		{
			get
			{
				return _list[index];
			}
			set
			{
				_list[index] = value;
			}
		}

		public override object SyncRoot => _list.SyncRoot;

		internal ArrayListWrapper(ArrayList list)
		{
			_list = list;
		}

		public override int Add(object value)
		{
			return _list.Add(value);
		}

		public override void AddRange(ICollection c)
		{
			_list.AddRange(c);
		}

		public override int BinarySearch(object value)
		{
			return _list.BinarySearch(value);
		}

		public override int BinarySearch(object value, IComparer comparer)
		{
			return _list.BinarySearch(value, comparer);
		}

		public override int BinarySearch(int index, int count, object value, IComparer comparer)
		{
			return _list.BinarySearch(index, count, value, comparer);
		}

		public override void Clear()
		{
			_list.Clear();
		}

		public override object Clone()
		{
			return new ArrayListWrapper((ArrayList)_list.Clone());
		}

		public override bool Contains(object item)
		{
			return _list.Contains(item);
		}

		public override void CopyTo(Array array)
		{
			_list.CopyTo(array);
		}

		public override void CopyTo(Array array, int index)
		{
			_list.CopyTo(array, index);
		}

		public override void CopyTo(int index, Array array, int arrayIndex, int count)
		{
			_list.CopyTo(index, array, arrayIndex, count);
		}

		public override IEnumerator GetEnumerator()
		{
			return _list.GetEnumerator();
		}

		public override IEnumerator GetEnumerator(int index, int count)
		{
			return _list.GetEnumerator(index, count);
		}

		public override int IndexOf(object value)
		{
			return _list.IndexOf(value);
		}

		public override int IndexOf(object value, int startIndex)
		{
			return _list.IndexOf(value, startIndex);
		}

		public override int IndexOf(object value, int startIndex, int count)
		{
			return _list.IndexOf(value, startIndex, count);
		}

		public override void Insert(int index, object value)
		{
			_list.Insert(index, value);
		}

		public override void InsertRange(int index, ICollection c)
		{
			_list.InsertRange(index, c);
		}

		public override int LastIndexOf(object value)
		{
			return _list.LastIndexOf(value);
		}

		public override int LastIndexOf(object value, int startIndex)
		{
			return _list.LastIndexOf(value, startIndex);
		}

		public override int LastIndexOf(object value, int startIndex, int count)
		{
			return _list.LastIndexOf(value, startIndex, count);
		}

		public override void Remove(object value)
		{
			_list.Remove(value);
		}

		public override void RemoveAt(int index)
		{
			_list.RemoveAt(index);
		}

		public override void RemoveRange(int index, int count)
		{
			_list.RemoveRange(index, count);
		}

		public override void Reverse(int index, int count)
		{
			_list.Reverse(index, count);
		}

		public override void SetRange(int index, ICollection c)
		{
			_list.SetRange(index, c);
		}

		public override ArrayList GetRange(int index, int count)
		{
			return _list.GetRange(index, count);
		}

		public override void Sort()
		{
			_list.Sort();
		}

		public override void Sort(IComparer comparer)
		{
			_list.Sort(comparer);
		}

		public override void Sort(int index, int count, IComparer comparer)
		{
			_list.Sort(index, count, comparer);
		}

		public override object[] ToArray()
		{
			return _list.ToArray();
		}

		public override Array ToArray(Type type)
		{
			return _list.ToArray(type);
		}

		public override void TrimToSize()
		{
			_list.TrimToSize();
		}
	}

	private sealed class ConnectionArrayList : ArrayListWrapper
	{
		public ConnectionArrayList(ArrayList list)
			: base(list)
		{
		}

		public override int Add(object value)
		{
			if (s_connectionType.IsInstanceOfType(value))
			{
				ArrayList arrayList = s_writeListField.GetValue(value) as ArrayList;
				HttpWebRequestArrayList value2 = new HttpWebRequestArrayList(arrayList ?? new ArrayList());
				s_writeListField.SetValue(value, value2);
			}
			return base.Add(value);
		}
	}

	private sealed class HttpWebRequestArrayList : ArrayListWrapper
	{
		public HttpWebRequestArrayList(ArrayList list)
			: base(list)
		{
		}

		public override int Add(object value)
		{
			if (value is HttpWebRequest request)
			{
				s_instance.RaiseRequestEvent(request);
			}
			return base.Add(value);
		}

		public override void RemoveAt(int index)
		{
			if (base[index] is HttpWebRequest httpWebRequest)
			{
				HttpWebResponse httpWebResponse = s_httpResponseAccessor(httpWebRequest);
				if (httpWebResponse != null)
				{
					s_instance.RaiseResponseEvent(httpWebRequest, httpWebResponse);
				}
				else
				{
					object obj = s_coreResponseAccessor(httpWebRequest);
					if (obj != null && s_coreResponseDataType.IsInstanceOfType(obj))
					{
						HttpStatusCode statusCode = s_coreStatusCodeAccessor(obj);
						WebHeaderCollection headers = s_coreHeadersAccessor(obj);
						s_instance.RaiseResponseEvent(httpWebRequest, statusCode, headers);
					}
				}
			}
			base.RemoveAt(index);
		}
	}

	internal static HttpHandlerDiagnosticListener s_instance = new HttpHandlerDiagnosticListener();

	private const string DiagnosticListenerName = "System.Net.Http.Desktop";

	private const string ActivityName = "System.Net.Http.Desktop.HttpRequestOut";

	private const string RequestStartName = "System.Net.Http.Desktop.HttpRequestOut.Start";

	private const string RequestStopName = "System.Net.Http.Desktop.HttpRequestOut.Stop";

	private const string RequestStopExName = "System.Net.Http.Desktop.HttpRequestOut.Ex.Stop";

	private const string InitializationFailed = "System.Net.Http.InitializationFailed";

	private const string RequestIdHeaderName = "Request-Id";

	private const string CorrelationContextHeaderName = "Correlation-Context";

	private const string TraceParentHeaderName = "traceparent";

	private const string TraceStateHeaderName = "tracestate";

	private bool initialized;

	private static FieldInfo s_connectionGroupListField;

	private static Type s_connectionGroupType;

	private static FieldInfo s_connectionListField;

	private static Type s_connectionType;

	private static FieldInfo s_writeListField;

	private static Func<HttpWebRequest, HttpWebResponse> s_httpResponseAccessor;

	private static Func<HttpWebRequest, int> s_autoRedirectsAccessor;

	private static Func<HttpWebRequest, object> s_coreResponseAccessor;

	private static Func<object, HttpStatusCode> s_coreStatusCodeAccessor;

	private static Func<object, WebHeaderCollection> s_coreHeadersAccessor;

	private static Type s_coreResponseDataType;

	public override IDisposable Subscribe(IObserver<KeyValuePair<string, object>> observer, Predicate<string> isEnabled)
	{
		IDisposable result = base.Subscribe(observer, isEnabled);
		Initialize();
		return result;
	}

	public override IDisposable Subscribe(IObserver<KeyValuePair<string, object>> observer, Func<string, object, object, bool> isEnabled)
	{
		IDisposable result = base.Subscribe(observer, isEnabled);
		Initialize();
		return result;
	}

	public override IDisposable Subscribe(IObserver<KeyValuePair<string, object>> observer)
	{
		IDisposable result = base.Subscribe(observer);
		Initialize();
		return result;
	}

	private void Initialize()
	{
		lock (this)
		{
			if (!initialized)
			{
				try
				{
					initialized = true;
					PrepareReflectionObjects();
					PerformInjection();
					return;
				}
				catch (Exception exception)
				{
					Write("System.Net.Http.InitializationFailed", new
					{
						Exception = exception
					});
					return;
				}
			}
		}
	}

	private HttpHandlerDiagnosticListener()
		: base("System.Net.Http.Desktop")
	{
	}

	private void RaiseRequestEvent(HttpWebRequest request)
	{
		if (request.Headers.Get("Request-Id") != null || !IsEnabled("System.Net.Http.Desktop.HttpRequestOut", request))
		{
			return;
		}
		Activity activity = new Activity("System.Net.Http.Desktop.HttpRequestOut");
		if (IsEnabled("System.Net.Http.Desktop.HttpRequestOut.Start"))
		{
			StartActivity(activity, new
			{
				Request = request
			});
		}
		else
		{
			activity.Start();
		}
		if (activity.IdFormat == ActivityIdFormat.W3C)
		{
			if (request.Headers.Get("traceparent") == null)
			{
				request.Headers.Add("traceparent", activity.Id);
				string traceStateString = activity.TraceStateString;
				if (traceStateString != null)
				{
					request.Headers.Add("tracestate", traceStateString);
				}
			}
		}
		else if (request.Headers.Get("Request-Id") == null)
		{
			request.Headers.Add("Request-Id", activity.Id);
		}
		if (request.Headers.Get("Correlation-Context") == null)
		{
			using IEnumerator<KeyValuePair<string, string>> enumerator = activity.Baggage.GetEnumerator();
			if (enumerator.MoveNext())
			{
				StringBuilder stringBuilder = new StringBuilder();
				do
				{
					KeyValuePair<string, string> current = enumerator.Current;
					stringBuilder.Append(WebUtility.UrlEncode(current.Key)).Append('=').Append(WebUtility.UrlEncode(current.Value))
						.Append(',');
				}
				while (enumerator.MoveNext());
				stringBuilder.Remove(stringBuilder.Length - 1, 1);
				request.Headers.Add("Correlation-Context", stringBuilder.ToString());
			}
		}
		activity.Stop();
	}

	private void RaiseResponseEvent(HttpWebRequest request, HttpWebResponse response)
	{
		if ((request.Headers.Get("traceparent") != null || request.Headers.Get("Request-Id") != null) && IsLastResponse(request, response.StatusCode))
		{
			Write("System.Net.Http.Desktop.HttpRequestOut.Stop", new
			{
				Request = request,
				Response = response
			});
		}
	}

	private void RaiseResponseEvent(HttpWebRequest request, HttpStatusCode statusCode, WebHeaderCollection headers)
	{
		if (request.Headers.Get("Request-Id") != null && IsLastResponse(request, statusCode))
		{
			Write("System.Net.Http.Desktop.HttpRequestOut.Ex.Stop", new
			{
				Request = request,
				StatusCode = statusCode,
				Headers = headers
			});
		}
	}

	private static bool IsLastResponse(HttpWebRequest request, HttpStatusCode statusCode)
	{
		if (request.AllowAutoRedirect && (statusCode == HttpStatusCode.MultipleChoices || statusCode == HttpStatusCode.MovedPermanently || statusCode == HttpStatusCode.Found || statusCode == HttpStatusCode.SeeOther || statusCode == HttpStatusCode.TemporaryRedirect || statusCode == HttpStatusCode.PermanentRedirect))
		{
			return s_autoRedirectsAccessor(request) >= request.MaximumAutomaticRedirections;
		}
		return true;
	}

	private static void PrepareReflectionObjects()
	{
		Assembly assembly = typeof(ServicePoint).Assembly;
		s_connectionGroupListField = typeof(ServicePoint).GetField("m_ConnectionGroupList", BindingFlags.Instance | BindingFlags.NonPublic);
		s_connectionGroupType = assembly?.GetType("System.Net.ConnectionGroup");
		s_connectionListField = s_connectionGroupType?.GetField("m_ConnectionList", BindingFlags.Instance | BindingFlags.NonPublic);
		s_connectionType = assembly?.GetType("System.Net.Connection");
		s_writeListField = s_connectionType?.GetField("m_WriteList", BindingFlags.Instance | BindingFlags.NonPublic);
		s_httpResponseAccessor = CreateFieldGetter<HttpWebRequest, HttpWebResponse>("_HttpResponse", BindingFlags.Instance | BindingFlags.NonPublic);
		s_autoRedirectsAccessor = CreateFieldGetter<HttpWebRequest, int>("_AutoRedirects", BindingFlags.Instance | BindingFlags.NonPublic);
		s_coreResponseAccessor = CreateFieldGetter<HttpWebRequest, object>("_CoreResponse", BindingFlags.Instance | BindingFlags.NonPublic);
		s_coreResponseDataType = assembly?.GetType("System.Net.CoreResponseData");
		if (s_coreResponseDataType != null)
		{
			s_coreStatusCodeAccessor = CreateFieldGetter<HttpStatusCode>(s_coreResponseDataType, "m_StatusCode", BindingFlags.Instance | BindingFlags.Public);
			s_coreHeadersAccessor = CreateFieldGetter<WebHeaderCollection>(s_coreResponseDataType, "m_ResponseHeaders", BindingFlags.Instance | BindingFlags.Public);
		}
		if (s_connectionGroupListField == null || s_connectionGroupType == null || s_connectionListField == null || s_connectionType == null || s_writeListField == null || s_httpResponseAccessor == null || s_autoRedirectsAccessor == null || s_coreResponseDataType == null || s_coreStatusCodeAccessor == null || s_coreHeadersAccessor == null)
		{
			throw new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.UnableToInitialize);
		}
	}

	private static void PerformInjection()
	{
		FieldInfo field = typeof(ServicePointManager).GetField("s_ServicePointTable", BindingFlags.Static | BindingFlags.NonPublic);
		if (field == null)
		{
			throw new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.UnableAccessServicePointTable);
		}
		Hashtable hashtable = field.GetValue(null) as Hashtable;
		ServicePointHashtable value = new ServicePointHashtable(hashtable ?? new Hashtable());
		field.SetValue(null, value);
	}

	private static Func<TClass, TField> CreateFieldGetter<TClass, TField>(string fieldName, BindingFlags flags) where TClass : class
	{
		FieldInfo field = typeof(TClass).GetField(fieldName, flags);
		if (field != null)
		{
			string name = field.ReflectedType.FullName + ".get_" + field.Name;
			DynamicMethod dynamicMethod = new DynamicMethod(name, typeof(TField), new Type[1] { typeof(TClass) }, restrictedSkipVisibility: true);
			ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
			iLGenerator.Emit(OpCodes.Ldarg_0);
			iLGenerator.Emit(OpCodes.Ldfld, field);
			iLGenerator.Emit(OpCodes.Ret);
			return (Func<TClass, TField>)dynamicMethod.CreateDelegate(typeof(Func<TClass, TField>));
		}
		return null;
	}

	private static Func<object, TField> CreateFieldGetter<TField>(Type classType, string fieldName, BindingFlags flags)
	{
		FieldInfo field = classType.GetField(fieldName, flags);
		if (field != null)
		{
			string name = classType.FullName + ".get_" + field.Name;
			DynamicMethod dynamicMethod = new DynamicMethod(name, typeof(TField), new Type[1] { typeof(object) }, restrictedSkipVisibility: true);
			ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
			iLGenerator.Emit(OpCodes.Ldarg_0);
			iLGenerator.Emit(OpCodes.Castclass, classType);
			iLGenerator.Emit(OpCodes.Ldfld, field);
			iLGenerator.Emit(OpCodes.Ret);
			return (Func<object, TField>)dynamicMethod.CreateDelegate(typeof(Func<object, TField>));
		}
		return null;
	}
}


using System.Collections;

private class HashtableWrapper : Hashtable, IEnumerable
{
	protected Hashtable _table;

	public override int Count => _table.Count;

	public override bool IsReadOnly => _table.IsReadOnly;

	public override bool IsFixedSize => _table.IsFixedSize;

	public override bool IsSynchronized => _table.IsSynchronized;

	public override object this[object key]
	{
		get
		{
			return _table[key];
		}
		set
		{
			_table[key] = value;
		}
	}

	public override object SyncRoot => _table.SyncRoot;

	public override ICollection Keys => _table.Keys;

	public override ICollection Values => _table.Values;

	internal HashtableWrapper(Hashtable table)
	{
		_table = table;
	}

	public override void Add(object key, object value)
	{
		_table.Add(key, value);
	}

	public override void Clear()
	{
		_table.Clear();
	}

	public override bool Contains(object key)
	{
		return _table.Contains(key);
	}

	public override bool ContainsKey(object key)
	{
		return _table.ContainsKey(key);
	}

	public override bool ContainsValue(object key)
	{
		return _table.ContainsValue(key);
	}

	public override void CopyTo(Array array, int arrayIndex)
	{
		_table.CopyTo(array, arrayIndex);
	}

	public override object Clone()
	{
		return new HashtableWrapper((Hashtable)_table.Clone());
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return _table.GetEnumerator();
	}

	public override IDictionaryEnumerator GetEnumerator()
	{
		return _table.GetEnumerator();
	}

	public override void Remove(object key)
	{
		_table.Remove(key);
	}
}


using System.Collections;
using System.Net;

private sealed class ServicePointHashtable : HashtableWrapper
{
	public override object this[object key]
	{
		get
		{
			return base[key];
		}
		set
		{
			if (value is WeakReference { IsAlive: not false, Target: ServicePoint target })
			{
				Hashtable hashtable = s_connectionGroupListField.GetValue(target) as Hashtable;
				ConnectionGroupHashtable value2 = new ConnectionGroupHashtable(hashtable ?? new Hashtable());
				s_connectionGroupListField.SetValue(target, value2);
			}
			base[key] = value;
		}
	}

	public ServicePointHashtable(Hashtable table)
		: base(table)
	{
	}
}


using System.Collections;

private sealed class ConnectionGroupHashtable : HashtableWrapper
{
	public override object this[object key]
	{
		get
		{
			return base[key];
		}
		set
		{
			if (s_connectionGroupType.IsInstanceOfType(value))
			{
				ArrayList arrayList = s_connectionListField.GetValue(value) as ArrayList;
				ConnectionArrayList value2 = new ConnectionArrayList(arrayList ?? new ArrayList());
				s_connectionListField.SetValue(value, value2);
			}
			base[key] = value;
		}
	}

	public ConnectionGroupHashtable(Hashtable table)
		: base(table)
	{
	}
}


using System.Collections;

private class ArrayListWrapper : ArrayList
{
	private ArrayList _list;

	public override int Capacity
	{
		get
		{
			return _list.Capacity;
		}
		set
		{
			_list.Capacity = value;
		}
	}

	public override int Count => _list.Count;

	public override bool IsReadOnly => _list.IsReadOnly;

	public override bool IsFixedSize => _list.IsFixedSize;

	public override bool IsSynchronized => _list.IsSynchronized;

	public override object this[int index]
	{
		get
		{
			return _list[index];
		}
		set
		{
			_list[index] = value;
		}
	}

	public override object SyncRoot => _list.SyncRoot;

	internal ArrayListWrapper(ArrayList list)
	{
		_list = list;
	}

	public override int Add(object value)
	{
		return _list.Add(value);
	}

	public override void AddRange(ICollection c)
	{
		_list.AddRange(c);
	}

	public override int BinarySearch(object value)
	{
		return _list.BinarySearch(value);
	}

	public override int BinarySearch(object value, IComparer comparer)
	{
		return _list.BinarySearch(value, comparer);
	}

	public override int BinarySearch(int index, int count, object value, IComparer comparer)
	{
		return _list.BinarySearch(index, count, value, comparer);
	}

	public override void Clear()
	{
		_list.Clear();
	}

	public override object Clone()
	{
		return new ArrayListWrapper((ArrayList)_list.Clone());
	}

	public override bool Contains(object item)
	{
		return _list.Contains(item);
	}

	public override void CopyTo(Array array)
	{
		_list.CopyTo(array);
	}

	public override void CopyTo(Array array, int index)
	{
		_list.CopyTo(array, index);
	}

	public override void CopyTo(int index, Array array, int arrayIndex, int count)
	{
		_list.CopyTo(index, array, arrayIndex, count);
	}

	public override IEnumerator GetEnumerator()
	{
		return _list.GetEnumerator();
	}

	public override IEnumerator GetEnumerator(int index, int count)
	{
		return _list.GetEnumerator(index, count);
	}

	public override int IndexOf(object value)
	{
		return _list.IndexOf(value);
	}

	public override int IndexOf(object value, int startIndex)
	{
		return _list.IndexOf(value, startIndex);
	}

	public override int IndexOf(object value, int startIndex, int count)
	{
		return _list.IndexOf(value, startIndex, count);
	}

	public override void Insert(int index, object value)
	{
		_list.Insert(index, value);
	}

	public override void InsertRange(int index, ICollection c)
	{
		_list.InsertRange(index, c);
	}

	public override int LastIndexOf(object value)
	{
		return _list.LastIndexOf(value);
	}

	public override int LastIndexOf(object value, int startIndex)
	{
		return _list.LastIndexOf(value, startIndex);
	}

	public override int LastIndexOf(object value, int startIndex, int count)
	{
		return _list.LastIndexOf(value, startIndex, count);
	}

	public override void Remove(object value)
	{
		_list.Remove(value);
	}

	public override void RemoveAt(int index)
	{
		_list.RemoveAt(index);
	}

	public override void RemoveRange(int index, int count)
	{
		_list.RemoveRange(index, count);
	}

	public override void Reverse(int index, int count)
	{
		_list.Reverse(index, count);
	}

	public override void SetRange(int index, ICollection c)
	{
		_list.SetRange(index, c);
	}

	public override ArrayList GetRange(int index, int count)
	{
		return _list.GetRange(index, count);
	}

	public override void Sort()
	{
		_list.Sort();
	}

	public override void Sort(IComparer comparer)
	{
		_list.Sort(comparer);
	}

	public override void Sort(int index, int count, IComparer comparer)
	{
		_list.Sort(index, count, comparer);
	}

	public override object[] ToArray()
	{
		return _list.ToArray();
	}

	public override Array ToArray(Type type)
	{
		return _list.ToArray(type);
	}

	public override void TrimToSize()
	{
		_list.TrimToSize();
	}
}


using System.Collections;

private sealed class ConnectionArrayList : ArrayListWrapper
{
	public ConnectionArrayList(ArrayList list)
		: base(list)
	{
	}

	public override int Add(object value)
	{
		if (s_connectionType.IsInstanceOfType(value))
		{
			ArrayList arrayList = s_writeListField.GetValue(value) as ArrayList;
			HttpWebRequestArrayList value2 = new HttpWebRequestArrayList(arrayList ?? new ArrayList());
			s_writeListField.SetValue(value, value2);
		}
		return base.Add(value);
	}
}


using System.Collections;
using System.Net;

private sealed class HttpWebRequestArrayList : ArrayListWrapper
{
	public HttpWebRequestArrayList(ArrayList list)
		: base(list)
	{
	}

	public override int Add(object value)
	{
		if (value is HttpWebRequest request)
		{
			s_instance.RaiseRequestEvent(request);
		}
		return base.Add(value);
	}

	public override void RemoveAt(int index)
	{
		if (base[index] is HttpWebRequest httpWebRequest)
		{
			HttpWebResponse httpWebResponse = s_httpResponseAccessor(httpWebRequest);
			if (httpWebResponse != null)
			{
				s_instance.RaiseResponseEvent(httpWebRequest, httpWebResponse);
			}
			else
			{
				object obj = s_coreResponseAccessor(httpWebRequest);
				if (obj != null && s_coreResponseDataType.IsInstanceOfType(obj))
				{
					HttpStatusCode statusCode = s_coreStatusCodeAccessor(obj);
					WebHeaderCollection headers = s_coreHeadersAccessor(obj);
					s_instance.RaiseResponseEvent(httpWebRequest, statusCode, headers);
				}
			}
		}
		base.RemoveAt(index);
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Field, AllowMultiple = true, Inherited = false)]
internal sealed class DynamicDependencyAttribute : Attribute
{
	public string MemberSignature { get; }

	public DynamicallyAccessedMemberTypes MemberTypes { get; }

	public Type Type { get; }

	public string TypeName { get; }

	public string AssemblyName { get; }

	public string Condition { get; set; }

	public DynamicDependencyAttribute(string memberSignature)
	{
		MemberSignature = memberSignature;
	}

	public DynamicDependencyAttribute(string memberSignature, Type type)
	{
		MemberSignature = memberSignature;
		Type = type;
	}

	public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName)
	{
		MemberSignature = memberSignature;
		TypeName = typeName;
		AssemblyName = assemblyName;
	}

	public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type)
	{
		MemberTypes = memberTypes;
		Type = type;
	}

	public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName)
	{
		MemberTypes = memberTypes;
		TypeName = typeName;
		AssemblyName = assemblyName;
	}
}


using System;

[Flags]
internal enum DynamicallyAccessedMemberTypes
{
	None = 0,
	PublicParameterlessConstructor = 1,
	PublicConstructors = 3,
	NonPublicConstructors = 4,
	PublicMethods = 8,
	NonPublicMethods = 0x10,
	PublicFields = 0x20,
	NonPublicFields = 0x40,
	PublicNestedTypes = 0x80,
	NonPublicNestedTypes = 0x100,
	PublicProperties = 0x200,
	NonPublicProperties = 0x400,
	PublicEvents = 0x800,
	NonPublicEvents = 0x1000,
	Interfaces = 0x2000,
	All = -1
}


using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Constructor | AttributeTargets.Method, Inherited = false)]
internal sealed class RequiresUnreferencedCodeAttribute : Attribute
{
	public string Message { get; }

	public string Url { get; set; }

	public RequiresUnreferencedCodeAttribute(string message)
	{
		Message = message;
	}
}


using System;

[AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]
internal sealed class UnconditionalSuppressMessageAttribute : Attribute
{
	public string Category { get; }

	public string CheckId { get; }

	public string Scope { get; set; }

	public string Target { get; set; }

	public string MessageId { get; set; }

	public string Justification { get; set; }

	public UnconditionalSuppressMessageAttribute(string category, string checkId)
	{
		Category = category;
		CheckId = checkId;
	}
}


using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Constructor | AttributeTargets.Method, Inherited = false)]
internal sealed class RequiresDynamicCodeAttribute : Attribute
{
	public string Message { get; }

	public string Url { get; set; }

	public RequiresDynamicCodeAttribute(string message)
	{
		Message = message;
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Metrics;
using System.Runtime.Versioning;
using System.Security;
using System.Threading;

[SecuritySafeCritical]
[UnsupportedOSPlatform("browser")]
internal sealed class AggregationManager
{
	public const double MinCollectionTimeSecs = 0.1;

	private static readonly QuantileAggregation s_defaultHistogramConfig = new QuantileAggregation(0.5, 0.95, 0.99);

	private readonly List<Predicate<Instrument>> _instrumentConfigFuncs = new List<Predicate<Instrument>>();

	private TimeSpan _collectionPeriod;

	private readonly ConcurrentDictionary<Instrument, InstrumentState> _instrumentStates = new ConcurrentDictionary<Instrument, InstrumentState>();

	private readonly CancellationTokenSource _cts = new CancellationTokenSource();

	private Thread _collectThread;

	private readonly MeterListener _listener;

	private int _currentTimeSeries;

	private int _currentHistograms;

	private readonly int _maxTimeSeries;

	private readonly int _maxHistograms;

	private readonly Action<Instrument, LabeledAggregationStatistics> _collectMeasurement;

	private readonly Action<DateTime, DateTime> _beginCollection;

	private readonly Action<DateTime, DateTime> _endCollection;

	private readonly Action<Instrument> _beginInstrumentMeasurements;

	private readonly Action<Instrument> _endInstrumentMeasurements;

	private readonly Action<Instrument> _instrumentPublished;

	private readonly Action _initialInstrumentEnumerationComplete;

	private readonly Action<Exception> _collectionError;

	private readonly Action _timeSeriesLimitReached;

	private readonly Action _histogramLimitReached;

	private readonly Action<Exception> _observableInstrumentCallbackError;

	public AggregationManager(int maxTimeSeries, int maxHistograms, Action<Instrument, LabeledAggregationStatistics> collectMeasurement, Action<DateTime, DateTime> beginCollection, Action<DateTime, DateTime> endCollection, Action<Instrument> beginInstrumentMeasurements, Action<Instrument> endInstrumentMeasurements, Action<Instrument> instrumentPublished, Action initialInstrumentEnumerationComplete, Action<Exception> collectionError, Action timeSeriesLimitReached, Action histogramLimitReached, Action<Exception> observableInstrumentCallbackError)
	{
		_maxTimeSeries = maxTimeSeries;
		_maxHistograms = maxHistograms;
		_collectMeasurement = collectMeasurement;
		_beginCollection = beginCollection;
		_endCollection = endCollection;
		_beginInstrumentMeasurements = beginInstrumentMeasurements;
		_endInstrumentMeasurements = endInstrumentMeasurements;
		_instrumentPublished = instrumentPublished;
		_initialInstrumentEnumerationComplete = initialInstrumentEnumerationComplete;
		_collectionError = collectionError;
		_timeSeriesLimitReached = timeSeriesLimitReached;
		_histogramLimitReached = histogramLimitReached;
		_observableInstrumentCallbackError = observableInstrumentCallbackError;
		_listener = new MeterListener
		{
			InstrumentPublished = delegate(Instrument instrument, MeterListener listener)
			{
				_instrumentPublished(instrument);
				InstrumentState instrumentState = GetInstrumentState(instrument);
				if (instrumentState != null)
				{
					_beginInstrumentMeasurements(instrument);
					listener.EnableMeasurementEvents(instrument, instrumentState);
				}
			},
			MeasurementsCompleted = delegate(Instrument instrument, object cookie)
			{
				_endInstrumentMeasurements(instrument);
				RemoveInstrumentState(instrument, (InstrumentState)cookie);
			}
		};
		_listener.SetMeasurementEventCallback(delegate(Instrument i, double m, ReadOnlySpan<KeyValuePair<string, object>> l, object c)
		{
			((InstrumentState)c).Update(m, l);
		});
		_listener.SetMeasurementEventCallback(delegate(Instrument i, float m, ReadOnlySpan<KeyValuePair<string, object>> l, object c)
		{
			((InstrumentState)c).Update(m, l);
		});
		_listener.SetMeasurementEventCallback(delegate(Instrument i, long m, ReadOnlySpan<KeyValuePair<string, object>> l, object c)
		{
			((InstrumentState)c).Update(m, l);
		});
		_listener.SetMeasurementEventCallback(delegate(Instrument i, int m, ReadOnlySpan<KeyValuePair<string, object>> l, object c)
		{
			((InstrumentState)c).Update(m, l);
		});
		_listener.SetMeasurementEventCallback(delegate(Instrument i, short m, ReadOnlySpan<KeyValuePair<string, object>> l, object c)
		{
			((InstrumentState)c).Update(m, l);
		});
		_listener.SetMeasurementEventCallback(delegate(Instrument i, byte m, ReadOnlySpan<KeyValuePair<string, object>> l, object c)
		{
			((InstrumentState)c).Update((int)m, l);
		});
		_listener.SetMeasurementEventCallback(delegate(Instrument i, decimal m, ReadOnlySpan<KeyValuePair<string, object>> l, object c)
		{
			((InstrumentState)c).Update((double)m, l);
		});
	}

	public void Include(string meterName)
	{
		Include((Instrument i) => i.Meter.Name == meterName);
	}

	public void Include(string meterName, string instrumentName)
	{
		Include((Instrument i) => i.Meter.Name == meterName && i.Name == instrumentName);
	}

	private void Include(Predicate<Instrument> instrumentFilter)
	{
		lock (this)
		{
			_instrumentConfigFuncs.Add(instrumentFilter);
		}
	}

	public AggregationManager SetCollectionPeriod(TimeSpan collectionPeriod)
	{
		lock (this)
		{
			_collectionPeriod = collectionPeriod;
			return this;
		}
	}

	public void Start()
	{
		_collectThread = new Thread((ThreadStart)delegate
		{
			CollectWorker(_cts.Token);
		});
		_collectThread.IsBackground = true;
		_collectThread.Name = "MetricsEventSource CollectWorker";
		_collectThread.Start();
		_listener.Start();
		_initialInstrumentEnumerationComplete();
	}

	private void CollectWorker(CancellationToken cancelToken)
	{
		try
		{
			double num = -1.0;
			lock (this)
			{
				num = _collectionPeriod.TotalSeconds;
			}
			DateTime utcNow = DateTime.UtcNow;
			DateTime arg = utcNow;
			while (!cancelToken.IsCancellationRequested)
			{
				DateTime utcNow2 = DateTime.UtcNow;
				double totalSeconds = (utcNow2 - utcNow).TotalSeconds;
				double value = Math.Ceiling(totalSeconds / num) * num;
				DateTime dateTime = utcNow.AddSeconds(value);
				DateTime dateTime2 = arg.AddSeconds(num);
				if (dateTime <= dateTime2)
				{
					dateTime = dateTime2;
				}
				TimeSpan timeout = dateTime - utcNow2;
				if (!cancelToken.WaitHandle.WaitOne(timeout))
				{
					_beginCollection(arg, dateTime);
					Collect();
					_endCollection(arg, dateTime);
					arg = dateTime;
					continue;
				}
				break;
			}
		}
		catch (Exception obj)
		{
			_collectionError(obj);
		}
	}

	public void Dispose()
	{
		_cts.Cancel();
		if (_collectThread != null)
		{
			_collectThread.Join();
			_collectThread = null;
		}
		_listener.Dispose();
	}

	private void RemoveInstrumentState(Instrument instrument, InstrumentState state)
	{
		_instrumentStates.TryRemove(instrument, out var _);
	}

	private InstrumentState GetInstrumentState(Instrument instrument)
	{
		if (!_instrumentStates.TryGetValue(instrument, out var value))
		{
			lock (this)
			{
				foreach (Predicate<Instrument> instrumentConfigFunc in _instrumentConfigFuncs)
				{
					if (instrumentConfigFunc(instrument))
					{
						value = BuildInstrumentState(instrument);
						if (value != null)
						{
							_instrumentStates.TryAdd(instrument, value);
							_instrumentStates.TryGetValue(instrument, out value);
						}
						break;
					}
				}
			}
		}
		return value;
	}

	[UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode", Justification = "MakeGenericType is creating instances over reference types that works fine in AOT.")]
	internal InstrumentState BuildInstrumentState(Instrument instrument)
	{
		Func<Aggregator> aggregatorFactory = GetAggregatorFactory(instrument);
		if (aggregatorFactory == null)
		{
			return null;
		}
		Type type = aggregatorFactory.GetType().GenericTypeArguments[0];
		Type type2 = typeof(InstrumentState<>).MakeGenericType(type);
		return (InstrumentState)Activator.CreateInstance(type2, aggregatorFactory);
	}

	private Func<Aggregator> GetAggregatorFactory(Instrument instrument)
	{
		Type type = instrument.GetType();
		Type type2 = null;
		type2 = (type.IsGenericType ? type.GetGenericTypeDefinition() : null);
		if (type2 == typeof(Counter<>))
		{
			return delegate
			{
				lock (this)
				{
					return CheckTimeSeriesAllowed() ? new RateSumAggregator() : null;
				}
			};
		}
		if (type2 == typeof(ObservableCounter<>))
		{
			return delegate
			{
				lock (this)
				{
					return CheckTimeSeriesAllowed() ? new RateAggregator() : null;
				}
			};
		}
		if (type2 == typeof(ObservableGauge<>))
		{
			return delegate
			{
				lock (this)
				{
					return CheckTimeSeriesAllowed() ? new LastValue() : null;
				}
			};
		}
		if (type2 == typeof(Histogram<>))
		{
			return delegate
			{
				lock (this)
				{
					return (!CheckHistogramAllowed() || !CheckTimeSeriesAllowed()) ? null : new ExponentialHistogramAggregator(s_defaultHistogramConfig);
				}
			};
		}
		return null;
	}

	private bool CheckTimeSeriesAllowed()
	{
		if (_currentTimeSeries < _maxTimeSeries)
		{
			_currentTimeSeries++;
			return true;
		}
		if (_currentTimeSeries == _maxTimeSeries)
		{
			_currentTimeSeries++;
			_timeSeriesLimitReached();
			return false;
		}
		return false;
	}

	private bool CheckHistogramAllowed()
	{
		if (_currentHistograms < _maxHistograms)
		{
			_currentHistograms++;
			return true;
		}
		if (_currentHistograms == _maxHistograms)
		{
			_currentHistograms++;
			_histogramLimitReached();
			return false;
		}
		return false;
	}

	internal void Collect()
	{
		try
		{
			_listener.RecordObservableInstruments();
		}
		catch (Exception obj)
		{
			_observableInstrumentCallbackError(obj);
		}
		foreach (KeyValuePair<Instrument, InstrumentState> kv in _instrumentStates)
		{
			kv.Value.Collect(kv.Key, delegate(LabeledAggregationStatistics labeledAggStats)
			{
				_collectMeasurement(kv.Key, labeledAggStats);
			});
		}
	}
}


using System.Diagnostics.Metrics;

internal abstract class Aggregator
{
	public abstract void Update(double measurement);

	public abstract IAggregationStatistics Collect();
}


internal interface IAggregationStatistics
{
}


using System.Runtime.CompilerServices;

[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
internal struct QuantileValue
{
	public double Quantile { get; }

	public double Value { get; }

	public QuantileValue(double quantile, double value)
	{
		Quantile = quantile;
		Value = value;
	}
}


using System.Diagnostics.Metrics;

internal sealed class HistogramStatistics : IAggregationStatistics
{
	public QuantileValue[] Quantiles { get; }

	internal HistogramStatistics(QuantileValue[] quantiles)
	{
		Quantiles = quantiles;
	}
}


using System.Collections.Generic;
using System.Diagnostics.Metrics;

internal sealed class LabeledAggregationStatistics
{
	public KeyValuePair<string, string>[] Labels { get; }

	public IAggregationStatistics AggregationStatistics { get; }

	public LabeledAggregationStatistics(IAggregationStatistics stats, params KeyValuePair<string, string>[] labels)
	{
		AggregationStatistics = stats;
		Labels = labels;
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;

[SecuritySafeCritical]
internal struct AggregatorStore<TAggregator> where TAggregator : Aggregator
{
	private volatile object _stateUnion;

	private volatile AggregatorLookupFunc<TAggregator> _cachedLookupFunc;

	private readonly Func<TAggregator> _createAggregatorFunc;

	public AggregatorStore(Func<TAggregator> createAggregator)
	{
		_stateUnion = null;
		_cachedLookupFunc = null;
		_createAggregatorFunc = createAggregator;
	}

	public TAggregator GetAggregator(ReadOnlySpan<KeyValuePair<string, object>> labels)
	{
		AggregatorLookupFunc<TAggregator> cachedLookupFunc = _cachedLookupFunc;
		if (cachedLookupFunc != null && cachedLookupFunc(labels, out var aggregator))
		{
			return aggregator;
		}
		return GetAggregatorSlow(labels);
	}

	private TAggregator GetAggregatorSlow(ReadOnlySpan<KeyValuePair<string, object>> labels)
	{
		TAggregator aggregator;
		bool flag = (_cachedLookupFunc = LabelInstructionCompiler.Create(ref this, _createAggregatorFunc, labels))(labels, out aggregator);
		return aggregator;
	}

	public void Collect(Action<LabeledAggregationStatistics> visitFunc)
	{
		object stateUnion = _stateUnion;
		object stateUnion2 = _stateUnion;
		if (!(stateUnion2 is TAggregator val))
		{
			if (!(stateUnion2 is FixedSizeLabelNameDictionary<StringSequence1, ObjectSequence1, TAggregator> fixedSizeLabelNameDictionary))
			{
				if (!(stateUnion2 is FixedSizeLabelNameDictionary<StringSequence2, ObjectSequence2, TAggregator> fixedSizeLabelNameDictionary2))
				{
					if (!(stateUnion2 is FixedSizeLabelNameDictionary<StringSequence3, ObjectSequence3, TAggregator> fixedSizeLabelNameDictionary3))
					{
						if (!(stateUnion2 is FixedSizeLabelNameDictionary<StringSequenceMany, ObjectSequenceMany, TAggregator> fixedSizeLabelNameDictionary4))
						{
							if (stateUnion2 is MultiSizeLabelNameDictionary<TAggregator> multiSizeLabelNameDictionary)
							{
								multiSizeLabelNameDictionary.Collect(visitFunc);
							}
						}
						else
						{
							fixedSizeLabelNameDictionary4.Collect(visitFunc);
						}
					}
					else
					{
						fixedSizeLabelNameDictionary3.Collect(visitFunc);
					}
				}
				else
				{
					fixedSizeLabelNameDictionary2.Collect(visitFunc);
				}
			}
			else
			{
				fixedSizeLabelNameDictionary.Collect(visitFunc);
			}
		}
		else
		{
			IAggregationStatistics stats = val.Collect();
			visitFunc(new LabeledAggregationStatistics(stats));
		}
	}

	public TAggregator GetAggregator()
	{
		MultiSizeLabelNameDictionary<TAggregator> multiSizeLabelNameDictionary2;
		while (true)
		{
			object stateUnion = _stateUnion;
			if (stateUnion == null)
			{
				TAggregator val = _createAggregatorFunc();
				if (val == null)
				{
					return val;
				}
				if (Interlocked.CompareExchange(ref _stateUnion, val, null) == null)
				{
					return val;
				}
				continue;
			}
			if (stateUnion is TAggregator result)
			{
				return result;
			}
			if (stateUnion is MultiSizeLabelNameDictionary<TAggregator> multiSizeLabelNameDictionary)
			{
				return multiSizeLabelNameDictionary.GetNoLabelAggregator(_createAggregatorFunc);
			}
			multiSizeLabelNameDictionary2 = new MultiSizeLabelNameDictionary<TAggregator>(stateUnion);
			if (Interlocked.CompareExchange(ref _stateUnion, multiSizeLabelNameDictionary2, stateUnion) == stateUnion)
			{
				break;
			}
		}
		return multiSizeLabelNameDictionary2.GetNoLabelAggregator(_createAggregatorFunc);
	}

	public ConcurrentDictionary<TObjectSequence, TAggregator> GetLabelValuesDictionary<TStringSequence, TObjectSequence>([In][<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly] ref TStringSequence names) where TStringSequence : IStringSequence, IEquatable<TStringSequence> where TObjectSequence : IObjectSequence, IEquatable<TObjectSequence>
	{
		MultiSizeLabelNameDictionary<TAggregator> multiSizeLabelNameDictionary2;
		while (true)
		{
			object stateUnion = _stateUnion;
			if (stateUnion == null)
			{
				FixedSizeLabelNameDictionary<TStringSequence, TObjectSequence, TAggregator> fixedSizeLabelNameDictionary = new FixedSizeLabelNameDictionary<TStringSequence, TObjectSequence, TAggregator>();
				if (Interlocked.CompareExchange(ref _stateUnion, fixedSizeLabelNameDictionary, null) == null)
				{
					return fixedSizeLabelNameDictionary.GetValuesDictionary(ref names);
				}
				continue;
			}
			if (stateUnion is FixedSizeLabelNameDictionary<TStringSequence, TObjectSequence, TAggregator> fixedSizeLabelNameDictionary2)
			{
				return fixedSizeLabelNameDictionary2.GetValuesDictionary(ref names);
			}
			if (stateUnion is MultiSizeLabelNameDictionary<TAggregator> multiSizeLabelNameDictionary)
			{
				return multiSizeLabelNameDictionary.GetFixedSizeLabelNameDictionary<TStringSequence, TObjectSequence>().GetValuesDictionary(ref names);
			}
			multiSizeLabelNameDictionary2 = new MultiSizeLabelNameDictionary<TAggregator>(stateUnion);
			if (Interlocked.CompareExchange(ref _stateUnion, multiSizeLabelNameDictionary2, stateUnion) == stateUnion)
			{
				break;
			}
		}
		return multiSizeLabelNameDictionary2.GetFixedSizeLabelNameDictionary<TStringSequence, TObjectSequence>().GetValuesDictionary(ref names);
	}
}


using System;
using System.Diagnostics.Metrics;
using System.Threading;

internal sealed class MultiSizeLabelNameDictionary<TAggregator> where TAggregator : Aggregator
{
	private TAggregator NoLabelAggregator;

	private FixedSizeLabelNameDictionary<StringSequence1, ObjectSequence1, TAggregator> Label1;

	private FixedSizeLabelNameDictionary<StringSequence2, ObjectSequence2, TAggregator> Label2;

	private FixedSizeLabelNameDictionary<StringSequence3, ObjectSequence3, TAggregator> Label3;

	private FixedSizeLabelNameDictionary<StringSequenceMany, ObjectSequenceMany, TAggregator> LabelMany;

	public MultiSizeLabelNameDictionary(object initialLabelNameDict)
	{
		NoLabelAggregator = null;
		Label1 = null;
		Label2 = null;
		Label3 = null;
		LabelMany = null;
		if (!(initialLabelNameDict is TAggregator noLabelAggregator))
		{
			if (!(initialLabelNameDict is FixedSizeLabelNameDictionary<StringSequence1, ObjectSequence1, TAggregator> label))
			{
				if (!(initialLabelNameDict is FixedSizeLabelNameDictionary<StringSequence2, ObjectSequence2, TAggregator> label2))
				{
					if (!(initialLabelNameDict is FixedSizeLabelNameDictionary<StringSequence3, ObjectSequence3, TAggregator> label3))
					{
						if (initialLabelNameDict is FixedSizeLabelNameDictionary<StringSequenceMany, ObjectSequenceMany, TAggregator> labelMany)
						{
							LabelMany = labelMany;
						}
					}
					else
					{
						Label3 = label3;
					}
				}
				else
				{
					Label2 = label2;
				}
			}
			else
			{
				Label1 = label;
			}
		}
		else
		{
			NoLabelAggregator = noLabelAggregator;
		}
	}

	public TAggregator GetNoLabelAggregator(Func<TAggregator> createFunc)
	{
		if (NoLabelAggregator == null)
		{
			TAggregator val = createFunc();
			if (val != null)
			{
				Interlocked.CompareExchange(ref NoLabelAggregator, val, null);
			}
		}
		return NoLabelAggregator;
	}

	public FixedSizeLabelNameDictionary<TStringSequence, TObjectSequence, TAggregator> GetFixedSizeLabelNameDictionary<TStringSequence, TObjectSequence>() where TStringSequence : IStringSequence, IEquatable<TStringSequence> where TObjectSequence : IObjectSequence, IEquatable<TObjectSequence>
	{
		TStringSequence val = default(TStringSequence);
		if (!(val is StringSequence1))
		{
			if (!(val is StringSequence2))
			{
				if (!(val is StringSequence3))
				{
					if (val is StringSequenceMany)
					{
						if (LabelMany == null)
						{
							Interlocked.CompareExchange(ref LabelMany, new FixedSizeLabelNameDictionary<StringSequenceMany, ObjectSequenceMany, TAggregator>(), null);
						}
						return (FixedSizeLabelNameDictionary<TStringSequence, TObjectSequence, TAggregator>)(object)LabelMany;
					}
					return null;
				}
				if (Label3 == null)
				{
					Interlocked.CompareExchange(ref Label3, new FixedSizeLabelNameDictionary<StringSequence3, ObjectSequence3, TAggregator>(), null);
				}
				return (FixedSizeLabelNameDictionary<TStringSequence, TObjectSequence, TAggregator>)(object)Label3;
			}
			if (Label2 == null)
			{
				Interlocked.CompareExchange(ref Label2, new FixedSizeLabelNameDictionary<StringSequence2, ObjectSequence2, TAggregator>(), null);
			}
			return (FixedSizeLabelNameDictionary<TStringSequence, TObjectSequence, TAggregator>)(object)Label2;
		}
		if (Label1 == null)
		{
			Interlocked.CompareExchange(ref Label1, new FixedSizeLabelNameDictionary<StringSequence1, ObjectSequence1, TAggregator>(), null);
		}
		return (FixedSizeLabelNameDictionary<TStringSequence, TObjectSequence, TAggregator>)(object)Label1;
	}

	public void Collect(Action<LabeledAggregationStatistics> visitFunc)
	{
		if (NoLabelAggregator != null)
		{
			IAggregationStatistics stats = NoLabelAggregator.Collect();
			visitFunc(new LabeledAggregationStatistics(stats));
		}
		Label1?.Collect(visitFunc);
		Label2?.Collect(visitFunc);
		Label3?.Collect(visitFunc);
		LabelMany?.Collect(visitFunc);
	}
}


using System.Runtime.CompilerServices;

internal struct LabelInstruction
{
	public int SourceIndex
	{
		[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
		get;
	}

	public string LabelName
	{
		[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
		get;
	}

	public LabelInstruction(int sourceIndex, string labelName)
	{
		SourceIndex = sourceIndex;
		LabelName = labelName;
	}
}


using System;
using System.Collections.Generic;

internal delegate bool AggregatorLookupFunc<TAggregator>(ReadOnlySpan<KeyValuePair<string, object>> labels, out TAggregator aggregator);


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Security;

[SecurityCritical]
internal static class LabelInstructionCompiler
{
	public static AggregatorLookupFunc<TAggregator> Create<TAggregator>(ref AggregatorStore<TAggregator> aggregatorStore, Func<TAggregator> createAggregatorFunc, ReadOnlySpan<KeyValuePair<string, object>> labels) where TAggregator : Aggregator
	{
		LabelInstruction[] array = Compile(labels);
		Array.Sort(array, (LabelInstruction a, LabelInstruction b) => string.CompareOrdinal(a.LabelName, b.LabelName));
		int expectedLabels = labels.Length;
		switch (array.Length)
		{
		case 0:
		{
			TAggregator defaultAggregator = aggregatorStore.GetAggregator();
			return delegate(ReadOnlySpan<KeyValuePair<string, object>> l, out TAggregator aggregator)
			{
				if (l.Length != expectedLabels)
				{
					aggregator = null;
					return false;
				}
				aggregator = defaultAggregator;
				return true;
			};
		}
		case 1:
		{
			StringSequence1 names2 = new StringSequence1(array[0].LabelName);
			ConcurrentDictionary<ObjectSequence1, TAggregator> labelValuesDictionary2 = aggregatorStore.GetLabelValuesDictionary<StringSequence1, ObjectSequence1>(ref names2);
			LabelInstructionInterpreter<ObjectSequence1, TAggregator> object2 = new LabelInstructionInterpreter<ObjectSequence1, TAggregator>(expectedLabels, array, labelValuesDictionary2, createAggregatorFunc);
			return object2.GetAggregator;
		}
		case 2:
		{
			StringSequence2 names4 = new StringSequence2(array[0].LabelName, array[1].LabelName);
			ConcurrentDictionary<ObjectSequence2, TAggregator> labelValuesDictionary4 = aggregatorStore.GetLabelValuesDictionary<StringSequence2, ObjectSequence2>(ref names4);
			LabelInstructionInterpreter<ObjectSequence2, TAggregator> object4 = new LabelInstructionInterpreter<ObjectSequence2, TAggregator>(expectedLabels, array, labelValuesDictionary4, createAggregatorFunc);
			return object4.GetAggregator;
		}
		case 3:
		{
			StringSequence3 names3 = new StringSequence3(array[0].LabelName, array[1].LabelName, array[2].LabelName);
			ConcurrentDictionary<ObjectSequence3, TAggregator> labelValuesDictionary3 = aggregatorStore.GetLabelValuesDictionary<StringSequence3, ObjectSequence3>(ref names3);
			LabelInstructionInterpreter<ObjectSequence3, TAggregator> object3 = new LabelInstructionInterpreter<ObjectSequence3, TAggregator>(expectedLabels, array, labelValuesDictionary3, createAggregatorFunc);
			return object3.GetAggregator;
		}
		default:
		{
			string[] array2 = new string[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array2[i] = array[i].LabelName;
			}
			StringSequenceMany names = new StringSequenceMany(array2);
			ConcurrentDictionary<ObjectSequenceMany, TAggregator> labelValuesDictionary = aggregatorStore.GetLabelValuesDictionary<StringSequenceMany, ObjectSequenceMany>(ref names);
			LabelInstructionInterpreter<ObjectSequenceMany, TAggregator> @object = new LabelInstructionInterpreter<ObjectSequenceMany, TAggregator>(expectedLabels, array, labelValuesDictionary, createAggregatorFunc);
			return @object.GetAggregator;
		}
		}
	}

	private static LabelInstruction[] Compile(ReadOnlySpan<KeyValuePair<string, object>> labels)
	{
		LabelInstruction[] array = new LabelInstruction[labels.Length];
		for (int i = 0; i < labels.Length; i++)
		{
			int num = i;
			int sourceIndex = i;
			KeyValuePair<string, object> keyValuePair = labels[i];
			array[num] = new LabelInstruction(sourceIndex, keyValuePair.Key);
		}
		return array;
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Security;

[SecurityCritical]
internal sealed class LabelInstructionInterpreter<TObjectSequence, TAggregator> where TObjectSequence : struct, IObjectSequence, IEquatable<TObjectSequence> where TAggregator : Aggregator
{
	private int _expectedLabelCount;

	private LabelInstruction[] _instructions;

	private ConcurrentDictionary<TObjectSequence, TAggregator> _valuesDict;

	private Func<TObjectSequence, TAggregator> _createAggregator;

	public LabelInstructionInterpreter(int expectedLabelCount, LabelInstruction[] instructions, ConcurrentDictionary<TObjectSequence, TAggregator> valuesDict, Func<TAggregator> createAggregator)
	{
		_expectedLabelCount = expectedLabelCount;
		_instructions = instructions;
		_valuesDict = valuesDict;
		_createAggregator = (TObjectSequence _) => createAggregator();
	}

	public bool GetAggregator(ReadOnlySpan<KeyValuePair<string, object>> labels, out TAggregator aggregator)
	{
		aggregator = null;
		if (labels.Length != _expectedLabelCount)
		{
			return false;
		}
		TObjectSequence val = default(TObjectSequence);
		if (val is ObjectSequenceMany)
		{
			val = (TObjectSequence)(object)new ObjectSequenceMany(new object[_expectedLabelCount]);
		}
		for (int i = 0; i < _instructions.Length; i++)
		{
			LabelInstruction labelInstruction = _instructions[i];
			string labelName = labelInstruction.LabelName;
			KeyValuePair<string, object> keyValuePair = labels[labelInstruction.SourceIndex];
			if (labelName != keyValuePair.Key)
			{
				return false;
			}
			int i2 = i;
			keyValuePair = labels[labelInstruction.SourceIndex];
			val[i2] = keyValuePair.Value;
		}
		if (!_valuesDict.TryGetValue(val, out aggregator))
		{
			aggregator = _createAggregator(val);
			if (aggregator == null)
			{
				return true;
			}
			aggregator = _valuesDict.GetOrAdd(val, aggregator);
		}
		return true;
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal sealed class FixedSizeLabelNameDictionary<TStringSequence, TObjectSequence, TAggregator> : ConcurrentDictionary<TStringSequence, ConcurrentDictionary<TObjectSequence, TAggregator>> where TStringSequence : IStringSequence, IEquatable<TStringSequence> where TObjectSequence : IObjectSequence, IEquatable<TObjectSequence> where TAggregator : Aggregator
{
	public void Collect(Action<LabeledAggregationStatistics> visitFunc)
	{
		using IEnumerator<KeyValuePair<TStringSequence, ConcurrentDictionary<TObjectSequence, TAggregator>>> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			KeyValuePair<TStringSequence, ConcurrentDictionary<TObjectSequence, TAggregator>> current = enumerator.Current;
			TStringSequence key = current.Key;
			foreach (KeyValuePair<TObjectSequence, TAggregator> item in current.Value)
			{
				TObjectSequence key2 = item.Key;
				KeyValuePair<string, string>[] array = new KeyValuePair<string, string>[key.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = new KeyValuePair<string, string>(key[i], key2[i]?.ToString() ?? "");
				}
				IAggregationStatistics stats = item.Value.Collect();
				visitFunc(new LabeledAggregationStatistics(stats, array));
			}
		}
	}

	public ConcurrentDictionary<TObjectSequence, TAggregator> GetValuesDictionary([In][<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly] ref TStringSequence names)
	{
		return GetOrAdd(names, (TStringSequence _) => new ConcurrentDictionary<TObjectSequence, TAggregator>());
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;

[SecuritySafeCritical]
internal sealed class Counter<T> : Instrument<T> where T : struct
{
	internal Counter(Meter meter, string name, string unit, string description)
		: base(meter, name, unit, description)
	{
		Publish();
	}

	public void Add(T delta)
	{
		RecordMeasurement(delta);
	}

	public void Add(T delta, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag)
	{
		RecordMeasurement(delta, tag);
	}

	public void Add(T delta, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag1, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag2)
	{
		RecordMeasurement(delta, tag1, tag2);
	}

	public void Add(T delta, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag1, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag2, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag3)
	{
		RecordMeasurement(delta, tag1, tag2, tag3);
	}

	public void Add(T delta, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })] ReadOnlySpan<KeyValuePair<string, object>> tags)
	{
		RecordMeasurement(delta, tags);
	}

	public void Add(T delta, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })] params KeyValuePair<string, object>[] tags)
	{
		RecordMeasurement(delta, MemoryExtensions.AsSpan(tags));
	}

	public void Add(T delta, [In][<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly] ref TagList tagList)
	{
		RecordMeasurement(delta, ref tagList);
	}
}


using System;

internal sealed class QuantileAggregation
{
	public double[] Quantiles { get; set; }

	public double MaxRelativeError { get; set; } = 0.001;

	public QuantileAggregation(params double[] quantiles)
	{
		Quantiles = quantiles;
		Array.Sort(Quantiles);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.Metrics;

internal sealed class ExponentialHistogramAggregator : Aggregator
{
	private struct Bucket
	{
		public double Value;

		public int Count;

		public Bucket(double value, int count)
		{
			Value = value;
			Count = count;
		}
	}

	private const int ExponentArraySize = 4096;

	private const int ExponentShift = 52;

	private const double MinRelativeError = 0.0001;

	private readonly QuantileAggregation _config;

	private int[][] _counters;

	private int _count;

	private readonly int _mantissaMax;

	private readonly int _mantissaMask;

	private readonly int _mantissaShift;

	public ExponentialHistogramAggregator(QuantileAggregation config)
	{
		_config = config;
		_counters = new int[4096][];
		if (_config.MaxRelativeError < 0.0001)
		{
			throw new ArgumentException();
		}
		int num = (int)Math.Ceiling(Math.Log(1.0 / _config.MaxRelativeError, 2.0)) - 1;
		_mantissaShift = 52 - num;
		_mantissaMax = 1 << num;
		_mantissaMask = _mantissaMax - 1;
	}

	public override IAggregationStatistics Collect()
	{
		int[][] counters;
		int count;
		lock (this)
		{
			counters = _counters;
			count = _count;
			_counters = new int[4096][];
			_count = 0;
		}
		QuantileValue[] array = new QuantileValue[_config.Quantiles.Length];
		int num = 0;
		if (num == _config.Quantiles.Length)
		{
			return new HistogramStatistics(array);
		}
		count -= GetInvalidCount(counters);
		int num2 = QuantileToRank(_config.Quantiles[num], count);
		int num3 = 0;
		foreach (Bucket item in IterateBuckets(counters))
		{
			num3 += item.Count;
			while (num3 > num2)
			{
				array[num] = new QuantileValue(_config.Quantiles[num], item.Value);
				num++;
				if (num == _config.Quantiles.Length)
				{
					return new HistogramStatistics(array);
				}
				num2 = QuantileToRank(_config.Quantiles[num], count);
			}
		}
		return new HistogramStatistics(Array.Empty<QuantileValue>());
	}

	private static int GetInvalidCount(int[][] counters)
	{
		int[] array = counters[2047];
		int[] array2 = counters[4095];
		int num = 0;
		if (array != null)
		{
			int[] array3 = array;
			foreach (int num2 in array3)
			{
				num += num2;
			}
		}
		if (array2 != null)
		{
			int[] array4 = array2;
			foreach (int num3 in array4)
			{
				num += num3;
			}
		}
		return num;
	}

	private IEnumerable<Bucket> IterateBuckets(int[][] counters)
	{
		for (int exponent = 4094; exponent >= 2048; exponent--)
		{
			int[] mantissaCounts = counters[exponent];
			if (mantissaCounts != null)
			{
				for (int mantissa = _mantissaMax - 1; mantissa >= 0; mantissa--)
				{
					int num = mantissaCounts[mantissa];
					if (num > 0)
					{
						yield return new Bucket(GetBucketCanonicalValue(exponent, mantissa), num);
					}
				}
			}
		}
		for (int exponent = 0; exponent < 2047; exponent++)
		{
			int[] mantissaCounts = counters[exponent];
			if (mantissaCounts == null)
			{
				continue;
			}
			for (int mantissa = 0; mantissa < _mantissaMax; mantissa++)
			{
				int num2 = mantissaCounts[mantissa];
				if (num2 > 0)
				{
					yield return new Bucket(GetBucketCanonicalValue(exponent, mantissa), num2);
				}
			}
		}
	}

	public override void Update(double measurement)
	{
		lock (this)
		{
			ulong num = (ulong)BitConverter.DoubleToInt64Bits(measurement);
			int num2 = (int)(num >> 52);
			int num3 = (int)(num >> _mantissaShift) & _mantissaMask;
			ref int[] reference = ref _counters[num2];
			if (reference == null)
			{
				reference = new int[_mantissaMax];
			}
			reference[num3]++;
			_count++;
		}
	}

	private static int QuantileToRank(double quantile, int count)
	{
		return Math.Min(Math.Max(0, (int)(quantile * (double)count)), count - 1);
	}

	private double GetBucketCanonicalValue(int exponent, int mantissa)
	{
		long value = ((long)exponent << 52) | ((long)mantissa << _mantissaShift);
		return BitConverter.Int64BitsToDouble(value);
	}
}


private struct Bucket
{
	public double Value;

	public int Count;

	public Bucket(double value, int count)
	{
		Value = value;
		Count = count;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;

[SecuritySafeCritical]
internal sealed class Histogram<T> : Instrument<T> where T : struct
{
	internal Histogram(Meter meter, string name, string unit, string description)
		: base(meter, name, unit, description)
	{
		Publish();
	}

	public void Record(T value)
	{
		RecordMeasurement(value);
	}

	public void Record(T value, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag)
	{
		RecordMeasurement(value, tag);
	}

	public void Record(T value, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag1, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag2)
	{
		RecordMeasurement(value, tag1, tag2);
	}

	public void Record(T value, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag1, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag2, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag3)
	{
		RecordMeasurement(value, tag1, tag2, tag3);
	}

	public void Record(T value, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })] ReadOnlySpan<KeyValuePair<string, object>> tags)
	{
		RecordMeasurement(value, tags);
	}

	public void Record(T value, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })] params KeyValuePair<string, object>[] tags)
	{
		RecordMeasurement(value, MemoryExtensions.AsSpan(tags));
	}

	public void Record(T value, [In][<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly] ref TagList tagList)
	{
		RecordMeasurement(value, ref tagList);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Security;

[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
[SecuritySafeCritical]
internal abstract class Instrument
{
	internal readonly DiagLinkedList<ListenerSubscription> _subscriptions = new DiagLinkedList<ListenerSubscription>();

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })]
	internal static KeyValuePair<string, object>[] EmptyTags => Array.Empty<KeyValuePair<string, object>>();

	internal static object SyncObject { get; } = new object();

	public Meter Meter { get; }

	public string Name { get; }

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public string Description
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		get;
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public string Unit
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
		get;
	}

	public bool Enabled => _subscriptions.First != null;

	public virtual bool IsObservable => false;

	protected Instrument(Meter meter, string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string unit, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string description)
	{
		Meter = meter ?? throw new ArgumentNullException("meter");
		Name = name ?? throw new ArgumentNullException("name");
		Description = description;
		Unit = unit;
	}

	protected void Publish()
	{
		List<MeterListener> list = null;
		lock (SyncObject)
		{
			if (Meter.Disposed || !Meter.AddInstrument(this))
			{
				return;
			}
			list = MeterListener.GetAllListeners();
		}
		if (list == null)
		{
			return;
		}
		foreach (MeterListener item in list)
		{
			item.InstrumentPublished?.Invoke(this, item);
		}
	}

	internal void NotifyForUnpublishedInstrument()
	{
		for (DiagNode<ListenerSubscription> diagNode = _subscriptions.First; diagNode != null; diagNode = diagNode.Next)
		{
			diagNode.Value.Listener.DisableMeasurementEvents(this);
		}
		_subscriptions.Clear();
	}

	internal static void ValidateTypeParameter<T>()
	{
		Type typeFromHandle = typeof(T);
		if (typeFromHandle != typeof(byte) && typeFromHandle != typeof(short) && typeFromHandle != typeof(int) && typeFromHandle != typeof(long) && typeFromHandle != typeof(double) && typeFromHandle != typeof(float) && typeFromHandle != typeof(decimal))
		{
			throw new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.Format(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.UnsupportedType, typeFromHandle));
		}
	}

	internal object EnableMeasurement(ListenerSubscription subscription, out bool oldStateStored)
	{
		oldStateStored = false;
		if (!_subscriptions.AddIfNotExist(subscription, (ListenerSubscription s1, ListenerSubscription s2) => s1.Listener == s2.Listener))
		{
			ListenerSubscription listenerSubscription = _subscriptions.Remove(subscription, (ListenerSubscription s1, ListenerSubscription s2) => s1.Listener == s2.Listener);
			_subscriptions.AddIfNotExist(subscription, (ListenerSubscription s1, ListenerSubscription s2) => s1.Listener == s2.Listener);
			oldStateStored = listenerSubscription.Listener == subscription.Listener;
			return listenerSubscription.State;
		}
		return false;
	}

	internal object DisableMeasurements(MeterListener listener)
	{
		return _subscriptions.Remove(new ListenerSubscription(listener), (ListenerSubscription s1, ListenerSubscription s2) => s1.Listener == s2.Listener).State;
	}

	internal virtual void Observe(MeterListener listener)
	{
		throw new InvalidOperationException();
	}

	internal object GetSubscriptionState(MeterListener listener)
	{
		for (DiagNode<ListenerSubscription> diagNode = _subscriptions.First; diagNode != null; diagNode = diagNode.Next)
		{
			if (listener == diagNode.Value.Listener)
			{
				return diagNode.Value.State;
			}
		}
		return null;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;

[SecuritySafeCritical]
internal abstract class Instrument<T> : Instrument where T : struct
{
	[ThreadStatic]
	private static KeyValuePair<string, object>[] ts_tags;

	private const int MaxTagsCount = 8;

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	protected Instrument(Meter meter, string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string unit, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string description)
		: base(meter, name, unit, description)
	{
		Instrument.ValidateTypeParameter<T>();
	}

	protected void RecordMeasurement(T measurement)
	{
		RecordMeasurement(measurement, MemoryExtensions.AsSpan(Instrument.EmptyTags));
	}

	protected void RecordMeasurement(T measurement, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })] ReadOnlySpan<KeyValuePair<string, object>> tags)
	{
		for (DiagNode<ListenerSubscription> diagNode = _subscriptions.First; diagNode != null; diagNode = diagNode.Next)
		{
			diagNode.Value.Listener.NotifyMeasurement(this, measurement, tags, diagNode.Value.State);
		}
	}

	protected void RecordMeasurement(T measurement, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag)
	{
		KeyValuePair<string, object>[] array = ts_tags ?? new KeyValuePair<string, object>[8];
		ts_tags = null;
		array[0] = tag;
		RecordMeasurement(measurement, MemoryExtensions.AsSpan(array).Slice(0, 1));
		ts_tags = array;
	}

	protected void RecordMeasurement(T measurement, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag1, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag2)
	{
		KeyValuePair<string, object>[] array = ts_tags ?? new KeyValuePair<string, object>[8];
		ts_tags = null;
		array[0] = tag1;
		array[1] = tag2;
		RecordMeasurement(measurement, MemoryExtensions.AsSpan(array).Slice(0, 2));
		ts_tags = array;
	}

	protected void RecordMeasurement(T measurement, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag1, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag2, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag3)
	{
		KeyValuePair<string, object>[] array = ts_tags ?? new KeyValuePair<string, object>[8];
		ts_tags = null;
		array[0] = tag1;
		array[1] = tag2;
		array[2] = tag3;
		RecordMeasurement(measurement, MemoryExtensions.AsSpan(array).Slice(0, 3));
		ts_tags = array;
	}

	protected void RecordMeasurement(T measurement, [In][<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly] ref TagList tagList)
	{
		KeyValuePair<string, object>[] tags = tagList.Tags;
		if (tags != null)
		{
			RecordMeasurement(measurement, MemoryExtensions.AsSpan(tags).Slice(0, tagList.Count));
			return;
		}
		tags = ts_tags ?? new KeyValuePair<string, object>[8];
		switch (tagList.Count)
		{
		default:
			return;
		case 8:
			tags[7] = tagList.Tag8;
			goto case 7;
		case 7:
			tags[6] = tagList.Tag7;
			goto case 6;
		case 6:
			tags[5] = tagList.Tag6;
			goto case 5;
		case 5:
			tags[4] = tagList.Tag5;
			goto case 4;
		case 4:
			tags[3] = tagList.Tag4;
			goto case 3;
		case 3:
			tags[2] = tagList.Tag3;
			goto case 2;
		case 2:
			tags[1] = tagList.Tag2;
			break;
		case 1:
			break;
		case 0:
			return;
		}
		tags[0] = tagList.Tag1;
		ts_tags = null;
		RecordMeasurement(measurement, MemoryExtensions.AsSpan(tags).Slice(0, tagList.Count));
		ts_tags = tags;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Security;

internal abstract class InstrumentState
{
	[SecuritySafeCritical]
	public abstract void Update(double measurement, ReadOnlySpan<KeyValuePair<string, object>> labels);

	public abstract void Collect(Instrument instrument, Action<LabeledAggregationStatistics> aggregationVisitFunc);
}


using System;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Security;

internal sealed class InstrumentState<TAggregator> : InstrumentState where TAggregator : Aggregator
{
	private AggregatorStore<TAggregator> _aggregatorStore;

	public InstrumentState(Func<TAggregator> createAggregatorFunc)
	{
		_aggregatorStore = new AggregatorStore<TAggregator>(createAggregatorFunc);
	}

	public override void Collect(Instrument instrument, Action<LabeledAggregationStatistics> aggregationVisitFunc)
	{
		_aggregatorStore.Collect(aggregationVisitFunc);
	}

	[SecuritySafeCritical]
	public override void Update(double measurement, ReadOnlySpan<KeyValuePair<string, object>> labels)
	{
		_aggregatorStore.GetAggregator(labels)?.Update(measurement);
	}
}


using System.Diagnostics.Metrics;

internal sealed class LastValue : Aggregator
{
	private double? _lastValue;

	public override void Update(double value)
	{
		_lastValue = value;
	}

	public override IAggregationStatistics Collect()
	{
		lock (this)
		{
			LastValueStatistics result = new LastValueStatistics(_lastValue);
			_lastValue = null;
			return result;
		}
	}
}


using System.Diagnostics.Metrics;

internal sealed class LastValueStatistics : IAggregationStatistics
{
	public double? LastValue { get; }

	internal LastValueStatistics(double? lastValue)
	{
		LastValue = lastValue;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Security;

[SecuritySafeCritical]
[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
internal struct Measurement<T> where T : struct
{
	private readonly KeyValuePair<string, object>[] _tags;

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })]
	public ReadOnlySpan<KeyValuePair<string, object>> Tags
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })]
		get
		{
			return MemoryExtensions.AsSpan(_tags);
		}
	}

	public T Value { get; }

	public Measurement(T value)
	{
		_tags = Instrument.EmptyTags;
		Value = value;
	}

	public Measurement(T value, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })] IEnumerable<KeyValuePair<string, object>> tags)
	{
		_tags = ToArray(tags);
		Value = value;
	}

	public Measurement(T value, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0, 1, 2 })] params KeyValuePair<string, object>[] tags)
	{
		if (tags != null)
		{
			_tags = new KeyValuePair<string, object>[tags.Length];
			tags.CopyTo(_tags, 0);
		}
		else
		{
			_tags = Instrument.EmptyTags;
		}
		Value = value;
	}

	public Measurement(T value, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })] ReadOnlySpan<KeyValuePair<string, object>> tags)
	{
		_tags = tags.ToArray();
		Value = value;
	}

	private static KeyValuePair<string, object>[] ToArray(IEnumerable<KeyValuePair<string, object>> tags)
	{
		if (tags != null)
		{
			return new List<KeyValuePair<string, object>>(tags).ToArray();
		}
		return Instrument.EmptyTags;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Security;

[SecuritySafeCritical]
[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(2)]
[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)]
internal class Meter : IDisposable
{
	private static readonly List<Meter> s_allMeters = new List<Meter>();

	private List<Instrument> _instruments = new List<Instrument>();

	internal bool Disposed { get; private set; }

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)]
	public string Name
	{
		[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
		get;
	}

	public string Version { get; }

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	public Meter(string name)
		: this(name, null)
	{
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	public Meter(string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string version)
	{
		Name = name ?? throw new ArgumentNullException("name");
		Version = version;
		lock (Instrument.SyncObject)
		{
			s_allMeters.Add(this);
		}
		GC.KeepAlive(MetricsEventSource.Log);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })]
	public Counter<T> CreateCounter<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, string unit = null, string description = null) where T : struct
	{
		return new Counter<T>(this, name, unit, description);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })]
	public Histogram<T> CreateHistogram<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, string unit = null, string description = null) where T : struct
	{
		return new Histogram<T>(this, name, unit, description);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })]
	public UpDownCounter<T> CreateUpDownCounter<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, string unit = null, string description = null) where T : struct
	{
		return new UpDownCounter<T>(this, name, unit, description);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })]
	public ObservableUpDownCounter<T> CreateObservableUpDownCounter<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })] Func<T> observeValue, string unit = null, string description = null) where T : struct
	{
		return new ObservableUpDownCounter<T>(this, name, observeValue, unit, description);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })]
	public ObservableUpDownCounter<T> CreateObservableUpDownCounter<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 0 })] Func<Measurement<T>> observeValue, string unit = null, string description = null) where T : struct
	{
		return new ObservableUpDownCounter<T>(this, name, observeValue, unit, description);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })]
	public ObservableUpDownCounter<T> CreateObservableUpDownCounter<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 1, 0, 0 })] Func<IEnumerable<Measurement<T>>> observeValues, string unit = null, string description = null) where T : struct
	{
		return new ObservableUpDownCounter<T>(this, name, observeValues, unit, description);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })]
	public ObservableCounter<T> CreateObservableCounter<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })] Func<T> observeValue, string unit = null, string description = null) where T : struct
	{
		return new ObservableCounter<T>(this, name, observeValue, unit, description);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })]
	public ObservableCounter<T> CreateObservableCounter<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 0 })] Func<Measurement<T>> observeValue, string unit = null, string description = null) where T : struct
	{
		return new ObservableCounter<T>(this, name, observeValue, unit, description);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })]
	public ObservableCounter<T> CreateObservableCounter<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 1, 0, 0 })] Func<IEnumerable<Measurement<T>>> observeValues, string unit = null, string description = null) where T : struct
	{
		return new ObservableCounter<T>(this, name, observeValues, unit, description);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })]
	public ObservableGauge<T> CreateObservableGauge<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })] Func<T> observeValue, string unit = null, string description = null) where T : struct
	{
		return new ObservableGauge<T>(this, name, observeValue, unit, description);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })]
	public ObservableGauge<T> CreateObservableGauge<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 0 })] Func<Measurement<T>> observeValue, string unit = null, string description = null) where T : struct
	{
		return new ObservableGauge<T>(this, name, observeValue, unit, description);
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0 })]
	public ObservableGauge<T> CreateObservableGauge<[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(0)] T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 1, 0, 0 })] Func<IEnumerable<Measurement<T>>> observeValues, string unit = null, string description = null) where T : struct
	{
		return new ObservableGauge<T>(this, name, observeValues, unit, description);
	}

	public void Dispose()
	{
		List<Instrument> list = null;
		lock (Instrument.SyncObject)
		{
			if (Disposed)
			{
				return;
			}
			Disposed = true;
			s_allMeters.Remove(this);
			list = _instruments;
			_instruments = new List<Instrument>();
		}
		if (list == null)
		{
			return;
		}
		foreach (Instrument item in list)
		{
			item.NotifyForUnpublishedInstrument();
		}
	}

	internal bool AddInstrument(Instrument instrument)
	{
		if (!_instruments.Contains(instrument))
		{
			_instruments.Add(instrument);
			return true;
		}
		return false;
	}

	internal static List<Instrument> GetPublishedInstruments()
	{
		List<Instrument> list = null;
		if (s_allMeters.Count > 0)
		{
			list = new List<Instrument>();
			foreach (Meter s_allMeter in s_allMeters)
			{
				foreach (Instrument instrument in s_allMeter._instruments)
				{
					list.Add(instrument);
				}
			}
		}
		return list;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;

internal delegate void MeasurementCallback<T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(1)] Instrument instrument, T measurement, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })] ReadOnlySpan<KeyValuePair<string, object>> tags, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object state) where T : struct;


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Security;

[SecuritySafeCritical]
internal sealed class MeterListener : IDisposable
{
	private static List<MeterListener> s_allStartedListeners = new List<MeterListener>();

	private DiagLinkedList<Instrument> _enabledMeasurementInstruments = new DiagLinkedList<Instrument>();

	private bool _disposed;

	private MeasurementCallback<byte> _byteMeasurementCallback = delegate
	{
	};

	private MeasurementCallback<short> _shortMeasurementCallback = delegate
	{
	};

	private MeasurementCallback<int> _intMeasurementCallback = delegate
	{
	};

	private MeasurementCallback<long> _longMeasurementCallback = delegate
	{
	};

	private MeasurementCallback<float> _floatMeasurementCallback = delegate
	{
	};

	private MeasurementCallback<double> _doubleMeasurementCallback = delegate
	{
	};

	private MeasurementCallback<decimal> _decimalMeasurementCallback = delegate
	{
	};

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1, 1 })]
	public Action<Instrument, MeterListener> InstrumentPublished
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1, 1 })]
		get;
		[param: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1, 1 })]
		set;
	}

	[<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1, 2 })]
	public Action<Instrument, object> MeasurementsCompleted
	{
		[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1, 2 })]
		get;
		[param: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 1, 2 })]
		set;
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	public void EnableMeasurementEvents(Instrument instrument, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] object state = null)
	{
		bool oldStateStored = false;
		bool flag = false;
		object arg = null;
		lock (Instrument.SyncObject)
		{
			if (instrument != null && !_disposed && !instrument.Meter.Disposed)
			{
				_enabledMeasurementInstruments.AddIfNotExist(instrument, object.ReferenceEquals);
				arg = instrument.EnableMeasurement(new ListenerSubscription(this, state), out oldStateStored);
				flag = true;
			}
		}
		if (flag)
		{
			if (oldStateStored && MeasurementsCompleted != null)
			{
				MeasurementsCompleted?.Invoke(instrument, arg);
			}
		}
		else
		{
			MeasurementsCompleted?.Invoke(instrument, state);
		}
	}

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)]
	public object DisableMeasurementEvents(Instrument instrument)
	{
		object obj = null;
		lock (Instrument.SyncObject)
		{
			if (instrument == null || _enabledMeasurementInstruments.Remove(instrument, object.ReferenceEquals) == null)
			{
				return null;
			}
			obj = instrument.DisableMeasurements(this);
		}
		MeasurementsCompleted?.Invoke(instrument, obj);
		return obj;
	}

	public void SetMeasurementEventCallback<T>([<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 2, 0 })] MeasurementCallback<T> measurementCallback) where T : struct
	{
		if (measurementCallback == null)
		{
			measurementCallback = delegate
			{
			};
		}
		if (typeof(T) == typeof(byte))
		{
			_byteMeasurementCallback = (MeasurementCallback<byte>)(object)measurementCallback;
			return;
		}
		if (typeof(T) == typeof(int))
		{
			_intMeasurementCallback = (MeasurementCallback<int>)(object)measurementCallback;
			return;
		}
		if (typeof(T) == typeof(float))
		{
			_floatMeasurementCallback = (MeasurementCallback<float>)(object)measurementCallback;
			return;
		}
		if (typeof(T) == typeof(double))
		{
			_doubleMeasurementCallback = (MeasurementCallback<double>)(object)measurementCallback;
			return;
		}
		if (typeof(T) == typeof(decimal))
		{
			_decimalMeasurementCallback = (MeasurementCallback<decimal>)(object)measurementCallback;
			return;
		}
		if (typeof(T) == typeof(short))
		{
			_shortMeasurementCallback = (MeasurementCallback<short>)(object)measurementCallback;
			return;
		}
		if (typeof(T) == typeof(long))
		{
			_longMeasurementCallback = (MeasurementCallback<long>)(object)measurementCallback;
			return;
		}
		throw new InvalidOperationException(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.Format(<98aa27ce-a3b7-4f67-9b18-59078b0717c9>SR.UnsupportedType, typeof(T)));
	}

	public void Start()
	{
		List<Instrument> list = null;
		lock (Instrument.SyncObject)
		{
			if (_disposed)
			{
				return;
			}
			if (!s_allStartedListeners.Contains(this))
			{
				s_allStartedListeners.Add(this);
				list = Meter.GetPublishedInstruments();
			}
		}
		if (list == null)
		{
			return;
		}
		foreach (Instrument item in list)
		{
			InstrumentPublished?.Invoke(item, this);
		}
	}

	public void RecordObservableInstruments()
	{
		List<Exception> list = null;
		for (DiagNode<Instrument> diagNode = _enabledMeasurementInstruments.First; diagNode != null; diagNode = diagNode.Next)
		{
			if (diagNode.Value.IsObservable)
			{
				try
				{
					diagNode.Value.Observe(this);
				}
				catch (Exception item)
				{
					if (list == null)
					{
						list = new List<Exception>();
					}
					list.Add(item);
				}
			}
		}
		if (list != null)
		{
			throw new AggregateException(list);
		}
	}

	public void Dispose()
	{
		Dictionary<Instrument, object> dictionary = null;
		Action<Instrument, object> measurementsCompleted = MeasurementsCompleted;
		lock (Instrument.SyncObject)
		{
			if (_disposed)
			{
				return;
			}
			_disposed = true;
			s_allStartedListeners.Remove(this);
			DiagNode<Instrument> diagNode = _enabledMeasurementInstruments.First;
			if (diagNode != null && measurementsCompleted != null)
			{
				dictionary = new Dictionary<Instrument, object>();
				do
				{
					object value = diagNode.Value.DisableMeasurements(this);
					dictionary.Add(diagNode.Value, value);
					diagNode = diagNode.Next;
				}
				while (diagNode != null);
				_enabledMeasurementInstruments.Clear();
			}
		}
		if (dictionary == null)
		{
			return;
		}
		foreach (KeyValuePair<Instrument, object> item in dictionary)
		{
			measurementsCompleted?.Invoke(item.Key, item.Value);
		}
	}

	internal static List<MeterListener> GetAllListeners()
	{
		if (s_allStartedListeners.Count != 0)
		{
			return new List<MeterListener>(s_allStartedListeners);
		}
		return null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void NotifyMeasurement<T>(Instrument instrument, T measurement, ReadOnlySpan<KeyValuePair<string, object>> tags, object state) where T : struct
	{
		if (typeof(T) == typeof(byte))
		{
			_byteMeasurementCallback(instrument, (byte)(object)measurement, tags, state);
		}
		if (typeof(T) == typeof(short))
		{
			_shortMeasurementCallback(instrument, (short)(object)measurement, tags, state);
		}
		if (typeof(T) == typeof(int))
		{
			_intMeasurementCallback(instrument, (int)(object)measurement, tags, state);
		}
		if (typeof(T) == typeof(long))
		{
			_longMeasurementCallback(instrument, (long)(object)measurement, tags, state);
		}
		if (typeof(T) == typeof(float))
		{
			_floatMeasurementCallback(instrument, (float)(object)measurement, tags, state);
		}
		if (typeof(T) == typeof(double))
		{
			_doubleMeasurementCallback(instrument, (double)(object)measurement, tags, state);
		}
		if (typeof(T) == typeof(decimal))
		{
			_decimalMeasurementCallback(instrument, (decimal)(object)measurement, tags, state);
		}
	}
}


using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;

[<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly]
internal struct ListenerSubscription
{
	internal MeterListener Listener { get; }

	internal object State { get; }

	internal ListenerSubscription(MeterListener listener, object state = null)
	{
		Listener = listener;
		State = state;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Metrics;
using System.Diagnostics.Tracing;
using System.Globalization;
using System.Runtime.Versioning;
using System.Text;
using System.Threading;

[EventSource(Name = "System.Diagnostics.Metrics")]
internal sealed class MetricsEventSource : EventSource
{
	public static class Keywords
	{
		public const EventKeywords Messages = (EventKeywords)1L;

		public const EventKeywords TimeSeriesValues = (EventKeywords)2L;

		public const EventKeywords InstrumentPublishing = (EventKeywords)4L;
	}

	private sealed class CommandHandler
	{
		private AggregationManager _aggregationManager;

		private string _sessionId = "";

		private static readonly char[] s_instrumentSeparators = new char[4] { '\r', '\n', ',', ';' };

		public MetricsEventSource Parent { get; private set; }

		public CommandHandler(MetricsEventSource parent)
		{
			Parent = parent;
		}

		public void OnEventCommand(EventCommandEventArgs command)
		{
			try
			{
				if (command.Command == EventCommand.Update || command.Command == EventCommand.Disable || command.Command == EventCommand.Enable)
				{
					if (_aggregationManager != null)
					{
						if (command.Command == EventCommand.Enable || command.Command == EventCommand.Update)
						{
							Parent.MultipleSessionsNotSupportedError(_sessionId);
							return;
						}
						_aggregationManager.Dispose();
						_aggregationManager = null;
						Parent.Message("Previous session with id " + _sessionId + " is stopped");
					}
					_sessionId = "";
				}
				if ((command.Command != 0 && command.Command != EventCommand.Enable) || command.Arguments == null)
				{
					return;
				}
				if (command.Arguments.TryGetValue("SessionId", out string value))
				{
					_sessionId = value;
					Parent.Message("SessionId argument received: " + _sessionId);
				}
				else
				{
					_sessionId = Guid.NewGuid().ToString();
					Parent.Message("New session started. SessionId auto-generated: " + _sessionId);
				}
				double num = 1.0;
				double result;
				if (command.Arguments.TryGetValue("RefreshInterval", out string value2))
				{
					Parent.Message("RefreshInterval argument received: " + value2);
					if (!double.TryParse(value2, out result))
					{
						Parent.Message($"Failed to parse RefreshInterval. Using default {num}s.");
						result = num;
					}
					else if (result < 0.1)
					{
						Parent.Message($"RefreshInterval too small. Using minimum interval {0.1} seconds.");
						result = 0.1;
					}
				}
				else
				{
					Parent.Message($"No RefreshInterval argument received. Using default {num}s.");
					result = num;
				}
				int num2 = 1000;
				int result2;
				if (command.Arguments.TryGetValue("MaxTimeSeries", out string value3))
				{
					Parent.Message("MaxTimeSeries argument received: " + value3);
					if (!int.TryParse(value3, out result2))
					{
						Parent.Message($"Failed to parse MaxTimeSeries. Using default {num2}");
						result2 = num2;
					}
				}
				else
				{
					Parent.Message($"No MaxTimeSeries argument received. Using default {num2}");
					result2 = num2;
				}
				int num3 = 20;
				int result3;
				if (command.Arguments.TryGetValue("MaxHistograms", out string value4))
				{
					Parent.Message("MaxHistograms argument received: " + value4);
					if (!int.TryParse(value4, out result3))
					{
						Parent.Message($"Failed to parse MaxHistograms. Using default {num3}");
						result3 = num3;
					}
				}
				else
				{
					Parent.Message($"No MaxHistogram argument received. Using default {num3}");
					result3 = num3;
				}
				string sessionId = _sessionId;
				_aggregationManager = new AggregationManager(result2, result3, delegate(Instrument i, LabeledAggregationStatistics s)
				{
					TransmitMetricValue(i, s, sessionId);
				}, delegate(DateTime startIntervalTime, DateTime endIntervalTime)
				{
					Parent.CollectionStart(sessionId, startIntervalTime, endIntervalTime);
				}, delegate(DateTime startIntervalTime, DateTime endIntervalTime)
				{
					Parent.CollectionStop(sessionId, startIntervalTime, endIntervalTime);
				}, delegate(Instrument i)
				{
					Parent.BeginInstrumentReporting(sessionId, i.Meter.Name, i.Meter.Version, i.Name, i.GetType().Name, i.Unit, i.Description);
				}, delegate(Instrument i)
				{
					Parent.EndInstrumentReporting(sessionId, i.Meter.Name, i.Meter.Version, i.Name, i.GetType().Name, i.Unit, i.Description);
				}, delegate(Instrument i)
				{
					Parent.InstrumentPublished(sessionId, i.Meter.Name, i.Meter.Version, i.Name, i.GetType().Name, i.Unit, i.Description);
				}, delegate
				{
					Parent.InitialInstrumentEnumerationComplete(sessionId);
				}, delegate(Exception e)
				{
					Parent.Error(sessionId, e.ToString());
				}, delegate
				{
					Parent.TimeSeriesLimitReached(sessionId);
				}, delegate
				{
					Parent.HistogramLimitReached(sessionId);
				}, delegate(Exception e)
				{
					Parent.ObservableInstrumentCallbackError(sessionId, e.ToString());
				});
				_aggregationManager.SetCollectionPeriod(TimeSpan.FromSeconds(result));
				if (command.Arguments.TryGetValue("Metrics", out string value5))
				{
					Parent.Message("Metrics argument received: " + value5);
					ParseSpecs(value5);
				}
				else
				{
					Parent.Message("No Metrics argument received");
				}
				_aggregationManager.Start();
			}
			catch (Exception e2) when (LogError(e2))
			{
			}
		}

		private bool LogError(Exception e)
		{
			Parent.Error(_sessionId, e.ToString());
			return false;
		}

		[UnsupportedOSPlatform("browser")]
		private void ParseSpecs(string metricsSpecs)
		{
			if (metricsSpecs == null)
			{
				return;
			}
			string[] array = metricsSpecs.Split(s_instrumentSeparators, StringSplitOptions.RemoveEmptyEntries);
			string[] array2 = array;
			foreach (string text in array2)
			{
				if (!MetricSpec.TryParse(text, out var spec))
				{
					Parent.Message("Failed to parse metric spec: " + text);
					continue;
				}
				Parent.Message($"Parsed metric: {spec}");
				if (spec.InstrumentName != null)
				{
					_aggregationManager.Include(spec.MeterName, spec.InstrumentName);
				}
				else
				{
					_aggregationManager.Include(spec.MeterName);
				}
			}
		}

		private static void TransmitMetricValue(Instrument instrument, LabeledAggregationStatistics stats, string sessionId)
		{
			if (stats.AggregationStatistics is RateStatistics rateStatistics)
			{
				Log.CounterRateValuePublished(sessionId, instrument.Meter.Name, instrument.Meter.Version, instrument.Name, instrument.Unit, FormatTags(stats.Labels), rateStatistics.Delta.HasValue ? rateStatistics.Delta.Value.ToString(CultureInfo.InvariantCulture) : "");
			}
			else if (stats.AggregationStatistics is LastValueStatistics lastValueStatistics)
			{
				Log.GaugeValuePublished(sessionId, instrument.Meter.Name, instrument.Meter.Version, instrument.Name, instrument.Unit, FormatTags(stats.Labels), lastValueStatistics.LastValue.HasValue ? lastValueStatistics.LastValue.Value.ToString(CultureInfo.InvariantCulture) : "");
			}
			else if (stats.AggregationStatistics is HistogramStatistics histogramStatistics)
			{
				Log.HistogramValuePublished(sessionId, instrument.Meter.Name, instrument.Meter.Version, instrument.Name, instrument.Unit, FormatTags(stats.Labels), FormatQuantiles(histogramStatistics.Quantiles));
			}
		}

		private static string FormatTags(KeyValuePair<string, string>[] labels)
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < labels.Length; i++)
			{
				stringBuilder.AppendFormat(CultureInfo.InvariantCulture, "{0}={1}", labels[i].Key, labels[i].Value);
				if (i != labels.Length - 1)
				{
					stringBuilder.Append(',');
				}
			}
			return stringBuilder.ToString();
		}

		private static string FormatQuantiles(QuantileValue[] quantiles)
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < quantiles.Length; i++)
			{
				stringBuilder.AppendFormat(CultureInfo.InvariantCulture, "{0}={1}", quantiles[i].Quantile, quantiles[i].Value);
				if (i != quantiles.Length - 1)
				{
					stringBuilder.Append(';');
				}
			}
			return stringBuilder.ToString();
		}
	}

	private sealed class MetricSpec
	{
		private const char MeterInstrumentSeparator = '\\';

		public string MeterName { get; private set; }

		public string InstrumentName { get; private set; }

		public MetricSpec(string meterName, string instrumentName)
		{
			MeterName = meterName;
			InstrumentName = instrumentName;
		}

		public static bool TryParse(string text, out MetricSpec spec)
		{
			int num = text.IndexOf('\\');
			if (num == -1)
			{
				spec = new MetricSpec(text.Trim(), null);
				return true;
			}
			string meterName = text.Substring(0, num).Trim();
			string instrumentName = text.Substring(num + 1).Trim();
			spec = new MetricSpec(meterName, instrumentName);
			return true;
		}

		public override string ToString()
		{
			if (InstrumentName == null)
			{
				return MeterName;
			}
			return MeterName + "\\" + InstrumentName;
		}
	}

	public static readonly MetricsEventSource Log = new MetricsEventSource();

	private CommandHandler _handler;

	private CommandHandler Handler
	{
		get
		{
			if (_handler == null)
			{
				Interlocked.CompareExchange(ref _handler, new CommandHandler(this), null);
			}
			return _handler;
		}
	}

	private MetricsEventSource()
	{
	}

	[Event(1, Keywords = (EventKeywords)1L)]
	public void Message(string Message)
	{
		WriteEvent(1, Message);
	}

	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "This calls WriteEvent with all primitive arguments which is safe. Primitives are always serialized properly.")]
	[Event(2, Keywords = (EventKeywords)2L)]
	public void CollectionStart(string sessionId, DateTime intervalStartTime, DateTime intervalEndTime)
	{
		WriteEvent(2, new object[3] { sessionId, intervalStartTime, intervalEndTime });
	}

	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "This calls WriteEvent with all primitive arguments which is safe. Primitives are always serialized properly.")]
	[Event(3, Keywords = (EventKeywords)2L)]
	public void CollectionStop(string sessionId, DateTime intervalStartTime, DateTime intervalEndTime)
	{
		WriteEvent(3, new object[3] { sessionId, intervalStartTime, intervalEndTime });
	}

	[Event(4, Keywords = (EventKeywords)2L)]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "This calls WriteEvent with all primitive arguments which is safe. Primitives are always serialized properly.")]
	public void CounterRateValuePublished(string sessionId, string meterName, string meterVersion, string instrumentName, string unit, string tags, string rate)
	{
		WriteEvent(4, new object[7]
		{
			sessionId,
			meterName,
			meterVersion ?? "",
			instrumentName,
			unit ?? "",
			tags,
			rate
		});
	}

	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "This calls WriteEvent with all primitive arguments which is safe. Primitives are always serialized properly.")]
	[Event(5, Keywords = (EventKeywords)2L)]
	public void GaugeValuePublished(string sessionId, string meterName, string meterVersion, string instrumentName, string unit, string tags, string lastValue)
	{
		WriteEvent(5, new object[7]
		{
			sessionId,
			meterName,
			meterVersion ?? "",
			instrumentName,
			unit ?? "",
			tags,
			lastValue
		});
	}

	[Event(6, Keywords = (EventKeywords)2L)]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "This calls WriteEvent with all primitive arguments which is safe. Primitives are always serialized properly.")]
	public void HistogramValuePublished(string sessionId, string meterName, string meterVersion, string instrumentName, string unit, string tags, string quantiles)
	{
		WriteEvent(6, new object[7]
		{
			sessionId,
			meterName,
			meterVersion ?? "",
			instrumentName,
			unit ?? "",
			tags,
			quantiles
		});
	}

	[Event(7, Keywords = (EventKeywords)2L)]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "This calls WriteEvent with all primitive arguments which is safe. Primitives are always serialized properly.")]
	public void BeginInstrumentReporting(string sessionId, string meterName, string meterVersion, string instrumentName, string instrumentType, string unit, string description)
	{
		WriteEvent(7, new object[7]
		{
			sessionId,
			meterName,
			meterVersion ?? "",
			instrumentName,
			instrumentType,
			unit ?? "",
			description ?? ""
		});
	}

	[Event(8, Keywords = (EventKeywords)2L)]
	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "This calls WriteEvent with all primitive arguments which is safe. Primitives are always serialized properly.")]
	public void EndInstrumentReporting(string sessionId, string meterName, string meterVersion, string instrumentName, string instrumentType, string unit, string description)
	{
		WriteEvent(8, new object[7]
		{
			sessionId,
			meterName,
			meterVersion ?? "",
			instrumentName,
			instrumentType,
			unit ?? "",
			description ?? ""
		});
	}

	[Event(9, Keywords = (EventKeywords)7L)]
	public void Error(string sessionId, string errorMessage)
	{
		WriteEvent(9, sessionId, errorMessage);
	}

	[Event(10, Keywords = (EventKeywords)6L)]
	public void InitialInstrumentEnumerationComplete(string sessionId)
	{
		WriteEvent(10, sessionId);
	}

	[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "This calls WriteEvent with all primitive arguments which is safe. Primitives are always serialized properly.")]
	[Event(11, Keywords = (EventKeywords)4L)]
	public void InstrumentPublished(string sessionId, string meterName, string meterVersion, string instrumentName, string instrumentType, string unit, string description)
	{
		WriteEvent(11, new object[7]
		{
			sessionId,
			meterName,
			meterVersion ?? "",
			instrumentName,
			instrumentType,
			unit ?? "",
			description ?? ""
		});
	}

	[Event(12, Keywords = (EventKeywords)2L)]
	public void TimeSeriesLimitReached(string sessionId)
	{
		WriteEvent(12, sessionId);
	}

	[Event(13, Keywords = (EventKeywords)2L)]
	public void HistogramLimitReached(string sessionId)
	{
		WriteEvent(13, sessionId);
	}

	[Event(14, Keywords = (EventKeywords)2L)]
	public void ObservableInstrumentCallbackError(string sessionId, string errorMessage)
	{
		WriteEvent(14, sessionId, errorMessage);
	}

	[Event(15, Keywords = (EventKeywords)7L)]
	public void MultipleSessionsNotSupportedError(string runningSessionId)
	{
		WriteEvent(15, runningSessionId);
	}

	[NonEvent]
	protected override void OnEventCommand(EventCommandEventArgs command)
	{
		lock (this)
		{
			Handler.OnEventCommand(command);
		}
	}
}


using System.Diagnostics.Tracing;

public static class Keywords
{
	public const EventKeywords Messages = (EventKeywords)1L;

	public const EventKeywords TimeSeriesValues = (EventKeywords)2L;

	public const EventKeywords InstrumentPublishing = (EventKeywords)4L;
}


using System.Collections.Generic;
using System.Diagnostics.Tracing;
using System.Globalization;
using System.Runtime.Versioning;
using System.Text;

private sealed class CommandHandler
{
	private AggregationManager _aggregationManager;

	private string _sessionId = "";

	private static readonly char[] s_instrumentSeparators = new char[4] { '\r', '\n', ',', ';' };

	public MetricsEventSource Parent { get; private set; }

	public CommandHandler(MetricsEventSource parent)
	{
		Parent = parent;
	}

	public void OnEventCommand(EventCommandEventArgs command)
	{
		try
		{
			if (command.Command == EventCommand.Update || command.Command == EventCommand.Disable || command.Command == EventCommand.Enable)
			{
				if (_aggregationManager != null)
				{
					if (command.Command == EventCommand.Enable || command.Command == EventCommand.Update)
					{
						Parent.MultipleSessionsNotSupportedError(_sessionId);
						return;
					}
					_aggregationManager.Dispose();
					_aggregationManager = null;
					Parent.Message("Previous session with id " + _sessionId + " is stopped");
				}
				_sessionId = "";
			}
			if ((command.Command != 0 && command.Command != EventCommand.Enable) || command.Arguments == null)
			{
				return;
			}
			if (command.Arguments.TryGetValue("SessionId", out string value))
			{
				_sessionId = value;
				Parent.Message("SessionId argument received: " + _sessionId);
			}
			else
			{
				_sessionId = Guid.NewGuid().ToString();
				Parent.Message("New session started. SessionId auto-generated: " + _sessionId);
			}
			double num = 1.0;
			double result;
			if (command.Arguments.TryGetValue("RefreshInterval", out string value2))
			{
				Parent.Message("RefreshInterval argument received: " + value2);
				if (!double.TryParse(value2, out result))
				{
					Parent.Message($"Failed to parse RefreshInterval. Using default {num}s.");
					result = num;
				}
				else if (result < 0.1)
				{
					Parent.Message($"RefreshInterval too small. Using minimum interval {0.1} seconds.");
					result = 0.1;
				}
			}
			else
			{
				Parent.Message($"No RefreshInterval argument received. Using default {num}s.");
				result = num;
			}
			int num2 = 1000;
			int result2;
			if (command.Arguments.TryGetValue("MaxTimeSeries", out string value3))
			{
				Parent.Message("MaxTimeSeries argument received: " + value3);
				if (!int.TryParse(value3, out result2))
				{
					Parent.Message($"Failed to parse MaxTimeSeries. Using default {num2}");
					result2 = num2;
				}
			}
			else
			{
				Parent.Message($"No MaxTimeSeries argument received. Using default {num2}");
				result2 = num2;
			}
			int num3 = 20;
			int result3;
			if (command.Arguments.TryGetValue("MaxHistograms", out string value4))
			{
				Parent.Message("MaxHistograms argument received: " + value4);
				if (!int.TryParse(value4, out result3))
				{
					Parent.Message($"Failed to parse MaxHistograms. Using default {num3}");
					result3 = num3;
				}
			}
			else
			{
				Parent.Message($"No MaxHistogram argument received. Using default {num3}");
				result3 = num3;
			}
			string sessionId = _sessionId;
			_aggregationManager = new AggregationManager(result2, result3, delegate(Instrument i, LabeledAggregationStatistics s)
			{
				TransmitMetricValue(i, s, sessionId);
			}, delegate(DateTime startIntervalTime, DateTime endIntervalTime)
			{
				Parent.CollectionStart(sessionId, startIntervalTime, endIntervalTime);
			}, delegate(DateTime startIntervalTime, DateTime endIntervalTime)
			{
				Parent.CollectionStop(sessionId, startIntervalTime, endIntervalTime);
			}, delegate(Instrument i)
			{
				Parent.BeginInstrumentReporting(sessionId, i.Meter.Name, i.Meter.Version, i.Name, i.GetType().Name, i.Unit, i.Description);
			}, delegate(Instrument i)
			{
				Parent.EndInstrumentReporting(sessionId, i.Meter.Name, i.Meter.Version, i.Name, i.GetType().Name, i.Unit, i.Description);
			}, delegate(Instrument i)
			{
				Parent.InstrumentPublished(sessionId, i.Meter.Name, i.Meter.Version, i.Name, i.GetType().Name, i.Unit, i.Description);
			}, delegate
			{
				Parent.InitialInstrumentEnumerationComplete(sessionId);
			}, delegate(Exception e)
			{
				Parent.Error(sessionId, e.ToString());
			}, delegate
			{
				Parent.TimeSeriesLimitReached(sessionId);
			}, delegate
			{
				Parent.HistogramLimitReached(sessionId);
			}, delegate(Exception e)
			{
				Parent.ObservableInstrumentCallbackError(sessionId, e.ToString());
			});
			_aggregationManager.SetCollectionPeriod(TimeSpan.FromSeconds(result));
			if (command.Arguments.TryGetValue("Metrics", out string value5))
			{
				Parent.Message("Metrics argument received: " + value5);
				ParseSpecs(value5);
			}
			else
			{
				Parent.Message("No Metrics argument received");
			}
			_aggregationManager.Start();
		}
		catch (Exception e2) when (LogError(e2))
		{
		}
	}

	private bool LogError(Exception e)
	{
		Parent.Error(_sessionId, e.ToString());
		return false;
	}

	[UnsupportedOSPlatform("browser")]
	private void ParseSpecs(string metricsSpecs)
	{
		if (metricsSpecs == null)
		{
			return;
		}
		string[] array = metricsSpecs.Split(s_instrumentSeparators, StringSplitOptions.RemoveEmptyEntries);
		string[] array2 = array;
		foreach (string text in array2)
		{
			if (!MetricSpec.TryParse(text, out var spec))
			{
				Parent.Message("Failed to parse metric spec: " + text);
				continue;
			}
			Parent.Message($"Parsed metric: {spec}");
			if (spec.InstrumentName != null)
			{
				_aggregationManager.Include(spec.MeterName, spec.InstrumentName);
			}
			else
			{
				_aggregationManager.Include(spec.MeterName);
			}
		}
	}

	private static void TransmitMetricValue(Instrument instrument, LabeledAggregationStatistics stats, string sessionId)
	{
		if (stats.AggregationStatistics is RateStatistics rateStatistics)
		{
			Log.CounterRateValuePublished(sessionId, instrument.Meter.Name, instrument.Meter.Version, instrument.Name, instrument.Unit, FormatTags(stats.Labels), rateStatistics.Delta.HasValue ? rateStatistics.Delta.Value.ToString(CultureInfo.InvariantCulture) : "");
		}
		else if (stats.AggregationStatistics is LastValueStatistics lastValueStatistics)
		{
			Log.GaugeValuePublished(sessionId, instrument.Meter.Name, instrument.Meter.Version, instrument.Name, instrument.Unit, FormatTags(stats.Labels), lastValueStatistics.LastValue.HasValue ? lastValueStatistics.LastValue.Value.ToString(CultureInfo.InvariantCulture) : "");
		}
		else if (stats.AggregationStatistics is HistogramStatistics histogramStatistics)
		{
			Log.HistogramValuePublished(sessionId, instrument.Meter.Name, instrument.Meter.Version, instrument.Name, instrument.Unit, FormatTags(stats.Labels), FormatQuantiles(histogramStatistics.Quantiles));
		}
	}

	private static string FormatTags(KeyValuePair<string, string>[] labels)
	{
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < labels.Length; i++)
		{
			stringBuilder.AppendFormat(CultureInfo.InvariantCulture, "{0}={1}", labels[i].Key, labels[i].Value);
			if (i != labels.Length - 1)
			{
				stringBuilder.Append(',');
			}
		}
		return stringBuilder.ToString();
	}

	private static string FormatQuantiles(QuantileValue[] quantiles)
	{
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < quantiles.Length; i++)
		{
			stringBuilder.AppendFormat(CultureInfo.InvariantCulture, "{0}={1}", quantiles[i].Quantile, quantiles[i].Value);
			if (i != quantiles.Length - 1)
			{
				stringBuilder.Append(';');
			}
		}
		return stringBuilder.ToString();
	}
}


private sealed class MetricSpec
{
	private const char MeterInstrumentSeparator = '\\';

	public string MeterName { get; private set; }

	public string InstrumentName { get; private set; }

	public MetricSpec(string meterName, string instrumentName)
	{
		MeterName = meterName;
		InstrumentName = instrumentName;
	}

	public static bool TryParse(string text, out MetricSpec spec)
	{
		int num = text.IndexOf('\\');
		if (num == -1)
		{
			spec = new MetricSpec(text.Trim(), null);
			return true;
		}
		string meterName = text.Substring(0, num).Trim();
		string instrumentName = text.Substring(num + 1).Trim();
		spec = new MetricSpec(meterName, instrumentName);
		return true;
	}

	public override string ToString()
	{
		if (InstrumentName == null)
		{
			return MeterName;
		}
		return MeterName + "\\" + InstrumentName;
	}
}


using System;
using System.Diagnostics.Metrics;

internal struct ObjectSequence1 : IEquatable<ObjectSequence1>, IObjectSequence
{
	public object Value1;

	public object this[int i]
	{
		get
		{
			if (i == 0)
			{
				return Value1;
			}
			throw new IndexOutOfRangeException();
		}
		set
		{
			if (i == 0)
			{
				Value1 = value;
				return;
			}
			throw new IndexOutOfRangeException();
		}
	}

	public ObjectSequence1(object value1)
	{
		Value1 = value1;
	}

	public override int GetHashCode()
	{
		return Value1?.GetHashCode() ?? 0;
	}

	public bool Equals(ObjectSequence1 other)
	{
		if (Value1 != null)
		{
			return Value1.Equals(other.Value1);
		}
		return other.Value1 == null;
	}

	public override bool Equals(object obj)
	{
		if (obj is ObjectSequence1 other)
		{
			return Equals(other);
		}
		return false;
	}
}


using System;
using System.Diagnostics.Metrics;

internal struct ObjectSequence2 : IEquatable<ObjectSequence2>, IObjectSequence
{
	public object Value1;

	public object Value2;

	public object this[int i]
	{
		get
		{
			return i switch
			{
				0 => Value1, 
				1 => Value2, 
				_ => throw new IndexOutOfRangeException(), 
			};
		}
		set
		{
			switch (i)
			{
			case 0:
				Value1 = value;
				break;
			case 1:
				Value2 = value;
				break;
			default:
				throw new IndexOutOfRangeException();
			}
		}
	}

	public ObjectSequence2(object value1, object value2)
	{
		Value1 = value1;
		Value2 = value2;
	}

	public bool Equals(ObjectSequence2 other)
	{
		if ((Value1 == null) ? (other.Value1 == null) : Value1.Equals(other.Value1))
		{
			if (Value2 != null)
			{
				return Value2.Equals(other.Value2);
			}
			return other.Value2 == null;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is ObjectSequence2 other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (Value1?.GetHashCode() ?? 0) ^ (Value2?.GetHashCode() ?? 0);
	}
}


using System;
using System.Diagnostics.Metrics;

internal struct ObjectSequence3 : IEquatable<ObjectSequence3>, IObjectSequence
{
	public object Value1;

	public object Value2;

	public object Value3;

	public object this[int i]
	{
		get
		{
			return i switch
			{
				0 => Value1, 
				1 => Value2, 
				2 => Value3, 
				_ => throw new IndexOutOfRangeException(), 
			};
		}
		set
		{
			switch (i)
			{
			case 0:
				Value1 = value;
				break;
			case 1:
				Value2 = value;
				break;
			case 2:
				Value3 = value;
				break;
			default:
				throw new IndexOutOfRangeException();
			}
		}
	}

	public ObjectSequence3(object value1, object value2, object value3)
	{
		Value1 = value1;
		Value2 = value2;
		Value3 = value3;
	}

	public bool Equals(ObjectSequence3 other)
	{
		if (((Value1 == null) ? (other.Value1 == null) : Value1.Equals(other.Value1)) && ((Value2 == null) ? (other.Value2 == null) : Value2.Equals(other.Value2)))
		{
			if (Value3 != null)
			{
				return Value3.Equals(other.Value3);
			}
			return other.Value3 == null;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is ObjectSequence3 other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (Value1?.GetHashCode() ?? 0) ^ (Value2?.GetHashCode() ?? 0) ^ (Value3?.GetHashCode() ?? 0);
	}
}


using System;
using System.Diagnostics.Metrics;

internal struct ObjectSequenceMany : IEquatable<ObjectSequenceMany>, IObjectSequence
{
	private readonly object[] _values;

	public object this[int i]
	{
		get
		{
			return _values[i];
		}
		set
		{
			_values[i] = value;
		}
	}

	public ObjectSequenceMany(object[] values)
	{
		_values = values;
	}

	public bool Equals(ObjectSequenceMany other)
	{
		if (_values.Length != other._values.Length)
		{
			return false;
		}
		for (int i = 0; i < _values.Length; i++)
		{
			object obj = _values[i];
			object obj2 = other._values[i];
			if (obj == null)
			{
				if (obj2 != null)
				{
					return false;
				}
			}
			else if (!obj.Equals(obj2))
			{
				return false;
			}
		}
		return true;
	}

	public override bool Equals(object obj)
	{
		if (obj is ObjectSequenceMany other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		int num = 0;
		for (int i = 0; i < _values.Length; i++)
		{
			num <<= 3;
			object obj = _values[i];
			if (obj != null)
			{
				num ^= obj.GetHashCode();
			}
		}
		return num;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Security;

[SecuritySafeCritical]
internal sealed class ObservableCounter<T> : ObservableInstrument<T> where T : struct
{
	private object _callback;

	internal ObservableCounter(Meter meter, string name, Func<T> observeValue, string unit, string description)
		: base(meter, name, unit, description)
	{
		_callback = observeValue ?? throw new ArgumentNullException("observeValue");
		Publish();
	}

	internal ObservableCounter(Meter meter, string name, Func<Measurement<T>> observeValue, string unit, string description)
		: base(meter, name, unit, description)
	{
		_callback = observeValue ?? throw new ArgumentNullException("observeValue");
		Publish();
	}

	internal ObservableCounter(Meter meter, string name, Func<IEnumerable<Measurement<T>>> observeValues, string unit, string description)
		: base(meter, name, unit, description)
	{
		_callback = observeValues ?? throw new ArgumentNullException("observeValues");
		Publish();
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 0 })]
	protected override IEnumerable<Measurement<T>> Observe()
	{
		return ObservableInstrument<T>.Observe(_callback);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Security;

[SecuritySafeCritical]
internal sealed class ObservableGauge<T> : ObservableInstrument<T> where T : struct
{
	private object _callback;

	internal ObservableGauge(Meter meter, string name, Func<T> observeValue, string unit, string description)
		: base(meter, name, unit, description)
	{
		_callback = observeValue ?? throw new ArgumentNullException("observeValue");
		Publish();
	}

	internal ObservableGauge(Meter meter, string name, Func<Measurement<T>> observeValue, string unit, string description)
		: base(meter, name, unit, description)
	{
		_callback = observeValue ?? throw new ArgumentNullException("observeValue");
		Publish();
	}

	internal ObservableGauge(Meter meter, string name, Func<IEnumerable<Measurement<T>>> observeValues, string unit, string description)
		: base(meter, name, unit, description)
	{
		_callback = observeValues ?? throw new ArgumentNullException("observeValues");
		Publish();
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 0 })]
	protected override IEnumerable<Measurement<T>> Observe()
	{
		return ObservableInstrument<T>.Observe(_callback);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Security;

[SecuritySafeCritical]
internal abstract class ObservableInstrument<T> : Instrument where T : struct
{
	public override bool IsObservable => true;

	[<6c14b95c-4a6b-457d-94a2-080f46b2b478>NullableContext(1)]
	protected ObservableInstrument(Meter meter, string name, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string unit, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(2)] string description)
		: base(meter, name, unit, description)
	{
		Instrument.ValidateTypeParameter<T>();
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 0 })]
	protected abstract IEnumerable<Measurement<T>> Observe();

	[SecuritySafeCritical]
	internal override void Observe(MeterListener listener)
	{
		object subscriptionState = GetSubscriptionState(listener);
		IEnumerable<Measurement<T>> enumerable = Observe();
		if (enumerable == null)
		{
			return;
		}
		foreach (Measurement<T> item in enumerable)
		{
			listener.NotifyMeasurement(this, item.Value, item.Tags, subscriptionState);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static IEnumerable<Measurement<T>> Observe(object callback)
	{
		if (callback is Func<T> func)
		{
			return new Measurement<T>[1]
			{
				new Measurement<T>(func())
			};
		}
		if (callback is Func<Measurement<T>> func2)
		{
			return new Measurement<T>[1] { func2() };
		}
		if (callback is Func<IEnumerable<Measurement<T>>> func3)
		{
			return func3();
		}
		return null;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Security;

[SecuritySafeCritical]
internal sealed class ObservableUpDownCounter<T> : ObservableInstrument<T> where T : struct
{
	private object _callback;

	internal ObservableUpDownCounter(Meter meter, string name, Func<T> observeValue, string unit, string description)
		: base(meter, name, unit, description)
	{
		_callback = observeValue ?? throw new ArgumentNullException("observeValue");
		Publish();
	}

	internal ObservableUpDownCounter(Meter meter, string name, Func<Measurement<T>> observeValue, string unit, string description)
		: base(meter, name, unit, description)
	{
		_callback = observeValue ?? throw new ArgumentNullException("observeValue");
		Publish();
	}

	internal ObservableUpDownCounter(Meter meter, string name, Func<IEnumerable<Measurement<T>>> observeValues, string unit, string description)
		: base(meter, name, unit, description)
	{
		_callback = observeValues ?? throw new ArgumentNullException("observeValues");
		Publish();
	}

	[return: <cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 0 })]
	protected override IEnumerable<Measurement<T>> Observe()
	{
		return ObservableInstrument<T>.Observe(_callback);
	}
}


using System.Diagnostics.Metrics;

internal sealed class RateSumAggregator : Aggregator
{
	private double _sum;

	public override void Update(double value)
	{
		lock (this)
		{
			_sum += value;
		}
	}

	public override IAggregationStatistics Collect()
	{
		lock (this)
		{
			RateStatistics result = new RateStatistics(_sum);
			_sum = 0.0;
			return result;
		}
	}
}


using System.Diagnostics.Metrics;

internal sealed class RateAggregator : Aggregator
{
	private double? _prevValue;

	private double _value;

	public override void Update(double value)
	{
		lock (this)
		{
			_value = value;
		}
	}

	public override IAggregationStatistics Collect()
	{
		lock (this)
		{
			double? delta = null;
			if (_prevValue.HasValue)
			{
				delta = _value - _prevValue.Value;
			}
			RateStatistics result = new RateStatistics(delta);
			_prevValue = _value;
			return result;
		}
	}
}


using System.Diagnostics.Metrics;

internal sealed class RateStatistics : IAggregationStatistics
{
	public double? Delta { get; }

	public RateStatistics(double? delta)
	{
		Delta = delta;
	}
}


using System;
using System.Diagnostics.Metrics;

internal struct StringSequence1 : IEquatable<StringSequence1>, IStringSequence
{
	public string Value1;

	public string this[int i]
	{
		get
		{
			if (i == 0)
			{
				return Value1;
			}
			throw new IndexOutOfRangeException();
		}
		set
		{
			if (i == 0)
			{
				Value1 = value;
				return;
			}
			throw new IndexOutOfRangeException();
		}
	}

	public int Length => 1;

	public StringSequence1(string value1)
	{
		Value1 = value1;
	}

	public override int GetHashCode()
	{
		return Value1.GetHashCode();
	}

	public bool Equals(StringSequence1 other)
	{
		return Value1 == other.Value1;
	}

	public override bool Equals(object obj)
	{
		if (obj is StringSequence1 other)
		{
			return Equals(other);
		}
		return false;
	}
}


using System;
using System.Diagnostics.Metrics;

internal struct StringSequence2 : IEquatable<StringSequence2>, IStringSequence
{
	public string Value1;

	public string Value2;

	public string this[int i]
	{
		get
		{
			return i switch
			{
				0 => Value1, 
				1 => Value2, 
				_ => throw new IndexOutOfRangeException(), 
			};
		}
		set
		{
			switch (i)
			{
			case 0:
				Value1 = value;
				break;
			case 1:
				Value2 = value;
				break;
			default:
				throw new IndexOutOfRangeException();
			}
		}
	}

	public int Length => 2;

	public StringSequence2(string value1, string value2)
	{
		Value1 = value1;
		Value2 = value2;
	}

	public bool Equals(StringSequence2 other)
	{
		if (Value1 == other.Value1)
		{
			return Value2 == other.Value2;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is StringSequence2 other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (Value1?.GetHashCode() ?? 0) ^ (Value2?.GetHashCode() ?? 0);
	}
}


using System;
using System.Diagnostics.Metrics;

internal struct StringSequence3 : IEquatable<StringSequence3>, IStringSequence
{
	public string Value1;

	public string Value2;

	public string Value3;

	public string this[int i]
	{
		get
		{
			return i switch
			{
				0 => Value1, 
				1 => Value2, 
				2 => Value3, 
				_ => throw new IndexOutOfRangeException(), 
			};
		}
		set
		{
			switch (i)
			{
			case 0:
				Value1 = value;
				break;
			case 1:
				Value2 = value;
				break;
			case 2:
				Value3 = value;
				break;
			default:
				throw new IndexOutOfRangeException();
			}
		}
	}

	public int Length => 3;

	public StringSequence3(string value1, string value2, string value3)
	{
		Value1 = value1;
		Value2 = value2;
		Value3 = value3;
	}

	public bool Equals(StringSequence3 other)
	{
		if (Value1 == other.Value1 && Value2 == other.Value2)
		{
			return Value3 == other.Value3;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is StringSequence3 other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (Value1?.GetHashCode() ?? 0) ^ (Value2?.GetHashCode() ?? 0) ^ (Value3?.GetHashCode() ?? 0);
	}
}


using System;
using System.Diagnostics.Metrics;

internal struct StringSequenceMany : IEquatable<StringSequenceMany>, IStringSequence
{
	private readonly string[] _values;

	public string this[int i]
	{
		get
		{
			return _values[i];
		}
		set
		{
			_values[i] = value;
		}
	}

	public int Length => _values.Length;

	public StringSequenceMany(string[] values)
	{
		_values = values;
	}

	public Span<string> AsSpan()
	{
		return MemoryExtensions.AsSpan(_values);
	}

	public bool Equals(StringSequenceMany other)
	{
		return MemoryExtensions.AsSpan(_values).SequenceEqual(MemoryExtensions.AsSpan(other._values));
	}

	public override bool Equals(object obj)
	{
		if (obj is StringSequenceMany other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		int num = 0;
		for (int i = 0; i < _values.Length; i++)
		{
			num <<= 3;
			num ^= _values[i].GetHashCode();
		}
		return num;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;

[SecuritySafeCritical]
internal sealed class UpDownCounter<T> : Instrument<T> where T : struct
{
	internal UpDownCounter(Meter meter, string name, string unit, string description)
		: base(meter, name, unit, description)
	{
		Publish();
	}

	public void Add(T delta)
	{
		RecordMeasurement(delta);
	}

	public void Add(T delta, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag)
	{
		RecordMeasurement(delta, tag);
	}

	public void Add(T delta, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag1, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag2)
	{
		RecordMeasurement(delta, tag1, tag2);
	}

	public void Add(T delta, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag1, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag2, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 1, 2 })] KeyValuePair<string, object> tag3)
	{
		RecordMeasurement(delta, tag1, tag2, tag3);
	}

	public void Add(T delta, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 0, 0, 1, 2 })] ReadOnlySpan<KeyValuePair<string, object>> tags)
	{
		RecordMeasurement(delta, tags);
	}

	public void Add(T delta, [<cb19cdbf-9746-4655-867e-0e010acfd54a>Nullable(new byte[] { 1, 0, 1, 2 })] params KeyValuePair<string, object>[] tags)
	{
		RecordMeasurement(delta, MemoryExtensions.AsSpan(tags));
	}

	public void Add(T delta, [In][<b470df79-a5b8-442e-9a19-dc7ef3b9a2cb>IsReadOnly] ref TagList tagList)
	{
		RecordMeasurement(delta, ref tagList);
	}
}


internal interface IObjectSequence
{
	object this[int i] { get; set; }
}


internal interface IStringSequence
{
	string this[int i] { get; set; }

	int Length { get; }
}


internal static class SR
{
}


using System;
using System.ComponentModel;
using System.Numerics.Hashing;
using System.Runtime.CompilerServices;

[<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
internal struct SequencePosition : IEquatable<SequencePosition>
{
	private readonly object _object;

	private readonly int _integer;

	public SequencePosition(object @object, int integer)
	{
		_object = @object;
		_integer = integer;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public object GetObject()
	{
		return _object;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public int GetInteger()
	{
		return _integer;
	}

	public bool Equals(SequencePosition other)
	{
		if (_integer == other._integer)
		{
			return object.Equals(_object, other._object);
		}
		return false;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public override bool Equals(object obj)
	{
		if (obj is SequencePosition other)
		{
			return Equals(other);
		}
		return false;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public override int GetHashCode()
	{
		return <c139fa64-ff40-4487-9647-1f385a5dbff6>HashHelpers.Combine(_object?.GetHashCode() ?? 0, _integer);
	}
}


using System;

internal static class DecimalDecCalc
{
	private static uint D32DivMod1E9(uint hi32, ref uint lo32)
	{
		ulong num = ((ulong)hi32 << 32) | lo32;
		lo32 = (uint)(num / 1000000000);
		return (uint)(num % 1000000000);
	}

	internal static uint DecDivMod1E9(ref MutableDecimal value)
	{
		return D32DivMod1E9(D32DivMod1E9(D32DivMod1E9(0u, ref value.High), ref value.Mid), ref value.Low);
	}

	internal static void DecAddInt32(ref MutableDecimal value, uint i)
	{
		if (D32AddCarry(ref value.Low, i) && D32AddCarry(ref value.Mid, 1u))
		{
			D32AddCarry(ref value.High, 1u);
		}
	}

	private static bool D32AddCarry(ref uint value, uint i)
	{
		uint num = value;
		uint num2 = (value = num + i);
		if (num2 >= num)
		{
			return num2 < i;
		}
		return true;
	}

	internal static void DecMul10(ref MutableDecimal value)
	{
		MutableDecimal d = value;
		DecShiftLeft(ref value);
		DecShiftLeft(ref value);
		DecAdd(ref value, d);
		DecShiftLeft(ref value);
	}

	private static void DecShiftLeft(ref MutableDecimal value)
	{
		uint num = (((value.Low & 0x80000000u) != 0) ? 1u : 0u);
		uint num2 = (((value.Mid & 0x80000000u) != 0) ? 1u : 0u);
		value.Low <<= 1;
		value.Mid = (value.Mid << 1) | num;
		value.High = (value.High << 1) | num2;
	}

	private static void DecAdd(ref MutableDecimal value, MutableDecimal d)
	{
		if (D32AddCarry(ref value.Low, d.Low) && D32AddCarry(ref value.Mid, 1u))
		{
			D32AddCarry(ref value.High, 1u);
		}
		if (D32AddCarry(ref value.Mid, d.Mid))
		{
			D32AddCarry(ref value.High, 1u);
		}
		D32AddCarry(ref value.High, d.High);
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;

internal static class Number
{
	private static class DoubleHelper
	{
		public unsafe static uint Exponent(double d)
		{
			return (*(uint*)((byte*)(&d) + 4) >> 20) & 0x7FF;
		}

		public unsafe static ulong Mantissa(double d)
		{
			return (uint)(*(int*)(&d)) | ((ulong)(*(uint*)((byte*)(&d) + 4) & 0xFFFFF) << 32);
		}

		public unsafe static bool Sign(double d)
		{
			return *(uint*)((byte*)(&d) + 4) >> 31 != 0;
		}
	}

	internal const int DECIMAL_PRECISION = 29;

	private static readonly ulong[] s_rgval64Power10 = new ulong[30]
	{
		11529215046068469760uL, 14411518807585587200uL, 18014398509481984000uL, 11258999068426240000uL, 14073748835532800000uL, 17592186044416000000uL, 10995116277760000000uL, 13743895347200000000uL, 17179869184000000000uL, 10737418240000000000uL,
		13421772800000000000uL, 16777216000000000000uL, 10485760000000000000uL, 13107200000000000000uL, 16384000000000000000uL, 14757395258967641293uL, 11805916207174113035uL, 9444732965739290428uL, 15111572745182864686uL, 12089258196146291749uL,
		9671406556917033399uL, 15474250491067253438uL, 12379400392853802751uL, 9903520314283042201uL, 15845632502852867522uL, 12676506002282294018uL, 10141204801825835215uL, 16225927682921336344uL, 12980742146337069075uL, 10384593717069655260uL
	};

	private static readonly sbyte[] s_rgexp64Power10 = new sbyte[15]
	{
		4, 7, 10, 14, 17, 20, 24, 27, 30, 34,
		37, 40, 44, 47, 50
	};

	private static readonly ulong[] s_rgval64Power10By16 = new ulong[42]
	{
		10240000000000000000uL, 11368683772161602974uL, 12621774483536188886uL, 14012984643248170708uL, 15557538194652854266uL, 17272337110188889248uL, 9588073174409622172uL, 10644899600020376798uL, 11818212630765741798uL, 13120851772591970216uL,
		14567071740625403792uL, 16172698447808779622uL, 17955302187076837696uL, 9967194951097567532uL, 11065809325636130658uL, 12285516299433008778uL, 13639663065038175358uL, 15143067982934716296uL, 16812182738118149112uL, 9332636185032188787uL,
		10361307573072618722uL, 16615349947311448416uL, 14965776766268445891uL, 13479973333575319909uL, 12141680576410806707uL, 10936253623915059637uL, 9850501549098619819uL, 17745086042373215136uL, 15983352577617880260uL, 14396524142538228461uL,
		12967236152753103031uL, 11679847981112819795uL, 10520271803096747049uL, 9475818434452569218uL, 17070116948172427008uL, 15375394465392026135uL, 13848924157002783096uL, 12474001934591998882uL, 11235582092889474480uL, 10120112665365530972uL,
		18230774251475056952uL, 16420821625123739930uL
	};

	private static readonly short[] s_rgexp64Power10By16 = new short[21]
	{
		54, 107, 160, 213, 266, 319, 373, 426, 479, 532,
		585, 638, 691, 745, 798, 851, 904, 957, 1010, 1064,
		1117
	};

	public static void RoundNumber(ref NumberBuffer number, int pos)
	{
		Span<byte> digits = number.Digits;
		int i;
		for (i = 0; i < pos && digits[i] != 0; i++)
		{
		}
		if (i == pos && digits[i] >= 53)
		{
			while (i > 0 && digits[i - 1] == 57)
			{
				i--;
			}
			if (i > 0)
			{
				digits[i - 1]++;
			}
			else
			{
				number.Scale++;
				digits[0] = 49;
				i = 1;
			}
		}
		else
		{
			while (i > 0 && digits[i - 1] == 48)
			{
				i--;
			}
		}
		if (i == 0)
		{
			number.Scale = 0;
			number.IsNegative = false;
		}
		digits[i] = 0;
	}

	internal static bool NumberBufferToDouble(ref NumberBuffer number, out double value)
	{
		double num = NumberToDouble(ref number);
		uint num2 = DoubleHelper.Exponent(num);
		ulong num3 = DoubleHelper.Mantissa(num);
		switch (num2)
		{
		case 2047u:
			value = 0.0;
			return false;
		case 0u:
			if (num3 == 0L)
			{
				num = 0.0;
			}
			break;
		}
		value = num;
		return true;
	}

	public unsafe static bool NumberBufferToDecimal(ref NumberBuffer number, ref decimal value)
	{
		MutableDecimal source = default(MutableDecimal);
		byte* ptr = number.UnsafeDigits;
		int num = number.Scale;
		if (*ptr == 0)
		{
			if (num > 0)
			{
				num = 0;
			}
		}
		else
		{
			if (num > 29)
			{
				return false;
			}
			while ((num > 0 || (*ptr != 0 && num > -28)) && (source.High < 429496729 || (source.High == 429496729 && (source.Mid < 2576980377u || (source.Mid == 2576980377u && (source.Low < 2576980377u || (source.Low == 2576980377u && *ptr <= 53)))))))
			{
				DecimalDecCalc.DecMul10(ref source);
				if (*ptr != 0)
				{
					DecimalDecCalc.DecAddInt32(ref source, (uint)(*(ptr++) - 48));
				}
				num--;
			}
			if (*(ptr++) >= 53)
			{
				bool flag = true;
				if (*(ptr - 1) == 53 && *(ptr - 2) % 2 == 0)
				{
					int num2 = 20;
					while (*ptr == 48 && num2 != 0)
					{
						ptr++;
						num2--;
					}
					if (*ptr == 0 || num2 == 0)
					{
						flag = false;
					}
				}
				if (flag)
				{
					DecimalDecCalc.DecAddInt32(ref source, 1u);
					if ((source.High | source.Mid | source.Low) == 0)
					{
						source.High = 429496729u;
						source.Mid = 2576980377u;
						source.Low = 2576980378u;
						num++;
					}
				}
			}
		}
		if (num > 0)
		{
			return false;
		}
		if (num <= -29)
		{
			source.High = 0u;
			source.Low = 0u;
			source.Mid = 0u;
			source.Scale = 28;
		}
		else
		{
			source.Scale = -num;
		}
		source.IsNegative = number.IsNegative;
		value = Unsafe.As<MutableDecimal, decimal>(ref source);
		return true;
	}

	public static void DecimalToNumber(decimal value, ref NumberBuffer number)
	{
		ref MutableDecimal reference = ref Unsafe.As<decimal, MutableDecimal>(ref value);
		Span<byte> digits = number.Digits;
		number.IsNegative = reference.IsNegative;
		int num = 29;
		while ((reference.Mid != 0) | (reference.High != 0))
		{
			uint num2 = DecimalDecCalc.DecDivMod1E9(ref reference);
			for (int i = 0; i < 9; i++)
			{
				digits[--num] = (byte)(num2 % 10 + 48);
				num2 /= 10;
			}
		}
		for (uint num3 = reference.Low; num3 != 0; num3 /= 10)
		{
			digits[--num] = (byte)(num3 % 10 + 48);
		}
		int num4 = 29 - num;
		number.Scale = num4 - reference.Scale;
		Span<byte> digits2 = number.Digits;
		int index = 0;
		while (--num4 >= 0)
		{
			digits2[index++] = digits[num++];
		}
		digits2[index] = 0;
	}

	private static uint DigitsToInt(ReadOnlySpan<byte> digits, int count)
	{
		uint value;
		int bytesConsumed;
		bool flag = Utf8Parser.TryParse(digits.Slice(0, count), out value, out bytesConsumed, 'D');
		return value;
	}

	private static ulong Mul32x32To64(uint a, uint b)
	{
		return (ulong)a * (ulong)b;
	}

	private static ulong Mul64Lossy(ulong a, ulong b, ref int pexp)
	{
		ulong num = Mul32x32To64((uint)(a >> 32), (uint)(b >> 32)) + (Mul32x32To64((uint)(a >> 32), (uint)b) >> 32) + (Mul32x32To64((uint)a, (uint)(b >> 32)) >> 32);
		if ((num & 0x8000000000000000uL) == 0L)
		{
			num <<= 1;
			pexp--;
		}
		return num;
	}

	private static int abs(int value)
	{
		if (value < 0)
		{
			return -value;
		}
		return value;
	}

	private unsafe static double NumberToDouble(ref NumberBuffer number)
	{
		ReadOnlySpan<byte> digits = number.Digits;
		int i = 0;
		int numDigits = number.NumDigits;
		int num = numDigits;
		for (; digits[i] == 48; i++)
		{
			num--;
		}
		if (num == 0)
		{
			return 0.0;
		}
		int num2 = Math.Min(num, 9);
		num -= num2;
		ulong num3 = DigitsToInt(digits, num2);
		if (num > 0)
		{
			num2 = Math.Min(num, 9);
			num -= num2;
			uint b = (uint)(s_rgval64Power10[num2 - 1] >> 64 - s_rgexp64Power10[num2 - 1]);
			num3 = Mul32x32To64((uint)num3, b) + DigitsToInt(digits.Slice(9), num2);
		}
		int num4 = number.Scale - (numDigits - num);
		int num5 = abs(num4);
		if (num5 >= 352)
		{
			ulong num6 = ((num4 > 0) ? 9218868437227405312uL : 0);
			if (number.IsNegative)
			{
				num6 |= 0x8000000000000000uL;
			}
			return *(double*)(&num6);
		}
		int pexp = 64;
		if ((num3 & 0xFFFFFFFF00000000uL) == 0L)
		{
			num3 <<= 32;
			pexp -= 32;
		}
		if ((num3 & 0xFFFF000000000000uL) == 0L)
		{
			num3 <<= 16;
			pexp -= 16;
		}
		if ((num3 & 0xFF00000000000000uL) == 0L)
		{
			num3 <<= 8;
			pexp -= 8;
		}
		if ((num3 & 0xF000000000000000uL) == 0L)
		{
			num3 <<= 4;
			pexp -= 4;
		}
		if ((num3 & 0xC000000000000000uL) == 0L)
		{
			num3 <<= 2;
			pexp -= 2;
		}
		if ((num3 & 0x8000000000000000uL) == 0L)
		{
			num3 <<= 1;
			pexp--;
		}
		int num7 = num5 & 0xF;
		if (num7 != 0)
		{
			int num8 = s_rgexp64Power10[num7 - 1];
			pexp += ((num4 < 0) ? (-num8 + 1) : num8);
			ulong b2 = s_rgval64Power10[num7 + ((num4 < 0) ? 15 : 0) - 1];
			num3 = Mul64Lossy(num3, b2, ref pexp);
		}
		num7 = num5 >> 4;
		if (num7 != 0)
		{
			int num9 = s_rgexp64Power10By16[num7 - 1];
			pexp += ((num4 < 0) ? (-num9 + 1) : num9);
			ulong b3 = s_rgval64Power10By16[num7 + ((num4 < 0) ? 21 : 0) - 1];
			num3 = Mul64Lossy(num3, b3, ref pexp);
		}
		if (((int)num3 & 0x400) != 0)
		{
			ulong num10 = num3 + 1023 + (ulong)(((int)num3 >> 11) & 1);
			if (num10 < num3)
			{
				num10 = (num10 >> 1) | 0x8000000000000000uL;
				pexp++;
			}
			num3 = num10;
		}
		pexp += 1022;
		num3 = ((pexp <= 0) ? ((pexp == -52 && num3 >= 9223372036854775896uL) ? 1 : ((pexp > -52) ? (num3 >> -pexp + 11 + 1) : 0)) : ((pexp < 2047) ? ((ulong)((long)pexp << 52) + ((num3 >> 11) & 0xFFFFFFFFFFFFFL)) : 9218868437227405312uL));
		if (number.IsNegative)
		{
			num3 |= 0x8000000000000000uL;
		}
		return *(double*)(&num3);
	}
}


private static class DoubleHelper
{
	public unsafe static uint Exponent(double d)
	{
		return (*(uint*)((byte*)(&d) + 4) >> 20) & 0x7FF;
	}

	public unsafe static ulong Mantissa(double d)
	{
		return (uint)(*(int*)(&d)) | ((ulong)(*(uint*)((byte*)(&d) + 4) & 0xFFFFF) << 32);
	}

	public unsafe static bool Sign(double d)
	{
		return *(uint*)((byte*)(&d) + 4) >> 31 != 0;
	}
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;

[<439493f3-a3f7-4dc9-b609-17ad8331cd81>IsByRefLike]
internal struct NumberBuffer
{
	public int Scale;

	public bool IsNegative;

	public const int BufferSize = 51;

	private byte _b0;

	private byte _b1;

	private byte _b2;

	private byte _b3;

	private byte _b4;

	private byte _b5;

	private byte _b6;

	private byte _b7;

	private byte _b8;

	private byte _b9;

	private byte _b10;

	private byte _b11;

	private byte _b12;

	private byte _b13;

	private byte _b14;

	private byte _b15;

	private byte _b16;

	private byte _b17;

	private byte _b18;

	private byte _b19;

	private byte _b20;

	private byte _b21;

	private byte _b22;

	private byte _b23;

	private byte _b24;

	private byte _b25;

	private byte _b26;

	private byte _b27;

	private byte _b28;

	private byte _b29;

	private byte _b30;

	private byte _b31;

	private byte _b32;

	private byte _b33;

	private byte _b34;

	private byte _b35;

	private byte _b36;

	private byte _b37;

	private byte _b38;

	private byte _b39;

	private byte _b40;

	private byte _b41;

	private byte _b42;

	private byte _b43;

	private byte _b44;

	private byte _b45;

	private byte _b46;

	private byte _b47;

	private byte _b48;

	private byte _b49;

	private byte _b50;

	public unsafe Span<byte> Digits => new Span<byte>(Unsafe.AsPointer(ref _b0), 51);

	public unsafe byte* UnsafeDigits => (byte*)Unsafe.AsPointer(ref _b0);

	public int NumDigits => Digits.IndexOf<byte>(0);

	[Conditional("DEBUG")]
	public void CheckConsistency()
	{
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append('[');
		stringBuilder.Append('"');
		Span<byte> digits = Digits;
		for (int i = 0; i < 51; i++)
		{
			byte b = digits[i];
			if (b == 0)
			{
				break;
			}
			stringBuilder.Append((char)b);
		}
		stringBuilder.Append('"');
		stringBuilder.Append(", Scale = " + Scale);
		stringBuilder.Append(", IsNegative   = " + IsNegative);
		stringBuilder.Append(']');
		return stringBuilder.ToString();
	}
}


using System;
using System.Buffers;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[DebuggerDisplay("{ToString(),raw}")]
[DebuggerTypeProxy(typeof(System.MemoryDebugView<>))]
[<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
internal struct Memory<T>
{
	private readonly object _object;

	private readonly int _index;

	private readonly int _length;

	private const int RemoveFlagsBitMask = int.MaxValue;

	public static Memory<T> Empty => default(Memory<T>);

	public int Length => _length & 0x7FFFFFFF;

	public bool IsEmpty => (_length & 0x7FFFFFFF) == 0;

	public Span<T> Span
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if (_index < 0)
			{
				return ((MemoryManager<T>)_object).GetSpan().Slice(_index & 0x7FFFFFFF, _length);
			}
			if (typeof(T) == typeof(char) && _object is string text)
			{
				return new Span<T>(Unsafe.As<Pinnable<T>>(text), MemoryExtensions.StringAdjustment, text.Length).Slice(_index, _length);
			}
			if (_object != null)
			{
				return new Span<T>((T[])_object, _index, _length & 0x7FFFFFFF);
			}
			return default(Span<T>);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Memory(T[] array)
	{
		if (array == null)
		{
			this = default(Memory<T>);
			return;
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArrayTypeMismatchException();
		}
		_object = array;
		_index = 0;
		_length = array.Length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Memory(T[] array, int start)
	{
		if (array == null)
		{
			if (start != 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException();
			}
			this = default(Memory<T>);
			return;
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArrayTypeMismatchException();
		}
		if ((uint)start > (uint)array.Length)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		_object = array;
		_index = start;
		_length = array.Length - start;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Memory(T[] array, int start, int length)
	{
		if (array == null)
		{
			if (start != 0 || length != 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException();
			}
			this = default(Memory<T>);
			return;
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArrayTypeMismatchException();
		}
		if ((uint)start > (uint)array.Length || (uint)length > (uint)(array.Length - start))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		_object = array;
		_index = start;
		_length = length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Memory(MemoryManager<T> manager, int length)
	{
		if (length < 0)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		_object = manager;
		_index = int.MinValue;
		_length = length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Memory(MemoryManager<T> manager, int start, int length)
	{
		if (length < 0 || start < 0)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		_object = manager;
		_index = start | int.MinValue;
		_length = length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Memory(object obj, int start, int length)
	{
		_object = obj;
		_index = start;
		_length = length;
	}

	public static implicit operator Memory<T>(T[] array)
	{
		return new Memory<T>(array);
	}

	public static implicit operator Memory<T>(ArraySegment<T> segment)
	{
		return new Memory<T>(segment.Array, segment.Offset, segment.Count);
	}

	public static implicit operator ReadOnlyMemory<T>(Memory<T> memory)
	{
		return Unsafe.As<Memory<T>, ReadOnlyMemory<T>>(ref memory);
	}

	public override string ToString()
	{
		if (typeof(T) == typeof(char))
		{
			if (!(_object is string text))
			{
				return Span.ToString();
			}
			return text.Substring(_index, _length & 0x7FFFFFFF);
		}
		return $"System.Memory<{typeof(T).Name}>[{_length & 0x7FFFFFFF}]";
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Memory<T> Slice(int start)
	{
		int length = _length;
		int num = length & 0x7FFFFFFF;
		if ((uint)start > (uint)num)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		return new Memory<T>(_object, _index + start, length - start);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Memory<T> Slice(int start, int length)
	{
		int length2 = _length;
		int num = length2 & 0x7FFFFFFF;
		if ((uint)start > (uint)num || (uint)length > (uint)(num - start))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		return new Memory<T>(_object, _index + start, length | (length2 & int.MinValue));
	}

	public void CopyTo(Memory<T> destination)
	{
		Span.CopyTo(destination.Span);
	}

	public bool TryCopyTo(Memory<T> destination)
	{
		return Span.TryCopyTo(destination.Span);
	}

	public unsafe MemoryHandle Pin()
	{
		if (_index < 0)
		{
			return ((MemoryManager<T>)_object).Pin(_index & 0x7FFFFFFF);
		}
		if (typeof(T) == typeof(char) && _object is string value)
		{
			GCHandle handle = GCHandle.Alloc(value, GCHandleType.Pinned);
			void* pointer = Unsafe.Add<T>((void*)handle.AddrOfPinnedObject(), _index);
			return new MemoryHandle(pointer, handle);
		}
		if (_object is T[] array)
		{
			if (_length < 0)
			{
				void* pointer2 = Unsafe.Add<T>(Unsafe.AsPointer(ref MemoryMarshal.GetReference<T>(array)), _index);
				return new MemoryHandle(pointer2);
			}
			GCHandle handle2 = GCHandle.Alloc(array, GCHandleType.Pinned);
			void* pointer3 = Unsafe.Add<T>((void*)handle2.AddrOfPinnedObject(), _index);
			return new MemoryHandle(pointer3, handle2);
		}
		return default(MemoryHandle);
	}

	public T[] ToArray()
	{
		return Span.ToArray();
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public override bool Equals(object obj)
	{
		if (obj is ReadOnlyMemory<T> readOnlyMemory)
		{
			return readOnlyMemory.Equals(this);
		}
		if (obj is Memory<T> other)
		{
			return Equals(other);
		}
		return false;
	}

	public bool Equals(Memory<T> other)
	{
		if (_object == other._object && _index == other._index)
		{
			return _length == other._length;
		}
		return false;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public override int GetHashCode()
	{
		if (_object == null)
		{
			return 0;
		}
		int hashCode = _object.GetHashCode();
		int index = _index;
		int hashCode2 = index.GetHashCode();
		index = _length;
		return CombineHashCodes(hashCode, hashCode2, index.GetHashCode());
	}

	private static int CombineHashCodes(int left, int right)
	{
		return ((left << 5) + left) ^ right;
	}

	private static int CombineHashCodes(int h1, int h2, int h3)
	{
		return CombineHashCodes(CombineHashCodes(h1, h2), h3);
	}
}


using System;
using System.Diagnostics;

internal sealed class MemoryDebugView<T>
{
	private readonly ReadOnlyMemory<T> _memory;

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	public T[] Items => _memory.ToArray();

	public MemoryDebugView(Memory<T> memory)
	{
		_memory = memory;
	}

	public MemoryDebugView(ReadOnlyMemory<T> memory)
	{
		_memory = memory;
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class MemoryExtensions
{
	internal static readonly IntPtr StringAdjustment = MeasureStringAdjustment();

	public static ReadOnlySpan<char> Trim(this ReadOnlySpan<char> span)
	{
		return span.TrimStart().TrimEnd();
	}

	public static ReadOnlySpan<char> TrimStart(this ReadOnlySpan<char> span)
	{
		int i;
		for (i = 0; i < span.Length && char.IsWhiteSpace(span[i]); i++)
		{
		}
		return span.Slice(i);
	}

	public static ReadOnlySpan<char> TrimEnd(this ReadOnlySpan<char> span)
	{
		int num = span.Length - 1;
		while (num >= 0 && char.IsWhiteSpace(span[num]))
		{
			num--;
		}
		return span.Slice(0, num + 1);
	}

	public static ReadOnlySpan<char> Trim(this ReadOnlySpan<char> span, char trimChar)
	{
		return span.TrimStart(trimChar).TrimEnd(trimChar);
	}

	public static ReadOnlySpan<char> TrimStart(this ReadOnlySpan<char> span, char trimChar)
	{
		int i;
		for (i = 0; i < span.Length && span[i] == trimChar; i++)
		{
		}
		return span.Slice(i);
	}

	public static ReadOnlySpan<char> TrimEnd(this ReadOnlySpan<char> span, char trimChar)
	{
		int num = span.Length - 1;
		while (num >= 0 && span[num] == trimChar)
		{
			num--;
		}
		return span.Slice(0, num + 1);
	}

	public static ReadOnlySpan<char> Trim(this ReadOnlySpan<char> span, ReadOnlySpan<char> trimChars)
	{
		return span.TrimStart(trimChars).TrimEnd(trimChars);
	}

	public static ReadOnlySpan<char> TrimStart(this ReadOnlySpan<char> span, ReadOnlySpan<char> trimChars)
	{
		if (trimChars.IsEmpty)
		{
			return span.TrimStart();
		}
		int i;
		for (i = 0; i < span.Length; i++)
		{
			int num = 0;
			while (num < trimChars.Length)
			{
				if (span[i] != trimChars[num])
				{
					num++;
					continue;
				}
				goto IL_003c;
			}
			break;
			IL_003c:;
		}
		return span.Slice(i);
	}

	public static ReadOnlySpan<char> TrimEnd(this ReadOnlySpan<char> span, ReadOnlySpan<char> trimChars)
	{
		if (trimChars.IsEmpty)
		{
			return span.TrimEnd();
		}
		int num;
		for (num = span.Length - 1; num >= 0; num--)
		{
			int num2 = 0;
			while (num2 < trimChars.Length)
			{
				if (span[num] != trimChars[num2])
				{
					num2++;
					continue;
				}
				goto IL_0044;
			}
			break;
			IL_0044:;
		}
		return span.Slice(0, num + 1);
	}

	public static bool IsWhiteSpace(this ReadOnlySpan<char> span)
	{
		for (int i = 0; i < span.Length; i++)
		{
			if (!char.IsWhiteSpace(span[i]))
			{
				return false;
			}
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value), span.Length);
		}
		if (typeof(T) == typeof(char))
		{
			return System.SpanHelpers.IndexOf(ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, char>(ref value), span.Length);
		}
		return System.SpanHelpers.IndexOf(ref MemoryMarshal.GetReference(span), value, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), value.Length);
		}
		return System.SpanHelpers.IndexOf(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(value), value.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value), span.Length);
		}
		if (typeof(T) == typeof(char))
		{
			return System.SpanHelpers.LastIndexOf(ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, char>(ref value), span.Length);
		}
		return System.SpanHelpers.LastIndexOf(ref MemoryMarshal.GetReference(span), value, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), value.Length);
		}
		return System.SpanHelpers.LastIndexOf(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(value), value.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool SequenceEqual<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>
	{
		int length = span.Length;
		if (default(T) != null && IsTypeComparableAsBytes<T>(out var size))
		{
			if (length == other.Length)
			{
				return System.SpanHelpers.SequenceEqual(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(other)), (NUInt)length * size);
			}
			return false;
		}
		if (length == other.Length)
		{
			return System.SpanHelpers.SequenceEqual(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(other), length);
		}
		return false;
	}

	public static int SequenceCompareTo<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IComparable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.SequenceCompareTo(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(other)), other.Length);
		}
		if (typeof(T) == typeof(char))
		{
			return System.SpanHelpers.SequenceCompareTo(ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(other)), other.Length);
		}
		return System.SpanHelpers.SequenceCompareTo(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(other), other.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value), span.Length);
		}
		if (typeof(T) == typeof(char))
		{
			return System.SpanHelpers.IndexOf(ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, char>(ref value), span.Length);
		}
		return System.SpanHelpers.IndexOf(ref MemoryMarshal.GetReference(span), value, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), value.Length);
		}
		return System.SpanHelpers.IndexOf(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(value), value.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value), span.Length);
		}
		if (typeof(T) == typeof(char))
		{
			return System.SpanHelpers.LastIndexOf(ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, char>(ref value), span.Length);
		}
		return System.SpanHelpers.LastIndexOf(ref MemoryMarshal.GetReference(span), value, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), value.Length);
		}
		return System.SpanHelpers.LastIndexOf(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(value), value.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), span.Length);
		}
		return System.SpanHelpers.IndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), Unsafe.As<T, byte>(ref value2), span.Length);
		}
		return System.SpanHelpers.IndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, value2, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)), values.Length);
		}
		return System.SpanHelpers.IndexOfAny(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(values), values.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), span.Length);
		}
		return System.SpanHelpers.IndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), Unsafe.As<T, byte>(ref value2), span.Length);
		}
		return System.SpanHelpers.IndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, value2, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)), values.Length);
		}
		return System.SpanHelpers.IndexOfAny(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(values), values.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), span.Length);
		}
		return System.SpanHelpers.LastIndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), Unsafe.As<T, byte>(ref value2), span.Length);
		}
		return System.SpanHelpers.LastIndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, value2, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)), values.Length);
		}
		return System.SpanHelpers.LastIndexOfAny(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(values), values.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), span.Length);
		}
		return System.SpanHelpers.LastIndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), Unsafe.As<T, byte>(ref value2), span.Length);
		}
		return System.SpanHelpers.LastIndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, value2, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)), values.Length);
		}
		return System.SpanHelpers.LastIndexOfAny(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(values), values.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool SequenceEqual<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>
	{
		int length = span.Length;
		if (default(T) != null && IsTypeComparableAsBytes<T>(out var size))
		{
			if (length == other.Length)
			{
				return System.SpanHelpers.SequenceEqual(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(other)), (NUInt)length * size);
			}
			return false;
		}
		if (length == other.Length)
		{
			return System.SpanHelpers.SequenceEqual(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(other), length);
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int SequenceCompareTo<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IComparable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.SequenceCompareTo(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(other)), other.Length);
		}
		if (typeof(T) == typeof(char))
		{
			return System.SpanHelpers.SequenceCompareTo(ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(other)), other.Length);
		}
		return System.SpanHelpers.SequenceCompareTo(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(other), other.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool StartsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		int length = value.Length;
		if (default(T) != null && IsTypeComparableAsBytes<T>(out var size))
		{
			if (length <= span.Length)
			{
				return System.SpanHelpers.SequenceEqual(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), (NUInt)length * size);
			}
			return false;
		}
		if (length <= span.Length)
		{
			return System.SpanHelpers.SequenceEqual(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(value), length);
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool StartsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		int length = value.Length;
		if (default(T) != null && IsTypeComparableAsBytes<T>(out var size))
		{
			if (length <= span.Length)
			{
				return System.SpanHelpers.SequenceEqual(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), (NUInt)length * size);
			}
			return false;
		}
		if (length <= span.Length)
		{
			return System.SpanHelpers.SequenceEqual(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(value), length);
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool EndsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		int length = span.Length;
		int length2 = value.Length;
		if (default(T) != null && IsTypeComparableAsBytes<T>(out var size))
		{
			if (length2 <= length)
			{
				return System.SpanHelpers.SequenceEqual(ref Unsafe.As<T, byte>(ref Unsafe.Add(ref MemoryMarshal.GetReference(span), length - length2)), ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), (NUInt)length2 * size);
			}
			return false;
		}
		if (length2 <= length)
		{
			return System.SpanHelpers.SequenceEqual(ref Unsafe.Add(ref MemoryMarshal.GetReference(span), length - length2), ref MemoryMarshal.GetReference(value), length2);
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool EndsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		int length = span.Length;
		int length2 = value.Length;
		if (default(T) != null && IsTypeComparableAsBytes<T>(out var size))
		{
			if (length2 <= length)
			{
				return System.SpanHelpers.SequenceEqual(ref Unsafe.As<T, byte>(ref Unsafe.Add(ref MemoryMarshal.GetReference(span), length - length2)), ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), (NUInt)length2 * size);
			}
			return false;
		}
		if (length2 <= length)
		{
			return System.SpanHelpers.SequenceEqual(ref Unsafe.Add(ref MemoryMarshal.GetReference(span), length - length2), ref MemoryMarshal.GetReference(value), length2);
		}
		return false;
	}

	public static void Reverse<T>(this Span<T> span)
	{
		ref T reference = ref MemoryMarshal.GetReference(span);
		int num = 0;
		int num2 = span.Length - 1;
		while (num < num2)
		{
			T val = Unsafe.Add(ref reference, num);
			Unsafe.Add(ref reference, num) = Unsafe.Add(ref reference, num2);
			Unsafe.Add(ref reference, num2) = val;
			num++;
			num2--;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Span<T> AsSpan<T>(this T[] array)
	{
		return new Span<T>(array);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Span<T> AsSpan<T>(this T[] array, int start, int length)
	{
		return new Span<T>(array, start, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Span<T> AsSpan<T>(this ArraySegment<T> segment)
	{
		return new Span<T>(segment.Array, segment.Offset, segment.Count);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Span<T> AsSpan<T>(this ArraySegment<T> segment, int start)
	{
		if ((uint)start > segment.Count)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		return new Span<T>(segment.Array, segment.Offset + start, segment.Count - start);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Span<T> AsSpan<T>(this ArraySegment<T> segment, int start, int length)
	{
		if ((uint)start > segment.Count)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		if ((uint)length > segment.Count - start)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.length);
		}
		return new Span<T>(segment.Array, segment.Offset + start, length);
	}

	public static Memory<T> AsMemory<T>(this T[] array)
	{
		return new Memory<T>(array);
	}

	public static Memory<T> AsMemory<T>(this T[] array, int start)
	{
		return new Memory<T>(array, start);
	}

	public static Memory<T> AsMemory<T>(this T[] array, int start, int length)
	{
		return new Memory<T>(array, start, length);
	}

	public static Memory<T> AsMemory<T>(this ArraySegment<T> segment)
	{
		return new Memory<T>(segment.Array, segment.Offset, segment.Count);
	}

	public static Memory<T> AsMemory<T>(this ArraySegment<T> segment, int start)
	{
		if ((uint)start > segment.Count)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		return new Memory<T>(segment.Array, segment.Offset + start, segment.Count - start);
	}

	public static Memory<T> AsMemory<T>(this ArraySegment<T> segment, int start, int length)
	{
		if ((uint)start > segment.Count)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		if ((uint)length > segment.Count - start)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.length);
		}
		return new Memory<T>(segment.Array, segment.Offset + start, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void CopyTo<T>(this T[] source, Span<T> destination)
	{
		new ReadOnlySpan<T>(source).CopyTo(destination);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void CopyTo<T>(this T[] source, Memory<T> destination)
	{
		source.CopyTo(destination.Span);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool Overlaps<T>(this Span<T> span, ReadOnlySpan<T> other)
	{
		return ((ReadOnlySpan<T>)span).Overlaps(other);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool Overlaps<T>(this Span<T> span, ReadOnlySpan<T> other, out int elementOffset)
	{
		return ((ReadOnlySpan<T>)span).Overlaps(other, out elementOffset);
	}

	public static bool Overlaps<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other)
	{
		if (span.IsEmpty || other.IsEmpty)
		{
			return false;
		}
		IntPtr intPtr = Unsafe.ByteOffset(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(other));
		if (Unsafe.SizeOf<IntPtr>() == 4)
		{
			if ((uint)(int)intPtr >= (uint)(span.Length * Unsafe.SizeOf<T>()))
			{
				return (uint)(int)intPtr > (uint)(-(other.Length * Unsafe.SizeOf<T>()));
			}
			return true;
		}
		if ((ulong)(long)intPtr >= (ulong)((long)span.Length * (long)Unsafe.SizeOf<T>()))
		{
			return (ulong)(long)intPtr > (ulong)(-((long)other.Length * (long)Unsafe.SizeOf<T>()));
		}
		return true;
	}

	public static bool Overlaps<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other, out int elementOffset)
	{
		if (span.IsEmpty || other.IsEmpty)
		{
			elementOffset = 0;
			return false;
		}
		IntPtr intPtr = Unsafe.ByteOffset(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(other));
		if (Unsafe.SizeOf<IntPtr>() == 4)
		{
			if ((uint)(int)intPtr < (uint)(span.Length * Unsafe.SizeOf<T>()) || (uint)(int)intPtr > (uint)(-(other.Length * Unsafe.SizeOf<T>())))
			{
				if ((int)intPtr % Unsafe.SizeOf<T>() != 0)
				{
					<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_OverlapAlignmentMismatch();
				}
				elementOffset = (int)intPtr / Unsafe.SizeOf<T>();
				return true;
			}
			elementOffset = 0;
			return false;
		}
		if ((ulong)(long)intPtr < (ulong)((long)span.Length * (long)Unsafe.SizeOf<T>()) || (ulong)(long)intPtr > (ulong)(-((long)other.Length * (long)Unsafe.SizeOf<T>())))
		{
			if ((long)intPtr % Unsafe.SizeOf<T>() != 0L)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_OverlapAlignmentMismatch();
			}
			elementOffset = (int)((long)intPtr / Unsafe.SizeOf<T>());
			return true;
		}
		elementOffset = 0;
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T>(this Span<T> span, IComparable<T> comparable)
	{
		return span.BinarySearch<T, IComparable<T>>(comparable);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T, TComparable>(this Span<T> span, TComparable comparable) where TComparable : IComparable<T>
	{
		return BinarySearch((ReadOnlySpan<T>)span, comparable);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T, TComparer>(this Span<T> span, T value, TComparer comparer) where TComparer : IComparer<T>
	{
		return ((ReadOnlySpan<T>)span).BinarySearch(value, comparer);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T>(this ReadOnlySpan<T> span, IComparable<T> comparable)
	{
		return MemoryExtensions.BinarySearch<T, IComparable<T>>(span, comparable);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T, TComparable>(this ReadOnlySpan<T> span, TComparable comparable) where TComparable : IComparable<T>
	{
		return System.SpanHelpers.BinarySearch(span, comparable);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T, TComparer>(this ReadOnlySpan<T> span, T value, TComparer comparer) where TComparer : IComparer<T>
	{
		if (comparer == null)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentNullException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.comparer);
		}
		System.SpanHelpers.ComparerComparable<T, TComparer> comparable = new System.SpanHelpers.ComparerComparable<T, TComparer>(value, comparer);
		return BinarySearch(span, comparable);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool IsTypeComparableAsBytes<T>(out NUInt size)
	{
		if (typeof(T) == typeof(byte) || typeof(T) == typeof(sbyte))
		{
			size = (NUInt)1;
			return true;
		}
		if (typeof(T) == typeof(char) || typeof(T) == typeof(short) || typeof(T) == typeof(ushort))
		{
			size = (NUInt)2;
			return true;
		}
		if (typeof(T) == typeof(int) || typeof(T) == typeof(uint))
		{
			size = (NUInt)4;
			return true;
		}
		if (typeof(T) == typeof(long) || typeof(T) == typeof(ulong))
		{
			size = (NUInt)8;
			return true;
		}
		size = default(NUInt);
		return false;
	}

	public static Span<T> AsSpan<T>(this T[] array, int start)
	{
		return Span<T>.Create(array, start);
	}

	public static bool Contains(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType)
	{
		return span.IndexOf(value, comparisonType) >= 0;
	}

	public static bool Equals(this ReadOnlySpan<char> span, ReadOnlySpan<char> other, StringComparison comparisonType)
	{
		switch (comparisonType)
		{
		case StringComparison.Ordinal:
			return span.SequenceEqual(other);
		case StringComparison.OrdinalIgnoreCase:
			if (span.Length != other.Length)
			{
				return false;
			}
			return EqualsOrdinalIgnoreCase(span, other);
		default:
			return span.ToString().Equals(other.ToString(), comparisonType);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool EqualsOrdinalIgnoreCase(ReadOnlySpan<char> span, ReadOnlySpan<char> other)
	{
		if (other.Length == 0)
		{
			return true;
		}
		return CompareToOrdinalIgnoreCase(span, other) == 0;
	}

	public static int CompareTo(this ReadOnlySpan<char> span, ReadOnlySpan<char> other, StringComparison comparisonType)
	{
		return comparisonType switch
		{
			StringComparison.Ordinal => span.SequenceCompareTo(other), 
			StringComparison.OrdinalIgnoreCase => CompareToOrdinalIgnoreCase(span, other), 
			_ => string.Compare(span.ToString(), other.ToString(), comparisonType), 
		};
	}

	private unsafe static int CompareToOrdinalIgnoreCase(ReadOnlySpan<char> strA, ReadOnlySpan<char> strB)
	{
		int num = Math.Min(strA.Length, strB.Length);
		int num2 = num;
		fixed (char* reference = &MemoryMarshal.GetReference(strA))
		{
			fixed (char* reference2 = &MemoryMarshal.GetReference(strB))
			{
				char* ptr = reference;
				char* ptr2 = reference2;
				while (num != 0 && *ptr <= '\u007f' && *ptr2 <= '\u007f')
				{
					int num3 = *ptr;
					int num4 = *ptr2;
					if (num3 == num4)
					{
						ptr++;
						ptr2++;
						num--;
						continue;
					}
					if ((uint)(num3 - 97) <= 25u)
					{
						num3 -= 32;
					}
					if ((uint)(num4 - 97) <= 25u)
					{
						num4 -= 32;
					}
					if (num3 != num4)
					{
						return num3 - num4;
					}
					ptr++;
					ptr2++;
					num--;
				}
				if (num == 0)
				{
					return strA.Length - strB.Length;
				}
				num2 -= num;
				return string.Compare(strA.Slice(num2).ToString(), strB.Slice(num2).ToString(), StringComparison.OrdinalIgnoreCase);
			}
		}
	}

	public static int IndexOf(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType)
	{
		if (comparisonType == StringComparison.Ordinal)
		{
			return span.IndexOf(value);
		}
		return span.ToString().IndexOf(value.ToString(), comparisonType);
	}

	public static int ToLower(this ReadOnlySpan<char> source, Span<char> destination, CultureInfo culture)
	{
		if (culture == null)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentNullException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.culture);
		}
		if (destination.Length < source.Length)
		{
			return -1;
		}
		string text = source.ToString();
		string text2 = text.ToLower(culture);
		AsSpan(text2).CopyTo(destination);
		return source.Length;
	}

	public static int ToLowerInvariant(this ReadOnlySpan<char> source, Span<char> destination)
	{
		return source.ToLower(destination, CultureInfo.InvariantCulture);
	}

	public static int ToUpper(this ReadOnlySpan<char> source, Span<char> destination, CultureInfo culture)
	{
		if (culture == null)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentNullException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.culture);
		}
		if (destination.Length < source.Length)
		{
			return -1;
		}
		string text = source.ToString();
		string text2 = text.ToUpper(culture);
		AsSpan(text2).CopyTo(destination);
		return source.Length;
	}

	public static int ToUpperInvariant(this ReadOnlySpan<char> source, Span<char> destination)
	{
		return source.ToUpper(destination, CultureInfo.InvariantCulture);
	}

	public static bool EndsWith(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType)
	{
		switch (comparisonType)
		{
		case StringComparison.Ordinal:
			return span.EndsWith(value);
		case StringComparison.OrdinalIgnoreCase:
			if (value.Length <= span.Length)
			{
				return EqualsOrdinalIgnoreCase(span.Slice(span.Length - value.Length), value);
			}
			return false;
		default:
		{
			string text = span.ToString();
			string value2 = value.ToString();
			return text.EndsWith(value2, comparisonType);
		}
		}
	}

	public static bool StartsWith(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType)
	{
		switch (comparisonType)
		{
		case StringComparison.Ordinal:
			return span.StartsWith(value);
		case StringComparison.OrdinalIgnoreCase:
			if (value.Length <= span.Length)
			{
				return EqualsOrdinalIgnoreCase(span.Slice(0, value.Length), value);
			}
			return false;
		default:
		{
			string text = span.ToString();
			string value2 = value.ToString();
			return text.StartsWith(value2, comparisonType);
		}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ReadOnlySpan<char> AsSpan(this string text)
	{
		if (text == null)
		{
			return default(ReadOnlySpan<char>);
		}
		return new ReadOnlySpan<char>(Unsafe.As<Pinnable<char>>(text), StringAdjustment, text.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ReadOnlySpan<char> AsSpan(this string text, int start)
	{
		if (text == null)
		{
			if (start != 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
			}
			return default(ReadOnlySpan<char>);
		}
		if ((uint)start > (uint)text.Length)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		return new ReadOnlySpan<char>(Unsafe.As<Pinnable<char>>(text), StringAdjustment + start * 2, text.Length - start);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ReadOnlySpan<char> AsSpan(this string text, int start, int length)
	{
		if (text == null)
		{
			if (start != 0 || length != 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
			}
			return default(ReadOnlySpan<char>);
		}
		if ((uint)start > (uint)text.Length || (uint)length > (uint)(text.Length - start))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		return new ReadOnlySpan<char>(Unsafe.As<Pinnable<char>>(text), StringAdjustment + start * 2, length);
	}

	public static ReadOnlyMemory<char> AsMemory(this string text)
	{
		if (text == null)
		{
			return default(ReadOnlyMemory<char>);
		}
		return new ReadOnlyMemory<char>(text, 0, text.Length);
	}

	public static ReadOnlyMemory<char> AsMemory(this string text, int start)
	{
		if (text == null)
		{
			if (start != 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
			}
			return default(ReadOnlyMemory<char>);
		}
		if ((uint)start > (uint)text.Length)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		return new ReadOnlyMemory<char>(text, start, text.Length - start);
	}

	public static ReadOnlyMemory<char> AsMemory(this string text, int start, int length)
	{
		if (text == null)
		{
			if (start != 0 || length != 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
			}
			return default(ReadOnlyMemory<char>);
		}
		if ((uint)start > (uint)text.Length || (uint)length > (uint)(text.Length - start))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		return new ReadOnlyMemory<char>(text, start, length);
	}

	private unsafe static IntPtr MeasureStringAdjustment()
	{
		string text = "a";
		fixed (char* source = text)
		{
			return Unsafe.ByteOffset(ref Unsafe.As<Pinnable<char>>(text).Data, ref Unsafe.AsRef<char>(source));
		}
	}
}


using System;
using System.Buffers;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[DebuggerDisplay("{ToString(),raw}")]
[DebuggerTypeProxy(typeof(System.MemoryDebugView<>))]
[<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
internal struct ReadOnlyMemory<T>
{
	private readonly object _object;

	private readonly int _index;

	private readonly int _length;

	internal const int RemoveFlagsBitMask = int.MaxValue;

	public static ReadOnlyMemory<T> Empty => default(ReadOnlyMemory<T>);

	public int Length => _length & 0x7FFFFFFF;

	public bool IsEmpty => (_length & 0x7FFFFFFF) == 0;

	public ReadOnlySpan<T> Span
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if (_index < 0)
			{
				return ((MemoryManager<T>)_object).GetSpan().Slice(_index & 0x7FFFFFFF, _length);
			}
			if (typeof(T) == typeof(char) && _object is string text)
			{
				return new ReadOnlySpan<T>(Unsafe.As<Pinnable<T>>(text), MemoryExtensions.StringAdjustment, text.Length).Slice(_index, _length);
			}
			if (_object != null)
			{
				return new ReadOnlySpan<T>((T[])_object, _index, _length & 0x7FFFFFFF);
			}
			return default(ReadOnlySpan<T>);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlyMemory(T[] array)
	{
		if (array == null)
		{
			this = default(ReadOnlyMemory<T>);
			return;
		}
		_object = array;
		_index = 0;
		_length = array.Length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlyMemory(T[] array, int start, int length)
	{
		if (array == null)
		{
			if (start != 0 || length != 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException();
			}
			this = default(ReadOnlyMemory<T>);
			return;
		}
		if ((uint)start > (uint)array.Length || (uint)length > (uint)(array.Length - start))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		_object = array;
		_index = start;
		_length = length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal ReadOnlyMemory(object obj, int start, int length)
	{
		_object = obj;
		_index = start;
		_length = length;
	}

	public static implicit operator ReadOnlyMemory<T>(T[] array)
	{
		return new ReadOnlyMemory<T>(array);
	}

	public static implicit operator ReadOnlyMemory<T>(ArraySegment<T> segment)
	{
		return new ReadOnlyMemory<T>(segment.Array, segment.Offset, segment.Count);
	}

	public override string ToString()
	{
		if (typeof(T) == typeof(char))
		{
			if (!(_object is string text))
			{
				return Span.ToString();
			}
			return text.Substring(_index, _length & 0x7FFFFFFF);
		}
		return $"System.ReadOnlyMemory<{typeof(T).Name}>[{_length & 0x7FFFFFFF}]";
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlyMemory<T> Slice(int start)
	{
		int length = _length;
		int num = length & 0x7FFFFFFF;
		if ((uint)start > (uint)num)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		return new ReadOnlyMemory<T>(_object, _index + start, length - start);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlyMemory<T> Slice(int start, int length)
	{
		int length2 = _length;
		int num = _length & 0x7FFFFFFF;
		if ((uint)start > (uint)num || (uint)length > (uint)(num - start))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		return new ReadOnlyMemory<T>(_object, _index + start, length | (length2 & int.MinValue));
	}

	public void CopyTo(Memory<T> destination)
	{
		Span.CopyTo(destination.Span);
	}

	public bool TryCopyTo(Memory<T> destination)
	{
		return Span.TryCopyTo(destination.Span);
	}

	public unsafe MemoryHandle Pin()
	{
		if (_index < 0)
		{
			return ((MemoryManager<T>)_object).Pin(_index & 0x7FFFFFFF);
		}
		if (typeof(T) == typeof(char) && _object is string value)
		{
			GCHandle handle = GCHandle.Alloc(value, GCHandleType.Pinned);
			void* pointer = Unsafe.Add<T>((void*)handle.AddrOfPinnedObject(), _index);
			return new MemoryHandle(pointer, handle);
		}
		if (_object is T[] array)
		{
			if (_length < 0)
			{
				void* pointer2 = Unsafe.Add<T>(Unsafe.AsPointer(ref MemoryMarshal.GetReference<T>(array)), _index);
				return new MemoryHandle(pointer2);
			}
			GCHandle handle2 = GCHandle.Alloc(array, GCHandleType.Pinned);
			void* pointer3 = Unsafe.Add<T>((void*)handle2.AddrOfPinnedObject(), _index);
			return new MemoryHandle(pointer3, handle2);
		}
		return default(MemoryHandle);
	}

	public T[] ToArray()
	{
		return Span.ToArray();
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public override bool Equals(object obj)
	{
		if (obj is ReadOnlyMemory<T> other)
		{
			return Equals(other);
		}
		if (obj is Memory<T> memory)
		{
			return Equals(memory);
		}
		return false;
	}

	public bool Equals(ReadOnlyMemory<T> other)
	{
		if (_object == other._object && _index == other._index)
		{
			return _length == other._length;
		}
		return false;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public override int GetHashCode()
	{
		if (_object == null)
		{
			return 0;
		}
		int hashCode = _object.GetHashCode();
		int index = _index;
		int hashCode2 = index.GetHashCode();
		index = _length;
		return CombineHashCodes(hashCode, hashCode2, index.GetHashCode());
	}

	private static int CombineHashCodes(int left, int right)
	{
		return ((left << 5) + left) ^ right;
	}

	private static int CombineHashCodes(int h1, int h2, int h3)
	{
		return CombineHashCodes(CombineHashCodes(h1, h2), h3);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal object GetObjectStartLength(out int start, out int length)
	{
		start = _index;
		length = _length;
		return _object;
	}
}


using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.CompilerServices;

[<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
[DebuggerDisplay("{ToString(),raw}")]
[DebuggerTypeProxy(typeof(System.SpanDebugView<>))]
[<439493f3-a3f7-4dc9-b609-17ad8331cd81>IsByRefLike]
[DebuggerTypeProxy(typeof(System.SpanDebugView<>))]
internal struct ReadOnlySpan<T>
{
	[<439493f3-a3f7-4dc9-b609-17ad8331cd81>IsByRefLike]
	public struct Enumerator
	{
		private readonly ReadOnlySpan<T> _span;

		private int _index;

		[<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
		public ref T Current
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			[return: <fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
			get
			{
				return ref _span[_index];
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal Enumerator(ReadOnlySpan<T> span)
		{
			_span = span;
			_index = -1;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public bool MoveNext()
		{
			int num = _index + 1;
			if (num < _span.Length)
			{
				_index = num;
				return true;
			}
			return false;
		}
	}

	private readonly Pinnable<T> _pinnable;

	private readonly IntPtr _byteOffset;

	private readonly int _length;

	public int Length => _length;

	public bool IsEmpty => _length == 0;

	public static ReadOnlySpan<T> Empty => default(ReadOnlySpan<T>);

	[<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
	public unsafe ref T this[int index]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[return: <fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
		get
		{
			if ((uint)index >= (uint)_length)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowIndexOutOfRangeException();
			}
			if (_pinnable == null)
			{
				IntPtr byteOffset = _byteOffset;
				return ref Unsafe.Add(ref Unsafe.AsRef<T>(byteOffset.ToPointer()), index);
			}
			return ref Unsafe.Add(ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset), index);
		}
	}

	internal Pinnable<T> Pinnable => _pinnable;

	internal IntPtr ByteOffset => _byteOffset;

	public static bool operator !=(ReadOnlySpan<T> left, ReadOnlySpan<T> right)
	{
		return !(left == right);
	}

	[Obsolete("Equals() on ReadOnlySpan will always throw an exception. Use == instead.")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public override bool Equals(object obj)
	{
		throw new NotSupportedException(<c1e4ce84-b725-4d32-90ca-a752f1fa7530>SR.NotSupported_CannotCallEqualsOnSpan);
	}

	[Obsolete("GetHashCode() on ReadOnlySpan will always throw an exception.")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public override int GetHashCode()
	{
		throw new NotSupportedException(<c1e4ce84-b725-4d32-90ca-a752f1fa7530>SR.NotSupported_CannotCallGetHashCodeOnSpan);
	}

	public static implicit operator ReadOnlySpan<T>(T[] array)
	{
		return new ReadOnlySpan<T>(array);
	}

	public static implicit operator ReadOnlySpan<T>(ArraySegment<T> segment)
	{
		return new ReadOnlySpan<T>(segment.Array, segment.Offset, segment.Count);
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(this);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlySpan(T[] array)
	{
		if (array == null)
		{
			this = default(ReadOnlySpan<T>);
			return;
		}
		_length = array.Length;
		_pinnable = Unsafe.As<Pinnable<T>>(array);
		_byteOffset = System.SpanHelpers.PerTypeValues<T>.ArrayAdjustment;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlySpan(T[] array, int start, int length)
	{
		if (array == null)
		{
			if (start != 0 || length != 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
			}
			this = default(ReadOnlySpan<T>);
			return;
		}
		if ((uint)start > (uint)array.Length || (uint)length > (uint)(array.Length - start))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		_length = length;
		_pinnable = Unsafe.As<Pinnable<T>>(array);
		_byteOffset = System.SpanHelpers.PerTypeValues<T>.ArrayAdjustment.Add<T>(start);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public unsafe ReadOnlySpan(void* pointer, int length)
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		if (length < 0)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		_length = length;
		_pinnable = null;
		_byteOffset = new IntPtr(pointer);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal ReadOnlySpan(Pinnable<T> pinnable, IntPtr byteOffset, int length)
	{
		_length = length;
		_pinnable = pinnable;
		_byteOffset = byteOffset;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[return: <fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
	public unsafe ref T GetPinnableReference()
	{
		if (_length != 0)
		{
			if (_pinnable == null)
			{
				IntPtr byteOffset = _byteOffset;
				return ref Unsafe.AsRef<T>(byteOffset.ToPointer());
			}
			return ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset);
		}
		return ref Unsafe.AsRef<T>(null);
	}

	public void CopyTo(Span<T> destination)
	{
		if (!TryCopyTo(destination))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_DestinationTooShort();
		}
	}

	public bool TryCopyTo(Span<T> destination)
	{
		int length = _length;
		int length2 = destination.Length;
		if (length == 0)
		{
			return true;
		}
		if ((uint)length > (uint)length2)
		{
			return false;
		}
		ref T src = ref DangerousGetPinnableReference();
		System.SpanHelpers.CopyTo(ref destination.DangerousGetPinnableReference(), length2, ref src, length);
		return true;
	}

	public static bool operator ==(ReadOnlySpan<T> left, ReadOnlySpan<T> right)
	{
		if (left._length == right._length)
		{
			return Unsafe.AreSame(ref left.DangerousGetPinnableReference(), ref right.DangerousGetPinnableReference());
		}
		return false;
	}

	public unsafe override string ToString()
	{
		if (typeof(T) == typeof(char))
		{
			if (_byteOffset == MemoryExtensions.StringAdjustment)
			{
				object obj = Unsafe.As<object>(_pinnable);
				if (obj is string text && _length == text.Length)
				{
					return text;
				}
			}
			fixed (char* value = &Unsafe.As<T, char>(ref DangerousGetPinnableReference()))
			{
				return new string(value, 0, _length);
			}
		}
		return $"System.ReadOnlySpan<{typeof(T).Name}>[{_length}]";
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlySpan<T> Slice(int start)
	{
		if ((uint)start > (uint)_length)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		IntPtr byteOffset = _byteOffset.Add<T>(start);
		int length = _length - start;
		return new ReadOnlySpan<T>(_pinnable, byteOffset, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlySpan<T> Slice(int start, int length)
	{
		if ((uint)start > (uint)_length || (uint)length > (uint)(_length - start))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		IntPtr byteOffset = _byteOffset.Add<T>(start);
		return new ReadOnlySpan<T>(_pinnable, byteOffset, length);
	}

	public T[] ToArray()
	{
		if (_length == 0)
		{
			return System.SpanHelpers.PerTypeValues<T>.EmptyArray;
		}
		T[] array = new T[_length];
		CopyTo(array);
		return array;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	internal unsafe ref T DangerousGetPinnableReference()
	{
		if (_pinnable == null)
		{
			IntPtr byteOffset = _byteOffset;
			return ref Unsafe.AsRef<T>(byteOffset.ToPointer());
		}
		return ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset);
	}
}


using System.Runtime.CompilerServices;

[<439493f3-a3f7-4dc9-b609-17ad8331cd81>IsByRefLike]
public struct Enumerator
{
	private readonly ReadOnlySpan<T> _span;

	private int _index;

	[<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
	public ref T Current
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[return: <fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
		get
		{
			return ref _span[_index];
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Enumerator(ReadOnlySpan<T> span)
	{
		_span = span;
		_index = -1;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool MoveNext()
	{
		int num = _index + 1;
		if (num < _span.Length)
		{
			_index = num;
			return true;
		}
		return false;
	}
}


using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.CompilerServices;

[DebuggerDisplay("{ToString(),raw}")]
[<439493f3-a3f7-4dc9-b609-17ad8331cd81>IsByRefLike]
[DebuggerTypeProxy(typeof(System.SpanDebugView<>))]
[<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
[DebuggerTypeProxy(typeof(System.SpanDebugView<>))]
internal struct Span<T>
{
	[<439493f3-a3f7-4dc9-b609-17ad8331cd81>IsByRefLike]
	public struct Enumerator
	{
		private readonly Span<T> _span;

		private int _index;

		public ref T Current
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref _span[_index];
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal Enumerator(Span<T> span)
		{
			_span = span;
			_index = -1;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public bool MoveNext()
		{
			int num = _index + 1;
			if (num < _span.Length)
			{
				_index = num;
				return true;
			}
			return false;
		}
	}

	private readonly Pinnable<T> _pinnable;

	private readonly IntPtr _byteOffset;

	private readonly int _length;

	public int Length => _length;

	public bool IsEmpty => _length == 0;

	public static Span<T> Empty => default(Span<T>);

	public unsafe ref T this[int index]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if ((uint)index >= (uint)_length)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowIndexOutOfRangeException();
			}
			if (_pinnable == null)
			{
				IntPtr byteOffset = _byteOffset;
				return ref Unsafe.Add(ref Unsafe.AsRef<T>(byteOffset.ToPointer()), index);
			}
			return ref Unsafe.Add(ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset), index);
		}
	}

	internal Pinnable<T> Pinnable => _pinnable;

	internal IntPtr ByteOffset => _byteOffset;

	public static bool operator !=(Span<T> left, Span<T> right)
	{
		return !(left == right);
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("Equals() on Span will always throw an exception. Use == instead.")]
	public override bool Equals(object obj)
	{
		throw new NotSupportedException(<c1e4ce84-b725-4d32-90ca-a752f1fa7530>SR.NotSupported_CannotCallEqualsOnSpan);
	}

	[Obsolete("GetHashCode() on Span will always throw an exception.")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public override int GetHashCode()
	{
		throw new NotSupportedException(<c1e4ce84-b725-4d32-90ca-a752f1fa7530>SR.NotSupported_CannotCallGetHashCodeOnSpan);
	}

	public static implicit operator Span<T>(T[] array)
	{
		return new Span<T>(array);
	}

	public static implicit operator Span<T>(ArraySegment<T> segment)
	{
		return new Span<T>(segment.Array, segment.Offset, segment.Count);
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(this);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Span(T[] array)
	{
		if (array == null)
		{
			this = default(Span<T>);
			return;
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArrayTypeMismatchException();
		}
		_length = array.Length;
		_pinnable = Unsafe.As<Pinnable<T>>(array);
		_byteOffset = System.SpanHelpers.PerTypeValues<T>.ArrayAdjustment;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static Span<T> Create(T[] array, int start)
	{
		if (array == null)
		{
			if (start != 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
			}
			return default(Span<T>);
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArrayTypeMismatchException();
		}
		if ((uint)start > (uint)array.Length)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		IntPtr byteOffset = System.SpanHelpers.PerTypeValues<T>.ArrayAdjustment.Add<T>(start);
		int length = array.Length - start;
		return new Span<T>(Unsafe.As<Pinnable<T>>(array), byteOffset, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Span(T[] array, int start, int length)
	{
		if (array == null)
		{
			if (start != 0 || length != 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
			}
			this = default(Span<T>);
			return;
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArrayTypeMismatchException();
		}
		if ((uint)start > (uint)array.Length || (uint)length > (uint)(array.Length - start))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		_length = length;
		_pinnable = Unsafe.As<Pinnable<T>>(array);
		_byteOffset = System.SpanHelpers.PerTypeValues<T>.ArrayAdjustment.Add<T>(start);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public unsafe Span(void* pointer, int length)
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		if (length < 0)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		_length = length;
		_pinnable = null;
		_byteOffset = new IntPtr(pointer);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Span(Pinnable<T> pinnable, IntPtr byteOffset, int length)
	{
		_length = length;
		_pinnable = pinnable;
		_byteOffset = byteOffset;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public unsafe ref T GetPinnableReference()
	{
		if (_length != 0)
		{
			if (_pinnable == null)
			{
				IntPtr byteOffset = _byteOffset;
				return ref Unsafe.AsRef<T>(byteOffset.ToPointer());
			}
			return ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset);
		}
		return ref Unsafe.AsRef<T>(null);
	}

	public unsafe void Clear()
	{
		int length = _length;
		if (length == 0)
		{
			return;
		}
		UIntPtr byteLength = (UIntPtr)(ulong)((uint)length * Unsafe.SizeOf<T>());
		if ((Unsafe.SizeOf<T>() & (sizeof(IntPtr) - 1)) != 0)
		{
			if (_pinnable == null)
			{
				IntPtr byteOffset = _byteOffset;
				byte* ptr = (byte*)byteOffset.ToPointer();
				System.SpanHelpers.ClearLessThanPointerSized(ptr, byteLength);
			}
			else
			{
				System.SpanHelpers.ClearLessThanPointerSized(ref Unsafe.As<T, byte>(ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset)), byteLength);
			}
		}
		else if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			UIntPtr pointerSizeLength = (UIntPtr)(ulong)(length * Unsafe.SizeOf<T>() / sizeof(IntPtr));
			System.SpanHelpers.ClearPointerSizedWithReferences(ref Unsafe.As<T, IntPtr>(ref DangerousGetPinnableReference()), pointerSizeLength);
		}
		else
		{
			System.SpanHelpers.ClearPointerSizedWithoutReferences(ref Unsafe.As<T, byte>(ref DangerousGetPinnableReference()), byteLength);
		}
	}

	public unsafe void Fill(T value)
	{
		int length = _length;
		if (length == 0)
		{
			return;
		}
		if (Unsafe.SizeOf<T>() == 1)
		{
			byte value2 = Unsafe.As<T, byte>(ref value);
			if (_pinnable == null)
			{
				IntPtr byteOffset = _byteOffset;
				Unsafe.InitBlockUnaligned(byteOffset.ToPointer(), value2, (uint)length);
			}
			else
			{
				Unsafe.InitBlockUnaligned(ref Unsafe.As<T, byte>(ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset)), value2, (uint)length);
			}
			return;
		}
		ref T source = ref DangerousGetPinnableReference();
		int i;
		for (i = 0; i < (length & -8); i += 8)
		{
			Unsafe.Add(ref source, i) = value;
			Unsafe.Add(ref source, i + 1) = value;
			Unsafe.Add(ref source, i + 2) = value;
			Unsafe.Add(ref source, i + 3) = value;
			Unsafe.Add(ref source, i + 4) = value;
			Unsafe.Add(ref source, i + 5) = value;
			Unsafe.Add(ref source, i + 6) = value;
			Unsafe.Add(ref source, i + 7) = value;
		}
		if (i < (length & -4))
		{
			Unsafe.Add(ref source, i) = value;
			Unsafe.Add(ref source, i + 1) = value;
			Unsafe.Add(ref source, i + 2) = value;
			Unsafe.Add(ref source, i + 3) = value;
			i += 4;
		}
		for (; i < length; i++)
		{
			Unsafe.Add(ref source, i) = value;
		}
	}

	public void CopyTo(Span<T> destination)
	{
		if (!TryCopyTo(destination))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_DestinationTooShort();
		}
	}

	public bool TryCopyTo(Span<T> destination)
	{
		int length = _length;
		int length2 = destination._length;
		if (length == 0)
		{
			return true;
		}
		if ((uint)length > (uint)length2)
		{
			return false;
		}
		ref T src = ref DangerousGetPinnableReference();
		System.SpanHelpers.CopyTo(ref destination.DangerousGetPinnableReference(), length2, ref src, length);
		return true;
	}

	public static bool operator ==(Span<T> left, Span<T> right)
	{
		if (left._length == right._length)
		{
			return Unsafe.AreSame(ref left.DangerousGetPinnableReference(), ref right.DangerousGetPinnableReference());
		}
		return false;
	}

	public static implicit operator ReadOnlySpan<T>(Span<T> span)
	{
		return new ReadOnlySpan<T>(span._pinnable, span._byteOffset, span._length);
	}

	public unsafe override string ToString()
	{
		if (typeof(T) == typeof(char))
		{
			fixed (char* value = &Unsafe.As<T, char>(ref DangerousGetPinnableReference()))
			{
				return new string(value, 0, _length);
			}
		}
		return $"System.Span<{typeof(T).Name}>[{_length}]";
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Span<T> Slice(int start)
	{
		if ((uint)start > (uint)_length)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		IntPtr byteOffset = _byteOffset.Add<T>(start);
		int length = _length - start;
		return new Span<T>(_pinnable, byteOffset, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Span<T> Slice(int start, int length)
	{
		if ((uint)start > (uint)_length || (uint)length > (uint)(_length - start))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		}
		IntPtr byteOffset = _byteOffset.Add<T>(start);
		return new Span<T>(_pinnable, byteOffset, length);
	}

	public T[] ToArray()
	{
		if (_length == 0)
		{
			return System.SpanHelpers.PerTypeValues<T>.EmptyArray;
		}
		T[] array = new T[_length];
		CopyTo(array);
		return array;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	internal unsafe ref T DangerousGetPinnableReference()
	{
		if (_pinnable == null)
		{
			IntPtr byteOffset = _byteOffset;
			return ref Unsafe.AsRef<T>(byteOffset.ToPointer());
		}
		return ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset);
	}
}


using System.Runtime.CompilerServices;

[<439493f3-a3f7-4dc9-b609-17ad8331cd81>IsByRefLike]
public struct Enumerator
{
	private readonly Span<T> _span;

	private int _index;

	public ref T Current
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return ref _span[_index];
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Enumerator(Span<T> span)
	{
		_span = span;
		_index = -1;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool MoveNext()
	{
		int num = _index + 1;
		if (num < _span.Length)
		{
			_index = num;
			return true;
		}
		return false;
	}
}


using System;
using System.Diagnostics;

internal sealed class SpanDebugView<T>
{
	private readonly T[] _array;

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	public T[] Items => _array;

	public SpanDebugView(Span<T> span)
	{
		_array = span.ToArray();
	}

	public SpanDebugView(ReadOnlySpan<T> span)
	{
		_array = span.ToArray();
	}
}


using System;
using System.Collections.Generic;
using System.Numerics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class SpanHelpers
{
	internal struct ComparerComparable<T, TComparer> : IComparable<T> where TComparer : IComparer<T>
	{
		private readonly T _value;

		private readonly TComparer _comparer;

		public ComparerComparable(T value, TComparer comparer)
		{
			_value = value;
			_comparer = comparer;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public int CompareTo(T other)
		{
			return _comparer.Compare(_value, other);
		}
	}

	[StructLayout(LayoutKind.Sequential, Size = 64)]
	private struct Reg64
	{
	}

	[StructLayout(LayoutKind.Sequential, Size = 32)]
	private struct Reg32
	{
	}

	[StructLayout(LayoutKind.Sequential, Size = 16)]
	private struct Reg16
	{
	}

	public static class PerTypeValues<T>
	{
		public static readonly bool IsReferenceOrContainsReferences = IsReferenceOrContainsReferencesCore(typeof(T));

		public static readonly T[] EmptyArray = new T[0];

		public static readonly IntPtr ArrayAdjustment = MeasureArrayAdjustment();

		private static IntPtr MeasureArrayAdjustment()
		{
			T[] array = new T[1];
			return Unsafe.ByteOffset(ref Unsafe.As<Pinnable<T>>(array).Data, ref array[0]);
		}
	}

	private const ulong XorPowerOfTwoToHighByte = 283686952306184uL;

	private const ulong XorPowerOfTwoToHighChar = 4295098372uL;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T, TComparable>(this ReadOnlySpan<T> span, TComparable comparable) where TComparable : IComparable<T>
	{
		if (comparable == null)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentNullException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.comparable);
		}
		return BinarySearch(ref MemoryMarshal.GetReference(span), span.Length, comparable);
	}

	public static int BinarySearch<T, TComparable>(ref T spanStart, int length, TComparable comparable) where TComparable : IComparable<T>
	{
		int num = 0;
		int num2 = length - 1;
		while (num <= num2)
		{
			int num3 = num2 + num >>> 1;
			int num4 = comparable.CompareTo(Unsafe.Add(ref spanStart, num3));
			if (num4 == 0)
			{
				return num3;
			}
			if (num4 > 0)
			{
				num = num3 + 1;
			}
			else
			{
				num2 = num3 - 1;
			}
		}
		return ~num;
	}

	public static int IndexOf(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength)
	{
		if (valueLength == 0)
		{
			return 0;
		}
		byte value2 = value;
		ref byte second = ref Unsafe.Add(ref value, 1);
		int num = valueLength - 1;
		int num2 = 0;
		while (true)
		{
			int num3 = searchSpaceLength - num2 - num;
			if (num3 <= 0)
			{
				break;
			}
			int num4 = IndexOf(ref Unsafe.Add(ref searchSpace, num2), value2, num3);
			if (num4 == -1)
			{
				break;
			}
			num2 += num4;
			if (SequenceEqual(ref Unsafe.Add(ref searchSpace, num2 + 1), ref second, num))
			{
				return num2;
			}
			num2++;
		}
		return -1;
	}

	public static int IndexOfAny(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength)
	{
		if (valueLength == 0)
		{
			return 0;
		}
		int num = -1;
		for (int i = 0; i < valueLength; i++)
		{
			int num2 = IndexOf(ref searchSpace, Unsafe.Add(ref value, i), searchSpaceLength);
			if ((uint)num2 < (uint)num)
			{
				num = num2;
				searchSpaceLength = num2;
				if (num == 0)
				{
					break;
				}
			}
		}
		return num;
	}

	public static int LastIndexOfAny(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength)
	{
		if (valueLength == 0)
		{
			return 0;
		}
		int num = -1;
		for (int i = 0; i < valueLength; i++)
		{
			int num2 = LastIndexOf(ref searchSpace, Unsafe.Add(ref value, i), searchSpaceLength);
			if (num2 > num)
			{
				num = num2;
			}
		}
		return num;
	}

	public unsafe static int IndexOf(ref byte searchSpace, byte value, int length)
	{
		IntPtr intPtr = (IntPtr)0;
		IntPtr intPtr2 = (IntPtr)length;
		if (Vector.IsHardwareAccelerated && length >= Vector<byte>.Count * 2)
		{
			int num = (int)Unsafe.AsPointer(ref searchSpace) & (Vector<byte>.Count - 1);
			intPtr2 = (IntPtr)((Vector<byte>.Count - num) & (Vector<byte>.Count - 1));
		}
		while (true)
		{
			if ((nuint)(void*)intPtr2 >= (nuint)8u)
			{
				intPtr2 -= 8;
				if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr))
				{
					goto IL_0242;
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr + 1))
				{
					goto IL_024a;
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr + 2))
				{
					goto IL_0258;
				}
				if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr + 3))
				{
					if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr + 4))
					{
						if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr + 5))
						{
							if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr + 6))
							{
								if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr + 7))
								{
									break;
								}
								intPtr += 8;
								continue;
							}
							return (int)(void*)(intPtr + 6);
						}
						return (int)(void*)(intPtr + 5);
					}
					return (int)(void*)(intPtr + 4);
				}
				goto IL_0266;
			}
			if ((nuint)(void*)intPtr2 >= (nuint)4u)
			{
				intPtr2 -= 4;
				if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr))
				{
					goto IL_0242;
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr + 1))
				{
					goto IL_024a;
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr + 2))
				{
					goto IL_0258;
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr + 3))
				{
					goto IL_0266;
				}
				intPtr += 4;
			}
			while ((void*)intPtr2 != null)
			{
				intPtr2 -= 1;
				if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr))
				{
					intPtr += 1;
					continue;
				}
				goto IL_0242;
			}
			if (Vector.IsHardwareAccelerated && (int)(void*)intPtr < length)
			{
				intPtr2 = (IntPtr)((length - (int)(void*)intPtr) & ~(Vector<byte>.Count - 1));
				Vector<byte> vector = GetVector(value);
				for (; (void*)intPtr2 > (void*)intPtr; intPtr += Vector<byte>.Count)
				{
					Vector<byte> vector2 = Vector.Equals(vector, Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref searchSpace, intPtr)));
					if (!Vector<byte>.Zero.Equals(vector2))
					{
						return (int)(void*)intPtr + LocateFirstFoundByte(vector2);
					}
				}
				if ((int)(void*)intPtr < length)
				{
					intPtr2 = (IntPtr)(length - (int)(void*)intPtr);
					continue;
				}
			}
			return -1;
			IL_0266:
			return (int)(void*)(intPtr + 3);
			IL_0242:
			return (int)(void*)intPtr;
			IL_0258:
			return (int)(void*)(intPtr + 2);
			IL_024a:
			return (int)(void*)(intPtr + 1);
		}
		return (int)(void*)(intPtr + 7);
	}

	public static int LastIndexOf(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength)
	{
		if (valueLength == 0)
		{
			return 0;
		}
		byte value2 = value;
		ref byte second = ref Unsafe.Add(ref value, 1);
		int num = valueLength - 1;
		int num2 = 0;
		while (true)
		{
			int num3 = searchSpaceLength - num2 - num;
			if (num3 <= 0)
			{
				break;
			}
			int num4 = LastIndexOf(ref searchSpace, value2, num3);
			if (num4 == -1)
			{
				break;
			}
			if (SequenceEqual(ref Unsafe.Add(ref searchSpace, num4 + 1), ref second, num))
			{
				return num4;
			}
			num2 += num3 - num4;
		}
		return -1;
	}

	public unsafe static int LastIndexOf(ref byte searchSpace, byte value, int length)
	{
		IntPtr intPtr = (IntPtr)length;
		IntPtr intPtr2 = (IntPtr)length;
		if (Vector.IsHardwareAccelerated && length >= Vector<byte>.Count * 2)
		{
			int num = (int)Unsafe.AsPointer(ref searchSpace) & (Vector<byte>.Count - 1);
			intPtr2 = (IntPtr)(((length & (Vector<byte>.Count - 1)) + num) & (Vector<byte>.Count - 1));
		}
		while (true)
		{
			if ((nuint)(void*)intPtr2 >= (nuint)8u)
			{
				intPtr2 -= 8;
				intPtr -= 8;
				if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr + 7))
				{
					break;
				}
				if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr + 6))
				{
					if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr + 5))
					{
						if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr + 4))
						{
							if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr + 3))
							{
								if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr + 2))
								{
									if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr + 1))
									{
										if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr))
										{
											continue;
										}
										goto IL_0254;
									}
									goto IL_025c;
								}
								goto IL_026a;
							}
							goto IL_0278;
						}
						return (int)(void*)(intPtr + 4);
					}
					return (int)(void*)(intPtr + 5);
				}
				return (int)(void*)(intPtr + 6);
			}
			if ((nuint)(void*)intPtr2 >= (nuint)4u)
			{
				intPtr2 -= 4;
				intPtr -= 4;
				if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr + 3))
				{
					goto IL_0278;
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr + 2))
				{
					goto IL_026a;
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr + 1))
				{
					goto IL_025c;
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, intPtr))
				{
					goto IL_0254;
				}
			}
			while ((void*)intPtr2 != null)
			{
				intPtr2 -= 1;
				intPtr -= 1;
				if (value != Unsafe.AddByteOffset(ref searchSpace, intPtr))
				{
					continue;
				}
				goto IL_0254;
			}
			if (Vector.IsHardwareAccelerated && (void*)intPtr != null)
			{
				intPtr2 = (IntPtr)((int)(void*)intPtr & ~(Vector<byte>.Count - 1));
				Vector<byte> vector = GetVector(value);
				for (; (nuint)(void*)intPtr2 > (nuint)(Vector<byte>.Count - 1); intPtr2 -= Vector<byte>.Count)
				{
					Vector<byte> vector2 = Vector.Equals(vector, Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref searchSpace, intPtr - Vector<byte>.Count)));
					if (Vector<byte>.Zero.Equals(vector2))
					{
						intPtr -= Vector<byte>.Count;
						continue;
					}
					return (int)intPtr - Vector<byte>.Count + LocateLastFoundByte(vector2);
				}
				if ((void*)intPtr != null)
				{
					intPtr2 = intPtr;
					continue;
				}
			}
			return -1;
			IL_0254:
			return (int)(void*)intPtr;
			IL_026a:
			return (int)(void*)(intPtr + 2);
			IL_0278:
			return (int)(void*)(intPtr + 3);
			IL_025c:
			return (int)(void*)(intPtr + 1);
		}
		return (int)(void*)(intPtr + 7);
	}

	public unsafe static int IndexOfAny(ref byte searchSpace, byte value0, byte value1, int length)
	{
		IntPtr intPtr = (IntPtr)0;
		IntPtr intPtr2 = (IntPtr)length;
		if (Vector.IsHardwareAccelerated && length >= Vector<byte>.Count * 2)
		{
			int num = (int)Unsafe.AsPointer(ref searchSpace) & (Vector<byte>.Count - 1);
			intPtr2 = (IntPtr)((Vector<byte>.Count - num) & (Vector<byte>.Count - 1));
		}
		while (true)
		{
			if ((nuint)(void*)intPtr2 >= (nuint)8u)
			{
				intPtr2 -= 8;
				uint num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr);
				if (value0 == num2 || value1 == num2)
				{
					goto IL_02ff;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 1);
				if (value0 == num2 || value1 == num2)
				{
					goto IL_0307;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 2);
				if (value0 == num2 || value1 == num2)
				{
					goto IL_0315;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 3);
				if (value0 != num2 && value1 != num2)
				{
					num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 4);
					if (value0 != num2 && value1 != num2)
					{
						num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 5);
						if (value0 != num2 && value1 != num2)
						{
							num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 6);
							if (value0 != num2 && value1 != num2)
							{
								num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 7);
								if (value0 == num2 || value1 == num2)
								{
									break;
								}
								intPtr += 8;
								continue;
							}
							return (int)(void*)(intPtr + 6);
						}
						return (int)(void*)(intPtr + 5);
					}
					return (int)(void*)(intPtr + 4);
				}
				goto IL_0323;
			}
			if ((nuint)(void*)intPtr2 >= (nuint)4u)
			{
				intPtr2 -= 4;
				uint num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr);
				if (value0 == num2 || value1 == num2)
				{
					goto IL_02ff;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 1);
				if (value0 == num2 || value1 == num2)
				{
					goto IL_0307;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 2);
				if (value0 == num2 || value1 == num2)
				{
					goto IL_0315;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 3);
				if (value0 == num2 || value1 == num2)
				{
					goto IL_0323;
				}
				intPtr += 4;
			}
			while ((void*)intPtr2 != null)
			{
				intPtr2 -= 1;
				uint num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr);
				if (value0 != num2 && value1 != num2)
				{
					intPtr += 1;
					continue;
				}
				goto IL_02ff;
			}
			if (Vector.IsHardwareAccelerated && (int)(void*)intPtr < length)
			{
				intPtr2 = (IntPtr)((length - (int)(void*)intPtr) & ~(Vector<byte>.Count - 1));
				Vector<byte> vector = GetVector(value0);
				Vector<byte> vector2 = GetVector(value1);
				for (; (void*)intPtr2 > (void*)intPtr; intPtr += Vector<byte>.Count)
				{
					Vector<byte> left = Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref searchSpace, intPtr));
					Vector<byte> vector3 = Vector.BitwiseOr(Vector.Equals(left, vector), Vector.Equals(left, vector2));
					if (!Vector<byte>.Zero.Equals(vector3))
					{
						return (int)(void*)intPtr + LocateFirstFoundByte(vector3);
					}
				}
				if ((int)(void*)intPtr < length)
				{
					intPtr2 = (IntPtr)(length - (int)(void*)intPtr);
					continue;
				}
			}
			return -1;
			IL_02ff:
			return (int)(void*)intPtr;
			IL_0315:
			return (int)(void*)(intPtr + 2);
			IL_0307:
			return (int)(void*)(intPtr + 1);
			IL_0323:
			return (int)(void*)(intPtr + 3);
		}
		return (int)(void*)(intPtr + 7);
	}

	public unsafe static int IndexOfAny(ref byte searchSpace, byte value0, byte value1, byte value2, int length)
	{
		IntPtr intPtr = (IntPtr)0;
		IntPtr intPtr2 = (IntPtr)length;
		if (Vector.IsHardwareAccelerated && length >= Vector<byte>.Count * 2)
		{
			int num = (int)Unsafe.AsPointer(ref searchSpace) & (Vector<byte>.Count - 1);
			intPtr2 = (IntPtr)((Vector<byte>.Count - num) & (Vector<byte>.Count - 1));
		}
		while (true)
		{
			if ((nuint)(void*)intPtr2 >= (nuint)8u)
			{
				intPtr2 -= 8;
				uint num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr);
				if (value0 == num2 || value1 == num2 || value2 == num2)
				{
					goto IL_0393;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 1);
				if (value0 == num2 || value1 == num2 || value2 == num2)
				{
					goto IL_039b;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 2);
				if (value0 == num2 || value1 == num2 || value2 == num2)
				{
					goto IL_03a9;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 3);
				if (value0 != num2 && value1 != num2 && value2 != num2)
				{
					num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 4);
					if (value0 != num2 && value1 != num2 && value2 != num2)
					{
						num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 5);
						if (value0 != num2 && value1 != num2 && value2 != num2)
						{
							num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 6);
							if (value0 != num2 && value1 != num2 && value2 != num2)
							{
								num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 7);
								if (value0 == num2 || value1 == num2 || value2 == num2)
								{
									break;
								}
								intPtr += 8;
								continue;
							}
							return (int)(void*)(intPtr + 6);
						}
						return (int)(void*)(intPtr + 5);
					}
					return (int)(void*)(intPtr + 4);
				}
				goto IL_03b7;
			}
			if ((nuint)(void*)intPtr2 >= (nuint)4u)
			{
				intPtr2 -= 4;
				uint num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr);
				if (value0 == num2 || value1 == num2 || value2 == num2)
				{
					goto IL_0393;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 1);
				if (value0 == num2 || value1 == num2 || value2 == num2)
				{
					goto IL_039b;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 2);
				if (value0 == num2 || value1 == num2 || value2 == num2)
				{
					goto IL_03a9;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 3);
				if (value0 == num2 || value1 == num2 || value2 == num2)
				{
					goto IL_03b7;
				}
				intPtr += 4;
			}
			while ((void*)intPtr2 != null)
			{
				intPtr2 -= 1;
				uint num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr);
				if (value0 != num2 && value1 != num2 && value2 != num2)
				{
					intPtr += 1;
					continue;
				}
				goto IL_0393;
			}
			if (Vector.IsHardwareAccelerated && (int)(void*)intPtr < length)
			{
				intPtr2 = (IntPtr)((length - (int)(void*)intPtr) & ~(Vector<byte>.Count - 1));
				Vector<byte> vector = GetVector(value0);
				Vector<byte> vector2 = GetVector(value1);
				Vector<byte> vector3 = GetVector(value2);
				for (; (void*)intPtr2 > (void*)intPtr; intPtr += Vector<byte>.Count)
				{
					Vector<byte> left = Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref searchSpace, intPtr));
					Vector<byte> vector4 = Vector.BitwiseOr(Vector.BitwiseOr(Vector.Equals(left, vector), Vector.Equals(left, vector2)), Vector.Equals(left, vector3));
					if (!Vector<byte>.Zero.Equals(vector4))
					{
						return (int)(void*)intPtr + LocateFirstFoundByte(vector4);
					}
				}
				if ((int)(void*)intPtr < length)
				{
					intPtr2 = (IntPtr)(length - (int)(void*)intPtr);
					continue;
				}
			}
			return -1;
			IL_0393:
			return (int)(void*)intPtr;
			IL_039b:
			return (int)(void*)(intPtr + 1);
			IL_03b7:
			return (int)(void*)(intPtr + 3);
			IL_03a9:
			return (int)(void*)(intPtr + 2);
		}
		return (int)(void*)(intPtr + 7);
	}

	public unsafe static int LastIndexOfAny(ref byte searchSpace, byte value0, byte value1, int length)
	{
		IntPtr intPtr = (IntPtr)length;
		IntPtr intPtr2 = (IntPtr)length;
		if (Vector.IsHardwareAccelerated && length >= Vector<byte>.Count * 2)
		{
			int num = (int)Unsafe.AsPointer(ref searchSpace) & (Vector<byte>.Count - 1);
			intPtr2 = (IntPtr)(((length & (Vector<byte>.Count - 1)) + num) & (Vector<byte>.Count - 1));
		}
		while (true)
		{
			if ((nuint)(void*)intPtr2 >= (nuint)8u)
			{
				intPtr2 -= 8;
				intPtr -= 8;
				uint num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 7);
				if (value0 == num2 || value1 == num2)
				{
					break;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 6);
				if (value0 != num2 && value1 != num2)
				{
					num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 5);
					if (value0 != num2 && value1 != num2)
					{
						num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 4);
						if (value0 != num2 && value1 != num2)
						{
							num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 3);
							if (value0 != num2 && value1 != num2)
							{
								num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 2);
								if (value0 != num2 && value1 != num2)
								{
									num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 1);
									if (value0 != num2 && value1 != num2)
									{
										num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr);
										if (value0 != num2 && value1 != num2)
										{
											continue;
										}
										goto IL_0314;
									}
									goto IL_031c;
								}
								goto IL_032a;
							}
							goto IL_0338;
						}
						return (int)(void*)(intPtr + 4);
					}
					return (int)(void*)(intPtr + 5);
				}
				return (int)(void*)(intPtr + 6);
			}
			if ((nuint)(void*)intPtr2 >= (nuint)4u)
			{
				intPtr2 -= 4;
				intPtr -= 4;
				uint num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 3);
				if (value0 == num2 || value1 == num2)
				{
					goto IL_0338;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 2);
				if (value0 == num2 || value1 == num2)
				{
					goto IL_032a;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 1);
				if (value0 == num2 || value1 == num2)
				{
					goto IL_031c;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr);
				if (value0 == num2 || value1 == num2)
				{
					goto IL_0314;
				}
			}
			while ((void*)intPtr2 != null)
			{
				intPtr2 -= 1;
				intPtr -= 1;
				uint num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr);
				if (value0 != num2 && value1 != num2)
				{
					continue;
				}
				goto IL_0314;
			}
			if (Vector.IsHardwareAccelerated && (void*)intPtr != null)
			{
				intPtr2 = (IntPtr)((int)(void*)intPtr & ~(Vector<byte>.Count - 1));
				Vector<byte> vector = GetVector(value0);
				Vector<byte> vector2 = GetVector(value1);
				for (; (nuint)(void*)intPtr2 > (nuint)(Vector<byte>.Count - 1); intPtr2 -= Vector<byte>.Count)
				{
					Vector<byte> left = Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref searchSpace, intPtr - Vector<byte>.Count));
					Vector<byte> vector3 = Vector.BitwiseOr(Vector.Equals(left, vector), Vector.Equals(left, vector2));
					if (Vector<byte>.Zero.Equals(vector3))
					{
						intPtr -= Vector<byte>.Count;
						continue;
					}
					return (int)intPtr - Vector<byte>.Count + LocateLastFoundByte(vector3);
				}
				if ((void*)intPtr != null)
				{
					intPtr2 = intPtr;
					continue;
				}
			}
			return -1;
			IL_0314:
			return (int)(void*)intPtr;
			IL_0338:
			return (int)(void*)(intPtr + 3);
			IL_031c:
			return (int)(void*)(intPtr + 1);
			IL_032a:
			return (int)(void*)(intPtr + 2);
		}
		return (int)(void*)(intPtr + 7);
	}

	public unsafe static int LastIndexOfAny(ref byte searchSpace, byte value0, byte value1, byte value2, int length)
	{
		IntPtr intPtr = (IntPtr)length;
		IntPtr intPtr2 = (IntPtr)length;
		if (Vector.IsHardwareAccelerated && length >= Vector<byte>.Count * 2)
		{
			int num = (int)Unsafe.AsPointer(ref searchSpace) & (Vector<byte>.Count - 1);
			intPtr2 = (IntPtr)(((length & (Vector<byte>.Count - 1)) + num) & (Vector<byte>.Count - 1));
		}
		while (true)
		{
			if ((nuint)(void*)intPtr2 >= (nuint)8u)
			{
				intPtr2 -= 8;
				intPtr -= 8;
				uint num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 7);
				if (value0 == num2 || value1 == num2 || value2 == num2)
				{
					break;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 6);
				if (value0 != num2 && value1 != num2 && value2 != num2)
				{
					num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 5);
					if (value0 != num2 && value1 != num2 && value2 != num2)
					{
						num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 4);
						if (value0 != num2 && value1 != num2 && value2 != num2)
						{
							num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 3);
							if (value0 != num2 && value1 != num2 && value2 != num2)
							{
								num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 2);
								if (value0 != num2 && value1 != num2 && value2 != num2)
								{
									num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 1);
									if (value0 != num2 && value1 != num2 && value2 != num2)
									{
										num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr);
										if (value0 != num2 && value1 != num2 && value2 != num2)
										{
											continue;
										}
										goto IL_03ab;
									}
									goto IL_03b3;
								}
								goto IL_03c1;
							}
							goto IL_03cf;
						}
						return (int)(void*)(intPtr + 4);
					}
					return (int)(void*)(intPtr + 5);
				}
				return (int)(void*)(intPtr + 6);
			}
			if ((nuint)(void*)intPtr2 >= (nuint)4u)
			{
				intPtr2 -= 4;
				intPtr -= 4;
				uint num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 3);
				if (value0 == num2 || value1 == num2 || value2 == num2)
				{
					goto IL_03cf;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 2);
				if (value0 == num2 || value1 == num2 || value2 == num2)
				{
					goto IL_03c1;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr + 1);
				if (value0 == num2 || value1 == num2 || value2 == num2)
				{
					goto IL_03b3;
				}
				num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr);
				if (value0 == num2 || value1 == num2 || value2 == num2)
				{
					goto IL_03ab;
				}
			}
			while ((void*)intPtr2 != null)
			{
				intPtr2 -= 1;
				intPtr -= 1;
				uint num2 = Unsafe.AddByteOffset(ref searchSpace, intPtr);
				if (value0 != num2 && value1 != num2 && value2 != num2)
				{
					continue;
				}
				goto IL_03ab;
			}
			if (Vector.IsHardwareAccelerated && (void*)intPtr != null)
			{
				intPtr2 = (IntPtr)((int)(void*)intPtr & ~(Vector<byte>.Count - 1));
				Vector<byte> vector = GetVector(value0);
				Vector<byte> vector2 = GetVector(value1);
				Vector<byte> vector3 = GetVector(value2);
				for (; (nuint)(void*)intPtr2 > (nuint)(Vector<byte>.Count - 1); intPtr2 -= Vector<byte>.Count)
				{
					Vector<byte> left = Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref searchSpace, intPtr - Vector<byte>.Count));
					Vector<byte> vector4 = Vector.BitwiseOr(Vector.BitwiseOr(Vector.Equals(left, vector), Vector.Equals(left, vector2)), Vector.Equals(left, vector3));
					if (Vector<byte>.Zero.Equals(vector4))
					{
						intPtr -= Vector<byte>.Count;
						continue;
					}
					return (int)intPtr - Vector<byte>.Count + LocateLastFoundByte(vector4);
				}
				if ((void*)intPtr != null)
				{
					intPtr2 = intPtr;
					continue;
				}
			}
			return -1;
			IL_03ab:
			return (int)(void*)intPtr;
			IL_03cf:
			return (int)(void*)(intPtr + 3);
			IL_03c1:
			return (int)(void*)(intPtr + 2);
			IL_03b3:
			return (int)(void*)(intPtr + 1);
		}
		return (int)(void*)(intPtr + 7);
	}

	public unsafe static bool SequenceEqual(ref byte first, ref byte second, NUInt length)
	{
		if (Unsafe.AreSame(ref first, ref second))
		{
			goto IL_013d;
		}
		IntPtr intPtr = (IntPtr)0;
		IntPtr intPtr2 = (IntPtr)(void*)length;
		if (Vector.IsHardwareAccelerated && (nuint)(void*)intPtr2 >= (nuint)Vector<byte>.Count)
		{
			intPtr2 -= Vector<byte>.Count;
			while (true)
			{
				if ((void*)intPtr2 > (void*)intPtr)
				{
					if (Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref first, intPtr)) != Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref second, intPtr)))
					{
						break;
					}
					intPtr += Vector<byte>.Count;
					continue;
				}
				return Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref first, intPtr2)) == Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref second, intPtr2));
			}
		}
		else
		{
			if ((nuint)(void*)intPtr2 < (nuint)sizeof(UIntPtr))
			{
				while ((void*)intPtr2 > (void*)intPtr)
				{
					if (Unsafe.AddByteOffset(ref first, intPtr) == Unsafe.AddByteOffset(ref second, intPtr))
					{
						intPtr += 1;
						continue;
					}
					goto IL_013f;
				}
				goto IL_013d;
			}
			intPtr2 -= sizeof(UIntPtr);
			while (true)
			{
				if ((void*)intPtr2 > (void*)intPtr)
				{
					if (Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref first, intPtr)) != Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref second, intPtr)))
					{
						break;
					}
					intPtr += sizeof(UIntPtr);
					continue;
				}
				return Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref first, intPtr2)) == Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref second, intPtr2));
			}
		}
		goto IL_013f;
		IL_013f:
		return false;
		IL_013d:
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int LocateFirstFoundByte(Vector<byte> match)
	{
		Vector<ulong> vector = Vector.AsVectorUInt64(match);
		ulong num = 0uL;
		int i;
		for (i = 0; i < Vector<ulong>.Count; i++)
		{
			num = vector[i];
			if (num != 0L)
			{
				break;
			}
		}
		return i * 8 + LocateFirstFoundByte(num);
	}

	public unsafe static int SequenceCompareTo(ref byte first, int firstLength, ref byte second, int secondLength)
	{
		if (!Unsafe.AreSame(ref first, ref second))
		{
			IntPtr intPtr = (IntPtr)((firstLength < secondLength) ? firstLength : secondLength);
			IntPtr intPtr2 = (IntPtr)0;
			IntPtr intPtr3 = (IntPtr)(void*)intPtr;
			if (Vector.IsHardwareAccelerated && (nuint)(void*)intPtr3 > (nuint)Vector<byte>.Count)
			{
				intPtr3 -= Vector<byte>.Count;
				for (; (void*)intPtr3 > (void*)intPtr2 && !(Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref first, intPtr2)) != Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref second, intPtr2))); intPtr2 += Vector<byte>.Count)
				{
				}
			}
			else if ((nuint)(void*)intPtr3 > (nuint)sizeof(UIntPtr))
			{
				intPtr3 -= sizeof(UIntPtr);
				for (; (void*)intPtr3 > (void*)intPtr2 && !(Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref first, intPtr2)) != Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref second, intPtr2))); intPtr2 += sizeof(UIntPtr))
				{
				}
			}
			for (; (void*)intPtr > (void*)intPtr2; intPtr2 += 1)
			{
				int num = Unsafe.AddByteOffset(ref first, intPtr2).CompareTo(Unsafe.AddByteOffset(ref second, intPtr2));
				if (num != 0)
				{
					return num;
				}
			}
		}
		return firstLength - secondLength;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int LocateLastFoundByte(Vector<byte> match)
	{
		Vector<ulong> vector = Vector.AsVectorUInt64(match);
		ulong num = 0uL;
		int num2;
		for (num2 = Vector<ulong>.Count - 1; num2 >= 0; num2--)
		{
			num = vector[num2];
			if (num != 0L)
			{
				break;
			}
		}
		return num2 * 8 + LocateLastFoundByte(num);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int LocateFirstFoundByte(ulong match)
	{
		ulong num = match ^ (match - 1);
		return (int)(num * 283686952306184L >> 57);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int LocateLastFoundByte(ulong match)
	{
		int num = 7;
		while ((long)match > 0L)
		{
			match <<= 8;
			num--;
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static Vector<byte> GetVector(byte vectorByte)
	{
		return Vector.AsVectorByte(new Vector<uint>((uint)(vectorByte * 16843009)));
	}

	public unsafe static int SequenceCompareTo(ref char first, int firstLength, ref char second, int secondLength)
	{
		int result = firstLength - secondLength;
		if (!Unsafe.AreSame(ref first, ref second))
		{
			IntPtr intPtr = (IntPtr)((firstLength < secondLength) ? firstLength : secondLength);
			IntPtr intPtr2 = (IntPtr)0;
			if ((nuint)(void*)intPtr >= (nuint)(sizeof(UIntPtr) / 2))
			{
				if (Vector.IsHardwareAccelerated && (nuint)(void*)intPtr >= (nuint)Vector<ushort>.Count)
				{
					IntPtr intPtr3 = intPtr - Vector<ushort>.Count;
					while (!(Unsafe.ReadUnaligned<Vector<ushort>>(ref Unsafe.As<char, byte>(ref Unsafe.Add(ref first, intPtr2))) != Unsafe.ReadUnaligned<Vector<ushort>>(ref Unsafe.As<char, byte>(ref Unsafe.Add(ref second, intPtr2)))))
					{
						intPtr2 += Vector<ushort>.Count;
						if ((void*)intPtr3 < (void*)intPtr2)
						{
							break;
						}
					}
				}
				for (; (void*)intPtr >= (void*)(intPtr2 + sizeof(UIntPtr) / 2) && !(Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.As<char, byte>(ref Unsafe.Add(ref first, intPtr2))) != Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.As<char, byte>(ref Unsafe.Add(ref second, intPtr2)))); intPtr2 += sizeof(UIntPtr) / 2)
				{
				}
			}
			if (sizeof(UIntPtr) > 4 && (void*)intPtr >= (void*)(intPtr2 + 2) && Unsafe.ReadUnaligned<int>(ref Unsafe.As<char, byte>(ref Unsafe.Add(ref first, intPtr2))) == Unsafe.ReadUnaligned<int>(ref Unsafe.As<char, byte>(ref Unsafe.Add(ref second, intPtr2))))
			{
				intPtr2 += 2;
			}
			for (; (void*)intPtr2 < (void*)intPtr; intPtr2 += 1)
			{
				int num = Unsafe.Add(ref first, intPtr2).CompareTo(Unsafe.Add(ref second, intPtr2));
				if (num != 0)
				{
					return num;
				}
			}
		}
		return result;
	}

	public unsafe static int IndexOf(ref char searchSpace, char value, int length)
	{
		fixed (char* ptr = &searchSpace)
		{
			char* ptr2 = ptr;
			char* ptr3 = ptr2 + length;
			if (Vector.IsHardwareAccelerated && length >= Vector<ushort>.Count * 2)
			{
				int num = ((int)ptr2 & (Unsafe.SizeOf<Vector<ushort>>() - 1)) / 2;
				length = (Vector<ushort>.Count - num) & (Vector<ushort>.Count - 1);
			}
			while (true)
			{
				if (length >= 4)
				{
					length -= 4;
					if (*ptr2 == value)
					{
						break;
					}
					if (ptr2[1] != value)
					{
						if (ptr2[2] != value)
						{
							if (ptr2[3] != value)
							{
								ptr2 += 4;
								continue;
							}
							ptr2++;
						}
						ptr2++;
					}
					ptr2++;
					break;
				}
				while (length > 0)
				{
					length--;
					if (*ptr2 == value)
					{
						goto end_IL_0079;
					}
					ptr2++;
				}
				if (Vector.IsHardwareAccelerated && ptr2 < ptr3)
				{
					length = (int)((ptr3 - ptr2) & ~(Vector<ushort>.Count - 1));
					Vector<ushort> left = new Vector<ushort>(value);
					while (length > 0)
					{
						Vector<ushort> vector = Vector.Equals(left, Unsafe.Read<Vector<ushort>>(ptr2));
						if (Vector<ushort>.Zero.Equals(vector))
						{
							ptr2 += Vector<ushort>.Count;
							length -= Vector<ushort>.Count;
							continue;
						}
						return (int)(ptr2 - ptr) + LocateFirstFoundChar(vector);
					}
					if (ptr2 < ptr3)
					{
						length = (int)(ptr3 - ptr2);
						continue;
					}
				}
				return -1;
				continue;
				end_IL_0079:
				break;
			}
			return (int)(ptr2 - ptr);
		}
	}

	public unsafe static int LastIndexOf(ref char searchSpace, char value, int length)
	{
		fixed (char* ptr = &searchSpace)
		{
			char* ptr2 = ptr + length;
			char* ptr3 = ptr;
			if (Vector.IsHardwareAccelerated && length >= Vector<ushort>.Count * 2)
			{
				length = ((int)ptr2 & (Unsafe.SizeOf<Vector<ushort>>() - 1)) / 2;
			}
			while (true)
			{
				if (length >= 4)
				{
					length -= 4;
					ptr2 -= 4;
					if (ptr2[3] == value)
					{
						break;
					}
					if (ptr2[2] != value)
					{
						if (ptr2[1] != value)
						{
							if (*ptr2 != value)
							{
								continue;
							}
							goto IL_011d;
						}
						return (int)(ptr2 - ptr3) + 1;
					}
					return (int)(ptr2 - ptr3) + 2;
				}
				while (length > 0)
				{
					length--;
					ptr2--;
					if (*ptr2 != value)
					{
						continue;
					}
					goto IL_011d;
				}
				if (Vector.IsHardwareAccelerated && ptr2 > ptr3)
				{
					length = (int)((ptr2 - ptr3) & ~(Vector<ushort>.Count - 1));
					Vector<ushort> left = new Vector<ushort>(value);
					while (length > 0)
					{
						char* ptr4 = ptr2 - Vector<ushort>.Count;
						Vector<ushort> vector = Vector.Equals(left, Unsafe.Read<Vector<ushort>>(ptr4));
						if (Vector<ushort>.Zero.Equals(vector))
						{
							ptr2 -= Vector<ushort>.Count;
							length -= Vector<ushort>.Count;
							continue;
						}
						return (int)(ptr4 - ptr3) + LocateLastFoundChar(vector);
					}
					if (ptr2 > ptr3)
					{
						length = (int)(ptr2 - ptr3);
						continue;
					}
				}
				return -1;
				IL_011d:
				return (int)(ptr2 - ptr3);
			}
			return (int)(ptr2 - ptr3) + 3;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int LocateFirstFoundChar(Vector<ushort> match)
	{
		Vector<ulong> vector = Vector.AsVectorUInt64(match);
		ulong num = 0uL;
		int i;
		for (i = 0; i < Vector<ulong>.Count; i++)
		{
			num = vector[i];
			if (num != 0L)
			{
				break;
			}
		}
		return i * 4 + LocateFirstFoundChar(num);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int LocateFirstFoundChar(ulong match)
	{
		ulong num = match ^ (match - 1);
		return (int)(num * 4295098372L >> 49);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int LocateLastFoundChar(Vector<ushort> match)
	{
		Vector<ulong> vector = Vector.AsVectorUInt64(match);
		ulong num = 0uL;
		int num2;
		for (num2 = Vector<ulong>.Count - 1; num2 >= 0; num2--)
		{
			num = vector[num2];
			if (num != 0L)
			{
				break;
			}
		}
		return num2 * 4 + LocateLastFoundChar(num);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int LocateLastFoundChar(ulong match)
	{
		int num = 3;
		while ((long)match > 0L)
		{
			match <<= 16;
			num--;
		}
		return num;
	}

	public static int IndexOf<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength) where T : IEquatable<T>
	{
		if (valueLength == 0)
		{
			return 0;
		}
		T value2 = value;
		ref T second = ref Unsafe.Add(ref value, 1);
		int num = valueLength - 1;
		int num2 = 0;
		while (true)
		{
			int num3 = searchSpaceLength - num2 - num;
			if (num3 <= 0)
			{
				break;
			}
			int num4 = IndexOf(ref Unsafe.Add(ref searchSpace, num2), value2, num3);
			if (num4 == -1)
			{
				break;
			}
			num2 += num4;
			if (SequenceEqual(ref Unsafe.Add(ref searchSpace, num2 + 1), ref second, num))
			{
				return num2;
			}
			num2++;
		}
		return -1;
	}

	public unsafe static int IndexOf<T>(ref T searchSpace, T value, int length) where T : IEquatable<T>
	{
		IntPtr intPtr = (IntPtr)0;
		while (true)
		{
			if (length >= 8)
			{
				length -= 8;
				if (!value.Equals(Unsafe.Add(ref searchSpace, intPtr)))
				{
					if (value.Equals(Unsafe.Add(ref searchSpace, intPtr + 1)))
					{
						goto IL_020a;
					}
					if (value.Equals(Unsafe.Add(ref searchSpace, intPtr + 2)))
					{
						goto IL_0218;
					}
					if (!value.Equals(Unsafe.Add(ref searchSpace, intPtr + 3)))
					{
						if (!value.Equals(Unsafe.Add(ref searchSpace, intPtr + 4)))
						{
							if (!value.Equals(Unsafe.Add(ref searchSpace, intPtr + 5)))
							{
								if (!value.Equals(Unsafe.Add(ref searchSpace, intPtr + 6)))
								{
									if (value.Equals(Unsafe.Add(ref searchSpace, intPtr + 7)))
									{
										break;
									}
									intPtr += 8;
									continue;
								}
								return (int)(void*)(intPtr + 6);
							}
							return (int)(void*)(intPtr + 5);
						}
						return (int)(void*)(intPtr + 4);
					}
					goto IL_0226;
				}
			}
			else
			{
				if (length >= 4)
				{
					length -= 4;
					if (value.Equals(Unsafe.Add(ref searchSpace, intPtr)))
					{
						goto IL_0202;
					}
					if (value.Equals(Unsafe.Add(ref searchSpace, intPtr + 1)))
					{
						goto IL_020a;
					}
					if (value.Equals(Unsafe.Add(ref searchSpace, intPtr + 2)))
					{
						goto IL_0218;
					}
					if (value.Equals(Unsafe.Add(ref searchSpace, intPtr + 3)))
					{
						goto IL_0226;
					}
					intPtr += 4;
				}
				while (true)
				{
					if (length > 0)
					{
						if (value.Equals(Unsafe.Add(ref searchSpace, intPtr)))
						{
							break;
						}
						intPtr += 1;
						length--;
						continue;
					}
					return -1;
				}
			}
			goto IL_0202;
			IL_0218:
			return (int)(void*)(intPtr + 2);
			IL_0202:
			return (int)(void*)intPtr;
			IL_020a:
			return (int)(void*)(intPtr + 1);
			IL_0226:
			return (int)(void*)(intPtr + 3);
		}
		return (int)(void*)(intPtr + 7);
	}

	public static int IndexOfAny<T>(ref T searchSpace, T value0, T value1, int length) where T : IEquatable<T>
	{
		int num = 0;
		while (true)
		{
			if (length - num >= 8)
			{
				T other = Unsafe.Add(ref searchSpace, num);
				if (!value0.Equals(other) && !value1.Equals(other))
				{
					other = Unsafe.Add(ref searchSpace, num + 1);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02cb;
					}
					other = Unsafe.Add(ref searchSpace, num + 2);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02cf;
					}
					other = Unsafe.Add(ref searchSpace, num + 3);
					if (!value0.Equals(other) && !value1.Equals(other))
					{
						other = Unsafe.Add(ref searchSpace, num + 4);
						if (!value0.Equals(other) && !value1.Equals(other))
						{
							other = Unsafe.Add(ref searchSpace, num + 5);
							if (!value0.Equals(other) && !value1.Equals(other))
							{
								other = Unsafe.Add(ref searchSpace, num + 6);
								if (!value0.Equals(other) && !value1.Equals(other))
								{
									other = Unsafe.Add(ref searchSpace, num + 7);
									if (value0.Equals(other) || value1.Equals(other))
									{
										break;
									}
									num += 8;
									continue;
								}
								return num + 6;
							}
							return num + 5;
						}
						return num + 4;
					}
					goto IL_02d3;
				}
			}
			else
			{
				if (length - num >= 4)
				{
					T other = Unsafe.Add(ref searchSpace, num);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02c9;
					}
					other = Unsafe.Add(ref searchSpace, num + 1);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02cb;
					}
					other = Unsafe.Add(ref searchSpace, num + 2);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02cf;
					}
					other = Unsafe.Add(ref searchSpace, num + 3);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02d3;
					}
					num += 4;
				}
				while (true)
				{
					if (num < length)
					{
						T other = Unsafe.Add(ref searchSpace, num);
						if (value0.Equals(other) || value1.Equals(other))
						{
							break;
						}
						num++;
						continue;
					}
					return -1;
				}
			}
			goto IL_02c9;
			IL_02cf:
			return num + 2;
			IL_02cb:
			return num + 1;
			IL_02d3:
			return num + 3;
			IL_02c9:
			return num;
		}
		return num + 7;
	}

	public static int IndexOfAny<T>(ref T searchSpace, T value0, T value1, T value2, int length) where T : IEquatable<T>
	{
		int num = 0;
		while (true)
		{
			if (length - num >= 8)
			{
				T other = Unsafe.Add(ref searchSpace, num);
				if (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other))
				{
					other = Unsafe.Add(ref searchSpace, num + 1);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03c2;
					}
					other = Unsafe.Add(ref searchSpace, num + 2);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03c6;
					}
					other = Unsafe.Add(ref searchSpace, num + 3);
					if (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other))
					{
						other = Unsafe.Add(ref searchSpace, num + 4);
						if (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other))
						{
							other = Unsafe.Add(ref searchSpace, num + 5);
							if (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other))
							{
								other = Unsafe.Add(ref searchSpace, num + 6);
								if (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other))
								{
									other = Unsafe.Add(ref searchSpace, num + 7);
									if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
									{
										break;
									}
									num += 8;
									continue;
								}
								return num + 6;
							}
							return num + 5;
						}
						return num + 4;
					}
					goto IL_03ca;
				}
			}
			else
			{
				if (length - num >= 4)
				{
					T other = Unsafe.Add(ref searchSpace, num);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03c0;
					}
					other = Unsafe.Add(ref searchSpace, num + 1);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03c2;
					}
					other = Unsafe.Add(ref searchSpace, num + 2);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03c6;
					}
					other = Unsafe.Add(ref searchSpace, num + 3);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03ca;
					}
					num += 4;
				}
				while (true)
				{
					if (num < length)
					{
						T other = Unsafe.Add(ref searchSpace, num);
						if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
						{
							break;
						}
						num++;
						continue;
					}
					return -1;
				}
			}
			goto IL_03c0;
			IL_03c0:
			return num;
			IL_03c6:
			return num + 2;
			IL_03c2:
			return num + 1;
			IL_03ca:
			return num + 3;
		}
		return num + 7;
	}

	public static int IndexOfAny<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength) where T : IEquatable<T>
	{
		if (valueLength == 0)
		{
			return 0;
		}
		int num = -1;
		for (int i = 0; i < valueLength; i++)
		{
			int num2 = IndexOf(ref searchSpace, Unsafe.Add(ref value, i), searchSpaceLength);
			if ((uint)num2 < (uint)num)
			{
				num = num2;
				searchSpaceLength = num2;
				if (num == 0)
				{
					break;
				}
			}
		}
		return num;
	}

	public static int LastIndexOf<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength) where T : IEquatable<T>
	{
		if (valueLength == 0)
		{
			return 0;
		}
		T value2 = value;
		ref T second = ref Unsafe.Add(ref value, 1);
		int num = valueLength - 1;
		int num2 = 0;
		while (true)
		{
			int num3 = searchSpaceLength - num2 - num;
			if (num3 <= 0)
			{
				break;
			}
			int num4 = LastIndexOf(ref searchSpace, value2, num3);
			if (num4 == -1)
			{
				break;
			}
			if (SequenceEqual(ref Unsafe.Add(ref searchSpace, num4 + 1), ref second, num))
			{
				return num4;
			}
			num2 += num3 - num4;
		}
		return -1;
	}

	public static int LastIndexOf<T>(ref T searchSpace, T value, int length) where T : IEquatable<T>
	{
		while (true)
		{
			if (length >= 8)
			{
				length -= 8;
				if (value.Equals(Unsafe.Add(ref searchSpace, length + 7)))
				{
					break;
				}
				if (value.Equals(Unsafe.Add(ref searchSpace, length + 6)))
				{
					return length + 6;
				}
				if (value.Equals(Unsafe.Add(ref searchSpace, length + 5)))
				{
					return length + 5;
				}
				if (value.Equals(Unsafe.Add(ref searchSpace, length + 4)))
				{
					return length + 4;
				}
				if (value.Equals(Unsafe.Add(ref searchSpace, length + 3)))
				{
					goto IL_01c2;
				}
				if (value.Equals(Unsafe.Add(ref searchSpace, length + 2)))
				{
					goto IL_01be;
				}
				if (value.Equals(Unsafe.Add(ref searchSpace, length + 1)))
				{
					goto IL_01ba;
				}
				if (!value.Equals(Unsafe.Add(ref searchSpace, length)))
				{
					continue;
				}
			}
			else
			{
				if (length >= 4)
				{
					length -= 4;
					if (value.Equals(Unsafe.Add(ref searchSpace, length + 3)))
					{
						goto IL_01c2;
					}
					if (value.Equals(Unsafe.Add(ref searchSpace, length + 2)))
					{
						goto IL_01be;
					}
					if (value.Equals(Unsafe.Add(ref searchSpace, length + 1)))
					{
						goto IL_01ba;
					}
					if (value.Equals(Unsafe.Add(ref searchSpace, length)))
					{
						goto IL_01b8;
					}
				}
				do
				{
					if (length > 0)
					{
						length--;
						continue;
					}
					return -1;
				}
				while (!value.Equals(Unsafe.Add(ref searchSpace, length)));
			}
			goto IL_01b8;
			IL_01be:
			return length + 2;
			IL_01c2:
			return length + 3;
			IL_01ba:
			return length + 1;
			IL_01b8:
			return length;
		}
		return length + 7;
	}

	public static int LastIndexOfAny<T>(ref T searchSpace, T value0, T value1, int length) where T : IEquatable<T>
	{
		while (true)
		{
			if (length >= 8)
			{
				length -= 8;
				T other = Unsafe.Add(ref searchSpace, length + 7);
				if (value0.Equals(other) || value1.Equals(other))
				{
					break;
				}
				other = Unsafe.Add(ref searchSpace, length + 6);
				if (value0.Equals(other) || value1.Equals(other))
				{
					return length + 6;
				}
				other = Unsafe.Add(ref searchSpace, length + 5);
				if (value0.Equals(other) || value1.Equals(other))
				{
					return length + 5;
				}
				other = Unsafe.Add(ref searchSpace, length + 4);
				if (value0.Equals(other) || value1.Equals(other))
				{
					return length + 4;
				}
				other = Unsafe.Add(ref searchSpace, length + 3);
				if (value0.Equals(other) || value1.Equals(other))
				{
					goto IL_02cd;
				}
				other = Unsafe.Add(ref searchSpace, length + 2);
				if (value0.Equals(other) || value1.Equals(other))
				{
					goto IL_02c9;
				}
				other = Unsafe.Add(ref searchSpace, length + 1);
				if (value0.Equals(other) || value1.Equals(other))
				{
					goto IL_02c5;
				}
				other = Unsafe.Add(ref searchSpace, length);
				if (!value0.Equals(other) && !value1.Equals(other))
				{
					continue;
				}
			}
			else
			{
				T other;
				if (length >= 4)
				{
					length -= 4;
					other = Unsafe.Add(ref searchSpace, length + 3);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02cd;
					}
					other = Unsafe.Add(ref searchSpace, length + 2);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02c9;
					}
					other = Unsafe.Add(ref searchSpace, length + 1);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02c5;
					}
					other = Unsafe.Add(ref searchSpace, length);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02c3;
					}
				}
				do
				{
					if (length > 0)
					{
						length--;
						other = Unsafe.Add(ref searchSpace, length);
						continue;
					}
					return -1;
				}
				while (!value0.Equals(other) && !value1.Equals(other));
			}
			goto IL_02c3;
			IL_02c9:
			return length + 2;
			IL_02c5:
			return length + 1;
			IL_02c3:
			return length;
			IL_02cd:
			return length + 3;
		}
		return length + 7;
	}

	public static int LastIndexOfAny<T>(ref T searchSpace, T value0, T value1, T value2, int length) where T : IEquatable<T>
	{
		while (true)
		{
			if (length >= 8)
			{
				length -= 8;
				T other = Unsafe.Add(ref searchSpace, length + 7);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					break;
				}
				other = Unsafe.Add(ref searchSpace, length + 6);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					return length + 6;
				}
				other = Unsafe.Add(ref searchSpace, length + 5);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					return length + 5;
				}
				other = Unsafe.Add(ref searchSpace, length + 4);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					return length + 4;
				}
				other = Unsafe.Add(ref searchSpace, length + 3);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					goto IL_03da;
				}
				other = Unsafe.Add(ref searchSpace, length + 2);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					goto IL_03d5;
				}
				other = Unsafe.Add(ref searchSpace, length + 1);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					goto IL_03d0;
				}
				other = Unsafe.Add(ref searchSpace, length);
				if (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other))
				{
					continue;
				}
			}
			else
			{
				T other;
				if (length >= 4)
				{
					length -= 4;
					other = Unsafe.Add(ref searchSpace, length + 3);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03da;
					}
					other = Unsafe.Add(ref searchSpace, length + 2);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03d5;
					}
					other = Unsafe.Add(ref searchSpace, length + 1);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03d0;
					}
					other = Unsafe.Add(ref searchSpace, length);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03cd;
					}
				}
				do
				{
					if (length > 0)
					{
						length--;
						other = Unsafe.Add(ref searchSpace, length);
						continue;
					}
					return -1;
				}
				while (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other));
			}
			goto IL_03cd;
			IL_03d0:
			return length + 1;
			IL_03d5:
			return length + 2;
			IL_03da:
			return length + 3;
			IL_03cd:
			return length;
		}
		return length + 7;
	}

	public static int LastIndexOfAny<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength) where T : IEquatable<T>
	{
		if (valueLength == 0)
		{
			return 0;
		}
		int num = -1;
		for (int i = 0; i < valueLength; i++)
		{
			int num2 = LastIndexOf(ref searchSpace, Unsafe.Add(ref value, i), searchSpaceLength);
			if (num2 > num)
			{
				num = num2;
			}
		}
		return num;
	}

	public static bool SequenceEqual<T>(ref T first, ref T second, int length) where T : IEquatable<T>
	{
		if (!Unsafe.AreSame(ref first, ref second))
		{
			IntPtr intPtr = (IntPtr)0;
			while (true)
			{
				if (length >= 8)
				{
					length -= 8;
					if (Unsafe.Add(ref first, intPtr).Equals(Unsafe.Add(ref second, intPtr)) && Unsafe.Add(ref first, intPtr + 1).Equals(Unsafe.Add(ref second, intPtr + 1)) && Unsafe.Add(ref first, intPtr + 2).Equals(Unsafe.Add(ref second, intPtr + 2)) && Unsafe.Add(ref first, intPtr + 3).Equals(Unsafe.Add(ref second, intPtr + 3)) && Unsafe.Add(ref first, intPtr + 4).Equals(Unsafe.Add(ref second, intPtr + 4)) && Unsafe.Add(ref first, intPtr + 5).Equals(Unsafe.Add(ref second, intPtr + 5)) && Unsafe.Add(ref first, intPtr + 6).Equals(Unsafe.Add(ref second, intPtr + 6)) && Unsafe.Add(ref first, intPtr + 7).Equals(Unsafe.Add(ref second, intPtr + 7)))
					{
						intPtr += 8;
						continue;
					}
					goto IL_028b;
				}
				if (length >= 4)
				{
					length -= 4;
					if (!Unsafe.Add(ref first, intPtr).Equals(Unsafe.Add(ref second, intPtr)) || !Unsafe.Add(ref first, intPtr + 1).Equals(Unsafe.Add(ref second, intPtr + 1)) || !Unsafe.Add(ref first, intPtr + 2).Equals(Unsafe.Add(ref second, intPtr + 2)) || !Unsafe.Add(ref first, intPtr + 3).Equals(Unsafe.Add(ref second, intPtr + 3)))
					{
						goto IL_028b;
					}
					intPtr += 4;
				}
				while (length > 0)
				{
					if (Unsafe.Add(ref first, intPtr).Equals(Unsafe.Add(ref second, intPtr)))
					{
						intPtr += 1;
						length--;
						continue;
					}
					goto IL_028b;
				}
				break;
				IL_028b:
				return false;
			}
		}
		return true;
	}

	public static int SequenceCompareTo<T>(ref T first, int firstLength, ref T second, int secondLength) where T : IComparable<T>
	{
		int num = firstLength;
		if (num > secondLength)
		{
			num = secondLength;
		}
		for (int i = 0; i < num; i++)
		{
			int num2 = Unsafe.Add(ref first, i).CompareTo(Unsafe.Add(ref second, i));
			if (num2 != 0)
			{
				return num2;
			}
		}
		return firstLength.CompareTo(secondLength);
	}

	public unsafe static void CopyTo<T>(ref T dst, int dstLength, ref T src, int srcLength)
	{
		IntPtr intPtr = Unsafe.ByteOffset(ref src, ref Unsafe.Add(ref src, srcLength));
		IntPtr intPtr2 = Unsafe.ByteOffset(ref dst, ref Unsafe.Add(ref dst, dstLength));
		IntPtr intPtr3 = Unsafe.ByteOffset(ref src, ref dst);
		bool num;
		if (sizeof(IntPtr) != 4)
		{
			if ((ulong)(long)intPtr3 >= (ulong)(long)intPtr)
			{
				num = (ulong)(long)intPtr3 > (ulong)(-(long)intPtr2);
				goto IL_006f;
			}
		}
		else if ((uint)(int)intPtr3 >= (uint)(int)intPtr)
		{
			num = (uint)(int)intPtr3 > (uint)(-(int)intPtr2);
			goto IL_006f;
		}
		goto IL_00de;
		IL_006f:
		if (!num && !IsReferenceOrContainsReferences<T>())
		{
			ref byte source = ref Unsafe.As<T, byte>(ref dst);
			ref byte source2 = ref Unsafe.As<T, byte>(ref src);
			ulong num2 = (ulong)(long)intPtr;
			uint num4;
			for (ulong num3 = 0uL; num3 < num2; num3 += num4)
			{
				num4 = (uint)((num2 - num3 > uint.MaxValue) ? uint.MaxValue : (num2 - num3));
				Unsafe.CopyBlock(ref Unsafe.Add(ref source, (IntPtr)(long)num3), ref Unsafe.Add(ref source2, (IntPtr)(long)num3), num4);
			}
			return;
		}
		goto IL_00de;
		IL_00de:
		bool flag = ((sizeof(IntPtr) == 4) ? ((uint)(int)intPtr3 > (uint)(-(int)intPtr2)) : ((ulong)(long)intPtr3 > (ulong)(-(long)intPtr2)));
		int num5 = (flag ? 1 : (-1));
		int num6 = ((!flag) ? (srcLength - 1) : 0);
		int i;
		for (i = 0; i < (srcLength & -8); i += 8)
		{
			Unsafe.Add(ref dst, num6) = Unsafe.Add(ref src, num6);
			Unsafe.Add(ref dst, num6 + num5) = Unsafe.Add(ref src, num6 + num5);
			Unsafe.Add(ref dst, num6 + num5 * 2) = Unsafe.Add(ref src, num6 + num5 * 2);
			Unsafe.Add(ref dst, num6 + num5 * 3) = Unsafe.Add(ref src, num6 + num5 * 3);
			Unsafe.Add(ref dst, num6 + num5 * 4) = Unsafe.Add(ref src, num6 + num5 * 4);
			Unsafe.Add(ref dst, num6 + num5 * 5) = Unsafe.Add(ref src, num6 + num5 * 5);
			Unsafe.Add(ref dst, num6 + num5 * 6) = Unsafe.Add(ref src, num6 + num5 * 6);
			Unsafe.Add(ref dst, num6 + num5 * 7) = Unsafe.Add(ref src, num6 + num5 * 7);
			num6 += num5 * 8;
		}
		if (i < (srcLength & -4))
		{
			Unsafe.Add(ref dst, num6) = Unsafe.Add(ref src, num6);
			Unsafe.Add(ref dst, num6 + num5) = Unsafe.Add(ref src, num6 + num5);
			Unsafe.Add(ref dst, num6 + num5 * 2) = Unsafe.Add(ref src, num6 + num5 * 2);
			Unsafe.Add(ref dst, num6 + num5 * 3) = Unsafe.Add(ref src, num6 + num5 * 3);
			num6 += num5 * 4;
			i += 4;
		}
		for (; i < srcLength; i++)
		{
			Unsafe.Add(ref dst, num6) = Unsafe.Add(ref src, num6);
			num6 += num5;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static IntPtr Add<T>(this IntPtr start, int index)
	{
		if (sizeof(IntPtr) == 4)
		{
			uint num = (uint)(index * Unsafe.SizeOf<T>());
			return (IntPtr)((byte*)(void*)start + num);
		}
		ulong num2 = (ulong)index * (ulong)Unsafe.SizeOf<T>();
		return (IntPtr)((byte*)(void*)start + num2);
	}

	public static bool IsReferenceOrContainsReferences<T>()
	{
		return PerTypeValues<T>.IsReferenceOrContainsReferences;
	}

	private static bool IsReferenceOrContainsReferencesCore(Type type)
	{
		if (type.GetTypeInfo().IsPrimitive)
		{
			return false;
		}
		if (!type.GetTypeInfo().IsValueType)
		{
			return true;
		}
		Type underlyingType = Nullable.GetUnderlyingType(type);
		if (underlyingType != null)
		{
			type = underlyingType;
		}
		if (type.GetTypeInfo().IsEnum)
		{
			return false;
		}
		foreach (FieldInfo declaredField in type.GetTypeInfo().DeclaredFields)
		{
			if (!declaredField.IsStatic && IsReferenceOrContainsReferencesCore(declaredField.FieldType))
			{
				return true;
			}
		}
		return false;
	}

	public unsafe static void ClearLessThanPointerSized(byte* ptr, UIntPtr byteLength)
	{
		if (sizeof(UIntPtr) == 4)
		{
			Unsafe.InitBlockUnaligned(ptr, 0, (uint)byteLength);
			return;
		}
		ulong num = (ulong)byteLength;
		uint num2 = (uint)(num & 0xFFFFFFFFu);
		Unsafe.InitBlockUnaligned(ptr, 0, num2);
		num -= num2;
		ptr += num2;
		while (num != 0)
		{
			num2 = (uint)((num >= uint.MaxValue) ? uint.MaxValue : num);
			Unsafe.InitBlockUnaligned(ptr, 0, num2);
			ptr += num2;
			num -= num2;
		}
	}

	public unsafe static void ClearLessThanPointerSized(ref byte b, UIntPtr byteLength)
	{
		if (sizeof(UIntPtr) == 4)
		{
			Unsafe.InitBlockUnaligned(ref b, 0, (uint)byteLength);
			return;
		}
		ulong num = (ulong)byteLength;
		uint num2 = (uint)(num & 0xFFFFFFFFu);
		Unsafe.InitBlockUnaligned(ref b, 0, num2);
		num -= num2;
		long num3 = num2;
		while (num != 0)
		{
			num2 = (uint)((num >= uint.MaxValue) ? uint.MaxValue : num);
			Unsafe.InitBlockUnaligned(ref Unsafe.Add(ref b, (IntPtr)num3), 0, num2);
			num3 += num2;
			num -= num2;
		}
	}

	public unsafe static void ClearPointerSizedWithoutReferences(ref byte b, UIntPtr byteLength)
	{
		IntPtr zero;
		for (zero = IntPtr.Zero; zero.LessThanEqual(byteLength - sizeof(Reg64)); zero += sizeof(Reg64))
		{
			Unsafe.As<byte, Reg64>(ref Unsafe.Add(ref b, zero)) = default(Reg64);
		}
		if (zero.LessThanEqual(byteLength - sizeof(Reg32)))
		{
			Unsafe.As<byte, Reg32>(ref Unsafe.Add(ref b, zero)) = default(Reg32);
			zero += sizeof(Reg32);
		}
		if (zero.LessThanEqual(byteLength - sizeof(Reg16)))
		{
			Unsafe.As<byte, Reg16>(ref Unsafe.Add(ref b, zero)) = default(Reg16);
			zero += sizeof(Reg16);
		}
		if (zero.LessThanEqual(byteLength - 8))
		{
			Unsafe.As<byte, long>(ref Unsafe.Add(ref b, zero)) = 0L;
			zero += 8;
		}
		if (sizeof(IntPtr) == 4 && zero.LessThanEqual(byteLength - 4))
		{
			Unsafe.As<byte, int>(ref Unsafe.Add(ref b, zero)) = 0;
			zero += 4;
		}
	}

	public static void ClearPointerSizedWithReferences(ref IntPtr ip, UIntPtr pointerSizeLength)
	{
		IntPtr intPtr = IntPtr.Zero;
		IntPtr zero = IntPtr.Zero;
		while ((zero = intPtr + 8).LessThanEqual(pointerSizeLength))
		{
			Unsafe.Add(ref ip, intPtr + 0) = default(IntPtr);
			Unsafe.Add(ref ip, intPtr + 1) = default(IntPtr);
			Unsafe.Add(ref ip, intPtr + 2) = default(IntPtr);
			Unsafe.Add(ref ip, intPtr + 3) = default(IntPtr);
			Unsafe.Add(ref ip, intPtr + 4) = default(IntPtr);
			Unsafe.Add(ref ip, intPtr + 5) = default(IntPtr);
			Unsafe.Add(ref ip, intPtr + 6) = default(IntPtr);
			Unsafe.Add(ref ip, intPtr + 7) = default(IntPtr);
			intPtr = zero;
		}
		if ((zero = intPtr + 4).LessThanEqual(pointerSizeLength))
		{
			Unsafe.Add(ref ip, intPtr + 0) = default(IntPtr);
			Unsafe.Add(ref ip, intPtr + 1) = default(IntPtr);
			Unsafe.Add(ref ip, intPtr + 2) = default(IntPtr);
			Unsafe.Add(ref ip, intPtr + 3) = default(IntPtr);
			intPtr = zero;
		}
		if ((zero = intPtr + 2).LessThanEqual(pointerSizeLength))
		{
			Unsafe.Add(ref ip, intPtr + 0) = default(IntPtr);
			Unsafe.Add(ref ip, intPtr + 1) = default(IntPtr);
			intPtr = zero;
		}
		if ((intPtr + 1).LessThanEqual(pointerSizeLength))
		{
			Unsafe.Add(ref ip, intPtr) = default(IntPtr);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private unsafe static bool LessThanEqual(this IntPtr index, UIntPtr length)
	{
		if (sizeof(UIntPtr) != 4)
		{
			return (long)index <= (long)(ulong)length;
		}
		return (int)index <= (int)(uint)length;
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;

internal struct ComparerComparable<T, TComparer> : IComparable<T> where TComparer : IComparer<T>
{
	private readonly T _value;

	private readonly TComparer _comparer;

	public ComparerComparable(T value, TComparer comparer)
	{
		_value = value;
		_comparer = comparer;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int CompareTo(T other)
	{
		return _comparer.Compare(_value, other);
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 64)]
private struct Reg64
{
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 32)]
private struct Reg32
{
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 16)]
private struct Reg16
{
}


using System.Runtime.CompilerServices;

public static class PerTypeValues<T>
{
	public static readonly bool IsReferenceOrContainsReferences = IsReferenceOrContainsReferencesCore(typeof(T));

	public static readonly T[] EmptyArray = new T[0];

	public static readonly IntPtr ArrayAdjustment = MeasureArrayAdjustment();

	private static IntPtr MeasureArrayAdjustment()
	{
		T[] array = new T[1];
		return Unsafe.ByteOffset(ref Unsafe.As<Pinnable<T>>(array).Data, ref array[0]);
	}
}


using System;
using System.Runtime.CompilerServices;

internal struct NUInt
{
	private unsafe readonly void* _value;

	private unsafe NUInt(uint value)
	{
		_value = (void*)value;
	}

	private unsafe NUInt(ulong value)
	{
		_value = (void*)value;
	}

	public static implicit operator NUInt(uint value)
	{
		return new NUInt(value);
	}

	public unsafe static implicit operator IntPtr(NUInt value)
	{
		return (IntPtr)value._value;
	}

	public static explicit operator NUInt(int value)
	{
		return new NUInt((uint)value);
	}

	public unsafe static explicit operator void*(NUInt value)
	{
		return value._value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static NUInt operator *(NUInt left, NUInt right)
	{
		if (sizeof(IntPtr) != 4)
		{
			return new NUInt((ulong)left._value * (ulong)right._value);
		}
		return new NUInt((uint)((int)left._value * (int)right._value));
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential)]
internal sealed class Pinnable<T>
{
	public T Data;
}


using System;

internal static class NotImplemented
{
	internal static Exception ByDesign => new NotImplementedException();

	internal static Exception ByDesignWithMessage(string message)
	{
		return new NotImplementedException(message);
	}

	internal static Exception ActiveIssue(string issue)
	{
		return new NotImplementedException();
	}
}


internal struct MutableDecimal
{
	public uint Flags;

	public uint High;

	public uint Low;

	public uint Mid;

	private const uint SignMask = 2147483648u;

	private const uint ScaleMask = 16711680u;

	private const int ScaleShift = 16;

	public bool IsNegative
	{
		get
		{
			return (Flags & 0x80000000u) != 0;
		}
		set
		{
			Flags = (Flags & 0x7FFFFFFF) | (uint)(value ? int.MinValue : 0);
		}
	}

	public int Scale
	{
		get
		{
			return (byte)(Flags >> 16);
		}
		set
		{
			Flags = (Flags & 0xFF00FFFFu) | (uint)(value << 16);
		}
	}
}


using System;
using System.Buffers;

internal static class SequenceMarshal
{
	public static bool TryGetReadOnlySequenceSegment<T>(ReadOnlySequence<T> sequence, out ReadOnlySequenceSegment<T> startSegment, out int startIndex, out ReadOnlySequenceSegment<T> endSegment, out int endIndex)
	{
		return sequence.TryGetReadOnlySequenceSegment(out startSegment, out startIndex, out endSegment, out endIndex);
	}

	public static bool TryGetArray<T>(ReadOnlySequence<T> sequence, out ArraySegment<T> segment)
	{
		return sequence.TryGetArray(out segment);
	}

	public static bool TryGetReadOnlyMemory<T>(ReadOnlySequence<T> sequence, out ReadOnlyMemory<T> memory)
	{
		if (!sequence.IsSingleSegment)
		{
			memory = default(ReadOnlyMemory<T>);
			return false;
		}
		memory = sequence.First;
		return true;
	}

	internal static bool TryGetString(ReadOnlySequence<char> sequence, out string text, out int start, out int length)
	{
		return sequence.TryGetString(out text, out start, out length);
	}
}


using System;
using System.Buffers;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

internal static class MemoryMarshal
{
	public static bool TryGetArray<T>(ReadOnlyMemory<T> memory, out ArraySegment<T> segment)
	{
		int start;
		int length;
		object objectStartLength = memory.GetObjectStartLength(out start, out length);
		if (start < 0)
		{
			if (((MemoryManager<T>)objectStartLength).TryGetArray(out var segment2))
			{
				segment = new ArraySegment<T>(segment2.Array, segment2.Offset + (start & 0x7FFFFFFF), length);
				return true;
			}
		}
		else if (objectStartLength is T[] array)
		{
			segment = new ArraySegment<T>(array, start, length & 0x7FFFFFFF);
			return true;
		}
		if ((length & 0x7FFFFFFF) == 0)
		{
			segment = new ArraySegment<T>(System.SpanHelpers.PerTypeValues<T>.EmptyArray);
			return true;
		}
		segment = default(ArraySegment<T>);
		return false;
	}

	public static bool TryGetMemoryManager<T, TManager>(ReadOnlyMemory<T> memory, out TManager manager) where TManager : MemoryManager<T>
	{
		int start;
		int length;
		TManager val = (manager = memory.GetObjectStartLength(out start, out length) as TManager);
		return manager != null;
	}

	public static bool TryGetMemoryManager<T, TManager>(ReadOnlyMemory<T> memory, out TManager manager, out int start, out int length) where TManager : MemoryManager<T>
	{
		TManager val = (manager = memory.GetObjectStartLength(out start, out length) as TManager);
		start &= int.MaxValue;
		if (manager == null)
		{
			start = 0;
			length = 0;
			return false;
		}
		return true;
	}

	public static IEnumerable<T> ToEnumerable<T>(ReadOnlyMemory<T> memory)
	{
		for (int i = 0; i < memory.Length; i++)
		{
			yield return memory.Span[i];
		}
	}

	public static bool TryGetString(ReadOnlyMemory<char> memory, out string text, out int start, out int length)
	{
		if (memory.GetObjectStartLength(out var start2, out var length2) is string text2)
		{
			text = text2;
			start = start2;
			length = length2;
			return true;
		}
		text = null;
		start = 0;
		length = 0;
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static T Read<T>(ReadOnlySpan<byte> source) where T : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		if (Unsafe.SizeOf<T>() > source.Length)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.length);
		}
		return Unsafe.ReadUnaligned<T>(ref GetReference(source));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryRead<T>(ReadOnlySpan<byte> source, out T value) where T : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		if (Unsafe.SizeOf<T>() > (uint)source.Length)
		{
			value = default(T);
			return false;
		}
		value = Unsafe.ReadUnaligned<T>(ref GetReference(source));
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Write<T>(Span<byte> destination, ref T value) where T : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		if ((uint)Unsafe.SizeOf<T>() > (uint)destination.Length)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.length);
		}
		Unsafe.WriteUnaligned(ref GetReference(destination), value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryWrite<T>(Span<byte> destination, ref T value) where T : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		if (Unsafe.SizeOf<T>() > (uint)destination.Length)
		{
			return false;
		}
		Unsafe.WriteUnaligned(ref GetReference(destination), value);
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Memory<T> CreateFromPinnedArray<T>(T[] array, int start, int length)
	{
		if (array == null)
		{
			if (start != 0 || length != 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException();
			}
			return default(Memory<T>);
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArrayTypeMismatchException();
		}
		if ((uint)start > (uint)array.Length || (uint)length > (uint)(array.Length - start))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		return new Memory<T>((object)array, start, length | int.MinValue);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Span<byte> AsBytes<T>(Span<T> span) where T : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		int length = checked(span.Length * Unsafe.SizeOf<T>());
		return new Span<byte>(Unsafe.As<Pinnable<byte>>(span.Pinnable), span.ByteOffset, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ReadOnlySpan<byte> AsBytes<T>(ReadOnlySpan<T> span) where T : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		int length = checked(span.Length * Unsafe.SizeOf<T>());
		return new ReadOnlySpan<byte>(Unsafe.As<Pinnable<byte>>(span.Pinnable), span.ByteOffset, length);
	}

	public static Memory<T> AsMemory<T>(ReadOnlyMemory<T> memory)
	{
		return Unsafe.As<ReadOnlyMemory<T>, Memory<T>>(ref memory);
	}

	public unsafe static ref T GetReference<T>(Span<T> span)
	{
		if (span.Pinnable == null)
		{
			return ref Unsafe.AsRef<T>(span.ByteOffset.ToPointer());
		}
		return ref Unsafe.AddByteOffset(ref span.Pinnable.Data, span.ByteOffset);
	}

	public unsafe static ref T GetReference<T>(ReadOnlySpan<T> span)
	{
		if (span.Pinnable == null)
		{
			return ref Unsafe.AsRef<T>(span.ByteOffset.ToPointer());
		}
		return ref Unsafe.AddByteOffset(ref span.Pinnable.Data, span.ByteOffset);
	}

	public static Span<TTo> Cast<TFrom, TTo>(Span<TFrom> span) where TFrom : struct where TTo : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<TFrom>())
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(TFrom));
		}
		if (System.SpanHelpers.IsReferenceOrContainsReferences<TTo>())
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(TTo));
		}
		checked
		{
			int length = (int)unchecked(checked(unchecked((long)span.Length) * unchecked((long)Unsafe.SizeOf<TFrom>())) / Unsafe.SizeOf<TTo>());
			return new Span<TTo>(Unsafe.As<Pinnable<TTo>>(span.Pinnable), span.ByteOffset, length);
		}
	}

	public static ReadOnlySpan<TTo> Cast<TFrom, TTo>(ReadOnlySpan<TFrom> span) where TFrom : struct where TTo : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<TFrom>())
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(TFrom));
		}
		if (System.SpanHelpers.IsReferenceOrContainsReferences<TTo>())
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(TTo));
		}
		checked
		{
			int length = (int)unchecked(checked(unchecked((long)span.Length) * unchecked((long)Unsafe.SizeOf<TFrom>())) / Unsafe.SizeOf<TTo>());
			return new ReadOnlySpan<TTo>(Unsafe.As<Pinnable<TTo>>(span.Pinnable), span.ByteOffset, length);
		}
	}
}


using System;
using System.Buffers;
using System.Runtime.CompilerServices;

internal sealed class ArrayMemoryPool<T> : MemoryPool<T>
{
	private sealed class ArrayMemoryPoolBuffer : IMemoryOwner<T>, IDisposable
	{
		private T[] _array;

		public Memory<T> Memory
		{
			get
			{
				T[] array = _array;
				if (array == null)
				{
					<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowObjectDisposedException_ArrayMemoryPoolBuffer();
				}
				return new Memory<T>(array);
			}
		}

		public ArrayMemoryPoolBuffer(int size)
		{
			_array = ArrayPool<T>.Shared.Rent(size);
		}

		public void Dispose()
		{
			T[] array = _array;
			if (array != null)
			{
				_array = null;
				ArrayPool<T>.Shared.Return(array);
			}
		}
	}

	private const int s_maxBufferSize = int.MaxValue;

	public sealed override int MaxBufferSize => int.MaxValue;

	public sealed override IMemoryOwner<T> Rent(int minimumBufferSize = -1)
	{
		if (minimumBufferSize == -1)
		{
			minimumBufferSize = 1 + 4095 / Unsafe.SizeOf<T>();
		}
		else if ((uint)minimumBufferSize > 2147483647u)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.minimumBufferSize);
		}
		return new ArrayMemoryPoolBuffer(minimumBufferSize);
	}

	protected sealed override void Dispose(bool disposing)
	{
	}
}


private sealed class ArrayMemoryPoolBuffer : IMemoryOwner<T>, IDisposable
{
	private T[] _array;

	public Memory<T> Memory
	{
		get
		{
			T[] array = _array;
			if (array == null)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowObjectDisposedException_ArrayMemoryPoolBuffer();
			}
			return new Memory<T>(array);
		}
	}

	public ArrayMemoryPoolBuffer(int size)
	{
		_array = ArrayPool<T>.Shared.Rent(size);
	}

	public void Dispose()
	{
		T[] array = _array;
		if (array != null)
		{
			_array = null;
			ArrayPool<T>.Shared.Return(array);
		}
	}
}


using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class BuffersExtensions
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static SequencePosition? PositionOf<T>([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] this ref ReadOnlySequence<T> source, T value) where T : IEquatable<T>
	{
		if (source.IsSingleSegment)
		{
			int num = source.First.Span.IndexOf(value);
			if (num != -1)
			{
				return source.GetPosition(num);
			}
			return null;
		}
		return PositionOfMultiSegment(ref source, value);
	}

	private static SequencePosition? PositionOfMultiSegment<T>([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref ReadOnlySequence<T> source, T value) where T : IEquatable<T>
	{
		SequencePosition position = source.Start;
		SequencePosition origin = position;
		ReadOnlyMemory<T> memory;
		while (source.TryGet(ref position, out memory))
		{
			int num = memory.Span.IndexOf(value);
			if (num != -1)
			{
				return source.GetPosition(num, origin);
			}
			if (position.GetObject() == null)
			{
				break;
			}
			origin = position;
		}
		return null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void CopyTo<T>([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] this ref ReadOnlySequence<T> source, Span<T> destination)
	{
		if (source.Length > destination.Length)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.destination);
		}
		if (source.IsSingleSegment)
		{
			source.First.Span.CopyTo(destination);
		}
		else
		{
			CopyToMultiSegment(ref source, destination);
		}
	}

	private static void CopyToMultiSegment<T>([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref ReadOnlySequence<T> sequence, Span<T> destination)
	{
		SequencePosition position = sequence.Start;
		ReadOnlyMemory<T> memory;
		while (sequence.TryGet(ref position, out memory))
		{
			ReadOnlySpan<T> span = memory.Span;
			span.CopyTo(destination);
			if (position.GetObject() != null)
			{
				destination = destination.Slice(span.Length);
				continue;
			}
			break;
		}
	}

	public static T[] ToArray<T>([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] this ref ReadOnlySequence<T> sequence)
	{
		T[] array = new T[sequence.Length];
		CopyTo(ref sequence, array);
		return array;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Write<T>(this IBufferWriter<T> writer, ReadOnlySpan<T> value)
	{
		Span<T> span = writer.GetSpan();
		if (value.Length <= span.Length)
		{
			value.CopyTo(span);
			writer.Advance(value.Length);
		}
		else
		{
			WriteMultiSegment(writer, ref value, span);
		}
	}

	private static void WriteMultiSegment<T>(IBufferWriter<T> writer, [In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref ReadOnlySpan<T> source, Span<T> destination)
	{
		ReadOnlySpan<T> readOnlySpan = source;
		while (true)
		{
			int num = Math.Min(destination.Length, readOnlySpan.Length);
			readOnlySpan.Slice(0, num).CopyTo(destination);
			writer.Advance(num);
			readOnlySpan = readOnlySpan.Slice(num);
			if (readOnlySpan.Length > 0)
			{
				destination = writer.GetSpan(readOnlySpan.Length);
				continue;
			}
			break;
		}
	}
}


using System;

internal interface IBufferWriter<T>
{
	void Advance(int count);

	Memory<T> GetMemory(int sizeHint = 0);

	Span<T> GetSpan(int sizeHint = 0);
}


using System;
using System.Buffers;

internal abstract class MemoryPool<T> : IDisposable
{
	private static readonly MemoryPool<T> s_shared = new System.Buffers.ArrayMemoryPool<T>();

	public static MemoryPool<T> Shared => s_shared;

	public abstract int MaxBufferSize { get; }

	public abstract IMemoryOwner<T> Rent(int minBufferSize = -1);

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	protected abstract void Dispose(bool disposing);
}


internal enum OperationStatus
{
	Done,
	DestinationTooSmall,
	NeedMoreData,
	InvalidData
}


using System;
using System.Buffers;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[DebuggerDisplay("{ToString(),raw}")]
[DebuggerTypeProxy(typeof(System.Buffers.ReadOnlySequenceDebugView<>))]
[<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
internal struct ReadOnlySequence<T>
{
	public struct Enumerator
	{
		private readonly ReadOnlySequence<T> _sequence;

		private SequencePosition _next;

		private ReadOnlyMemory<T> _currentMemory;

		public ReadOnlyMemory<T> Current => _currentMemory;

		public Enumerator([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref ReadOnlySequence<T> sequence)
		{
			_currentMemory = default(ReadOnlyMemory<T>);
			_next = sequence.Start;
			_sequence = sequence;
		}

		public bool MoveNext()
		{
			if (_next.GetObject() == null)
			{
				return false;
			}
			return _sequence.TryGet(ref _next, out _currentMemory);
		}
	}

	private enum SequenceType
	{
		MultiSegment,
		Array,
		MemoryManager,
		String,
		Empty
	}

	private readonly SequencePosition _sequenceStart;

	private readonly SequencePosition _sequenceEnd;

	public static readonly ReadOnlySequence<T> Empty = new ReadOnlySequence<T>(System.SpanHelpers.PerTypeValues<T>.EmptyArray);

	public long Length => GetLength();

	public bool IsEmpty => Length == 0;

	public bool IsSingleSegment
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return _sequenceStart.GetObject() == _sequenceEnd.GetObject();
		}
	}

	public ReadOnlyMemory<T> First => GetFirstBuffer();

	public SequencePosition Start => _sequenceStart;

	public SequencePosition End => _sequenceEnd;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private ReadOnlySequence(object startSegment, int startIndexAndFlags, object endSegment, int endIndexAndFlags)
	{
		_sequenceStart = new SequencePosition(startSegment, startIndexAndFlags);
		_sequenceEnd = new SequencePosition(endSegment, endIndexAndFlags);
	}

	public ReadOnlySequence(ReadOnlySequenceSegment<T> startSegment, int startIndex, ReadOnlySequenceSegment<T> endSegment, int endIndex)
	{
		if (startSegment == null || endSegment == null || (startSegment != endSegment && startSegment.RunningIndex > endSegment.RunningIndex) || (uint)startSegment.Memory.Length < (uint)startIndex || (uint)endSegment.Memory.Length < (uint)endIndex || (startSegment == endSegment && endIndex < startIndex))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentValidationException(startSegment, startIndex, endSegment);
		}
		_sequenceStart = new SequencePosition(startSegment, System.Buffers.ReadOnlySequence.SegmentToSequenceStart(startIndex));
		_sequenceEnd = new SequencePosition(endSegment, System.Buffers.ReadOnlySequence.SegmentToSequenceEnd(endIndex));
	}

	public ReadOnlySequence(T[] array)
	{
		if (array == null)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentNullException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.array);
		}
		_sequenceStart = new SequencePosition(array, System.Buffers.ReadOnlySequence.ArrayToSequenceStart(0));
		_sequenceEnd = new SequencePosition(array, System.Buffers.ReadOnlySequence.ArrayToSequenceEnd(array.Length));
	}

	public ReadOnlySequence(T[] array, int start, int length)
	{
		if (array == null || (uint)start > (uint)array.Length || (uint)length > (uint)(array.Length - start))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentValidationException(array, start);
		}
		_sequenceStart = new SequencePosition(array, System.Buffers.ReadOnlySequence.ArrayToSequenceStart(start));
		_sequenceEnd = new SequencePosition(array, System.Buffers.ReadOnlySequence.ArrayToSequenceEnd(start + length));
	}

	public ReadOnlySequence(ReadOnlyMemory<T> memory)
	{
		ArraySegment<T> segment;
		if (MemoryMarshal.TryGetMemoryManager<T, MemoryManager<T>>(memory, out var manager, out var start, out var length))
		{
			_sequenceStart = new SequencePosition(manager, System.Buffers.ReadOnlySequence.MemoryManagerToSequenceStart(start));
			_sequenceEnd = new SequencePosition(manager, System.Buffers.ReadOnlySequence.MemoryManagerToSequenceEnd(start + length));
		}
		else if (MemoryMarshal.TryGetArray(memory, out segment))
		{
			T[] array = segment.Array;
			int offset = segment.Offset;
			_sequenceStart = new SequencePosition(array, System.Buffers.ReadOnlySequence.ArrayToSequenceStart(offset));
			_sequenceEnd = new SequencePosition(array, System.Buffers.ReadOnlySequence.ArrayToSequenceEnd(offset + segment.Count));
		}
		else if (typeof(T) == typeof(char))
		{
			if (!MemoryMarshal.TryGetString((ReadOnlyMemory<char>)(object)memory, out var text, out var start2, out length))
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowInvalidOperationException();
			}
			_sequenceStart = new SequencePosition(text, System.Buffers.ReadOnlySequence.StringToSequenceStart(start2));
			_sequenceEnd = new SequencePosition(text, System.Buffers.ReadOnlySequence.StringToSequenceEnd(start2 + length));
		}
		else
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowInvalidOperationException();
			_sequenceStart = default(SequencePosition);
			_sequenceEnd = default(SequencePosition);
		}
	}

	public ReadOnlySequence<T> Slice(long start, long length)
	{
		if (start < 0 || length < 0)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowStartOrEndArgumentValidationException(start);
		}
		int index = GetIndex(ref _sequenceStart);
		int index2 = GetIndex(ref _sequenceEnd);
		object @object = _sequenceStart.GetObject();
		object object2 = _sequenceEnd.GetObject();
		SequencePosition position;
		SequencePosition end;
		if (@object != object2)
		{
			ReadOnlySequenceSegment<T> readOnlySequenceSegment = (ReadOnlySequenceSegment<T>)@object;
			int num = readOnlySequenceSegment.Memory.Length - index;
			if (num > start)
			{
				index += (int)start;
				position = new SequencePosition(@object, index);
				end = GetEndPosition(readOnlySequenceSegment, @object, index, object2, index2, length);
			}
			else
			{
				if (num < 0)
				{
					<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
				}
				position = SeekMultiSegment(readOnlySequenceSegment.Next, object2, index2, start - num, <cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
				int index3 = GetIndex(ref position);
				object object3 = position.GetObject();
				if (object3 != object2)
				{
					end = GetEndPosition((ReadOnlySequenceSegment<T>)object3, object3, index3, object2, index2, length);
				}
				else
				{
					if (index2 - index3 < length)
					{
						<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowStartOrEndArgumentValidationException(0L);
					}
					end = new SequencePosition(object3, index3 + (int)length);
				}
			}
		}
		else
		{
			if (index2 - index < start)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowStartOrEndArgumentValidationException(-1L);
			}
			index += (int)start;
			position = new SequencePosition(@object, index);
			if (index2 - index < length)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowStartOrEndArgumentValidationException(0L);
			}
			end = new SequencePosition(@object, index + (int)length);
		}
		return SliceImpl(ref position, ref end);
	}

	public ReadOnlySequence<T> Slice(long start, SequencePosition end)
	{
		if (start < 0)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowStartOrEndArgumentValidationException(start);
		}
		uint index = (uint)GetIndex(ref end);
		object @object = end.GetObject();
		uint index2 = (uint)GetIndex(ref _sequenceStart);
		object object2 = _sequenceStart.GetObject();
		uint index3 = (uint)GetIndex(ref _sequenceEnd);
		object object3 = _sequenceEnd.GetObject();
		if (object2 == object3)
		{
			if (!InRange(index, index2, index3))
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
			}
			if (index - index2 < start)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowStartOrEndArgumentValidationException(-1L);
			}
		}
		else
		{
			ReadOnlySequenceSegment<T> readOnlySequenceSegment = (ReadOnlySequenceSegment<T>)object2;
			ulong num = (ulong)(readOnlySequenceSegment.RunningIndex + index2);
			ulong num2 = (ulong)(((ReadOnlySequenceSegment<T>)@object).RunningIndex + index);
			if (!InRange(num2, num, (ulong)(((ReadOnlySequenceSegment<T>)object3).RunningIndex + index3)))
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
			}
			if ((ulong)((long)num + start) > num2)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
			}
			int num3 = readOnlySequenceSegment.Memory.Length - (int)index2;
			if (num3 <= start)
			{
				if (num3 < 0)
				{
					<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
				}
				SequencePosition start2 = SeekMultiSegment(readOnlySequenceSegment.Next, @object, (int)index, start - num3, <cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
				return SliceImpl(ref start2, ref end);
			}
		}
		SequencePosition start3 = new SequencePosition(object2, (int)index2 + (int)start);
		return SliceImpl(ref start3, ref end);
	}

	public ReadOnlySequence<T> Slice(SequencePosition start, long length)
	{
		uint index = (uint)GetIndex(ref start);
		object @object = start.GetObject();
		uint index2 = (uint)GetIndex(ref _sequenceStart);
		object object2 = _sequenceStart.GetObject();
		uint index3 = (uint)GetIndex(ref _sequenceEnd);
		object object3 = _sequenceEnd.GetObject();
		if (object2 == object3)
		{
			if (!InRange(index, index2, index3))
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
			}
			if (length < 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowStartOrEndArgumentValidationException(0L);
			}
			if (index3 - index < length)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowStartOrEndArgumentValidationException(0L);
			}
		}
		else
		{
			ReadOnlySequenceSegment<T> readOnlySequenceSegment = (ReadOnlySequenceSegment<T>)@object;
			ulong num = (ulong)(readOnlySequenceSegment.RunningIndex + index);
			ulong start2 = (ulong)(((ReadOnlySequenceSegment<T>)object2).RunningIndex + index2);
			ulong num2 = (ulong)(((ReadOnlySequenceSegment<T>)object3).RunningIndex + index3);
			if (!InRange(num, start2, num2))
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
			}
			if (length < 0)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowStartOrEndArgumentValidationException(0L);
			}
			if ((ulong)((long)num + length) > num2)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.length);
			}
			int num3 = readOnlySequenceSegment.Memory.Length - (int)index;
			if (num3 < length)
			{
				if (num3 < 0)
				{
					<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
				}
				SequencePosition end = SeekMultiSegment(readOnlySequenceSegment.Next, object3, (int)index3, length - num3, <cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.length);
				return SliceImpl(ref start, ref end);
			}
		}
		SequencePosition end2 = new SequencePosition(@object, (int)index + (int)length);
		return SliceImpl(ref start, ref end2);
	}

	public ReadOnlySequence<T> Slice(int start, int length)
	{
		return Slice((long)start, (long)length);
	}

	public ReadOnlySequence<T> Slice(int start, SequencePosition end)
	{
		return Slice((long)start, end);
	}

	public ReadOnlySequence<T> Slice(SequencePosition start, int length)
	{
		return Slice(start, (long)length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlySequence<T> Slice(SequencePosition start, SequencePosition end)
	{
		BoundsCheck((uint)GetIndex(ref start), start.GetObject(), (uint)GetIndex(ref end), end.GetObject());
		return SliceImpl(ref start, ref end);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlySequence<T> Slice(SequencePosition start)
	{
		BoundsCheck(ref start);
		return SliceImpl(ref start, ref _sequenceEnd);
	}

	public ReadOnlySequence<T> Slice(long start)
	{
		if (start < 0)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowStartOrEndArgumentValidationException(start);
		}
		if (start == 0L)
		{
			return this;
		}
		SequencePosition start2 = Seek(ref _sequenceStart, ref _sequenceEnd, start, <cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.start);
		return SliceImpl(ref start2, ref _sequenceEnd);
	}

	public override string ToString()
	{
		if (typeof(T) == typeof(char))
		{
			ReadOnlySequence<T> source = this;
			ReadOnlySequence<char> sequence = Unsafe.As<ReadOnlySequence<T>, ReadOnlySequence<char>>(ref source);
			if (SequenceMarshal.TryGetString(sequence, out var text, out var start, out var length))
			{
				return text.Substring(start, length);
			}
			if (Length < int.MaxValue)
			{
				return new string(BuffersExtensions.ToArray(ref sequence));
			}
		}
		return $"System.Buffers.ReadOnlySequence<{typeof(T).Name}>[{Length}]";
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(ref this);
	}

	public SequencePosition GetPosition(long offset)
	{
		return GetPosition(offset, _sequenceStart);
	}

	public SequencePosition GetPosition(long offset, SequencePosition origin)
	{
		if (offset < 0)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_OffsetOutOfRange();
		}
		return Seek(ref origin, ref _sequenceEnd, offset, <cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.offset);
	}

	public bool TryGet(ref SequencePosition position, out ReadOnlyMemory<T> memory, bool advance = true)
	{
		SequencePosition next;
		bool result = TryGetBuffer(ref position, out memory, out next);
		if (advance)
		{
			position = next;
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool TryGetBuffer([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref SequencePosition position, out ReadOnlyMemory<T> memory, out SequencePosition next)
	{
		object @object = position.GetObject();
		next = default(SequencePosition);
		if (@object == null)
		{
			memory = default(ReadOnlyMemory<T>);
			return false;
		}
		SequenceType sequenceType = GetSequenceType();
		object object2 = _sequenceEnd.GetObject();
		int index = GetIndex(ref position);
		int index2 = GetIndex(ref _sequenceEnd);
		if (sequenceType == SequenceType.MultiSegment)
		{
			ReadOnlySequenceSegment<T> readOnlySequenceSegment = (ReadOnlySequenceSegment<T>)@object;
			if (readOnlySequenceSegment != object2)
			{
				ReadOnlySequenceSegment<T> next2 = readOnlySequenceSegment.Next;
				if (next2 == null)
				{
					<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowInvalidOperationException_EndPositionNotReached();
				}
				next = new SequencePosition(next2, 0);
				memory = readOnlySequenceSegment.Memory.Slice(index);
			}
			else
			{
				memory = readOnlySequenceSegment.Memory.Slice(index, index2 - index);
			}
		}
		else
		{
			if (@object != object2)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowInvalidOperationException_EndPositionNotReached();
			}
			if (sequenceType == SequenceType.Array)
			{
				memory = new ReadOnlyMemory<T>((T[])@object, index, index2 - index);
			}
			else if (typeof(T) == typeof(char) && sequenceType == SequenceType.String)
			{
				memory = (ReadOnlyMemory<T>)(object)MemoryExtensions.AsMemory((string)@object, index, index2 - index);
			}
			else
			{
				memory = ((MemoryManager<T>)@object).Memory.Slice(index, index2 - index);
			}
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private ReadOnlyMemory<T> GetFirstBuffer()
	{
		object @object = _sequenceStart.GetObject();
		if (@object == null)
		{
			return default(ReadOnlyMemory<T>);
		}
		int integer = _sequenceStart.GetInteger();
		int integer2 = _sequenceEnd.GetInteger();
		bool flag = @object != _sequenceEnd.GetObject();
		if (integer >= 0)
		{
			if (integer2 >= 0)
			{
				ReadOnlyMemory<T> memory = ((ReadOnlySequenceSegment<T>)@object).Memory;
				if (flag)
				{
					return memory.Slice(integer);
				}
				return memory.Slice(integer, integer2 - integer);
			}
			if (flag)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowInvalidOperationException_EndPositionNotReached();
			}
			return new ReadOnlyMemory<T>((T[])@object, integer, (integer2 & 0x7FFFFFFF) - integer);
		}
		if (flag)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowInvalidOperationException_EndPositionNotReached();
		}
		if (typeof(T) == typeof(char) && integer2 < 0)
		{
			return (ReadOnlyMemory<T>)(object)MemoryExtensions.AsMemory((string)@object, integer & 0x7FFFFFFF, integer2 - integer);
		}
		integer &= 0x7FFFFFFF;
		return ((MemoryManager<T>)@object).Memory.Slice(integer, integer2 - integer);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private SequencePosition Seek([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref SequencePosition start, [In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref SequencePosition end, long offset, <cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument argument)
	{
		int index = GetIndex(ref start);
		int index2 = GetIndex(ref end);
		object @object = start.GetObject();
		object object2 = end.GetObject();
		if (@object != object2)
		{
			ReadOnlySequenceSegment<T> readOnlySequenceSegment = (ReadOnlySequenceSegment<T>)@object;
			int num = readOnlySequenceSegment.Memory.Length - index;
			if (num <= offset)
			{
				if (num < 0)
				{
					<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
				}
				return SeekMultiSegment(readOnlySequenceSegment.Next, object2, index2, offset - num, argument);
			}
		}
		else if (index2 - index < offset)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(argument);
		}
		return new SequencePosition(@object, index + (int)offset);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static SequencePosition SeekMultiSegment(ReadOnlySequenceSegment<T> currentSegment, object endObject, int endIndex, long offset, <cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument argument)
	{
		while (true)
		{
			if (currentSegment != null && currentSegment != endObject)
			{
				int length = currentSegment.Memory.Length;
				if (length > offset)
				{
					break;
				}
				offset -= length;
				currentSegment = currentSegment.Next;
				continue;
			}
			if (currentSegment == null || endIndex < offset)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(argument);
			}
			break;
		}
		return new SequencePosition(currentSegment, (int)offset);
	}

	private void BoundsCheck([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref SequencePosition position)
	{
		uint index = (uint)GetIndex(ref position);
		uint index2 = (uint)GetIndex(ref _sequenceStart);
		uint index3 = (uint)GetIndex(ref _sequenceEnd);
		object @object = _sequenceStart.GetObject();
		object object2 = _sequenceEnd.GetObject();
		if (@object == object2)
		{
			if (!InRange(index, index2, index3))
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
			}
			return;
		}
		ulong start = (ulong)(((ReadOnlySequenceSegment<T>)@object).RunningIndex + index2);
		if (!InRange((ulong)(((ReadOnlySequenceSegment<T>)position.GetObject()).RunningIndex + index), start, (ulong)(((ReadOnlySequenceSegment<T>)object2).RunningIndex + index3)))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
		}
	}

	private void BoundsCheck(uint sliceStartIndex, object sliceStartObject, uint sliceEndIndex, object sliceEndObject)
	{
		uint index = (uint)GetIndex(ref _sequenceStart);
		uint index2 = (uint)GetIndex(ref _sequenceEnd);
		object @object = _sequenceStart.GetObject();
		object object2 = _sequenceEnd.GetObject();
		if (@object == object2)
		{
			if (sliceStartObject != sliceEndObject || sliceStartObject != @object || sliceStartIndex > sliceEndIndex || sliceStartIndex < index || sliceEndIndex > index2)
			{
				<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
			}
			return;
		}
		ulong num = (ulong)(((ReadOnlySequenceSegment<T>)sliceStartObject).RunningIndex + sliceStartIndex);
		ulong num2 = (ulong)(((ReadOnlySequenceSegment<T>)sliceEndObject).RunningIndex + sliceEndIndex);
		if (num > num2)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
		}
		if (num < (ulong)(((ReadOnlySequenceSegment<T>)@object).RunningIndex + index) || num2 > (ulong)(((ReadOnlySequenceSegment<T>)object2).RunningIndex + index2))
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
		}
	}

	private static SequencePosition GetEndPosition(ReadOnlySequenceSegment<T> startSegment, object startObject, int startIndex, object endObject, int endIndex, long length)
	{
		int num = startSegment.Memory.Length - startIndex;
		if (num > length)
		{
			return new SequencePosition(startObject, startIndex + (int)length);
		}
		if (num < 0)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
		}
		return SeekMultiSegment(startSegment.Next, endObject, endIndex, length - num, <cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private SequenceType GetSequenceType()
	{
		return (SequenceType)(-(2 * (_sequenceStart.GetInteger() >> 31) + (_sequenceEnd.GetInteger() >> 31)));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int GetIndex([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref SequencePosition position)
	{
		return position.GetInteger() & 0x7FFFFFFF;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private ReadOnlySequence<T> SliceImpl([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref SequencePosition start, [In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref SequencePosition end)
	{
		return new ReadOnlySequence<T>(start.GetObject(), GetIndex(ref start) | (_sequenceStart.GetInteger() & int.MinValue), end.GetObject(), GetIndex(ref end) | (_sequenceEnd.GetInteger() & int.MinValue));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private long GetLength()
	{
		int index = GetIndex(ref _sequenceStart);
		int index2 = GetIndex(ref _sequenceEnd);
		object @object = _sequenceStart.GetObject();
		object object2 = _sequenceEnd.GetObject();
		if (@object != object2)
		{
			ReadOnlySequenceSegment<T> readOnlySequenceSegment = (ReadOnlySequenceSegment<T>)@object;
			ReadOnlySequenceSegment<T> readOnlySequenceSegment2 = (ReadOnlySequenceSegment<T>)object2;
			return readOnlySequenceSegment2.RunningIndex + index2 - (readOnlySequenceSegment.RunningIndex + index);
		}
		return index2 - index;
	}

	internal bool TryGetReadOnlySequenceSegment(out ReadOnlySequenceSegment<T> startSegment, out int startIndex, out ReadOnlySequenceSegment<T> endSegment, out int endIndex)
	{
		object @object = _sequenceStart.GetObject();
		if (@object == null || GetSequenceType() != 0)
		{
			startSegment = null;
			startIndex = 0;
			endSegment = null;
			endIndex = 0;
			return false;
		}
		startSegment = (ReadOnlySequenceSegment<T>)@object;
		startIndex = GetIndex(ref _sequenceStart);
		endSegment = (ReadOnlySequenceSegment<T>)_sequenceEnd.GetObject();
		endIndex = GetIndex(ref _sequenceEnd);
		return true;
	}

	internal bool TryGetArray(out ArraySegment<T> segment)
	{
		if (GetSequenceType() != SequenceType.Array)
		{
			segment = default(ArraySegment<T>);
			return false;
		}
		int index = GetIndex(ref _sequenceStart);
		segment = new ArraySegment<T>((T[])_sequenceStart.GetObject(), index, GetIndex(ref _sequenceEnd) - index);
		return true;
	}

	internal bool TryGetString(out string text, out int start, out int length)
	{
		if (typeof(T) != typeof(char) || GetSequenceType() != SequenceType.String)
		{
			start = 0;
			length = 0;
			text = null;
			return false;
		}
		start = GetIndex(ref _sequenceStart);
		length = GetIndex(ref _sequenceEnd) - start;
		text = (string)_sequenceStart.GetObject();
		return true;
	}

	private static bool InRange(uint value, uint start, uint end)
	{
		return value - start <= end - start;
	}

	private static bool InRange(ulong value, ulong start, ulong end)
	{
		return value - start <= end - start;
	}
}


using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

public struct Enumerator
{
	private readonly ReadOnlySequence<T> _sequence;

	private SequencePosition _next;

	private ReadOnlyMemory<T> _currentMemory;

	public ReadOnlyMemory<T> Current => _currentMemory;

	public Enumerator([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref ReadOnlySequence<T> sequence)
	{
		_currentMemory = default(ReadOnlyMemory<T>);
		_next = sequence.Start;
		_sequence = sequence;
	}

	public bool MoveNext()
	{
		if (_next.GetObject() == null)
		{
			return false;
		}
		return _sequence.TryGet(ref _next, out _currentMemory);
	}
}


private enum SequenceType
{
	MultiSegment,
	Array,
	MemoryManager,
	String,
	Empty
}


using System.Runtime.CompilerServices;

internal static class ReadOnlySequence
{
	public const int FlagBitMask = int.MinValue;

	public const int IndexBitMask = int.MaxValue;

	public const int SegmentStartMask = 0;

	public const int SegmentEndMask = 0;

	public const int ArrayStartMask = 0;

	public const int ArrayEndMask = int.MinValue;

	public const int MemoryManagerStartMask = int.MinValue;

	public const int MemoryManagerEndMask = 0;

	public const int StringStartMask = int.MinValue;

	public const int StringEndMask = int.MinValue;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int SegmentToSequenceStart(int startIndex)
	{
		return startIndex | 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int SegmentToSequenceEnd(int endIndex)
	{
		return endIndex | 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int ArrayToSequenceStart(int startIndex)
	{
		return startIndex | 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int ArrayToSequenceEnd(int endIndex)
	{
		return endIndex | int.MinValue;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int MemoryManagerToSequenceStart(int startIndex)
	{
		return startIndex | int.MinValue;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int MemoryManagerToSequenceEnd(int endIndex)
	{
		return endIndex | 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int StringToSequenceStart(int startIndex)
	{
		return startIndex | int.MinValue;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int StringToSequenceEnd(int endIndex)
	{
		return endIndex | int.MinValue;
	}
}


using System;
using System.Buffers;
using System.Diagnostics;

internal sealed class ReadOnlySequenceDebugView<T>
{
	[DebuggerDisplay("Count: {Segments.Length}", Name = "Segments")]
	public struct ReadOnlySequenceDebugViewSegments
	{
		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		public ReadOnlyMemory<T>[] Segments { get; set; }
	}

	private readonly T[] _array;

	private readonly ReadOnlySequenceDebugViewSegments _segments;

	public ReadOnlySequenceDebugViewSegments BufferSegments => _segments;

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	public T[] Items => _array;

	public ReadOnlySequenceDebugView(ReadOnlySequence<T> sequence)
	{
		_array = BuffersExtensions.ToArray(ref sequence);
		int num = 0;
		ReadOnlySequence<T>.Enumerator enumerator = sequence.GetEnumerator();
		while (enumerator.MoveNext())
		{
			ReadOnlyMemory<T> current = enumerator.Current;
			num++;
		}
		ReadOnlyMemory<T>[] array = new ReadOnlyMemory<T>[num];
		int num2 = 0;
		ReadOnlySequence<T>.Enumerator enumerator2 = sequence.GetEnumerator();
		while (enumerator2.MoveNext())
		{
			ReadOnlyMemory<T> current2 = enumerator2.Current;
			array[num2] = current2;
			num2++;
		}
		_segments = new ReadOnlySequenceDebugViewSegments
		{
			Segments = array
		};
	}
}


using System.Diagnostics;

[DebuggerDisplay("Count: {Segments.Length}", Name = "Segments")]
public struct ReadOnlySequenceDebugViewSegments
{
	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	public ReadOnlyMemory<T>[] Segments { get; set; }
}


using System;
using System.Buffers;

internal abstract class ReadOnlySequenceSegment<T>
{
	public ReadOnlyMemory<T> Memory { get; protected set; }

	public ReadOnlySequenceSegment<T> Next { get; protected set; }

	public long RunningIndex { get; protected set; }
}


using System;
using System.Buffers;
using System.Runtime.CompilerServices;

[<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly]
internal struct StandardFormat : IEquatable<StandardFormat>
{
	public const byte NoPrecision = byte.MaxValue;

	public const byte MaxPrecision = 99;

	private readonly byte _format;

	private readonly byte _precision;

	public char Symbol => (char)_format;

	public byte Precision => _precision;

	public bool HasPrecision => _precision != byte.MaxValue;

	public bool IsDefault
	{
		get
		{
			if (_format == 0)
			{
				return _precision == 0;
			}
			return false;
		}
	}

	public StandardFormat(char symbol, byte precision = byte.MaxValue)
	{
		if (precision != byte.MaxValue && precision > 99)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_PrecisionTooLarge();
		}
		if (symbol != (byte)symbol)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException_SymbolDoesNotFit();
		}
		_format = (byte)symbol;
		_precision = precision;
	}

	public static implicit operator StandardFormat(char symbol)
	{
		return new StandardFormat(symbol);
	}

	public static StandardFormat Parse(ReadOnlySpan<char> format)
	{
		if (format.Length == 0)
		{
			return default(StandardFormat);
		}
		char symbol = format[0];
		byte precision;
		if (format.Length == 1)
		{
			precision = byte.MaxValue;
		}
		else
		{
			uint num = 0u;
			for (int i = 1; i < format.Length; i++)
			{
				uint num2 = (uint)(format[i] - 48);
				if (num2 > 9)
				{
					throw new FormatException(<c1e4ce84-b725-4d32-90ca-a752f1fa7530>SR.Format(<c1e4ce84-b725-4d32-90ca-a752f1fa7530>SR.Argument_CannotParsePrecision, (byte)99));
				}
				num = num * 10 + num2;
				if (num > 99)
				{
					throw new FormatException(<c1e4ce84-b725-4d32-90ca-a752f1fa7530>SR.Format(<c1e4ce84-b725-4d32-90ca-a752f1fa7530>SR.Argument_PrecisionTooLarge, (byte)99));
				}
			}
			precision = (byte)num;
		}
		return new StandardFormat(symbol, precision);
	}

	public static StandardFormat Parse(string format)
	{
		if (format != null)
		{
			return Parse(MemoryExtensions.AsSpan(format));
		}
		return default(StandardFormat);
	}

	public override bool Equals(object obj)
	{
		if (obj is StandardFormat other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		byte format = _format;
		int hashCode = format.GetHashCode();
		format = _precision;
		return hashCode ^ format.GetHashCode();
	}

	public bool Equals(StandardFormat other)
	{
		if (_format == other._format)
		{
			return _precision == other._precision;
		}
		return false;
	}

	public unsafe override string ToString()
	{
		char* ptr = stackalloc char[4];
		int length = 0;
		char symbol = Symbol;
		if (symbol != 0)
		{
			ptr[length++] = symbol;
			byte b = Precision;
			if (b != byte.MaxValue)
			{
				if (b >= 100)
				{
					ptr[length++] = (char)(48 + b / 100 % 10);
					b %= 100;
				}
				if (b >= 10)
				{
					ptr[length++] = (char)(48 + b / 10 % 10);
					b %= 10;
				}
				ptr[length++] = (char)(48 + b);
			}
		}
		return new string(ptr, 0, length);
	}

	public static bool operator ==(StandardFormat left, StandardFormat right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(StandardFormat left, StandardFormat right)
	{
		return !left.Equals(right);
	}
}


using System.Buffers;

internal interface IPinnable
{
	MemoryHandle Pin(int elementIndex);

	void Unpin();
}


using System;

internal interface IMemoryOwner<T> : IDisposable
{
	Memory<T> Memory { get; }
}


using System;
using System.Buffers;
using System.Runtime.InteropServices;

internal struct MemoryHandle : IDisposable
{
	private unsafe void* _pointer;

	private GCHandle _handle;

	private IPinnable _pinnable;

	[CLSCompliant(false)]
	public unsafe void* Pointer => _pointer;

	[CLSCompliant(false)]
	public unsafe MemoryHandle(void* pointer, GCHandle handle = default(GCHandle), IPinnable pinnable = null)
	{
		_pointer = pointer;
		_handle = handle;
		_pinnable = pinnable;
	}

	public unsafe void Dispose()
	{
		if (_handle.IsAllocated)
		{
			_handle.Free();
		}
		if (_pinnable != null)
		{
			_pinnable.Unpin();
			_pinnable = null;
		}
		_pointer = null;
	}
}


using System;
using System.Buffers;
using System.Runtime.CompilerServices;

internal abstract class MemoryManager<T> : IMemoryOwner<T>, IDisposable, IPinnable
{
	public virtual Memory<T> Memory => new Memory<T>(this, GetSpan().Length);

	public abstract Span<T> GetSpan();

	public abstract MemoryHandle Pin(int elementIndex = 0);

	public abstract void Unpin();

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	protected Memory<T> CreateMemory(int length)
	{
		return new Memory<T>(this, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	protected Memory<T> CreateMemory(int start, int length)
	{
		return new Memory<T>(this, start, length);
	}

	protected internal virtual bool TryGetArray(out ArraySegment<T> segment)
	{
		segment = default(ArraySegment<T>);
		return false;
	}

	void IDisposable.Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	protected abstract void Dispose(bool disposing);
}


using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class Base64
{
	private static readonly sbyte[] s_decodingMap = new sbyte[256]
	{
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, 62, -1, -1, -1, 63, 52, 53,
		54, 55, 56, 57, 58, 59, 60, 61, -1, -1,
		-1, -1, -1, -1, -1, 0, 1, 2, 3, 4,
		5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
		15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
		25, -1, -1, -1, -1, -1, -1, 26, 27, 28,
		29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
		39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
		49, 50, 51, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1
	};

	private static readonly byte[] s_encodingMap = new byte[64]
	{
		65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
		75, 76, 77, 78, 79, 80, 81, 82, 83, 84,
		85, 86, 87, 88, 89, 90, 97, 98, 99, 100,
		101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
		111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
		121, 122, 48, 49, 50, 51, 52, 53, 54, 55,
		56, 57, 43, 47
	};

	private const byte EncodingPad = 61;

	private const int MaximumEncodeLength = 1610612733;

	public static OperationStatus DecodeFromUtf8(ReadOnlySpan<byte> utf8, Span<byte> bytes, out int bytesConsumed, out int bytesWritten, bool isFinalBlock = true)
	{
		ref byte reference = ref MemoryMarshal.GetReference(utf8);
		ref byte reference2 = ref MemoryMarshal.GetReference(bytes);
		int num = utf8.Length & -4;
		int length = bytes.Length;
		int num2 = 0;
		int num3 = 0;
		if (utf8.Length != 0)
		{
			ref sbyte reference3 = ref s_decodingMap[0];
			int num4 = (isFinalBlock ? 4 : 0);
			int num5 = 0;
			num5 = ((length < GetMaxDecodedFromUtf8Length(num)) ? (length / 3 * 4) : (num - num4));
			while (true)
			{
				if (num2 < num5)
				{
					int num6 = Decode(ref Unsafe.Add(ref reference, num2), ref reference3);
					if (num6 >= 0)
					{
						WriteThreeLowOrderBytes(ref Unsafe.Add(ref reference2, num3), num6);
						num3 += 3;
						num2 += 4;
						continue;
					}
				}
				else
				{
					if (num5 != num - num4)
					{
						goto IL_0205;
					}
					if (num2 == num)
					{
						if (!isFinalBlock)
						{
							bytesConsumed = num2;
							bytesWritten = num3;
							return OperationStatus.NeedMoreData;
						}
					}
					else
					{
						int elementOffset = Unsafe.Add(ref reference, num - 4);
						int elementOffset2 = Unsafe.Add(ref reference, num - 3);
						int num7 = Unsafe.Add(ref reference, num - 2);
						int num8 = Unsafe.Add(ref reference, num - 1);
						elementOffset = Unsafe.Add(ref reference3, elementOffset);
						elementOffset2 = Unsafe.Add(ref reference3, elementOffset2);
						elementOffset <<= 18;
						elementOffset2 <<= 12;
						elementOffset |= elementOffset2;
						if (num8 != 61)
						{
							num7 = Unsafe.Add(ref reference3, num7);
							num8 = Unsafe.Add(ref reference3, num8);
							num7 <<= 6;
							elementOffset |= num8;
							elementOffset |= num7;
							if (elementOffset >= 0)
							{
								if (num3 <= length - 3)
								{
									WriteThreeLowOrderBytes(ref Unsafe.Add(ref reference2, num3), elementOffset);
									num3 += 3;
									goto IL_01eb;
								}
								goto IL_0205;
							}
						}
						else if (num7 != 61)
						{
							num7 = Unsafe.Add(ref reference3, num7);
							num7 <<= 6;
							elementOffset |= num7;
							if (elementOffset >= 0)
							{
								if (num3 <= length - 2)
								{
									Unsafe.Add(ref reference2, num3) = (byte)(elementOffset >> 16);
									Unsafe.Add(ref reference2, num3 + 1) = (byte)(elementOffset >> 8);
									num3 += 2;
									goto IL_01eb;
								}
								goto IL_0205;
							}
						}
						else if (elementOffset >= 0)
						{
							if (num3 <= length - 1)
							{
								Unsafe.Add(ref reference2, num3) = (byte)(elementOffset >> 16);
								num3++;
								goto IL_01eb;
							}
							goto IL_0205;
						}
					}
				}
				goto IL_022b;
				IL_01eb:
				num2 += 4;
				if (num == utf8.Length)
				{
					break;
				}
				goto IL_022b;
				IL_022b:
				bytesConsumed = num2;
				bytesWritten = num3;
				return OperationStatus.InvalidData;
				IL_0205:
				if (!(num != utf8.Length && isFinalBlock))
				{
					bytesConsumed = num2;
					bytesWritten = num3;
					return OperationStatus.DestinationTooSmall;
				}
				goto IL_022b;
			}
		}
		bytesConsumed = num2;
		bytesWritten = num3;
		return OperationStatus.Done;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int GetMaxDecodedFromUtf8Length(int length)
	{
		if (length < 0)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.length);
		}
		return (length >> 2) * 3;
	}

	public static OperationStatus DecodeFromUtf8InPlace(Span<byte> buffer, out int bytesWritten)
	{
		int length = buffer.Length;
		int num = 0;
		int num2 = 0;
		if (length == (length >> 2) * 4)
		{
			if (length == 0)
			{
				goto IL_016d;
			}
			ref byte reference = ref MemoryMarshal.GetReference(buffer);
			ref sbyte reference2 = ref s_decodingMap[0];
			while (num < length - 4)
			{
				int num3 = Decode(ref Unsafe.Add(ref reference, num), ref reference2);
				if (num3 >= 0)
				{
					WriteThreeLowOrderBytes(ref Unsafe.Add(ref reference, num2), num3);
					num2 += 3;
					num += 4;
					continue;
				}
				goto IL_0172;
			}
			int elementOffset = Unsafe.Add(ref reference, length - 4);
			int elementOffset2 = Unsafe.Add(ref reference, length - 3);
			int num4 = Unsafe.Add(ref reference, length - 2);
			int num5 = Unsafe.Add(ref reference, length - 1);
			elementOffset = Unsafe.Add(ref reference2, elementOffset);
			elementOffset2 = Unsafe.Add(ref reference2, elementOffset2);
			elementOffset <<= 18;
			elementOffset2 <<= 12;
			elementOffset |= elementOffset2;
			if (num5 != 61)
			{
				num4 = Unsafe.Add(ref reference2, num4);
				num5 = Unsafe.Add(ref reference2, num5);
				num4 <<= 6;
				elementOffset |= num5;
				elementOffset |= num4;
				if (elementOffset >= 0)
				{
					WriteThreeLowOrderBytes(ref Unsafe.Add(ref reference, num2), elementOffset);
					num2 += 3;
					goto IL_016d;
				}
			}
			else if (num4 != 61)
			{
				num4 = Unsafe.Add(ref reference2, num4);
				num4 <<= 6;
				elementOffset |= num4;
				if (elementOffset >= 0)
				{
					Unsafe.Add(ref reference, num2) = (byte)(elementOffset >> 16);
					Unsafe.Add(ref reference, num2 + 1) = (byte)(elementOffset >> 8);
					num2 += 2;
					goto IL_016d;
				}
			}
			else if (elementOffset >= 0)
			{
				Unsafe.Add(ref reference, num2) = (byte)(elementOffset >> 16);
				num2++;
				goto IL_016d;
			}
		}
		goto IL_0172;
		IL_0172:
		bytesWritten = num2;
		return OperationStatus.InvalidData;
		IL_016d:
		bytesWritten = num2;
		return OperationStatus.Done;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int Decode(ref byte encodedBytes, ref sbyte decodingMap)
	{
		int elementOffset = encodedBytes;
		int elementOffset2 = Unsafe.Add(ref encodedBytes, 1);
		int elementOffset3 = Unsafe.Add(ref encodedBytes, 2);
		int elementOffset4 = Unsafe.Add(ref encodedBytes, 3);
		elementOffset = Unsafe.Add(ref decodingMap, elementOffset);
		elementOffset2 = Unsafe.Add(ref decodingMap, elementOffset2);
		elementOffset3 = Unsafe.Add(ref decodingMap, elementOffset3);
		elementOffset4 = Unsafe.Add(ref decodingMap, elementOffset4);
		elementOffset <<= 18;
		elementOffset2 <<= 12;
		elementOffset3 <<= 6;
		elementOffset |= elementOffset4;
		elementOffset2 |= elementOffset3;
		return elementOffset | elementOffset2;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static void WriteThreeLowOrderBytes(ref byte destination, int value)
	{
		destination = (byte)(value >> 16);
		Unsafe.Add(ref destination, 1) = (byte)(value >> 8);
		Unsafe.Add(ref destination, 2) = (byte)value;
	}

	public static OperationStatus EncodeToUtf8(ReadOnlySpan<byte> bytes, Span<byte> utf8, out int bytesConsumed, out int bytesWritten, bool isFinalBlock = true)
	{
		ref byte reference = ref MemoryMarshal.GetReference(bytes);
		ref byte reference2 = ref MemoryMarshal.GetReference(utf8);
		int length = bytes.Length;
		int length2 = utf8.Length;
		int num = 0;
		num = ((length > 1610612733 || length2 < GetMaxEncodedToUtf8Length(length)) ? ((length2 >> 2) * 3 - 2) : (length - 2));
		int i = 0;
		int num2 = 0;
		int num3 = 0;
		ref byte encodingMap = ref s_encodingMap[0];
		for (; i < num; i += 3)
		{
			num3 = Encode(ref Unsafe.Add(ref reference, i), ref encodingMap);
			Unsafe.WriteUnaligned(ref Unsafe.Add(ref reference2, num2), num3);
			num2 += 4;
		}
		if (num == length - 2)
		{
			if (isFinalBlock)
			{
				if (i == length - 1)
				{
					num3 = EncodeAndPadTwo(ref Unsafe.Add(ref reference, i), ref encodingMap);
					Unsafe.WriteUnaligned(ref Unsafe.Add(ref reference2, num2), num3);
					num2 += 4;
					i++;
				}
				else if (i == length - 2)
				{
					num3 = EncodeAndPadOne(ref Unsafe.Add(ref reference, i), ref encodingMap);
					Unsafe.WriteUnaligned(ref Unsafe.Add(ref reference2, num2), num3);
					num2 += 4;
					i += 2;
				}
				bytesConsumed = i;
				bytesWritten = num2;
				return OperationStatus.Done;
			}
			bytesConsumed = i;
			bytesWritten = num2;
			return OperationStatus.NeedMoreData;
		}
		bytesConsumed = i;
		bytesWritten = num2;
		return OperationStatus.DestinationTooSmall;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int GetMaxEncodedToUtf8Length(int length)
	{
		if ((uint)length > 1610612733u)
		{
			<efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.ThrowArgumentOutOfRangeException(<cc7a1cbb-4170-432f-b89a-e8b4f50166fc>ExceptionArgument.length);
		}
		return (length + 2) / 3 * 4;
	}

	public static OperationStatus EncodeToUtf8InPlace(Span<byte> buffer, int dataLength, out int bytesWritten)
	{
		int maxEncodedToUtf8Length = GetMaxEncodedToUtf8Length(dataLength);
		if (buffer.Length >= maxEncodedToUtf8Length)
		{
			int num = dataLength - dataLength / 3 * 3;
			int num2 = maxEncodedToUtf8Length - 4;
			int num3 = dataLength - num;
			int num4 = 0;
			ref byte encodingMap = ref s_encodingMap[0];
			ref byte reference = ref MemoryMarshal.GetReference(buffer);
			switch (num)
			{
			case 1:
				num4 = EncodeAndPadTwo(ref Unsafe.Add(ref reference, num3), ref encodingMap);
				Unsafe.WriteUnaligned(ref Unsafe.Add(ref reference, num2), num4);
				num2 -= 4;
				break;
			default:
				num4 = EncodeAndPadOne(ref Unsafe.Add(ref reference, num3), ref encodingMap);
				Unsafe.WriteUnaligned(ref Unsafe.Add(ref reference, num2), num4);
				num2 -= 4;
				break;
			case 0:
				break;
			}
			for (num3 -= 3; num3 >= 0; num3 -= 3)
			{
				num4 = Encode(ref Unsafe.Add(ref reference, num3), ref encodingMap);
				Unsafe.WriteUnaligned(ref Unsafe.Add(ref reference, num2), num4);
				num2 -= 4;
			}
			bytesWritten = maxEncodedToUtf8Length;
			return OperationStatus.Done;
		}
		bytesWritten = 0;
		return OperationStatus.DestinationTooSmall;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int Encode(ref byte threeBytes, ref byte encodingMap)
	{
		int num = (threeBytes << 16) | (Unsafe.Add(ref threeBytes, 1) << 8) | Unsafe.Add(ref threeBytes, 2);
		int num2 = Unsafe.Add(ref encodingMap, num >> 18);
		int num3 = Unsafe.Add(ref encodingMap, (num >> 12) & 0x3F);
		int num4 = Unsafe.Add(ref encodingMap, (num >> 6) & 0x3F);
		int num5 = Unsafe.Add(ref encodingMap, num & 0x3F);
		return num2 | (num3 << 8) | (num4 << 16) | (num5 << 24);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int EncodeAndPadOne(ref byte twoBytes, ref byte encodingMap)
	{
		int num = (twoBytes << 16) | (Unsafe.Add(ref twoBytes, 1) << 8);
		int num2 = Unsafe.Add(ref encodingMap, num >> 18);
		int num3 = Unsafe.Add(ref encodingMap, (num >> 12) & 0x3F);
		int num4 = Unsafe.Add(ref encodingMap, (num >> 6) & 0x3F);
		return num2 | (num3 << 8) | (num4 << 16) | 0x3D000000;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int EncodeAndPadTwo(ref byte oneByte, ref byte encodingMap)
	{
		int num = oneByte << 8;
		int num2 = Unsafe.Add(ref encodingMap, num >> 10);
		int num3 = Unsafe.Add(ref encodingMap, (num >> 4) & 0x3F);
		return num2 | (num3 << 8) | 0x3D0000 | 0x3D000000;
	}
}


using System;

internal static class Utf8Constants
{
	public const byte Colon = 58;

	public const byte Comma = 44;

	public const byte Minus = 45;

	public const byte Period = 46;

	public const byte Plus = 43;

	public const byte Slash = 47;

	public const byte Space = 32;

	public const byte Hyphen = 45;

	public const byte Separator = 44;

	public const int GroupSize = 3;

	public static readonly TimeSpan s_nullUtcOffset = TimeSpan.MinValue;

	public const int DateTimeMaxUtcOffsetHours = 14;

	public const int DateTimeNumFractionDigits = 7;

	public const int MaxDateTimeFraction = 9999999;

	public const ulong BillionMaxUIntValue = 4294967295000000000uL;

	public const uint Billion = 1000000000u;
}


using System;
using System.Buffers;
using System.Buffers.Text;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class FormattingHelpers
{
	public enum HexCasing : uint
	{
		Uppercase = 0u,
		Lowercase = 8224u
	}

	internal const string HexTableLower = "0123456789abcdef";

	internal const string HexTableUpper = "0123456789ABCDEF";

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static char GetSymbolOrDefault([In][<fdd897db-548f-4ce5-8c3c-053982a32f17>IsReadOnly] ref StandardFormat format, char defaultSymbol)
	{
		char c = format.Symbol;
		if (c == '\0' && format.Precision == 0)
		{
			c = defaultSymbol;
		}
		return c;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void FillWithAsciiZeros(Span<byte> buffer)
	{
		for (int i = 0; i < buffer.Length; i++)
		{
			buffer[i] = 48;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void WriteHexByte(byte value, Span<byte> buffer, int startingIndex = 0, HexCasing casing = HexCasing.Uppercase)
	{
		uint num = (uint)(((value & 0xF0) << 4) + (value & 0xF) - 35209);
		uint num2 = ((((0 - num) & 0x7070) >> 4) + num + 47545) | (uint)casing;
		buffer[startingIndex + 1] = (byte)num2;
		buffer[startingIndex] = (byte)(num2 >> 8);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void WriteDigits(ulong value, Span<byte> buffer)
	{
		for (int num = buffer.Length - 1; num >= 1; num--)
		{
			ulong num2 = 48 + value;
			value /= 10;
			buffer[num] = (byte)(num2 - value * 10);
		}
		buffer[0] = (byte)(48 + value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void WriteDigitsWithGroupSeparator(ulong value, Span<byte> buffer)
	{
		int num = 0;
		for (int num2 = buffer.Length - 1; num2 >= 1; num2--)
		{
			ulong num3 = 48 + value;
			value /= 10;
			buffer[num2] = (byte)(num3 - value * 10);
			if (num == 2)
			{
				buffer[--num2] = 44;
				num = 0;
			}
			else
			{
				num++;
			}
		}
		buffer[0] = (byte)(48 + value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void WriteDigits(uint value, Span<byte> buffer)
	{
		for (int num = buffer.Length - 1; num >= 1; num--)
		{
			uint num2 = 48 + value;
			value /= 10;
			buffer[num] = (byte)(num2 - value * 10);
		}
		buffer[0] = (byte)(48 + value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void WriteFourDecimalDigits(uint value, Span<byte> buffer, int startingIndex = 0)
	{
		uint num = 48 + value;
		value /= 10;
		buffer[startingIndex + 3] = (byte)(num - value * 10);
		num = 48 + value;
		value /= 10;
		buffer[startingIndex + 2] = (byte)(num - value * 10);
		num = 48 + value;
		value /= 10;
		buffer[startingIndex + 1] = (byte)(num - value * 10);
		buffer[startingIndex] = (byte)(48 + value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void WriteTwoDecimalDigits(uint value, Span<byte> buffer, int startingIndex = 0)
	{
		uint num = 48 + value;
		value /= 10;
		buffer[startingIndex + 1] = (byte)(num - value * 10);
		buffer[startingIndex] = (byte)(48 + value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ulong DivMod(ulong numerator, ulong denominator, out ulong modulo)
	{
		ulong num = numerator / denominator;
		modulo = numerator - num * denominator;
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static uint DivMod(uint numerator, uint denominator, out uint modulo)
	{
		uint num = numerator / denominator;
		modulo = numerator - num * denominator;
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int CountDecimalTrailingZeros(uint value, out uint valueWithoutTrailingZeros)
	{
		int num = 0;
		if (value != 0)
		{
			while (true)
			{
				uint modulo;
				uint num2 = DivMod(value, 10u, out modulo);
				if (modulo != 0)
				{
					break;
				}
				value = num2;
				num++;
			}
		}
		valueWithoutTrailingZeros = value;
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int CountDigits(ulong value)
	{
		int num = 1;
		uint num2;
		if (value >= 10000000)
		{
			if (value >= 100000000000000L)
			{
				num2 = (uint)(value / 100000000000000L);
				num += 14;
			}
			else
			{
				num2 = (uint)(value / 10000000);
				num += 7;
			}
		}
		else
		{
			num2 = (uint)value;
		}
		if (num2 >= 10)
		{
			num = ((num2 < 100) ? (num + 1) : ((num2 < 1000) ? (num + 2) : ((num2 < 10000) ? (num + 3) : ((num2 < 100000) ? (num + 4) : ((num2 >= 1000000) ? (num + 6) : (num + 5))))));
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int CountDigits(uint value)
	{
		int num = 1;
		if (value >= 100000)
		{
			value /= 100000;
			num += 5;
		}
		if (value >= 10)
		{
			num = ((value < 100) ? (num + 1) : ((value < 1000) ? (num + 2) : ((value >= 10000) ? (num + 4) : (num + 3))));
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int CountHexDigits(ulong value)
	{
		int num = 1;
		if (value > uint.MaxValue)
		{
			num += 8;
			value >>= 32;
		}
		if (value > 65535)
		{
			num += 4;
			value >>= 16;
		}
		if (value > 255)
		{
			num += 2;
			value >>= 8;
		}
		if (value > 15)
		{
			num++;
		}
		return num;
	}
}


public enum HexCasing : uint
{
	Uppercase = 0u,
	Lowercase = 8224u
}


using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Buffers.Text;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class Utf8Formatter
{
	[StructLayout(LayoutKind.Explicit)]
	private struct DecomposedGuid
	{
		[FieldOffset(0)]
		public Guid Guid;

		[FieldOffset(0)]
		public byte Byte00;

		[FieldOffset(1)]
		public byte Byte01;

		[FieldOffset(2)]
		public byte Byte02;

		[FieldOffset(3)]
		public byte Byte03;

		[FieldOffset(4)]
		public byte Byte04;

		[FieldOffset(5)]
		public byte Byte05;

		[FieldOffset(6)]
		public byte Byte06;

		[FieldOffset(7)]
		public byte Byte07;

		[FieldOffset(8)]
		public byte Byte08;

		[FieldOffset(9)]
		public byte Byte09;

		[FieldOffset(10)]
		public byte Byte10;

		[FieldOffset(11)]
		public byte Byte11;

		[FieldOffset(12)]
		public byte Byte12;

		[FieldOffset(13)]
		public byte Byte13;

		[FieldOffset(14)]
		public byte Byte14;

		[FieldOffset(15)]
		public byte Byte15;
	}

	private const byte TimeMarker = 84;

	private const byte UtcMarker = 90;

	private const byte GMT1 = 71;

	private const byte GMT2 = 77;

	private const byte GMT3 = 84;

	private const byte GMT1Lowercase = 103;

	private const byte GMT2Lowercase = 109;

	private const byte GMT3Lowercase = 116;

	private static readonly uint[] DayAbbreviations = new uint[7] { 7238995u, 7237453u, 6649172u, 6579543u, 7694420u, 6910534u, 7627091u };

	private static readonly uint[] DayAbbreviationsLowercase = new uint[7] { 7239027u, 7237485u, 6649204u, 6579575u, 7694452u, 6910566u, 7627123u };

	private static readonly uint[] MonthAbbreviations = new uint[12]
	{
		7233866u, 6448454u, 7496013u, 7499841u, 7954765u, 7238986u, 7107914u, 6780225u, 7365971u, 7627599u,
		7761742u, 6513988u
	};

	private static readonly uint[] MonthAbbreviationsLowercase = new uint[12]
	{
		7233898u, 6448486u, 7496045u, 7499873u, 7954797u, 7239018u, 7107946u, 6780257u, 7366003u, 7627631u,
		7761774u, 6514020u
	};

	private const byte OpenBrace = 123;

	private const byte CloseBrace = 125;

	private const byte OpenParen = 40;

	private const byte CloseParen = 41;

	private const byte Dash = 45;

	public static bool TryFormat(bool value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		char symbolOrDefault = System.Buffers.Text.FormattingHelpers.GetSymbolOrDefault(ref format, 'G');
		if (value)
		{
			if (symbolOrDefault == 'G')
			{
				if (BinaryPrimitives.TryWriteUInt32BigEndian(destination, 1416787301u))
				{
					goto IL_0033;
				}
			}
			else
			{
				if (symbolOrDefault != 'l')
				{
					goto IL_0083;
				}
				if (BinaryPrimitives.TryWriteUInt32BigEndian(destination, 1953658213u))
				{
					goto IL_0033;
				}
			}
		}
		else if (symbolOrDefault == 'G')
		{
			if (4u < (uint)destination.Length)
			{
				BinaryPrimitives.WriteUInt32BigEndian(destination, 1180789875u);
				goto IL_006e;
			}
		}
		else
		{
			if (symbolOrDefault != 'l')
			{
				goto IL_0083;
			}
			if (4u < (uint)destination.Length)
			{
				BinaryPrimitives.WriteUInt32BigEndian(destination, 1717660787u);
				goto IL_006e;
			}
		}
		bytesWritten = 0;
		return false;
		IL_006e:
		destination[4] = 101;
		bytesWritten = 5;
		return true;
		IL_0083:
		return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryFormatThrowFormatException(out bytesWritten);
		IL_0033:
		bytesWritten = 4;
		return true;
	}

	public static bool TryFormat(DateTimeOffset value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		TimeSpan offset = Utf8Constants.s_nullUtcOffset;
		char c = format.Symbol;
		if (format.IsDefault)
		{
			c = 'G';
			offset = value.Offset;
		}
		return c switch
		{
			'R' => TryFormatDateTimeR(value.UtcDateTime, destination, out bytesWritten), 
			'l' => TryFormatDateTimeL(value.UtcDateTime, destination, out bytesWritten), 
			'O' => TryFormatDateTimeO(value.DateTime, value.Offset, destination, out bytesWritten), 
			'G' => TryFormatDateTimeG(value.DateTime, offset, destination, out bytesWritten), 
			_ => <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryFormatThrowFormatException(out bytesWritten), 
		};
	}

	public static bool TryFormat(DateTime value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		return System.Buffers.Text.FormattingHelpers.GetSymbolOrDefault(ref format, 'G') switch
		{
			'R' => TryFormatDateTimeR(value, destination, out bytesWritten), 
			'l' => TryFormatDateTimeL(value, destination, out bytesWritten), 
			'O' => TryFormatDateTimeO(value, Utf8Constants.s_nullUtcOffset, destination, out bytesWritten), 
			'G' => TryFormatDateTimeG(value, Utf8Constants.s_nullUtcOffset, destination, out bytesWritten), 
			_ => <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryFormatThrowFormatException(out bytesWritten), 
		};
	}

	private static bool TryFormatDateTimeG(DateTime value, TimeSpan offset, Span<byte> destination, out int bytesWritten)
	{
		int num = 19;
		if (offset != Utf8Constants.s_nullUtcOffset)
		{
			num += 7;
		}
		if (destination.Length < num)
		{
			bytesWritten = 0;
			return false;
		}
		bytesWritten = num;
		byte b = destination[18];
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Month, destination);
		destination[2] = 47;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Day, destination, 3);
		destination[5] = 47;
		System.Buffers.Text.FormattingHelpers.WriteFourDecimalDigits((uint)value.Year, destination, 6);
		destination[10] = 32;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Hour, destination, 11);
		destination[13] = 58;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Minute, destination, 14);
		destination[16] = 58;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Second, destination, 17);
		if (offset != Utf8Constants.s_nullUtcOffset)
		{
			byte b2;
			if (offset < default(TimeSpan))
			{
				b2 = 45;
				offset = TimeSpan.FromTicks(-offset.Ticks);
			}
			else
			{
				b2 = 43;
			}
			System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)offset.Minutes, destination, 24);
			destination[23] = 58;
			System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)offset.Hours, destination, 21);
			destination[20] = b2;
			destination[19] = 32;
		}
		return true;
	}

	private static bool TryFormatDateTimeO(DateTime value, TimeSpan offset, Span<byte> destination, out int bytesWritten)
	{
		int num = 27;
		DateTimeKind dateTimeKind = DateTimeKind.Local;
		if (offset == Utf8Constants.s_nullUtcOffset)
		{
			dateTimeKind = value.Kind;
			switch (dateTimeKind)
			{
			case DateTimeKind.Local:
				offset = TimeZoneInfo.Local.GetUtcOffset(value);
				num += 6;
				break;
			case DateTimeKind.Utc:
				num++;
				break;
			}
		}
		else
		{
			num += 6;
		}
		if (destination.Length < num)
		{
			bytesWritten = 0;
			return false;
		}
		bytesWritten = num;
		byte b = destination[26];
		System.Buffers.Text.FormattingHelpers.WriteFourDecimalDigits((uint)value.Year, destination);
		destination[4] = 45;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Month, destination, 5);
		destination[7] = 45;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Day, destination, 8);
		destination[10] = 84;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Hour, destination, 11);
		destination[13] = 58;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Minute, destination, 14);
		destination[16] = 58;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Second, destination, 17);
		destination[19] = 46;
		System.Buffers.Text.FormattingHelpers.WriteDigits((uint)((ulong)value.Ticks % 10000000uL), destination.Slice(20, 7));
		switch (dateTimeKind)
		{
		case DateTimeKind.Local:
		{
			byte b2;
			if (offset < default(TimeSpan))
			{
				b2 = 45;
				offset = TimeSpan.FromTicks(-offset.Ticks);
			}
			else
			{
				b2 = 43;
			}
			System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)offset.Minutes, destination, 31);
			destination[30] = 58;
			System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)offset.Hours, destination, 28);
			destination[27] = b2;
			break;
		}
		case DateTimeKind.Utc:
			destination[27] = 90;
			break;
		}
		return true;
	}

	private static bool TryFormatDateTimeR(DateTime value, Span<byte> destination, out int bytesWritten)
	{
		if (28u >= (uint)destination.Length)
		{
			bytesWritten = 0;
			return false;
		}
		uint num = DayAbbreviations[(int)value.DayOfWeek];
		destination[0] = (byte)num;
		num >>= 8;
		destination[1] = (byte)num;
		num >>= 8;
		destination[2] = (byte)num;
		destination[3] = 44;
		destination[4] = 32;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Day, destination, 5);
		destination[7] = 32;
		uint num2 = MonthAbbreviations[value.Month - 1];
		destination[8] = (byte)num2;
		num2 >>= 8;
		destination[9] = (byte)num2;
		num2 >>= 8;
		destination[10] = (byte)num2;
		destination[11] = 32;
		System.Buffers.Text.FormattingHelpers.WriteFourDecimalDigits((uint)value.Year, destination, 12);
		destination[16] = 32;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Hour, destination, 17);
		destination[19] = 58;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Minute, destination, 20);
		destination[22] = 58;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Second, destination, 23);
		destination[25] = 32;
		destination[26] = 71;
		destination[27] = 77;
		destination[28] = 84;
		bytesWritten = 29;
		return true;
	}

	private static bool TryFormatDateTimeL(DateTime value, Span<byte> destination, out int bytesWritten)
	{
		if (28u >= (uint)destination.Length)
		{
			bytesWritten = 0;
			return false;
		}
		uint num = DayAbbreviationsLowercase[(int)value.DayOfWeek];
		destination[0] = (byte)num;
		num >>= 8;
		destination[1] = (byte)num;
		num >>= 8;
		destination[2] = (byte)num;
		destination[3] = 44;
		destination[4] = 32;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Day, destination, 5);
		destination[7] = 32;
		uint num2 = MonthAbbreviationsLowercase[value.Month - 1];
		destination[8] = (byte)num2;
		num2 >>= 8;
		destination[9] = (byte)num2;
		num2 >>= 8;
		destination[10] = (byte)num2;
		destination[11] = 32;
		System.Buffers.Text.FormattingHelpers.WriteFourDecimalDigits((uint)value.Year, destination, 12);
		destination[16] = 32;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Hour, destination, 17);
		destination[19] = 58;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Minute, destination, 20);
		destination[22] = 58;
		System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits((uint)value.Second, destination, 23);
		destination[25] = 32;
		destination[26] = 103;
		destination[27] = 109;
		destination[28] = 116;
		bytesWritten = 29;
		return true;
	}

	public static bool TryFormat(decimal value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		if (format.IsDefault)
		{
			format = 'G';
		}
		switch (format.Symbol)
		{
		case 'G':
		case 'g':
		{
			if (format.Precision != byte.MaxValue)
			{
				throw new NotSupportedException(<c1e4ce84-b725-4d32-90ca-a752f1fa7530>SR.Argument_GWithPrecisionNotSupported);
			}
			NumberBuffer number3 = default(NumberBuffer);
			System.Number.DecimalToNumber(value, ref number3);
			if (number3.Digits[0] == 0)
			{
				number3.IsNegative = false;
			}
			return TryFormatDecimalG(ref number3, destination, out bytesWritten);
		}
		case 'F':
		case 'f':
		{
			NumberBuffer number2 = default(NumberBuffer);
			System.Number.DecimalToNumber(value, ref number2);
			byte b2 = (byte)((format.Precision == byte.MaxValue) ? 2 : format.Precision);
			System.Number.RoundNumber(ref number2, number2.Scale + b2);
			return TryFormatDecimalF(ref number2, destination, out bytesWritten, b2);
		}
		case 'E':
		case 'e':
		{
			NumberBuffer number = default(NumberBuffer);
			System.Number.DecimalToNumber(value, ref number);
			byte b = (byte)((format.Precision == byte.MaxValue) ? 6 : format.Precision);
			System.Number.RoundNumber(ref number, b + 1);
			return TryFormatDecimalE(ref number, destination, out bytesWritten, b, (byte)format.Symbol);
		}
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryFormatThrowFormatException(out bytesWritten);
		}
	}

	private static bool TryFormatDecimalE(ref NumberBuffer number, Span<byte> destination, out int bytesWritten, byte precision, byte exponentSymbol)
	{
		int scale = number.Scale;
		ReadOnlySpan<byte> readOnlySpan = number.Digits;
		int num = (number.IsNegative ? 1 : 0) + 1 + ((precision != 0) ? (precision + 1) : 0) + 2 + 3;
		if (destination.Length < num)
		{
			bytesWritten = 0;
			return false;
		}
		int num2 = 0;
		int num3 = 0;
		if (number.IsNegative)
		{
			destination[num2++] = 45;
		}
		byte b = readOnlySpan[num3];
		int num4;
		if (b == 0)
		{
			destination[num2++] = 48;
			num4 = 0;
		}
		else
		{
			destination[num2++] = b;
			num3++;
			num4 = scale - 1;
		}
		if (precision > 0)
		{
			destination[num2++] = 46;
			for (int i = 0; i < precision; i++)
			{
				byte b2 = readOnlySpan[num3];
				if (b2 == 0)
				{
					while (i++ < precision)
					{
						destination[num2++] = 48;
					}
					break;
				}
				destination[num2++] = b2;
				num3++;
			}
		}
		destination[num2++] = exponentSymbol;
		if (num4 >= 0)
		{
			destination[num2++] = 43;
		}
		else
		{
			destination[num2++] = 45;
			num4 = -num4;
		}
		destination[num2++] = 48;
		destination[num2++] = (byte)(num4 / 10 + 48);
		destination[num2++] = (byte)(num4 % 10 + 48);
		bytesWritten = num;
		return true;
	}

	private static bool TryFormatDecimalF(ref NumberBuffer number, Span<byte> destination, out int bytesWritten, byte precision)
	{
		int scale = number.Scale;
		ReadOnlySpan<byte> readOnlySpan = number.Digits;
		int num = (number.IsNegative ? 1 : 0) + ((scale <= 0) ? 1 : scale) + ((precision != 0) ? (precision + 1) : 0);
		if (destination.Length < num)
		{
			bytesWritten = 0;
			return false;
		}
		int i = 0;
		int num2 = 0;
		if (number.IsNegative)
		{
			destination[num2++] = 45;
		}
		if (scale <= 0)
		{
			destination[num2++] = 48;
		}
		else
		{
			for (; i < scale; i++)
			{
				byte b = readOnlySpan[i];
				if (b == 0)
				{
					int num3 = scale - i;
					for (int j = 0; j < num3; j++)
					{
						destination[num2++] = 48;
					}
					break;
				}
				destination[num2++] = b;
			}
		}
		if (precision > 0)
		{
			destination[num2++] = 46;
			int k = 0;
			if (scale < 0)
			{
				int num4 = Math.Min(precision, -scale);
				for (int l = 0; l < num4; l++)
				{
					destination[num2++] = 48;
				}
				k += num4;
			}
			for (; k < precision; k++)
			{
				byte b2 = readOnlySpan[i];
				if (b2 == 0)
				{
					while (k++ < precision)
					{
						destination[num2++] = 48;
					}
					break;
				}
				destination[num2++] = b2;
				i++;
			}
		}
		bytesWritten = num;
		return true;
	}

	private static bool TryFormatDecimalG(ref NumberBuffer number, Span<byte> destination, out int bytesWritten)
	{
		int scale = number.Scale;
		ReadOnlySpan<byte> readOnlySpan = number.Digits;
		int numDigits = number.NumDigits;
		bool flag = scale < numDigits;
		int num;
		if (flag)
		{
			num = numDigits + 1;
			if (scale <= 0)
			{
				num += 1 + -scale;
			}
		}
		else
		{
			num = ((scale <= 0) ? 1 : scale);
		}
		if (number.IsNegative)
		{
			num++;
		}
		if (destination.Length < num)
		{
			bytesWritten = 0;
			return false;
		}
		int i = 0;
		int num2 = 0;
		if (number.IsNegative)
		{
			destination[num2++] = 45;
		}
		if (scale <= 0)
		{
			destination[num2++] = 48;
		}
		else
		{
			for (; i < scale; i++)
			{
				byte b = readOnlySpan[i];
				if (b == 0)
				{
					int num3 = scale - i;
					for (int j = 0; j < num3; j++)
					{
						destination[num2++] = 48;
					}
					break;
				}
				destination[num2++] = b;
			}
		}
		if (flag)
		{
			destination[num2++] = 46;
			if (scale < 0)
			{
				int num4 = -scale;
				for (int k = 0; k < num4; k++)
				{
					destination[num2++] = 48;
				}
			}
			byte b2;
			while ((b2 = readOnlySpan[i++]) != 0)
			{
				destination[num2++] = b2;
			}
		}
		bytesWritten = num;
		return true;
	}

	public static bool TryFormat(double value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		return TryFormatFloatingPoint(value, destination, out bytesWritten, format);
	}

	public static bool TryFormat(float value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		return TryFormatFloatingPoint(value, destination, out bytesWritten, format);
	}

	private static bool TryFormatFloatingPoint<T>(T value, Span<byte> destination, out int bytesWritten, StandardFormat format) where T : IFormattable
	{
		if (format.IsDefault)
		{
			format = 'G';
		}
		switch (format.Symbol)
		{
		case 'G':
		case 'g':
			if (format.Precision != byte.MaxValue)
			{
				throw new NotSupportedException(<c1e4ce84-b725-4d32-90ca-a752f1fa7530>SR.Argument_GWithPrecisionNotSupported);
			}
			break;
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryFormatThrowFormatException(out bytesWritten);
		case 'E':
		case 'F':
		case 'e':
		case 'f':
			break;
		}
		string text = format.ToString();
		string text2 = value.ToString(text, CultureInfo.InvariantCulture);
		int length = text2.Length;
		if (length > destination.Length)
		{
			bytesWritten = 0;
			return false;
		}
		for (int i = 0; i < length; i++)
		{
			destination[i] = (byte)text2[i];
		}
		bytesWritten = length;
		return true;
	}

	public static bool TryFormat(Guid value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		int num;
		switch (System.Buffers.Text.FormattingHelpers.GetSymbolOrDefault(ref format, 'D'))
		{
		case 'D':
			num = -2147483612;
			break;
		case 'B':
			num = -2139260122;
			break;
		case 'P':
			num = -2144786394;
			break;
		case 'N':
			num = 32;
			break;
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryFormatThrowFormatException(out bytesWritten);
		}
		if ((byte)num > destination.Length)
		{
			bytesWritten = 0;
			return false;
		}
		bytesWritten = (byte)num;
		num >>= 8;
		if ((byte)num != 0)
		{
			destination[0] = (byte)num;
			destination = destination.Slice(1);
		}
		num >>= 8;
		DecomposedGuid decomposedGuid = default(DecomposedGuid);
		decomposedGuid.Guid = value;
		byte b = destination[8];
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte03, destination, 0, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte02, destination, 2, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte01, destination, 4, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte00, destination, 6, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		if (num < 0)
		{
			destination[8] = 45;
			destination = destination.Slice(9);
		}
		else
		{
			destination = destination.Slice(8);
		}
		byte b2 = destination[4];
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte05, destination, 0, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte04, destination, 2, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		if (num < 0)
		{
			destination[4] = 45;
			destination = destination.Slice(5);
		}
		else
		{
			destination = destination.Slice(4);
		}
		byte b3 = destination[4];
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte07, destination, 0, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte06, destination, 2, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		if (num < 0)
		{
			destination[4] = 45;
			destination = destination.Slice(5);
		}
		else
		{
			destination = destination.Slice(4);
		}
		byte b4 = destination[4];
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte08, destination, 0, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte09, destination, 2, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		if (num < 0)
		{
			destination[4] = 45;
			destination = destination.Slice(5);
		}
		else
		{
			destination = destination.Slice(4);
		}
		byte b5 = destination[11];
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte10, destination, 0, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte11, destination, 2, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte12, destination, 4, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte13, destination, 6, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte14, destination, 8, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		System.Buffers.Text.FormattingHelpers.WriteHexByte(decomposedGuid.Byte15, destination, 10, System.Buffers.Text.FormattingHelpers.HexCasing.Lowercase);
		if ((byte)num != 0)
		{
			destination[12] = (byte)num;
		}
		return true;
	}

	public static bool TryFormat(byte value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		return TryFormatUInt64(value, destination, out bytesWritten, format);
	}

	[CLSCompliant(false)]
	public static bool TryFormat(sbyte value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		return TryFormatInt64(value, 255uL, destination, out bytesWritten, format);
	}

	[CLSCompliant(false)]
	public static bool TryFormat(ushort value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		return TryFormatUInt64(value, destination, out bytesWritten, format);
	}

	public static bool TryFormat(short value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		return TryFormatInt64(value, 65535uL, destination, out bytesWritten, format);
	}

	[CLSCompliant(false)]
	public static bool TryFormat(uint value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		return TryFormatUInt64(value, destination, out bytesWritten, format);
	}

	public static bool TryFormat(int value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		return TryFormatInt64(value, 4294967295uL, destination, out bytesWritten, format);
	}

	[CLSCompliant(false)]
	public static bool TryFormat(ulong value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		return TryFormatUInt64(value, destination, out bytesWritten, format);
	}

	public static bool TryFormat(long value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		return TryFormatInt64(value, ulong.MaxValue, destination, out bytesWritten, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatInt64(long value, ulong mask, Span<byte> destination, out int bytesWritten, StandardFormat format)
	{
		if (format.IsDefault)
		{
			return TryFormatInt64Default(value, destination, out bytesWritten);
		}
		switch (format.Symbol)
		{
		case 'G':
		case 'g':
			if (format.HasPrecision)
			{
				throw new NotSupportedException(<c1e4ce84-b725-4d32-90ca-a752f1fa7530>SR.Argument_GWithPrecisionNotSupported);
			}
			return TryFormatInt64D(value, format.Precision, destination, out bytesWritten);
		case 'D':
		case 'd':
			return TryFormatInt64D(value, format.Precision, destination, out bytesWritten);
		case 'N':
		case 'n':
			return TryFormatInt64N(value, format.Precision, destination, out bytesWritten);
		case 'x':
			return TryFormatUInt64X((ulong)value & mask, format.Precision, useLower: true, destination, out bytesWritten);
		case 'X':
			return TryFormatUInt64X((ulong)value & mask, format.Precision, useLower: false, destination, out bytesWritten);
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryFormatThrowFormatException(out bytesWritten);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatInt64D(long value, byte precision, Span<byte> destination, out int bytesWritten)
	{
		bool insertNegationSign = false;
		if (value < 0)
		{
			insertNegationSign = true;
			value = -value;
		}
		return TryFormatUInt64D((ulong)value, precision, destination, insertNegationSign, out bytesWritten);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatInt64Default(long value, Span<byte> destination, out int bytesWritten)
	{
		if ((ulong)value < 10uL)
		{
			return TryFormatUInt32SingleDigit((uint)value, destination, out bytesWritten);
		}
		if (IntPtr.Size == 8)
		{
			return TryFormatInt64MultipleDigits(value, destination, out bytesWritten);
		}
		if (value <= int.MaxValue && value >= int.MinValue)
		{
			return TryFormatInt32MultipleDigits((int)value, destination, out bytesWritten);
		}
		if (value <= 4294967295000000000L && value >= -4294967295000000000L)
		{
			if (value >= 0)
			{
				return TryFormatUInt64LessThanBillionMaxUInt((ulong)value, destination, out bytesWritten);
			}
			return TryFormatInt64MoreThanNegativeBillionMaxUInt(-value, destination, out bytesWritten);
		}
		if (value >= 0)
		{
			return TryFormatUInt64MoreThanBillionMaxUInt((ulong)value, destination, out bytesWritten);
		}
		return TryFormatInt64LessThanNegativeBillionMaxUInt(-value, destination, out bytesWritten);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatInt32Default(int value, Span<byte> destination, out int bytesWritten)
	{
		if ((uint)value < 10u)
		{
			return TryFormatUInt32SingleDigit((uint)value, destination, out bytesWritten);
		}
		return TryFormatInt32MultipleDigits(value, destination, out bytesWritten);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatInt32MultipleDigits(int value, Span<byte> destination, out int bytesWritten)
	{
		if (value < 0)
		{
			value = -value;
			int num = System.Buffers.Text.FormattingHelpers.CountDigits((uint)value);
			if (num >= destination.Length)
			{
				bytesWritten = 0;
				return false;
			}
			destination[0] = 45;
			bytesWritten = num + 1;
			System.Buffers.Text.FormattingHelpers.WriteDigits((uint)value, destination.Slice(1, num));
			return true;
		}
		return TryFormatUInt32MultipleDigits((uint)value, destination, out bytesWritten);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatInt64MultipleDigits(long value, Span<byte> destination, out int bytesWritten)
	{
		if (value < 0)
		{
			value = -value;
			int num = System.Buffers.Text.FormattingHelpers.CountDigits((ulong)value);
			if (num >= destination.Length)
			{
				bytesWritten = 0;
				return false;
			}
			destination[0] = 45;
			bytesWritten = num + 1;
			System.Buffers.Text.FormattingHelpers.WriteDigits((ulong)value, destination.Slice(1, num));
			return true;
		}
		return TryFormatUInt64MultipleDigits((ulong)value, destination, out bytesWritten);
	}

	private static bool TryFormatInt64MoreThanNegativeBillionMaxUInt(long value, Span<byte> destination, out int bytesWritten)
	{
		uint num = (uint)(value / 1000000000);
		uint value2 = (uint)(value - num * 1000000000);
		int num2 = System.Buffers.Text.FormattingHelpers.CountDigits(num);
		int num3 = num2 + 9;
		if (num3 >= destination.Length)
		{
			bytesWritten = 0;
			return false;
		}
		destination[0] = 45;
		bytesWritten = num3 + 1;
		System.Buffers.Text.FormattingHelpers.WriteDigits(num, destination.Slice(1, num2));
		System.Buffers.Text.FormattingHelpers.WriteDigits(value2, destination.Slice(num2 + 1, 9));
		return true;
	}

	private static bool TryFormatInt64LessThanNegativeBillionMaxUInt(long value, Span<byte> destination, out int bytesWritten)
	{
		ulong num = (ulong)value / 1000000000uL;
		uint value2 = (uint)((ulong)value - num * 1000000000);
		uint num2 = (uint)(num / 1000000000);
		uint value3 = (uint)(num - num2 * 1000000000);
		int num3 = System.Buffers.Text.FormattingHelpers.CountDigits(num2);
		int num4 = num3 + 18;
		if (num4 >= destination.Length)
		{
			bytesWritten = 0;
			return false;
		}
		destination[0] = 45;
		bytesWritten = num4 + 1;
		System.Buffers.Text.FormattingHelpers.WriteDigits(num2, destination.Slice(1, num3));
		System.Buffers.Text.FormattingHelpers.WriteDigits(value3, destination.Slice(num3 + 1, 9));
		System.Buffers.Text.FormattingHelpers.WriteDigits(value2, destination.Slice(num3 + 1 + 9, 9));
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatInt64N(long value, byte precision, Span<byte> destination, out int bytesWritten)
	{
		bool insertNegationSign = false;
		if (value < 0)
		{
			insertNegationSign = true;
			value = -value;
		}
		return TryFormatUInt64N((ulong)value, precision, destination, insertNegationSign, out bytesWritten);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatUInt64(ulong value, Span<byte> destination, out int bytesWritten, StandardFormat format)
	{
		if (format.IsDefault)
		{
			return TryFormatUInt64Default(value, destination, out bytesWritten);
		}
		switch (format.Symbol)
		{
		case 'G':
		case 'g':
			if (format.HasPrecision)
			{
				throw new NotSupportedException(<c1e4ce84-b725-4d32-90ca-a752f1fa7530>SR.Argument_GWithPrecisionNotSupported);
			}
			return TryFormatUInt64D(value, format.Precision, destination, insertNegationSign: false, out bytesWritten);
		case 'D':
		case 'd':
			return TryFormatUInt64D(value, format.Precision, destination, insertNegationSign: false, out bytesWritten);
		case 'N':
		case 'n':
			return TryFormatUInt64N(value, format.Precision, destination, insertNegationSign: false, out bytesWritten);
		case 'x':
			return TryFormatUInt64X(value, format.Precision, useLower: true, destination, out bytesWritten);
		case 'X':
			return TryFormatUInt64X(value, format.Precision, useLower: false, destination, out bytesWritten);
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryFormatThrowFormatException(out bytesWritten);
		}
	}

	private static bool TryFormatUInt64D(ulong value, byte precision, Span<byte> destination, bool insertNegationSign, out int bytesWritten)
	{
		int num = System.Buffers.Text.FormattingHelpers.CountDigits(value);
		int num2 = ((precision != byte.MaxValue) ? precision : 0) - num;
		if (num2 < 0)
		{
			num2 = 0;
		}
		int num3 = num + num2;
		if (insertNegationSign)
		{
			num3++;
		}
		if (num3 > destination.Length)
		{
			bytesWritten = 0;
			return false;
		}
		bytesWritten = num3;
		if (insertNegationSign)
		{
			destination[0] = 45;
			destination = destination.Slice(1);
		}
		if (num2 > 0)
		{
			System.Buffers.Text.FormattingHelpers.FillWithAsciiZeros(destination.Slice(0, num2));
		}
		System.Buffers.Text.FormattingHelpers.WriteDigits(value, destination.Slice(num2, num));
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatUInt64Default(ulong value, Span<byte> destination, out int bytesWritten)
	{
		if (value < 10)
		{
			return TryFormatUInt32SingleDigit((uint)value, destination, out bytesWritten);
		}
		if (IntPtr.Size == 8)
		{
			return TryFormatUInt64MultipleDigits(value, destination, out bytesWritten);
		}
		if (value <= uint.MaxValue)
		{
			return TryFormatUInt32MultipleDigits((uint)value, destination, out bytesWritten);
		}
		if (value <= 4294967295000000000L)
		{
			return TryFormatUInt64LessThanBillionMaxUInt(value, destination, out bytesWritten);
		}
		return TryFormatUInt64MoreThanBillionMaxUInt(value, destination, out bytesWritten);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatUInt32Default(uint value, Span<byte> destination, out int bytesWritten)
	{
		if (value < 10)
		{
			return TryFormatUInt32SingleDigit(value, destination, out bytesWritten);
		}
		return TryFormatUInt32MultipleDigits(value, destination, out bytesWritten);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatUInt32SingleDigit(uint value, Span<byte> destination, out int bytesWritten)
	{
		if (destination.Length == 0)
		{
			bytesWritten = 0;
			return false;
		}
		destination[0] = (byte)(48 + value);
		bytesWritten = 1;
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatUInt32MultipleDigits(uint value, Span<byte> destination, out int bytesWritten)
	{
		int num = System.Buffers.Text.FormattingHelpers.CountDigits(value);
		if (num > destination.Length)
		{
			bytesWritten = 0;
			return false;
		}
		bytesWritten = num;
		System.Buffers.Text.FormattingHelpers.WriteDigits(value, destination.Slice(0, num));
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatUInt64SingleDigit(ulong value, Span<byte> destination, out int bytesWritten)
	{
		if (destination.Length == 0)
		{
			bytesWritten = 0;
			return false;
		}
		destination[0] = (byte)(48 + value);
		bytesWritten = 1;
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool TryFormatUInt64MultipleDigits(ulong value, Span<byte> destination, out int bytesWritten)
	{
		int num = System.Buffers.Text.FormattingHelpers.CountDigits(value);
		if (num > destination.Length)
		{
			bytesWritten = 0;
			return false;
		}
		bytesWritten = num;
		System.Buffers.Text.FormattingHelpers.WriteDigits(value, destination.Slice(0, num));
		return true;
	}

	private static bool TryFormatUInt64LessThanBillionMaxUInt(ulong value, Span<byte> destination, out int bytesWritten)
	{
		uint num = (uint)(value / 1000000000);
		uint value2 = (uint)(value - num * 1000000000);
		int num2 = System.Buffers.Text.FormattingHelpers.CountDigits(num);
		int num3 = num2 + 9;
		if (num3 > destination.Length)
		{
			bytesWritten = 0;
			return false;
		}
		bytesWritten = num3;
		System.Buffers.Text.FormattingHelpers.WriteDigits(num, destination.Slice(0, num2));
		System.Buffers.Text.FormattingHelpers.WriteDigits(value2, destination.Slice(num2, 9));
		return true;
	}

	private static bool TryFormatUInt64MoreThanBillionMaxUInt(ulong value, Span<byte> destination, out int bytesWritten)
	{
		ulong num = value / 1000000000;
		uint value2 = (uint)(value - num * 1000000000);
		uint num2 = (uint)(num / 1000000000);
		uint value3 = (uint)(num - num2 * 1000000000);
		int num3 = System.Buffers.Text.FormattingHelpers.CountDigits(num2);
		int num4 = num3 + 18;
		if (num4 > destination.Length)
		{
			bytesWritten = 0;
			return false;
		}
		bytesWritten = num4;
		System.Buffers.Text.FormattingHelpers.WriteDigits(num2, destination.Slice(0, num3));
		System.Buffers.Text.FormattingHelpers.WriteDigits(value3, destination.Slice(num3, 9));
		System.Buffers.Text.FormattingHelpers.WriteDigits(value2, destination.Slice(num3 + 9, 9));
		return true;
	}

	private static bool TryFormatUInt64N(ulong value, byte precision, Span<byte> destination, bool insertNegationSign, out int bytesWritten)
	{
		int num = System.Buffers.Text.FormattingHelpers.CountDigits(value);
		int num2 = (num - 1) / 3;
		int num3 = ((precision == byte.MaxValue) ? 2 : precision);
		int num4 = num + num2;
		if (num3 > 0)
		{
			num4 += num3 + 1;
		}
		if (insertNegationSign)
		{
			num4++;
		}
		if (num4 > destination.Length)
		{
			bytesWritten = 0;
			return false;
		}
		bytesWritten = num4;
		if (insertNegationSign)
		{
			destination[0] = 45;
			destination = destination.Slice(1);
		}
		System.Buffers.Text.FormattingHelpers.WriteDigitsWithGroupSeparator(value, destination.Slice(0, num + num2));
		if (num3 > 0)
		{
			destination[num + num2] = 46;
			System.Buffers.Text.FormattingHelpers.FillWithAsciiZeros(destination.Slice(num + num2 + 1, num3));
		}
		return true;
	}

	private static bool TryFormatUInt64X(ulong value, byte precision, bool useLower, Span<byte> destination, out int bytesWritten)
	{
		int num = System.Buffers.Text.FormattingHelpers.CountHexDigits(value);
		int num2 = ((precision == byte.MaxValue) ? num : Math.Max(precision, num));
		if (destination.Length < num2)
		{
			bytesWritten = 0;
			return false;
		}
		bytesWritten = num2;
		string text = (useLower ? "0123456789abcdef" : "0123456789ABCDEF");
		while ((uint)(--num2) < (uint)destination.Length)
		{
			destination[num2] = (byte)text[(int)value & 0xF];
			value >>= 4;
		}
		return true;
	}

	public static bool TryFormat(TimeSpan value, Span<byte> destination, out int bytesWritten, StandardFormat format = default(StandardFormat))
	{
		char c = System.Buffers.Text.FormattingHelpers.GetSymbolOrDefault(ref format, 'c');
		switch (c)
		{
		case 'T':
		case 't':
			c = 'c';
			break;
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryFormatThrowFormatException(out bytesWritten);
		case 'G':
		case 'c':
		case 'g':
			break;
		}
		int num = 8;
		long ticks = value.Ticks;
		uint valueWithoutTrailingZeros;
		ulong num2;
		if (ticks < 0)
		{
			ticks = -ticks;
			if (ticks < 0)
			{
				valueWithoutTrailingZeros = 4775808u;
				num2 = 922337203685uL;
				goto IL_0082;
			}
		}
		num2 = System.Buffers.Text.FormattingHelpers.DivMod((ulong)Math.Abs(value.Ticks), 10000000uL, out var modulo);
		valueWithoutTrailingZeros = (uint)modulo;
		goto IL_0082;
		IL_0082:
		int num3 = 0;
		switch (c)
		{
		case 'c':
			if (valueWithoutTrailingZeros != 0)
			{
				num3 = 7;
			}
			break;
		case 'G':
			num3 = 7;
			break;
		default:
			if (valueWithoutTrailingZeros != 0)
			{
				num3 = 7 - System.Buffers.Text.FormattingHelpers.CountDecimalTrailingZeros(valueWithoutTrailingZeros, out valueWithoutTrailingZeros);
			}
			break;
		}
		if (num3 != 0)
		{
			num += num3 + 1;
		}
		ulong num4 = 0uL;
		ulong modulo2 = 0uL;
		if (num2 != 0)
		{
			num4 = System.Buffers.Text.FormattingHelpers.DivMod(num2, 60uL, out modulo2);
		}
		ulong num5 = 0uL;
		ulong modulo3 = 0uL;
		if (num4 != 0)
		{
			num5 = System.Buffers.Text.FormattingHelpers.DivMod(num4, 60uL, out modulo3);
		}
		uint num6 = 0u;
		uint modulo4 = 0u;
		if (num5 != 0)
		{
			num6 = System.Buffers.Text.FormattingHelpers.DivMod((uint)num5, 24u, out modulo4);
		}
		int num7 = 2;
		if (modulo4 < 10 && c == 'g')
		{
			num7--;
			num--;
		}
		int num8 = 0;
		if (num6 == 0)
		{
			if (c == 'G')
			{
				num += 2;
				num8 = 1;
			}
		}
		else
		{
			num8 = System.Buffers.Text.FormattingHelpers.CountDigits(num6);
			num += num8 + 1;
		}
		if (value.Ticks < 0)
		{
			num++;
		}
		if (destination.Length < num)
		{
			bytesWritten = 0;
			return false;
		}
		bytesWritten = num;
		int num9 = 0;
		if (value.Ticks < 0)
		{
			destination[num9++] = 45;
		}
		if (num8 > 0)
		{
			System.Buffers.Text.FormattingHelpers.WriteDigits(num6, destination.Slice(num9, num8));
			num9 += num8;
			destination[num9++] = (byte)((c == 'c') ? 46 : 58);
		}
		System.Buffers.Text.FormattingHelpers.WriteDigits(modulo4, destination.Slice(num9, num7));
		num9 += num7;
		destination[num9++] = 58;
		System.Buffers.Text.FormattingHelpers.WriteDigits((uint)modulo3, destination.Slice(num9, 2));
		num9 += 2;
		destination[num9++] = 58;
		System.Buffers.Text.FormattingHelpers.WriteDigits((uint)modulo2, destination.Slice(num9, 2));
		num9 += 2;
		if (num3 > 0)
		{
			destination[num9++] = 46;
			System.Buffers.Text.FormattingHelpers.WriteDigits(valueWithoutTrailingZeros, destination.Slice(num9, num3));
			num9 += num3;
		}
		return true;
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
private struct DecomposedGuid
{
	[FieldOffset(0)]
	public Guid Guid;

	[FieldOffset(0)]
	public byte Byte00;

	[FieldOffset(1)]
	public byte Byte01;

	[FieldOffset(2)]
	public byte Byte02;

	[FieldOffset(3)]
	public byte Byte03;

	[FieldOffset(4)]
	public byte Byte04;

	[FieldOffset(5)]
	public byte Byte05;

	[FieldOffset(6)]
	public byte Byte06;

	[FieldOffset(7)]
	public byte Byte07;

	[FieldOffset(8)]
	public byte Byte08;

	[FieldOffset(9)]
	public byte Byte09;

	[FieldOffset(10)]
	public byte Byte10;

	[FieldOffset(11)]
	public byte Byte11;

	[FieldOffset(12)]
	public byte Byte12;

	[FieldOffset(13)]
	public byte Byte13;

	[FieldOffset(14)]
	public byte Byte14;

	[FieldOffset(15)]
	public byte Byte15;
}


using System.Runtime.CompilerServices;

internal static class ParserHelpers
{
	public const int ByteOverflowLength = 3;

	public const int ByteOverflowLengthHex = 2;

	public const int UInt16OverflowLength = 5;

	public const int UInt16OverflowLengthHex = 4;

	public const int UInt32OverflowLength = 10;

	public const int UInt32OverflowLengthHex = 8;

	public const int UInt64OverflowLength = 20;

	public const int UInt64OverflowLengthHex = 16;

	public const int SByteOverflowLength = 3;

	public const int SByteOverflowLengthHex = 2;

	public const int Int16OverflowLength = 5;

	public const int Int16OverflowLengthHex = 4;

	public const int Int32OverflowLength = 10;

	public const int Int32OverflowLengthHex = 8;

	public const int Int64OverflowLength = 19;

	public const int Int64OverflowLengthHex = 16;

	public static readonly byte[] s_hexLookup = new byte[256]
	{
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 0, 1,
		2, 3, 4, 5, 6, 7, 8, 9, 255, 255,
		255, 255, 255, 255, 255, 10, 11, 12, 13, 14,
		15, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 10, 11, 12,
		13, 14, 15, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255
	};

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsDigit(int i)
	{
		return (uint)(i - 48) <= 9u;
	}
}


using System;
using System.Buffers.Text;
using System.Runtime.CompilerServices;

internal static class Utf8Parser
{
	[Flags]
	private enum ParseNumberOptions
	{
		AllowExponent = 1
	}

	private enum ComponentParseResult : byte
	{
		NoMoreData,
		Colon,
		Period,
		ParseFailure
	}

	private struct TimeSpanSplitter
	{
		public uint V1;

		public uint V2;

		public uint V3;

		public uint V4;

		public uint V5;

		public bool IsNegative;

		public uint Separators;

		public bool TrySplitTimeSpan(ReadOnlySpan<byte> source, bool periodUsedToSeparateDay, out int bytesConsumed)
		{
			int i = 0;
			byte b = 0;
			for (; i != source.Length; i++)
			{
				b = source[i];
				if (b != 32 && b != 9)
				{
					break;
				}
			}
			if (i == source.Length)
			{
				bytesConsumed = 0;
				return false;
			}
			if (b == 45)
			{
				IsNegative = true;
				i++;
				if (i == source.Length)
				{
					bytesConsumed = 0;
					return false;
				}
			}
			if (!TryParseUInt32D(source.Slice(i), out V1, out var bytesConsumed2))
			{
				bytesConsumed = 0;
				return false;
			}
			i += bytesConsumed2;
			ComponentParseResult componentParseResult = ParseComponent(source, periodUsedToSeparateDay, ref i, out V2);
			switch (componentParseResult)
			{
			case ComponentParseResult.ParseFailure:
				bytesConsumed = 0;
				return false;
			case ComponentParseResult.NoMoreData:
				bytesConsumed = i;
				return true;
			default:
				Separators |= (uint)componentParseResult << 24;
				componentParseResult = ParseComponent(source, neverParseAsFraction: false, ref i, out V3);
				switch (componentParseResult)
				{
				case ComponentParseResult.ParseFailure:
					bytesConsumed = 0;
					return false;
				case ComponentParseResult.NoMoreData:
					bytesConsumed = i;
					return true;
				default:
					Separators |= (uint)componentParseResult << 16;
					componentParseResult = ParseComponent(source, neverParseAsFraction: false, ref i, out V4);
					switch (componentParseResult)
					{
					case ComponentParseResult.ParseFailure:
						bytesConsumed = 0;
						return false;
					case ComponentParseResult.NoMoreData:
						bytesConsumed = i;
						return true;
					default:
						Separators |= (uint)componentParseResult << 8;
						componentParseResult = ParseComponent(source, neverParseAsFraction: false, ref i, out V5);
						switch (componentParseResult)
						{
						case ComponentParseResult.ParseFailure:
							bytesConsumed = 0;
							return false;
						case ComponentParseResult.NoMoreData:
							bytesConsumed = i;
							return true;
						default:
							Separators |= (uint)componentParseResult;
							if (i != source.Length && (source[i] == 46 || source[i] == 58))
							{
								bytesConsumed = 0;
								return false;
							}
							bytesConsumed = i;
							return true;
						}
					}
				}
			}
		}

		private static ComponentParseResult ParseComponent(ReadOnlySpan<byte> source, bool neverParseAsFraction, ref int srcIndex, out uint value)
		{
			if (srcIndex == source.Length)
			{
				value = 0u;
				return ComponentParseResult.NoMoreData;
			}
			byte b = source[srcIndex];
			if (b == 58 || (b == 46 && neverParseAsFraction))
			{
				srcIndex++;
				if (!TryParseUInt32D(source.Slice(srcIndex), out value, out var bytesConsumed))
				{
					value = 0u;
					return ComponentParseResult.ParseFailure;
				}
				srcIndex += bytesConsumed;
				if (b != 58)
				{
					return ComponentParseResult.Period;
				}
				return ComponentParseResult.Colon;
			}
			if (b == 46)
			{
				srcIndex++;
				if (!TryParseTimeSpanFraction(source.Slice(srcIndex), out value, out var bytesConsumed2))
				{
					value = 0u;
					return ComponentParseResult.ParseFailure;
				}
				srcIndex += bytesConsumed2;
				return ComponentParseResult.Period;
			}
			value = 0u;
			return ComponentParseResult.NoMoreData;
		}
	}

	private const uint FlipCase = 32u;

	private const uint NoFlipCase = 0u;

	private static readonly int[] s_daysToMonth365 = new int[13]
	{
		0, 31, 59, 90, 120, 151, 181, 212, 243, 273,
		304, 334, 365
	};

	private static readonly int[] s_daysToMonth366 = new int[13]
	{
		0, 31, 60, 91, 121, 152, 182, 213, 244, 274,
		305, 335, 366
	};

	public static bool TryParse(ReadOnlySpan<byte> source, out bool value, out int bytesConsumed, char standardFormat = '\0')
	{
		if (standardFormat != 0 && standardFormat != 'G' && standardFormat != 'l')
		{
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<bool>(out value, out bytesConsumed);
		}
		if (source.Length >= 4)
		{
			if ((source[0] == 84 || source[0] == 116) && (source[1] == 82 || source[1] == 114) && (source[2] == 85 || source[2] == 117) && (source[3] == 69 || source[3] == 101))
			{
				bytesConsumed = 4;
				value = true;
				return true;
			}
			if (source.Length >= 5 && (source[0] == 70 || source[0] == 102) && (source[1] == 65 || source[1] == 97) && (source[2] == 76 || source[2] == 108) && (source[3] == 83 || source[3] == 115) && (source[4] == 69 || source[4] == 101))
			{
				bytesConsumed = 5;
				value = false;
				return true;
			}
		}
		bytesConsumed = 0;
		value = false;
		return false;
	}

	public static bool TryParse(ReadOnlySpan<byte> source, out DateTime value, out int bytesConsumed, char standardFormat = '\0')
	{
		switch (standardFormat)
		{
		case 'R':
		{
			if (!TryParseDateTimeOffsetR(source, 0u, out var dateTimeOffset, out bytesConsumed))
			{
				value = default(DateTime);
				return false;
			}
			value = dateTimeOffset.DateTime;
			return true;
		}
		case 'l':
		{
			if (!TryParseDateTimeOffsetR(source, 32u, out var dateTimeOffset2, out bytesConsumed))
			{
				value = default(DateTime);
				return false;
			}
			value = dateTimeOffset2.DateTime;
			return true;
		}
		case 'O':
		{
			if (!TryParseDateTimeOffsetO(source, out var value2, out bytesConsumed, out var kind))
			{
				value = default(DateTime);
				bytesConsumed = 0;
				return false;
			}
			switch (kind)
			{
			case DateTimeKind.Local:
				value = value2.LocalDateTime;
				break;
			case DateTimeKind.Utc:
				value = value2.UtcDateTime;
				break;
			default:
				value = value2.DateTime;
				break;
			}
			return true;
		}
		case '\0':
		case 'G':
		{
			DateTimeOffset valueAsOffset;
			return TryParseDateTimeG(source, out value, out valueAsOffset, out bytesConsumed);
		}
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<DateTime>(out value, out bytesConsumed);
		}
	}

	public static bool TryParse(ReadOnlySpan<byte> source, out DateTimeOffset value, out int bytesConsumed, char standardFormat = '\0')
	{
		DateTimeKind kind;
		DateTime value2;
		return standardFormat switch
		{
			'R' => TryParseDateTimeOffsetR(source, 0u, out value, out bytesConsumed), 
			'l' => TryParseDateTimeOffsetR(source, 32u, out value, out bytesConsumed), 
			'O' => TryParseDateTimeOffsetO(source, out value, out bytesConsumed, out kind), 
			'\0' => TryParseDateTimeOffsetDefault(source, out value, out bytesConsumed), 
			'G' => TryParseDateTimeG(source, out value2, out value, out bytesConsumed), 
			_ => <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<DateTimeOffset>(out value, out bytesConsumed), 
		};
	}

	private static bool TryParseDateTimeOffsetDefault(ReadOnlySpan<byte> source, out DateTimeOffset value, out int bytesConsumed)
	{
		if (source.Length < 26)
		{
			bytesConsumed = 0;
			value = default(DateTimeOffset);
			return false;
		}
		if (!TryParseDateTimeG(source, out var value2, out var _, out var _))
		{
			bytesConsumed = 0;
			value = default(DateTimeOffset);
			return false;
		}
		if (source[19] != 32)
		{
			bytesConsumed = 0;
			value = default(DateTimeOffset);
			return false;
		}
		byte b = source[20];
		if (b != 43 && b != 45)
		{
			bytesConsumed = 0;
			value = default(DateTimeOffset);
			return false;
		}
		uint num = (uint)(source[21] - 48);
		uint num2 = (uint)(source[22] - 48);
		if (num > 9 || num2 > 9)
		{
			bytesConsumed = 0;
			value = default(DateTimeOffset);
			return false;
		}
		int num3 = (int)(num * 10 + num2);
		if (source[23] != 58)
		{
			bytesConsumed = 0;
			value = default(DateTimeOffset);
			return false;
		}
		uint num4 = (uint)(source[24] - 48);
		uint num5 = (uint)(source[25] - 48);
		if (num4 > 9 || num5 > 9)
		{
			bytesConsumed = 0;
			value = default(DateTimeOffset);
			return false;
		}
		int num6 = (int)(num4 * 10 + num5);
		TimeSpan timeSpan = new TimeSpan(num3, num6, 0);
		if (b == 45)
		{
			timeSpan = -timeSpan;
		}
		if (!TryCreateDateTimeOffset(value2, b == 45, num3, num6, out value))
		{
			bytesConsumed = 0;
			value = default(DateTimeOffset);
			return false;
		}
		bytesConsumed = 26;
		return true;
	}

	private static bool TryParseDateTimeG(ReadOnlySpan<byte> source, out DateTime value, out DateTimeOffset valueAsOffset, out int bytesConsumed)
	{
		if (source.Length < 19)
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		uint num = (uint)(source[0] - 48);
		uint num2 = (uint)(source[1] - 48);
		if (num > 9 || num2 > 9)
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		int month = (int)(num * 10 + num2);
		if (source[2] != 47)
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		uint num3 = (uint)(source[3] - 48);
		uint num4 = (uint)(source[4] - 48);
		if (num3 > 9 || num4 > 9)
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		int day = (int)(num3 * 10 + num4);
		if (source[5] != 47)
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		uint num5 = (uint)(source[6] - 48);
		uint num6 = (uint)(source[7] - 48);
		uint num7 = (uint)(source[8] - 48);
		uint num8 = (uint)(source[9] - 48);
		if (num5 > 9 || num6 > 9 || num7 > 9 || num8 > 9)
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		int year = (int)(num5 * 1000 + num6 * 100 + num7 * 10 + num8);
		if (source[10] != 32)
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		uint num9 = (uint)(source[11] - 48);
		uint num10 = (uint)(source[12] - 48);
		if (num9 > 9 || num10 > 9)
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		int hour = (int)(num9 * 10 + num10);
		if (source[13] != 58)
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		uint num11 = (uint)(source[14] - 48);
		uint num12 = (uint)(source[15] - 48);
		if (num11 > 9 || num12 > 9)
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		int minute = (int)(num11 * 10 + num12);
		if (source[16] != 58)
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		uint num13 = (uint)(source[17] - 48);
		uint num14 = (uint)(source[18] - 48);
		if (num13 > 9 || num14 > 9)
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		int second = (int)(num13 * 10 + num14);
		if (!TryCreateDateTimeOffsetInterpretingDataAsLocalTime(year, month, day, hour, minute, second, 0, out valueAsOffset))
		{
			bytesConsumed = 0;
			value = default(DateTime);
			valueAsOffset = default(DateTimeOffset);
			return false;
		}
		bytesConsumed = 19;
		value = valueAsOffset.DateTime;
		return true;
	}

	private static bool TryCreateDateTimeOffset(DateTime dateTime, bool offsetNegative, int offsetHours, int offsetMinutes, out DateTimeOffset value)
	{
		if ((uint)offsetHours > 14u)
		{
			value = default(DateTimeOffset);
			return false;
		}
		if ((uint)offsetMinutes > 59u)
		{
			value = default(DateTimeOffset);
			return false;
		}
		if (offsetHours == 14 && offsetMinutes != 0)
		{
			value = default(DateTimeOffset);
			return false;
		}
		long num = ((long)offsetHours * 3600L + (long)offsetMinutes * 60L) * 10000000;
		if (offsetNegative)
		{
			num = -num;
		}
		try
		{
			value = new DateTimeOffset(dateTime.Ticks, new TimeSpan(num));
		}
		catch (ArgumentOutOfRangeException)
		{
			value = default(DateTimeOffset);
			return false;
		}
		return true;
	}

	private static bool TryCreateDateTimeOffset(int year, int month, int day, int hour, int minute, int second, int fraction, bool offsetNegative, int offsetHours, int offsetMinutes, out DateTimeOffset value)
	{
		if (!TryCreateDateTime(year, month, day, hour, minute, second, fraction, DateTimeKind.Unspecified, out var value2))
		{
			value = default(DateTimeOffset);
			return false;
		}
		if (!TryCreateDateTimeOffset(value2, offsetNegative, offsetHours, offsetMinutes, out value))
		{
			value = default(DateTimeOffset);
			return false;
		}
		return true;
	}

	private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(int year, int month, int day, int hour, int minute, int second, int fraction, out DateTimeOffset value)
	{
		if (!TryCreateDateTime(year, month, day, hour, minute, second, fraction, DateTimeKind.Local, out var value2))
		{
			value = default(DateTimeOffset);
			return false;
		}
		try
		{
			value = new DateTimeOffset(value2);
		}
		catch (ArgumentOutOfRangeException)
		{
			value = default(DateTimeOffset);
			return false;
		}
		return true;
	}

	private static bool TryCreateDateTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeKind kind, out DateTime value)
	{
		if (year == 0)
		{
			value = default(DateTime);
			return false;
		}
		if ((uint)(month - 1) >= 12u)
		{
			value = default(DateTime);
			return false;
		}
		uint num = (uint)(day - 1);
		if (num >= 28 && num >= DateTime.DaysInMonth(year, month))
		{
			value = default(DateTime);
			return false;
		}
		if ((uint)hour > 23u)
		{
			value = default(DateTime);
			return false;
		}
		if ((uint)minute > 59u)
		{
			value = default(DateTime);
			return false;
		}
		if ((uint)second > 59u)
		{
			value = default(DateTime);
			return false;
		}
		int[] array = (DateTime.IsLeapYear(year) ? s_daysToMonth366 : s_daysToMonth365);
		int num2 = year - 1;
		int num3 = num2 * 365 + num2 / 4 - num2 / 100 + num2 / 400 + array[month - 1] + day - 1;
		long num4 = num3 * 864000000000L;
		int num5 = hour * 3600 + minute * 60 + second;
		num4 += (long)num5 * 10000000L;
		num4 += fraction;
		value = new DateTime(num4, kind);
		return true;
	}

	private static bool TryParseDateTimeOffsetO(ReadOnlySpan<byte> source, out DateTimeOffset value, out int bytesConsumed, out DateTimeKind kind)
	{
		if (source.Length < 27)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		uint num = (uint)(source[0] - 48);
		uint num2 = (uint)(source[1] - 48);
		uint num3 = (uint)(source[2] - 48);
		uint num4 = (uint)(source[3] - 48);
		if (num > 9 || num2 > 9 || num3 > 9 || num4 > 9)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		int year = (int)(num * 1000 + num2 * 100 + num3 * 10 + num4);
		if (source[4] != 45)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		uint num5 = (uint)(source[5] - 48);
		uint num6 = (uint)(source[6] - 48);
		if (num5 > 9 || num6 > 9)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		int month = (int)(num5 * 10 + num6);
		if (source[7] != 45)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		uint num7 = (uint)(source[8] - 48);
		uint num8 = (uint)(source[9] - 48);
		if (num7 > 9 || num8 > 9)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		int day = (int)(num7 * 10 + num8);
		if (source[10] != 84)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		uint num9 = (uint)(source[11] - 48);
		uint num10 = (uint)(source[12] - 48);
		if (num9 > 9 || num10 > 9)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		int hour = (int)(num9 * 10 + num10);
		if (source[13] != 58)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		uint num11 = (uint)(source[14] - 48);
		uint num12 = (uint)(source[15] - 48);
		if (num11 > 9 || num12 > 9)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		int minute = (int)(num11 * 10 + num12);
		if (source[16] != 58)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		uint num13 = (uint)(source[17] - 48);
		uint num14 = (uint)(source[18] - 48);
		if (num13 > 9 || num14 > 9)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		int second = (int)(num13 * 10 + num14);
		if (source[19] != 46)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		uint num15 = (uint)(source[20] - 48);
		uint num16 = (uint)(source[21] - 48);
		uint num17 = (uint)(source[22] - 48);
		uint num18 = (uint)(source[23] - 48);
		uint num19 = (uint)(source[24] - 48);
		uint num20 = (uint)(source[25] - 48);
		uint num21 = (uint)(source[26] - 48);
		if (num15 > 9 || num16 > 9 || num17 > 9 || num18 > 9 || num19 > 9 || num20 > 9 || num21 > 9)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		int fraction = (int)(num15 * 1000000 + num16 * 100000 + num17 * 10000 + num18 * 1000 + num19 * 100 + num20 * 10 + num21);
		byte b = (byte)((source.Length > 27) ? source[27] : 0);
		if (b != 90 && b != 43 && b != 45)
		{
			if (!TryCreateDateTimeOffsetInterpretingDataAsLocalTime(year, month, day, hour, minute, second, fraction, out value))
			{
				value = default(DateTimeOffset);
				bytesConsumed = 0;
				kind = DateTimeKind.Unspecified;
				return false;
			}
			bytesConsumed = 27;
			kind = DateTimeKind.Unspecified;
			return true;
		}
		if (b == 90)
		{
			if (!TryCreateDateTimeOffset(year, month, day, hour, minute, second, fraction, offsetNegative: false, 0, 0, out value))
			{
				value = default(DateTimeOffset);
				bytesConsumed = 0;
				kind = DateTimeKind.Unspecified;
				return false;
			}
			bytesConsumed = 28;
			kind = DateTimeKind.Utc;
			return true;
		}
		if (source.Length < 33)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		uint num22 = (uint)(source[28] - 48);
		uint num23 = (uint)(source[29] - 48);
		if (num22 > 9 || num23 > 9)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		int offsetHours = (int)(num22 * 10 + num23);
		if (source[30] != 58)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		uint num24 = (uint)(source[31] - 48);
		uint num25 = (uint)(source[32] - 48);
		if (num24 > 9 || num25 > 9)
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		int offsetMinutes = (int)(num24 * 10 + num25);
		if (!TryCreateDateTimeOffset(year, month, day, hour, minute, second, fraction, b == 45, offsetHours, offsetMinutes, out value))
		{
			value = default(DateTimeOffset);
			bytesConsumed = 0;
			kind = DateTimeKind.Unspecified;
			return false;
		}
		bytesConsumed = 33;
		kind = DateTimeKind.Local;
		return true;
	}

	private static bool TryParseDateTimeOffsetR(ReadOnlySpan<byte> source, uint caseFlipXorMask, out DateTimeOffset dateTimeOffset, out int bytesConsumed)
	{
		if (source.Length < 29)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		uint num = source[0] ^ caseFlipXorMask;
		uint num2 = source[1];
		uint num3 = source[2];
		uint num4 = source[3];
		DayOfWeek dayOfWeek;
		switch ((num << 24) | (num2 << 16) | (num3 << 8) | num4)
		{
		case 1400204844u:
			dayOfWeek = DayOfWeek.Sunday;
			break;
		case 1299148332u:
			dayOfWeek = DayOfWeek.Monday;
			break;
		case 1416979756u:
			dayOfWeek = DayOfWeek.Tuesday;
			break;
		case 1466262572u:
			dayOfWeek = DayOfWeek.Wednesday;
			break;
		case 1416131884u:
			dayOfWeek = DayOfWeek.Thursday;
			break;
		case 1181903148u:
			dayOfWeek = DayOfWeek.Friday;
			break;
		case 1398895660u:
			dayOfWeek = DayOfWeek.Saturday;
			break;
		default:
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		if (source[4] != 32)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		uint num5 = (uint)(source[5] - 48);
		uint num6 = (uint)(source[6] - 48);
		if (num5 > 9 || num6 > 9)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		int day = (int)(num5 * 10 + num6);
		if (source[7] != 32)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		uint num7 = source[8] ^ caseFlipXorMask;
		uint num8 = source[9];
		uint num9 = source[10];
		uint num10 = source[11];
		int month;
		switch ((num7 << 24) | (num8 << 16) | (num9 << 8) | num10)
		{
		case 1247899168u:
			month = 1;
			break;
		case 1181049376u:
			month = 2;
			break;
		case 1298231840u:
			month = 3;
			break;
		case 1097888288u:
			month = 4;
			break;
		case 1298233632u:
			month = 5;
			break;
		case 1249209888u:
			month = 6;
			break;
		case 1249209376u:
			month = 7;
			break;
		case 1098213152u:
			month = 8;
			break;
		case 1399156768u:
			month = 9;
			break;
		case 1331917856u:
			month = 10;
			break;
		case 1315927584u:
			month = 11;
			break;
		case 1147495200u:
			month = 12;
			break;
		default:
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		uint num11 = (uint)(source[12] - 48);
		uint num12 = (uint)(source[13] - 48);
		uint num13 = (uint)(source[14] - 48);
		uint num14 = (uint)(source[15] - 48);
		if (num11 > 9 || num12 > 9 || num13 > 9 || num14 > 9)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		int year = (int)(num11 * 1000 + num12 * 100 + num13 * 10 + num14);
		if (source[16] != 32)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		uint num15 = (uint)(source[17] - 48);
		uint num16 = (uint)(source[18] - 48);
		if (num15 > 9 || num16 > 9)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		int hour = (int)(num15 * 10 + num16);
		if (source[19] != 58)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		uint num17 = (uint)(source[20] - 48);
		uint num18 = (uint)(source[21] - 48);
		if (num17 > 9 || num18 > 9)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		int minute = (int)(num17 * 10 + num18);
		if (source[22] != 58)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		uint num19 = (uint)(source[23] - 48);
		uint num20 = (uint)(source[24] - 48);
		if (num19 > 9 || num20 > 9)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		int second = (int)(num19 * 10 + num20);
		uint num21 = source[25];
		uint num22 = source[26] ^ caseFlipXorMask;
		uint num23 = source[27] ^ caseFlipXorMask;
		uint num24 = source[28] ^ caseFlipXorMask;
		uint num25 = (num21 << 24) | (num22 << 16) | (num23 << 8) | num24;
		if (num25 != 541543764)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		if (!TryCreateDateTimeOffset(year, month, day, hour, minute, second, 0, offsetNegative: false, 0, 0, out dateTimeOffset))
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		if (dayOfWeek != dateTimeOffset.DayOfWeek)
		{
			bytesConsumed = 0;
			dateTimeOffset = default(DateTimeOffset);
			return false;
		}
		bytesConsumed = 29;
		return true;
	}

	public static bool TryParse(ReadOnlySpan<byte> source, out decimal value, out int bytesConsumed, char standardFormat = '\0')
	{
		ParseNumberOptions options;
		switch (standardFormat)
		{
		case '\0':
		case 'E':
		case 'G':
		case 'e':
		case 'g':
			options = ParseNumberOptions.AllowExponent;
			break;
		case 'F':
		case 'f':
			options = (ParseNumberOptions)0;
			break;
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<decimal>(out value, out bytesConsumed);
		}
		NumberBuffer number = default(NumberBuffer);
		if (!TryParseNumber(source, ref number, out bytesConsumed, options, out var textUsedExponentNotation))
		{
			value = default(decimal);
			return false;
		}
		if (!textUsedExponentNotation && (standardFormat == 'E' || standardFormat == 'e'))
		{
			value = default(decimal);
			bytesConsumed = 0;
			return false;
		}
		if (number.Digits[0] == 0 && number.Scale == 0)
		{
			number.IsNegative = false;
		}
		value = default(decimal);
		if (!System.Number.NumberBufferToDecimal(ref number, ref value))
		{
			value = default(decimal);
			bytesConsumed = 0;
			return false;
		}
		return true;
	}

	public static bool TryParse(ReadOnlySpan<byte> source, out float value, out int bytesConsumed, char standardFormat = '\0')
	{
		if (TryParseNormalAsFloatingPoint(source, out var value2, out bytesConsumed, standardFormat))
		{
			value = (float)value2;
			if (float.IsInfinity(value))
			{
				value = 0f;
				bytesConsumed = 0;
				return false;
			}
			return true;
		}
		return TryParseAsSpecialFloatingPoint(source, float.PositiveInfinity, float.NegativeInfinity, float.NaN, out value, out bytesConsumed);
	}

	public static bool TryParse(ReadOnlySpan<byte> source, out double value, out int bytesConsumed, char standardFormat = '\0')
	{
		if (TryParseNormalAsFloatingPoint(source, out value, out bytesConsumed, standardFormat))
		{
			return true;
		}
		return TryParseAsSpecialFloatingPoint(source, double.PositiveInfinity, double.NegativeInfinity, double.NaN, out value, out bytesConsumed);
	}

	private static bool TryParseNormalAsFloatingPoint(ReadOnlySpan<byte> source, out double value, out int bytesConsumed, char standardFormat)
	{
		ParseNumberOptions options;
		switch (standardFormat)
		{
		case '\0':
		case 'E':
		case 'G':
		case 'e':
		case 'g':
			options = ParseNumberOptions.AllowExponent;
			break;
		case 'F':
		case 'f':
			options = (ParseNumberOptions)0;
			break;
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<double>(out value, out bytesConsumed);
		}
		NumberBuffer number = default(NumberBuffer);
		if (!TryParseNumber(source, ref number, out bytesConsumed, options, out var textUsedExponentNotation))
		{
			value = 0.0;
			return false;
		}
		if (!textUsedExponentNotation && (standardFormat == 'E' || standardFormat == 'e'))
		{
			value = 0.0;
			bytesConsumed = 0;
			return false;
		}
		if (number.Digits[0] == 0)
		{
			number.IsNegative = false;
		}
		if (!System.Number.NumberBufferToDouble(ref number, out value))
		{
			value = 0.0;
			bytesConsumed = 0;
			return false;
		}
		return true;
	}

	private static bool TryParseAsSpecialFloatingPoint<T>(ReadOnlySpan<byte> source, T positiveInfinity, T negativeInfinity, T nan, out T value, out int bytesConsumed)
	{
		if (source.Length >= 8 && source[0] == 73 && source[1] == 110 && source[2] == 102 && source[3] == 105 && source[4] == 110 && source[5] == 105 && source[6] == 116 && source[7] == 121)
		{
			value = positiveInfinity;
			bytesConsumed = 8;
			return true;
		}
		if (source.Length >= 9 && source[0] == 45 && source[1] == 73 && source[2] == 110 && source[3] == 102 && source[4] == 105 && source[5] == 110 && source[6] == 105 && source[7] == 116 && source[8] == 121)
		{
			value = negativeInfinity;
			bytesConsumed = 9;
			return true;
		}
		if (source.Length >= 3 && source[0] == 78 && source[1] == 97 && source[2] == 78)
		{
			value = nan;
			bytesConsumed = 3;
			return true;
		}
		value = default(T);
		bytesConsumed = 0;
		return false;
	}

	public static bool TryParse(ReadOnlySpan<byte> source, out Guid value, out int bytesConsumed, char standardFormat = '\0')
	{
		switch (standardFormat)
		{
		case '\0':
		case 'D':
			return TryParseGuidCore(source, ends: false, ' ', ' ', out value, out bytesConsumed);
		case 'B':
			return TryParseGuidCore(source, ends: true, '{', '}', out value, out bytesConsumed);
		case 'P':
			return TryParseGuidCore(source, ends: true, '(', ')', out value, out bytesConsumed);
		case 'N':
			return TryParseGuidN(source, out value, out bytesConsumed);
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<Guid>(out value, out bytesConsumed);
		}
	}

	private static bool TryParseGuidN(ReadOnlySpan<byte> text, out Guid value, out int bytesConsumed)
	{
		if (text.Length < 32)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (!TryParseUInt32X(text.Slice(0, 8), out var value2, out var bytesConsumed2) || bytesConsumed2 != 8)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (!TryParseUInt16X(text.Slice(8, 4), out var value3, out bytesConsumed2) || bytesConsumed2 != 4)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (!TryParseUInt16X(text.Slice(12, 4), out var value4, out bytesConsumed2) || bytesConsumed2 != 4)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (!TryParseUInt16X(text.Slice(16, 4), out var value5, out bytesConsumed2) || bytesConsumed2 != 4)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (!TryParseUInt64X(text.Slice(20), out var value6, out bytesConsumed2) || bytesConsumed2 != 12)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		bytesConsumed = 32;
		value = new Guid((int)value2, (short)value3, (short)value4, (byte)(value5 >> 8), (byte)value5, (byte)(value6 >> 40), (byte)(value6 >> 32), (byte)(value6 >> 24), (byte)(value6 >> 16), (byte)(value6 >> 8), (byte)value6);
		return true;
	}

	private static bool TryParseGuidCore(ReadOnlySpan<byte> source, bool ends, char begin, char end, out Guid value, out int bytesConsumed)
	{
		int num = 36 + (ends ? 2 : 0);
		if (source.Length < num)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (ends)
		{
			if (source[0] != begin)
			{
				value = default(Guid);
				bytesConsumed = 0;
				return false;
			}
			source = source.Slice(1);
		}
		if (!TryParseUInt32X(source, out var value2, out var bytesConsumed2))
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (bytesConsumed2 != 8)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (source[bytesConsumed2] != 45)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		source = source.Slice(9);
		if (!TryParseUInt16X(source, out var value3, out bytesConsumed2))
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (bytesConsumed2 != 4)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (source[bytesConsumed2] != 45)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		source = source.Slice(5);
		if (!TryParseUInt16X(source, out var value4, out bytesConsumed2))
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (bytesConsumed2 != 4)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (source[bytesConsumed2] != 45)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		source = source.Slice(5);
		if (!TryParseUInt16X(source, out var value5, out bytesConsumed2))
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (bytesConsumed2 != 4)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (source[bytesConsumed2] != 45)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		source = source.Slice(5);
		if (!TryParseUInt64X(source, out var value6, out bytesConsumed2))
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (bytesConsumed2 != 12)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		if (ends && source[bytesConsumed2] != end)
		{
			value = default(Guid);
			bytesConsumed = 0;
			return false;
		}
		bytesConsumed = num;
		value = new Guid((int)value2, (short)value3, (short)value4, (byte)(value5 >> 8), (byte)value5, (byte)(value6 >> 40), (byte)(value6 >> 32), (byte)(value6 >> 24), (byte)(value6 >> 16), (byte)(value6 >> 8), (byte)value6);
		return true;
	}

	[CLSCompliant(false)]
	public static bool TryParse(ReadOnlySpan<byte> source, out sbyte value, out int bytesConsumed, char standardFormat = '\0')
	{
		switch (standardFormat)
		{
		case '\0':
		case 'D':
		case 'G':
		case 'd':
		case 'g':
			return TryParseSByteD(source, out value, out bytesConsumed);
		case 'N':
		case 'n':
			return TryParseSByteN(source, out value, out bytesConsumed);
		case 'X':
		case 'x':
			value = 0;
			return TryParseByteX(source, out Unsafe.As<sbyte, byte>(ref value), out bytesConsumed);
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<sbyte>(out value, out bytesConsumed);
		}
	}

	public static bool TryParse(ReadOnlySpan<byte> source, out short value, out int bytesConsumed, char standardFormat = '\0')
	{
		switch (standardFormat)
		{
		case '\0':
		case 'D':
		case 'G':
		case 'd':
		case 'g':
			return TryParseInt16D(source, out value, out bytesConsumed);
		case 'N':
		case 'n':
			return TryParseInt16N(source, out value, out bytesConsumed);
		case 'X':
		case 'x':
			value = 0;
			return TryParseUInt16X(source, out Unsafe.As<short, ushort>(ref value), out bytesConsumed);
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<short>(out value, out bytesConsumed);
		}
	}

	public static bool TryParse(ReadOnlySpan<byte> source, out int value, out int bytesConsumed, char standardFormat = '\0')
	{
		switch (standardFormat)
		{
		case '\0':
		case 'D':
		case 'G':
		case 'd':
		case 'g':
			return TryParseInt32D(source, out value, out bytesConsumed);
		case 'N':
		case 'n':
			return TryParseInt32N(source, out value, out bytesConsumed);
		case 'X':
		case 'x':
			value = 0;
			return TryParseUInt32X(source, out Unsafe.As<int, uint>(ref value), out bytesConsumed);
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<int>(out value, out bytesConsumed);
		}
	}

	public static bool TryParse(ReadOnlySpan<byte> source, out long value, out int bytesConsumed, char standardFormat = '\0')
	{
		switch (standardFormat)
		{
		case '\0':
		case 'D':
		case 'G':
		case 'd':
		case 'g':
			return TryParseInt64D(source, out value, out bytesConsumed);
		case 'N':
		case 'n':
			return TryParseInt64N(source, out value, out bytesConsumed);
		case 'X':
		case 'x':
			value = 0L;
			return TryParseUInt64X(source, out Unsafe.As<long, ulong>(ref value), out bytesConsumed);
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<long>(out value, out bytesConsumed);
		}
	}

	private static bool TryParseSByteD(ReadOnlySpan<byte> source, out sbyte value, out int bytesConsumed)
	{
		int num;
		int num2;
		int num4;
		int num3;
		if (source.Length >= 1)
		{
			num = 1;
			num2 = 0;
			num3 = source[num2];
			if (num3 == 45)
			{
				num = -1;
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_0123;
				}
				num3 = source[num2];
			}
			else if (num3 == 43)
			{
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_0123;
				}
				num3 = source[num2];
			}
			num4 = 0;
			if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
			{
				if (num3 != 48)
				{
					goto IL_009c;
				}
				while (true)
				{
					num2++;
					if ((uint)num2 >= (uint)source.Length)
					{
						break;
					}
					num3 = source[num2];
					if (num3 == 48)
					{
						continue;
					}
					goto IL_0091;
				}
				goto IL_012b;
			}
		}
		goto IL_0123;
		IL_012b:
		bytesConsumed = num2;
		value = (sbyte)(num4 * num);
		return true;
		IL_009c:
		num4 = num3 - 48;
		num2++;
		if ((uint)num2 < (uint)source.Length)
		{
			num3 = source[num2];
			if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
			{
				num2++;
				num4 = 10 * num4 + num3 - 48;
				if ((uint)num2 < (uint)source.Length)
				{
					num3 = source[num2];
					if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
					{
						num2++;
						num4 = num4 * 10 + num3 - 48;
						if ((uint)num4 > 127L + (long)((-1 * num + 1) / 2) || ((uint)num2 < (uint)source.Length && System.Buffers.Text.ParserHelpers.IsDigit(source[num2])))
						{
							goto IL_0123;
						}
					}
				}
			}
		}
		goto IL_012b;
		IL_0123:
		bytesConsumed = 0;
		value = 0;
		return false;
		IL_0091:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
		{
			goto IL_009c;
		}
		goto IL_012b;
	}

	private static bool TryParseInt16D(ReadOnlySpan<byte> source, out short value, out int bytesConsumed)
	{
		int num;
		int num2;
		int num4;
		int num3;
		if (source.Length >= 1)
		{
			num = 1;
			num2 = 0;
			num3 = source[num2];
			if (num3 == 45)
			{
				num = -1;
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_0186;
				}
				num3 = source[num2];
			}
			else if (num3 == 43)
			{
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_0186;
				}
				num3 = source[num2];
			}
			num4 = 0;
			if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
			{
				if (num3 != 48)
				{
					goto IL_009c;
				}
				while (true)
				{
					num2++;
					if ((uint)num2 >= (uint)source.Length)
					{
						break;
					}
					num3 = source[num2];
					if (num3 == 48)
					{
						continue;
					}
					goto IL_0091;
				}
				goto IL_018e;
			}
		}
		goto IL_0186;
		IL_018e:
		bytesConsumed = num2;
		value = (short)(num4 * num);
		return true;
		IL_009c:
		num4 = num3 - 48;
		num2++;
		if ((uint)num2 < (uint)source.Length)
		{
			num3 = source[num2];
			if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
			{
				num2++;
				num4 = 10 * num4 + num3 - 48;
				if ((uint)num2 < (uint)source.Length)
				{
					num3 = source[num2];
					if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
					{
						num2++;
						num4 = 10 * num4 + num3 - 48;
						if ((uint)num2 < (uint)source.Length)
						{
							num3 = source[num2];
							if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
							{
								num2++;
								num4 = 10 * num4 + num3 - 48;
								if ((uint)num2 < (uint)source.Length)
								{
									num3 = source[num2];
									if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
									{
										num2++;
										num4 = num4 * 10 + num3 - 48;
										if ((uint)num4 > 32767L + (long)((-1 * num + 1) / 2) || ((uint)num2 < (uint)source.Length && System.Buffers.Text.ParserHelpers.IsDigit(source[num2])))
										{
											goto IL_0186;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		goto IL_018e;
		IL_0186:
		bytesConsumed = 0;
		value = 0;
		return false;
		IL_0091:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
		{
			goto IL_009c;
		}
		goto IL_018e;
	}

	private static bool TryParseInt32D(ReadOnlySpan<byte> source, out int value, out int bytesConsumed)
	{
		int num;
		int num2;
		int num4;
		int num3;
		if (source.Length >= 1)
		{
			num = 1;
			num2 = 0;
			num3 = source[num2];
			if (num3 == 45)
			{
				num = -1;
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_0281;
				}
				num3 = source[num2];
			}
			else if (num3 == 43)
			{
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_0281;
				}
				num3 = source[num2];
			}
			num4 = 0;
			if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
			{
				if (num3 != 48)
				{
					goto IL_009c;
				}
				while (true)
				{
					num2++;
					if ((uint)num2 >= (uint)source.Length)
					{
						break;
					}
					num3 = source[num2];
					if (num3 == 48)
					{
						continue;
					}
					goto IL_0091;
				}
				goto IL_0289;
			}
		}
		goto IL_0281;
		IL_0289:
		bytesConsumed = num2;
		value = num4 * num;
		return true;
		IL_009c:
		num4 = num3 - 48;
		num2++;
		if ((uint)num2 < (uint)source.Length)
		{
			num3 = source[num2];
			if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
			{
				num2++;
				num4 = 10 * num4 + num3 - 48;
				if ((uint)num2 < (uint)source.Length)
				{
					num3 = source[num2];
					if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
					{
						num2++;
						num4 = 10 * num4 + num3 - 48;
						if ((uint)num2 < (uint)source.Length)
						{
							num3 = source[num2];
							if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
							{
								num2++;
								num4 = 10 * num4 + num3 - 48;
								if ((uint)num2 < (uint)source.Length)
								{
									num3 = source[num2];
									if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
									{
										num2++;
										num4 = 10 * num4 + num3 - 48;
										if ((uint)num2 < (uint)source.Length)
										{
											num3 = source[num2];
											if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
											{
												num2++;
												num4 = 10 * num4 + num3 - 48;
												if ((uint)num2 < (uint)source.Length)
												{
													num3 = source[num2];
													if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
													{
														num2++;
														num4 = 10 * num4 + num3 - 48;
														if ((uint)num2 < (uint)source.Length)
														{
															num3 = source[num2];
															if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
															{
																num2++;
																num4 = 10 * num4 + num3 - 48;
																if ((uint)num2 < (uint)source.Length)
																{
																	num3 = source[num2];
																	if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
																	{
																		num2++;
																		num4 = 10 * num4 + num3 - 48;
																		if ((uint)num2 < (uint)source.Length)
																		{
																			num3 = source[num2];
																			if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
																			{
																				num2++;
																				if (num4 <= 214748364)
																				{
																					num4 = num4 * 10 + num3 - 48;
																					if ((uint)num4 <= 2147483647L + (long)((-1 * num + 1) / 2) && ((uint)num2 >= (uint)source.Length || !System.Buffers.Text.ParserHelpers.IsDigit(source[num2])))
																					{
																						goto IL_0289;
																					}
																				}
																				goto IL_0281;
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		goto IL_0289;
		IL_0281:
		bytesConsumed = 0;
		value = 0;
		return false;
		IL_0091:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
		{
			goto IL_009c;
		}
		goto IL_0289;
	}

	private static bool TryParseInt64D(ReadOnlySpan<byte> source, out long value, out int bytesConsumed)
	{
		if (source.Length < 1)
		{
			bytesConsumed = 0;
			value = 0L;
			return false;
		}
		int num = 0;
		int num2 = 1;
		if (source[0] == 45)
		{
			num = 1;
			num2 = -1;
			if (source.Length <= num)
			{
				bytesConsumed = 0;
				value = 0L;
				return false;
			}
		}
		else if (source[0] == 43)
		{
			num = 1;
			if (source.Length <= num)
			{
				bytesConsumed = 0;
				value = 0L;
				return false;
			}
		}
		int num3 = 19 + num;
		long num4 = source[num] - 48;
		if (num4 < 0 || num4 > 9)
		{
			bytesConsumed = 0;
			value = 0L;
			return false;
		}
		ulong num5 = (ulong)num4;
		if (source.Length < num3)
		{
			for (int i = num + 1; i < source.Length; i++)
			{
				long num6 = source[i] - 48;
				if (num6 < 0 || num6 > 9)
				{
					bytesConsumed = i;
					value = (long)num5 * (long)num2;
					return true;
				}
				num5 = num5 * 10 + (ulong)num6;
			}
		}
		else
		{
			for (int j = num + 1; j < num3 - 1; j++)
			{
				long num7 = source[j] - 48;
				if (num7 < 0 || num7 > 9)
				{
					bytesConsumed = j;
					value = (long)num5 * (long)num2;
					return true;
				}
				num5 = num5 * 10 + (ulong)num7;
			}
			for (int k = num3 - 1; k < source.Length; k++)
			{
				long num8 = source[k] - 48;
				if (num8 < 0 || num8 > 9)
				{
					bytesConsumed = k;
					value = (long)num5 * (long)num2;
					return true;
				}
				bool flag = num2 > 0;
				bool flag2 = num8 > 8 || (flag && num8 > 7);
				if (num5 > 922337203685477580L || (num5 == 922337203685477580L && flag2))
				{
					bytesConsumed = 0;
					value = 0L;
					return false;
				}
				num5 = num5 * 10 + (ulong)num8;
			}
		}
		bytesConsumed = source.Length;
		value = (long)num5 * (long)num2;
		return true;
	}

	private static bool TryParseSByteN(ReadOnlySpan<byte> source, out sbyte value, out int bytesConsumed)
	{
		int num;
		int num2;
		int num4;
		int num3;
		if (source.Length >= 1)
		{
			num = 1;
			num2 = 0;
			num3 = source[num2];
			if (num3 == 45)
			{
				num = -1;
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_00f9;
				}
				num3 = source[num2];
			}
			else if (num3 == 43)
			{
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_00f9;
				}
				num3 = source[num2];
			}
			if (num3 != 46)
			{
				if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
				{
					num4 = num3 - 48;
					while (true)
					{
						num2++;
						if ((uint)num2 >= (uint)source.Length)
						{
							break;
						}
						num3 = source[num2];
						if (num3 == 44)
						{
							continue;
						}
						if (num3 == 46)
						{
							goto IL_00d4;
						}
						if (!System.Buffers.Text.ParserHelpers.IsDigit(num3))
						{
							break;
						}
						num4 = num4 * 10 + num3 - 48;
						if (num4 <= 127 + (-1 * num + 1) / 2)
						{
							continue;
						}
						goto IL_00f9;
					}
					goto IL_0101;
				}
			}
			else
			{
				num4 = 0;
				num2++;
				if ((uint)num2 < (uint)source.Length && source[num2] == 48)
				{
					goto IL_00d4;
				}
			}
		}
		goto IL_00f9;
		IL_00f9:
		bytesConsumed = 0;
		value = 0;
		return false;
		IL_00f1:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
		{
			goto IL_00f9;
		}
		goto IL_0101;
		IL_00d4:
		while (true)
		{
			num2++;
			if ((uint)num2 >= (uint)source.Length)
			{
				break;
			}
			num3 = source[num2];
			if (num3 == 48)
			{
				continue;
			}
			goto IL_00f1;
		}
		goto IL_0101;
		IL_0101:
		bytesConsumed = num2;
		value = (sbyte)(num4 * num);
		return true;
	}

	private static bool TryParseInt16N(ReadOnlySpan<byte> source, out short value, out int bytesConsumed)
	{
		int num;
		int num2;
		int num4;
		int num3;
		if (source.Length >= 1)
		{
			num = 1;
			num2 = 0;
			num3 = source[num2];
			if (num3 == 45)
			{
				num = -1;
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_00ff;
				}
				num3 = source[num2];
			}
			else if (num3 == 43)
			{
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_00ff;
				}
				num3 = source[num2];
			}
			if (num3 != 46)
			{
				if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
				{
					num4 = num3 - 48;
					while (true)
					{
						num2++;
						if ((uint)num2 >= (uint)source.Length)
						{
							break;
						}
						num3 = source[num2];
						if (num3 == 44)
						{
							continue;
						}
						if (num3 == 46)
						{
							goto IL_00da;
						}
						if (!System.Buffers.Text.ParserHelpers.IsDigit(num3))
						{
							break;
						}
						num4 = num4 * 10 + num3 - 48;
						if (num4 <= 32767 + (-1 * num + 1) / 2)
						{
							continue;
						}
						goto IL_00ff;
					}
					goto IL_0107;
				}
			}
			else
			{
				num4 = 0;
				num2++;
				if ((uint)num2 < (uint)source.Length && source[num2] == 48)
				{
					goto IL_00da;
				}
			}
		}
		goto IL_00ff;
		IL_00ff:
		bytesConsumed = 0;
		value = 0;
		return false;
		IL_00f7:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
		{
			goto IL_00ff;
		}
		goto IL_0107;
		IL_00da:
		while (true)
		{
			num2++;
			if ((uint)num2 >= (uint)source.Length)
			{
				break;
			}
			num3 = source[num2];
			if (num3 == 48)
			{
				continue;
			}
			goto IL_00f7;
		}
		goto IL_0107;
		IL_0107:
		bytesConsumed = num2;
		value = (short)(num4 * num);
		return true;
	}

	private static bool TryParseInt32N(ReadOnlySpan<byte> source, out int value, out int bytesConsumed)
	{
		int num;
		int num2;
		int num4;
		int num3;
		if (source.Length >= 1)
		{
			num = 1;
			num2 = 0;
			num3 = source[num2];
			if (num3 == 45)
			{
				num = -1;
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_010a;
				}
				num3 = source[num2];
			}
			else if (num3 == 43)
			{
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_010a;
				}
				num3 = source[num2];
			}
			if (num3 != 46)
			{
				if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
				{
					num4 = num3 - 48;
					while (true)
					{
						num2++;
						if ((uint)num2 >= (uint)source.Length)
						{
							break;
						}
						num3 = source[num2];
						if (num3 == 44)
						{
							continue;
						}
						if (num3 == 46)
						{
							goto IL_00e5;
						}
						if (!System.Buffers.Text.ParserHelpers.IsDigit(num3))
						{
							break;
						}
						if ((uint)num4 <= 214748364u)
						{
							num4 = num4 * 10 + num3 - 48;
							if ((uint)num4 <= 2147483647L + (long)((-1 * num + 1) / 2))
							{
								continue;
							}
						}
						goto IL_010a;
					}
					goto IL_0112;
				}
			}
			else
			{
				num4 = 0;
				num2++;
				if ((uint)num2 < (uint)source.Length && source[num2] == 48)
				{
					goto IL_00e5;
				}
			}
		}
		goto IL_010a;
		IL_010a:
		bytesConsumed = 0;
		value = 0;
		return false;
		IL_0102:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
		{
			goto IL_010a;
		}
		goto IL_0112;
		IL_00e5:
		while (true)
		{
			num2++;
			if ((uint)num2 >= (uint)source.Length)
			{
				break;
			}
			num3 = source[num2];
			if (num3 == 48)
			{
				continue;
			}
			goto IL_0102;
		}
		goto IL_0112;
		IL_0112:
		bytesConsumed = num2;
		value = num4 * num;
		return true;
	}

	private static bool TryParseInt64N(ReadOnlySpan<byte> source, out long value, out int bytesConsumed)
	{
		int num;
		int num2;
		long num4;
		int num3;
		if (source.Length >= 1)
		{
			num = 1;
			num2 = 0;
			num3 = source[num2];
			if (num3 == 45)
			{
				num = -1;
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_0115;
				}
				num3 = source[num2];
			}
			else if (num3 == 43)
			{
				num2++;
				if ((uint)num2 >= (uint)source.Length)
				{
					goto IL_0115;
				}
				num3 = source[num2];
			}
			if (num3 != 46)
			{
				if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
				{
					num4 = num3 - 48;
					while (true)
					{
						num2++;
						if ((uint)num2 >= (uint)source.Length)
						{
							break;
						}
						num3 = source[num2];
						if (num3 == 44)
						{
							continue;
						}
						if (num3 == 46)
						{
							goto IL_00f0;
						}
						if (!System.Buffers.Text.ParserHelpers.IsDigit(num3))
						{
							break;
						}
						if ((ulong)num4 <= 922337203685477580uL)
						{
							num4 = num4 * 10 + num3 - 48;
							if ((ulong)num4 <= (ulong)(long.MaxValue + (-1 * num + 1) / 2))
							{
								continue;
							}
						}
						goto IL_0115;
					}
					goto IL_011e;
				}
			}
			else
			{
				num4 = 0L;
				num2++;
				if ((uint)num2 < (uint)source.Length && source[num2] == 48)
				{
					goto IL_00f0;
				}
			}
		}
		goto IL_0115;
		IL_0115:
		bytesConsumed = 0;
		value = 0L;
		return false;
		IL_010d:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num3))
		{
			goto IL_0115;
		}
		goto IL_011e;
		IL_00f0:
		while (true)
		{
			num2++;
			if ((uint)num2 >= (uint)source.Length)
			{
				break;
			}
			num3 = source[num2];
			if (num3 == 48)
			{
				continue;
			}
			goto IL_010d;
		}
		goto IL_011e;
		IL_011e:
		bytesConsumed = num2;
		value = num4 * num;
		return true;
	}

	public static bool TryParse(ReadOnlySpan<byte> source, out byte value, out int bytesConsumed, char standardFormat = '\0')
	{
		switch (standardFormat)
		{
		case '\0':
		case 'D':
		case 'G':
		case 'd':
		case 'g':
			return TryParseByteD(source, out value, out bytesConsumed);
		case 'N':
		case 'n':
			return TryParseByteN(source, out value, out bytesConsumed);
		case 'X':
		case 'x':
			return TryParseByteX(source, out value, out bytesConsumed);
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<byte>(out value, out bytesConsumed);
		}
	}

	[CLSCompliant(false)]
	public static bool TryParse(ReadOnlySpan<byte> source, out ushort value, out int bytesConsumed, char standardFormat = '\0')
	{
		switch (standardFormat)
		{
		case '\0':
		case 'D':
		case 'G':
		case 'd':
		case 'g':
			return TryParseUInt16D(source, out value, out bytesConsumed);
		case 'N':
		case 'n':
			return TryParseUInt16N(source, out value, out bytesConsumed);
		case 'X':
		case 'x':
			return TryParseUInt16X(source, out value, out bytesConsumed);
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<ushort>(out value, out bytesConsumed);
		}
	}

	[CLSCompliant(false)]
	public static bool TryParse(ReadOnlySpan<byte> source, out uint value, out int bytesConsumed, char standardFormat = '\0')
	{
		switch (standardFormat)
		{
		case '\0':
		case 'D':
		case 'G':
		case 'd':
		case 'g':
			return TryParseUInt32D(source, out value, out bytesConsumed);
		case 'N':
		case 'n':
			return TryParseUInt32N(source, out value, out bytesConsumed);
		case 'X':
		case 'x':
			return TryParseUInt32X(source, out value, out bytesConsumed);
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<uint>(out value, out bytesConsumed);
		}
	}

	[CLSCompliant(false)]
	public static bool TryParse(ReadOnlySpan<byte> source, out ulong value, out int bytesConsumed, char standardFormat = '\0')
	{
		switch (standardFormat)
		{
		case '\0':
		case 'D':
		case 'G':
		case 'd':
		case 'g':
			return TryParseUInt64D(source, out value, out bytesConsumed);
		case 'N':
		case 'n':
			return TryParseUInt64N(source, out value, out bytesConsumed);
		case 'X':
		case 'x':
			return TryParseUInt64X(source, out value, out bytesConsumed);
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<ulong>(out value, out bytesConsumed);
		}
	}

	private static bool TryParseByteD(ReadOnlySpan<byte> source, out byte value, out int bytesConsumed)
	{
		int num;
		int num3;
		int num2;
		if (source.Length >= 1)
		{
			num = 0;
			num2 = source[num];
			num3 = 0;
			if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
			{
				if (num2 != 48)
				{
					goto IL_0056;
				}
				while (true)
				{
					num++;
					if ((uint)num >= (uint)source.Length)
					{
						break;
					}
					num2 = source[num];
					if (num2 == 48)
					{
						continue;
					}
					goto IL_004b;
				}
				goto IL_00dd;
			}
		}
		goto IL_00d5;
		IL_004b:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
		{
			goto IL_0056;
		}
		goto IL_00dd;
		IL_0056:
		num3 = num2 - 48;
		num++;
		if ((uint)num < (uint)source.Length)
		{
			num2 = source[num];
			if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
			{
				num++;
				num3 = 10 * num3 + num2 - 48;
				if ((uint)num < (uint)source.Length)
				{
					num2 = source[num];
					if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
					{
						num++;
						num3 = num3 * 10 + num2 - 48;
						if ((uint)num3 > 255u || ((uint)num < (uint)source.Length && System.Buffers.Text.ParserHelpers.IsDigit(source[num])))
						{
							goto IL_00d5;
						}
					}
				}
			}
		}
		goto IL_00dd;
		IL_00dd:
		bytesConsumed = num;
		value = (byte)num3;
		return true;
		IL_00d5:
		bytesConsumed = 0;
		value = 0;
		return false;
	}

	private static bool TryParseUInt16D(ReadOnlySpan<byte> source, out ushort value, out int bytesConsumed)
	{
		int num;
		int num3;
		int num2;
		if (source.Length >= 1)
		{
			num = 0;
			num2 = source[num];
			num3 = 0;
			if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
			{
				if (num2 != 48)
				{
					goto IL_0056;
				}
				while (true)
				{
					num++;
					if ((uint)num >= (uint)source.Length)
					{
						break;
					}
					num2 = source[num];
					if (num2 == 48)
					{
						continue;
					}
					goto IL_004b;
				}
				goto IL_013d;
			}
		}
		goto IL_0135;
		IL_004b:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
		{
			goto IL_0056;
		}
		goto IL_013d;
		IL_0056:
		num3 = num2 - 48;
		num++;
		if ((uint)num < (uint)source.Length)
		{
			num2 = source[num];
			if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
			{
				num++;
				num3 = 10 * num3 + num2 - 48;
				if ((uint)num < (uint)source.Length)
				{
					num2 = source[num];
					if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
					{
						num++;
						num3 = 10 * num3 + num2 - 48;
						if ((uint)num < (uint)source.Length)
						{
							num2 = source[num];
							if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
							{
								num++;
								num3 = 10 * num3 + num2 - 48;
								if ((uint)num < (uint)source.Length)
								{
									num2 = source[num];
									if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
									{
										num++;
										num3 = num3 * 10 + num2 - 48;
										if ((uint)num3 > 65535u || ((uint)num < (uint)source.Length && System.Buffers.Text.ParserHelpers.IsDigit(source[num])))
										{
											goto IL_0135;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		goto IL_013d;
		IL_013d:
		bytesConsumed = num;
		value = (ushort)num3;
		return true;
		IL_0135:
		bytesConsumed = 0;
		value = 0;
		return false;
	}

	private static bool TryParseUInt32D(ReadOnlySpan<byte> source, out uint value, out int bytesConsumed)
	{
		int num;
		int num3;
		int num2;
		if (source.Length >= 1)
		{
			num = 0;
			num2 = source[num];
			num3 = 0;
			if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
			{
				if (num2 != 48)
				{
					goto IL_0056;
				}
				while (true)
				{
					num++;
					if ((uint)num >= (uint)source.Length)
					{
						break;
					}
					num2 = source[num];
					if (num2 == 48)
					{
						continue;
					}
					goto IL_004b;
				}
				goto IL_023d;
			}
		}
		goto IL_0235;
		IL_004b:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
		{
			goto IL_0056;
		}
		goto IL_023d;
		IL_0056:
		num3 = num2 - 48;
		num++;
		if ((uint)num < (uint)source.Length)
		{
			num2 = source[num];
			if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
			{
				num++;
				num3 = 10 * num3 + num2 - 48;
				if ((uint)num < (uint)source.Length)
				{
					num2 = source[num];
					if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
					{
						num++;
						num3 = 10 * num3 + num2 - 48;
						if ((uint)num < (uint)source.Length)
						{
							num2 = source[num];
							if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
							{
								num++;
								num3 = 10 * num3 + num2 - 48;
								if ((uint)num < (uint)source.Length)
								{
									num2 = source[num];
									if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
									{
										num++;
										num3 = 10 * num3 + num2 - 48;
										if ((uint)num < (uint)source.Length)
										{
											num2 = source[num];
											if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
											{
												num++;
												num3 = 10 * num3 + num2 - 48;
												if ((uint)num < (uint)source.Length)
												{
													num2 = source[num];
													if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
													{
														num++;
														num3 = 10 * num3 + num2 - 48;
														if ((uint)num < (uint)source.Length)
														{
															num2 = source[num];
															if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
															{
																num++;
																num3 = 10 * num3 + num2 - 48;
																if ((uint)num < (uint)source.Length)
																{
																	num2 = source[num];
																	if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
																	{
																		num++;
																		num3 = 10 * num3 + num2 - 48;
																		if ((uint)num < (uint)source.Length)
																		{
																			num2 = source[num];
																			if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
																			{
																				num++;
																				if ((uint)num3 <= 429496729u && (num3 != 429496729 || num2 <= 53))
																				{
																					num3 = num3 * 10 + num2 - 48;
																					if ((uint)num >= (uint)source.Length || !System.Buffers.Text.ParserHelpers.IsDigit(source[num]))
																					{
																						goto IL_023d;
																					}
																				}
																				goto IL_0235;
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		goto IL_023d;
		IL_023d:
		bytesConsumed = num;
		value = (uint)num3;
		return true;
		IL_0235:
		bytesConsumed = 0;
		value = 0u;
		return false;
	}

	private static bool TryParseUInt64D(ReadOnlySpan<byte> source, out ulong value, out int bytesConsumed)
	{
		if (source.Length < 1)
		{
			bytesConsumed = 0;
			value = 0uL;
			return false;
		}
		ulong num = (uint)(source[0] - 48);
		if (num > 9)
		{
			bytesConsumed = 0;
			value = 0uL;
			return false;
		}
		ulong num2 = num;
		if (source.Length < 19)
		{
			for (int i = 1; i < source.Length; i++)
			{
				ulong num3 = (uint)(source[i] - 48);
				if (num3 > 9)
				{
					bytesConsumed = i;
					value = num2;
					return true;
				}
				num2 = num2 * 10 + num3;
			}
		}
		else
		{
			for (int j = 1; j < 18; j++)
			{
				ulong num4 = (uint)(source[j] - 48);
				if (num4 > 9)
				{
					bytesConsumed = j;
					value = num2;
					return true;
				}
				num2 = num2 * 10 + num4;
			}
			for (int k = 18; k < source.Length; k++)
			{
				ulong num5 = (uint)(source[k] - 48);
				if (num5 > 9)
				{
					bytesConsumed = k;
					value = num2;
					return true;
				}
				if (num2 > 1844674407370955161L || (num2 == 1844674407370955161L && num5 > 5))
				{
					bytesConsumed = 0;
					value = 0uL;
					return false;
				}
				num2 = num2 * 10 + num5;
			}
		}
		bytesConsumed = source.Length;
		value = num2;
		return true;
	}

	private static bool TryParseByteN(ReadOnlySpan<byte> source, out byte value, out int bytesConsumed)
	{
		int num;
		int num3;
		int num2;
		if (source.Length >= 1)
		{
			num = 0;
			num2 = source[num];
			if (num2 == 43)
			{
				num++;
				if ((uint)num >= (uint)source.Length)
				{
					goto IL_00ce;
				}
				num2 = source[num];
			}
			if (num2 != 46)
			{
				if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
				{
					num3 = num2 - 48;
					while (true)
					{
						num++;
						if ((uint)num >= (uint)source.Length)
						{
							break;
						}
						num2 = source[num];
						if (num2 == 44)
						{
							continue;
						}
						if (num2 == 46)
						{
							goto IL_00a9;
						}
						if (!System.Buffers.Text.ParserHelpers.IsDigit(num2))
						{
							break;
						}
						num3 = num3 * 10 + num2 - 48;
						if (num3 <= 255)
						{
							continue;
						}
						goto IL_00ce;
					}
					goto IL_00d6;
				}
			}
			else
			{
				num3 = 0;
				num++;
				if ((uint)num < (uint)source.Length && source[num] == 48)
				{
					goto IL_00a9;
				}
			}
		}
		goto IL_00ce;
		IL_00c6:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
		{
			goto IL_00ce;
		}
		goto IL_00d6;
		IL_00a9:
		while (true)
		{
			num++;
			if ((uint)num >= (uint)source.Length)
			{
				break;
			}
			num2 = source[num];
			if (num2 == 48)
			{
				continue;
			}
			goto IL_00c6;
		}
		goto IL_00d6;
		IL_00d6:
		bytesConsumed = num;
		value = (byte)num3;
		return true;
		IL_00ce:
		bytesConsumed = 0;
		value = 0;
		return false;
	}

	private static bool TryParseUInt16N(ReadOnlySpan<byte> source, out ushort value, out int bytesConsumed)
	{
		int num;
		int num3;
		int num2;
		if (source.Length >= 1)
		{
			num = 0;
			num2 = source[num];
			if (num2 == 43)
			{
				num++;
				if ((uint)num >= (uint)source.Length)
				{
					goto IL_00ce;
				}
				num2 = source[num];
			}
			if (num2 != 46)
			{
				if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
				{
					num3 = num2 - 48;
					while (true)
					{
						num++;
						if ((uint)num >= (uint)source.Length)
						{
							break;
						}
						num2 = source[num];
						if (num2 == 44)
						{
							continue;
						}
						if (num2 == 46)
						{
							goto IL_00a9;
						}
						if (!System.Buffers.Text.ParserHelpers.IsDigit(num2))
						{
							break;
						}
						num3 = num3 * 10 + num2 - 48;
						if (num3 <= 65535)
						{
							continue;
						}
						goto IL_00ce;
					}
					goto IL_00d6;
				}
			}
			else
			{
				num3 = 0;
				num++;
				if ((uint)num < (uint)source.Length && source[num] == 48)
				{
					goto IL_00a9;
				}
			}
		}
		goto IL_00ce;
		IL_00c6:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
		{
			goto IL_00ce;
		}
		goto IL_00d6;
		IL_00a9:
		while (true)
		{
			num++;
			if ((uint)num >= (uint)source.Length)
			{
				break;
			}
			num2 = source[num];
			if (num2 == 48)
			{
				continue;
			}
			goto IL_00c6;
		}
		goto IL_00d6;
		IL_00d6:
		bytesConsumed = num;
		value = (ushort)num3;
		return true;
		IL_00ce:
		bytesConsumed = 0;
		value = 0;
		return false;
	}

	private static bool TryParseUInt32N(ReadOnlySpan<byte> source, out uint value, out int bytesConsumed)
	{
		int num;
		int num3;
		int num2;
		if (source.Length >= 1)
		{
			num = 0;
			num2 = source[num];
			if (num2 == 43)
			{
				num++;
				if ((uint)num >= (uint)source.Length)
				{
					goto IL_00de;
				}
				num2 = source[num];
			}
			if (num2 != 46)
			{
				if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
				{
					num3 = num2 - 48;
					while (true)
					{
						num++;
						if ((uint)num >= (uint)source.Length)
						{
							break;
						}
						num2 = source[num];
						if (num2 == 44)
						{
							continue;
						}
						if (num2 == 46)
						{
							goto IL_00b9;
						}
						if (!System.Buffers.Text.ParserHelpers.IsDigit(num2))
						{
							break;
						}
						if ((uint)num3 <= 429496729u && (num3 != 429496729 || num2 <= 53))
						{
							num3 = num3 * 10 + num2 - 48;
							continue;
						}
						goto IL_00de;
					}
					goto IL_00e6;
				}
			}
			else
			{
				num3 = 0;
				num++;
				if ((uint)num < (uint)source.Length && source[num] == 48)
				{
					goto IL_00b9;
				}
			}
		}
		goto IL_00de;
		IL_00de:
		bytesConsumed = 0;
		value = 0u;
		return false;
		IL_00b9:
		while (true)
		{
			num++;
			if ((uint)num >= (uint)source.Length)
			{
				break;
			}
			num2 = source[num];
			if (num2 == 48)
			{
				continue;
			}
			goto IL_00d6;
		}
		goto IL_00e6;
		IL_00e6:
		bytesConsumed = num;
		value = (uint)num3;
		return true;
		IL_00d6:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
		{
			goto IL_00de;
		}
		goto IL_00e6;
	}

	private static bool TryParseUInt64N(ReadOnlySpan<byte> source, out ulong value, out int bytesConsumed)
	{
		int num;
		long num3;
		int num2;
		if (source.Length >= 1)
		{
			num = 0;
			num2 = source[num];
			if (num2 == 43)
			{
				num++;
				if ((uint)num >= (uint)source.Length)
				{
					goto IL_00eb;
				}
				num2 = source[num];
			}
			if (num2 != 46)
			{
				if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
				{
					num3 = num2 - 48;
					while (true)
					{
						num++;
						if ((uint)num >= (uint)source.Length)
						{
							break;
						}
						num2 = source[num];
						if (num2 == 44)
						{
							continue;
						}
						if (num2 == 46)
						{
							goto IL_00c6;
						}
						if (!System.Buffers.Text.ParserHelpers.IsDigit(num2))
						{
							break;
						}
						if ((ulong)num3 <= 1844674407370955161uL && (num3 != 1844674407370955161L || num2 <= 53))
						{
							num3 = num3 * 10 + num2 - 48;
							continue;
						}
						goto IL_00eb;
					}
					goto IL_00f4;
				}
			}
			else
			{
				num3 = 0L;
				num++;
				if ((uint)num < (uint)source.Length && source[num] == 48)
				{
					goto IL_00c6;
				}
			}
		}
		goto IL_00eb;
		IL_00eb:
		bytesConsumed = 0;
		value = 0uL;
		return false;
		IL_00c6:
		while (true)
		{
			num++;
			if ((uint)num >= (uint)source.Length)
			{
				break;
			}
			num2 = source[num];
			if (num2 == 48)
			{
				continue;
			}
			goto IL_00e3;
		}
		goto IL_00f4;
		IL_00f4:
		bytesConsumed = num;
		value = (ulong)num3;
		return true;
		IL_00e3:
		if (System.Buffers.Text.ParserHelpers.IsDigit(num2))
		{
			goto IL_00eb;
		}
		goto IL_00f4;
	}

	private static bool TryParseByteX(ReadOnlySpan<byte> source, out byte value, out int bytesConsumed)
	{
		if (source.Length < 1)
		{
			bytesConsumed = 0;
			value = 0;
			return false;
		}
		byte[] s_hexLookup = System.Buffers.Text.ParserHelpers.s_hexLookup;
		byte b = source[0];
		byte b2 = s_hexLookup[b];
		if (b2 == byte.MaxValue)
		{
			bytesConsumed = 0;
			value = 0;
			return false;
		}
		uint num = b2;
		if (source.Length <= 2)
		{
			for (int i = 1; i < source.Length; i++)
			{
				b = source[i];
				b2 = s_hexLookup[b];
				if (b2 == byte.MaxValue)
				{
					bytesConsumed = i;
					value = (byte)num;
					return true;
				}
				num = (num << 4) + b2;
			}
		}
		else
		{
			for (int j = 1; j < 2; j++)
			{
				b = source[j];
				b2 = s_hexLookup[b];
				if (b2 == byte.MaxValue)
				{
					bytesConsumed = j;
					value = (byte)num;
					return true;
				}
				num = (num << 4) + b2;
			}
			for (int k = 2; k < source.Length; k++)
			{
				b = source[k];
				b2 = s_hexLookup[b];
				if (b2 == byte.MaxValue)
				{
					bytesConsumed = k;
					value = (byte)num;
					return true;
				}
				if (num > 15)
				{
					bytesConsumed = 0;
					value = 0;
					return false;
				}
				num = (num << 4) + b2;
			}
		}
		bytesConsumed = source.Length;
		value = (byte)num;
		return true;
	}

	private static bool TryParseUInt16X(ReadOnlySpan<byte> source, out ushort value, out int bytesConsumed)
	{
		if (source.Length < 1)
		{
			bytesConsumed = 0;
			value = 0;
			return false;
		}
		byte[] s_hexLookup = System.Buffers.Text.ParserHelpers.s_hexLookup;
		byte b = source[0];
		byte b2 = s_hexLookup[b];
		if (b2 == byte.MaxValue)
		{
			bytesConsumed = 0;
			value = 0;
			return false;
		}
		uint num = b2;
		if (source.Length <= 4)
		{
			for (int i = 1; i < source.Length; i++)
			{
				b = source[i];
				b2 = s_hexLookup[b];
				if (b2 == byte.MaxValue)
				{
					bytesConsumed = i;
					value = (ushort)num;
					return true;
				}
				num = (num << 4) + b2;
			}
		}
		else
		{
			for (int j = 1; j < 4; j++)
			{
				b = source[j];
				b2 = s_hexLookup[b];
				if (b2 == byte.MaxValue)
				{
					bytesConsumed = j;
					value = (ushort)num;
					return true;
				}
				num = (num << 4) + b2;
			}
			for (int k = 4; k < source.Length; k++)
			{
				b = source[k];
				b2 = s_hexLookup[b];
				if (b2 == byte.MaxValue)
				{
					bytesConsumed = k;
					value = (ushort)num;
					return true;
				}
				if (num > 4095)
				{
					bytesConsumed = 0;
					value = 0;
					return false;
				}
				num = (num << 4) + b2;
			}
		}
		bytesConsumed = source.Length;
		value = (ushort)num;
		return true;
	}

	private static bool TryParseUInt32X(ReadOnlySpan<byte> source, out uint value, out int bytesConsumed)
	{
		if (source.Length < 1)
		{
			bytesConsumed = 0;
			value = 0u;
			return false;
		}
		byte[] s_hexLookup = System.Buffers.Text.ParserHelpers.s_hexLookup;
		byte b = source[0];
		byte b2 = s_hexLookup[b];
		if (b2 == byte.MaxValue)
		{
			bytesConsumed = 0;
			value = 0u;
			return false;
		}
		uint num = b2;
		if (source.Length <= 8)
		{
			for (int i = 1; i < source.Length; i++)
			{
				b = source[i];
				b2 = s_hexLookup[b];
				if (b2 == byte.MaxValue)
				{
					bytesConsumed = i;
					value = num;
					return true;
				}
				num = (num << 4) + b2;
			}
		}
		else
		{
			for (int j = 1; j < 8; j++)
			{
				b = source[j];
				b2 = s_hexLookup[b];
				if (b2 == byte.MaxValue)
				{
					bytesConsumed = j;
					value = num;
					return true;
				}
				num = (num << 4) + b2;
			}
			for (int k = 8; k < source.Length; k++)
			{
				b = source[k];
				b2 = s_hexLookup[b];
				if (b2 == byte.MaxValue)
				{
					bytesConsumed = k;
					value = num;
					return true;
				}
				if (num > 268435455)
				{
					bytesConsumed = 0;
					value = 0u;
					return false;
				}
				num = (num << 4) + b2;
			}
		}
		bytesConsumed = source.Length;
		value = num;
		return true;
	}

	private static bool TryParseUInt64X(ReadOnlySpan<byte> source, out ulong value, out int bytesConsumed)
	{
		if (source.Length < 1)
		{
			bytesConsumed = 0;
			value = 0uL;
			return false;
		}
		byte[] s_hexLookup = System.Buffers.Text.ParserHelpers.s_hexLookup;
		byte b = source[0];
		byte b2 = s_hexLookup[b];
		if (b2 == byte.MaxValue)
		{
			bytesConsumed = 0;
			value = 0uL;
			return false;
		}
		ulong num = b2;
		if (source.Length <= 16)
		{
			for (int i = 1; i < source.Length; i++)
			{
				b = source[i];
				b2 = s_hexLookup[b];
				if (b2 == byte.MaxValue)
				{
					bytesConsumed = i;
					value = num;
					return true;
				}
				num = (num << 4) + b2;
			}
		}
		else
		{
			for (int j = 1; j < 16; j++)
			{
				b = source[j];
				b2 = s_hexLookup[b];
				if (b2 == byte.MaxValue)
				{
					bytesConsumed = j;
					value = num;
					return true;
				}
				num = (num << 4) + b2;
			}
			for (int k = 16; k < source.Length; k++)
			{
				b = source[k];
				b2 = s_hexLookup[b];
				if (b2 == byte.MaxValue)
				{
					bytesConsumed = k;
					value = num;
					return true;
				}
				if (num > 1152921504606846975L)
				{
					bytesConsumed = 0;
					value = 0uL;
					return false;
				}
				num = (num << 4) + b2;
			}
		}
		bytesConsumed = source.Length;
		value = num;
		return true;
	}

	private static bool TryParseNumber(ReadOnlySpan<byte> source, ref NumberBuffer number, out int bytesConsumed, ParseNumberOptions options, out bool textUsedExponentNotation)
	{
		textUsedExponentNotation = false;
		if (source.Length == 0)
		{
			bytesConsumed = 0;
			return false;
		}
		Span<byte> digits = number.Digits;
		int i = 0;
		int num = 0;
		byte b = source[i];
		if (b != 43)
		{
			if (b != 45)
			{
				goto IL_0055;
			}
			number.IsNegative = true;
		}
		i++;
		if (i == source.Length)
		{
			bytesConsumed = 0;
			return false;
		}
		b = source[i];
		goto IL_0055;
		IL_0229:
		if (!TryParseUInt32D(source.Slice(i), out var value, out var bytesConsumed2))
		{
			bytesConsumed = 0;
			return false;
		}
		i += bytesConsumed2;
		bool flag;
		if (flag)
		{
			if (number.Scale < int.MinValue + value)
			{
				number.Scale = int.MinValue;
			}
			else
			{
				number.Scale -= (int)value;
			}
		}
		else
		{
			if (number.Scale > 2147483647L - (long)value)
			{
				bytesConsumed = 0;
				return false;
			}
			number.Scale += (int)value;
		}
		bytesConsumed = i;
		return true;
		IL_0055:
		int num2 = i;
		for (; i != source.Length; i++)
		{
			b = source[i];
			if (b != 48)
			{
				break;
			}
		}
		if (i == source.Length)
		{
			digits[0] = 0;
			number.Scale = 0;
			bytesConsumed = i;
			return true;
		}
		int num3 = i;
		for (; i != source.Length; i++)
		{
			b = source[i];
			if ((uint)(b - 48) > 9u)
			{
				break;
			}
		}
		int num4 = i - num2;
		int num5 = i - num3;
		int num6 = Math.Min(num5, 50);
		source.Slice(num3, num6).CopyTo(digits);
		num = num6;
		number.Scale = num5;
		if (i == source.Length)
		{
			bytesConsumed = i;
			return true;
		}
		int num7 = 0;
		if (b == 46)
		{
			i++;
			int num8 = i;
			for (; i != source.Length; i++)
			{
				b = source[i];
				if ((uint)(b - 48) > 9u)
				{
					break;
				}
			}
			num7 = i - num8;
			int j = num8;
			if (num == 0)
			{
				for (; j < i && source[j] == 48; j++)
				{
					number.Scale--;
				}
			}
			int num9 = Math.Min(i - j, 51 - num - 1);
			source.Slice(j, num9).CopyTo(digits.Slice(num));
			num += num9;
			if (i == source.Length)
			{
				if (num4 == 0 && num7 == 0)
				{
					bytesConsumed = 0;
					return false;
				}
				bytesConsumed = i;
				return true;
			}
		}
		if (num4 == 0 && num7 == 0)
		{
			bytesConsumed = 0;
			return false;
		}
		if ((b & -33) != 69)
		{
			bytesConsumed = i;
			return true;
		}
		textUsedExponentNotation = true;
		i++;
		if ((options & ParseNumberOptions.AllowExponent) == 0)
		{
			bytesConsumed = 0;
			return false;
		}
		if (i == source.Length)
		{
			bytesConsumed = 0;
			return false;
		}
		flag = false;
		b = source[i];
		if (b != 43)
		{
			if (b != 45)
			{
				goto IL_0229;
			}
			flag = true;
		}
		i++;
		if (i == source.Length)
		{
			bytesConsumed = 0;
			return false;
		}
		b = source[i];
		goto IL_0229;
	}

	private static bool TryParseTimeSpanBigG(ReadOnlySpan<byte> source, out TimeSpan value, out int bytesConsumed)
	{
		int i = 0;
		byte b = 0;
		for (; i != source.Length; i++)
		{
			b = source[i];
			if (b != 32 && b != 9)
			{
				break;
			}
		}
		if (i == source.Length)
		{
			value = default(TimeSpan);
			bytesConsumed = 0;
			return false;
		}
		bool isNegative = false;
		if (b == 45)
		{
			isNegative = true;
			i++;
			if (i == source.Length)
			{
				value = default(TimeSpan);
				bytesConsumed = 0;
				return false;
			}
		}
		if (!TryParseUInt32D(source.Slice(i), out var value2, out var bytesConsumed2))
		{
			value = default(TimeSpan);
			bytesConsumed = 0;
			return false;
		}
		i += bytesConsumed2;
		if (i == source.Length || source[i++] != 58)
		{
			value = default(TimeSpan);
			bytesConsumed = 0;
			return false;
		}
		if (!TryParseUInt32D(source.Slice(i), out var value3, out bytesConsumed2))
		{
			value = default(TimeSpan);
			bytesConsumed = 0;
			return false;
		}
		i += bytesConsumed2;
		if (i == source.Length || source[i++] != 58)
		{
			value = default(TimeSpan);
			bytesConsumed = 0;
			return false;
		}
		if (!TryParseUInt32D(source.Slice(i), out var value4, out bytesConsumed2))
		{
			value = default(TimeSpan);
			bytesConsumed = 0;
			return false;
		}
		i += bytesConsumed2;
		if (i == source.Length || source[i++] != 58)
		{
			value = default(TimeSpan);
			bytesConsumed = 0;
			return false;
		}
		if (!TryParseUInt32D(source.Slice(i), out var value5, out bytesConsumed2))
		{
			value = default(TimeSpan);
			bytesConsumed = 0;
			return false;
		}
		i += bytesConsumed2;
		if (i == source.Length || source[i++] != 46)
		{
			value = default(TimeSpan);
			bytesConsumed = 0;
			return false;
		}
		if (!TryParseTimeSpanFraction(source.Slice(i), out var value6, out bytesConsumed2))
		{
			value = default(TimeSpan);
			bytesConsumed = 0;
			return false;
		}
		i += bytesConsumed2;
		if (!TryCreateTimeSpan(isNegative, value2, value3, value4, value5, value6, out value))
		{
			value = default(TimeSpan);
			bytesConsumed = 0;
			return false;
		}
		if (i != source.Length && (source[i] == 46 || source[i] == 58))
		{
			value = default(TimeSpan);
			bytesConsumed = 0;
			return false;
		}
		bytesConsumed = i;
		return true;
	}

	private static bool TryParseTimeSpanC(ReadOnlySpan<byte> source, out TimeSpan value, out int bytesConsumed)
	{
		TimeSpanSplitter timeSpanSplitter = default(TimeSpanSplitter);
		if (!timeSpanSplitter.TrySplitTimeSpan(source, periodUsedToSeparateDay: true, out bytesConsumed))
		{
			value = default(TimeSpan);
			return false;
		}
		bool isNegative = timeSpanSplitter.IsNegative;
		bool flag;
		switch (timeSpanSplitter.Separators)
		{
		case 0u:
			flag = TryCreateTimeSpan(isNegative, timeSpanSplitter.V1, 0u, 0u, 0u, 0u, out value);
			break;
		case 16777216u:
			flag = TryCreateTimeSpan(isNegative, 0u, timeSpanSplitter.V1, timeSpanSplitter.V2, 0u, 0u, out value);
			break;
		case 33619968u:
			flag = TryCreateTimeSpan(isNegative, timeSpanSplitter.V1, timeSpanSplitter.V2, timeSpanSplitter.V3, 0u, 0u, out value);
			break;
		case 16842752u:
			flag = TryCreateTimeSpan(isNegative, 0u, timeSpanSplitter.V1, timeSpanSplitter.V2, timeSpanSplitter.V3, 0u, out value);
			break;
		case 33620224u:
			flag = TryCreateTimeSpan(isNegative, timeSpanSplitter.V1, timeSpanSplitter.V2, timeSpanSplitter.V3, timeSpanSplitter.V4, 0u, out value);
			break;
		case 16843264u:
			flag = TryCreateTimeSpan(isNegative, 0u, timeSpanSplitter.V1, timeSpanSplitter.V2, timeSpanSplitter.V3, timeSpanSplitter.V4, out value);
			break;
		case 33620226u:
			flag = TryCreateTimeSpan(isNegative, timeSpanSplitter.V1, timeSpanSplitter.V2, timeSpanSplitter.V3, timeSpanSplitter.V4, timeSpanSplitter.V5, out value);
			break;
		default:
			value = default(TimeSpan);
			flag = false;
			break;
		}
		if (!flag)
		{
			bytesConsumed = 0;
			return false;
		}
		return true;
	}

	public static bool TryParse(ReadOnlySpan<byte> source, out TimeSpan value, out int bytesConsumed, char standardFormat = '\0')
	{
		switch (standardFormat)
		{
		case '\0':
		case 'T':
		case 'c':
		case 't':
			return TryParseTimeSpanC(source, out value, out bytesConsumed);
		case 'G':
			return TryParseTimeSpanBigG(source, out value, out bytesConsumed);
		case 'g':
			return TryParseTimeSpanLittleG(source, out value, out bytesConsumed);
		default:
			return <efefee0c-bc34-4852-a4f2-f3a29a97a3fc>ThrowHelper.TryParseThrowFormatException<TimeSpan>(out value, out bytesConsumed);
		}
	}

	private static bool TryParseTimeSpanFraction(ReadOnlySpan<byte> source, out uint value, out int bytesConsumed)
	{
		int num = 0;
		if (num == source.Length)
		{
			value = 0u;
			bytesConsumed = 0;
			return false;
		}
		uint num2 = (uint)(source[num] - 48);
		if (num2 > 9)
		{
			value = 0u;
			bytesConsumed = 0;
			return false;
		}
		num++;
		uint num3 = num2;
		int num4 = 1;
		while (num != source.Length)
		{
			num2 = (uint)(source[num] - 48);
			if (num2 > 9)
			{
				break;
			}
			num++;
			num4++;
			if (num4 > 7)
			{
				value = 0u;
				bytesConsumed = 0;
				return false;
			}
			num3 = 10 * num3 + num2;
		}
		switch (num4)
		{
		case 6:
			num3 *= 10;
			break;
		case 5:
			num3 *= 100;
			break;
		case 4:
			num3 *= 1000;
			break;
		case 3:
			num3 *= 10000;
			break;
		case 2:
			num3 *= 100000;
			break;
		default:
			num3 *= 1000000;
			break;
		case 7:
			break;
		}
		value = num3;
		bytesConsumed = num;
		return true;
	}

	private static bool TryCreateTimeSpan(bool isNegative, uint days, uint hours, uint minutes, uint seconds, uint fraction, out TimeSpan timeSpan)
	{
		if (hours > 23 || minutes > 59 || seconds > 59)
		{
			timeSpan = default(TimeSpan);
			return false;
		}
		long num = ((long)days * 3600L * 24 + (long)hours * 3600L + (long)minutes * 60L + seconds) * 1000;
		long ticks;
		if (isNegative)
		{
			num = -num;
			if (num < -922337203685477L)
			{
				timeSpan = default(TimeSpan);
				return false;
			}
			long num2 = num * 10000;
			if (num2 < long.MinValue + fraction)
			{
				timeSpan = default(TimeSpan);
				return false;
			}
			ticks = num2 - fraction;
		}
		else
		{
			if (num > 922337203685477L)
			{
				timeSpan = default(TimeSpan);
				return false;
			}
			long num3 = num * 10000;
			if (num3 > long.MaxValue - (long)fraction)
			{
				timeSpan = default(TimeSpan);
				return false;
			}
			ticks = num3 + fraction;
		}
		timeSpan = new TimeSpan(ticks);
		return true;
	}

	private static bool TryParseTimeSpanLittleG(ReadOnlySpan<byte> source, out TimeSpan value, out int bytesConsumed)
	{
		TimeSpanSplitter timeSpanSplitter = default(TimeSpanSplitter);
		if (!timeSpanSplitter.TrySplitTimeSpan(source, periodUsedToSeparateDay: false, out bytesConsumed))
		{
			value = default(TimeSpan);
			return false;
		}
		bool isNegative = timeSpanSplitter.IsNegative;
		bool flag;
		switch (timeSpanSplitter.Separators)
		{
		case 0u:
			flag = TryCreateTimeSpan(isNegative, timeSpanSplitter.V1, 0u, 0u, 0u, 0u, out value);
			break;
		case 16777216u:
			flag = TryCreateTimeSpan(isNegative, 0u, timeSpanSplitter.V1, timeSpanSplitter.V2, 0u, 0u, out value);
			break;
		case 16842752u:
			flag = TryCreateTimeSpan(isNegative, 0u, timeSpanSplitter.V1, timeSpanSplitter.V2, timeSpanSplitter.V3, 0u, out value);
			break;
		case 16843008u:
			flag = TryCreateTimeSpan(isNegative, timeSpanSplitter.V1, timeSpanSplitter.V2, timeSpanSplitter.V3, timeSpanSplitter.V4, 0u, out value);
			break;
		case 16843264u:
			flag = TryCreateTimeSpan(isNegative, 0u, timeSpanSplitter.V1, timeSpanSplitter.V2, timeSpanSplitter.V3, timeSpanSplitter.V4, out value);
			break;
		case 16843010u:
			flag = TryCreateTimeSpan(isNegative, timeSpanSplitter.V1, timeSpanSplitter.V2, timeSpanSplitter.V3, timeSpanSplitter.V4, timeSpanSplitter.V5, out value);
			break;
		default:
			value = default(TimeSpan);
			flag = false;
			break;
		}
		if (!flag)
		{
			bytesConsumed = 0;
			return false;
		}
		return true;
	}
}


[Flags]
private enum ParseNumberOptions
{
	AllowExponent = 1
}


private enum ComponentParseResult : byte
{
	NoMoreData,
	Colon,
	Period,
	ParseFailure
}


private struct TimeSpanSplitter
{
	public uint V1;

	public uint V2;

	public uint V3;

	public uint V4;

	public uint V5;

	public bool IsNegative;

	public uint Separators;

	public bool TrySplitTimeSpan(ReadOnlySpan<byte> source, bool periodUsedToSeparateDay, out int bytesConsumed)
	{
		int i = 0;
		byte b = 0;
		for (; i != source.Length; i++)
		{
			b = source[i];
			if (b != 32 && b != 9)
			{
				break;
			}
		}
		if (i == source.Length)
		{
			bytesConsumed = 0;
			return false;
		}
		if (b == 45)
		{
			IsNegative = true;
			i++;
			if (i == source.Length)
			{
				bytesConsumed = 0;
				return false;
			}
		}
		if (!TryParseUInt32D(source.Slice(i), out V1, out var bytesConsumed2))
		{
			bytesConsumed = 0;
			return false;
		}
		i += bytesConsumed2;
		ComponentParseResult componentParseResult = ParseComponent(source, periodUsedToSeparateDay, ref i, out V2);
		switch (componentParseResult)
		{
		case ComponentParseResult.ParseFailure:
			bytesConsumed = 0;
			return false;
		case ComponentParseResult.NoMoreData:
			bytesConsumed = i;
			return true;
		default:
			Separators |= (uint)componentParseResult << 24;
			componentParseResult = ParseComponent(source, neverParseAsFraction: false, ref i, out V3);
			switch (componentParseResult)
			{
			case ComponentParseResult.ParseFailure:
				bytesConsumed = 0;
				return false;
			case ComponentParseResult.NoMoreData:
				bytesConsumed = i;
				return true;
			default:
				Separators |= (uint)componentParseResult << 16;
				componentParseResult = ParseComponent(source, neverParseAsFraction: false, ref i, out V4);
				switch (componentParseResult)
				{
				case ComponentParseResult.ParseFailure:
					bytesConsumed = 0;
					return false;
				case ComponentParseResult.NoMoreData:
					bytesConsumed = i;
					return true;
				default:
					Separators |= (uint)componentParseResult << 8;
					componentParseResult = ParseComponent(source, neverParseAsFraction: false, ref i, out V5);
					switch (componentParseResult)
					{
					case ComponentParseResult.ParseFailure:
						bytesConsumed = 0;
						return false;
					case ComponentParseResult.NoMoreData:
						bytesConsumed = i;
						return true;
					default:
						Separators |= (uint)componentParseResult;
						if (i != source.Length && (source[i] == 46 || source[i] == 58))
						{
							bytesConsumed = 0;
							return false;
						}
						bytesConsumed = i;
						return true;
					}
				}
			}
		}
	}

	private static ComponentParseResult ParseComponent(ReadOnlySpan<byte> source, bool neverParseAsFraction, ref int srcIndex, out uint value)
	{
		if (srcIndex == source.Length)
		{
			value = 0u;
			return ComponentParseResult.NoMoreData;
		}
		byte b = source[srcIndex];
		if (b == 58 || (b == 46 && neverParseAsFraction))
		{
			srcIndex++;
			if (!TryParseUInt32D(source.Slice(srcIndex), out value, out var bytesConsumed))
			{
				value = 0u;
				return ComponentParseResult.ParseFailure;
			}
			srcIndex += bytesConsumed;
			if (b != 58)
			{
				return ComponentParseResult.Period;
			}
			return ComponentParseResult.Colon;
		}
		if (b == 46)
		{
			srcIndex++;
			if (!TryParseTimeSpanFraction(source.Slice(srcIndex), out value, out var bytesConsumed2))
			{
				value = 0u;
				return ComponentParseResult.ParseFailure;
			}
			srcIndex += bytesConsumed2;
			return ComponentParseResult.Period;
		}
		value = 0u;
		return ComponentParseResult.NoMoreData;
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class BinaryPrimitives
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static sbyte ReverseEndianness(sbyte value)
	{
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static short ReverseEndianness(short value)
	{
		return (short)(((value & 0xFF) << 8) | ((value & 0xFF00) >> 8));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int ReverseEndianness(int value)
	{
		return (int)ReverseEndianness((uint)value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static long ReverseEndianness(long value)
	{
		return (long)ReverseEndianness((ulong)value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static byte ReverseEndianness(byte value)
	{
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ushort ReverseEndianness(ushort value)
	{
		return (ushort)((value >> 8) + (value << 8));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static uint ReverseEndianness(uint value)
	{
		uint num = value & 0xFF00FF;
		uint num2 = value & 0xFF00FF00u;
		return ((num >> 8) | (num << 24)) + ((num2 << 8) | (num2 >> 24));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ulong ReverseEndianness(ulong value)
	{
		return ((ulong)ReverseEndianness((uint)value) << 32) + ReverseEndianness((uint)(value >> 32));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static short ReadInt16BigEndian(ReadOnlySpan<byte> source)
	{
		short num = MemoryMarshal.Read<short>(source);
		if (BitConverter.IsLittleEndian)
		{
			num = ReverseEndianness(num);
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int ReadInt32BigEndian(ReadOnlySpan<byte> source)
	{
		int num = MemoryMarshal.Read<int>(source);
		if (BitConverter.IsLittleEndian)
		{
			num = ReverseEndianness(num);
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static long ReadInt64BigEndian(ReadOnlySpan<byte> source)
	{
		long num = MemoryMarshal.Read<long>(source);
		if (BitConverter.IsLittleEndian)
		{
			num = ReverseEndianness(num);
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ushort ReadUInt16BigEndian(ReadOnlySpan<byte> source)
	{
		ushort num = MemoryMarshal.Read<ushort>(source);
		if (BitConverter.IsLittleEndian)
		{
			num = ReverseEndianness(num);
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static uint ReadUInt32BigEndian(ReadOnlySpan<byte> source)
	{
		uint num = MemoryMarshal.Read<uint>(source);
		if (BitConverter.IsLittleEndian)
		{
			num = ReverseEndianness(num);
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ulong ReadUInt64BigEndian(ReadOnlySpan<byte> source)
	{
		ulong num = MemoryMarshal.Read<ulong>(source);
		if (BitConverter.IsLittleEndian)
		{
			num = ReverseEndianness(num);
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryReadInt16BigEndian(ReadOnlySpan<byte> source, out short value)
	{
		bool result = MemoryMarshal.TryRead<short>(source, out value);
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryReadInt32BigEndian(ReadOnlySpan<byte> source, out int value)
	{
		bool result = MemoryMarshal.TryRead<int>(source, out value);
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryReadInt64BigEndian(ReadOnlySpan<byte> source, out long value)
	{
		bool result = MemoryMarshal.TryRead<long>(source, out value);
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool TryReadUInt16BigEndian(ReadOnlySpan<byte> source, out ushort value)
	{
		bool result = MemoryMarshal.TryRead<ushort>(source, out value);
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool TryReadUInt32BigEndian(ReadOnlySpan<byte> source, out uint value)
	{
		bool result = MemoryMarshal.TryRead<uint>(source, out value);
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool TryReadUInt64BigEndian(ReadOnlySpan<byte> source, out ulong value)
	{
		bool result = MemoryMarshal.TryRead<ulong>(source, out value);
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static short ReadInt16LittleEndian(ReadOnlySpan<byte> source)
	{
		short num = MemoryMarshal.Read<short>(source);
		if (!BitConverter.IsLittleEndian)
		{
			num = ReverseEndianness(num);
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int ReadInt32LittleEndian(ReadOnlySpan<byte> source)
	{
		int num = MemoryMarshal.Read<int>(source);
		if (!BitConverter.IsLittleEndian)
		{
			num = ReverseEndianness(num);
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static long ReadInt64LittleEndian(ReadOnlySpan<byte> source)
	{
		long num = MemoryMarshal.Read<long>(source);
		if (!BitConverter.IsLittleEndian)
		{
			num = ReverseEndianness(num);
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ushort ReadUInt16LittleEndian(ReadOnlySpan<byte> source)
	{
		ushort num = MemoryMarshal.Read<ushort>(source);
		if (!BitConverter.IsLittleEndian)
		{
			num = ReverseEndianness(num);
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static uint ReadUInt32LittleEndian(ReadOnlySpan<byte> source)
	{
		uint num = MemoryMarshal.Read<uint>(source);
		if (!BitConverter.IsLittleEndian)
		{
			num = ReverseEndianness(num);
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ulong ReadUInt64LittleEndian(ReadOnlySpan<byte> source)
	{
		ulong num = MemoryMarshal.Read<ulong>(source);
		if (!BitConverter.IsLittleEndian)
		{
			num = ReverseEndianness(num);
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryReadInt16LittleEndian(ReadOnlySpan<byte> source, out short value)
	{
		bool result = MemoryMarshal.TryRead<short>(source, out value);
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryReadInt32LittleEndian(ReadOnlySpan<byte> source, out int value)
	{
		bool result = MemoryMarshal.TryRead<int>(source, out value);
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryReadInt64LittleEndian(ReadOnlySpan<byte> source, out long value)
	{
		bool result = MemoryMarshal.TryRead<long>(source, out value);
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool TryReadUInt16LittleEndian(ReadOnlySpan<byte> source, out ushort value)
	{
		bool result = MemoryMarshal.TryRead<ushort>(source, out value);
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool TryReadUInt32LittleEndian(ReadOnlySpan<byte> source, out uint value)
	{
		bool result = MemoryMarshal.TryRead<uint>(source, out value);
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool TryReadUInt64LittleEndian(ReadOnlySpan<byte> source, out ulong value)
	{
		bool result = MemoryMarshal.TryRead<ulong>(source, out value);
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void WriteInt16BigEndian(Span<byte> destination, short value)
	{
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		MemoryMarshal.Write(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void WriteInt32BigEndian(Span<byte> destination, int value)
	{
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		MemoryMarshal.Write(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void WriteInt64BigEndian(Span<byte> destination, long value)
	{
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		MemoryMarshal.Write(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static void WriteUInt16BigEndian(Span<byte> destination, ushort value)
	{
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		MemoryMarshal.Write(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static void WriteUInt32BigEndian(Span<byte> destination, uint value)
	{
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		MemoryMarshal.Write(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static void WriteUInt64BigEndian(Span<byte> destination, ulong value)
	{
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		MemoryMarshal.Write(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryWriteInt16BigEndian(Span<byte> destination, short value)
	{
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return MemoryMarshal.TryWrite(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryWriteInt32BigEndian(Span<byte> destination, int value)
	{
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return MemoryMarshal.TryWrite(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryWriteInt64BigEndian(Span<byte> destination, long value)
	{
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return MemoryMarshal.TryWrite(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool TryWriteUInt16BigEndian(Span<byte> destination, ushort value)
	{
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return MemoryMarshal.TryWrite(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool TryWriteUInt32BigEndian(Span<byte> destination, uint value)
	{
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return MemoryMarshal.TryWrite(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool TryWriteUInt64BigEndian(Span<byte> destination, ulong value)
	{
		if (BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return MemoryMarshal.TryWrite(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void WriteInt16LittleEndian(Span<byte> destination, short value)
	{
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		MemoryMarshal.Write(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void WriteInt32LittleEndian(Span<byte> destination, int value)
	{
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		MemoryMarshal.Write(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void WriteInt64LittleEndian(Span<byte> destination, long value)
	{
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		MemoryMarshal.Write(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static void WriteUInt16LittleEndian(Span<byte> destination, ushort value)
	{
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		MemoryMarshal.Write(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static void WriteUInt32LittleEndian(Span<byte> destination, uint value)
	{
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		MemoryMarshal.Write(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static void WriteUInt64LittleEndian(Span<byte> destination, ulong value)
	{
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		MemoryMarshal.Write(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryWriteInt16LittleEndian(Span<byte> destination, short value)
	{
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return MemoryMarshal.TryWrite(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryWriteInt32LittleEndian(Span<byte> destination, int value)
	{
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return MemoryMarshal.TryWrite(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryWriteInt64LittleEndian(Span<byte> destination, long value)
	{
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return MemoryMarshal.TryWrite(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool TryWriteUInt16LittleEndian(Span<byte> destination, ushort value)
	{
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return MemoryMarshal.TryWrite(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool TryWriteUInt32LittleEndian(Span<byte> destination, uint value)
	{
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return MemoryMarshal.TryWrite(destination, ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool TryWriteUInt64LittleEndian(Span<byte> destination, ulong value)
	{
		if (!BitConverter.IsLittleEndian)
		{
			value = ReverseEndianness(value);
		}
		return MemoryMarshal.TryWrite(destination, ref value);
	}
}


internal static class SR
{
}


using System;
using System.Runtime.CompilerServices;

internal static class MathF
{
	public const float PI = 3.1415927f;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float Abs(float x)
	{
		return Math.Abs(x);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float Acos(float x)
	{
		return (float)Math.Acos(x);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float Cos(float x)
	{
		return (float)Math.Cos(x);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float IEEERemainder(float x, float y)
	{
		return (float)Math.IEEERemainder(x, y);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float Pow(float x, float y)
	{
		return (float)Math.Pow(x, y);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float Sin(float x)
	{
		return (float)Math.Sin(x);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float Sqrt(float x)
	{
		return (float)Math.Sqrt(x);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float Tan(float x)
	{
		return (float)Math.Tan(x);
	}
}


using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Field, Inherited = false)]
internal sealed class IntrinsicAttribute : Attribute
{
}


using System.Runtime.CompilerServices;

internal class ConstantHelper
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static byte GetByteWithAllBitsSet()
	{
		byte result = 0;
		result = byte.MaxValue;
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static sbyte GetSByteWithAllBitsSet()
	{
		sbyte result = 0;
		result = -1;
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ushort GetUInt16WithAllBitsSet()
	{
		ushort result = 0;
		result = ushort.MaxValue;
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static short GetInt16WithAllBitsSet()
	{
		short result = 0;
		result = -1;
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static uint GetUInt32WithAllBitsSet()
	{
		uint result = 0u;
		result = uint.MaxValue;
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int GetInt32WithAllBitsSet()
	{
		int result = 0;
		result = -1;
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ulong GetUInt64WithAllBitsSet()
	{
		ulong result = 0uL;
		result = ulong.MaxValue;
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static long GetInt64WithAllBitsSet()
	{
		long result = 0L;
		result = -1L;
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static float GetSingleWithAllBitsSet()
	{
		float result = 0f;
		*(int*)(&result) = -1;
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static double GetDoubleWithAllBitsSet()
	{
		double result = 0.0;
		*(long*)(&result) = -1L;
		return result;
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
internal struct Register
{
	[FieldOffset(0)]
	internal byte byte_0;

	[FieldOffset(1)]
	internal byte byte_1;

	[FieldOffset(2)]
	internal byte byte_2;

	[FieldOffset(3)]
	internal byte byte_3;

	[FieldOffset(4)]
	internal byte byte_4;

	[FieldOffset(5)]
	internal byte byte_5;

	[FieldOffset(6)]
	internal byte byte_6;

	[FieldOffset(7)]
	internal byte byte_7;

	[FieldOffset(8)]
	internal byte byte_8;

	[FieldOffset(9)]
	internal byte byte_9;

	[FieldOffset(10)]
	internal byte byte_10;

	[FieldOffset(11)]
	internal byte byte_11;

	[FieldOffset(12)]
	internal byte byte_12;

	[FieldOffset(13)]
	internal byte byte_13;

	[FieldOffset(14)]
	internal byte byte_14;

	[FieldOffset(15)]
	internal byte byte_15;

	[FieldOffset(0)]
	internal sbyte sbyte_0;

	[FieldOffset(1)]
	internal sbyte sbyte_1;

	[FieldOffset(2)]
	internal sbyte sbyte_2;

	[FieldOffset(3)]
	internal sbyte sbyte_3;

	[FieldOffset(4)]
	internal sbyte sbyte_4;

	[FieldOffset(5)]
	internal sbyte sbyte_5;

	[FieldOffset(6)]
	internal sbyte sbyte_6;

	[FieldOffset(7)]
	internal sbyte sbyte_7;

	[FieldOffset(8)]
	internal sbyte sbyte_8;

	[FieldOffset(9)]
	internal sbyte sbyte_9;

	[FieldOffset(10)]
	internal sbyte sbyte_10;

	[FieldOffset(11)]
	internal sbyte sbyte_11;

	[FieldOffset(12)]
	internal sbyte sbyte_12;

	[FieldOffset(13)]
	internal sbyte sbyte_13;

	[FieldOffset(14)]
	internal sbyte sbyte_14;

	[FieldOffset(15)]
	internal sbyte sbyte_15;

	[FieldOffset(0)]
	internal ushort uint16_0;

	[FieldOffset(2)]
	internal ushort uint16_1;

	[FieldOffset(4)]
	internal ushort uint16_2;

	[FieldOffset(6)]
	internal ushort uint16_3;

	[FieldOffset(8)]
	internal ushort uint16_4;

	[FieldOffset(10)]
	internal ushort uint16_5;

	[FieldOffset(12)]
	internal ushort uint16_6;

	[FieldOffset(14)]
	internal ushort uint16_7;

	[FieldOffset(0)]
	internal short int16_0;

	[FieldOffset(2)]
	internal short int16_1;

	[FieldOffset(4)]
	internal short int16_2;

	[FieldOffset(6)]
	internal short int16_3;

	[FieldOffset(8)]
	internal short int16_4;

	[FieldOffset(10)]
	internal short int16_5;

	[FieldOffset(12)]
	internal short int16_6;

	[FieldOffset(14)]
	internal short int16_7;

	[FieldOffset(0)]
	internal uint uint32_0;

	[FieldOffset(4)]
	internal uint uint32_1;

	[FieldOffset(8)]
	internal uint uint32_2;

	[FieldOffset(12)]
	internal uint uint32_3;

	[FieldOffset(0)]
	internal int int32_0;

	[FieldOffset(4)]
	internal int int32_1;

	[FieldOffset(8)]
	internal int int32_2;

	[FieldOffset(12)]
	internal int int32_3;

	[FieldOffset(0)]
	internal ulong uint64_0;

	[FieldOffset(8)]
	internal ulong uint64_1;

	[FieldOffset(0)]
	internal long int64_0;

	[FieldOffset(8)]
	internal long int64_1;

	[FieldOffset(0)]
	internal float single_0;

	[FieldOffset(4)]
	internal float single_1;

	[FieldOffset(8)]
	internal float single_2;

	[FieldOffset(12)]
	internal float single_3;

	[FieldOffset(0)]
	internal double double_0;

	[FieldOffset(8)]
	internal double double_1;
}


