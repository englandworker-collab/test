using System;
using System.Globalization;
using System.Numerics;
using System.Numerics.Hashing;
using System.Runtime.CompilerServices;
using System.Text;

[System.Runtime.CompilerServices.Intrinsic]
internal struct Vector<T> : IEquatable<Vector<T>>, IFormattable where T : struct
{
	private struct VectorSizeHelper
	{
		internal Vector<T> _placeholder;

		internal byte _byte;
	}

	private Register register;

	private static readonly int s_count = InitializeCount();

	private static readonly Vector<T> s_zero = default(Vector<T>);

	private static readonly Vector<T> s_one = new Vector<T>(GetOneValue());

	private static readonly Vector<T> s_allOnes = new Vector<T>(GetAllBitsSetValue());

	public static int Count
	{
		[System.Runtime.CompilerServices.Intrinsic]
		get
		{
			return s_count;
		}
	}

	public static Vector<T> Zero
	{
		[System.Runtime.CompilerServices.Intrinsic]
		get
		{
			return s_zero;
		}
	}

	public static Vector<T> One
	{
		[System.Runtime.CompilerServices.Intrinsic]
		get
		{
			return s_one;
		}
	}

	internal static Vector<T> AllOnes => s_allOnes;

	public unsafe T this[int index]
	{
		[System.Runtime.CompilerServices.Intrinsic]
		get
		{
			if (index >= Count || index < 0)
			{
				throw new IndexOutOfRangeException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Format(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_ArgumentOutOfRangeException, index));
			}
			if (typeof(T) == typeof(byte))
			{
				fixed (byte* byte_ = &register.byte_0)
				{
					return (T)(object)byte_[index];
				}
			}
			if (typeof(T) == typeof(sbyte))
			{
				fixed (sbyte* sbyte_ = &register.sbyte_0)
				{
					return (T)(object)sbyte_[index];
				}
			}
			if (typeof(T) == typeof(ushort))
			{
				fixed (ushort* uint16_ = &register.uint16_0)
				{
					return (T)(object)uint16_[index];
				}
			}
			if (typeof(T) == typeof(short))
			{
				fixed (short* int16_ = &register.int16_0)
				{
					return (T)(object)int16_[index];
				}
			}
			if (typeof(T) == typeof(uint))
			{
				fixed (uint* uint32_ = &register.uint32_0)
				{
					return (T)(object)uint32_[index];
				}
			}
			if (typeof(T) == typeof(int))
			{
				fixed (int* int32_ = &register.int32_0)
				{
					return (T)(object)int32_[index];
				}
			}
			if (typeof(T) == typeof(ulong))
			{
				fixed (ulong* uint64_ = &register.uint64_0)
				{
					return (T)(object)uint64_[index];
				}
			}
			if (typeof(T) == typeof(long))
			{
				fixed (long* int64_ = &register.int64_0)
				{
					return (T)(object)int64_[index];
				}
			}
			if (typeof(T) == typeof(float))
			{
				fixed (float* single_ = &register.single_0)
				{
					return (T)(object)single_[index];
				}
			}
			if (typeof(T) == typeof(double))
			{
				fixed (double* double_ = &register.double_0)
				{
					return (T)(object)double_[index];
				}
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
	}

	private unsafe static int InitializeCount()
	{
		VectorSizeHelper vectorSizeHelper = default(VectorSizeHelper);
		byte* ptr = &vectorSizeHelper._placeholder.register.byte_0;
		byte* ptr2 = &vectorSizeHelper._byte;
		int num = (int)(ptr2 - ptr);
		int num2 = -1;
		if (typeof(T) == typeof(byte))
		{
			num2 = 1;
		}
		else if (typeof(T) == typeof(sbyte))
		{
			num2 = 1;
		}
		else if (typeof(T) == typeof(ushort))
		{
			num2 = 2;
		}
		else if (typeof(T) == typeof(short))
		{
			num2 = 2;
		}
		else if (typeof(T) == typeof(uint))
		{
			num2 = 4;
		}
		else if (typeof(T) == typeof(int))
		{
			num2 = 4;
		}
		else if (typeof(T) == typeof(ulong))
		{
			num2 = 8;
		}
		else if (typeof(T) == typeof(long))
		{
			num2 = 8;
		}
		else if (typeof(T) == typeof(float))
		{
			num2 = 4;
		}
		else
		{
			if (!(typeof(T) == typeof(double)))
			{
				throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
			}
			num2 = 8;
		}
		return num / num2;
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe Vector(T value)
	{
		this = default(Vector<T>);
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				fixed (byte* byte_ = &register.byte_0)
				{
					for (int i = 0; i < Count; i++)
					{
						byte_[i] = (byte)(object)value;
					}
				}
			}
			else if (typeof(T) == typeof(sbyte))
			{
				fixed (sbyte* sbyte_ = &register.sbyte_0)
				{
					for (int j = 0; j < Count; j++)
					{
						sbyte_[j] = (sbyte)(object)value;
					}
				}
			}
			else if (typeof(T) == typeof(ushort))
			{
				fixed (ushort* uint16_ = &register.uint16_0)
				{
					for (int k = 0; k < Count; k++)
					{
						uint16_[k] = (ushort)(object)value;
					}
				}
			}
			else if (typeof(T) == typeof(short))
			{
				fixed (short* int16_ = &register.int16_0)
				{
					for (int l = 0; l < Count; l++)
					{
						int16_[l] = (short)(object)value;
					}
				}
			}
			else if (typeof(T) == typeof(uint))
			{
				fixed (uint* uint32_ = &register.uint32_0)
				{
					for (int m = 0; m < Count; m++)
					{
						uint32_[m] = (uint)(object)value;
					}
				}
			}
			else if (typeof(T) == typeof(int))
			{
				fixed (int* int32_ = &register.int32_0)
				{
					for (int n = 0; n < Count; n++)
					{
						int32_[n] = (int)(object)value;
					}
				}
			}
			else if (typeof(T) == typeof(ulong))
			{
				fixed (ulong* uint64_ = &register.uint64_0)
				{
					for (int num = 0; num < Count; num++)
					{
						uint64_[num] = (ulong)(object)value;
					}
				}
			}
			else if (typeof(T) == typeof(long))
			{
				fixed (long* int64_ = &register.int64_0)
				{
					for (int num2 = 0; num2 < Count; num2++)
					{
						int64_[num2] = (long)(object)value;
					}
				}
			}
			else if (typeof(T) == typeof(float))
			{
				fixed (float* single_ = &register.single_0)
				{
					for (int num3 = 0; num3 < Count; num3++)
					{
						single_[num3] = (float)(object)value;
					}
				}
			}
			else
			{
				if (!(typeof(T) == typeof(double)))
				{
					return;
				}
				fixed (double* double_ = &register.double_0)
				{
					for (int num4 = 0; num4 < Count; num4++)
					{
						double_[num4] = (double)(object)value;
					}
				}
			}
		}
		else if (typeof(T) == typeof(byte))
		{
			register.byte_0 = (byte)(object)value;
			register.byte_1 = (byte)(object)value;
			register.byte_2 = (byte)(object)value;
			register.byte_3 = (byte)(object)value;
			register.byte_4 = (byte)(object)value;
			register.byte_5 = (byte)(object)value;
			register.byte_6 = (byte)(object)value;
			register.byte_7 = (byte)(object)value;
			register.byte_8 = (byte)(object)value;
			register.byte_9 = (byte)(object)value;
			register.byte_10 = (byte)(object)value;
			register.byte_11 = (byte)(object)value;
			register.byte_12 = (byte)(object)value;
			register.byte_13 = (byte)(object)value;
			register.byte_14 = (byte)(object)value;
			register.byte_15 = (byte)(object)value;
		}
		else if (typeof(T) == typeof(sbyte))
		{
			register.sbyte_0 = (sbyte)(object)value;
			register.sbyte_1 = (sbyte)(object)value;
			register.sbyte_2 = (sbyte)(object)value;
			register.sbyte_3 = (sbyte)(object)value;
			register.sbyte_4 = (sbyte)(object)value;
			register.sbyte_5 = (sbyte)(object)value;
			register.sbyte_6 = (sbyte)(object)value;
			register.sbyte_7 = (sbyte)(object)value;
			register.sbyte_8 = (sbyte)(object)value;
			register.sbyte_9 = (sbyte)(object)value;
			register.sbyte_10 = (sbyte)(object)value;
			register.sbyte_11 = (sbyte)(object)value;
			register.sbyte_12 = (sbyte)(object)value;
			register.sbyte_13 = (sbyte)(object)value;
			register.sbyte_14 = (sbyte)(object)value;
			register.sbyte_15 = (sbyte)(object)value;
		}
		else if (typeof(T) == typeof(ushort))
		{
			register.uint16_0 = (ushort)(object)value;
			register.uint16_1 = (ushort)(object)value;
			register.uint16_2 = (ushort)(object)value;
			register.uint16_3 = (ushort)(object)value;
			register.uint16_4 = (ushort)(object)value;
			register.uint16_5 = (ushort)(object)value;
			register.uint16_6 = (ushort)(object)value;
			register.uint16_7 = (ushort)(object)value;
		}
		else if (typeof(T) == typeof(short))
		{
			register.int16_0 = (short)(object)value;
			register.int16_1 = (short)(object)value;
			register.int16_2 = (short)(object)value;
			register.int16_3 = (short)(object)value;
			register.int16_4 = (short)(object)value;
			register.int16_5 = (short)(object)value;
			register.int16_6 = (short)(object)value;
			register.int16_7 = (short)(object)value;
		}
		else if (typeof(T) == typeof(uint))
		{
			register.uint32_0 = (uint)(object)value;
			register.uint32_1 = (uint)(object)value;
			register.uint32_2 = (uint)(object)value;
			register.uint32_3 = (uint)(object)value;
		}
		else if (typeof(T) == typeof(int))
		{
			register.int32_0 = (int)(object)value;
			register.int32_1 = (int)(object)value;
			register.int32_2 = (int)(object)value;
			register.int32_3 = (int)(object)value;
		}
		else if (typeof(T) == typeof(ulong))
		{
			register.uint64_0 = (ulong)(object)value;
			register.uint64_1 = (ulong)(object)value;
		}
		else if (typeof(T) == typeof(long))
		{
			register.int64_0 = (long)(object)value;
			register.int64_1 = (long)(object)value;
		}
		else if (typeof(T) == typeof(float))
		{
			register.single_0 = (float)(object)value;
			register.single_1 = (float)(object)value;
			register.single_2 = (float)(object)value;
			register.single_3 = (float)(object)value;
		}
		else if (typeof(T) == typeof(double))
		{
			register.double_0 = (double)(object)value;
			register.double_1 = (double)(object)value;
		}
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public Vector(T[] values)
		: this(values, 0)
	{
	}

	public unsafe Vector(T[] values, int index)
	{
		this = default(Vector<T>);
		if (values == null)
		{
			throw new NullReferenceException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_NullArgumentNullRef);
		}
		if (index < 0 || values.Length - index < Count)
		{
			throw new IndexOutOfRangeException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Format(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_InsufficientNumberOfElements, Count, "values"));
		}
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				fixed (byte* byte_ = &register.byte_0)
				{
					for (int i = 0; i < Count; i++)
					{
						byte_[i] = (byte)(object)values[i + index];
					}
				}
			}
			else if (typeof(T) == typeof(sbyte))
			{
				fixed (sbyte* sbyte_ = &register.sbyte_0)
				{
					for (int j = 0; j < Count; j++)
					{
						sbyte_[j] = (sbyte)(object)values[j + index];
					}
				}
			}
			else if (typeof(T) == typeof(ushort))
			{
				fixed (ushort* uint16_ = &register.uint16_0)
				{
					for (int k = 0; k < Count; k++)
					{
						uint16_[k] = (ushort)(object)values[k + index];
					}
				}
			}
			else if (typeof(T) == typeof(short))
			{
				fixed (short* int16_ = &register.int16_0)
				{
					for (int l = 0; l < Count; l++)
					{
						int16_[l] = (short)(object)values[l + index];
					}
				}
			}
			else if (typeof(T) == typeof(uint))
			{
				fixed (uint* uint32_ = &register.uint32_0)
				{
					for (int m = 0; m < Count; m++)
					{
						uint32_[m] = (uint)(object)values[m + index];
					}
				}
			}
			else if (typeof(T) == typeof(int))
			{
				fixed (int* int32_ = &register.int32_0)
				{
					for (int n = 0; n < Count; n++)
					{
						int32_[n] = (int)(object)values[n + index];
					}
				}
			}
			else if (typeof(T) == typeof(ulong))
			{
				fixed (ulong* uint64_ = &register.uint64_0)
				{
					for (int num = 0; num < Count; num++)
					{
						uint64_[num] = (ulong)(object)values[num + index];
					}
				}
			}
			else if (typeof(T) == typeof(long))
			{
				fixed (long* int64_ = &register.int64_0)
				{
					for (int num2 = 0; num2 < Count; num2++)
					{
						int64_[num2] = (long)(object)values[num2 + index];
					}
				}
			}
			else if (typeof(T) == typeof(float))
			{
				fixed (float* single_ = &register.single_0)
				{
					for (int num3 = 0; num3 < Count; num3++)
					{
						single_[num3] = (float)(object)values[num3 + index];
					}
				}
			}
			else
			{
				if (!(typeof(T) == typeof(double)))
				{
					return;
				}
				fixed (double* double_ = &register.double_0)
				{
					for (int num4 = 0; num4 < Count; num4++)
					{
						double_[num4] = (double)(object)values[num4 + index];
					}
				}
			}
		}
		else if (typeof(T) == typeof(byte))
		{
			fixed (byte* byte_2 = &register.byte_0)
			{
				*byte_2 = (byte)(object)values[index];
				byte_2[1] = (byte)(object)values[1 + index];
				byte_2[2] = (byte)(object)values[2 + index];
				byte_2[3] = (byte)(object)values[3 + index];
				byte_2[4] = (byte)(object)values[4 + index];
				byte_2[5] = (byte)(object)values[5 + index];
				byte_2[6] = (byte)(object)values[6 + index];
				byte_2[7] = (byte)(object)values[7 + index];
				byte_2[8] = (byte)(object)values[8 + index];
				byte_2[9] = (byte)(object)values[9 + index];
				byte_2[10] = (byte)(object)values[10 + index];
				byte_2[11] = (byte)(object)values[11 + index];
				byte_2[12] = (byte)(object)values[12 + index];
				byte_2[13] = (byte)(object)values[13 + index];
				byte_2[14] = (byte)(object)values[14 + index];
				byte_2[15] = (byte)(object)values[15 + index];
			}
		}
		else if (typeof(T) == typeof(sbyte))
		{
			fixed (sbyte* sbyte_2 = &register.sbyte_0)
			{
				*sbyte_2 = (sbyte)(object)values[index];
				sbyte_2[1] = (sbyte)(object)values[1 + index];
				sbyte_2[2] = (sbyte)(object)values[2 + index];
				sbyte_2[3] = (sbyte)(object)values[3 + index];
				sbyte_2[4] = (sbyte)(object)values[4 + index];
				sbyte_2[5] = (sbyte)(object)values[5 + index];
				sbyte_2[6] = (sbyte)(object)values[6 + index];
				sbyte_2[7] = (sbyte)(object)values[7 + index];
				sbyte_2[8] = (sbyte)(object)values[8 + index];
				sbyte_2[9] = (sbyte)(object)values[9 + index];
				sbyte_2[10] = (sbyte)(object)values[10 + index];
				sbyte_2[11] = (sbyte)(object)values[11 + index];
				sbyte_2[12] = (sbyte)(object)values[12 + index];
				sbyte_2[13] = (sbyte)(object)values[13 + index];
				sbyte_2[14] = (sbyte)(object)values[14 + index];
				sbyte_2[15] = (sbyte)(object)values[15 + index];
			}
		}
		else if (typeof(T) == typeof(ushort))
		{
			fixed (ushort* uint16_2 = &register.uint16_0)
			{
				*uint16_2 = (ushort)(object)values[index];
				uint16_2[1] = (ushort)(object)values[1 + index];
				uint16_2[2] = (ushort)(object)values[2 + index];
				uint16_2[3] = (ushort)(object)values[3 + index];
				uint16_2[4] = (ushort)(object)values[4 + index];
				uint16_2[5] = (ushort)(object)values[5 + index];
				uint16_2[6] = (ushort)(object)values[6 + index];
				uint16_2[7] = (ushort)(object)values[7 + index];
			}
		}
		else if (typeof(T) == typeof(short))
		{
			fixed (short* int16_2 = &register.int16_0)
			{
				*int16_2 = (short)(object)values[index];
				int16_2[1] = (short)(object)values[1 + index];
				int16_2[2] = (short)(object)values[2 + index];
				int16_2[3] = (short)(object)values[3 + index];
				int16_2[4] = (short)(object)values[4 + index];
				int16_2[5] = (short)(object)values[5 + index];
				int16_2[6] = (short)(object)values[6 + index];
				int16_2[7] = (short)(object)values[7 + index];
			}
		}
		else if (typeof(T) == typeof(uint))
		{
			fixed (uint* uint32_2 = &register.uint32_0)
			{
				*uint32_2 = (uint)(object)values[index];
				uint32_2[1] = (uint)(object)values[1 + index];
				uint32_2[2] = (uint)(object)values[2 + index];
				uint32_2[3] = (uint)(object)values[3 + index];
			}
		}
		else if (typeof(T) == typeof(int))
		{
			fixed (int* int32_2 = &register.int32_0)
			{
				*int32_2 = (int)(object)values[index];
				int32_2[1] = (int)(object)values[1 + index];
				int32_2[2] = (int)(object)values[2 + index];
				int32_2[3] = (int)(object)values[3 + index];
			}
		}
		else if (typeof(T) == typeof(ulong))
		{
			fixed (ulong* uint64_2 = &register.uint64_0)
			{
				*uint64_2 = (ulong)(object)values[index];
				uint64_2[1] = (ulong)(object)values[1 + index];
			}
		}
		else if (typeof(T) == typeof(long))
		{
			fixed (long* int64_2 = &register.int64_0)
			{
				*int64_2 = (long)(object)values[index];
				int64_2[1] = (long)(object)values[1 + index];
			}
		}
		else if (typeof(T) == typeof(float))
		{
			fixed (float* single_2 = &register.single_0)
			{
				*single_2 = (float)(object)values[index];
				single_2[1] = (float)(object)values[1 + index];
				single_2[2] = (float)(object)values[2 + index];
				single_2[3] = (float)(object)values[3 + index];
			}
		}
		else if (typeof(T) == typeof(double))
		{
			fixed (double* double_2 = &register.double_0)
			{
				*double_2 = (double)(object)values[index];
				double_2[1] = (double)(object)values[1 + index];
			}
		}
	}

	internal unsafe Vector(void* dataPointer)
		: this(dataPointer, 0)
	{
	}

	internal unsafe Vector(void* dataPointer, int offset)
	{
		this = default(Vector<T>);
		if (typeof(T) == typeof(byte))
		{
			byte* ptr = (byte*)dataPointer;
			ptr += offset;
			fixed (byte* byte_ = &register.byte_0)
			{
				for (int i = 0; i < Count; i++)
				{
					byte_[i] = ptr[i];
				}
			}
			return;
		}
		if (typeof(T) == typeof(sbyte))
		{
			sbyte* ptr2 = (sbyte*)dataPointer;
			ptr2 += offset;
			fixed (sbyte* sbyte_ = &register.sbyte_0)
			{
				for (int j = 0; j < Count; j++)
				{
					sbyte_[j] = ptr2[j];
				}
			}
			return;
		}
		if (typeof(T) == typeof(ushort))
		{
			ushort* ptr3 = (ushort*)dataPointer;
			ptr3 += offset;
			fixed (ushort* uint16_ = &register.uint16_0)
			{
				for (int k = 0; k < Count; k++)
				{
					uint16_[k] = ptr3[k];
				}
			}
			return;
		}
		if (typeof(T) == typeof(short))
		{
			short* ptr4 = (short*)dataPointer;
			ptr4 += offset;
			fixed (short* int16_ = &register.int16_0)
			{
				for (int l = 0; l < Count; l++)
				{
					int16_[l] = ptr4[l];
				}
			}
			return;
		}
		if (typeof(T) == typeof(uint))
		{
			uint* ptr5 = (uint*)dataPointer;
			ptr5 += offset;
			fixed (uint* uint32_ = &register.uint32_0)
			{
				for (int m = 0; m < Count; m++)
				{
					uint32_[m] = ptr5[m];
				}
			}
			return;
		}
		if (typeof(T) == typeof(int))
		{
			int* ptr6 = (int*)dataPointer;
			ptr6 += offset;
			fixed (int* int32_ = &register.int32_0)
			{
				for (int n = 0; n < Count; n++)
				{
					int32_[n] = ptr6[n];
				}
			}
			return;
		}
		if (typeof(T) == typeof(ulong))
		{
			ulong* ptr7 = (ulong*)dataPointer;
			ptr7 += offset;
			fixed (ulong* uint64_ = &register.uint64_0)
			{
				for (int num = 0; num < Count; num++)
				{
					uint64_[num] = ptr7[num];
				}
			}
			return;
		}
		if (typeof(T) == typeof(long))
		{
			long* ptr8 = (long*)dataPointer;
			ptr8 += offset;
			fixed (long* int64_ = &register.int64_0)
			{
				for (int num2 = 0; num2 < Count; num2++)
				{
					int64_[num2] = ptr8[num2];
				}
			}
			return;
		}
		if (typeof(T) == typeof(float))
		{
			float* ptr9 = (float*)dataPointer;
			ptr9 += offset;
			fixed (float* single_ = &register.single_0)
			{
				for (int num3 = 0; num3 < Count; num3++)
				{
					single_[num3] = ptr9[num3];
				}
			}
			return;
		}
		if (typeof(T) == typeof(double))
		{
			double* ptr10 = (double*)dataPointer;
			ptr10 += offset;
			fixed (double* double_ = &register.double_0)
			{
				for (int num4 = 0; num4 < Count; num4++)
				{
					double_[num4] = ptr10[num4];
				}
			}
			return;
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	private Vector(ref Register existingRegister)
	{
		register = existingRegister;
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public void CopyTo(T[] destination)
	{
		CopyTo(destination, 0);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe void CopyTo(T[] destination, int startIndex)
	{
		if (destination == null)
		{
			throw new NullReferenceException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_NullArgumentNullRef);
		}
		if (startIndex < 0 || startIndex >= destination.Length)
		{
			throw new ArgumentOutOfRangeException("startIndex", <fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Format(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_ArgumentOutOfRangeException, startIndex));
		}
		if (destination.Length - startIndex < Count)
		{
			throw new ArgumentException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Format(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_ElementsInSourceIsGreaterThanDestination, startIndex));
		}
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				fixed (byte* ptr = (byte[])(object)destination)
				{
					for (int i = 0; i < Count; i++)
					{
						ptr[startIndex + i] = (byte)(object)this[i];
					}
				}
			}
			else if (typeof(T) == typeof(sbyte))
			{
				fixed (sbyte* ptr2 = (sbyte[])(object)destination)
				{
					for (int j = 0; j < Count; j++)
					{
						ptr2[startIndex + j] = (sbyte)(object)this[j];
					}
				}
			}
			else if (typeof(T) == typeof(ushort))
			{
				fixed (ushort* ptr3 = (ushort[])(object)destination)
				{
					for (int k = 0; k < Count; k++)
					{
						ptr3[startIndex + k] = (ushort)(object)this[k];
					}
				}
			}
			else if (typeof(T) == typeof(short))
			{
				fixed (short* ptr4 = (short[])(object)destination)
				{
					for (int l = 0; l < Count; l++)
					{
						ptr4[startIndex + l] = (short)(object)this[l];
					}
				}
			}
			else if (typeof(T) == typeof(uint))
			{
				fixed (uint* ptr5 = (uint[])(object)destination)
				{
					for (int m = 0; m < Count; m++)
					{
						ptr5[startIndex + m] = (uint)(object)this[m];
					}
				}
			}
			else if (typeof(T) == typeof(int))
			{
				fixed (int* ptr6 = (int[])(object)destination)
				{
					for (int n = 0; n < Count; n++)
					{
						ptr6[startIndex + n] = (int)(object)this[n];
					}
				}
			}
			else if (typeof(T) == typeof(ulong))
			{
				fixed (ulong* ptr7 = (ulong[])(object)destination)
				{
					for (int num = 0; num < Count; num++)
					{
						ptr7[startIndex + num] = (ulong)(object)this[num];
					}
				}
			}
			else if (typeof(T) == typeof(long))
			{
				fixed (long* ptr8 = (long[])(object)destination)
				{
					for (int num2 = 0; num2 < Count; num2++)
					{
						ptr8[startIndex + num2] = (long)(object)this[num2];
					}
				}
			}
			else if (typeof(T) == typeof(float))
			{
				fixed (float* ptr9 = (float[])(object)destination)
				{
					for (int num3 = 0; num3 < Count; num3++)
					{
						ptr9[startIndex + num3] = (float)(object)this[num3];
					}
				}
			}
			else
			{
				if (!(typeof(T) == typeof(double)))
				{
					return;
				}
				fixed (double* ptr10 = (double[])(object)destination)
				{
					for (int num4 = 0; num4 < Count; num4++)
					{
						ptr10[startIndex + num4] = (double)(object)this[num4];
					}
				}
			}
		}
		else if (typeof(T) == typeof(byte))
		{
			fixed (byte* ptr11 = (byte[])(object)destination)
			{
				ptr11[startIndex] = register.byte_0;
				ptr11[startIndex + 1] = register.byte_1;
				ptr11[startIndex + 2] = register.byte_2;
				ptr11[startIndex + 3] = register.byte_3;
				ptr11[startIndex + 4] = register.byte_4;
				ptr11[startIndex + 5] = register.byte_5;
				ptr11[startIndex + 6] = register.byte_6;
				ptr11[startIndex + 7] = register.byte_7;
				ptr11[startIndex + 8] = register.byte_8;
				ptr11[startIndex + 9] = register.byte_9;
				ptr11[startIndex + 10] = register.byte_10;
				ptr11[startIndex + 11] = register.byte_11;
				ptr11[startIndex + 12] = register.byte_12;
				ptr11[startIndex + 13] = register.byte_13;
				ptr11[startIndex + 14] = register.byte_14;
				ptr11[startIndex + 15] = register.byte_15;
			}
		}
		else if (typeof(T) == typeof(sbyte))
		{
			fixed (sbyte* ptr12 = (sbyte[])(object)destination)
			{
				ptr12[startIndex] = register.sbyte_0;
				ptr12[startIndex + 1] = register.sbyte_1;
				ptr12[startIndex + 2] = register.sbyte_2;
				ptr12[startIndex + 3] = register.sbyte_3;
				ptr12[startIndex + 4] = register.sbyte_4;
				ptr12[startIndex + 5] = register.sbyte_5;
				ptr12[startIndex + 6] = register.sbyte_6;
				ptr12[startIndex + 7] = register.sbyte_7;
				ptr12[startIndex + 8] = register.sbyte_8;
				ptr12[startIndex + 9] = register.sbyte_9;
				ptr12[startIndex + 10] = register.sbyte_10;
				ptr12[startIndex + 11] = register.sbyte_11;
				ptr12[startIndex + 12] = register.sbyte_12;
				ptr12[startIndex + 13] = register.sbyte_13;
				ptr12[startIndex + 14] = register.sbyte_14;
				ptr12[startIndex + 15] = register.sbyte_15;
			}
		}
		else if (typeof(T) == typeof(ushort))
		{
			fixed (ushort* ptr13 = (ushort[])(object)destination)
			{
				ptr13[startIndex] = register.uint16_0;
				ptr13[startIndex + 1] = register.uint16_1;
				ptr13[startIndex + 2] = register.uint16_2;
				ptr13[startIndex + 3] = register.uint16_3;
				ptr13[startIndex + 4] = register.uint16_4;
				ptr13[startIndex + 5] = register.uint16_5;
				ptr13[startIndex + 6] = register.uint16_6;
				ptr13[startIndex + 7] = register.uint16_7;
			}
		}
		else if (typeof(T) == typeof(short))
		{
			fixed (short* ptr14 = (short[])(object)destination)
			{
				ptr14[startIndex] = register.int16_0;
				ptr14[startIndex + 1] = register.int16_1;
				ptr14[startIndex + 2] = register.int16_2;
				ptr14[startIndex + 3] = register.int16_3;
				ptr14[startIndex + 4] = register.int16_4;
				ptr14[startIndex + 5] = register.int16_5;
				ptr14[startIndex + 6] = register.int16_6;
				ptr14[startIndex + 7] = register.int16_7;
			}
		}
		else if (typeof(T) == typeof(uint))
		{
			fixed (uint* ptr15 = (uint[])(object)destination)
			{
				ptr15[startIndex] = register.uint32_0;
				ptr15[startIndex + 1] = register.uint32_1;
				ptr15[startIndex + 2] = register.uint32_2;
				ptr15[startIndex + 3] = register.uint32_3;
			}
		}
		else if (typeof(T) == typeof(int))
		{
			fixed (int* ptr16 = (int[])(object)destination)
			{
				ptr16[startIndex] = register.int32_0;
				ptr16[startIndex + 1] = register.int32_1;
				ptr16[startIndex + 2] = register.int32_2;
				ptr16[startIndex + 3] = register.int32_3;
			}
		}
		else if (typeof(T) == typeof(ulong))
		{
			fixed (ulong* ptr17 = (ulong[])(object)destination)
			{
				ptr17[startIndex] = register.uint64_0;
				ptr17[startIndex + 1] = register.uint64_1;
			}
		}
		else if (typeof(T) == typeof(long))
		{
			fixed (long* ptr18 = (long[])(object)destination)
			{
				ptr18[startIndex] = register.int64_0;
				ptr18[startIndex + 1] = register.int64_1;
			}
		}
		else if (typeof(T) == typeof(float))
		{
			fixed (float* ptr19 = (float[])(object)destination)
			{
				ptr19[startIndex] = register.single_0;
				ptr19[startIndex + 1] = register.single_1;
				ptr19[startIndex + 2] = register.single_2;
				ptr19[startIndex + 3] = register.single_3;
			}
		}
		else if (typeof(T) == typeof(double))
		{
			fixed (double* ptr20 = (double[])(object)destination)
			{
				ptr20[startIndex] = register.double_0;
				ptr20[startIndex + 1] = register.double_1;
			}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override bool Equals(object obj)
	{
		if (!(obj is Vector<T>))
		{
			return false;
		}
		return Equals((Vector<T>)obj);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public bool Equals(Vector<T> other)
	{
		if (Vector.IsHardwareAccelerated)
		{
			for (int i = 0; i < Count; i++)
			{
				if (!ScalarEquals(this[i], other[i]))
				{
					return false;
				}
			}
			return true;
		}
		if (typeof(T) == typeof(byte))
		{
			if (register.byte_0 == other.register.byte_0 && register.byte_1 == other.register.byte_1 && register.byte_2 == other.register.byte_2 && register.byte_3 == other.register.byte_3 && register.byte_4 == other.register.byte_4 && register.byte_5 == other.register.byte_5 && register.byte_6 == other.register.byte_6 && register.byte_7 == other.register.byte_7 && register.byte_8 == other.register.byte_8 && register.byte_9 == other.register.byte_9 && register.byte_10 == other.register.byte_10 && register.byte_11 == other.register.byte_11 && register.byte_12 == other.register.byte_12 && register.byte_13 == other.register.byte_13 && register.byte_14 == other.register.byte_14)
			{
				return register.byte_15 == other.register.byte_15;
			}
			return false;
		}
		if (typeof(T) == typeof(sbyte))
		{
			if (register.sbyte_0 == other.register.sbyte_0 && register.sbyte_1 == other.register.sbyte_1 && register.sbyte_2 == other.register.sbyte_2 && register.sbyte_3 == other.register.sbyte_3 && register.sbyte_4 == other.register.sbyte_4 && register.sbyte_5 == other.register.sbyte_5 && register.sbyte_6 == other.register.sbyte_6 && register.sbyte_7 == other.register.sbyte_7 && register.sbyte_8 == other.register.sbyte_8 && register.sbyte_9 == other.register.sbyte_9 && register.sbyte_10 == other.register.sbyte_10 && register.sbyte_11 == other.register.sbyte_11 && register.sbyte_12 == other.register.sbyte_12 && register.sbyte_13 == other.register.sbyte_13 && register.sbyte_14 == other.register.sbyte_14)
			{
				return register.sbyte_15 == other.register.sbyte_15;
			}
			return false;
		}
		if (typeof(T) == typeof(ushort))
		{
			if (register.uint16_0 == other.register.uint16_0 && register.uint16_1 == other.register.uint16_1 && register.uint16_2 == other.register.uint16_2 && register.uint16_3 == other.register.uint16_3 && register.uint16_4 == other.register.uint16_4 && register.uint16_5 == other.register.uint16_5 && register.uint16_6 == other.register.uint16_6)
			{
				return register.uint16_7 == other.register.uint16_7;
			}
			return false;
		}
		if (typeof(T) == typeof(short))
		{
			if (register.int16_0 == other.register.int16_0 && register.int16_1 == other.register.int16_1 && register.int16_2 == other.register.int16_2 && register.int16_3 == other.register.int16_3 && register.int16_4 == other.register.int16_4 && register.int16_5 == other.register.int16_5 && register.int16_6 == other.register.int16_6)
			{
				return register.int16_7 == other.register.int16_7;
			}
			return false;
		}
		if (typeof(T) == typeof(uint))
		{
			if (register.uint32_0 == other.register.uint32_0 && register.uint32_1 == other.register.uint32_1 && register.uint32_2 == other.register.uint32_2)
			{
				return register.uint32_3 == other.register.uint32_3;
			}
			return false;
		}
		if (typeof(T) == typeof(int))
		{
			if (register.int32_0 == other.register.int32_0 && register.int32_1 == other.register.int32_1 && register.int32_2 == other.register.int32_2)
			{
				return register.int32_3 == other.register.int32_3;
			}
			return false;
		}
		if (typeof(T) == typeof(ulong))
		{
			if (register.uint64_0 == other.register.uint64_0)
			{
				return register.uint64_1 == other.register.uint64_1;
			}
			return false;
		}
		if (typeof(T) == typeof(long))
		{
			if (register.int64_0 == other.register.int64_0)
			{
				return register.int64_1 == other.register.int64_1;
			}
			return false;
		}
		if (typeof(T) == typeof(float))
		{
			if (register.single_0 == other.register.single_0 && register.single_1 == other.register.single_1 && register.single_2 == other.register.single_2)
			{
				return register.single_3 == other.register.single_3;
			}
			return false;
		}
		if (typeof(T) == typeof(double))
		{
			if (register.double_0 == other.register.double_0)
			{
				return register.double_1 == other.register.double_1;
			}
			return false;
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	public override int GetHashCode()
	{
		int num = 0;
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				for (int i = 0; i < Count; i++)
				{
					num = HashHelpers.Combine(num, ((byte)(object)this[i]).GetHashCode());
				}
				return num;
			}
			if (typeof(T) == typeof(sbyte))
			{
				for (int j = 0; j < Count; j++)
				{
					num = HashHelpers.Combine(num, ((sbyte)(object)this[j]).GetHashCode());
				}
				return num;
			}
			if (typeof(T) == typeof(ushort))
			{
				for (int k = 0; k < Count; k++)
				{
					num = HashHelpers.Combine(num, ((ushort)(object)this[k]).GetHashCode());
				}
				return num;
			}
			if (typeof(T) == typeof(short))
			{
				for (int l = 0; l < Count; l++)
				{
					num = HashHelpers.Combine(num, ((short)(object)this[l]).GetHashCode());
				}
				return num;
			}
			if (typeof(T) == typeof(uint))
			{
				for (int m = 0; m < Count; m++)
				{
					num = HashHelpers.Combine(num, ((uint)(object)this[m]).GetHashCode());
				}
				return num;
			}
			if (typeof(T) == typeof(int))
			{
				for (int n = 0; n < Count; n++)
				{
					num = HashHelpers.Combine(num, ((int)(object)this[n]).GetHashCode());
				}
				return num;
			}
			if (typeof(T) == typeof(ulong))
			{
				for (int num2 = 0; num2 < Count; num2++)
				{
					num = HashHelpers.Combine(num, ((ulong)(object)this[num2]).GetHashCode());
				}
				return num;
			}
			if (typeof(T) == typeof(long))
			{
				for (int num3 = 0; num3 < Count; num3++)
				{
					num = HashHelpers.Combine(num, ((long)(object)this[num3]).GetHashCode());
				}
				return num;
			}
			if (typeof(T) == typeof(float))
			{
				for (int num4 = 0; num4 < Count; num4++)
				{
					num = HashHelpers.Combine(num, ((float)(object)this[num4]).GetHashCode());
				}
				return num;
			}
			if (typeof(T) == typeof(double))
			{
				for (int num5 = 0; num5 < Count; num5++)
				{
					num = HashHelpers.Combine(num, ((double)(object)this[num5]).GetHashCode());
				}
				return num;
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
		if (typeof(T) == typeof(byte))
		{
			num = HashHelpers.Combine(num, register.byte_0.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_1.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_2.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_3.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_4.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_5.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_6.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_7.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_8.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_9.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_10.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_11.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_12.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_13.GetHashCode());
			num = HashHelpers.Combine(num, register.byte_14.GetHashCode());
			return HashHelpers.Combine(num, register.byte_15.GetHashCode());
		}
		if (typeof(T) == typeof(sbyte))
		{
			num = HashHelpers.Combine(num, register.sbyte_0.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_1.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_2.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_3.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_4.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_5.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_6.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_7.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_8.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_9.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_10.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_11.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_12.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_13.GetHashCode());
			num = HashHelpers.Combine(num, register.sbyte_14.GetHashCode());
			return HashHelpers.Combine(num, register.sbyte_15.GetHashCode());
		}
		if (typeof(T) == typeof(ushort))
		{
			num = HashHelpers.Combine(num, register.uint16_0.GetHashCode());
			num = HashHelpers.Combine(num, register.uint16_1.GetHashCode());
			num = HashHelpers.Combine(num, register.uint16_2.GetHashCode());
			num = HashHelpers.Combine(num, register.uint16_3.GetHashCode());
			num = HashHelpers.Combine(num, register.uint16_4.GetHashCode());
			num = HashHelpers.Combine(num, register.uint16_5.GetHashCode());
			num = HashHelpers.Combine(num, register.uint16_6.GetHashCode());
			return HashHelpers.Combine(num, register.uint16_7.GetHashCode());
		}
		if (typeof(T) == typeof(short))
		{
			num = HashHelpers.Combine(num, register.int16_0.GetHashCode());
			num = HashHelpers.Combine(num, register.int16_1.GetHashCode());
			num = HashHelpers.Combine(num, register.int16_2.GetHashCode());
			num = HashHelpers.Combine(num, register.int16_3.GetHashCode());
			num = HashHelpers.Combine(num, register.int16_4.GetHashCode());
			num = HashHelpers.Combine(num, register.int16_5.GetHashCode());
			num = HashHelpers.Combine(num, register.int16_6.GetHashCode());
			return HashHelpers.Combine(num, register.int16_7.GetHashCode());
		}
		if (typeof(T) == typeof(uint))
		{
			num = HashHelpers.Combine(num, register.uint32_0.GetHashCode());
			num = HashHelpers.Combine(num, register.uint32_1.GetHashCode());
			num = HashHelpers.Combine(num, register.uint32_2.GetHashCode());
			return HashHelpers.Combine(num, register.uint32_3.GetHashCode());
		}
		if (typeof(T) == typeof(int))
		{
			num = HashHelpers.Combine(num, register.int32_0.GetHashCode());
			num = HashHelpers.Combine(num, register.int32_1.GetHashCode());
			num = HashHelpers.Combine(num, register.int32_2.GetHashCode());
			return HashHelpers.Combine(num, register.int32_3.GetHashCode());
		}
		if (typeof(T) == typeof(ulong))
		{
			num = HashHelpers.Combine(num, register.uint64_0.GetHashCode());
			return HashHelpers.Combine(num, register.uint64_1.GetHashCode());
		}
		if (typeof(T) == typeof(long))
		{
			num = HashHelpers.Combine(num, register.int64_0.GetHashCode());
			return HashHelpers.Combine(num, register.int64_1.GetHashCode());
		}
		if (typeof(T) == typeof(float))
		{
			num = HashHelpers.Combine(num, register.single_0.GetHashCode());
			num = HashHelpers.Combine(num, register.single_1.GetHashCode());
			num = HashHelpers.Combine(num, register.single_2.GetHashCode());
			return HashHelpers.Combine(num, register.single_3.GetHashCode());
		}
		if (typeof(T) == typeof(double))
		{
			num = HashHelpers.Combine(num, register.double_0.GetHashCode());
			return HashHelpers.Combine(num, register.double_1.GetHashCode());
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	public override string ToString()
	{
		return ToString("G", CultureInfo.CurrentCulture);
	}

	public string ToString(string format)
	{
		return ToString(format, CultureInfo.CurrentCulture);
	}

	public string ToString(string format, IFormatProvider formatProvider)
	{
		StringBuilder stringBuilder = new StringBuilder();
		string numberGroupSeparator = NumberFormatInfo.GetInstance(formatProvider).NumberGroupSeparator;
		stringBuilder.Append('<');
		for (int i = 0; i < Count - 1; i++)
		{
			stringBuilder.Append(((IFormattable)(object)this[i]).ToString(format, formatProvider));
			stringBuilder.Append(numberGroupSeparator);
			stringBuilder.Append(' ');
		}
		stringBuilder.Append(((IFormattable)(object)this[Count - 1]).ToString(format, formatProvider));
		stringBuilder.Append('>');
		return stringBuilder.ToString();
	}

	public unsafe static Vector<T> operator +(Vector<T> left, Vector<T> right)
	{
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				byte* ptr = stackalloc byte[(int)(uint)Count];
				for (int i = 0; i < Count; i++)
				{
					ptr[i] = (byte)(object)ScalarAdd(left[i], right[i]);
				}
				return new Vector<T>(ptr);
			}
			if (typeof(T) == typeof(sbyte))
			{
				sbyte* ptr2 = stackalloc sbyte[(int)(uint)Count];
				for (int j = 0; j < Count; j++)
				{
					ptr2[j] = (sbyte)(object)ScalarAdd(left[j], right[j]);
				}
				return new Vector<T>(ptr2);
			}
			if (typeof(T) == typeof(ushort))
			{
				ushort* ptr3 = stackalloc ushort[Count];
				for (int k = 0; k < Count; k++)
				{
					ptr3[k] = (ushort)(object)ScalarAdd(left[k], right[k]);
				}
				return new Vector<T>(ptr3);
			}
			if (typeof(T) == typeof(short))
			{
				short* ptr4 = stackalloc short[Count];
				for (int l = 0; l < Count; l++)
				{
					ptr4[l] = (short)(object)ScalarAdd(left[l], right[l]);
				}
				return new Vector<T>(ptr4);
			}
			if (typeof(T) == typeof(uint))
			{
				uint* ptr5 = stackalloc uint[Count];
				for (int m = 0; m < Count; m++)
				{
					ptr5[m] = (uint)(object)ScalarAdd(left[m], right[m]);
				}
				return new Vector<T>(ptr5);
			}
			if (typeof(T) == typeof(int))
			{
				int* ptr6 = stackalloc int[Count];
				for (int n = 0; n < Count; n++)
				{
					ptr6[n] = (int)(object)ScalarAdd(left[n], right[n]);
				}
				return new Vector<T>(ptr6);
			}
			if (typeof(T) == typeof(ulong))
			{
				ulong* ptr7 = stackalloc ulong[Count];
				for (int num = 0; num < Count; num++)
				{
					ptr7[num] = (ulong)(object)ScalarAdd(left[num], right[num]);
				}
				return new Vector<T>(ptr7);
			}
			if (typeof(T) == typeof(long))
			{
				long* ptr8 = stackalloc long[Count];
				for (int num2 = 0; num2 < Count; num2++)
				{
					ptr8[num2] = (long)(object)ScalarAdd(left[num2], right[num2]);
				}
				return new Vector<T>(ptr8);
			}
			if (typeof(T) == typeof(float))
			{
				float* ptr9 = stackalloc float[Count];
				for (int num3 = 0; num3 < Count; num3++)
				{
					ptr9[num3] = (float)(object)ScalarAdd(left[num3], right[num3]);
				}
				return new Vector<T>(ptr9);
			}
			if (typeof(T) == typeof(double))
			{
				double* ptr10 = stackalloc double[Count];
				for (int num4 = 0; num4 < Count; num4++)
				{
					ptr10[num4] = (double)(object)ScalarAdd(left[num4], right[num4]);
				}
				return new Vector<T>(ptr10);
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
		Vector<T> result = default(Vector<T>);
		if (typeof(T) == typeof(byte))
		{
			result.register.byte_0 = (byte)(left.register.byte_0 + right.register.byte_0);
			result.register.byte_1 = (byte)(left.register.byte_1 + right.register.byte_1);
			result.register.byte_2 = (byte)(left.register.byte_2 + right.register.byte_2);
			result.register.byte_3 = (byte)(left.register.byte_3 + right.register.byte_3);
			result.register.byte_4 = (byte)(left.register.byte_4 + right.register.byte_4);
			result.register.byte_5 = (byte)(left.register.byte_5 + right.register.byte_5);
			result.register.byte_6 = (byte)(left.register.byte_6 + right.register.byte_6);
			result.register.byte_7 = (byte)(left.register.byte_7 + right.register.byte_7);
			result.register.byte_8 = (byte)(left.register.byte_8 + right.register.byte_8);
			result.register.byte_9 = (byte)(left.register.byte_9 + right.register.byte_9);
			result.register.byte_10 = (byte)(left.register.byte_10 + right.register.byte_10);
			result.register.byte_11 = (byte)(left.register.byte_11 + right.register.byte_11);
			result.register.byte_12 = (byte)(left.register.byte_12 + right.register.byte_12);
			result.register.byte_13 = (byte)(left.register.byte_13 + right.register.byte_13);
			result.register.byte_14 = (byte)(left.register.byte_14 + right.register.byte_14);
			result.register.byte_15 = (byte)(left.register.byte_15 + right.register.byte_15);
		}
		else if (typeof(T) == typeof(sbyte))
		{
			result.register.sbyte_0 = (sbyte)(left.register.sbyte_0 + right.register.sbyte_0);
			result.register.sbyte_1 = (sbyte)(left.register.sbyte_1 + right.register.sbyte_1);
			result.register.sbyte_2 = (sbyte)(left.register.sbyte_2 + right.register.sbyte_2);
			result.register.sbyte_3 = (sbyte)(left.register.sbyte_3 + right.register.sbyte_3);
			result.register.sbyte_4 = (sbyte)(left.register.sbyte_4 + right.register.sbyte_4);
			result.register.sbyte_5 = (sbyte)(left.register.sbyte_5 + right.register.sbyte_5);
			result.register.sbyte_6 = (sbyte)(left.register.sbyte_6 + right.register.sbyte_6);
			result.register.sbyte_7 = (sbyte)(left.register.sbyte_7 + right.register.sbyte_7);
			result.register.sbyte_8 = (sbyte)(left.register.sbyte_8 + right.register.sbyte_8);
			result.register.sbyte_9 = (sbyte)(left.register.sbyte_9 + right.register.sbyte_9);
			result.register.sbyte_10 = (sbyte)(left.register.sbyte_10 + right.register.sbyte_10);
			result.register.sbyte_11 = (sbyte)(left.register.sbyte_11 + right.register.sbyte_11);
			result.register.sbyte_12 = (sbyte)(left.register.sbyte_12 + right.register.sbyte_12);
			result.register.sbyte_13 = (sbyte)(left.register.sbyte_13 + right.register.sbyte_13);
			result.register.sbyte_14 = (sbyte)(left.register.sbyte_14 + right.register.sbyte_14);
			result.register.sbyte_15 = (sbyte)(left.register.sbyte_15 + right.register.sbyte_15);
		}
		else if (typeof(T) == typeof(ushort))
		{
			result.register.uint16_0 = (ushort)(left.register.uint16_0 + right.register.uint16_0);
			result.register.uint16_1 = (ushort)(left.register.uint16_1 + right.register.uint16_1);
			result.register.uint16_2 = (ushort)(left.register.uint16_2 + right.register.uint16_2);
			result.register.uint16_3 = (ushort)(left.register.uint16_3 + right.register.uint16_3);
			result.register.uint16_4 = (ushort)(left.register.uint16_4 + right.register.uint16_4);
			result.register.uint16_5 = (ushort)(left.register.uint16_5 + right.register.uint16_5);
			result.register.uint16_6 = (ushort)(left.register.uint16_6 + right.register.uint16_6);
			result.register.uint16_7 = (ushort)(left.register.uint16_7 + right.register.uint16_7);
		}
		else if (typeof(T) == typeof(short))
		{
			result.register.int16_0 = (short)(left.register.int16_0 + right.register.int16_0);
			result.register.int16_1 = (short)(left.register.int16_1 + right.register.int16_1);
			result.register.int16_2 = (short)(left.register.int16_2 + right.register.int16_2);
			result.register.int16_3 = (short)(left.register.int16_3 + right.register.int16_3);
			result.register.int16_4 = (short)(left.register.int16_4 + right.register.int16_4);
			result.register.int16_5 = (short)(left.register.int16_5 + right.register.int16_5);
			result.register.int16_6 = (short)(left.register.int16_6 + right.register.int16_6);
			result.register.int16_7 = (short)(left.register.int16_7 + right.register.int16_7);
		}
		else if (typeof(T) == typeof(uint))
		{
			result.register.uint32_0 = left.register.uint32_0 + right.register.uint32_0;
			result.register.uint32_1 = left.register.uint32_1 + right.register.uint32_1;
			result.register.uint32_2 = left.register.uint32_2 + right.register.uint32_2;
			result.register.uint32_3 = left.register.uint32_3 + right.register.uint32_3;
		}
		else if (typeof(T) == typeof(int))
		{
			result.register.int32_0 = left.register.int32_0 + right.register.int32_0;
			result.register.int32_1 = left.register.int32_1 + right.register.int32_1;
			result.register.int32_2 = left.register.int32_2 + right.register.int32_2;
			result.register.int32_3 = left.register.int32_3 + right.register.int32_3;
		}
		else if (typeof(T) == typeof(ulong))
		{
			result.register.uint64_0 = left.register.uint64_0 + right.register.uint64_0;
			result.register.uint64_1 = left.register.uint64_1 + right.register.uint64_1;
		}
		else if (typeof(T) == typeof(long))
		{
			result.register.int64_0 = left.register.int64_0 + right.register.int64_0;
			result.register.int64_1 = left.register.int64_1 + right.register.int64_1;
		}
		else if (typeof(T) == typeof(float))
		{
			result.register.single_0 = left.register.single_0 + right.register.single_0;
			result.register.single_1 = left.register.single_1 + right.register.single_1;
			result.register.single_2 = left.register.single_2 + right.register.single_2;
			result.register.single_3 = left.register.single_3 + right.register.single_3;
		}
		else if (typeof(T) == typeof(double))
		{
			result.register.double_0 = left.register.double_0 + right.register.double_0;
			result.register.double_1 = left.register.double_1 + right.register.double_1;
		}
		return result;
	}

	public unsafe static Vector<T> operator -(Vector<T> left, Vector<T> right)
	{
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				byte* ptr = stackalloc byte[(int)(uint)Count];
				for (int i = 0; i < Count; i++)
				{
					ptr[i] = (byte)(object)ScalarSubtract(left[i], right[i]);
				}
				return new Vector<T>(ptr);
			}
			if (typeof(T) == typeof(sbyte))
			{
				sbyte* ptr2 = stackalloc sbyte[(int)(uint)Count];
				for (int j = 0; j < Count; j++)
				{
					ptr2[j] = (sbyte)(object)ScalarSubtract(left[j], right[j]);
				}
				return new Vector<T>(ptr2);
			}
			if (typeof(T) == typeof(ushort))
			{
				ushort* ptr3 = stackalloc ushort[Count];
				for (int k = 0; k < Count; k++)
				{
					ptr3[k] = (ushort)(object)ScalarSubtract(left[k], right[k]);
				}
				return new Vector<T>(ptr3);
			}
			if (typeof(T) == typeof(short))
			{
				short* ptr4 = stackalloc short[Count];
				for (int l = 0; l < Count; l++)
				{
					ptr4[l] = (short)(object)ScalarSubtract(left[l], right[l]);
				}
				return new Vector<T>(ptr4);
			}
			if (typeof(T) == typeof(uint))
			{
				uint* ptr5 = stackalloc uint[Count];
				for (int m = 0; m < Count; m++)
				{
					ptr5[m] = (uint)(object)ScalarSubtract(left[m], right[m]);
				}
				return new Vector<T>(ptr5);
			}
			if (typeof(T) == typeof(int))
			{
				int* ptr6 = stackalloc int[Count];
				for (int n = 0; n < Count; n++)
				{
					ptr6[n] = (int)(object)ScalarSubtract(left[n], right[n]);
				}
				return new Vector<T>(ptr6);
			}
			if (typeof(T) == typeof(ulong))
			{
				ulong* ptr7 = stackalloc ulong[Count];
				for (int num = 0; num < Count; num++)
				{
					ptr7[num] = (ulong)(object)ScalarSubtract(left[num], right[num]);
				}
				return new Vector<T>(ptr7);
			}
			if (typeof(T) == typeof(long))
			{
				long* ptr8 = stackalloc long[Count];
				for (int num2 = 0; num2 < Count; num2++)
				{
					ptr8[num2] = (long)(object)ScalarSubtract(left[num2], right[num2]);
				}
				return new Vector<T>(ptr8);
			}
			if (typeof(T) == typeof(float))
			{
				float* ptr9 = stackalloc float[Count];
				for (int num3 = 0; num3 < Count; num3++)
				{
					ptr9[num3] = (float)(object)ScalarSubtract(left[num3], right[num3]);
				}
				return new Vector<T>(ptr9);
			}
			if (typeof(T) == typeof(double))
			{
				double* ptr10 = stackalloc double[Count];
				for (int num4 = 0; num4 < Count; num4++)
				{
					ptr10[num4] = (double)(object)ScalarSubtract(left[num4], right[num4]);
				}
				return new Vector<T>(ptr10);
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
		Vector<T> result = default(Vector<T>);
		if (typeof(T) == typeof(byte))
		{
			result.register.byte_0 = (byte)(left.register.byte_0 - right.register.byte_0);
			result.register.byte_1 = (byte)(left.register.byte_1 - right.register.byte_1);
			result.register.byte_2 = (byte)(left.register.byte_2 - right.register.byte_2);
			result.register.byte_3 = (byte)(left.register.byte_3 - right.register.byte_3);
			result.register.byte_4 = (byte)(left.register.byte_4 - right.register.byte_4);
			result.register.byte_5 = (byte)(left.register.byte_5 - right.register.byte_5);
			result.register.byte_6 = (byte)(left.register.byte_6 - right.register.byte_6);
			result.register.byte_7 = (byte)(left.register.byte_7 - right.register.byte_7);
			result.register.byte_8 = (byte)(left.register.byte_8 - right.register.byte_8);
			result.register.byte_9 = (byte)(left.register.byte_9 - right.register.byte_9);
			result.register.byte_10 = (byte)(left.register.byte_10 - right.register.byte_10);
			result.register.byte_11 = (byte)(left.register.byte_11 - right.register.byte_11);
			result.register.byte_12 = (byte)(left.register.byte_12 - right.register.byte_12);
			result.register.byte_13 = (byte)(left.register.byte_13 - right.register.byte_13);
			result.register.byte_14 = (byte)(left.register.byte_14 - right.register.byte_14);
			result.register.byte_15 = (byte)(left.register.byte_15 - right.register.byte_15);
		}
		else if (typeof(T) == typeof(sbyte))
		{
			result.register.sbyte_0 = (sbyte)(left.register.sbyte_0 - right.register.sbyte_0);
			result.register.sbyte_1 = (sbyte)(left.register.sbyte_1 - right.register.sbyte_1);
			result.register.sbyte_2 = (sbyte)(left.register.sbyte_2 - right.register.sbyte_2);
			result.register.sbyte_3 = (sbyte)(left.register.sbyte_3 - right.register.sbyte_3);
			result.register.sbyte_4 = (sbyte)(left.register.sbyte_4 - right.register.sbyte_4);
			result.register.sbyte_5 = (sbyte)(left.register.sbyte_5 - right.register.sbyte_5);
			result.register.sbyte_6 = (sbyte)(left.register.sbyte_6 - right.register.sbyte_6);
			result.register.sbyte_7 = (sbyte)(left.register.sbyte_7 - right.register.sbyte_7);
			result.register.sbyte_8 = (sbyte)(left.register.sbyte_8 - right.register.sbyte_8);
			result.register.sbyte_9 = (sbyte)(left.register.sbyte_9 - right.register.sbyte_9);
			result.register.sbyte_10 = (sbyte)(left.register.sbyte_10 - right.register.sbyte_10);
			result.register.sbyte_11 = (sbyte)(left.register.sbyte_11 - right.register.sbyte_11);
			result.register.sbyte_12 = (sbyte)(left.register.sbyte_12 - right.register.sbyte_12);
			result.register.sbyte_13 = (sbyte)(left.register.sbyte_13 - right.register.sbyte_13);
			result.register.sbyte_14 = (sbyte)(left.register.sbyte_14 - right.register.sbyte_14);
			result.register.sbyte_15 = (sbyte)(left.register.sbyte_15 - right.register.sbyte_15);
		}
		else if (typeof(T) == typeof(ushort))
		{
			result.register.uint16_0 = (ushort)(left.register.uint16_0 - right.register.uint16_0);
			result.register.uint16_1 = (ushort)(left.register.uint16_1 - right.register.uint16_1);
			result.register.uint16_2 = (ushort)(left.register.uint16_2 - right.register.uint16_2);
			result.register.uint16_3 = (ushort)(left.register.uint16_3 - right.register.uint16_3);
			result.register.uint16_4 = (ushort)(left.register.uint16_4 - right.register.uint16_4);
			result.register.uint16_5 = (ushort)(left.register.uint16_5 - right.register.uint16_5);
			result.register.uint16_6 = (ushort)(left.register.uint16_6 - right.register.uint16_6);
			result.register.uint16_7 = (ushort)(left.register.uint16_7 - right.register.uint16_7);
		}
		else if (typeof(T) == typeof(short))
		{
			result.register.int16_0 = (short)(left.register.int16_0 - right.register.int16_0);
			result.register.int16_1 = (short)(left.register.int16_1 - right.register.int16_1);
			result.register.int16_2 = (short)(left.register.int16_2 - right.register.int16_2);
			result.register.int16_3 = (short)(left.register.int16_3 - right.register.int16_3);
			result.register.int16_4 = (short)(left.register.int16_4 - right.register.int16_4);
			result.register.int16_5 = (short)(left.register.int16_5 - right.register.int16_5);
			result.register.int16_6 = (short)(left.register.int16_6 - right.register.int16_6);
			result.register.int16_7 = (short)(left.register.int16_7 - right.register.int16_7);
		}
		else if (typeof(T) == typeof(uint))
		{
			result.register.uint32_0 = left.register.uint32_0 - right.register.uint32_0;
			result.register.uint32_1 = left.register.uint32_1 - right.register.uint32_1;
			result.register.uint32_2 = left.register.uint32_2 - right.register.uint32_2;
			result.register.uint32_3 = left.register.uint32_3 - right.register.uint32_3;
		}
		else if (typeof(T) == typeof(int))
		{
			result.register.int32_0 = left.register.int32_0 - right.register.int32_0;
			result.register.int32_1 = left.register.int32_1 - right.register.int32_1;
			result.register.int32_2 = left.register.int32_2 - right.register.int32_2;
			result.register.int32_3 = left.register.int32_3 - right.register.int32_3;
		}
		else if (typeof(T) == typeof(ulong))
		{
			result.register.uint64_0 = left.register.uint64_0 - right.register.uint64_0;
			result.register.uint64_1 = left.register.uint64_1 - right.register.uint64_1;
		}
		else if (typeof(T) == typeof(long))
		{
			result.register.int64_0 = left.register.int64_0 - right.register.int64_0;
			result.register.int64_1 = left.register.int64_1 - right.register.int64_1;
		}
		else if (typeof(T) == typeof(float))
		{
			result.register.single_0 = left.register.single_0 - right.register.single_0;
			result.register.single_1 = left.register.single_1 - right.register.single_1;
			result.register.single_2 = left.register.single_2 - right.register.single_2;
			result.register.single_3 = left.register.single_3 - right.register.single_3;
		}
		else if (typeof(T) == typeof(double))
		{
			result.register.double_0 = left.register.double_0 - right.register.double_0;
			result.register.double_1 = left.register.double_1 - right.register.double_1;
		}
		return result;
	}

	public unsafe static Vector<T> operator *(Vector<T> left, Vector<T> right)
	{
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				byte* ptr = stackalloc byte[(int)(uint)Count];
				for (int i = 0; i < Count; i++)
				{
					ptr[i] = (byte)(object)ScalarMultiply(left[i], right[i]);
				}
				return new Vector<T>(ptr);
			}
			if (typeof(T) == typeof(sbyte))
			{
				sbyte* ptr2 = stackalloc sbyte[(int)(uint)Count];
				for (int j = 0; j < Count; j++)
				{
					ptr2[j] = (sbyte)(object)ScalarMultiply(left[j], right[j]);
				}
				return new Vector<T>(ptr2);
			}
			if (typeof(T) == typeof(ushort))
			{
				ushort* ptr3 = stackalloc ushort[Count];
				for (int k = 0; k < Count; k++)
				{
					ptr3[k] = (ushort)(object)ScalarMultiply(left[k], right[k]);
				}
				return new Vector<T>(ptr3);
			}
			if (typeof(T) == typeof(short))
			{
				short* ptr4 = stackalloc short[Count];
				for (int l = 0; l < Count; l++)
				{
					ptr4[l] = (short)(object)ScalarMultiply(left[l], right[l]);
				}
				return new Vector<T>(ptr4);
			}
			if (typeof(T) == typeof(uint))
			{
				uint* ptr5 = stackalloc uint[Count];
				for (int m = 0; m < Count; m++)
				{
					ptr5[m] = (uint)(object)ScalarMultiply(left[m], right[m]);
				}
				return new Vector<T>(ptr5);
			}
			if (typeof(T) == typeof(int))
			{
				int* ptr6 = stackalloc int[Count];
				for (int n = 0; n < Count; n++)
				{
					ptr6[n] = (int)(object)ScalarMultiply(left[n], right[n]);
				}
				return new Vector<T>(ptr6);
			}
			if (typeof(T) == typeof(ulong))
			{
				ulong* ptr7 = stackalloc ulong[Count];
				for (int num = 0; num < Count; num++)
				{
					ptr7[num] = (ulong)(object)ScalarMultiply(left[num], right[num]);
				}
				return new Vector<T>(ptr7);
			}
			if (typeof(T) == typeof(long))
			{
				long* ptr8 = stackalloc long[Count];
				for (int num2 = 0; num2 < Count; num2++)
				{
					ptr8[num2] = (long)(object)ScalarMultiply(left[num2], right[num2]);
				}
				return new Vector<T>(ptr8);
			}
			if (typeof(T) == typeof(float))
			{
				float* ptr9 = stackalloc float[Count];
				for (int num3 = 0; num3 < Count; num3++)
				{
					ptr9[num3] = (float)(object)ScalarMultiply(left[num3], right[num3]);
				}
				return new Vector<T>(ptr9);
			}
			if (typeof(T) == typeof(double))
			{
				double* ptr10 = stackalloc double[Count];
				for (int num4 = 0; num4 < Count; num4++)
				{
					ptr10[num4] = (double)(object)ScalarMultiply(left[num4], right[num4]);
				}
				return new Vector<T>(ptr10);
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
		Vector<T> result = default(Vector<T>);
		if (typeof(T) == typeof(byte))
		{
			result.register.byte_0 = (byte)(left.register.byte_0 * right.register.byte_0);
			result.register.byte_1 = (byte)(left.register.byte_1 * right.register.byte_1);
			result.register.byte_2 = (byte)(left.register.byte_2 * right.register.byte_2);
			result.register.byte_3 = (byte)(left.register.byte_3 * right.register.byte_3);
			result.register.byte_4 = (byte)(left.register.byte_4 * right.register.byte_4);
			result.register.byte_5 = (byte)(left.register.byte_5 * right.register.byte_5);
			result.register.byte_6 = (byte)(left.register.byte_6 * right.register.byte_6);
			result.register.byte_7 = (byte)(left.register.byte_7 * right.register.byte_7);
			result.register.byte_8 = (byte)(left.register.byte_8 * right.register.byte_8);
			result.register.byte_9 = (byte)(left.register.byte_9 * right.register.byte_9);
			result.register.byte_10 = (byte)(left.register.byte_10 * right.register.byte_10);
			result.register.byte_11 = (byte)(left.register.byte_11 * right.register.byte_11);
			result.register.byte_12 = (byte)(left.register.byte_12 * right.register.byte_12);
			result.register.byte_13 = (byte)(left.register.byte_13 * right.register.byte_13);
			result.register.byte_14 = (byte)(left.register.byte_14 * right.register.byte_14);
			result.register.byte_15 = (byte)(left.register.byte_15 * right.register.byte_15);
		}
		else if (typeof(T) == typeof(sbyte))
		{
			result.register.sbyte_0 = (sbyte)(left.register.sbyte_0 * right.register.sbyte_0);
			result.register.sbyte_1 = (sbyte)(left.register.sbyte_1 * right.register.sbyte_1);
			result.register.sbyte_2 = (sbyte)(left.register.sbyte_2 * right.register.sbyte_2);
			result.register.sbyte_3 = (sbyte)(left.register.sbyte_3 * right.register.sbyte_3);
			result.register.sbyte_4 = (sbyte)(left.register.sbyte_4 * right.register.sbyte_4);
			result.register.sbyte_5 = (sbyte)(left.register.sbyte_5 * right.register.sbyte_5);
			result.register.sbyte_6 = (sbyte)(left.register.sbyte_6 * right.register.sbyte_6);
			result.register.sbyte_7 = (sbyte)(left.register.sbyte_7 * right.register.sbyte_7);
			result.register.sbyte_8 = (sbyte)(left.register.sbyte_8 * right.register.sbyte_8);
			result.register.sbyte_9 = (sbyte)(left.register.sbyte_9 * right.register.sbyte_9);
			result.register.sbyte_10 = (sbyte)(left.register.sbyte_10 * right.register.sbyte_10);
			result.register.sbyte_11 = (sbyte)(left.register.sbyte_11 * right.register.sbyte_11);
			result.register.sbyte_12 = (sbyte)(left.register.sbyte_12 * right.register.sbyte_12);
			result.register.sbyte_13 = (sbyte)(left.register.sbyte_13 * right.register.sbyte_13);
			result.register.sbyte_14 = (sbyte)(left.register.sbyte_14 * right.register.sbyte_14);
			result.register.sbyte_15 = (sbyte)(left.register.sbyte_15 * right.register.sbyte_15);
		}
		else if (typeof(T) == typeof(ushort))
		{
			result.register.uint16_0 = (ushort)(left.register.uint16_0 * right.register.uint16_0);
			result.register.uint16_1 = (ushort)(left.register.uint16_1 * right.register.uint16_1);
			result.register.uint16_2 = (ushort)(left.register.uint16_2 * right.register.uint16_2);
			result.register.uint16_3 = (ushort)(left.register.uint16_3 * right.register.uint16_3);
			result.register.uint16_4 = (ushort)(left.register.uint16_4 * right.register.uint16_4);
			result.register.uint16_5 = (ushort)(left.register.uint16_5 * right.register.uint16_5);
			result.register.uint16_6 = (ushort)(left.register.uint16_6 * right.register.uint16_6);
			result.register.uint16_7 = (ushort)(left.register.uint16_7 * right.register.uint16_7);
		}
		else if (typeof(T) == typeof(short))
		{
			result.register.int16_0 = (short)(left.register.int16_0 * right.register.int16_0);
			result.register.int16_1 = (short)(left.register.int16_1 * right.register.int16_1);
			result.register.int16_2 = (short)(left.register.int16_2 * right.register.int16_2);
			result.register.int16_3 = (short)(left.register.int16_3 * right.register.int16_3);
			result.register.int16_4 = (short)(left.register.int16_4 * right.register.int16_4);
			result.register.int16_5 = (short)(left.register.int16_5 * right.register.int16_5);
			result.register.int16_6 = (short)(left.register.int16_6 * right.register.int16_6);
			result.register.int16_7 = (short)(left.register.int16_7 * right.register.int16_7);
		}
		else if (typeof(T) == typeof(uint))
		{
			result.register.uint32_0 = left.register.uint32_0 * right.register.uint32_0;
			result.register.uint32_1 = left.register.uint32_1 * right.register.uint32_1;
			result.register.uint32_2 = left.register.uint32_2 * right.register.uint32_2;
			result.register.uint32_3 = left.register.uint32_3 * right.register.uint32_3;
		}
		else if (typeof(T) == typeof(int))
		{
			result.register.int32_0 = left.register.int32_0 * right.register.int32_0;
			result.register.int32_1 = left.register.int32_1 * right.register.int32_1;
			result.register.int32_2 = left.register.int32_2 * right.register.int32_2;
			result.register.int32_3 = left.register.int32_3 * right.register.int32_3;
		}
		else if (typeof(T) == typeof(ulong))
		{
			result.register.uint64_0 = left.register.uint64_0 * right.register.uint64_0;
			result.register.uint64_1 = left.register.uint64_1 * right.register.uint64_1;
		}
		else if (typeof(T) == typeof(long))
		{
			result.register.int64_0 = left.register.int64_0 * right.register.int64_0;
			result.register.int64_1 = left.register.int64_1 * right.register.int64_1;
		}
		else if (typeof(T) == typeof(float))
		{
			result.register.single_0 = left.register.single_0 * right.register.single_0;
			result.register.single_1 = left.register.single_1 * right.register.single_1;
			result.register.single_2 = left.register.single_2 * right.register.single_2;
			result.register.single_3 = left.register.single_3 * right.register.single_3;
		}
		else if (typeof(T) == typeof(double))
		{
			result.register.double_0 = left.register.double_0 * right.register.double_0;
			result.register.double_1 = left.register.double_1 * right.register.double_1;
		}
		return result;
	}

	public static Vector<T> operator *(Vector<T> value, T factor)
	{
		if (Vector.IsHardwareAccelerated)
		{
			return new Vector<T>(factor) * value;
		}
		Vector<T> result = default(Vector<T>);
		if (typeof(T) == typeof(byte))
		{
			result.register.byte_0 = (byte)(value.register.byte_0 * (byte)(object)factor);
			result.register.byte_1 = (byte)(value.register.byte_1 * (byte)(object)factor);
			result.register.byte_2 = (byte)(value.register.byte_2 * (byte)(object)factor);
			result.register.byte_3 = (byte)(value.register.byte_3 * (byte)(object)factor);
			result.register.byte_4 = (byte)(value.register.byte_4 * (byte)(object)factor);
			result.register.byte_5 = (byte)(value.register.byte_5 * (byte)(object)factor);
			result.register.byte_6 = (byte)(value.register.byte_6 * (byte)(object)factor);
			result.register.byte_7 = (byte)(value.register.byte_7 * (byte)(object)factor);
			result.register.byte_8 = (byte)(value.register.byte_8 * (byte)(object)factor);
			result.register.byte_9 = (byte)(value.register.byte_9 * (byte)(object)factor);
			result.register.byte_10 = (byte)(value.register.byte_10 * (byte)(object)factor);
			result.register.byte_11 = (byte)(value.register.byte_11 * (byte)(object)factor);
			result.register.byte_12 = (byte)(value.register.byte_12 * (byte)(object)factor);
			result.register.byte_13 = (byte)(value.register.byte_13 * (byte)(object)factor);
			result.register.byte_14 = (byte)(value.register.byte_14 * (byte)(object)factor);
			result.register.byte_15 = (byte)(value.register.byte_15 * (byte)(object)factor);
		}
		else if (typeof(T) == typeof(sbyte))
		{
			result.register.sbyte_0 = (sbyte)(value.register.sbyte_0 * (sbyte)(object)factor);
			result.register.sbyte_1 = (sbyte)(value.register.sbyte_1 * (sbyte)(object)factor);
			result.register.sbyte_2 = (sbyte)(value.register.sbyte_2 * (sbyte)(object)factor);
			result.register.sbyte_3 = (sbyte)(value.register.sbyte_3 * (sbyte)(object)factor);
			result.register.sbyte_4 = (sbyte)(value.register.sbyte_4 * (sbyte)(object)factor);
			result.register.sbyte_5 = (sbyte)(value.register.sbyte_5 * (sbyte)(object)factor);
			result.register.sbyte_6 = (sbyte)(value.register.sbyte_6 * (sbyte)(object)factor);
			result.register.sbyte_7 = (sbyte)(value.register.sbyte_7 * (sbyte)(object)factor);
			result.register.sbyte_8 = (sbyte)(value.register.sbyte_8 * (sbyte)(object)factor);
			result.register.sbyte_9 = (sbyte)(value.register.sbyte_9 * (sbyte)(object)factor);
			result.register.sbyte_10 = (sbyte)(value.register.sbyte_10 * (sbyte)(object)factor);
			result.register.sbyte_11 = (sbyte)(value.register.sbyte_11 * (sbyte)(object)factor);
			result.register.sbyte_12 = (sbyte)(value.register.sbyte_12 * (sbyte)(object)factor);
			result.register.sbyte_13 = (sbyte)(value.register.sbyte_13 * (sbyte)(object)factor);
			result.register.sbyte_14 = (sbyte)(value.register.sbyte_14 * (sbyte)(object)factor);
			result.register.sbyte_15 = (sbyte)(value.register.sbyte_15 * (sbyte)(object)factor);
		}
		else if (typeof(T) == typeof(ushort))
		{
			result.register.uint16_0 = (ushort)(value.register.uint16_0 * (ushort)(object)factor);
			result.register.uint16_1 = (ushort)(value.register.uint16_1 * (ushort)(object)factor);
			result.register.uint16_2 = (ushort)(value.register.uint16_2 * (ushort)(object)factor);
			result.register.uint16_3 = (ushort)(value.register.uint16_3 * (ushort)(object)factor);
			result.register.uint16_4 = (ushort)(value.register.uint16_4 * (ushort)(object)factor);
			result.register.uint16_5 = (ushort)(value.register.uint16_5 * (ushort)(object)factor);
			result.register.uint16_6 = (ushort)(value.register.uint16_6 * (ushort)(object)factor);
			result.register.uint16_7 = (ushort)(value.register.uint16_7 * (ushort)(object)factor);
		}
		else if (typeof(T) == typeof(short))
		{
			result.register.int16_0 = (short)(value.register.int16_0 * (short)(object)factor);
			result.register.int16_1 = (short)(value.register.int16_1 * (short)(object)factor);
			result.register.int16_2 = (short)(value.register.int16_2 * (short)(object)factor);
			result.register.int16_3 = (short)(value.register.int16_3 * (short)(object)factor);
			result.register.int16_4 = (short)(value.register.int16_4 * (short)(object)factor);
			result.register.int16_5 = (short)(value.register.int16_5 * (short)(object)factor);
			result.register.int16_6 = (short)(value.register.int16_6 * (short)(object)factor);
			result.register.int16_7 = (short)(value.register.int16_7 * (short)(object)factor);
		}
		else if (typeof(T) == typeof(uint))
		{
			result.register.uint32_0 = value.register.uint32_0 * (uint)(object)factor;
			result.register.uint32_1 = value.register.uint32_1 * (uint)(object)factor;
			result.register.uint32_2 = value.register.uint32_2 * (uint)(object)factor;
			result.register.uint32_3 = value.register.uint32_3 * (uint)(object)factor;
		}
		else if (typeof(T) == typeof(int))
		{
			result.register.int32_0 = value.register.int32_0 * (int)(object)factor;
			result.register.int32_1 = value.register.int32_1 * (int)(object)factor;
			result.register.int32_2 = value.register.int32_2 * (int)(object)factor;
			result.register.int32_3 = value.register.int32_3 * (int)(object)factor;
		}
		else if (typeof(T) == typeof(ulong))
		{
			result.register.uint64_0 = value.register.uint64_0 * (ulong)(object)factor;
			result.register.uint64_1 = value.register.uint64_1 * (ulong)(object)factor;
		}
		else if (typeof(T) == typeof(long))
		{
			result.register.int64_0 = value.register.int64_0 * (long)(object)factor;
			result.register.int64_1 = value.register.int64_1 * (long)(object)factor;
		}
		else if (typeof(T) == typeof(float))
		{
			result.register.single_0 = value.register.single_0 * (float)(object)factor;
			result.register.single_1 = value.register.single_1 * (float)(object)factor;
			result.register.single_2 = value.register.single_2 * (float)(object)factor;
			result.register.single_3 = value.register.single_3 * (float)(object)factor;
		}
		else if (typeof(T) == typeof(double))
		{
			result.register.double_0 = value.register.double_0 * (double)(object)factor;
			result.register.double_1 = value.register.double_1 * (double)(object)factor;
		}
		return result;
	}

	public static Vector<T> operator *(T factor, Vector<T> value)
	{
		if (Vector.IsHardwareAccelerated)
		{
			return new Vector<T>(factor) * value;
		}
		Vector<T> result = default(Vector<T>);
		if (typeof(T) == typeof(byte))
		{
			result.register.byte_0 = (byte)(value.register.byte_0 * (byte)(object)factor);
			result.register.byte_1 = (byte)(value.register.byte_1 * (byte)(object)factor);
			result.register.byte_2 = (byte)(value.register.byte_2 * (byte)(object)factor);
			result.register.byte_3 = (byte)(value.register.byte_3 * (byte)(object)factor);
			result.register.byte_4 = (byte)(value.register.byte_4 * (byte)(object)factor);
			result.register.byte_5 = (byte)(value.register.byte_5 * (byte)(object)factor);
			result.register.byte_6 = (byte)(value.register.byte_6 * (byte)(object)factor);
			result.register.byte_7 = (byte)(value.register.byte_7 * (byte)(object)factor);
			result.register.byte_8 = (byte)(value.register.byte_8 * (byte)(object)factor);
			result.register.byte_9 = (byte)(value.register.byte_9 * (byte)(object)factor);
			result.register.byte_10 = (byte)(value.register.byte_10 * (byte)(object)factor);
			result.register.byte_11 = (byte)(value.register.byte_11 * (byte)(object)factor);
			result.register.byte_12 = (byte)(value.register.byte_12 * (byte)(object)factor);
			result.register.byte_13 = (byte)(value.register.byte_13 * (byte)(object)factor);
			result.register.byte_14 = (byte)(value.register.byte_14 * (byte)(object)factor);
			result.register.byte_15 = (byte)(value.register.byte_15 * (byte)(object)factor);
		}
		else if (typeof(T) == typeof(sbyte))
		{
			result.register.sbyte_0 = (sbyte)(value.register.sbyte_0 * (sbyte)(object)factor);
			result.register.sbyte_1 = (sbyte)(value.register.sbyte_1 * (sbyte)(object)factor);
			result.register.sbyte_2 = (sbyte)(value.register.sbyte_2 * (sbyte)(object)factor);
			result.register.sbyte_3 = (sbyte)(value.register.sbyte_3 * (sbyte)(object)factor);
			result.register.sbyte_4 = (sbyte)(value.register.sbyte_4 * (sbyte)(object)factor);
			result.register.sbyte_5 = (sbyte)(value.register.sbyte_5 * (sbyte)(object)factor);
			result.register.sbyte_6 = (sbyte)(value.register.sbyte_6 * (sbyte)(object)factor);
			result.register.sbyte_7 = (sbyte)(value.register.sbyte_7 * (sbyte)(object)factor);
			result.register.sbyte_8 = (sbyte)(value.register.sbyte_8 * (sbyte)(object)factor);
			result.register.sbyte_9 = (sbyte)(value.register.sbyte_9 * (sbyte)(object)factor);
			result.register.sbyte_10 = (sbyte)(value.register.sbyte_10 * (sbyte)(object)factor);
			result.register.sbyte_11 = (sbyte)(value.register.sbyte_11 * (sbyte)(object)factor);
			result.register.sbyte_12 = (sbyte)(value.register.sbyte_12 * (sbyte)(object)factor);
			result.register.sbyte_13 = (sbyte)(value.register.sbyte_13 * (sbyte)(object)factor);
			result.register.sbyte_14 = (sbyte)(value.register.sbyte_14 * (sbyte)(object)factor);
			result.register.sbyte_15 = (sbyte)(value.register.sbyte_15 * (sbyte)(object)factor);
		}
		else if (typeof(T) == typeof(ushort))
		{
			result.register.uint16_0 = (ushort)(value.register.uint16_0 * (ushort)(object)factor);
			result.register.uint16_1 = (ushort)(value.register.uint16_1 * (ushort)(object)factor);
			result.register.uint16_2 = (ushort)(value.register.uint16_2 * (ushort)(object)factor);
			result.register.uint16_3 = (ushort)(value.register.uint16_3 * (ushort)(object)factor);
			result.register.uint16_4 = (ushort)(value.register.uint16_4 * (ushort)(object)factor);
			result.register.uint16_5 = (ushort)(value.register.uint16_5 * (ushort)(object)factor);
			result.register.uint16_6 = (ushort)(value.register.uint16_6 * (ushort)(object)factor);
			result.register.uint16_7 = (ushort)(value.register.uint16_7 * (ushort)(object)factor);
		}
		else if (typeof(T) == typeof(short))
		{
			result.register.int16_0 = (short)(value.register.int16_0 * (short)(object)factor);
			result.register.int16_1 = (short)(value.register.int16_1 * (short)(object)factor);
			result.register.int16_2 = (short)(value.register.int16_2 * (short)(object)factor);
			result.register.int16_3 = (short)(value.register.int16_3 * (short)(object)factor);
			result.register.int16_4 = (short)(value.register.int16_4 * (short)(object)factor);
			result.register.int16_5 = (short)(value.register.int16_5 * (short)(object)factor);
			result.register.int16_6 = (short)(value.register.int16_6 * (short)(object)factor);
			result.register.int16_7 = (short)(value.register.int16_7 * (short)(object)factor);
		}
		else if (typeof(T) == typeof(uint))
		{
			result.register.uint32_0 = value.register.uint32_0 * (uint)(object)factor;
			result.register.uint32_1 = value.register.uint32_1 * (uint)(object)factor;
			result.register.uint32_2 = value.register.uint32_2 * (uint)(object)factor;
			result.register.uint32_3 = value.register.uint32_3 * (uint)(object)factor;
		}
		else if (typeof(T) == typeof(int))
		{
			result.register.int32_0 = value.register.int32_0 * (int)(object)factor;
			result.register.int32_1 = value.register.int32_1 * (int)(object)factor;
			result.register.int32_2 = value.register.int32_2 * (int)(object)factor;
			result.register.int32_3 = value.register.int32_3 * (int)(object)factor;
		}
		else if (typeof(T) == typeof(ulong))
		{
			result.register.uint64_0 = value.register.uint64_0 * (ulong)(object)factor;
			result.register.uint64_1 = value.register.uint64_1 * (ulong)(object)factor;
		}
		else if (typeof(T) == typeof(long))
		{
			result.register.int64_0 = value.register.int64_0 * (long)(object)factor;
			result.register.int64_1 = value.register.int64_1 * (long)(object)factor;
		}
		else if (typeof(T) == typeof(float))
		{
			result.register.single_0 = value.register.single_0 * (float)(object)factor;
			result.register.single_1 = value.register.single_1 * (float)(object)factor;
			result.register.single_2 = value.register.single_2 * (float)(object)factor;
			result.register.single_3 = value.register.single_3 * (float)(object)factor;
		}
		else if (typeof(T) == typeof(double))
		{
			result.register.double_0 = value.register.double_0 * (double)(object)factor;
			result.register.double_1 = value.register.double_1 * (double)(object)factor;
		}
		return result;
	}

	public unsafe static Vector<T> operator /(Vector<T> left, Vector<T> right)
	{
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				byte* ptr = stackalloc byte[(int)(uint)Count];
				for (int i = 0; i < Count; i++)
				{
					ptr[i] = (byte)(object)ScalarDivide(left[i], right[i]);
				}
				return new Vector<T>(ptr);
			}
			if (typeof(T) == typeof(sbyte))
			{
				sbyte* ptr2 = stackalloc sbyte[(int)(uint)Count];
				for (int j = 0; j < Count; j++)
				{
					ptr2[j] = (sbyte)(object)ScalarDivide(left[j], right[j]);
				}
				return new Vector<T>(ptr2);
			}
			if (typeof(T) == typeof(ushort))
			{
				ushort* ptr3 = stackalloc ushort[Count];
				for (int k = 0; k < Count; k++)
				{
					ptr3[k] = (ushort)(object)ScalarDivide(left[k], right[k]);
				}
				return new Vector<T>(ptr3);
			}
			if (typeof(T) == typeof(short))
			{
				short* ptr4 = stackalloc short[Count];
				for (int l = 0; l < Count; l++)
				{
					ptr4[l] = (short)(object)ScalarDivide(left[l], right[l]);
				}
				return new Vector<T>(ptr4);
			}
			if (typeof(T) == typeof(uint))
			{
				uint* ptr5 = stackalloc uint[Count];
				for (int m = 0; m < Count; m++)
				{
					ptr5[m] = (uint)(object)ScalarDivide(left[m], right[m]);
				}
				return new Vector<T>(ptr5);
			}
			if (typeof(T) == typeof(int))
			{
				int* ptr6 = stackalloc int[Count];
				for (int n = 0; n < Count; n++)
				{
					ptr6[n] = (int)(object)ScalarDivide(left[n], right[n]);
				}
				return new Vector<T>(ptr6);
			}
			if (typeof(T) == typeof(ulong))
			{
				ulong* ptr7 = stackalloc ulong[Count];
				for (int num = 0; num < Count; num++)
				{
					ptr7[num] = (ulong)(object)ScalarDivide(left[num], right[num]);
				}
				return new Vector<T>(ptr7);
			}
			if (typeof(T) == typeof(long))
			{
				long* ptr8 = stackalloc long[Count];
				for (int num2 = 0; num2 < Count; num2++)
				{
					ptr8[num2] = (long)(object)ScalarDivide(left[num2], right[num2]);
				}
				return new Vector<T>(ptr8);
			}
			if (typeof(T) == typeof(float))
			{
				float* ptr9 = stackalloc float[Count];
				for (int num3 = 0; num3 < Count; num3++)
				{
					ptr9[num3] = (float)(object)ScalarDivide(left[num3], right[num3]);
				}
				return new Vector<T>(ptr9);
			}
			if (typeof(T) == typeof(double))
			{
				double* ptr10 = stackalloc double[Count];
				for (int num4 = 0; num4 < Count; num4++)
				{
					ptr10[num4] = (double)(object)ScalarDivide(left[num4], right[num4]);
				}
				return new Vector<T>(ptr10);
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
		Vector<T> result = default(Vector<T>);
		if (typeof(T) == typeof(byte))
		{
			result.register.byte_0 = (byte)(left.register.byte_0 / right.register.byte_0);
			result.register.byte_1 = (byte)(left.register.byte_1 / right.register.byte_1);
			result.register.byte_2 = (byte)(left.register.byte_2 / right.register.byte_2);
			result.register.byte_3 = (byte)(left.register.byte_3 / right.register.byte_3);
			result.register.byte_4 = (byte)(left.register.byte_4 / right.register.byte_4);
			result.register.byte_5 = (byte)(left.register.byte_5 / right.register.byte_5);
			result.register.byte_6 = (byte)(left.register.byte_6 / right.register.byte_6);
			result.register.byte_7 = (byte)(left.register.byte_7 / right.register.byte_7);
			result.register.byte_8 = (byte)(left.register.byte_8 / right.register.byte_8);
			result.register.byte_9 = (byte)(left.register.byte_9 / right.register.byte_9);
			result.register.byte_10 = (byte)(left.register.byte_10 / right.register.byte_10);
			result.register.byte_11 = (byte)(left.register.byte_11 / right.register.byte_11);
			result.register.byte_12 = (byte)(left.register.byte_12 / right.register.byte_12);
			result.register.byte_13 = (byte)(left.register.byte_13 / right.register.byte_13);
			result.register.byte_14 = (byte)(left.register.byte_14 / right.register.byte_14);
			result.register.byte_15 = (byte)(left.register.byte_15 / right.register.byte_15);
		}
		else if (typeof(T) == typeof(sbyte))
		{
			result.register.sbyte_0 = (sbyte)(left.register.sbyte_0 / right.register.sbyte_0);
			result.register.sbyte_1 = (sbyte)(left.register.sbyte_1 / right.register.sbyte_1);
			result.register.sbyte_2 = (sbyte)(left.register.sbyte_2 / right.register.sbyte_2);
			result.register.sbyte_3 = (sbyte)(left.register.sbyte_3 / right.register.sbyte_3);
			result.register.sbyte_4 = (sbyte)(left.register.sbyte_4 / right.register.sbyte_4);
			result.register.sbyte_5 = (sbyte)(left.register.sbyte_5 / right.register.sbyte_5);
			result.register.sbyte_6 = (sbyte)(left.register.sbyte_6 / right.register.sbyte_6);
			result.register.sbyte_7 = (sbyte)(left.register.sbyte_7 / right.register.sbyte_7);
			result.register.sbyte_8 = (sbyte)(left.register.sbyte_8 / right.register.sbyte_8);
			result.register.sbyte_9 = (sbyte)(left.register.sbyte_9 / right.register.sbyte_9);
			result.register.sbyte_10 = (sbyte)(left.register.sbyte_10 / right.register.sbyte_10);
			result.register.sbyte_11 = (sbyte)(left.register.sbyte_11 / right.register.sbyte_11);
			result.register.sbyte_12 = (sbyte)(left.register.sbyte_12 / right.register.sbyte_12);
			result.register.sbyte_13 = (sbyte)(left.register.sbyte_13 / right.register.sbyte_13);
			result.register.sbyte_14 = (sbyte)(left.register.sbyte_14 / right.register.sbyte_14);
			result.register.sbyte_15 = (sbyte)(left.register.sbyte_15 / right.register.sbyte_15);
		}
		else if (typeof(T) == typeof(ushort))
		{
			result.register.uint16_0 = (ushort)(left.register.uint16_0 / right.register.uint16_0);
			result.register.uint16_1 = (ushort)(left.register.uint16_1 / right.register.uint16_1);
			result.register.uint16_2 = (ushort)(left.register.uint16_2 / right.register.uint16_2);
			result.register.uint16_3 = (ushort)(left.register.uint16_3 / right.register.uint16_3);
			result.register.uint16_4 = (ushort)(left.register.uint16_4 / right.register.uint16_4);
			result.register.uint16_5 = (ushort)(left.register.uint16_5 / right.register.uint16_5);
			result.register.uint16_6 = (ushort)(left.register.uint16_6 / right.register.uint16_6);
			result.register.uint16_7 = (ushort)(left.register.uint16_7 / right.register.uint16_7);
		}
		else if (typeof(T) == typeof(short))
		{
			result.register.int16_0 = (short)(left.register.int16_0 / right.register.int16_0);
			result.register.int16_1 = (short)(left.register.int16_1 / right.register.int16_1);
			result.register.int16_2 = (short)(left.register.int16_2 / right.register.int16_2);
			result.register.int16_3 = (short)(left.register.int16_3 / right.register.int16_3);
			result.register.int16_4 = (short)(left.register.int16_4 / right.register.int16_4);
			result.register.int16_5 = (short)(left.register.int16_5 / right.register.int16_5);
			result.register.int16_6 = (short)(left.register.int16_6 / right.register.int16_6);
			result.register.int16_7 = (short)(left.register.int16_7 / right.register.int16_7);
		}
		else if (typeof(T) == typeof(uint))
		{
			result.register.uint32_0 = left.register.uint32_0 / right.register.uint32_0;
			result.register.uint32_1 = left.register.uint32_1 / right.register.uint32_1;
			result.register.uint32_2 = left.register.uint32_2 / right.register.uint32_2;
			result.register.uint32_3 = left.register.uint32_3 / right.register.uint32_3;
		}
		else if (typeof(T) == typeof(int))
		{
			result.register.int32_0 = left.register.int32_0 / right.register.int32_0;
			result.register.int32_1 = left.register.int32_1 / right.register.int32_1;
			result.register.int32_2 = left.register.int32_2 / right.register.int32_2;
			result.register.int32_3 = left.register.int32_3 / right.register.int32_3;
		}
		else if (typeof(T) == typeof(ulong))
		{
			result.register.uint64_0 = left.register.uint64_0 / right.register.uint64_0;
			result.register.uint64_1 = left.register.uint64_1 / right.register.uint64_1;
		}
		else if (typeof(T) == typeof(long))
		{
			result.register.int64_0 = left.register.int64_0 / right.register.int64_0;
			result.register.int64_1 = left.register.int64_1 / right.register.int64_1;
		}
		else if (typeof(T) == typeof(float))
		{
			result.register.single_0 = left.register.single_0 / right.register.single_0;
			result.register.single_1 = left.register.single_1 / right.register.single_1;
			result.register.single_2 = left.register.single_2 / right.register.single_2;
			result.register.single_3 = left.register.single_3 / right.register.single_3;
		}
		else if (typeof(T) == typeof(double))
		{
			result.register.double_0 = left.register.double_0 / right.register.double_0;
			result.register.double_1 = left.register.double_1 / right.register.double_1;
		}
		return result;
	}

	public static Vector<T> operator -(Vector<T> value)
	{
		return Zero - value;
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<T> operator &(Vector<T> left, Vector<T> right)
	{
		Vector<T> result = default(Vector<T>);
		if (Vector.IsHardwareAccelerated)
		{
			long* ptr = &result.register.int64_0;
			long* ptr2 = &left.register.int64_0;
			long* ptr3 = &right.register.int64_0;
			for (int i = 0; i < Vector<long>.Count; i++)
			{
				ptr[i] = ptr2[i] & ptr3[i];
			}
		}
		else
		{
			result.register.int64_0 = left.register.int64_0 & right.register.int64_0;
			result.register.int64_1 = left.register.int64_1 & right.register.int64_1;
		}
		return result;
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<T> operator |(Vector<T> left, Vector<T> right)
	{
		Vector<T> result = default(Vector<T>);
		if (Vector.IsHardwareAccelerated)
		{
			long* ptr = &result.register.int64_0;
			long* ptr2 = &left.register.int64_0;
			long* ptr3 = &right.register.int64_0;
			for (int i = 0; i < Vector<long>.Count; i++)
			{
				ptr[i] = ptr2[i] | ptr3[i];
			}
		}
		else
		{
			result.register.int64_0 = left.register.int64_0 | right.register.int64_0;
			result.register.int64_1 = left.register.int64_1 | right.register.int64_1;
		}
		return result;
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<T> operator ^(Vector<T> left, Vector<T> right)
	{
		Vector<T> result = default(Vector<T>);
		if (Vector.IsHardwareAccelerated)
		{
			long* ptr = &result.register.int64_0;
			long* ptr2 = &left.register.int64_0;
			long* ptr3 = &right.register.int64_0;
			for (int i = 0; i < Vector<long>.Count; i++)
			{
				ptr[i] = ptr2[i] ^ ptr3[i];
			}
		}
		else
		{
			result.register.int64_0 = left.register.int64_0 ^ right.register.int64_0;
			result.register.int64_1 = left.register.int64_1 ^ right.register.int64_1;
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> operator ~(Vector<T> value)
	{
		return s_allOnes ^ value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator ==(Vector<T> left, Vector<T> right)
	{
		return left.Equals(right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator !=(Vector<T> left, Vector<T> right)
	{
		return !(left == right);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public static explicit operator Vector<byte>(Vector<T> value)
	{
		return new Vector<byte>(ref value.register);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	[CLSCompliant(false)]
	public static explicit operator Vector<sbyte>(Vector<T> value)
	{
		return new Vector<sbyte>(ref value.register);
	}

	[CLSCompliant(false)]
	[System.Runtime.CompilerServices.Intrinsic]
	public static explicit operator Vector<ushort>(Vector<T> value)
	{
		return new Vector<ushort>(ref value.register);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public static explicit operator Vector<short>(Vector<T> value)
	{
		return new Vector<short>(ref value.register);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	[CLSCompliant(false)]
	public static explicit operator Vector<uint>(Vector<T> value)
	{
		return new Vector<uint>(ref value.register);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public static explicit operator Vector<int>(Vector<T> value)
	{
		return new Vector<int>(ref value.register);
	}

	[CLSCompliant(false)]
	[System.Runtime.CompilerServices.Intrinsic]
	public static explicit operator Vector<ulong>(Vector<T> value)
	{
		return new Vector<ulong>(ref value.register);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public static explicit operator Vector<long>(Vector<T> value)
	{
		return new Vector<long>(ref value.register);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public static explicit operator Vector<float>(Vector<T> value)
	{
		return new Vector<float>(ref value.register);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public static explicit operator Vector<double>(Vector<T> value)
	{
		return new Vector<double>(ref value.register);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.CompilerServices.Intrinsic]
	internal unsafe static Vector<T> Equals(Vector<T> left, Vector<T> right)
	{
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				byte* ptr = stackalloc byte[(int)(uint)Count];
				for (int i = 0; i < Count; i++)
				{
					ptr[i] = (byte)(ScalarEquals(left[i], right[i]) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr);
			}
			if (typeof(T) == typeof(sbyte))
			{
				sbyte* ptr2 = stackalloc sbyte[(int)(uint)Count];
				for (int j = 0; j < Count; j++)
				{
					ptr2[j] = (sbyte)(ScalarEquals(left[j], right[j]) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr2);
			}
			if (typeof(T) == typeof(ushort))
			{
				ushort* ptr3 = stackalloc ushort[Count];
				for (int k = 0; k < Count; k++)
				{
					ptr3[k] = (ushort)(ScalarEquals(left[k], right[k]) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr3);
			}
			if (typeof(T) == typeof(short))
			{
				short* ptr4 = stackalloc short[Count];
				for (int l = 0; l < Count; l++)
				{
					ptr4[l] = (short)(ScalarEquals(left[l], right[l]) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr4);
			}
			if (typeof(T) == typeof(uint))
			{
				uint* ptr5 = stackalloc uint[Count];
				for (int m = 0; m < Count; m++)
				{
					ptr5[m] = (ScalarEquals(left[m], right[m]) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
				}
				return new Vector<T>(ptr5);
			}
			if (typeof(T) == typeof(int))
			{
				int* ptr6 = stackalloc int[Count];
				for (int n = 0; n < Count; n++)
				{
					ptr6[n] = (ScalarEquals(left[n], right[n]) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr6);
			}
			if (typeof(T) == typeof(ulong))
			{
				ulong* ptr7 = stackalloc ulong[Count];
				for (int num = 0; num < Count; num++)
				{
					ptr7[num] = (ScalarEquals(left[num], right[num]) ? ConstantHelper.GetUInt64WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr7);
			}
			if (typeof(T) == typeof(long))
			{
				long* ptr8 = stackalloc long[Count];
				for (int num2 = 0; num2 < Count; num2++)
				{
					ptr8[num2] = (ScalarEquals(left[num2], right[num2]) ? ConstantHelper.GetInt64WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr8);
			}
			if (typeof(T) == typeof(float))
			{
				float* ptr9 = stackalloc float[Count];
				for (int num3 = 0; num3 < Count; num3++)
				{
					ptr9[num3] = (ScalarEquals(left[num3], right[num3]) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
				}
				return new Vector<T>(ptr9);
			}
			if (typeof(T) == typeof(double))
			{
				double* ptr10 = stackalloc double[Count];
				for (int num4 = 0; num4 < Count; num4++)
				{
					ptr10[num4] = (ScalarEquals(left[num4], right[num4]) ? ConstantHelper.GetDoubleWithAllBitsSet() : 0.0);
				}
				return new Vector<T>(ptr10);
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
		Register existingRegister = default(Register);
		if (typeof(T) == typeof(byte))
		{
			existingRegister.byte_0 = (byte)((left.register.byte_0 == right.register.byte_0) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_1 = (byte)((left.register.byte_1 == right.register.byte_1) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_2 = (byte)((left.register.byte_2 == right.register.byte_2) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_3 = (byte)((left.register.byte_3 == right.register.byte_3) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_4 = (byte)((left.register.byte_4 == right.register.byte_4) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_5 = (byte)((left.register.byte_5 == right.register.byte_5) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_6 = (byte)((left.register.byte_6 == right.register.byte_6) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_7 = (byte)((left.register.byte_7 == right.register.byte_7) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_8 = (byte)((left.register.byte_8 == right.register.byte_8) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_9 = (byte)((left.register.byte_9 == right.register.byte_9) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_10 = (byte)((left.register.byte_10 == right.register.byte_10) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_11 = (byte)((left.register.byte_11 == right.register.byte_11) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_12 = (byte)((left.register.byte_12 == right.register.byte_12) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_13 = (byte)((left.register.byte_13 == right.register.byte_13) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_14 = (byte)((left.register.byte_14 == right.register.byte_14) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_15 = (byte)((left.register.byte_15 == right.register.byte_15) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(sbyte))
		{
			existingRegister.sbyte_0 = (sbyte)((left.register.sbyte_0 == right.register.sbyte_0) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_1 = (sbyte)((left.register.sbyte_1 == right.register.sbyte_1) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_2 = (sbyte)((left.register.sbyte_2 == right.register.sbyte_2) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_3 = (sbyte)((left.register.sbyte_3 == right.register.sbyte_3) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_4 = (sbyte)((left.register.sbyte_4 == right.register.sbyte_4) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_5 = (sbyte)((left.register.sbyte_5 == right.register.sbyte_5) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_6 = (sbyte)((left.register.sbyte_6 == right.register.sbyte_6) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_7 = (sbyte)((left.register.sbyte_7 == right.register.sbyte_7) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_8 = (sbyte)((left.register.sbyte_8 == right.register.sbyte_8) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_9 = (sbyte)((left.register.sbyte_9 == right.register.sbyte_9) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_10 = (sbyte)((left.register.sbyte_10 == right.register.sbyte_10) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_11 = (sbyte)((left.register.sbyte_11 == right.register.sbyte_11) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_12 = (sbyte)((left.register.sbyte_12 == right.register.sbyte_12) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_13 = (sbyte)((left.register.sbyte_13 == right.register.sbyte_13) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_14 = (sbyte)((left.register.sbyte_14 == right.register.sbyte_14) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_15 = (sbyte)((left.register.sbyte_15 == right.register.sbyte_15) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(ushort))
		{
			existingRegister.uint16_0 = (ushort)((left.register.uint16_0 == right.register.uint16_0) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_1 = (ushort)((left.register.uint16_1 == right.register.uint16_1) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_2 = (ushort)((left.register.uint16_2 == right.register.uint16_2) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_3 = (ushort)((left.register.uint16_3 == right.register.uint16_3) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_4 = (ushort)((left.register.uint16_4 == right.register.uint16_4) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_5 = (ushort)((left.register.uint16_5 == right.register.uint16_5) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_6 = (ushort)((left.register.uint16_6 == right.register.uint16_6) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_7 = (ushort)((left.register.uint16_7 == right.register.uint16_7) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(short))
		{
			existingRegister.int16_0 = (short)((left.register.int16_0 == right.register.int16_0) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_1 = (short)((left.register.int16_1 == right.register.int16_1) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_2 = (short)((left.register.int16_2 == right.register.int16_2) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_3 = (short)((left.register.int16_3 == right.register.int16_3) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_4 = (short)((left.register.int16_4 == right.register.int16_4) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_5 = (short)((left.register.int16_5 == right.register.int16_5) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_6 = (short)((left.register.int16_6 == right.register.int16_6) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_7 = (short)((left.register.int16_7 == right.register.int16_7) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(uint))
		{
			existingRegister.uint32_0 = ((left.register.uint32_0 == right.register.uint32_0) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
			existingRegister.uint32_1 = ((left.register.uint32_1 == right.register.uint32_1) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
			existingRegister.uint32_2 = ((left.register.uint32_2 == right.register.uint32_2) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
			existingRegister.uint32_3 = ((left.register.uint32_3 == right.register.uint32_3) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(int))
		{
			existingRegister.int32_0 = ((left.register.int32_0 == right.register.int32_0) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
			existingRegister.int32_1 = ((left.register.int32_1 == right.register.int32_1) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
			existingRegister.int32_2 = ((left.register.int32_2 == right.register.int32_2) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
			existingRegister.int32_3 = ((left.register.int32_3 == right.register.int32_3) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(ulong))
		{
			existingRegister.uint64_0 = ((left.register.uint64_0 == right.register.uint64_0) ? ConstantHelper.GetUInt64WithAllBitsSet() : 0);
			existingRegister.uint64_1 = ((left.register.uint64_1 == right.register.uint64_1) ? ConstantHelper.GetUInt64WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(long))
		{
			existingRegister.int64_0 = ((left.register.int64_0 == right.register.int64_0) ? ConstantHelper.GetInt64WithAllBitsSet() : 0);
			existingRegister.int64_1 = ((left.register.int64_1 == right.register.int64_1) ? ConstantHelper.GetInt64WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(float))
		{
			existingRegister.single_0 = ((left.register.single_0 == right.register.single_0) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
			existingRegister.single_1 = ((left.register.single_1 == right.register.single_1) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
			existingRegister.single_2 = ((left.register.single_2 == right.register.single_2) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
			existingRegister.single_3 = ((left.register.single_3 == right.register.single_3) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(double))
		{
			existingRegister.double_0 = ((left.register.double_0 == right.register.double_0) ? ConstantHelper.GetDoubleWithAllBitsSet() : 0.0);
			existingRegister.double_1 = ((left.register.double_1 == right.register.double_1) ? ConstantHelper.GetDoubleWithAllBitsSet() : 0.0);
			return new Vector<T>(ref existingRegister);
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.CompilerServices.Intrinsic]
	internal unsafe static Vector<T> LessThan(Vector<T> left, Vector<T> right)
	{
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				byte* ptr = stackalloc byte[(int)(uint)Count];
				for (int i = 0; i < Count; i++)
				{
					ptr[i] = (byte)(ScalarLessThan(left[i], right[i]) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr);
			}
			if (typeof(T) == typeof(sbyte))
			{
				sbyte* ptr2 = stackalloc sbyte[(int)(uint)Count];
				for (int j = 0; j < Count; j++)
				{
					ptr2[j] = (sbyte)(ScalarLessThan(left[j], right[j]) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr2);
			}
			if (typeof(T) == typeof(ushort))
			{
				ushort* ptr3 = stackalloc ushort[Count];
				for (int k = 0; k < Count; k++)
				{
					ptr3[k] = (ushort)(ScalarLessThan(left[k], right[k]) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr3);
			}
			if (typeof(T) == typeof(short))
			{
				short* ptr4 = stackalloc short[Count];
				for (int l = 0; l < Count; l++)
				{
					ptr4[l] = (short)(ScalarLessThan(left[l], right[l]) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr4);
			}
			if (typeof(T) == typeof(uint))
			{
				uint* ptr5 = stackalloc uint[Count];
				for (int m = 0; m < Count; m++)
				{
					ptr5[m] = (ScalarLessThan(left[m], right[m]) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
				}
				return new Vector<T>(ptr5);
			}
			if (typeof(T) == typeof(int))
			{
				int* ptr6 = stackalloc int[Count];
				for (int n = 0; n < Count; n++)
				{
					ptr6[n] = (ScalarLessThan(left[n], right[n]) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr6);
			}
			if (typeof(T) == typeof(ulong))
			{
				ulong* ptr7 = stackalloc ulong[Count];
				for (int num = 0; num < Count; num++)
				{
					ptr7[num] = (ScalarLessThan(left[num], right[num]) ? ConstantHelper.GetUInt64WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr7);
			}
			if (typeof(T) == typeof(long))
			{
				long* ptr8 = stackalloc long[Count];
				for (int num2 = 0; num2 < Count; num2++)
				{
					ptr8[num2] = (ScalarLessThan(left[num2], right[num2]) ? ConstantHelper.GetInt64WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr8);
			}
			if (typeof(T) == typeof(float))
			{
				float* ptr9 = stackalloc float[Count];
				for (int num3 = 0; num3 < Count; num3++)
				{
					ptr9[num3] = (ScalarLessThan(left[num3], right[num3]) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
				}
				return new Vector<T>(ptr9);
			}
			if (typeof(T) == typeof(double))
			{
				double* ptr10 = stackalloc double[Count];
				for (int num4 = 0; num4 < Count; num4++)
				{
					ptr10[num4] = (ScalarLessThan(left[num4], right[num4]) ? ConstantHelper.GetDoubleWithAllBitsSet() : 0.0);
				}
				return new Vector<T>(ptr10);
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
		Register existingRegister = default(Register);
		if (typeof(T) == typeof(byte))
		{
			existingRegister.byte_0 = (byte)((left.register.byte_0 < right.register.byte_0) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_1 = (byte)((left.register.byte_1 < right.register.byte_1) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_2 = (byte)((left.register.byte_2 < right.register.byte_2) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_3 = (byte)((left.register.byte_3 < right.register.byte_3) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_4 = (byte)((left.register.byte_4 < right.register.byte_4) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_5 = (byte)((left.register.byte_5 < right.register.byte_5) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_6 = (byte)((left.register.byte_6 < right.register.byte_6) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_7 = (byte)((left.register.byte_7 < right.register.byte_7) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_8 = (byte)((left.register.byte_8 < right.register.byte_8) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_9 = (byte)((left.register.byte_9 < right.register.byte_9) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_10 = (byte)((left.register.byte_10 < right.register.byte_10) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_11 = (byte)((left.register.byte_11 < right.register.byte_11) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_12 = (byte)((left.register.byte_12 < right.register.byte_12) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_13 = (byte)((left.register.byte_13 < right.register.byte_13) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_14 = (byte)((left.register.byte_14 < right.register.byte_14) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_15 = (byte)((left.register.byte_15 < right.register.byte_15) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(sbyte))
		{
			existingRegister.sbyte_0 = (sbyte)((left.register.sbyte_0 < right.register.sbyte_0) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_1 = (sbyte)((left.register.sbyte_1 < right.register.sbyte_1) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_2 = (sbyte)((left.register.sbyte_2 < right.register.sbyte_2) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_3 = (sbyte)((left.register.sbyte_3 < right.register.sbyte_3) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_4 = (sbyte)((left.register.sbyte_4 < right.register.sbyte_4) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_5 = (sbyte)((left.register.sbyte_5 < right.register.sbyte_5) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_6 = (sbyte)((left.register.sbyte_6 < right.register.sbyte_6) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_7 = (sbyte)((left.register.sbyte_7 < right.register.sbyte_7) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_8 = (sbyte)((left.register.sbyte_8 < right.register.sbyte_8) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_9 = (sbyte)((left.register.sbyte_9 < right.register.sbyte_9) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_10 = (sbyte)((left.register.sbyte_10 < right.register.sbyte_10) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_11 = (sbyte)((left.register.sbyte_11 < right.register.sbyte_11) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_12 = (sbyte)((left.register.sbyte_12 < right.register.sbyte_12) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_13 = (sbyte)((left.register.sbyte_13 < right.register.sbyte_13) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_14 = (sbyte)((left.register.sbyte_14 < right.register.sbyte_14) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_15 = (sbyte)((left.register.sbyte_15 < right.register.sbyte_15) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(ushort))
		{
			existingRegister.uint16_0 = (ushort)((left.register.uint16_0 < right.register.uint16_0) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_1 = (ushort)((left.register.uint16_1 < right.register.uint16_1) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_2 = (ushort)((left.register.uint16_2 < right.register.uint16_2) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_3 = (ushort)((left.register.uint16_3 < right.register.uint16_3) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_4 = (ushort)((left.register.uint16_4 < right.register.uint16_4) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_5 = (ushort)((left.register.uint16_5 < right.register.uint16_5) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_6 = (ushort)((left.register.uint16_6 < right.register.uint16_6) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_7 = (ushort)((left.register.uint16_7 < right.register.uint16_7) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(short))
		{
			existingRegister.int16_0 = (short)((left.register.int16_0 < right.register.int16_0) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_1 = (short)((left.register.int16_1 < right.register.int16_1) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_2 = (short)((left.register.int16_2 < right.register.int16_2) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_3 = (short)((left.register.int16_3 < right.register.int16_3) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_4 = (short)((left.register.int16_4 < right.register.int16_4) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_5 = (short)((left.register.int16_5 < right.register.int16_5) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_6 = (short)((left.register.int16_6 < right.register.int16_6) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_7 = (short)((left.register.int16_7 < right.register.int16_7) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(uint))
		{
			existingRegister.uint32_0 = ((left.register.uint32_0 < right.register.uint32_0) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
			existingRegister.uint32_1 = ((left.register.uint32_1 < right.register.uint32_1) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
			existingRegister.uint32_2 = ((left.register.uint32_2 < right.register.uint32_2) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
			existingRegister.uint32_3 = ((left.register.uint32_3 < right.register.uint32_3) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(int))
		{
			existingRegister.int32_0 = ((left.register.int32_0 < right.register.int32_0) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
			existingRegister.int32_1 = ((left.register.int32_1 < right.register.int32_1) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
			existingRegister.int32_2 = ((left.register.int32_2 < right.register.int32_2) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
			existingRegister.int32_3 = ((left.register.int32_3 < right.register.int32_3) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(ulong))
		{
			existingRegister.uint64_0 = ((left.register.uint64_0 < right.register.uint64_0) ? ConstantHelper.GetUInt64WithAllBitsSet() : 0);
			existingRegister.uint64_1 = ((left.register.uint64_1 < right.register.uint64_1) ? ConstantHelper.GetUInt64WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(long))
		{
			existingRegister.int64_0 = ((left.register.int64_0 < right.register.int64_0) ? ConstantHelper.GetInt64WithAllBitsSet() : 0);
			existingRegister.int64_1 = ((left.register.int64_1 < right.register.int64_1) ? ConstantHelper.GetInt64WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(float))
		{
			existingRegister.single_0 = ((left.register.single_0 < right.register.single_0) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
			existingRegister.single_1 = ((left.register.single_1 < right.register.single_1) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
			existingRegister.single_2 = ((left.register.single_2 < right.register.single_2) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
			existingRegister.single_3 = ((left.register.single_3 < right.register.single_3) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(double))
		{
			existingRegister.double_0 = ((left.register.double_0 < right.register.double_0) ? ConstantHelper.GetDoubleWithAllBitsSet() : 0.0);
			existingRegister.double_1 = ((left.register.double_1 < right.register.double_1) ? ConstantHelper.GetDoubleWithAllBitsSet() : 0.0);
			return new Vector<T>(ref existingRegister);
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.CompilerServices.Intrinsic]
	internal unsafe static Vector<T> GreaterThan(Vector<T> left, Vector<T> right)
	{
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				byte* ptr = stackalloc byte[(int)(uint)Count];
				for (int i = 0; i < Count; i++)
				{
					ptr[i] = (byte)(ScalarGreaterThan(left[i], right[i]) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr);
			}
			if (typeof(T) == typeof(sbyte))
			{
				sbyte* ptr2 = stackalloc sbyte[(int)(uint)Count];
				for (int j = 0; j < Count; j++)
				{
					ptr2[j] = (sbyte)(ScalarGreaterThan(left[j], right[j]) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr2);
			}
			if (typeof(T) == typeof(ushort))
			{
				ushort* ptr3 = stackalloc ushort[Count];
				for (int k = 0; k < Count; k++)
				{
					ptr3[k] = (ushort)(ScalarGreaterThan(left[k], right[k]) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr3);
			}
			if (typeof(T) == typeof(short))
			{
				short* ptr4 = stackalloc short[Count];
				for (int l = 0; l < Count; l++)
				{
					ptr4[l] = (short)(ScalarGreaterThan(left[l], right[l]) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr4);
			}
			if (typeof(T) == typeof(uint))
			{
				uint* ptr5 = stackalloc uint[Count];
				for (int m = 0; m < Count; m++)
				{
					ptr5[m] = (ScalarGreaterThan(left[m], right[m]) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
				}
				return new Vector<T>(ptr5);
			}
			if (typeof(T) == typeof(int))
			{
				int* ptr6 = stackalloc int[Count];
				for (int n = 0; n < Count; n++)
				{
					ptr6[n] = (ScalarGreaterThan(left[n], right[n]) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr6);
			}
			if (typeof(T) == typeof(ulong))
			{
				ulong* ptr7 = stackalloc ulong[Count];
				for (int num = 0; num < Count; num++)
				{
					ptr7[num] = (ScalarGreaterThan(left[num], right[num]) ? ConstantHelper.GetUInt64WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr7);
			}
			if (typeof(T) == typeof(long))
			{
				long* ptr8 = stackalloc long[Count];
				for (int num2 = 0; num2 < Count; num2++)
				{
					ptr8[num2] = (ScalarGreaterThan(left[num2], right[num2]) ? ConstantHelper.GetInt64WithAllBitsSet() : 0);
				}
				return new Vector<T>(ptr8);
			}
			if (typeof(T) == typeof(float))
			{
				float* ptr9 = stackalloc float[Count];
				for (int num3 = 0; num3 < Count; num3++)
				{
					ptr9[num3] = (ScalarGreaterThan(left[num3], right[num3]) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
				}
				return new Vector<T>(ptr9);
			}
			if (typeof(T) == typeof(double))
			{
				double* ptr10 = stackalloc double[Count];
				for (int num4 = 0; num4 < Count; num4++)
				{
					ptr10[num4] = (ScalarGreaterThan(left[num4], right[num4]) ? ConstantHelper.GetDoubleWithAllBitsSet() : 0.0);
				}
				return new Vector<T>(ptr10);
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
		Register existingRegister = default(Register);
		if (typeof(T) == typeof(byte))
		{
			existingRegister.byte_0 = (byte)((left.register.byte_0 > right.register.byte_0) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_1 = (byte)((left.register.byte_1 > right.register.byte_1) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_2 = (byte)((left.register.byte_2 > right.register.byte_2) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_3 = (byte)((left.register.byte_3 > right.register.byte_3) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_4 = (byte)((left.register.byte_4 > right.register.byte_4) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_5 = (byte)((left.register.byte_5 > right.register.byte_5) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_6 = (byte)((left.register.byte_6 > right.register.byte_6) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_7 = (byte)((left.register.byte_7 > right.register.byte_7) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_8 = (byte)((left.register.byte_8 > right.register.byte_8) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_9 = (byte)((left.register.byte_9 > right.register.byte_9) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_10 = (byte)((left.register.byte_10 > right.register.byte_10) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_11 = (byte)((left.register.byte_11 > right.register.byte_11) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_12 = (byte)((left.register.byte_12 > right.register.byte_12) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_13 = (byte)((left.register.byte_13 > right.register.byte_13) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_14 = (byte)((left.register.byte_14 > right.register.byte_14) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			existingRegister.byte_15 = (byte)((left.register.byte_15 > right.register.byte_15) ? ConstantHelper.GetByteWithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(sbyte))
		{
			existingRegister.sbyte_0 = (sbyte)((left.register.sbyte_0 > right.register.sbyte_0) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_1 = (sbyte)((left.register.sbyte_1 > right.register.sbyte_1) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_2 = (sbyte)((left.register.sbyte_2 > right.register.sbyte_2) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_3 = (sbyte)((left.register.sbyte_3 > right.register.sbyte_3) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_4 = (sbyte)((left.register.sbyte_4 > right.register.sbyte_4) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_5 = (sbyte)((left.register.sbyte_5 > right.register.sbyte_5) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_6 = (sbyte)((left.register.sbyte_6 > right.register.sbyte_6) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_7 = (sbyte)((left.register.sbyte_7 > right.register.sbyte_7) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_8 = (sbyte)((left.register.sbyte_8 > right.register.sbyte_8) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_9 = (sbyte)((left.register.sbyte_9 > right.register.sbyte_9) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_10 = (sbyte)((left.register.sbyte_10 > right.register.sbyte_10) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_11 = (sbyte)((left.register.sbyte_11 > right.register.sbyte_11) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_12 = (sbyte)((left.register.sbyte_12 > right.register.sbyte_12) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_13 = (sbyte)((left.register.sbyte_13 > right.register.sbyte_13) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_14 = (sbyte)((left.register.sbyte_14 > right.register.sbyte_14) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			existingRegister.sbyte_15 = (sbyte)((left.register.sbyte_15 > right.register.sbyte_15) ? ConstantHelper.GetSByteWithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(ushort))
		{
			existingRegister.uint16_0 = (ushort)((left.register.uint16_0 > right.register.uint16_0) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_1 = (ushort)((left.register.uint16_1 > right.register.uint16_1) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_2 = (ushort)((left.register.uint16_2 > right.register.uint16_2) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_3 = (ushort)((left.register.uint16_3 > right.register.uint16_3) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_4 = (ushort)((left.register.uint16_4 > right.register.uint16_4) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_5 = (ushort)((left.register.uint16_5 > right.register.uint16_5) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_6 = (ushort)((left.register.uint16_6 > right.register.uint16_6) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			existingRegister.uint16_7 = (ushort)((left.register.uint16_7 > right.register.uint16_7) ? ConstantHelper.GetUInt16WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(short))
		{
			existingRegister.int16_0 = (short)((left.register.int16_0 > right.register.int16_0) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_1 = (short)((left.register.int16_1 > right.register.int16_1) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_2 = (short)((left.register.int16_2 > right.register.int16_2) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_3 = (short)((left.register.int16_3 > right.register.int16_3) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_4 = (short)((left.register.int16_4 > right.register.int16_4) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_5 = (short)((left.register.int16_5 > right.register.int16_5) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_6 = (short)((left.register.int16_6 > right.register.int16_6) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			existingRegister.int16_7 = (short)((left.register.int16_7 > right.register.int16_7) ? ConstantHelper.GetInt16WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(uint))
		{
			existingRegister.uint32_0 = ((left.register.uint32_0 > right.register.uint32_0) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
			existingRegister.uint32_1 = ((left.register.uint32_1 > right.register.uint32_1) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
			existingRegister.uint32_2 = ((left.register.uint32_2 > right.register.uint32_2) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
			existingRegister.uint32_3 = ((left.register.uint32_3 > right.register.uint32_3) ? ConstantHelper.GetUInt32WithAllBitsSet() : 0u);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(int))
		{
			existingRegister.int32_0 = ((left.register.int32_0 > right.register.int32_0) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
			existingRegister.int32_1 = ((left.register.int32_1 > right.register.int32_1) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
			existingRegister.int32_2 = ((left.register.int32_2 > right.register.int32_2) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
			existingRegister.int32_3 = ((left.register.int32_3 > right.register.int32_3) ? ConstantHelper.GetInt32WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(ulong))
		{
			existingRegister.uint64_0 = ((left.register.uint64_0 > right.register.uint64_0) ? ConstantHelper.GetUInt64WithAllBitsSet() : 0);
			existingRegister.uint64_1 = ((left.register.uint64_1 > right.register.uint64_1) ? ConstantHelper.GetUInt64WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(long))
		{
			existingRegister.int64_0 = ((left.register.int64_0 > right.register.int64_0) ? ConstantHelper.GetInt64WithAllBitsSet() : 0);
			existingRegister.int64_1 = ((left.register.int64_1 > right.register.int64_1) ? ConstantHelper.GetInt64WithAllBitsSet() : 0);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(float))
		{
			existingRegister.single_0 = ((left.register.single_0 > right.register.single_0) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
			existingRegister.single_1 = ((left.register.single_1 > right.register.single_1) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
			existingRegister.single_2 = ((left.register.single_2 > right.register.single_2) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
			existingRegister.single_3 = ((left.register.single_3 > right.register.single_3) ? ConstantHelper.GetSingleWithAllBitsSet() : 0f);
			return new Vector<T>(ref existingRegister);
		}
		if (typeof(T) == typeof(double))
		{
			existingRegister.double_0 = ((left.register.double_0 > right.register.double_0) ? ConstantHelper.GetDoubleWithAllBitsSet() : 0.0);
			existingRegister.double_1 = ((left.register.double_1 > right.register.double_1) ? ConstantHelper.GetDoubleWithAllBitsSet() : 0.0);
			return new Vector<T>(ref existingRegister);
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	internal static Vector<T> GreaterThanOrEqual(Vector<T> left, Vector<T> right)
	{
		return Equals(left, right) | GreaterThan(left, right);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	internal static Vector<T> LessThanOrEqual(Vector<T> left, Vector<T> right)
	{
		return Equals(left, right) | LessThan(left, right);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	internal static Vector<T> ConditionalSelect(Vector<T> condition, Vector<T> left, Vector<T> right)
	{
		return (left & condition) | Vector.AndNot(right, condition);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	internal unsafe static Vector<T> Abs(Vector<T> value)
	{
		if (typeof(T) == typeof(byte))
		{
			return value;
		}
		if (typeof(T) == typeof(ushort))
		{
			return value;
		}
		if (typeof(T) == typeof(uint))
		{
			return value;
		}
		if (typeof(T) == typeof(ulong))
		{
			return value;
		}
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(sbyte))
			{
				sbyte* ptr = stackalloc sbyte[(int)(uint)Count];
				for (int i = 0; i < Count; i++)
				{
					ptr[i] = (sbyte)(object)Math.Abs((sbyte)(object)value[i]);
				}
				return new Vector<T>(ptr);
			}
			if (typeof(T) == typeof(short))
			{
				short* ptr2 = stackalloc short[Count];
				for (int j = 0; j < Count; j++)
				{
					ptr2[j] = (short)(object)Math.Abs((short)(object)value[j]);
				}
				return new Vector<T>(ptr2);
			}
			if (typeof(T) == typeof(int))
			{
				int* ptr3 = stackalloc int[Count];
				for (int k = 0; k < Count; k++)
				{
					ptr3[k] = (int)(object)Math.Abs((int)(object)value[k]);
				}
				return new Vector<T>(ptr3);
			}
			if (typeof(T) == typeof(long))
			{
				long* ptr4 = stackalloc long[Count];
				for (int l = 0; l < Count; l++)
				{
					ptr4[l] = (long)(object)Math.Abs((long)(object)value[l]);
				}
				return new Vector<T>(ptr4);
			}
			if (typeof(T) == typeof(float))
			{
				float* ptr5 = stackalloc float[Count];
				for (int m = 0; m < Count; m++)
				{
					ptr5[m] = (float)(object)Math.Abs((float)(object)value[m]);
				}
				return new Vector<T>(ptr5);
			}
			if (typeof(T) == typeof(double))
			{
				double* ptr6 = stackalloc double[Count];
				for (int n = 0; n < Count; n++)
				{
					ptr6[n] = (double)(object)Math.Abs((double)(object)value[n]);
				}
				return new Vector<T>(ptr6);
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
		if (typeof(T) == typeof(sbyte))
		{
			value.register.sbyte_0 = Math.Abs(value.register.sbyte_0);
			value.register.sbyte_1 = Math.Abs(value.register.sbyte_1);
			value.register.sbyte_2 = Math.Abs(value.register.sbyte_2);
			value.register.sbyte_3 = Math.Abs(value.register.sbyte_3);
			value.register.sbyte_4 = Math.Abs(value.register.sbyte_4);
			value.register.sbyte_5 = Math.Abs(value.register.sbyte_5);
			value.register.sbyte_6 = Math.Abs(value.register.sbyte_6);
			value.register.sbyte_7 = Math.Abs(value.register.sbyte_7);
			value.register.sbyte_8 = Math.Abs(value.register.sbyte_8);
			value.register.sbyte_9 = Math.Abs(value.register.sbyte_9);
			value.register.sbyte_10 = Math.Abs(value.register.sbyte_10);
			value.register.sbyte_11 = Math.Abs(value.register.sbyte_11);
			value.register.sbyte_12 = Math.Abs(value.register.sbyte_12);
			value.register.sbyte_13 = Math.Abs(value.register.sbyte_13);
			value.register.sbyte_14 = Math.Abs(value.register.sbyte_14);
			value.register.sbyte_15 = Math.Abs(value.register.sbyte_15);
			return value;
		}
		if (typeof(T) == typeof(short))
		{
			value.register.int16_0 = Math.Abs(value.register.int16_0);
			value.register.int16_1 = Math.Abs(value.register.int16_1);
			value.register.int16_2 = Math.Abs(value.register.int16_2);
			value.register.int16_3 = Math.Abs(value.register.int16_3);
			value.register.int16_4 = Math.Abs(value.register.int16_4);
			value.register.int16_5 = Math.Abs(value.register.int16_5);
			value.register.int16_6 = Math.Abs(value.register.int16_6);
			value.register.int16_7 = Math.Abs(value.register.int16_7);
			return value;
		}
		if (typeof(T) == typeof(int))
		{
			value.register.int32_0 = Math.Abs(value.register.int32_0);
			value.register.int32_1 = Math.Abs(value.register.int32_1);
			value.register.int32_2 = Math.Abs(value.register.int32_2);
			value.register.int32_3 = Math.Abs(value.register.int32_3);
			return value;
		}
		if (typeof(T) == typeof(long))
		{
			value.register.int64_0 = Math.Abs(value.register.int64_0);
			value.register.int64_1 = Math.Abs(value.register.int64_1);
			return value;
		}
		if (typeof(T) == typeof(float))
		{
			value.register.single_0 = Math.Abs(value.register.single_0);
			value.register.single_1 = Math.Abs(value.register.single_1);
			value.register.single_2 = Math.Abs(value.register.single_2);
			value.register.single_3 = Math.Abs(value.register.single_3);
			return value;
		}
		if (typeof(T) == typeof(double))
		{
			value.register.double_0 = Math.Abs(value.register.double_0);
			value.register.double_1 = Math.Abs(value.register.double_1);
			return value;
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	internal unsafe static Vector<T> Min(Vector<T> left, Vector<T> right)
	{
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				byte* ptr = stackalloc byte[(int)(uint)Count];
				for (int i = 0; i < Count; i++)
				{
					ptr[i] = (ScalarLessThan(left[i], right[i]) ? ((byte)(object)left[i]) : ((byte)(object)right[i]));
				}
				return new Vector<T>(ptr);
			}
			if (typeof(T) == typeof(sbyte))
			{
				sbyte* ptr2 = stackalloc sbyte[(int)(uint)Count];
				for (int j = 0; j < Count; j++)
				{
					ptr2[j] = (ScalarLessThan(left[j], right[j]) ? ((sbyte)(object)left[j]) : ((sbyte)(object)right[j]));
				}
				return new Vector<T>(ptr2);
			}
			if (typeof(T) == typeof(ushort))
			{
				ushort* ptr3 = stackalloc ushort[Count];
				for (int k = 0; k < Count; k++)
				{
					ptr3[k] = (ScalarLessThan(left[k], right[k]) ? ((ushort)(object)left[k]) : ((ushort)(object)right[k]));
				}
				return new Vector<T>(ptr3);
			}
			if (typeof(T) == typeof(short))
			{
				short* ptr4 = stackalloc short[Count];
				for (int l = 0; l < Count; l++)
				{
					ptr4[l] = (ScalarLessThan(left[l], right[l]) ? ((short)(object)left[l]) : ((short)(object)right[l]));
				}
				return new Vector<T>(ptr4);
			}
			if (typeof(T) == typeof(uint))
			{
				uint* ptr5 = stackalloc uint[Count];
				for (int m = 0; m < Count; m++)
				{
					ptr5[m] = (ScalarLessThan(left[m], right[m]) ? ((uint)(object)left[m]) : ((uint)(object)right[m]));
				}
				return new Vector<T>(ptr5);
			}
			if (typeof(T) == typeof(int))
			{
				int* ptr6 = stackalloc int[Count];
				for (int n = 0; n < Count; n++)
				{
					ptr6[n] = (ScalarLessThan(left[n], right[n]) ? ((int)(object)left[n]) : ((int)(object)right[n]));
				}
				return new Vector<T>(ptr6);
			}
			if (typeof(T) == typeof(ulong))
			{
				ulong* ptr7 = stackalloc ulong[Count];
				for (int num = 0; num < Count; num++)
				{
					ptr7[num] = (ScalarLessThan(left[num], right[num]) ? ((ulong)(object)left[num]) : ((ulong)(object)right[num]));
				}
				return new Vector<T>(ptr7);
			}
			if (typeof(T) == typeof(long))
			{
				long* ptr8 = stackalloc long[Count];
				for (int num2 = 0; num2 < Count; num2++)
				{
					ptr8[num2] = (ScalarLessThan(left[num2], right[num2]) ? ((long)(object)left[num2]) : ((long)(object)right[num2]));
				}
				return new Vector<T>(ptr8);
			}
			if (typeof(T) == typeof(float))
			{
				float* ptr9 = stackalloc float[Count];
				for (int num3 = 0; num3 < Count; num3++)
				{
					ptr9[num3] = (ScalarLessThan(left[num3], right[num3]) ? ((float)(object)left[num3]) : ((float)(object)right[num3]));
				}
				return new Vector<T>(ptr9);
			}
			if (typeof(T) == typeof(double))
			{
				double* ptr10 = stackalloc double[Count];
				for (int num4 = 0; num4 < Count; num4++)
				{
					ptr10[num4] = (ScalarLessThan(left[num4], right[num4]) ? ((double)(object)left[num4]) : ((double)(object)right[num4]));
				}
				return new Vector<T>(ptr10);
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
		Vector<T> result = default(Vector<T>);
		if (typeof(T) == typeof(byte))
		{
			result.register.byte_0 = ((left.register.byte_0 < right.register.byte_0) ? left.register.byte_0 : right.register.byte_0);
			result.register.byte_1 = ((left.register.byte_1 < right.register.byte_1) ? left.register.byte_1 : right.register.byte_1);
			result.register.byte_2 = ((left.register.byte_2 < right.register.byte_2) ? left.register.byte_2 : right.register.byte_2);
			result.register.byte_3 = ((left.register.byte_3 < right.register.byte_3) ? left.register.byte_3 : right.register.byte_3);
			result.register.byte_4 = ((left.register.byte_4 < right.register.byte_4) ? left.register.byte_4 : right.register.byte_4);
			result.register.byte_5 = ((left.register.byte_5 < right.register.byte_5) ? left.register.byte_5 : right.register.byte_5);
			result.register.byte_6 = ((left.register.byte_6 < right.register.byte_6) ? left.register.byte_6 : right.register.byte_6);
			result.register.byte_7 = ((left.register.byte_7 < right.register.byte_7) ? left.register.byte_7 : right.register.byte_7);
			result.register.byte_8 = ((left.register.byte_8 < right.register.byte_8) ? left.register.byte_8 : right.register.byte_8);
			result.register.byte_9 = ((left.register.byte_9 < right.register.byte_9) ? left.register.byte_9 : right.register.byte_9);
			result.register.byte_10 = ((left.register.byte_10 < right.register.byte_10) ? left.register.byte_10 : right.register.byte_10);
			result.register.byte_11 = ((left.register.byte_11 < right.register.byte_11) ? left.register.byte_11 : right.register.byte_11);
			result.register.byte_12 = ((left.register.byte_12 < right.register.byte_12) ? left.register.byte_12 : right.register.byte_12);
			result.register.byte_13 = ((left.register.byte_13 < right.register.byte_13) ? left.register.byte_13 : right.register.byte_13);
			result.register.byte_14 = ((left.register.byte_14 < right.register.byte_14) ? left.register.byte_14 : right.register.byte_14);
			result.register.byte_15 = ((left.register.byte_15 < right.register.byte_15) ? left.register.byte_15 : right.register.byte_15);
			return result;
		}
		if (typeof(T) == typeof(sbyte))
		{
			result.register.sbyte_0 = ((left.register.sbyte_0 < right.register.sbyte_0) ? left.register.sbyte_0 : right.register.sbyte_0);
			result.register.sbyte_1 = ((left.register.sbyte_1 < right.register.sbyte_1) ? left.register.sbyte_1 : right.register.sbyte_1);
			result.register.sbyte_2 = ((left.register.sbyte_2 < right.register.sbyte_2) ? left.register.sbyte_2 : right.register.sbyte_2);
			result.register.sbyte_3 = ((left.register.sbyte_3 < right.register.sbyte_3) ? left.register.sbyte_3 : right.register.sbyte_3);
			result.register.sbyte_4 = ((left.register.sbyte_4 < right.register.sbyte_4) ? left.register.sbyte_4 : right.register.sbyte_4);
			result.register.sbyte_5 = ((left.register.sbyte_5 < right.register.sbyte_5) ? left.register.sbyte_5 : right.register.sbyte_5);
			result.register.sbyte_6 = ((left.register.sbyte_6 < right.register.sbyte_6) ? left.register.sbyte_6 : right.register.sbyte_6);
			result.register.sbyte_7 = ((left.register.sbyte_7 < right.register.sbyte_7) ? left.register.sbyte_7 : right.register.sbyte_7);
			result.register.sbyte_8 = ((left.register.sbyte_8 < right.register.sbyte_8) ? left.register.sbyte_8 : right.register.sbyte_8);
			result.register.sbyte_9 = ((left.register.sbyte_9 < right.register.sbyte_9) ? left.register.sbyte_9 : right.register.sbyte_9);
			result.register.sbyte_10 = ((left.register.sbyte_10 < right.register.sbyte_10) ? left.register.sbyte_10 : right.register.sbyte_10);
			result.register.sbyte_11 = ((left.register.sbyte_11 < right.register.sbyte_11) ? left.register.sbyte_11 : right.register.sbyte_11);
			result.register.sbyte_12 = ((left.register.sbyte_12 < right.register.sbyte_12) ? left.register.sbyte_12 : right.register.sbyte_12);
			result.register.sbyte_13 = ((left.register.sbyte_13 < right.register.sbyte_13) ? left.register.sbyte_13 : right.register.sbyte_13);
			result.register.sbyte_14 = ((left.register.sbyte_14 < right.register.sbyte_14) ? left.register.sbyte_14 : right.register.sbyte_14);
			result.register.sbyte_15 = ((left.register.sbyte_15 < right.register.sbyte_15) ? left.register.sbyte_15 : right.register.sbyte_15);
			return result;
		}
		if (typeof(T) == typeof(ushort))
		{
			result.register.uint16_0 = ((left.register.uint16_0 < right.register.uint16_0) ? left.register.uint16_0 : right.register.uint16_0);
			result.register.uint16_1 = ((left.register.uint16_1 < right.register.uint16_1) ? left.register.uint16_1 : right.register.uint16_1);
			result.register.uint16_2 = ((left.register.uint16_2 < right.register.uint16_2) ? left.register.uint16_2 : right.register.uint16_2);
			result.register.uint16_3 = ((left.register.uint16_3 < right.register.uint16_3) ? left.register.uint16_3 : right.register.uint16_3);
			result.register.uint16_4 = ((left.register.uint16_4 < right.register.uint16_4) ? left.register.uint16_4 : right.register.uint16_4);
			result.register.uint16_5 = ((left.register.uint16_5 < right.register.uint16_5) ? left.register.uint16_5 : right.register.uint16_5);
			result.register.uint16_6 = ((left.register.uint16_6 < right.register.uint16_6) ? left.register.uint16_6 : right.register.uint16_6);
			result.register.uint16_7 = ((left.register.uint16_7 < right.register.uint16_7) ? left.register.uint16_7 : right.register.uint16_7);
			return result;
		}
		if (typeof(T) == typeof(short))
		{
			result.register.int16_0 = ((left.register.int16_0 < right.register.int16_0) ? left.register.int16_0 : right.register.int16_0);
			result.register.int16_1 = ((left.register.int16_1 < right.register.int16_1) ? left.register.int16_1 : right.register.int16_1);
			result.register.int16_2 = ((left.register.int16_2 < right.register.int16_2) ? left.register.int16_2 : right.register.int16_2);
			result.register.int16_3 = ((left.register.int16_3 < right.register.int16_3) ? left.register.int16_3 : right.register.int16_3);
			result.register.int16_4 = ((left.register.int16_4 < right.register.int16_4) ? left.register.int16_4 : right.register.int16_4);
			result.register.int16_5 = ((left.register.int16_5 < right.register.int16_5) ? left.register.int16_5 : right.register.int16_5);
			result.register.int16_6 = ((left.register.int16_6 < right.register.int16_6) ? left.register.int16_6 : right.register.int16_6);
			result.register.int16_7 = ((left.register.int16_7 < right.register.int16_7) ? left.register.int16_7 : right.register.int16_7);
			return result;
		}
		if (typeof(T) == typeof(uint))
		{
			result.register.uint32_0 = ((left.register.uint32_0 < right.register.uint32_0) ? left.register.uint32_0 : right.register.uint32_0);
			result.register.uint32_1 = ((left.register.uint32_1 < right.register.uint32_1) ? left.register.uint32_1 : right.register.uint32_1);
			result.register.uint32_2 = ((left.register.uint32_2 < right.register.uint32_2) ? left.register.uint32_2 : right.register.uint32_2);
			result.register.uint32_3 = ((left.register.uint32_3 < right.register.uint32_3) ? left.register.uint32_3 : right.register.uint32_3);
			return result;
		}
		if (typeof(T) == typeof(int))
		{
			result.register.int32_0 = ((left.register.int32_0 < right.register.int32_0) ? left.register.int32_0 : right.register.int32_0);
			result.register.int32_1 = ((left.register.int32_1 < right.register.int32_1) ? left.register.int32_1 : right.register.int32_1);
			result.register.int32_2 = ((left.register.int32_2 < right.register.int32_2) ? left.register.int32_2 : right.register.int32_2);
			result.register.int32_3 = ((left.register.int32_3 < right.register.int32_3) ? left.register.int32_3 : right.register.int32_3);
			return result;
		}
		if (typeof(T) == typeof(ulong))
		{
			result.register.uint64_0 = ((left.register.uint64_0 < right.register.uint64_0) ? left.register.uint64_0 : right.register.uint64_0);
			result.register.uint64_1 = ((left.register.uint64_1 < right.register.uint64_1) ? left.register.uint64_1 : right.register.uint64_1);
			return result;
		}
		if (typeof(T) == typeof(long))
		{
			result.register.int64_0 = ((left.register.int64_0 < right.register.int64_0) ? left.register.int64_0 : right.register.int64_0);
			result.register.int64_1 = ((left.register.int64_1 < right.register.int64_1) ? left.register.int64_1 : right.register.int64_1);
			return result;
		}
		if (typeof(T) == typeof(float))
		{
			result.register.single_0 = ((left.register.single_0 < right.register.single_0) ? left.register.single_0 : right.register.single_0);
			result.register.single_1 = ((left.register.single_1 < right.register.single_1) ? left.register.single_1 : right.register.single_1);
			result.register.single_2 = ((left.register.single_2 < right.register.single_2) ? left.register.single_2 : right.register.single_2);
			result.register.single_3 = ((left.register.single_3 < right.register.single_3) ? left.register.single_3 : right.register.single_3);
			return result;
		}
		if (typeof(T) == typeof(double))
		{
			result.register.double_0 = ((left.register.double_0 < right.register.double_0) ? left.register.double_0 : right.register.double_0);
			result.register.double_1 = ((left.register.double_1 < right.register.double_1) ? left.register.double_1 : right.register.double_1);
			return result;
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	internal unsafe static Vector<T> Max(Vector<T> left, Vector<T> right)
	{
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				byte* ptr = stackalloc byte[(int)(uint)Count];
				for (int i = 0; i < Count; i++)
				{
					ptr[i] = (ScalarGreaterThan(left[i], right[i]) ? ((byte)(object)left[i]) : ((byte)(object)right[i]));
				}
				return new Vector<T>(ptr);
			}
			if (typeof(T) == typeof(sbyte))
			{
				sbyte* ptr2 = stackalloc sbyte[(int)(uint)Count];
				for (int j = 0; j < Count; j++)
				{
					ptr2[j] = (ScalarGreaterThan(left[j], right[j]) ? ((sbyte)(object)left[j]) : ((sbyte)(object)right[j]));
				}
				return new Vector<T>(ptr2);
			}
			if (typeof(T) == typeof(ushort))
			{
				ushort* ptr3 = stackalloc ushort[Count];
				for (int k = 0; k < Count; k++)
				{
					ptr3[k] = (ScalarGreaterThan(left[k], right[k]) ? ((ushort)(object)left[k]) : ((ushort)(object)right[k]));
				}
				return new Vector<T>(ptr3);
			}
			if (typeof(T) == typeof(short))
			{
				short* ptr4 = stackalloc short[Count];
				for (int l = 0; l < Count; l++)
				{
					ptr4[l] = (ScalarGreaterThan(left[l], right[l]) ? ((short)(object)left[l]) : ((short)(object)right[l]));
				}
				return new Vector<T>(ptr4);
			}
			if (typeof(T) == typeof(uint))
			{
				uint* ptr5 = stackalloc uint[Count];
				for (int m = 0; m < Count; m++)
				{
					ptr5[m] = (ScalarGreaterThan(left[m], right[m]) ? ((uint)(object)left[m]) : ((uint)(object)right[m]));
				}
				return new Vector<T>(ptr5);
			}
			if (typeof(T) == typeof(int))
			{
				int* ptr6 = stackalloc int[Count];
				for (int n = 0; n < Count; n++)
				{
					ptr6[n] = (ScalarGreaterThan(left[n], right[n]) ? ((int)(object)left[n]) : ((int)(object)right[n]));
				}
				return new Vector<T>(ptr6);
			}
			if (typeof(T) == typeof(ulong))
			{
				ulong* ptr7 = stackalloc ulong[Count];
				for (int num = 0; num < Count; num++)
				{
					ptr7[num] = (ScalarGreaterThan(left[num], right[num]) ? ((ulong)(object)left[num]) : ((ulong)(object)right[num]));
				}
				return new Vector<T>(ptr7);
			}
			if (typeof(T) == typeof(long))
			{
				long* ptr8 = stackalloc long[Count];
				for (int num2 = 0; num2 < Count; num2++)
				{
					ptr8[num2] = (ScalarGreaterThan(left[num2], right[num2]) ? ((long)(object)left[num2]) : ((long)(object)right[num2]));
				}
				return new Vector<T>(ptr8);
			}
			if (typeof(T) == typeof(float))
			{
				float* ptr9 = stackalloc float[Count];
				for (int num3 = 0; num3 < Count; num3++)
				{
					ptr9[num3] = (ScalarGreaterThan(left[num3], right[num3]) ? ((float)(object)left[num3]) : ((float)(object)right[num3]));
				}
				return new Vector<T>(ptr9);
			}
			if (typeof(T) == typeof(double))
			{
				double* ptr10 = stackalloc double[Count];
				for (int num4 = 0; num4 < Count; num4++)
				{
					ptr10[num4] = (ScalarGreaterThan(left[num4], right[num4]) ? ((double)(object)left[num4]) : ((double)(object)right[num4]));
				}
				return new Vector<T>(ptr10);
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
		Vector<T> result = default(Vector<T>);
		if (typeof(T) == typeof(byte))
		{
			result.register.byte_0 = ((left.register.byte_0 > right.register.byte_0) ? left.register.byte_0 : right.register.byte_0);
			result.register.byte_1 = ((left.register.byte_1 > right.register.byte_1) ? left.register.byte_1 : right.register.byte_1);
			result.register.byte_2 = ((left.register.byte_2 > right.register.byte_2) ? left.register.byte_2 : right.register.byte_2);
			result.register.byte_3 = ((left.register.byte_3 > right.register.byte_3) ? left.register.byte_3 : right.register.byte_3);
			result.register.byte_4 = ((left.register.byte_4 > right.register.byte_4) ? left.register.byte_4 : right.register.byte_4);
			result.register.byte_5 = ((left.register.byte_5 > right.register.byte_5) ? left.register.byte_5 : right.register.byte_5);
			result.register.byte_6 = ((left.register.byte_6 > right.register.byte_6) ? left.register.byte_6 : right.register.byte_6);
			result.register.byte_7 = ((left.register.byte_7 > right.register.byte_7) ? left.register.byte_7 : right.register.byte_7);
			result.register.byte_8 = ((left.register.byte_8 > right.register.byte_8) ? left.register.byte_8 : right.register.byte_8);
			result.register.byte_9 = ((left.register.byte_9 > right.register.byte_9) ? left.register.byte_9 : right.register.byte_9);
			result.register.byte_10 = ((left.register.byte_10 > right.register.byte_10) ? left.register.byte_10 : right.register.byte_10);
			result.register.byte_11 = ((left.register.byte_11 > right.register.byte_11) ? left.register.byte_11 : right.register.byte_11);
			result.register.byte_12 = ((left.register.byte_12 > right.register.byte_12) ? left.register.byte_12 : right.register.byte_12);
			result.register.byte_13 = ((left.register.byte_13 > right.register.byte_13) ? left.register.byte_13 : right.register.byte_13);
			result.register.byte_14 = ((left.register.byte_14 > right.register.byte_14) ? left.register.byte_14 : right.register.byte_14);
			result.register.byte_15 = ((left.register.byte_15 > right.register.byte_15) ? left.register.byte_15 : right.register.byte_15);
			return result;
		}
		if (typeof(T) == typeof(sbyte))
		{
			result.register.sbyte_0 = ((left.register.sbyte_0 > right.register.sbyte_0) ? left.register.sbyte_0 : right.register.sbyte_0);
			result.register.sbyte_1 = ((left.register.sbyte_1 > right.register.sbyte_1) ? left.register.sbyte_1 : right.register.sbyte_1);
			result.register.sbyte_2 = ((left.register.sbyte_2 > right.register.sbyte_2) ? left.register.sbyte_2 : right.register.sbyte_2);
			result.register.sbyte_3 = ((left.register.sbyte_3 > right.register.sbyte_3) ? left.register.sbyte_3 : right.register.sbyte_3);
			result.register.sbyte_4 = ((left.register.sbyte_4 > right.register.sbyte_4) ? left.register.sbyte_4 : right.register.sbyte_4);
			result.register.sbyte_5 = ((left.register.sbyte_5 > right.register.sbyte_5) ? left.register.sbyte_5 : right.register.sbyte_5);
			result.register.sbyte_6 = ((left.register.sbyte_6 > right.register.sbyte_6) ? left.register.sbyte_6 : right.register.sbyte_6);
			result.register.sbyte_7 = ((left.register.sbyte_7 > right.register.sbyte_7) ? left.register.sbyte_7 : right.register.sbyte_7);
			result.register.sbyte_8 = ((left.register.sbyte_8 > right.register.sbyte_8) ? left.register.sbyte_8 : right.register.sbyte_8);
			result.register.sbyte_9 = ((left.register.sbyte_9 > right.register.sbyte_9) ? left.register.sbyte_9 : right.register.sbyte_9);
			result.register.sbyte_10 = ((left.register.sbyte_10 > right.register.sbyte_10) ? left.register.sbyte_10 : right.register.sbyte_10);
			result.register.sbyte_11 = ((left.register.sbyte_11 > right.register.sbyte_11) ? left.register.sbyte_11 : right.register.sbyte_11);
			result.register.sbyte_12 = ((left.register.sbyte_12 > right.register.sbyte_12) ? left.register.sbyte_12 : right.register.sbyte_12);
			result.register.sbyte_13 = ((left.register.sbyte_13 > right.register.sbyte_13) ? left.register.sbyte_13 : right.register.sbyte_13);
			result.register.sbyte_14 = ((left.register.sbyte_14 > right.register.sbyte_14) ? left.register.sbyte_14 : right.register.sbyte_14);
			result.register.sbyte_15 = ((left.register.sbyte_15 > right.register.sbyte_15) ? left.register.sbyte_15 : right.register.sbyte_15);
			return result;
		}
		if (typeof(T) == typeof(ushort))
		{
			result.register.uint16_0 = ((left.register.uint16_0 > right.register.uint16_0) ? left.register.uint16_0 : right.register.uint16_0);
			result.register.uint16_1 = ((left.register.uint16_1 > right.register.uint16_1) ? left.register.uint16_1 : right.register.uint16_1);
			result.register.uint16_2 = ((left.register.uint16_2 > right.register.uint16_2) ? left.register.uint16_2 : right.register.uint16_2);
			result.register.uint16_3 = ((left.register.uint16_3 > right.register.uint16_3) ? left.register.uint16_3 : right.register.uint16_3);
			result.register.uint16_4 = ((left.register.uint16_4 > right.register.uint16_4) ? left.register.uint16_4 : right.register.uint16_4);
			result.register.uint16_5 = ((left.register.uint16_5 > right.register.uint16_5) ? left.register.uint16_5 : right.register.uint16_5);
			result.register.uint16_6 = ((left.register.uint16_6 > right.register.uint16_6) ? left.register.uint16_6 : right.register.uint16_6);
			result.register.uint16_7 = ((left.register.uint16_7 > right.register.uint16_7) ? left.register.uint16_7 : right.register.uint16_7);
			return result;
		}
		if (typeof(T) == typeof(short))
		{
			result.register.int16_0 = ((left.register.int16_0 > right.register.int16_0) ? left.register.int16_0 : right.register.int16_0);
			result.register.int16_1 = ((left.register.int16_1 > right.register.int16_1) ? left.register.int16_1 : right.register.int16_1);
			result.register.int16_2 = ((left.register.int16_2 > right.register.int16_2) ? left.register.int16_2 : right.register.int16_2);
			result.register.int16_3 = ((left.register.int16_3 > right.register.int16_3) ? left.register.int16_3 : right.register.int16_3);
			result.register.int16_4 = ((left.register.int16_4 > right.register.int16_4) ? left.register.int16_4 : right.register.int16_4);
			result.register.int16_5 = ((left.register.int16_5 > right.register.int16_5) ? left.register.int16_5 : right.register.int16_5);
			result.register.int16_6 = ((left.register.int16_6 > right.register.int16_6) ? left.register.int16_6 : right.register.int16_6);
			result.register.int16_7 = ((left.register.int16_7 > right.register.int16_7) ? left.register.int16_7 : right.register.int16_7);
			return result;
		}
		if (typeof(T) == typeof(uint))
		{
			result.register.uint32_0 = ((left.register.uint32_0 > right.register.uint32_0) ? left.register.uint32_0 : right.register.uint32_0);
			result.register.uint32_1 = ((left.register.uint32_1 > right.register.uint32_1) ? left.register.uint32_1 : right.register.uint32_1);
			result.register.uint32_2 = ((left.register.uint32_2 > right.register.uint32_2) ? left.register.uint32_2 : right.register.uint32_2);
			result.register.uint32_3 = ((left.register.uint32_3 > right.register.uint32_3) ? left.register.uint32_3 : right.register.uint32_3);
			return result;
		}
		if (typeof(T) == typeof(int))
		{
			result.register.int32_0 = ((left.register.int32_0 > right.register.int32_0) ? left.register.int32_0 : right.register.int32_0);
			result.register.int32_1 = ((left.register.int32_1 > right.register.int32_1) ? left.register.int32_1 : right.register.int32_1);
			result.register.int32_2 = ((left.register.int32_2 > right.register.int32_2) ? left.register.int32_2 : right.register.int32_2);
			result.register.int32_3 = ((left.register.int32_3 > right.register.int32_3) ? left.register.int32_3 : right.register.int32_3);
			return result;
		}
		if (typeof(T) == typeof(ulong))
		{
			result.register.uint64_0 = ((left.register.uint64_0 > right.register.uint64_0) ? left.register.uint64_0 : right.register.uint64_0);
			result.register.uint64_1 = ((left.register.uint64_1 > right.register.uint64_1) ? left.register.uint64_1 : right.register.uint64_1);
			return result;
		}
		if (typeof(T) == typeof(long))
		{
			result.register.int64_0 = ((left.register.int64_0 > right.register.int64_0) ? left.register.int64_0 : right.register.int64_0);
			result.register.int64_1 = ((left.register.int64_1 > right.register.int64_1) ? left.register.int64_1 : right.register.int64_1);
			return result;
		}
		if (typeof(T) == typeof(float))
		{
			result.register.single_0 = ((left.register.single_0 > right.register.single_0) ? left.register.single_0 : right.register.single_0);
			result.register.single_1 = ((left.register.single_1 > right.register.single_1) ? left.register.single_1 : right.register.single_1);
			result.register.single_2 = ((left.register.single_2 > right.register.single_2) ? left.register.single_2 : right.register.single_2);
			result.register.single_3 = ((left.register.single_3 > right.register.single_3) ? left.register.single_3 : right.register.single_3);
			return result;
		}
		if (typeof(T) == typeof(double))
		{
			result.register.double_0 = ((left.register.double_0 > right.register.double_0) ? left.register.double_0 : right.register.double_0);
			result.register.double_1 = ((left.register.double_1 > right.register.double_1) ? left.register.double_1 : right.register.double_1);
			return result;
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	internal static T DotProduct(Vector<T> left, Vector<T> right)
	{
		if (Vector.IsHardwareAccelerated)
		{
			T val = default(T);
			for (int i = 0; i < Count; i++)
			{
				val = ScalarAdd(val, ScalarMultiply(left[i], right[i]));
			}
			return val;
		}
		if (typeof(T) == typeof(byte))
		{
			byte b = 0;
			b += (byte)(left.register.byte_0 * right.register.byte_0);
			b += (byte)(left.register.byte_1 * right.register.byte_1);
			b += (byte)(left.register.byte_2 * right.register.byte_2);
			b += (byte)(left.register.byte_3 * right.register.byte_3);
			b += (byte)(left.register.byte_4 * right.register.byte_4);
			b += (byte)(left.register.byte_5 * right.register.byte_5);
			b += (byte)(left.register.byte_6 * right.register.byte_6);
			b += (byte)(left.register.byte_7 * right.register.byte_7);
			b += (byte)(left.register.byte_8 * right.register.byte_8);
			b += (byte)(left.register.byte_9 * right.register.byte_9);
			b += (byte)(left.register.byte_10 * right.register.byte_10);
			b += (byte)(left.register.byte_11 * right.register.byte_11);
			b += (byte)(left.register.byte_12 * right.register.byte_12);
			b += (byte)(left.register.byte_13 * right.register.byte_13);
			b += (byte)(left.register.byte_14 * right.register.byte_14);
			b += (byte)(left.register.byte_15 * right.register.byte_15);
			return (T)(object)b;
		}
		if (typeof(T) == typeof(sbyte))
		{
			sbyte b2 = 0;
			b2 += (sbyte)(left.register.sbyte_0 * right.register.sbyte_0);
			b2 += (sbyte)(left.register.sbyte_1 * right.register.sbyte_1);
			b2 += (sbyte)(left.register.sbyte_2 * right.register.sbyte_2);
			b2 += (sbyte)(left.register.sbyte_3 * right.register.sbyte_3);
			b2 += (sbyte)(left.register.sbyte_4 * right.register.sbyte_4);
			b2 += (sbyte)(left.register.sbyte_5 * right.register.sbyte_5);
			b2 += (sbyte)(left.register.sbyte_6 * right.register.sbyte_6);
			b2 += (sbyte)(left.register.sbyte_7 * right.register.sbyte_7);
			b2 += (sbyte)(left.register.sbyte_8 * right.register.sbyte_8);
			b2 += (sbyte)(left.register.sbyte_9 * right.register.sbyte_9);
			b2 += (sbyte)(left.register.sbyte_10 * right.register.sbyte_10);
			b2 += (sbyte)(left.register.sbyte_11 * right.register.sbyte_11);
			b2 += (sbyte)(left.register.sbyte_12 * right.register.sbyte_12);
			b2 += (sbyte)(left.register.sbyte_13 * right.register.sbyte_13);
			b2 += (sbyte)(left.register.sbyte_14 * right.register.sbyte_14);
			b2 += (sbyte)(left.register.sbyte_15 * right.register.sbyte_15);
			return (T)(object)b2;
		}
		if (typeof(T) == typeof(ushort))
		{
			ushort num = 0;
			num += (ushort)(left.register.uint16_0 * right.register.uint16_0);
			num += (ushort)(left.register.uint16_1 * right.register.uint16_1);
			num += (ushort)(left.register.uint16_2 * right.register.uint16_2);
			num += (ushort)(left.register.uint16_3 * right.register.uint16_3);
			num += (ushort)(left.register.uint16_4 * right.register.uint16_4);
			num += (ushort)(left.register.uint16_5 * right.register.uint16_5);
			num += (ushort)(left.register.uint16_6 * right.register.uint16_6);
			num += (ushort)(left.register.uint16_7 * right.register.uint16_7);
			return (T)(object)num;
		}
		if (typeof(T) == typeof(short))
		{
			short num2 = 0;
			num2 += (short)(left.register.int16_0 * right.register.int16_0);
			num2 += (short)(left.register.int16_1 * right.register.int16_1);
			num2 += (short)(left.register.int16_2 * right.register.int16_2);
			num2 += (short)(left.register.int16_3 * right.register.int16_3);
			num2 += (short)(left.register.int16_4 * right.register.int16_4);
			num2 += (short)(left.register.int16_5 * right.register.int16_5);
			num2 += (short)(left.register.int16_6 * right.register.int16_6);
			num2 += (short)(left.register.int16_7 * right.register.int16_7);
			return (T)(object)num2;
		}
		if (typeof(T) == typeof(uint))
		{
			uint num3 = 0u;
			num3 += left.register.uint32_0 * right.register.uint32_0;
			num3 += left.register.uint32_1 * right.register.uint32_1;
			num3 += left.register.uint32_2 * right.register.uint32_2;
			num3 += left.register.uint32_3 * right.register.uint32_3;
			return (T)(object)num3;
		}
		if (typeof(T) == typeof(int))
		{
			int num4 = 0;
			num4 += left.register.int32_0 * right.register.int32_0;
			num4 += left.register.int32_1 * right.register.int32_1;
			num4 += left.register.int32_2 * right.register.int32_2;
			num4 += left.register.int32_3 * right.register.int32_3;
			return (T)(object)num4;
		}
		if (typeof(T) == typeof(ulong))
		{
			ulong num5 = 0uL;
			num5 += left.register.uint64_0 * right.register.uint64_0;
			num5 += left.register.uint64_1 * right.register.uint64_1;
			return (T)(object)num5;
		}
		if (typeof(T) == typeof(long))
		{
			long num6 = 0L;
			num6 += left.register.int64_0 * right.register.int64_0;
			num6 += left.register.int64_1 * right.register.int64_1;
			return (T)(object)num6;
		}
		if (typeof(T) == typeof(float))
		{
			float num7 = 0f;
			num7 += left.register.single_0 * right.register.single_0;
			num7 += left.register.single_1 * right.register.single_1;
			num7 += left.register.single_2 * right.register.single_2;
			num7 += left.register.single_3 * right.register.single_3;
			return (T)(object)num7;
		}
		if (typeof(T) == typeof(double))
		{
			double num8 = 0.0;
			num8 += left.register.double_0 * right.register.double_0;
			num8 += left.register.double_1 * right.register.double_1;
			return (T)(object)num8;
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	internal unsafe static Vector<T> SquareRoot(Vector<T> value)
	{
		if (Vector.IsHardwareAccelerated)
		{
			if (typeof(T) == typeof(byte))
			{
				byte* ptr = stackalloc byte[(int)(uint)Count];
				for (int i = 0; i < Count; i++)
				{
					ptr[i] = (byte)Math.Sqrt((int)(byte)(object)value[i]);
				}
				return new Vector<T>(ptr);
			}
			if (typeof(T) == typeof(sbyte))
			{
				sbyte* ptr2 = stackalloc sbyte[(int)(uint)Count];
				for (int j = 0; j < Count; j++)
				{
					ptr2[j] = (sbyte)Math.Sqrt((sbyte)(object)value[j]);
				}
				return new Vector<T>(ptr2);
			}
			if (typeof(T) == typeof(ushort))
			{
				ushort* ptr3 = stackalloc ushort[Count];
				for (int k = 0; k < Count; k++)
				{
					ptr3[k] = (ushort)Math.Sqrt((int)(ushort)(object)value[k]);
				}
				return new Vector<T>(ptr3);
			}
			if (typeof(T) == typeof(short))
			{
				short* ptr4 = stackalloc short[Count];
				for (int l = 0; l < Count; l++)
				{
					ptr4[l] = (short)Math.Sqrt((short)(object)value[l]);
				}
				return new Vector<T>(ptr4);
			}
			if (typeof(T) == typeof(uint))
			{
				uint* ptr5 = stackalloc uint[Count];
				for (int m = 0; m < Count; m++)
				{
					ptr5[m] = (uint)Math.Sqrt((uint)(object)value[m]);
				}
				return new Vector<T>(ptr5);
			}
			if (typeof(T) == typeof(int))
			{
				int* ptr6 = stackalloc int[Count];
				for (int n = 0; n < Count; n++)
				{
					ptr6[n] = (int)Math.Sqrt((int)(object)value[n]);
				}
				return new Vector<T>(ptr6);
			}
			if (typeof(T) == typeof(ulong))
			{
				ulong* ptr7 = stackalloc ulong[Count];
				for (int num = 0; num < Count; num++)
				{
					ptr7[num] = (ulong)Math.Sqrt((ulong)(object)value[num]);
				}
				return new Vector<T>(ptr7);
			}
			if (typeof(T) == typeof(long))
			{
				long* ptr8 = stackalloc long[Count];
				for (int num2 = 0; num2 < Count; num2++)
				{
					ptr8[num2] = (long)Math.Sqrt((long)(object)value[num2]);
				}
				return new Vector<T>(ptr8);
			}
			if (typeof(T) == typeof(float))
			{
				float* ptr9 = stackalloc float[Count];
				for (int num3 = 0; num3 < Count; num3++)
				{
					ptr9[num3] = (float)Math.Sqrt((float)(object)value[num3]);
				}
				return new Vector<T>(ptr9);
			}
			if (typeof(T) == typeof(double))
			{
				double* ptr10 = stackalloc double[Count];
				for (int num4 = 0; num4 < Count; num4++)
				{
					ptr10[num4] = Math.Sqrt((double)(object)value[num4]);
				}
				return new Vector<T>(ptr10);
			}
			throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
		}
		if (typeof(T) == typeof(byte))
		{
			value.register.byte_0 = (byte)Math.Sqrt((int)value.register.byte_0);
			value.register.byte_1 = (byte)Math.Sqrt((int)value.register.byte_1);
			value.register.byte_2 = (byte)Math.Sqrt((int)value.register.byte_2);
			value.register.byte_3 = (byte)Math.Sqrt((int)value.register.byte_3);
			value.register.byte_4 = (byte)Math.Sqrt((int)value.register.byte_4);
			value.register.byte_5 = (byte)Math.Sqrt((int)value.register.byte_5);
			value.register.byte_6 = (byte)Math.Sqrt((int)value.register.byte_6);
			value.register.byte_7 = (byte)Math.Sqrt((int)value.register.byte_7);
			value.register.byte_8 = (byte)Math.Sqrt((int)value.register.byte_8);
			value.register.byte_9 = (byte)Math.Sqrt((int)value.register.byte_9);
			value.register.byte_10 = (byte)Math.Sqrt((int)value.register.byte_10);
			value.register.byte_11 = (byte)Math.Sqrt((int)value.register.byte_11);
			value.register.byte_12 = (byte)Math.Sqrt((int)value.register.byte_12);
			value.register.byte_13 = (byte)Math.Sqrt((int)value.register.byte_13);
			value.register.byte_14 = (byte)Math.Sqrt((int)value.register.byte_14);
			value.register.byte_15 = (byte)Math.Sqrt((int)value.register.byte_15);
			return value;
		}
		if (typeof(T) == typeof(sbyte))
		{
			value.register.sbyte_0 = (sbyte)Math.Sqrt(value.register.sbyte_0);
			value.register.sbyte_1 = (sbyte)Math.Sqrt(value.register.sbyte_1);
			value.register.sbyte_2 = (sbyte)Math.Sqrt(value.register.sbyte_2);
			value.register.sbyte_3 = (sbyte)Math.Sqrt(value.register.sbyte_3);
			value.register.sbyte_4 = (sbyte)Math.Sqrt(value.register.sbyte_4);
			value.register.sbyte_5 = (sbyte)Math.Sqrt(value.register.sbyte_5);
			value.register.sbyte_6 = (sbyte)Math.Sqrt(value.register.sbyte_6);
			value.register.sbyte_7 = (sbyte)Math.Sqrt(value.register.sbyte_7);
			value.register.sbyte_8 = (sbyte)Math.Sqrt(value.register.sbyte_8);
			value.register.sbyte_9 = (sbyte)Math.Sqrt(value.register.sbyte_9);
			value.register.sbyte_10 = (sbyte)Math.Sqrt(value.register.sbyte_10);
			value.register.sbyte_11 = (sbyte)Math.Sqrt(value.register.sbyte_11);
			value.register.sbyte_12 = (sbyte)Math.Sqrt(value.register.sbyte_12);
			value.register.sbyte_13 = (sbyte)Math.Sqrt(value.register.sbyte_13);
			value.register.sbyte_14 = (sbyte)Math.Sqrt(value.register.sbyte_14);
			value.register.sbyte_15 = (sbyte)Math.Sqrt(value.register.sbyte_15);
			return value;
		}
		if (typeof(T) == typeof(ushort))
		{
			value.register.uint16_0 = (ushort)Math.Sqrt((int)value.register.uint16_0);
			value.register.uint16_1 = (ushort)Math.Sqrt((int)value.register.uint16_1);
			value.register.uint16_2 = (ushort)Math.Sqrt((int)value.register.uint16_2);
			value.register.uint16_3 = (ushort)Math.Sqrt((int)value.register.uint16_3);
			value.register.uint16_4 = (ushort)Math.Sqrt((int)value.register.uint16_4);
			value.register.uint16_5 = (ushort)Math.Sqrt((int)value.register.uint16_5);
			value.register.uint16_6 = (ushort)Math.Sqrt((int)value.register.uint16_6);
			value.register.uint16_7 = (ushort)Math.Sqrt((int)value.register.uint16_7);
			return value;
		}
		if (typeof(T) == typeof(short))
		{
			value.register.int16_0 = (short)Math.Sqrt(value.register.int16_0);
			value.register.int16_1 = (short)Math.Sqrt(value.register.int16_1);
			value.register.int16_2 = (short)Math.Sqrt(value.register.int16_2);
			value.register.int16_3 = (short)Math.Sqrt(value.register.int16_3);
			value.register.int16_4 = (short)Math.Sqrt(value.register.int16_4);
			value.register.int16_5 = (short)Math.Sqrt(value.register.int16_5);
			value.register.int16_6 = (short)Math.Sqrt(value.register.int16_6);
			value.register.int16_7 = (short)Math.Sqrt(value.register.int16_7);
			return value;
		}
		if (typeof(T) == typeof(uint))
		{
			value.register.uint32_0 = (uint)Math.Sqrt(value.register.uint32_0);
			value.register.uint32_1 = (uint)Math.Sqrt(value.register.uint32_1);
			value.register.uint32_2 = (uint)Math.Sqrt(value.register.uint32_2);
			value.register.uint32_3 = (uint)Math.Sqrt(value.register.uint32_3);
			return value;
		}
		if (typeof(T) == typeof(int))
		{
			value.register.int32_0 = (int)Math.Sqrt(value.register.int32_0);
			value.register.int32_1 = (int)Math.Sqrt(value.register.int32_1);
			value.register.int32_2 = (int)Math.Sqrt(value.register.int32_2);
			value.register.int32_3 = (int)Math.Sqrt(value.register.int32_3);
			return value;
		}
		if (typeof(T) == typeof(ulong))
		{
			value.register.uint64_0 = (ulong)Math.Sqrt(value.register.uint64_0);
			value.register.uint64_1 = (ulong)Math.Sqrt(value.register.uint64_1);
			return value;
		}
		if (typeof(T) == typeof(long))
		{
			value.register.int64_0 = (long)Math.Sqrt(value.register.int64_0);
			value.register.int64_1 = (long)Math.Sqrt(value.register.int64_1);
			return value;
		}
		if (typeof(T) == typeof(float))
		{
			value.register.single_0 = (float)Math.Sqrt(value.register.single_0);
			value.register.single_1 = (float)Math.Sqrt(value.register.single_1);
			value.register.single_2 = (float)Math.Sqrt(value.register.single_2);
			value.register.single_3 = (float)Math.Sqrt(value.register.single_3);
			return value;
		}
		if (typeof(T) == typeof(double))
		{
			value.register.double_0 = Math.Sqrt(value.register.double_0);
			value.register.double_1 = Math.Sqrt(value.register.double_1);
			return value;
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool ScalarEquals(T left, T right)
	{
		if (typeof(T) == typeof(byte))
		{
			return (byte)(object)left == (byte)(object)right;
		}
		if (typeof(T) == typeof(sbyte))
		{
			return (sbyte)(object)left == (sbyte)(object)right;
		}
		if (typeof(T) == typeof(ushort))
		{
			return (ushort)(object)left == (ushort)(object)right;
		}
		if (typeof(T) == typeof(short))
		{
			return (short)(object)left == (short)(object)right;
		}
		if (typeof(T) == typeof(uint))
		{
			return (uint)(object)left == (uint)(object)right;
		}
		if (typeof(T) == typeof(int))
		{
			return (int)(object)left == (int)(object)right;
		}
		if (typeof(T) == typeof(ulong))
		{
			return (ulong)(object)left == (ulong)(object)right;
		}
		if (typeof(T) == typeof(long))
		{
			return (long)(object)left == (long)(object)right;
		}
		if (typeof(T) == typeof(float))
		{
			return (float)(object)left == (float)(object)right;
		}
		if (typeof(T) == typeof(double))
		{
			return (double)(object)left == (double)(object)right;
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool ScalarLessThan(T left, T right)
	{
		if (typeof(T) == typeof(byte))
		{
			return (byte)(object)left < (byte)(object)right;
		}
		if (typeof(T) == typeof(sbyte))
		{
			return (sbyte)(object)left < (sbyte)(object)right;
		}
		if (typeof(T) == typeof(ushort))
		{
			return (ushort)(object)left < (ushort)(object)right;
		}
		if (typeof(T) == typeof(short))
		{
			return (short)(object)left < (short)(object)right;
		}
		if (typeof(T) == typeof(uint))
		{
			return (uint)(object)left < (uint)(object)right;
		}
		if (typeof(T) == typeof(int))
		{
			return (int)(object)left < (int)(object)right;
		}
		if (typeof(T) == typeof(ulong))
		{
			return (ulong)(object)left < (ulong)(object)right;
		}
		if (typeof(T) == typeof(long))
		{
			return (long)(object)left < (long)(object)right;
		}
		if (typeof(T) == typeof(float))
		{
			return (float)(object)left < (float)(object)right;
		}
		if (typeof(T) == typeof(double))
		{
			return (double)(object)left < (double)(object)right;
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool ScalarGreaterThan(T left, T right)
	{
		if (typeof(T) == typeof(byte))
		{
			return (byte)(object)left > (byte)(object)right;
		}
		if (typeof(T) == typeof(sbyte))
		{
			return (sbyte)(object)left > (sbyte)(object)right;
		}
		if (typeof(T) == typeof(ushort))
		{
			return (ushort)(object)left > (ushort)(object)right;
		}
		if (typeof(T) == typeof(short))
		{
			return (short)(object)left > (short)(object)right;
		}
		if (typeof(T) == typeof(uint))
		{
			return (uint)(object)left > (uint)(object)right;
		}
		if (typeof(T) == typeof(int))
		{
			return (int)(object)left > (int)(object)right;
		}
		if (typeof(T) == typeof(ulong))
		{
			return (ulong)(object)left > (ulong)(object)right;
		}
		if (typeof(T) == typeof(long))
		{
			return (long)(object)left > (long)(object)right;
		}
		if (typeof(T) == typeof(float))
		{
			return (float)(object)left > (float)(object)right;
		}
		if (typeof(T) == typeof(double))
		{
			return (double)(object)left > (double)(object)right;
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static T ScalarAdd(T left, T right)
	{
		if (typeof(T) == typeof(byte))
		{
			return (T)(object)(byte)((byte)(object)left + (byte)(object)right);
		}
		if (typeof(T) == typeof(sbyte))
		{
			return (T)(object)(sbyte)((sbyte)(object)left + (sbyte)(object)right);
		}
		if (typeof(T) == typeof(ushort))
		{
			return (T)(object)(ushort)((ushort)(object)left + (ushort)(object)right);
		}
		if (typeof(T) == typeof(short))
		{
			return (T)(object)(short)((short)(object)left + (short)(object)right);
		}
		if (typeof(T) == typeof(uint))
		{
			return (T)(object)((uint)(object)left + (uint)(object)right);
		}
		if (typeof(T) == typeof(int))
		{
			return (T)(object)((int)(object)left + (int)(object)right);
		}
		if (typeof(T) == typeof(ulong))
		{
			return (T)(object)((ulong)(object)left + (ulong)(object)right);
		}
		if (typeof(T) == typeof(long))
		{
			return (T)(object)((long)(object)left + (long)(object)right);
		}
		if (typeof(T) == typeof(float))
		{
			return (T)(object)((float)(object)left + (float)(object)right);
		}
		if (typeof(T) == typeof(double))
		{
			return (T)(object)((double)(object)left + (double)(object)right);
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static T ScalarSubtract(T left, T right)
	{
		if (typeof(T) == typeof(byte))
		{
			return (T)(object)(byte)((byte)(object)left - (byte)(object)right);
		}
		if (typeof(T) == typeof(sbyte))
		{
			return (T)(object)(sbyte)((sbyte)(object)left - (sbyte)(object)right);
		}
		if (typeof(T) == typeof(ushort))
		{
			return (T)(object)(ushort)((ushort)(object)left - (ushort)(object)right);
		}
		if (typeof(T) == typeof(short))
		{
			return (T)(object)(short)((short)(object)left - (short)(object)right);
		}
		if (typeof(T) == typeof(uint))
		{
			return (T)(object)((uint)(object)left - (uint)(object)right);
		}
		if (typeof(T) == typeof(int))
		{
			return (T)(object)((int)(object)left - (int)(object)right);
		}
		if (typeof(T) == typeof(ulong))
		{
			return (T)(object)((ulong)(object)left - (ulong)(object)right);
		}
		if (typeof(T) == typeof(long))
		{
			return (T)(object)((long)(object)left - (long)(object)right);
		}
		if (typeof(T) == typeof(float))
		{
			return (T)(object)((float)(object)left - (float)(object)right);
		}
		if (typeof(T) == typeof(double))
		{
			return (T)(object)((double)(object)left - (double)(object)right);
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static T ScalarMultiply(T left, T right)
	{
		if (typeof(T) == typeof(byte))
		{
			return (T)(object)(byte)((byte)(object)left * (byte)(object)right);
		}
		if (typeof(T) == typeof(sbyte))
		{
			return (T)(object)(sbyte)((sbyte)(object)left * (sbyte)(object)right);
		}
		if (typeof(T) == typeof(ushort))
		{
			return (T)(object)(ushort)((ushort)(object)left * (ushort)(object)right);
		}
		if (typeof(T) == typeof(short))
		{
			return (T)(object)(short)((short)(object)left * (short)(object)right);
		}
		if (typeof(T) == typeof(uint))
		{
			return (T)(object)((uint)(object)left * (uint)(object)right);
		}
		if (typeof(T) == typeof(int))
		{
			return (T)(object)((int)(object)left * (int)(object)right);
		}
		if (typeof(T) == typeof(ulong))
		{
			return (T)(object)((ulong)(object)left * (ulong)(object)right);
		}
		if (typeof(T) == typeof(long))
		{
			return (T)(object)((long)(object)left * (long)(object)right);
		}
		if (typeof(T) == typeof(float))
		{
			return (T)(object)((float)(object)left * (float)(object)right);
		}
		if (typeof(T) == typeof(double))
		{
			return (T)(object)((double)(object)left * (double)(object)right);
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static T ScalarDivide(T left, T right)
	{
		if (typeof(T) == typeof(byte))
		{
			return (T)(object)(byte)((byte)(object)left / (byte)(object)right);
		}
		if (typeof(T) == typeof(sbyte))
		{
			return (T)(object)(sbyte)((sbyte)(object)left / (sbyte)(object)right);
		}
		if (typeof(T) == typeof(ushort))
		{
			return (T)(object)(ushort)((ushort)(object)left / (ushort)(object)right);
		}
		if (typeof(T) == typeof(short))
		{
			return (T)(object)(short)((short)(object)left / (short)(object)right);
		}
		if (typeof(T) == typeof(uint))
		{
			return (T)(object)((uint)(object)left / (uint)(object)right);
		}
		if (typeof(T) == typeof(int))
		{
			return (T)(object)((int)(object)left / (int)(object)right);
		}
		if (typeof(T) == typeof(ulong))
		{
			return (T)(object)((ulong)(object)left / (ulong)(object)right);
		}
		if (typeof(T) == typeof(long))
		{
			return (T)(object)((long)(object)left / (long)(object)right);
		}
		if (typeof(T) == typeof(float))
		{
			return (T)(object)((float)(object)left / (float)(object)right);
		}
		if (typeof(T) == typeof(double))
		{
			return (T)(object)((double)(object)left / (double)(object)right);
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static T GetOneValue()
	{
		if (typeof(T) == typeof(byte))
		{
			byte b = 1;
			return (T)(object)b;
		}
		if (typeof(T) == typeof(sbyte))
		{
			sbyte b2 = 1;
			return (T)(object)b2;
		}
		if (typeof(T) == typeof(ushort))
		{
			ushort num = 1;
			return (T)(object)num;
		}
		if (typeof(T) == typeof(short))
		{
			short num2 = 1;
			return (T)(object)num2;
		}
		if (typeof(T) == typeof(uint))
		{
			uint num3 = 1u;
			return (T)(object)num3;
		}
		if (typeof(T) == typeof(int))
		{
			int num4 = 1;
			return (T)(object)num4;
		}
		if (typeof(T) == typeof(ulong))
		{
			ulong num5 = 1uL;
			return (T)(object)num5;
		}
		if (typeof(T) == typeof(long))
		{
			long num6 = 1L;
			return (T)(object)num6;
		}
		if (typeof(T) == typeof(float))
		{
			float num7 = 1f;
			return (T)(object)num7;
		}
		if (typeof(T) == typeof(double))
		{
			double num8 = 1.0;
			return (T)(object)num8;
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static T GetAllBitsSetValue()
	{
		if (typeof(T) == typeof(byte))
		{
			return (T)(object)ConstantHelper.GetByteWithAllBitsSet();
		}
		if (typeof(T) == typeof(sbyte))
		{
			return (T)(object)ConstantHelper.GetSByteWithAllBitsSet();
		}
		if (typeof(T) == typeof(ushort))
		{
			return (T)(object)ConstantHelper.GetUInt16WithAllBitsSet();
		}
		if (typeof(T) == typeof(short))
		{
			return (T)(object)ConstantHelper.GetInt16WithAllBitsSet();
		}
		if (typeof(T) == typeof(uint))
		{
			return (T)(object)ConstantHelper.GetUInt32WithAllBitsSet();
		}
		if (typeof(T) == typeof(int))
		{
			return (T)(object)ConstantHelper.GetInt32WithAllBitsSet();
		}
		if (typeof(T) == typeof(ulong))
		{
			return (T)(object)ConstantHelper.GetUInt64WithAllBitsSet();
		}
		if (typeof(T) == typeof(long))
		{
			return (T)(object)ConstantHelper.GetInt64WithAllBitsSet();
		}
		if (typeof(T) == typeof(float))
		{
			return (T)(object)ConstantHelper.GetSingleWithAllBitsSet();
		}
		if (typeof(T) == typeof(double))
		{
			return (T)(object)ConstantHelper.GetDoubleWithAllBitsSet();
		}
		throw new NotSupportedException(<fa25449b-e4ab-4eda-9733-a28f2aabb252>SR.Arg_TypeNotSupported);
	}
}


private struct VectorSizeHelper
{
	internal Vector<T> _placeholder;

	internal byte _byte;
}


using System;
using System.Numerics;
using System.Runtime.CompilerServices;

[System.Runtime.CompilerServices.Intrinsic]
internal static class Vector
{
	public static bool IsHardwareAccelerated
	{
		[System.Runtime.CompilerServices.Intrinsic]
		get
		{
			return false;
		}
	}

	[System.Runtime.CompilerServices.Intrinsic]
	[CLSCompliant(false)]
	public unsafe static void Widen(Vector<byte> source, out Vector<ushort> low, out Vector<ushort> high)
	{
		int count = Vector<byte>.Count;
		ushort* ptr = stackalloc ushort[count / 2];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = source[i];
		}
		ushort* ptr2 = stackalloc ushort[count / 2];
		for (int j = 0; j < count / 2; j++)
		{
			ptr2[j] = source[j + count / 2];
		}
		low = new Vector<ushort>(ptr);
		high = new Vector<ushort>(ptr2);
	}

	[CLSCompliant(false)]
	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static void Widen(Vector<ushort> source, out Vector<uint> low, out Vector<uint> high)
	{
		int count = Vector<ushort>.Count;
		uint* ptr = stackalloc uint[count / 2];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = source[i];
		}
		uint* ptr2 = stackalloc uint[count / 2];
		for (int j = 0; j < count / 2; j++)
		{
			ptr2[j] = source[j + count / 2];
		}
		low = new Vector<uint>(ptr);
		high = new Vector<uint>(ptr2);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	[CLSCompliant(false)]
	public unsafe static void Widen(Vector<uint> source, out Vector<ulong> low, out Vector<ulong> high)
	{
		int count = Vector<uint>.Count;
		ulong* ptr = stackalloc ulong[count / 2];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = source[i];
		}
		ulong* ptr2 = stackalloc ulong[count / 2];
		for (int j = 0; j < count / 2; j++)
		{
			ptr2[j] = source[j + count / 2];
		}
		low = new Vector<ulong>(ptr);
		high = new Vector<ulong>(ptr2);
	}

	[CLSCompliant(false)]
	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static void Widen(Vector<sbyte> source, out Vector<short> low, out Vector<short> high)
	{
		int count = Vector<sbyte>.Count;
		short* ptr = stackalloc short[count / 2];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = source[i];
		}
		short* ptr2 = stackalloc short[count / 2];
		for (int j = 0; j < count / 2; j++)
		{
			ptr2[j] = source[j + count / 2];
		}
		low = new Vector<short>(ptr);
		high = new Vector<short>(ptr2);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static void Widen(Vector<short> source, out Vector<int> low, out Vector<int> high)
	{
		int count = Vector<short>.Count;
		int* ptr = stackalloc int[count / 2];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = source[i];
		}
		int* ptr2 = stackalloc int[count / 2];
		for (int j = 0; j < count / 2; j++)
		{
			ptr2[j] = source[j + count / 2];
		}
		low = new Vector<int>(ptr);
		high = new Vector<int>(ptr2);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static void Widen(Vector<int> source, out Vector<long> low, out Vector<long> high)
	{
		int count = Vector<int>.Count;
		long* ptr = stackalloc long[count / 2];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = source[i];
		}
		long* ptr2 = stackalloc long[count / 2];
		for (int j = 0; j < count / 2; j++)
		{
			ptr2[j] = source[j + count / 2];
		}
		low = new Vector<long>(ptr);
		high = new Vector<long>(ptr2);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static void Widen(Vector<float> source, out Vector<double> low, out Vector<double> high)
	{
		int count = Vector<float>.Count;
		double* ptr = stackalloc double[count / 2];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = source[i];
		}
		double* ptr2 = stackalloc double[count / 2];
		for (int j = 0; j < count / 2; j++)
		{
			ptr2[j] = source[j + count / 2];
		}
		low = new Vector<double>(ptr);
		high = new Vector<double>(ptr2);
	}

	[CLSCompliant(false)]
	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<byte> Narrow(Vector<ushort> low, Vector<ushort> high)
	{
		int count = Vector<byte>.Count;
		byte* ptr = stackalloc byte[(int)(uint)count];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = (byte)low[i];
		}
		for (int j = 0; j < count / 2; j++)
		{
			ptr[j + count / 2] = (byte)high[j];
		}
		return new Vector<byte>(ptr);
	}

	[CLSCompliant(false)]
	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<ushort> Narrow(Vector<uint> low, Vector<uint> high)
	{
		int count = Vector<ushort>.Count;
		ushort* ptr = stackalloc ushort[count];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = (ushort)low[i];
		}
		for (int j = 0; j < count / 2; j++)
		{
			ptr[j + count / 2] = (ushort)high[j];
		}
		return new Vector<ushort>(ptr);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	[CLSCompliant(false)]
	public unsafe static Vector<uint> Narrow(Vector<ulong> low, Vector<ulong> high)
	{
		int count = Vector<uint>.Count;
		uint* ptr = stackalloc uint[count];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = (uint)low[i];
		}
		for (int j = 0; j < count / 2; j++)
		{
			ptr[j + count / 2] = (uint)high[j];
		}
		return new Vector<uint>(ptr);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	[CLSCompliant(false)]
	public unsafe static Vector<sbyte> Narrow(Vector<short> low, Vector<short> high)
	{
		int count = Vector<sbyte>.Count;
		sbyte* ptr = stackalloc sbyte[(int)(uint)count];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = (sbyte)low[i];
		}
		for (int j = 0; j < count / 2; j++)
		{
			ptr[j + count / 2] = (sbyte)high[j];
		}
		return new Vector<sbyte>(ptr);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<short> Narrow(Vector<int> low, Vector<int> high)
	{
		int count = Vector<short>.Count;
		short* ptr = stackalloc short[count];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = (short)low[i];
		}
		for (int j = 0; j < count / 2; j++)
		{
			ptr[j + count / 2] = (short)high[j];
		}
		return new Vector<short>(ptr);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<int> Narrow(Vector<long> low, Vector<long> high)
	{
		int count = Vector<int>.Count;
		int* ptr = stackalloc int[count];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = (int)low[i];
		}
		for (int j = 0; j < count / 2; j++)
		{
			ptr[j + count / 2] = (int)high[j];
		}
		return new Vector<int>(ptr);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<float> Narrow(Vector<double> low, Vector<double> high)
	{
		int count = Vector<float>.Count;
		float* ptr = stackalloc float[count];
		for (int i = 0; i < count / 2; i++)
		{
			ptr[i] = (float)low[i];
		}
		for (int j = 0; j < count / 2; j++)
		{
			ptr[j + count / 2] = (float)high[j];
		}
		return new Vector<float>(ptr);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<float> ConvertToSingle(Vector<int> value)
	{
		int count = Vector<float>.Count;
		float* ptr = stackalloc float[count];
		for (int i = 0; i < count; i++)
		{
			ptr[i] = value[i];
		}
		return new Vector<float>(ptr);
	}

	[CLSCompliant(false)]
	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<float> ConvertToSingle(Vector<uint> value)
	{
		int count = Vector<float>.Count;
		float* ptr = stackalloc float[count];
		for (int i = 0; i < count; i++)
		{
			ptr[i] = value[i];
		}
		return new Vector<float>(ptr);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<double> ConvertToDouble(Vector<long> value)
	{
		int count = Vector<double>.Count;
		double* ptr = stackalloc double[count];
		for (int i = 0; i < count; i++)
		{
			ptr[i] = value[i];
		}
		return new Vector<double>(ptr);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	[CLSCompliant(false)]
	public unsafe static Vector<double> ConvertToDouble(Vector<ulong> value)
	{
		int count = Vector<double>.Count;
		double* ptr = stackalloc double[count];
		for (int i = 0; i < count; i++)
		{
			ptr[i] = value[i];
		}
		return new Vector<double>(ptr);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<int> ConvertToInt32(Vector<float> value)
	{
		int count = Vector<int>.Count;
		int* ptr = stackalloc int[count];
		for (int i = 0; i < count; i++)
		{
			ptr[i] = (int)value[i];
		}
		return new Vector<int>(ptr);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	[CLSCompliant(false)]
	public unsafe static Vector<uint> ConvertToUInt32(Vector<float> value)
	{
		int count = Vector<uint>.Count;
		uint* ptr = stackalloc uint[count];
		for (int i = 0; i < count; i++)
		{
			ptr[i] = (uint)value[i];
		}
		return new Vector<uint>(ptr);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	public unsafe static Vector<long> ConvertToInt64(Vector<double> value)
	{
		int count = Vector<long>.Count;
		long* ptr = stackalloc long[count];
		for (int i = 0; i < count; i++)
		{
			ptr[i] = (long)value[i];
		}
		return new Vector<long>(ptr);
	}

	[System.Runtime.CompilerServices.Intrinsic]
	[CLSCompliant(false)]
	public unsafe static Vector<ulong> ConvertToUInt64(Vector<double> value)
	{
		int count = Vector<ulong>.Count;
		ulong* ptr = stackalloc ulong[count];
		for (int i = 0; i < count; i++)
		{
			ptr[i] = (ulong)value[i];
		}
		return new Vector<ulong>(ptr);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<float> ConditionalSelect(Vector<int> condition, Vector<float> left, Vector<float> right)
	{
		return Vector<float>.ConditionalSelect((Vector<float>)condition, left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<double> ConditionalSelect(Vector<long> condition, Vector<double> left, Vector<double> right)
	{
		return Vector<double>.ConditionalSelect((Vector<double>)condition, left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> ConditionalSelect<T>(Vector<T> condition, Vector<T> left, Vector<T> right) where T : struct
	{
		return Vector<T>.ConditionalSelect(condition, left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> Equals<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return Vector<T>.Equals(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<int> Equals(Vector<float> left, Vector<float> right)
	{
		return (Vector<int>)Vector<float>.Equals(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<int> Equals(Vector<int> left, Vector<int> right)
	{
		return Vector<int>.Equals(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<long> Equals(Vector<double> left, Vector<double> right)
	{
		return (Vector<long>)Vector<double>.Equals(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<long> Equals(Vector<long> left, Vector<long> right)
	{
		return Vector<long>.Equals(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool EqualsAll<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return left == right;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool EqualsAny<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return !Vector<T>.Equals(left, right).Equals(Vector<T>.Zero);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> LessThan<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return Vector<T>.LessThan(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<int> LessThan(Vector<float> left, Vector<float> right)
	{
		return (Vector<int>)Vector<float>.LessThan(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<int> LessThan(Vector<int> left, Vector<int> right)
	{
		return Vector<int>.LessThan(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<long> LessThan(Vector<double> left, Vector<double> right)
	{
		return (Vector<long>)Vector<double>.LessThan(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<long> LessThan(Vector<long> left, Vector<long> right)
	{
		return Vector<long>.LessThan(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool LessThanAll<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return ((Vector<int>)Vector<T>.LessThan(left, right)).Equals(Vector<int>.AllOnes);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool LessThanAny<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return !((Vector<int>)Vector<T>.LessThan(left, right)).Equals(Vector<int>.Zero);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> LessThanOrEqual<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return Vector<T>.LessThanOrEqual(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<int> LessThanOrEqual(Vector<float> left, Vector<float> right)
	{
		return (Vector<int>)Vector<float>.LessThanOrEqual(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<int> LessThanOrEqual(Vector<int> left, Vector<int> right)
	{
		return Vector<int>.LessThanOrEqual(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<long> LessThanOrEqual(Vector<long> left, Vector<long> right)
	{
		return Vector<long>.LessThanOrEqual(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<long> LessThanOrEqual(Vector<double> left, Vector<double> right)
	{
		return (Vector<long>)Vector<double>.LessThanOrEqual(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool LessThanOrEqualAll<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return ((Vector<int>)Vector<T>.LessThanOrEqual(left, right)).Equals(Vector<int>.AllOnes);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool LessThanOrEqualAny<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return !((Vector<int>)Vector<T>.LessThanOrEqual(left, right)).Equals(Vector<int>.Zero);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> GreaterThan<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return Vector<T>.GreaterThan(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<int> GreaterThan(Vector<float> left, Vector<float> right)
	{
		return (Vector<int>)Vector<float>.GreaterThan(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<int> GreaterThan(Vector<int> left, Vector<int> right)
	{
		return Vector<int>.GreaterThan(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<long> GreaterThan(Vector<double> left, Vector<double> right)
	{
		return (Vector<long>)Vector<double>.GreaterThan(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<long> GreaterThan(Vector<long> left, Vector<long> right)
	{
		return Vector<long>.GreaterThan(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool GreaterThanAll<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return ((Vector<int>)Vector<T>.GreaterThan(left, right)).Equals(Vector<int>.AllOnes);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool GreaterThanAny<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return !((Vector<int>)Vector<T>.GreaterThan(left, right)).Equals(Vector<int>.Zero);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> GreaterThanOrEqual<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return Vector<T>.GreaterThanOrEqual(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<int> GreaterThanOrEqual(Vector<float> left, Vector<float> right)
	{
		return (Vector<int>)Vector<float>.GreaterThanOrEqual(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<int> GreaterThanOrEqual(Vector<int> left, Vector<int> right)
	{
		return Vector<int>.GreaterThanOrEqual(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<long> GreaterThanOrEqual(Vector<long> left, Vector<long> right)
	{
		return Vector<long>.GreaterThanOrEqual(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<long> GreaterThanOrEqual(Vector<double> left, Vector<double> right)
	{
		return (Vector<long>)Vector<double>.GreaterThanOrEqual(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool GreaterThanOrEqualAll<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return ((Vector<int>)Vector<T>.GreaterThanOrEqual(left, right)).Equals(Vector<int>.AllOnes);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool GreaterThanOrEqualAny<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return !((Vector<int>)Vector<T>.GreaterThanOrEqual(left, right)).Equals(Vector<int>.Zero);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> Abs<T>(Vector<T> value) where T : struct
	{
		return Vector<T>.Abs(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> Min<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return Vector<T>.Min(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> Max<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return Vector<T>.Max(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static T Dot<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return Vector<T>.DotProduct(left, right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> SquareRoot<T>(Vector<T> value) where T : struct
	{
		return Vector<T>.SquareRoot(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> Add<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return left + right;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> Subtract<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return left - right;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> Multiply<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return left * right;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> Multiply<T>(Vector<T> left, T right) where T : struct
	{
		return left * right;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> Multiply<T>(T left, Vector<T> right) where T : struct
	{
		return left * right;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> Divide<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return left / right;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> Negate<T>(Vector<T> value) where T : struct
	{
		return -value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> BitwiseAnd<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return left & right;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> BitwiseOr<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return left | right;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> OnesComplement<T>(Vector<T> value) where T : struct
	{
		return ~value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> Xor<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return left ^ right;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<T> AndNot<T>(Vector<T> left, Vector<T> right) where T : struct
	{
		return left & ~right;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<byte> AsVectorByte<T>(Vector<T> value) where T : struct
	{
		return (Vector<byte>)value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static Vector<sbyte> AsVectorSByte<T>(Vector<T> value) where T : struct
	{
		return (Vector<sbyte>)value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static Vector<ushort> AsVectorUInt16<T>(Vector<T> value) where T : struct
	{
		return (Vector<ushort>)value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<short> AsVectorInt16<T>(Vector<T> value) where T : struct
	{
		return (Vector<short>)value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static Vector<uint> AsVectorUInt32<T>(Vector<T> value) where T : struct
	{
		return (Vector<uint>)value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<int> AsVectorInt32<T>(Vector<T> value) where T : struct
	{
		return (Vector<int>)value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static Vector<ulong> AsVectorUInt64<T>(Vector<T> value) where T : struct
	{
		return (Vector<ulong>)value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<long> AsVectorInt64<T>(Vector<T> value) where T : struct
	{
		return (Vector<long>)value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<float> AsVectorSingle<T>(Vector<T> value) where T : struct
	{
		return (Vector<float>)value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector<double> AsVectorDouble<T>(Vector<T> value) where T : struct
	{
		return (Vector<double>)value;
	}
}


using System;

internal static class HashHelpers
{
	public static readonly int RandomSeed = Guid.NewGuid().GetHashCode();

	public static int Combine(int h1, int h2)
	{
		uint num = (uint)((h1 << 5) | (h1 >>> 27));
		return ((int)num + h1) ^ h2;
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.Versioning;

internal static class Unsafe
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static T Read<T>(void* source)
	{
		return Unsafe.Read<T>(source);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static T ReadUnaligned<T>(void* source)
	{
		return Unsafe.ReadUnaligned<T>(source);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static T ReadUnaligned<T>(ref byte source)
	{
		return Unsafe.ReadUnaligned<T>(ref source);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void Write<T>(void* destination, T value)
	{
		Unsafe.Write(destination, value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void WriteUnaligned<T>(void* destination, T value)
	{
		Unsafe.WriteUnaligned(destination, value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static void WriteUnaligned<T>(ref byte destination, T value)
	{
		Unsafe.WriteUnaligned(ref destination, value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void Copy<T>(void* destination, ref T source)
	{
		Unsafe.Write(destination, source);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void Copy<T>(ref T destination, void* source)
	{
		destination = Unsafe.Read<T>(source);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void* AsPointer<T>(ref T value)
	{
		return Unsafe.AsPointer(ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static void SkipInit<T>(out T value)
	{
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static int SizeOf<T>()
	{
		return Unsafe.SizeOf<T>();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void CopyBlock(void* destination, void* source, uint byteCount)
	{
		// IL cpblk instruction
		Unsafe.CopyBlock(destination, source, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static void CopyBlock(ref byte destination, ref byte source, uint byteCount)
	{
		// IL cpblk instruction
		Unsafe.CopyBlock(ref destination, ref source, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void CopyBlockUnaligned(void* destination, void* source, uint byteCount)
	{
		// IL cpblk instruction
		Unsafe.CopyBlockUnaligned(destination, source, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static void CopyBlockUnaligned(ref byte destination, ref byte source, uint byteCount)
	{
		// IL cpblk instruction
		Unsafe.CopyBlockUnaligned(ref destination, ref source, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void InitBlock(void* startAddress, byte value, uint byteCount)
	{
		// IL initblk instruction
		Unsafe.InitBlock(startAddress, value, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static void InitBlock(ref byte startAddress, byte value, uint byteCount)
	{
		// IL initblk instruction
		Unsafe.InitBlock(ref startAddress, value, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void InitBlockUnaligned(void* startAddress, byte value, uint byteCount)
	{
		// IL initblk instruction
		Unsafe.InitBlockUnaligned(startAddress, value, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static void InitBlockUnaligned(ref byte startAddress, byte value, uint byteCount)
	{
		// IL initblk instruction
		Unsafe.InitBlockUnaligned(ref startAddress, value, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static T As<T>(object o) where T : class
	{
		return (T)o;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static ref T AsRef<T>(void* source)
	{
		return ref *(T*)source;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T AsRef<T>([<9dd0d30f-0657-432e-8623-52f8e70f9917>IsReadOnly] ref T source)
	{
		return ref source;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref TTo As<TFrom, TTo>(ref TFrom source)
	{
		return ref Unsafe.As<TFrom, TTo>(ref source);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T Unbox<T>(object box) where T : struct
	{
		return ref (T)box;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T Add<T>(ref T source, int elementOffset)
	{
		return ref Unsafe.Add(ref source, elementOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void* Add<T>(void* source, int elementOffset)
	{
		return (byte*)source + (nint)elementOffset * (nint)Unsafe.SizeOf<T>();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T Add<T>(ref T source, IntPtr elementOffset)
	{
		return ref Unsafe.Add(ref source, elementOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ref T Add<T>(ref T source, [System.Runtime.Versioning.NonVersionable] nuint elementOffset)
	{
		return ref Unsafe.Add(ref source, elementOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T AddByteOffset<T>(ref T source, IntPtr byteOffset)
	{
		return ref Unsafe.AddByteOffset(ref source, byteOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ref T AddByteOffset<T>(ref T source, [System.Runtime.Versioning.NonVersionable] nuint byteOffset)
	{
		return ref Unsafe.AddByteOffset(ref source, byteOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T Subtract<T>(ref T source, int elementOffset)
	{
		return ref Unsafe.Subtract(ref source, elementOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void* Subtract<T>(void* source, int elementOffset)
	{
		return (byte*)source - (nint)elementOffset * (nint)Unsafe.SizeOf<T>();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T Subtract<T>(ref T source, IntPtr elementOffset)
	{
		return ref Unsafe.Subtract(ref source, elementOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ref T Subtract<T>(ref T source, [System.Runtime.Versioning.NonVersionable] nuint elementOffset)
	{
		return ref Unsafe.Subtract(ref source, elementOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T SubtractByteOffset<T>(ref T source, IntPtr byteOffset)
	{
		return ref Unsafe.SubtractByteOffset(ref source, byteOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ref T SubtractByteOffset<T>(ref T source, [System.Runtime.Versioning.NonVersionable] nuint byteOffset)
	{
		return ref Unsafe.SubtractByteOffset(ref source, byteOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static IntPtr ByteOffset<T>(ref T origin, ref T target)
	{
		return Unsafe.ByteOffset(target: ref target, origin: ref origin);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static bool AreSame<T>(ref T left, ref T right)
	{
		return Unsafe.AreSame(ref left, ref right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static bool IsAddressGreaterThan<T>(ref T left, ref T right)
	{
		return Unsafe.IsAddressGreaterThan(ref left, ref right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static bool IsAddressLessThan<T>(ref T left, ref T right)
	{
		return Unsafe.IsAddressLessThan(ref left, ref right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static bool IsNullRef<T>(ref T source)
	{
		return Unsafe.AsPointer(ref source) == null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static ref T NullRef<T>()
	{
		return ref *(T*)null;
	}
}


using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Constructor | AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
internal sealed class NonVersionableAttribute : Attribute
{
}


using System;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;

[<e0a1ec95-561b-467e-9cb8-f6f3bc7ad8c8>Embedded]
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter, AllowMultiple = false, Inherited = false)]
[CompilerGenerated]
internal sealed class NativeIntegerAttribute : Attribute
{
	public readonly bool[] TransformFlags;

	public NativeIntegerAttribute()
	{
		TransformFlags = new bool[1] { true };
	}

	public NativeIntegerAttribute(bool[] A_0)
	{
		TransformFlags = A_0;
	}
}


internal enum ExceptionArgument
{
	task,
	source,
	state
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using System.Threading.Tasks.Sources;

[StructLayout(LayoutKind.Auto)]
[AsyncMethodBuilder(typeof(AsyncValueTaskMethodBuilder))]
[<d1319d0b-8e9a-4832-93a5-07396d9c0bfd>IsReadOnly]
internal struct ValueTask : IEquatable<ValueTask>
{
	private sealed class ValueTaskSourceAsTask : TaskCompletionSource<bool>
	{
		private static readonly Action<object> s_completionAction = delegate(object state)
		{
			IValueTaskSource source;
			if (!(state is ValueTaskSourceAsTask valueTaskSourceAsTask) || (source = valueTaskSourceAsTask._source) == null)
			{
				<f9b47b20-f8fc-4539-b746-9c209e9728ac>ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.state);
				return;
			}
			valueTaskSourceAsTask._source = null;
			ValueTaskSourceStatus status = source.GetStatus(valueTaskSourceAsTask._token);
			try
			{
				source.GetResult(valueTaskSourceAsTask._token);
				valueTaskSourceAsTask.TrySetResult(result: false);
			}
			catch (Exception exception)
			{
				if (status == ValueTaskSourceStatus.Canceled)
				{
					valueTaskSourceAsTask.TrySetCanceled();
				}
				else
				{
					valueTaskSourceAsTask.TrySetException(exception);
				}
			}
		};

		private IValueTaskSource _source;

		private readonly short _token;

		public ValueTaskSourceAsTask(IValueTaskSource source, short token)
		{
			_token = token;
			_source = source;
			source.OnCompleted(s_completionAction, this, token, ValueTaskSourceOnCompletedFlags.None);
		}
	}

	private static readonly Task s_canceledTask = Task.Delay(-1, new CancellationToken(canceled: true));

	internal readonly object _obj;

	internal readonly short _token;

	internal readonly bool _continueOnCapturedContext;

	internal static Task CompletedTask { get; } = Task.Delay(0);

	public bool IsCompleted
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			object obj = _obj;
			if (obj == null)
			{
				return true;
			}
			if (obj is Task task)
			{
				return task.IsCompleted;
			}
			return Unsafe.As<IValueTaskSource>(obj).GetStatus(_token) != ValueTaskSourceStatus.Pending;
		}
	}

	public bool IsCompletedSuccessfully
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			object obj = _obj;
			if (obj == null)
			{
				return true;
			}
			if (obj is Task task)
			{
				return task.Status == TaskStatus.RanToCompletion;
			}
			return Unsafe.As<IValueTaskSource>(obj).GetStatus(_token) == ValueTaskSourceStatus.Succeeded;
		}
	}

	public bool IsFaulted
	{
		get
		{
			object obj = _obj;
			if (obj == null)
			{
				return false;
			}
			if (obj is Task task)
			{
				return task.IsFaulted;
			}
			return Unsafe.As<IValueTaskSource>(obj).GetStatus(_token) == ValueTaskSourceStatus.Faulted;
		}
	}

	public bool IsCanceled
	{
		get
		{
			object obj = _obj;
			if (obj == null)
			{
				return false;
			}
			if (obj is Task task)
			{
				return task.IsCanceled;
			}
			return Unsafe.As<IValueTaskSource>(obj).GetStatus(_token) == ValueTaskSourceStatus.Canceled;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ValueTask(Task task)
	{
		if (task == null)
		{
			<f9b47b20-f8fc-4539-b746-9c209e9728ac>ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.task);
		}
		_obj = task;
		_continueOnCapturedContext = true;
		_token = 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ValueTask(IValueTaskSource source, short token)
	{
		if (source == null)
		{
			<f9b47b20-f8fc-4539-b746-9c209e9728ac>ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.source);
		}
		_obj = source;
		_token = token;
		_continueOnCapturedContext = true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private ValueTask(object obj, short token, bool continueOnCapturedContext)
	{
		_obj = obj;
		_token = token;
		_continueOnCapturedContext = continueOnCapturedContext;
	}

	public override int GetHashCode()
	{
		return _obj?.GetHashCode() ?? 0;
	}

	public override bool Equals(object obj)
	{
		if (obj is ValueTask)
		{
			return Equals((ValueTask)obj);
		}
		return false;
	}

	public bool Equals(ValueTask other)
	{
		if (_obj == other._obj)
		{
			return _token == other._token;
		}
		return false;
	}

	public static bool operator ==(ValueTask left, ValueTask right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(ValueTask left, ValueTask right)
	{
		return !left.Equals(right);
	}

	public Task AsTask()
	{
		object obj = _obj;
		object obj2;
		if (obj != null)
		{
			obj2 = obj as Task;
			if (obj2 == null)
			{
				return GetTaskForValueTaskSource(Unsafe.As<IValueTaskSource>(obj));
			}
		}
		else
		{
			obj2 = CompletedTask;
		}
		return (Task)obj2;
	}

	public ValueTask Preserve()
	{
		if (_obj != null)
		{
			return new ValueTask(AsTask());
		}
		return this;
	}

	private Task GetTaskForValueTaskSource(IValueTaskSource t)
	{
		ValueTaskSourceStatus status = t.GetStatus(_token);
		if (status != 0)
		{
			try
			{
				t.GetResult(_token);
				return CompletedTask;
			}
			catch (Exception exception)
			{
				if (status == ValueTaskSourceStatus.Canceled)
				{
					return s_canceledTask;
				}
				TaskCompletionSource<bool> taskCompletionSource = new TaskCompletionSource<bool>();
				taskCompletionSource.TrySetException(exception);
				return taskCompletionSource.Task;
			}
		}
		ValueTaskSourceAsTask valueTaskSourceAsTask = new ValueTaskSourceAsTask(t, _token);
		return valueTaskSourceAsTask.Task;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[StackTraceHidden]
	internal void ThrowIfCompletedUnsuccessfully()
	{
		object obj = _obj;
		if (obj != null)
		{
			if (obj is Task task)
			{
				task.GetAwaiter().GetResult();
			}
			else
			{
				Unsafe.As<IValueTaskSource>(obj).GetResult(_token);
			}
		}
	}

	public ValueTaskAwaiter GetAwaiter()
	{
		return new ValueTaskAwaiter(this);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext)
	{
		return new ConfiguredValueTaskAwaitable(new ValueTask(_obj, _token, continueOnCapturedContext));
	}
}


using System.Threading.Tasks.Sources;

private sealed class ValueTaskSourceAsTask : TaskCompletionSource<bool>
{
	private static readonly Action<object> s_completionAction = delegate(object state)
	{
		IValueTaskSource source;
		if (!(state is ValueTaskSourceAsTask valueTaskSourceAsTask) || (source = valueTaskSourceAsTask._source) == null)
		{
			<f9b47b20-f8fc-4539-b746-9c209e9728ac>ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.state);
			return;
		}
		valueTaskSourceAsTask._source = null;
		ValueTaskSourceStatus status = source.GetStatus(valueTaskSourceAsTask._token);
		try
		{
			source.GetResult(valueTaskSourceAsTask._token);
			valueTaskSourceAsTask.TrySetResult(result: false);
		}
		catch (Exception exception)
		{
			if (status == ValueTaskSourceStatus.Canceled)
			{
				valueTaskSourceAsTask.TrySetCanceled();
			}
			else
			{
				valueTaskSourceAsTask.TrySetException(exception);
			}
		}
	};

	private IValueTaskSource _source;

	private readonly short _token;

	public ValueTaskSourceAsTask(IValueTaskSource source, short token)
	{
		_token = token;
		_source = source;
		source.OnCompleted(s_completionAction, this, token, ValueTaskSourceOnCompletedFlags.None);
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Threading.Tasks.Sources;

[StructLayout(LayoutKind.Auto)]
[<d1319d0b-8e9a-4832-93a5-07396d9c0bfd>IsReadOnly]
[AsyncMethodBuilder(typeof(AsyncValueTaskMethodBuilder<>))]
internal struct ValueTask<TResult> : IEquatable<ValueTask<TResult>>
{
	private sealed class ValueTaskSourceAsTask : TaskCompletionSource<TResult>
	{
		private static readonly Action<object> s_completionAction = delegate(object state)
		{
			IValueTaskSource<TResult> source;
			if (!(state is ValueTaskSourceAsTask valueTaskSourceAsTask) || (source = valueTaskSourceAsTask._source) == null)
			{
				<f9b47b20-f8fc-4539-b746-9c209e9728ac>ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.state);
				return;
			}
			valueTaskSourceAsTask._source = null;
			ValueTaskSourceStatus status = source.GetStatus(valueTaskSourceAsTask._token);
			try
			{
				valueTaskSourceAsTask.TrySetResult(source.GetResult(valueTaskSourceAsTask._token));
			}
			catch (Exception exception)
			{
				if (status == ValueTaskSourceStatus.Canceled)
				{
					valueTaskSourceAsTask.TrySetCanceled();
				}
				else
				{
					valueTaskSourceAsTask.TrySetException(exception);
				}
			}
		};

		private IValueTaskSource<TResult> _source;

		private readonly short _token;

		public ValueTaskSourceAsTask(IValueTaskSource<TResult> source, short token)
		{
			_source = source;
			_token = token;
			source.OnCompleted(s_completionAction, this, token, ValueTaskSourceOnCompletedFlags.None);
		}
	}

	private static Task<TResult> s_canceledTask;

	internal readonly object _obj;

	internal readonly TResult _result;

	internal readonly short _token;

	internal readonly bool _continueOnCapturedContext;

	public bool IsCompleted
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			object obj = _obj;
			if (obj == null)
			{
				return true;
			}
			if (obj is Task<TResult> task)
			{
				return task.IsCompleted;
			}
			return Unsafe.As<IValueTaskSource<TResult>>(obj).GetStatus(_token) != ValueTaskSourceStatus.Pending;
		}
	}

	public bool IsCompletedSuccessfully
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			object obj = _obj;
			if (obj == null)
			{
				return true;
			}
			if (obj is Task<TResult> task)
			{
				return task.Status == TaskStatus.RanToCompletion;
			}
			return Unsafe.As<IValueTaskSource<TResult>>(obj).GetStatus(_token) == ValueTaskSourceStatus.Succeeded;
		}
	}

	public bool IsFaulted
	{
		get
		{
			object obj = _obj;
			if (obj == null)
			{
				return false;
			}
			if (obj is Task<TResult> task)
			{
				return task.IsFaulted;
			}
			return Unsafe.As<IValueTaskSource<TResult>>(obj).GetStatus(_token) == ValueTaskSourceStatus.Faulted;
		}
	}

	public bool IsCanceled
	{
		get
		{
			object obj = _obj;
			if (obj == null)
			{
				return false;
			}
			if (obj is Task<TResult> task)
			{
				return task.IsCanceled;
			}
			return Unsafe.As<IValueTaskSource<TResult>>(obj).GetStatus(_token) == ValueTaskSourceStatus.Canceled;
		}
	}

	public TResult Result
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			object obj = _obj;
			if (obj == null)
			{
				return _result;
			}
			if (obj is Task<TResult> task)
			{
				return task.GetAwaiter().GetResult();
			}
			return Unsafe.As<IValueTaskSource<TResult>>(obj).GetResult(_token);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ValueTask(TResult result)
	{
		_result = result;
		_obj = null;
		_continueOnCapturedContext = true;
		_token = 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ValueTask(Task<TResult> task)
	{
		if (task == null)
		{
			<f9b47b20-f8fc-4539-b746-9c209e9728ac>ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.task);
		}
		_obj = task;
		_result = default(TResult);
		_continueOnCapturedContext = true;
		_token = 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ValueTask(IValueTaskSource<TResult> source, short token)
	{
		if (source == null)
		{
			<f9b47b20-f8fc-4539-b746-9c209e9728ac>ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.source);
		}
		_obj = source;
		_token = token;
		_result = default(TResult);
		_continueOnCapturedContext = true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private ValueTask(object obj, TResult result, short token, bool continueOnCapturedContext)
	{
		_obj = obj;
		_result = result;
		_token = token;
		_continueOnCapturedContext = continueOnCapturedContext;
	}

	public override int GetHashCode()
	{
		if (_obj == null)
		{
			if (_result == null)
			{
				return 0;
			}
			return _result.GetHashCode();
		}
		return _obj.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj is ValueTask<TResult>)
		{
			return Equals((ValueTask<TResult>)obj);
		}
		return false;
	}

	public bool Equals(ValueTask<TResult> other)
	{
		if (_obj == null && other._obj == null)
		{
			return EqualityComparer<TResult>.Default.Equals(_result, other._result);
		}
		if (_obj == other._obj)
		{
			return _token == other._token;
		}
		return false;
	}

	public static bool operator ==(ValueTask<TResult> left, ValueTask<TResult> right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(ValueTask<TResult> left, ValueTask<TResult> right)
	{
		return !left.Equals(right);
	}

	public Task<TResult> AsTask()
	{
		object obj = _obj;
		if (obj == null)
		{
			return Task.FromResult(_result);
		}
		if (obj is Task<TResult> result)
		{
			return result;
		}
		return GetTaskForValueTaskSource(Unsafe.As<IValueTaskSource<TResult>>(obj));
	}

	public ValueTask<TResult> Preserve()
	{
		if (_obj != null)
		{
			return new ValueTask<TResult>(AsTask());
		}
		return this;
	}

	private Task<TResult> GetTaskForValueTaskSource(IValueTaskSource<TResult> t)
	{
		ValueTaskSourceStatus status = t.GetStatus(_token);
		if (status != 0)
		{
			try
			{
				return Task.FromResult(t.GetResult(_token));
			}
			catch (Exception exception)
			{
				if (status == ValueTaskSourceStatus.Canceled)
				{
					Task<TResult> task = s_canceledTask;
					if (task == null)
					{
						TaskCompletionSource<TResult> taskCompletionSource = new TaskCompletionSource<TResult>();
						taskCompletionSource.TrySetCanceled();
						task = (s_canceledTask = taskCompletionSource.Task);
					}
					return task;
				}
				TaskCompletionSource<TResult> taskCompletionSource2 = new TaskCompletionSource<TResult>();
				taskCompletionSource2.TrySetException(exception);
				return taskCompletionSource2.Task;
			}
		}
		ValueTaskSourceAsTask valueTaskSourceAsTask = new ValueTaskSourceAsTask(t, _token);
		return valueTaskSourceAsTask.Task;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ValueTaskAwaiter<TResult> GetAwaiter()
	{
		return new ValueTaskAwaiter<TResult>(this);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ConfiguredValueTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext)
	{
		return new ConfiguredValueTaskAwaitable<TResult>(new ValueTask<TResult>(_obj, _result, _token, continueOnCapturedContext));
	}

	public override string ToString()
	{
		if (IsCompletedSuccessfully)
		{
			TResult result = Result;
			if (result != null)
			{
				return result.ToString();
			}
		}
		return string.Empty;
	}
}


using System.Threading.Tasks.Sources;

private sealed class ValueTaskSourceAsTask : TaskCompletionSource<TResult>
{
	private static readonly Action<object> s_completionAction = delegate(object state)
	{
		IValueTaskSource<TResult> source;
		if (!(state is ValueTaskSourceAsTask valueTaskSourceAsTask) || (source = valueTaskSourceAsTask._source) == null)
		{
			<f9b47b20-f8fc-4539-b746-9c209e9728ac>ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.state);
			return;
		}
		valueTaskSourceAsTask._source = null;
		ValueTaskSourceStatus status = source.GetStatus(valueTaskSourceAsTask._token);
		try
		{
			valueTaskSourceAsTask.TrySetResult(source.GetResult(valueTaskSourceAsTask._token));
		}
		catch (Exception exception)
		{
			if (status == ValueTaskSourceStatus.Canceled)
			{
				valueTaskSourceAsTask.TrySetCanceled();
			}
			else
			{
				valueTaskSourceAsTask.TrySetException(exception);
			}
		}
	};

	private IValueTaskSource<TResult> _source;

	private readonly short _token;

	public ValueTaskSourceAsTask(IValueTaskSource<TResult> source, short token)
	{
		_source = source;
		_token = token;
		source.OnCompleted(s_completionAction, this, token, ValueTaskSourceOnCompletedFlags.None);
	}
}


using System;

[Flags]
internal enum ValueTaskSourceOnCompletedFlags
{
	None = 0,
	UseSchedulingContext = 1,
	FlowExecutionContext = 2
}


internal enum ValueTaskSourceStatus
{
	Pending,
	Succeeded,
	Faulted,
	Canceled
}


using System;
using System.Threading.Tasks.Sources;

internal interface IValueTaskSource
{
	ValueTaskSourceStatus GetStatus(short token);

	void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);

	void GetResult(short token);
}


using System;
using System.Threading.Tasks.Sources;

internal interface IValueTaskSource<out TResult>
{
	ValueTaskSourceStatus GetStatus(short token);

	void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);

	TResult GetResult(short token);
}


using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Interface | AttributeTargets.Delegate, Inherited = false, AllowMultiple = false)]
internal sealed class AsyncMethodBuilderAttribute : Attribute
{
	public Type BuilderType { get; }

	public AsyncMethodBuilderAttribute(Type builderType)
	{
		BuilderType = builderType;
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading.Tasks;

[StructLayout(LayoutKind.Auto)]
internal struct AsyncValueTaskMethodBuilder
{
	private AsyncTaskMethodBuilder _methodBuilder;

	private bool _haveResult;

	private bool _useBuilder;

	public ValueTask Task
	{
		get
		{
			if (_haveResult)
			{
				return default(ValueTask);
			}
			_useBuilder = true;
			return new ValueTask(_methodBuilder.Task);
		}
	}

	public static AsyncValueTaskMethodBuilder Create()
	{
		return default(AsyncValueTaskMethodBuilder);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine
	{
		_methodBuilder.Start(ref stateMachine);
	}

	public void SetStateMachine(IAsyncStateMachine stateMachine)
	{
		_methodBuilder.SetStateMachine(stateMachine);
	}

	public void SetResult()
	{
		if (_useBuilder)
		{
			_methodBuilder.SetResult();
		}
		else
		{
			_haveResult = true;
		}
	}

	public void SetException(Exception exception)
	{
		_methodBuilder.SetException(exception);
	}

	public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine
	{
		_useBuilder = true;
		_methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);
	}

	[SecuritySafeCritical]
	public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine
	{
		_useBuilder = true;
		_methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading.Tasks;

[StructLayout(LayoutKind.Auto)]
internal struct AsyncValueTaskMethodBuilder<TResult>
{
	private AsyncTaskMethodBuilder<TResult> _methodBuilder;

	private TResult _result;

	private bool _haveResult;

	private bool _useBuilder;

	public ValueTask<TResult> Task
	{
		get
		{
			if (_haveResult)
			{
				return new ValueTask<TResult>(_result);
			}
			_useBuilder = true;
			return new ValueTask<TResult>(_methodBuilder.Task);
		}
	}

	public static AsyncValueTaskMethodBuilder<TResult> Create()
	{
		return default(AsyncValueTaskMethodBuilder<TResult>);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine
	{
		_methodBuilder.Start(ref stateMachine);
	}

	public void SetStateMachine(IAsyncStateMachine stateMachine)
	{
		_methodBuilder.SetStateMachine(stateMachine);
	}

	public void SetResult(TResult result)
	{
		if (_useBuilder)
		{
			_methodBuilder.SetResult(result);
			return;
		}
		_result = result;
		_haveResult = true;
	}

	public void SetException(Exception exception)
	{
		_methodBuilder.SetException(exception);
	}

	public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine
	{
		_useBuilder = true;
		_methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);
	}

	[SecuritySafeCritical]
	public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine
	{
		_useBuilder = true;
		_methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);
	}
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Threading.Tasks.Sources;

[StructLayout(LayoutKind.Auto)]
[<d1319d0b-8e9a-4832-93a5-07396d9c0bfd>IsReadOnly]
internal struct ConfiguredValueTaskAwaitable
{
	[StructLayout(LayoutKind.Auto)]
	[<d1319d0b-8e9a-4832-93a5-07396d9c0bfd>IsReadOnly]
	public struct ConfiguredValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion
	{
		private readonly ValueTask _value;

		public bool IsCompleted
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return _value.IsCompleted;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal ConfiguredValueTaskAwaiter(ValueTask value)
		{
			_value = value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[StackTraceHidden]
		public void GetResult()
		{
			_value.ThrowIfCompletedUnsuccessfully();
		}

		public void OnCompleted(Action continuation)
		{
			object obj = _value._obj;
			if (obj is Task task)
			{
				task.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().OnCompleted(continuation);
			}
			else if (obj != null)
			{
				Unsafe.As<IValueTaskSource>(obj).OnCompleted(ValueTaskAwaiter.s_invokeActionDelegate, continuation, _value._token, (ValueTaskSourceOnCompletedFlags)(2 | (_value._continueOnCapturedContext ? 1 : 0)));
			}
			else
			{
				ValueTask.CompletedTask.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().OnCompleted(continuation);
			}
		}

		public void UnsafeOnCompleted(Action continuation)
		{
			object obj = _value._obj;
			if (obj is Task task)
			{
				task.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().UnsafeOnCompleted(continuation);
			}
			else if (obj != null)
			{
				Unsafe.As<IValueTaskSource>(obj).OnCompleted(ValueTaskAwaiter.s_invokeActionDelegate, continuation, _value._token, _value._continueOnCapturedContext ? ValueTaskSourceOnCompletedFlags.UseSchedulingContext : ValueTaskSourceOnCompletedFlags.None);
			}
			else
			{
				ValueTask.CompletedTask.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().UnsafeOnCompleted(continuation);
			}
		}
	}

	private readonly ValueTask _value;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal ConfiguredValueTaskAwaitable(ValueTask value)
	{
		_value = value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ConfiguredValueTaskAwaiter GetAwaiter()
	{
		return new ConfiguredValueTaskAwaiter(_value);
	}
}


using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Threading.Tasks.Sources;

[StructLayout(LayoutKind.Auto)]
[<d1319d0b-8e9a-4832-93a5-07396d9c0bfd>IsReadOnly]
public struct ConfiguredValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion
{
	private readonly ValueTask _value;

	public bool IsCompleted
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return _value.IsCompleted;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal ConfiguredValueTaskAwaiter(ValueTask value)
	{
		_value = value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[StackTraceHidden]
	public void GetResult()
	{
		_value.ThrowIfCompletedUnsuccessfully();
	}

	public void OnCompleted(Action continuation)
	{
		object obj = _value._obj;
		if (obj is Task task)
		{
			task.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().OnCompleted(continuation);
		}
		else if (obj != null)
		{
			Unsafe.As<IValueTaskSource>(obj).OnCompleted(ValueTaskAwaiter.s_invokeActionDelegate, continuation, _value._token, (ValueTaskSourceOnCompletedFlags)(2 | (_value._continueOnCapturedContext ? 1 : 0)));
		}
		else
		{
			ValueTask.CompletedTask.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().OnCompleted(continuation);
		}
	}

	public void UnsafeOnCompleted(Action continuation)
	{
		object obj = _value._obj;
		if (obj is Task task)
		{
			task.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().UnsafeOnCompleted(continuation);
		}
		else if (obj != null)
		{
			Unsafe.As<IValueTaskSource>(obj).OnCompleted(ValueTaskAwaiter.s_invokeActionDelegate, continuation, _value._token, _value._continueOnCapturedContext ? ValueTaskSourceOnCompletedFlags.UseSchedulingContext : ValueTaskSourceOnCompletedFlags.None);
		}
		else
		{
			ValueTask.CompletedTask.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().UnsafeOnCompleted(continuation);
		}
	}
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Threading.Tasks.Sources;

[StructLayout(LayoutKind.Auto)]
[<d1319d0b-8e9a-4832-93a5-07396d9c0bfd>IsReadOnly]
internal struct ConfiguredValueTaskAwaitable<TResult>
{
	[StructLayout(LayoutKind.Auto)]
	[<d1319d0b-8e9a-4832-93a5-07396d9c0bfd>IsReadOnly]
	public struct ConfiguredValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion
	{
		private readonly ValueTask<TResult> _value;

		public bool IsCompleted
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return _value.IsCompleted;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal ConfiguredValueTaskAwaiter(ValueTask<TResult> value)
		{
			_value = value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[StackTraceHidden]
		public TResult GetResult()
		{
			return _value.Result;
		}

		public void OnCompleted(Action continuation)
		{
			object obj = _value._obj;
			if (obj is Task<TResult> task)
			{
				task.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().OnCompleted(continuation);
			}
			else if (obj != null)
			{
				Unsafe.As<IValueTaskSource<TResult>>(obj).OnCompleted(ValueTaskAwaiter.s_invokeActionDelegate, continuation, _value._token, (ValueTaskSourceOnCompletedFlags)(2 | (_value._continueOnCapturedContext ? 1 : 0)));
			}
			else
			{
				ValueTask.CompletedTask.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().OnCompleted(continuation);
			}
		}

		public void UnsafeOnCompleted(Action continuation)
		{
			object obj = _value._obj;
			if (obj is Task<TResult> task)
			{
				task.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().UnsafeOnCompleted(continuation);
			}
			else if (obj != null)
			{
				Unsafe.As<IValueTaskSource<TResult>>(obj).OnCompleted(ValueTaskAwaiter.s_invokeActionDelegate, continuation, _value._token, _value._continueOnCapturedContext ? ValueTaskSourceOnCompletedFlags.UseSchedulingContext : ValueTaskSourceOnCompletedFlags.None);
			}
			else
			{
				ValueTask.CompletedTask.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().UnsafeOnCompleted(continuation);
			}
		}
	}

	private readonly ValueTask<TResult> _value;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal ConfiguredValueTaskAwaitable(ValueTask<TResult> value)
	{
		_value = value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ConfiguredValueTaskAwaiter GetAwaiter()
	{
		return new ConfiguredValueTaskAwaiter(_value);
	}
}


using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Threading.Tasks.Sources;

[StructLayout(LayoutKind.Auto)]
[<d1319d0b-8e9a-4832-93a5-07396d9c0bfd>IsReadOnly]
public struct ConfiguredValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion
{
	private readonly ValueTask<TResult> _value;

	public bool IsCompleted
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return _value.IsCompleted;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal ConfiguredValueTaskAwaiter(ValueTask<TResult> value)
	{
		_value = value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[StackTraceHidden]
	public TResult GetResult()
	{
		return _value.Result;
	}

	public void OnCompleted(Action continuation)
	{
		object obj = _value._obj;
		if (obj is Task<TResult> task)
		{
			task.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().OnCompleted(continuation);
		}
		else if (obj != null)
		{
			Unsafe.As<IValueTaskSource<TResult>>(obj).OnCompleted(ValueTaskAwaiter.s_invokeActionDelegate, continuation, _value._token, (ValueTaskSourceOnCompletedFlags)(2 | (_value._continueOnCapturedContext ? 1 : 0)));
		}
		else
		{
			ValueTask.CompletedTask.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().OnCompleted(continuation);
		}
	}

	public void UnsafeOnCompleted(Action continuation)
	{
		object obj = _value._obj;
		if (obj is Task<TResult> task)
		{
			task.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().UnsafeOnCompleted(continuation);
		}
		else if (obj != null)
		{
			Unsafe.As<IValueTaskSource<TResult>>(obj).OnCompleted(ValueTaskAwaiter.s_invokeActionDelegate, continuation, _value._token, _value._continueOnCapturedContext ? ValueTaskSourceOnCompletedFlags.UseSchedulingContext : ValueTaskSourceOnCompletedFlags.None);
		}
		else
		{
			ValueTask.CompletedTask.ConfigureAwait(_value._continueOnCapturedContext).GetAwaiter().UnsafeOnCompleted(continuation);
		}
	}
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using System.Threading.Tasks.Sources;

[<d1319d0b-8e9a-4832-93a5-07396d9c0bfd>IsReadOnly]
internal struct ValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion
{
	internal static readonly Action<object> s_invokeActionDelegate = delegate(object state)
	{
		if (!(state is Action action))
		{
			<f9b47b20-f8fc-4539-b746-9c209e9728ac>ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.state);
		}
		else
		{
			action();
		}
	};

	private readonly ValueTask _value;

	public bool IsCompleted
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return _value.IsCompleted;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal ValueTaskAwaiter(ValueTask value)
	{
		_value = value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[StackTraceHidden]
	public void GetResult()
	{
		_value.ThrowIfCompletedUnsuccessfully();
	}

	public void OnCompleted(Action continuation)
	{
		object obj = _value._obj;
		if (obj is Task task)
		{
			task.GetAwaiter().OnCompleted(continuation);
		}
		else if (obj != null)
		{
			Unsafe.As<IValueTaskSource>(obj).OnCompleted(s_invokeActionDelegate, continuation, _value._token, ValueTaskSourceOnCompletedFlags.UseSchedulingContext | ValueTaskSourceOnCompletedFlags.FlowExecutionContext);
		}
		else
		{
			ValueTask.CompletedTask.GetAwaiter().OnCompleted(continuation);
		}
	}

	public void UnsafeOnCompleted(Action continuation)
	{
		object obj = _value._obj;
		if (obj is Task task)
		{
			task.GetAwaiter().UnsafeOnCompleted(continuation);
		}
		else if (obj != null)
		{
			Unsafe.As<IValueTaskSource>(obj).OnCompleted(s_invokeActionDelegate, continuation, _value._token, ValueTaskSourceOnCompletedFlags.UseSchedulingContext);
		}
		else
		{
			ValueTask.CompletedTask.GetAwaiter().UnsafeOnCompleted(continuation);
		}
	}
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using System.Threading.Tasks.Sources;

[<d1319d0b-8e9a-4832-93a5-07396d9c0bfd>IsReadOnly]
internal struct ValueTaskAwaiter<TResult> : ICriticalNotifyCompletion, INotifyCompletion
{
	private readonly ValueTask<TResult> _value;

	public bool IsCompleted
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return _value.IsCompleted;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal ValueTaskAwaiter(ValueTask<TResult> value)
	{
		_value = value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[StackTraceHidden]
	public TResult GetResult()
	{
		return _value.Result;
	}

	public void OnCompleted(Action continuation)
	{
		object obj = _value._obj;
		if (obj is Task<TResult> task)
		{
			task.GetAwaiter().OnCompleted(continuation);
		}
		else if (obj != null)
		{
			Unsafe.As<IValueTaskSource<TResult>>(obj).OnCompleted(ValueTaskAwaiter.s_invokeActionDelegate, continuation, _value._token, ValueTaskSourceOnCompletedFlags.UseSchedulingContext | ValueTaskSourceOnCompletedFlags.FlowExecutionContext);
		}
		else
		{
			ValueTask.CompletedTask.GetAwaiter().OnCompleted(continuation);
		}
	}

	public void UnsafeOnCompleted(Action continuation)
	{
		object obj = _value._obj;
		if (obj is Task<TResult> task)
		{
			task.GetAwaiter().UnsafeOnCompleted(continuation);
		}
		else if (obj != null)
		{
			Unsafe.As<IValueTaskSource<TResult>>(obj).OnCompleted(ValueTaskAwaiter.s_invokeActionDelegate, continuation, _value._token, ValueTaskSourceOnCompletedFlags.UseSchedulingContext);
		}
		else
		{
			ValueTask.CompletedTask.GetAwaiter().UnsafeOnCompleted(continuation);
		}
	}
}


using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Constructor | AttributeTargets.Method, Inherited = false)]
internal sealed class StackTraceHiddenAttribute : Attribute
{
}


using System;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;

[Embedded]
[CompilerGenerated]
internal sealed class IsByRefLikeAttribute : Attribute
{
}


using System;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;

[Embedded]
[CompilerGenerated]
[AttributeUsage(AttributeTargets.Module, AllowMultiple = false, Inherited = false)]
internal sealed class RefSafetyRulesAttribute : Attribute
{
	public readonly int Version;

	public RefSafetyRulesAttribute(int P_0)
	{
		Version = P_0;
	}
}


internal static class SR
{
}


using System;
using System.Runtime.CompilerServices;

internal static class ThrowHelper
{
	internal static void ThrowIfNull(object? argument, [CallerArgumentExpression("argument")] string? paramName = null)
	{
		if (argument == null)
		{
			Throw(paramName);
		}
	}

	private static void Throw(string paramName)
	{
		throw new ArgumentNullException(paramName);
	}
}


using System;
using System.Resources;
using FxResources.Microsoft.Extensions.Logging.Abstractions;

internal static class SR
{
	private static readonly bool s_usingResourceKeys = AppContext.TryGetSwitch("System.Resources.UseSystemResourceKeys", out var isEnabled) && isEnabled;

	private static ResourceManager s_resourceManager;

	internal static ResourceManager ResourceManager => s_resourceManager ?? (s_resourceManager = new ResourceManager(typeof(SR)));

	internal static string UnexpectedNumberOfNamedParameters => GetResourceString("UnexpectedNumberOfNamedParameters");

	private static bool UsingResourceKeys()
	{
		return s_usingResourceKeys;
	}

	internal static string GetResourceString(string resourceKey)
	{
		if (UsingResourceKeys())
		{
			return resourceKey;
		}
		string result = null;
		try
		{
			result = ResourceManager.GetString(resourceKey);
		}
		catch (MissingManifestResourceException)
		{
		}
		return result;
	}

	internal static string GetResourceString(string resourceKey, string defaultString)
	{
		string resourceString = GetResourceString(resourceKey);
		if (!(resourceKey == resourceString) && resourceString != null)
		{
			return resourceString;
		}
		return defaultString;
	}

	internal static string Format(string resourceFormat, object? p1)
	{
		if (UsingResourceKeys())
		{
			return string.Join(", ", resourceFormat, p1);
		}
		return string.Format(resourceFormat, p1);
	}

	internal static string Format(string resourceFormat, object? p1, object? p2)
	{
		if (UsingResourceKeys())
		{
			return string.Join(", ", resourceFormat, p1, p2);
		}
		return string.Format(resourceFormat, p1, p2);
	}

	internal static string Format(string resourceFormat, object? p1, object? p2, object? p3)
	{
		if (UsingResourceKeys())
		{
			return string.Join(", ", resourceFormat, p1, p2, p3);
		}
		return string.Format(resourceFormat, p1, p2, p3);
	}

	internal static string Format(string resourceFormat, params object?[]? args)
	{
		if (args != null)
		{
			if (UsingResourceKeys())
			{
				return resourceFormat + ", " + string.Join(", ", args);
			}
			return string.Format(resourceFormat, args);
		}
		return resourceFormat;
	}

	internal static string Format(IFormatProvider? provider, string resourceFormat, object? p1)
	{
		if (UsingResourceKeys())
		{
			return string.Join(", ", resourceFormat, p1);
		}
		return string.Format(provider, resourceFormat, p1);
	}

	internal static string Format(IFormatProvider? provider, string resourceFormat, object? p1, object? p2)
	{
		if (UsingResourceKeys())
		{
			return string.Join(", ", resourceFormat, p1, p2);
		}
		return string.Format(provider, resourceFormat, p1, p2);
	}

	internal static string Format(IFormatProvider? provider, string resourceFormat, object? p1, object? p2, object? p3)
	{
		if (UsingResourceKeys())
		{
			return string.Join(", ", resourceFormat, p1, p2, p3);
		}
		return string.Format(provider, resourceFormat, p1, p2, p3);
	}

	internal static string Format(IFormatProvider? provider, string resourceFormat, params object?[]? args)
	{
		if (args != null)
		{
			if (UsingResourceKeys())
			{
				return resourceFormat + ", " + string.Join(", ", args);
			}
			return string.Format(provider, resourceFormat, args);
		}
		return resourceFormat;
	}
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, Inherited = false)]
internal sealed class AllowNullAttribute : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, Inherited = false)]
internal sealed class DisallowNullAttribute : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, Inherited = false)]
internal sealed class MaybeNullAttribute : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, Inherited = false)]
internal sealed class NotNullAttribute : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
internal sealed class MaybeNullWhenAttribute : Attribute
{
	public bool ReturnValue { get; }

	public MaybeNullWhenAttribute(bool returnValue)
	{
		ReturnValue = returnValue;
	}
}


using System;

[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
internal sealed class NotNullWhenAttribute : Attribute
{
	public bool ReturnValue { get; }

	public NotNullWhenAttribute(bool returnValue)
	{
		ReturnValue = returnValue;
	}
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]
internal sealed class NotNullIfNotNullAttribute : Attribute
{
	public string ParameterName { get; }

	public NotNullIfNotNullAttribute(string parameterName)
	{
		ParameterName = parameterName;
	}
}


using System;

[AttributeUsage(AttributeTargets.Method, Inherited = false)]
internal sealed class DoesNotReturnAttribute : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
internal sealed class DoesNotReturnIfAttribute : Attribute
{
	public bool ParameterValue { get; }

	public DoesNotReturnIfAttribute(bool parameterValue)
	{
		ParameterValue = parameterValue;
	}
}


using System;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
internal sealed class MemberNotNullAttribute : Attribute
{
	public string[] Members { get; }

	public MemberNotNullAttribute(string member)
	{
		Members = new string[1] { member };
	}

	public MemberNotNullAttribute(params string[] members)
	{
		Members = members;
	}
}


using System;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
internal sealed class MemberNotNullWhenAttribute : Attribute
{
	public bool ReturnValue { get; }

	public string[] Members { get; }

	public MemberNotNullWhenAttribute(bool returnValue, string member)
	{
		ReturnValue = returnValue;
		Members = new string[1] { member };
	}

	public MemberNotNullWhenAttribute(bool returnValue, params string[] members)
	{
		ReturnValue = returnValue;
		Members = members;
	}
}


using System;
using System.Runtime.InteropServices;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
internal sealed class LibraryImportAttribute : Attribute
{
	public string LibraryName { get; }

	public string? EntryPoint { get; set; }

	public StringMarshalling StringMarshalling { get; set; }

	public Type? StringMarshallingCustomType { get; set; }

	public bool SetLastError { get; set; }

	public LibraryImportAttribute(string libraryName)
	{
		LibraryName = libraryName;
	}
}


internal enum StringMarshalling
{
	Custom,
	Utf8,
	Utf16
}


using System;

[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
internal sealed class CallerArgumentExpressionAttribute : Attribute
{
	public string ParameterName { get; }

	public CallerArgumentExpressionAttribute(string parameterName)
	{
		ParameterName = parameterName;
	}
}


using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

internal ref struct ValueStringBuilder
{
	private char[] _arrayToReturnToPool;

	private Span<char> _chars;

	private int _pos;

	public int Length
	{
		get
		{
			return _pos;
		}
		set
		{
			_pos = value;
		}
	}

	public int Capacity => _chars.Length;

	public ref char this[int index] => ref _chars[index];

	public Span<char> RawChars => _chars;

	public ValueStringBuilder(Span<char> initialBuffer)
	{
		_arrayToReturnToPool = null;
		_chars = initialBuffer;
		_pos = 0;
	}

	public ValueStringBuilder(int initialCapacity)
	{
		_arrayToReturnToPool = ArrayPool<char>.Shared.Rent(initialCapacity);
		_chars = _arrayToReturnToPool;
		_pos = 0;
	}

	public void EnsureCapacity(int capacity)
	{
		if ((uint)capacity > (uint)_chars.Length)
		{
			Grow(capacity - _pos);
		}
	}

	public ref char GetPinnableReference()
	{
		return ref MemoryMarshal.GetReference(_chars);
	}

	public ref char GetPinnableReference(bool terminate)
	{
		if (terminate)
		{
			EnsureCapacity(Length + 1);
			_chars[Length] = '\0';
		}
		return ref MemoryMarshal.GetReference(_chars);
	}

	public override string ToString()
	{
		string result = _chars.Slice(0, _pos).ToString();
		Dispose();
		return result;
	}

	public ReadOnlySpan<char> AsSpan(bool terminate)
	{
		if (terminate)
		{
			EnsureCapacity(Length + 1);
			_chars[Length] = '\0';
		}
		return _chars.Slice(0, _pos);
	}

	public ReadOnlySpan<char> AsSpan()
	{
		return _chars.Slice(0, _pos);
	}

	public ReadOnlySpan<char> AsSpan(int start)
	{
		return _chars.Slice(start, _pos - start);
	}

	public ReadOnlySpan<char> AsSpan(int start, int length)
	{
		return _chars.Slice(start, length);
	}

	public bool TryCopyTo(Span<char> destination, out int charsWritten)
	{
		if (_chars.Slice(0, _pos).TryCopyTo(destination))
		{
			charsWritten = _pos;
			Dispose();
			return true;
		}
		charsWritten = 0;
		Dispose();
		return false;
	}

	public void Insert(int index, char value, int count)
	{
		if (_pos > _chars.Length - count)
		{
			Grow(count);
		}
		int length = _pos - index;
		_chars.Slice(index, length).CopyTo(_chars.Slice(index + count));
		_chars.Slice(index, count).Fill(value);
		_pos += count;
	}

	public void Insert(int index, string? s)
	{
		if (s != null)
		{
			int length = s.Length;
			if (_pos > _chars.Length - length)
			{
				Grow(length);
			}
			int length2 = _pos - index;
			_chars.Slice(index, length2).CopyTo(_chars.Slice(index + length));
			MemoryExtensions.AsSpan(s).CopyTo(_chars.Slice(index));
			_pos += length;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Append(char c)
	{
		int pos = _pos;
		if ((uint)pos < (uint)_chars.Length)
		{
			_chars[pos] = c;
			_pos = pos + 1;
		}
		else
		{
			GrowAndAppend(c);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Append(string? s)
	{
		if (s != null)
		{
			int pos = _pos;
			if (s.Length == 1 && (uint)pos < (uint)_chars.Length)
			{
				_chars[pos] = s[0];
				_pos = pos + 1;
			}
			else
			{
				AppendSlow(s);
			}
		}
	}

	private void AppendSlow(string s)
	{
		int pos = _pos;
		if (pos > _chars.Length - s.Length)
		{
			Grow(s.Length);
		}
		MemoryExtensions.AsSpan(s).CopyTo(_chars.Slice(pos));
		_pos += s.Length;
	}

	public void Append(char c, int count)
	{
		if (_pos > _chars.Length - count)
		{
			Grow(count);
		}
		Span<char> span = _chars.Slice(_pos, count);
		for (int i = 0; i < span.Length; i++)
		{
			span[i] = c;
		}
		_pos += count;
	}

	public unsafe void Append(char* value, int length)
	{
		int pos = _pos;
		if (pos > _chars.Length - length)
		{
			Grow(length);
		}
		Span<char> span = _chars.Slice(_pos, length);
		for (int i = 0; i < span.Length; i++)
		{
			span[i] = *(value++);
		}
		_pos += length;
	}

	public void Append(ReadOnlySpan<char> value)
	{
		int pos = _pos;
		if (pos > _chars.Length - value.Length)
		{
			Grow(value.Length);
		}
		value.CopyTo(_chars.Slice(_pos));
		_pos += value.Length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Span<char> AppendSpan(int length)
	{
		int pos = _pos;
		if (pos > _chars.Length - length)
		{
			Grow(length);
		}
		_pos = pos + length;
		return _chars.Slice(pos, length);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void GrowAndAppend(char c)
	{
		Grow(1);
		Append(c);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void Grow(int additionalCapacityBeyondPos)
	{
		int minimumLength = (int)Math.Max((uint)(_pos + additionalCapacityBeyondPos), Math.Min((uint)(_chars.Length * 2), 2147483591u));
		char[] array = ArrayPool<char>.Shared.Rent(minimumLength);
		_chars.Slice(0, _pos).CopyTo(array);
		char[] arrayToReturnToPool = _arrayToReturnToPool;
		_chars = (_arrayToReturnToPool = array);
		if (arrayToReturnToPool != null)
		{
			ArrayPool<char>.Shared.Return(arrayToReturnToPool);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Dispose()
	{
		char[] arrayToReturnToPool = _arrayToReturnToPool;
		this = default(System.Text.ValueStringBuilder);
		if (arrayToReturnToPool != null)
		{
			ArrayPool<char>.Shared.Return(arrayToReturnToPool);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text;
using Microsoft.Extensions.Internal;

internal static class TypeNameHelper
{
	private readonly struct DisplayNameOptions
	{
		public bool FullName { get; }

		public bool IncludeGenericParameters { get; }

		public bool IncludeGenericParameterNames { get; }

		public char NestedTypeDelimiter { get; }

		public DisplayNameOptions(bool fullName, bool includeGenericParameterNames, bool includeGenericParameters, char nestedTypeDelimiter)
		{
			FullName = fullName;
			IncludeGenericParameters = includeGenericParameters;
			IncludeGenericParameterNames = includeGenericParameterNames;
			NestedTypeDelimiter = nestedTypeDelimiter;
		}
	}

	private const char DefaultNestedTypeDelimiter = '+';

	private static readonly Dictionary<Type, string> _builtInTypeNames = new Dictionary<Type, string>
	{
		{
			typeof(void),
			"void"
		},
		{
			typeof(bool),
			"bool"
		},
		{
			typeof(byte),
			"byte"
		},
		{
			typeof(char),
			"char"
		},
		{
			typeof(decimal),
			"decimal"
		},
		{
			typeof(double),
			"double"
		},
		{
			typeof(float),
			"float"
		},
		{
			typeof(int),
			"int"
		},
		{
			typeof(long),
			"long"
		},
		{
			typeof(object),
			"object"
		},
		{
			typeof(sbyte),
			"sbyte"
		},
		{
			typeof(short),
			"short"
		},
		{
			typeof(string),
			"string"
		},
		{
			typeof(uint),
			"uint"
		},
		{
			typeof(ulong),
			"ulong"
		},
		{
			typeof(ushort),
			"ushort"
		}
	};

	[return: NotNullIfNotNull("item")]
	public static string? GetTypeDisplayName(object? item, bool fullName = true)
	{
		if (item != null)
		{
			return GetTypeDisplayName(item.GetType(), fullName);
		}
		return null;
	}

	public static string GetTypeDisplayName(Type type, bool fullName = true, bool includeGenericParameterNames = false, bool includeGenericParameters = true, char nestedTypeDelimiter = '+')
	{
		StringBuilder stringBuilder = new StringBuilder();
		ProcessType(stringBuilder, type, new DisplayNameOptions(fullName, includeGenericParameterNames, includeGenericParameters, nestedTypeDelimiter));
		return stringBuilder.ToString();
	}

	private static void ProcessType(StringBuilder builder, Type type, in DisplayNameOptions options)
	{
		if (type.IsGenericType)
		{
			Type[] genericArguments = type.GetGenericArguments();
			ProcessGenericType(builder, type, genericArguments, genericArguments.Length, in options);
			return;
		}
		if (type.IsArray)
		{
			ProcessArrayType(builder, type, in options);
			return;
		}
		if (_builtInTypeNames.TryGetValue(type, out var value))
		{
			builder.Append(value);
			return;
		}
		if (type.IsGenericParameter)
		{
			if (options.IncludeGenericParameterNames)
			{
				builder.Append(type.Name);
			}
			return;
		}
		string text = (options.FullName ? type.FullName : type.Name);
		builder.Append(text);
		if (options.NestedTypeDelimiter != '+')
		{
			builder.Replace('+', options.NestedTypeDelimiter, builder.Length - text.Length, text.Length);
		}
	}

	private static void ProcessArrayType(StringBuilder builder, Type type, in DisplayNameOptions options)
	{
		Type type2 = type;
		while (type2.IsArray)
		{
			type2 = type2.GetElementType();
		}
		ProcessType(builder, type2, in options);
		while (type.IsArray)
		{
			builder.Append('[');
			builder.Append(',', type.GetArrayRank() - 1);
			builder.Append(']');
			type = type.GetElementType();
		}
	}

	private static void ProcessGenericType(StringBuilder builder, Type type, Type[] genericArguments, int length, in DisplayNameOptions options)
	{
		int num = 0;
		if (type.IsNested)
		{
			num = type.DeclaringType.GetGenericArguments().Length;
		}
		if (options.FullName)
		{
			if (type.IsNested)
			{
				ProcessGenericType(builder, type.DeclaringType, genericArguments, num, in options);
				builder.Append(options.NestedTypeDelimiter);
			}
			else if (!string.IsNullOrEmpty(type.Namespace))
			{
				builder.Append(type.Namespace);
				builder.Append('.');
			}
		}
		int num2 = type.Name.IndexOf('`');
		if (num2 <= 0)
		{
			builder.Append(type.Name);
			return;
		}
		builder.Append(type.Name, 0, num2);
		if (!options.IncludeGenericParameters)
		{
			return;
		}
		builder.Append('<');
		for (int i = num; i < length; i++)
		{
			ProcessType(builder, genericArguments[i], in options);
			if (i + 1 != length)
			{
				builder.Append(',');
				if (options.IncludeGenericParameterNames || !genericArguments[i + 1].IsGenericParameter)
				{
					builder.Append(' ');
				}
			}
		}
		builder.Append('>');
	}
}


private readonly struct DisplayNameOptions
{
	public bool FullName { get; }

	public bool IncludeGenericParameters { get; }

	public bool IncludeGenericParameterNames { get; }

	public char NestedTypeDelimiter { get; }

	public DisplayNameOptions(bool fullName, bool includeGenericParameterNames, bool includeGenericParameters, char nestedTypeDelimiter)
	{
		FullName = fullName;
		IncludeGenericParameters = includeGenericParameters;
		IncludeGenericParameterNames = includeGenericParameterNames;
		NestedTypeDelimiter = nestedTypeDelimiter;
	}
}


using System;
using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;

internal readonly struct EventId : IEquatable<EventId>
{
	public int Id { get; }

	public string? Name { get; }

	public static implicit operator EventId(int i)
	{
		return new EventId(i);
	}

	public static bool operator ==(EventId left, EventId right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(EventId left, EventId right)
	{
		return !left.Equals(right);
	}

	public EventId(int id, string? name = null)
	{
		Id = id;
		Name = name;
	}

	public override string ToString()
	{
		return Name ?? Id.ToString();
	}

	public bool Equals(EventId other)
	{
		return Id == other.Id;
	}

	public override bool Equals([NotNullWhen(true)] object? obj)
	{
		if (obj == null)
		{
			return false;
		}
		if (obj is EventId other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return Id;
	}
}


using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading;
using Microsoft.Extensions.Logging;

internal readonly struct FormattedLogValues : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	internal const int MaxCachedFormatters = 1024;

	private const string NullFormat = "[null]";

	private static int _count;

	private static ConcurrentDictionary<string, LogValuesFormatter> _formatters = new ConcurrentDictionary<string, LogValuesFormatter>();

	private readonly LogValuesFormatter _formatter;

	private readonly object[] _values;

	private readonly string _originalMessage;

	internal LogValuesFormatter? Formatter => _formatter;

	public KeyValuePair<string, object?> this[int index]
	{
		get
		{
			if (index < 0 || index >= Count)
			{
				throw new IndexOutOfRangeException("index");
			}
			if (index == Count - 1)
			{
				return new KeyValuePair<string, object>("{OriginalFormat}", _originalMessage);
			}
			return _formatter.GetValue(_values, index);
		}
	}

	public int Count
	{
		get
		{
			if (_formatter == null)
			{
				return 1;
			}
			return _formatter.ValueNames.Count + 1;
		}
	}

	public FormattedLogValues(string? format, params object?[]? values)
	{
		if (values != null && values.Length != 0 && format != null)
		{
			if (_count >= 1024)
			{
				if (!_formatters.TryGetValue(format, out _formatter))
				{
					_formatter = new LogValuesFormatter(format);
				}
			}
			else
			{
				_formatter = _formatters.GetOrAdd(format, delegate(string f)
				{
					Interlocked.Increment(ref _count);
					return new LogValuesFormatter(f);
				});
			}
		}
		else
		{
			_formatter = null;
		}
		_originalMessage = format ?? "[null]";
		_values = values;
	}

	public IEnumerator<KeyValuePair<string, object?>> GetEnumerator()
	{
		int i = 0;
		while (i < Count)
		{
			yield return this[i];
			int num = i + 1;
			i = num;
		}
	}

	public override string ToString()
	{
		if (_formatter == null)
		{
			return _originalMessage;
		}
		return _formatter.Format(_values);
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;

internal interface IExternalScopeProvider
{
	void ForEachScope<TState>(Action<object?, TState> callback, TState state);

	IDisposable Push(object? state);
}


using System;
using Microsoft.Extensions.Logging;

internal interface ILogger
{
	void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter);

	bool IsEnabled(LogLevel logLevel);

	IDisposable? BeginScope<TState>(TState state) where TState : notnull;
}


using System;
using Microsoft.Extensions.Logging;

internal interface ILoggerFactory : IDisposable
{
	ILogger CreateLogger(string categoryName);

	void AddProvider(ILoggerProvider provider);
}


using System;
using Microsoft.Extensions.Logging;

internal interface ILoggerProvider : IDisposable
{
	ILogger CreateLogger(string categoryName);
}


using Microsoft.Extensions.Logging;

internal interface ILogger<out TCategoryName> : ILogger
{
}


using Microsoft.Extensions.Logging;

internal interface ISupportExternalScope
{
	void SetScopeProvider(IExternalScopeProvider scopeProvider);
}


internal class LogDefineOptions
{
	public bool SkipEnabledCheck { get; set; }
}


using System;
using Microsoft.Extensions.Logging;

internal static class LoggerExtensions
{
	private static readonly Func<FormattedLogValues, Exception, string> _messageFormatter = MessageFormatter;

	public static void LogDebug(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Debug, eventId, exception, message, args);
	}

	public static void LogDebug(this ILogger logger, EventId eventId, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Debug, eventId, message, args);
	}

	public static void LogDebug(this ILogger logger, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Debug, exception, message, args);
	}

	public static void LogDebug(this ILogger logger, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Debug, message, args);
	}

	public static void LogTrace(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Trace, eventId, exception, message, args);
	}

	public static void LogTrace(this ILogger logger, EventId eventId, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Trace, eventId, message, args);
	}

	public static void LogTrace(this ILogger logger, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Trace, exception, message, args);
	}

	public static void LogTrace(this ILogger logger, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Trace, message, args);
	}

	public static void LogInformation(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Information, eventId, exception, message, args);
	}

	public static void LogInformation(this ILogger logger, EventId eventId, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Information, eventId, message, args);
	}

	public static void LogInformation(this ILogger logger, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Information, exception, message, args);
	}

	public static void LogInformation(this ILogger logger, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Information, message, args);
	}

	public static void LogWarning(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Warning, eventId, exception, message, args);
	}

	public static void LogWarning(this ILogger logger, EventId eventId, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Warning, eventId, message, args);
	}

	public static void LogWarning(this ILogger logger, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Warning, exception, message, args);
	}

	public static void LogWarning(this ILogger logger, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Warning, message, args);
	}

	public static void LogError(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Error, eventId, exception, message, args);
	}

	public static void LogError(this ILogger logger, EventId eventId, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Error, eventId, message, args);
	}

	public static void LogError(this ILogger logger, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Error, exception, message, args);
	}

	public static void LogError(this ILogger logger, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Error, message, args);
	}

	public static void LogCritical(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Critical, eventId, exception, message, args);
	}

	public static void LogCritical(this ILogger logger, EventId eventId, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Critical, eventId, message, args);
	}

	public static void LogCritical(this ILogger logger, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Critical, exception, message, args);
	}

	public static void LogCritical(this ILogger logger, string? message, params object?[] args)
	{
		logger.Log(LogLevel.Critical, message, args);
	}

	public static void Log(this ILogger logger, LogLevel logLevel, string? message, params object?[] args)
	{
		logger.Log(logLevel, 0, null, message, args);
	}

	public static void Log(this ILogger logger, LogLevel logLevel, EventId eventId, string? message, params object?[] args)
	{
		logger.Log(logLevel, eventId, null, message, args);
	}

	public static void Log(this ILogger logger, LogLevel logLevel, Exception? exception, string? message, params object?[] args)
	{
		logger.Log(logLevel, 0, exception, message, args);
	}

	public static void Log(this ILogger logger, LogLevel logLevel, EventId eventId, Exception? exception, string? message, params object?[] args)
	{
		System.ThrowHelper.ThrowIfNull(logger, "logger");
		logger.Log(logLevel, eventId, new FormattedLogValues(message, args), exception, _messageFormatter);
	}

	public static IDisposable? BeginScope(this ILogger logger, string messageFormat, params object?[] args)
	{
		System.ThrowHelper.ThrowIfNull(logger, "logger");
		return logger.BeginScope(new FormattedLogValues(messageFormat, args));
	}

	private static string MessageFormatter(FormattedLogValues state, Exception error)
	{
		return state.ToString();
	}
}


using System;
using System.Threading;
using Microsoft.Extensions.Logging;

internal class LoggerExternalScopeProvider : IExternalScopeProvider
{
	private sealed class Scope : IDisposable
	{
		private readonly LoggerExternalScopeProvider _provider;

		private bool _isDisposed;

		public Scope Parent { get; }

		public object State { get; }

		internal Scope(LoggerExternalScopeProvider provider, object state, Scope parent)
		{
			_provider = provider;
			State = state;
			Parent = parent;
		}

		public override string ToString()
		{
			return State?.ToString();
		}

		public void Dispose()
		{
			if (!_isDisposed)
			{
				_provider._currentScope.Value = Parent;
				_isDisposed = true;
			}
		}
	}

	private readonly AsyncLocal<Scope> _currentScope = new AsyncLocal<Scope>();

	public void ForEachScope<TState>(Action<object?, TState> callback, TState state)
	{
		Report(_currentScope.Value);
		void Report(Scope? current)
		{
			if (current != null)
			{
				Report(current.Parent);
				callback(current.State, state);
			}
		}
	}

	public IDisposable Push(object? state)
	{
		Scope value = _currentScope.Value;
		Scope scope = new Scope(this, state, value);
		_currentScope.Value = scope;
		return scope;
	}
}


using System;

private sealed class Scope : IDisposable
{
	private readonly LoggerExternalScopeProvider _provider;

	private bool _isDisposed;

	public Scope Parent { get; }

	public object State { get; }

	internal Scope(LoggerExternalScopeProvider provider, object state, Scope parent)
	{
		_provider = provider;
		State = state;
		Parent = parent;
	}

	public override string ToString()
	{
		return State?.ToString();
	}

	public void Dispose()
	{
		if (!_isDisposed)
		{
			_provider._currentScope.Value = Parent;
			_isDisposed = true;
		}
	}
}


using System;
using Microsoft.Extensions.Internal;
using Microsoft.Extensions.Logging;

internal static class LoggerFactoryExtensions
{
	public static ILogger<T> CreateLogger<T>(this ILoggerFactory factory)
	{
		System.ThrowHelper.ThrowIfNull(factory, "factory");
		return new Logger<T>(factory);
	}

	public static ILogger CreateLogger(this ILoggerFactory factory, Type type)
	{
		System.ThrowHelper.ThrowIfNull(factory, "factory");
		System.ThrowHelper.ThrowIfNull(type, "type");
		return factory.CreateLogger(TypeNameHelper.GetTypeDisplayName(type, fullName: true, includeGenericParameterNames: false, includeGenericParameters: false, '.'));
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Microsoft.Extensions.Logging;

internal static class LoggerMessage
{
	private readonly struct LogValues : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		public static readonly Func<LogValues, Exception, string> Callback = (LogValues state, Exception exception) => state.ToString();

		private readonly LogValuesFormatter _formatter;

		public KeyValuePair<string, object> this[int index]
		{
			get
			{
				if (index == 0)
				{
					return new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat);
				}
				throw new IndexOutOfRangeException("index");
			}
		}

		public int Count => 1;

		public LogValues(LogValuesFormatter formatter)
		{
			_formatter = formatter;
		}

		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			yield return this[0];
		}

		public override string ToString()
		{
			return _formatter.Format();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	private readonly struct LogValues<T0> : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		public static readonly Func<LogValues<T0>, Exception, string> Callback = (LogValues<T0> state, Exception exception) => state.ToString();

		private readonly LogValuesFormatter _formatter;

		private readonly T0 _value0;

		public KeyValuePair<string, object> this[int index] => index switch
		{
			0 => new KeyValuePair<string, object>(_formatter.ValueNames[0], _value0), 
			1 => new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat), 
			_ => throw new IndexOutOfRangeException("index"), 
		};

		public int Count => 2;

		public LogValues(LogValuesFormatter formatter, T0 value0)
		{
			_formatter = formatter;
			_value0 = value0;
		}

		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			int i = 0;
			while (i < Count)
			{
				yield return this[i];
				int num = i + 1;
				i = num;
			}
		}

		public override string ToString()
		{
			return _formatter.Format(_value0);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	private readonly struct LogValues<T0, T1> : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		public static readonly Func<LogValues<T0, T1>, Exception, string> Callback = (LogValues<T0, T1> state, Exception exception) => state.ToString();

		private readonly LogValuesFormatter _formatter;

		private readonly T0 _value0;

		private readonly T1 _value1;

		public KeyValuePair<string, object> this[int index] => index switch
		{
			0 => new KeyValuePair<string, object>(_formatter.ValueNames[0], _value0), 
			1 => new KeyValuePair<string, object>(_formatter.ValueNames[1], _value1), 
			2 => new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat), 
			_ => throw new IndexOutOfRangeException("index"), 
		};

		public int Count => 3;

		public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1)
		{
			_formatter = formatter;
			_value0 = value0;
			_value1 = value1;
		}

		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			int i = 0;
			while (i < Count)
			{
				yield return this[i];
				int num = i + 1;
				i = num;
			}
		}

		public override string ToString()
		{
			return _formatter.Format(_value0, _value1);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	private readonly struct LogValues<T0, T1, T2> : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		public static readonly Func<LogValues<T0, T1, T2>, Exception, string> Callback = (LogValues<T0, T1, T2> state, Exception exception) => state.ToString();

		private readonly LogValuesFormatter _formatter;

		private readonly T0 _value0;

		private readonly T1 _value1;

		private readonly T2 _value2;

		public int Count => 4;

		public KeyValuePair<string, object> this[int index] => index switch
		{
			0 => new KeyValuePair<string, object>(_formatter.ValueNames[0], _value0), 
			1 => new KeyValuePair<string, object>(_formatter.ValueNames[1], _value1), 
			2 => new KeyValuePair<string, object>(_formatter.ValueNames[2], _value2), 
			3 => new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat), 
			_ => throw new IndexOutOfRangeException("index"), 
		};

		public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1, T2 value2)
		{
			_formatter = formatter;
			_value0 = value0;
			_value1 = value1;
			_value2 = value2;
		}

		public override string ToString()
		{
			return _formatter.Format(_value0, _value1, _value2);
		}

		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			int i = 0;
			while (i < Count)
			{
				yield return this[i];
				int num = i + 1;
				i = num;
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	private readonly struct LogValues<T0, T1, T2, T3> : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		public static readonly Func<LogValues<T0, T1, T2, T3>, Exception, string> Callback = (LogValues<T0, T1, T2, T3> state, Exception exception) => state.ToString();

		private readonly LogValuesFormatter _formatter;

		private readonly T0 _value0;

		private readonly T1 _value1;

		private readonly T2 _value2;

		private readonly T3 _value3;

		public int Count => 5;

		public KeyValuePair<string, object> this[int index] => index switch
		{
			0 => new KeyValuePair<string, object>(_formatter.ValueNames[0], _value0), 
			1 => new KeyValuePair<string, object>(_formatter.ValueNames[1], _value1), 
			2 => new KeyValuePair<string, object>(_formatter.ValueNames[2], _value2), 
			3 => new KeyValuePair<string, object>(_formatter.ValueNames[3], _value3), 
			4 => new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat), 
			_ => throw new IndexOutOfRangeException("index"), 
		};

		public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1, T2 value2, T3 value3)
		{
			_formatter = formatter;
			_value0 = value0;
			_value1 = value1;
			_value2 = value2;
			_value3 = value3;
		}

		private object[] ToArray()
		{
			return new object[4] { _value0, _value1, _value2, _value3 };
		}

		public override string ToString()
		{
			return _formatter.FormatWithOverwrite(ToArray());
		}

		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			int i = 0;
			while (i < Count)
			{
				yield return this[i];
				int num = i + 1;
				i = num;
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	private readonly struct LogValues<T0, T1, T2, T3, T4> : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		public static readonly Func<LogValues<T0, T1, T2, T3, T4>, Exception, string> Callback = (LogValues<T0, T1, T2, T3, T4> state, Exception exception) => state.ToString();

		private readonly LogValuesFormatter _formatter;

		private readonly T0 _value0;

		private readonly T1 _value1;

		private readonly T2 _value2;

		private readonly T3 _value3;

		private readonly T4 _value4;

		public int Count => 6;

		public KeyValuePair<string, object> this[int index] => index switch
		{
			0 => new KeyValuePair<string, object>(_formatter.ValueNames[0], _value0), 
			1 => new KeyValuePair<string, object>(_formatter.ValueNames[1], _value1), 
			2 => new KeyValuePair<string, object>(_formatter.ValueNames[2], _value2), 
			3 => new KeyValuePair<string, object>(_formatter.ValueNames[3], _value3), 
			4 => new KeyValuePair<string, object>(_formatter.ValueNames[4], _value4), 
			5 => new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat), 
			_ => throw new IndexOutOfRangeException("index"), 
		};

		public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1, T2 value2, T3 value3, T4 value4)
		{
			_formatter = formatter;
			_value0 = value0;
			_value1 = value1;
			_value2 = value2;
			_value3 = value3;
			_value4 = value4;
		}

		private object[] ToArray()
		{
			return new object[5] { _value0, _value1, _value2, _value3, _value4 };
		}

		public override string ToString()
		{
			return _formatter.FormatWithOverwrite(ToArray());
		}

		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			int i = 0;
			while (i < Count)
			{
				yield return this[i];
				int num = i + 1;
				i = num;
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	private readonly struct LogValues<T0, T1, T2, T3, T4, T5> : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		public static readonly Func<LogValues<T0, T1, T2, T3, T4, T5>, Exception, string> Callback = (LogValues<T0, T1, T2, T3, T4, T5> state, Exception exception) => state.ToString();

		private readonly LogValuesFormatter _formatter;

		private readonly T0 _value0;

		private readonly T1 _value1;

		private readonly T2 _value2;

		private readonly T3 _value3;

		private readonly T4 _value4;

		private readonly T5 _value5;

		public int Count => 7;

		public KeyValuePair<string, object> this[int index] => index switch
		{
			0 => new KeyValuePair<string, object>(_formatter.ValueNames[0], _value0), 
			1 => new KeyValuePair<string, object>(_formatter.ValueNames[1], _value1), 
			2 => new KeyValuePair<string, object>(_formatter.ValueNames[2], _value2), 
			3 => new KeyValuePair<string, object>(_formatter.ValueNames[3], _value3), 
			4 => new KeyValuePair<string, object>(_formatter.ValueNames[4], _value4), 
			5 => new KeyValuePair<string, object>(_formatter.ValueNames[5], _value5), 
			6 => new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat), 
			_ => throw new IndexOutOfRangeException("index"), 
		};

		public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)
		{
			_formatter = formatter;
			_value0 = value0;
			_value1 = value1;
			_value2 = value2;
			_value3 = value3;
			_value4 = value4;
			_value5 = value5;
		}

		private object[] ToArray()
		{
			return new object[6] { _value0, _value1, _value2, _value3, _value4, _value5 };
		}

		public override string ToString()
		{
			return _formatter.FormatWithOverwrite(ToArray());
		}

		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			int i = 0;
			while (i < Count)
			{
				yield return this[i];
				int num = i + 1;
				i = num;
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	public static Func<ILogger, IDisposable?> DefineScope(string formatString)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 0);
		LogValues logValues = new LogValues(formatter);
		return (ILogger logger) => logger.BeginScope(logValues);
	}

	public static Func<ILogger, T1, IDisposable?> DefineScope<T1>(string formatString)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 1);
		return (ILogger logger, T1 arg1) => logger.BeginScope(new LogValues<T1>(formatter, arg1));
	}

	public static Func<ILogger, T1, T2, IDisposable?> DefineScope<T1, T2>(string formatString)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 2);
		return (ILogger logger, T1 arg1, T2 arg2) => logger.BeginScope(new LogValues<T1, T2>(formatter, arg1, arg2));
	}

	public static Func<ILogger, T1, T2, T3, IDisposable?> DefineScope<T1, T2, T3>(string formatString)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 3);
		return (ILogger logger, T1 arg1, T2 arg2, T3 arg3) => logger.BeginScope(new LogValues<T1, T2, T3>(formatter, arg1, arg2, arg3));
	}

	public static Func<ILogger, T1, T2, T3, T4, IDisposable?> DefineScope<T1, T2, T3, T4>(string formatString)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 4);
		return (ILogger logger, T1 arg1, T2 arg2, T3 arg3, T4 arg4) => logger.BeginScope(new LogValues<T1, T2, T3, T4>(formatter, arg1, arg2, arg3, arg4));
	}

	public static Func<ILogger, T1, T2, T3, T4, T5, IDisposable?> DefineScope<T1, T2, T3, T4, T5>(string formatString)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 5);
		return (ILogger logger, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) => logger.BeginScope(new LogValues<T1, T2, T3, T4, T5>(formatter, arg1, arg2, arg3, arg4, arg5));
	}

	public static Func<ILogger, T1, T2, T3, T4, T5, T6, IDisposable?> DefineScope<T1, T2, T3, T4, T5, T6>(string formatString)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 6);
		return (ILogger logger, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) => logger.BeginScope(new LogValues<T1, T2, T3, T4, T5, T6>(formatter, arg1, arg2, arg3, arg4, arg5, arg6));
	}

	public static Action<ILogger, Exception?> Define(LogLevel logLevel, EventId eventId, string formatString)
	{
		return Define(logLevel, eventId, formatString, null);
	}

	public static Action<ILogger, Exception?> Define(LogLevel logLevel, EventId eventId, string formatString, LogDefineOptions? options)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 0);
		if (options != null && options.SkipEnabledCheck)
		{
			return Log;
		}
		return delegate(ILogger logger, Exception exception)
		{
			if (logger.IsEnabled(logLevel))
			{
				Log(logger, exception);
			}
		};
		void Log(ILogger logger, Exception exception)
		{
			logger.Log(logLevel, eventId, new LogValues(formatter), exception, LogValues.Callback);
		}
	}

	public static Action<ILogger, T1, Exception?> Define<T1>(LogLevel logLevel, EventId eventId, string formatString)
	{
		return Define<T1>(logLevel, eventId, formatString, null);
	}

	public static Action<ILogger, T1, Exception?> Define<T1>(LogLevel logLevel, EventId eventId, string formatString, LogDefineOptions? options)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 1);
		if (options != null && options.SkipEnabledCheck)
		{
			return Log;
		}
		return delegate(ILogger logger, T1 arg1, Exception exception)
		{
			if (logger.IsEnabled(logLevel))
			{
				Log(logger, arg1, exception);
			}
		};
		void Log(ILogger logger, T1 arg1, Exception exception)
		{
			logger.Log(logLevel, eventId, new LogValues<T1>(formatter, arg1), exception, LogValues<T1>.Callback);
		}
	}

	public static Action<ILogger, T1, T2, Exception?> Define<T1, T2>(LogLevel logLevel, EventId eventId, string formatString)
	{
		return Define<T1, T2>(logLevel, eventId, formatString, null);
	}

	public static Action<ILogger, T1, T2, Exception?> Define<T1, T2>(LogLevel logLevel, EventId eventId, string formatString, LogDefineOptions? options)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 2);
		if (options != null && options.SkipEnabledCheck)
		{
			return Log;
		}
		return delegate(ILogger logger, T1 arg1, T2 arg2, Exception exception)
		{
			if (logger.IsEnabled(logLevel))
			{
				Log(logger, arg1, arg2, exception);
			}
		};
		void Log(ILogger logger, T1 arg1, T2 arg2, Exception exception)
		{
			logger.Log(logLevel, eventId, new LogValues<T1, T2>(formatter, arg1, arg2), exception, LogValues<T1, T2>.Callback);
		}
	}

	public static Action<ILogger, T1, T2, T3, Exception?> Define<T1, T2, T3>(LogLevel logLevel, EventId eventId, string formatString)
	{
		return Define<T1, T2, T3>(logLevel, eventId, formatString, null);
	}

	public static Action<ILogger, T1, T2, T3, Exception?> Define<T1, T2, T3>(LogLevel logLevel, EventId eventId, string formatString, LogDefineOptions? options)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 3);
		if (options != null && options.SkipEnabledCheck)
		{
			return Log;
		}
		return delegate(ILogger logger, T1 arg1, T2 arg2, T3 arg3, Exception exception)
		{
			if (logger.IsEnabled(logLevel))
			{
				Log(logger, arg1, arg2, arg3, exception);
			}
		};
		void Log(ILogger logger, T1 arg1, T2 arg2, T3 arg3, Exception exception)
		{
			logger.Log(logLevel, eventId, new LogValues<T1, T2, T3>(formatter, arg1, arg2, arg3), exception, LogValues<T1, T2, T3>.Callback);
		}
	}

	public static Action<ILogger, T1, T2, T3, T4, Exception?> Define<T1, T2, T3, T4>(LogLevel logLevel, EventId eventId, string formatString)
	{
		return Define<T1, T2, T3, T4>(logLevel, eventId, formatString, null);
	}

	public static Action<ILogger, T1, T2, T3, T4, Exception?> Define<T1, T2, T3, T4>(LogLevel logLevel, EventId eventId, string formatString, LogDefineOptions? options)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 4);
		if (options != null && options.SkipEnabledCheck)
		{
			return Log;
		}
		return delegate(ILogger logger, T1 arg1, T2 arg2, T3 arg3, T4 arg4, Exception exception)
		{
			if (logger.IsEnabled(logLevel))
			{
				Log(logger, arg1, arg2, arg3, arg4, exception);
			}
		};
		void Log(ILogger logger, T1 arg1, T2 arg2, T3 arg3, T4 arg4, Exception exception)
		{
			logger.Log(logLevel, eventId, new LogValues<T1, T2, T3, T4>(formatter, arg1, arg2, arg3, arg4), exception, LogValues<T1, T2, T3, T4>.Callback);
		}
	}

	public static Action<ILogger, T1, T2, T3, T4, T5, Exception?> Define<T1, T2, T3, T4, T5>(LogLevel logLevel, EventId eventId, string formatString)
	{
		return Define<T1, T2, T3, T4, T5>(logLevel, eventId, formatString, null);
	}

	public static Action<ILogger, T1, T2, T3, T4, T5, Exception?> Define<T1, T2, T3, T4, T5>(LogLevel logLevel, EventId eventId, string formatString, LogDefineOptions? options)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 5);
		if (options != null && options.SkipEnabledCheck)
		{
			return Log;
		}
		return delegate(ILogger logger, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, Exception exception)
		{
			if (logger.IsEnabled(logLevel))
			{
				Log(logger, arg1, arg2, arg3, arg4, arg5, exception);
			}
		};
		void Log(ILogger logger, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, Exception exception)
		{
			logger.Log(logLevel, eventId, new LogValues<T1, T2, T3, T4, T5>(formatter, arg1, arg2, arg3, arg4, arg5), exception, LogValues<T1, T2, T3, T4, T5>.Callback);
		}
	}

	public static Action<ILogger, T1, T2, T3, T4, T5, T6, Exception?> Define<T1, T2, T3, T4, T5, T6>(LogLevel logLevel, EventId eventId, string formatString)
	{
		return Define<T1, T2, T3, T4, T5, T6>(logLevel, eventId, formatString, null);
	}

	public static Action<ILogger, T1, T2, T3, T4, T5, T6, Exception?> Define<T1, T2, T3, T4, T5, T6>(LogLevel logLevel, EventId eventId, string formatString, LogDefineOptions? options)
	{
		LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, 6);
		if (options != null && options.SkipEnabledCheck)
		{
			return Log;
		}
		return delegate(ILogger logger, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, Exception exception)
		{
			if (logger.IsEnabled(logLevel))
			{
				Log(logger, arg1, arg2, arg3, arg4, arg5, arg6, exception);
			}
		};
		void Log(ILogger logger, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, Exception exception)
		{
			logger.Log(logLevel, eventId, new LogValues<T1, T2, T3, T4, T5, T6>(formatter, arg1, arg2, arg3, arg4, arg5, arg6), exception, LogValues<T1, T2, T3, T4, T5, T6>.Callback);
		}
	}

	private static LogValuesFormatter CreateLogValuesFormatter(string formatString, int expectedNamedParameterCount)
	{
		LogValuesFormatter logValuesFormatter = new LogValuesFormatter(formatString);
		int count = logValuesFormatter.ValueNames.Count;
		if (count != expectedNamedParameterCount)
		{
			throw new ArgumentException(System.SR.Format(System.SR.UnexpectedNumberOfNamedParameters, formatString, expectedNamedParameterCount, count));
		}
		return logValuesFormatter;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

private readonly struct LogValues : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	public static readonly Func<LogValues, Exception, string> Callback = (LogValues state, Exception exception) => state.ToString();

	private readonly LogValuesFormatter _formatter;

	public KeyValuePair<string, object> this[int index]
	{
		get
		{
			if (index == 0)
			{
				return new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat);
			}
			throw new IndexOutOfRangeException("index");
		}
	}

	public int Count => 1;

	public LogValues(LogValuesFormatter formatter)
	{
		_formatter = formatter;
	}

	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		yield return this[0];
	}

	public override string ToString()
	{
		return _formatter.Format();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

private readonly struct LogValues<T0> : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	public static readonly Func<LogValues<T0>, Exception, string> Callback = (LogValues<T0> state, Exception exception) => state.ToString();

	private readonly LogValuesFormatter _formatter;

	private readonly T0 _value0;

	public KeyValuePair<string, object> this[int index] => index switch
	{
		0 => new KeyValuePair<string, object>(_formatter.ValueNames[0], _value0), 
		1 => new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat), 
		_ => throw new IndexOutOfRangeException("index"), 
	};

	public int Count => 2;

	public LogValues(LogValuesFormatter formatter, T0 value0)
	{
		_formatter = formatter;
		_value0 = value0;
	}

	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		int i = 0;
		while (i < Count)
		{
			yield return this[i];
			int num = i + 1;
			i = num;
		}
	}

	public override string ToString()
	{
		return _formatter.Format(_value0);
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

private readonly struct LogValues<T0, T1> : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	public static readonly Func<LogValues<T0, T1>, Exception, string> Callback = (LogValues<T0, T1> state, Exception exception) => state.ToString();

	private readonly LogValuesFormatter _formatter;

	private readonly T0 _value0;

	private readonly T1 _value1;

	public KeyValuePair<string, object> this[int index] => index switch
	{
		0 => new KeyValuePair<string, object>(_formatter.ValueNames[0], _value0), 
		1 => new KeyValuePair<string, object>(_formatter.ValueNames[1], _value1), 
		2 => new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat), 
		_ => throw new IndexOutOfRangeException("index"), 
	};

	public int Count => 3;

	public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1)
	{
		_formatter = formatter;
		_value0 = value0;
		_value1 = value1;
	}

	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		int i = 0;
		while (i < Count)
		{
			yield return this[i];
			int num = i + 1;
			i = num;
		}
	}

	public override string ToString()
	{
		return _formatter.Format(_value0, _value1);
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

private readonly struct LogValues<T0, T1, T2> : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	public static readonly Func<LogValues<T0, T1, T2>, Exception, string> Callback = (LogValues<T0, T1, T2> state, Exception exception) => state.ToString();

	private readonly LogValuesFormatter _formatter;

	private readonly T0 _value0;

	private readonly T1 _value1;

	private readonly T2 _value2;

	public int Count => 4;

	public KeyValuePair<string, object> this[int index] => index switch
	{
		0 => new KeyValuePair<string, object>(_formatter.ValueNames[0], _value0), 
		1 => new KeyValuePair<string, object>(_formatter.ValueNames[1], _value1), 
		2 => new KeyValuePair<string, object>(_formatter.ValueNames[2], _value2), 
		3 => new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat), 
		_ => throw new IndexOutOfRangeException("index"), 
	};

	public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1, T2 value2)
	{
		_formatter = formatter;
		_value0 = value0;
		_value1 = value1;
		_value2 = value2;
	}

	public override string ToString()
	{
		return _formatter.Format(_value0, _value1, _value2);
	}

	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		int i = 0;
		while (i < Count)
		{
			yield return this[i];
			int num = i + 1;
			i = num;
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

private readonly struct LogValues<T0, T1, T2, T3> : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	public static readonly Func<LogValues<T0, T1, T2, T3>, Exception, string> Callback = (LogValues<T0, T1, T2, T3> state, Exception exception) => state.ToString();

	private readonly LogValuesFormatter _formatter;

	private readonly T0 _value0;

	private readonly T1 _value1;

	private readonly T2 _value2;

	private readonly T3 _value3;

	public int Count => 5;

	public KeyValuePair<string, object> this[int index] => index switch
	{
		0 => new KeyValuePair<string, object>(_formatter.ValueNames[0], _value0), 
		1 => new KeyValuePair<string, object>(_formatter.ValueNames[1], _value1), 
		2 => new KeyValuePair<string, object>(_formatter.ValueNames[2], _value2), 
		3 => new KeyValuePair<string, object>(_formatter.ValueNames[3], _value3), 
		4 => new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat), 
		_ => throw new IndexOutOfRangeException("index"), 
	};

	public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1, T2 value2, T3 value3)
	{
		_formatter = formatter;
		_value0 = value0;
		_value1 = value1;
		_value2 = value2;
		_value3 = value3;
	}

	private object[] ToArray()
	{
		return new object[4] { _value0, _value1, _value2, _value3 };
	}

	public override string ToString()
	{
		return _formatter.FormatWithOverwrite(ToArray());
	}

	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		int i = 0;
		while (i < Count)
		{
			yield return this[i];
			int num = i + 1;
			i = num;
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

private readonly struct LogValues<T0, T1, T2, T3, T4> : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	public static readonly Func<LogValues<T0, T1, T2, T3, T4>, Exception, string> Callback = (LogValues<T0, T1, T2, T3, T4> state, Exception exception) => state.ToString();

	private readonly LogValuesFormatter _formatter;

	private readonly T0 _value0;

	private readonly T1 _value1;

	private readonly T2 _value2;

	private readonly T3 _value3;

	private readonly T4 _value4;

	public int Count => 6;

	public KeyValuePair<string, object> this[int index] => index switch
	{
		0 => new KeyValuePair<string, object>(_formatter.ValueNames[0], _value0), 
		1 => new KeyValuePair<string, object>(_formatter.ValueNames[1], _value1), 
		2 => new KeyValuePair<string, object>(_formatter.ValueNames[2], _value2), 
		3 => new KeyValuePair<string, object>(_formatter.ValueNames[3], _value3), 
		4 => new KeyValuePair<string, object>(_formatter.ValueNames[4], _value4), 
		5 => new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat), 
		_ => throw new IndexOutOfRangeException("index"), 
	};

	public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1, T2 value2, T3 value3, T4 value4)
	{
		_formatter = formatter;
		_value0 = value0;
		_value1 = value1;
		_value2 = value2;
		_value3 = value3;
		_value4 = value4;
	}

	private object[] ToArray()
	{
		return new object[5] { _value0, _value1, _value2, _value3, _value4 };
	}

	public override string ToString()
	{
		return _formatter.FormatWithOverwrite(ToArray());
	}

	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		int i = 0;
		while (i < Count)
		{
			yield return this[i];
			int num = i + 1;
			i = num;
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

private readonly struct LogValues<T0, T1, T2, T3, T4, T5> : IReadOnlyList<KeyValuePair<string, object>>, IReadOnlyCollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	public static readonly Func<LogValues<T0, T1, T2, T3, T4, T5>, Exception, string> Callback = (LogValues<T0, T1, T2, T3, T4, T5> state, Exception exception) => state.ToString();

	private readonly LogValuesFormatter _formatter;

	private readonly T0 _value0;

	private readonly T1 _value1;

	private readonly T2 _value2;

	private readonly T3 _value3;

	private readonly T4 _value4;

	private readonly T5 _value5;

	public int Count => 7;

	public KeyValuePair<string, object> this[int index] => index switch
	{
		0 => new KeyValuePair<string, object>(_formatter.ValueNames[0], _value0), 
		1 => new KeyValuePair<string, object>(_formatter.ValueNames[1], _value1), 
		2 => new KeyValuePair<string, object>(_formatter.ValueNames[2], _value2), 
		3 => new KeyValuePair<string, object>(_formatter.ValueNames[3], _value3), 
		4 => new KeyValuePair<string, object>(_formatter.ValueNames[4], _value4), 
		5 => new KeyValuePair<string, object>(_formatter.ValueNames[5], _value5), 
		6 => new KeyValuePair<string, object>("{OriginalFormat}", _formatter.OriginalFormat), 
		_ => throw new IndexOutOfRangeException("index"), 
	};

	public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)
	{
		_formatter = formatter;
		_value0 = value0;
		_value1 = value1;
		_value2 = value2;
		_value3 = value3;
		_value4 = value4;
		_value5 = value5;
	}

	private object[] ToArray()
	{
		return new object[6] { _value0, _value1, _value2, _value3, _value4, _value5 };
	}

	public override string ToString()
	{
		return _formatter.FormatWithOverwrite(ToArray());
	}

	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		int i = 0;
		while (i < Count)
		{
			yield return this[i];
			int num = i + 1;
			i = num;
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using Microsoft.Extensions.Logging;

[AttributeUsage(AttributeTargets.Method)]
internal sealed class LoggerMessageAttribute : Attribute
{
	public int EventId { get; set; } = -1;

	public string? EventName { get; set; }

	public LogLevel Level { get; set; } = LogLevel.None;

	public string Message { get; set; } = "";

	public bool SkipEnabledCheck { get; set; }

	public LoggerMessageAttribute()
	{
	}

	public LoggerMessageAttribute(int eventId, LogLevel level, string message)
	{
		EventId = eventId;
		Level = level;
		Message = message;
	}
}


using System;
using Microsoft.Extensions.Internal;
using Microsoft.Extensions.Logging;

internal class Logger<T> : ILogger<T>, ILogger
{
	private readonly ILogger _logger;

	public Logger(ILoggerFactory factory)
	{
		System.ThrowHelper.ThrowIfNull(factory, "factory");
		_logger = factory.CreateLogger(TypeNameHelper.GetTypeDisplayName(typeof(T), fullName: true, includeGenericParameterNames: false, includeGenericParameters: false, '.'));
	}

	IDisposable ILogger.BeginScope<TState>(TState state)
	{
		return _logger.BeginScope(state);
	}

	bool ILogger.IsEnabled(LogLevel logLevel)
	{
		return _logger.IsEnabled(logLevel);
	}

	void ILogger.Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
	{
		_logger.Log(logLevel, eventId, state, exception, formatter);
	}
}


internal enum LogLevel
{
	Trace,
	Debug,
	Information,
	Warning,
	Error,
	Critical,
	None
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

internal sealed class LogValuesFormatter
{
	private const string NullValue = "(null)";

	private static readonly char[] FormatDelimiters = new char[2] { ',', ':' };

	private readonly string _format;

	private readonly List<string> _valueNames = new List<string>();

	public string OriginalFormat { get; private set; }

	public List<string> ValueNames => _valueNames;

	public LogValuesFormatter(string format)
	{
		System.ThrowHelper.ThrowIfNull(format, "format");
		OriginalFormat = format;
		Span<char> initialBuffer = stackalloc char[256];
		System.Text.ValueStringBuilder valueStringBuilder = new System.Text.ValueStringBuilder(initialBuffer);
		int num = 0;
		int length = format.Length;
		while (num < length)
		{
			int num2 = FindBraceIndex(format, '{', num, length);
			if (num == 0 && num2 == length)
			{
				_format = format;
				return;
			}
			int num3 = FindBraceIndex(format, '}', num2, length);
			if (num3 == length)
			{
				valueStringBuilder.Append(MemoryExtensions.AsSpan(format, num, length - num));
				num = length;
				continue;
			}
			int num4 = FindIndexOfAny(format, FormatDelimiters, num2, num3);
			valueStringBuilder.Append(MemoryExtensions.AsSpan(format, num, num2 - num + 1));
			valueStringBuilder.Append(_valueNames.Count.ToString());
			_valueNames.Add(format.Substring(num2 + 1, num4 - num2 - 1));
			valueStringBuilder.Append(MemoryExtensions.AsSpan(format, num4, num3 - num4 + 1));
			num = num3 + 1;
		}
		_format = valueStringBuilder.ToString();
	}

	private static int FindBraceIndex(string format, char brace, int startIndex, int endIndex)
	{
		int result = endIndex;
		int i = startIndex;
		int num = 0;
		for (; i < endIndex; i++)
		{
			if (num > 0 && format[i] != brace)
			{
				if (num % 2 != 0)
				{
					break;
				}
				num = 0;
				result = endIndex;
			}
			else
			{
				if (format[i] != brace)
				{
					continue;
				}
				if (brace == '}')
				{
					if (num == 0)
					{
						result = i;
					}
				}
				else
				{
					result = i;
				}
				num++;
			}
		}
		return result;
	}

	private static int FindIndexOfAny(string format, char[] chars, int startIndex, int endIndex)
	{
		int num = format.IndexOfAny(chars, startIndex, endIndex - startIndex);
		if (num != -1)
		{
			return num;
		}
		return endIndex;
	}

	public string Format(object?[]? values)
	{
		object[] array = values;
		if (values != null)
		{
			for (int i = 0; i < values.Length; i++)
			{
				object obj = FormatArgument(values[i]);
				if (obj != values[i])
				{
					array = new object[values.Length];
					Array.Copy(values, array, i);
					array[i++] = obj;
					for (; i < values.Length; i++)
					{
						array[i] = FormatArgument(values[i]);
					}
					break;
				}
			}
		}
		return string.Format(CultureInfo.InvariantCulture, _format, array ?? Array.Empty<object>());
	}

	internal string FormatWithOverwrite(object?[]? values)
	{
		if (values != null)
		{
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = FormatArgument(values[i]);
			}
		}
		return string.Format(CultureInfo.InvariantCulture, _format, values ?? Array.Empty<object>());
	}

	internal string Format()
	{
		return _format;
	}

	internal string Format(object? arg0)
	{
		return string.Format(CultureInfo.InvariantCulture, _format, FormatArgument(arg0));
	}

	internal string Format(object? arg0, object? arg1)
	{
		return string.Format(CultureInfo.InvariantCulture, _format, FormatArgument(arg0), FormatArgument(arg1));
	}

	internal string Format(object? arg0, object? arg1, object? arg2)
	{
		return string.Format(CultureInfo.InvariantCulture, _format, FormatArgument(arg0), FormatArgument(arg1), FormatArgument(arg2));
	}

	public KeyValuePair<string, object?> GetValue(object?[] values, int index)
	{
		if (index < 0 || index > _valueNames.Count)
		{
			throw new IndexOutOfRangeException("index");
		}
		if (_valueNames.Count > index)
		{
			return new KeyValuePair<string, object>(_valueNames[index], values[index]);
		}
		return new KeyValuePair<string, object>("{OriginalFormat}", OriginalFormat);
	}

	public IEnumerable<KeyValuePair<string, object?>> GetValues(object[] values)
	{
		KeyValuePair<string, object>[] array = new KeyValuePair<string, object>[values.Length + 1];
		for (int i = 0; i != _valueNames.Count; i++)
		{
			array[i] = new KeyValuePair<string, object>(_valueNames[i], values[i]);
		}
		array[^1] = new KeyValuePair<string, object>("{OriginalFormat}", OriginalFormat);
		return array;
	}

	private object FormatArgument(object value)
	{
		if (value == null)
		{
			return "(null)";
		}
		if (value is string)
		{
			return value;
		}
		if (value is IEnumerable enumerable)
		{
			Span<char> initialBuffer = stackalloc char[256];
			System.Text.ValueStringBuilder valueStringBuilder = new System.Text.ValueStringBuilder(initialBuffer);
			bool flag = true;
			foreach (object item in enumerable)
			{
				if (!flag)
				{
					valueStringBuilder.Append(", ");
				}
				valueStringBuilder.Append((item != null) ? item.ToString() : "(null)");
				flag = false;
			}
			return valueStringBuilder.ToString();
		}
		return value;
	}
}


using System;
using Microsoft.Extensions.Logging;

internal sealed class NullExternalScopeProvider : IExternalScopeProvider
{
	public static IExternalScopeProvider Instance { get; } = new NullExternalScopeProvider();

	private NullExternalScopeProvider()
	{
	}

	void IExternalScopeProvider.ForEachScope<TState>(Action<object, TState> callback, TState state)
	{
	}

	IDisposable IExternalScopeProvider.Push(object state)
	{
		return NullScope.Instance;
	}
}


using System;
using Microsoft.Extensions.Logging;

internal sealed class NullScope : IDisposable
{
	public static NullScope Instance { get; } = new NullScope();

	private NullScope()
	{
	}

	public void Dispose()
	{
	}
}


using System;
using Microsoft.Extensions.Logging;

internal readonly struct LogEntry<TState>
{
	public LogLevel LogLevel { get; }

	public string Category { get; }

	public EventId EventId { get; }

	public TState State { get; }

	public Exception? Exception { get; }

	public Func<TState, Exception?, string> Formatter { get; }

	public LogEntry(LogLevel logLevel, string category, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
	{
		LogLevel = logLevel;
		Category = category;
		EventId = eventId;
		State = state;
		Exception = exception;
		Formatter = formatter;
	}
}


using System;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

internal class NullLogger : ILogger
{
	public static NullLogger Instance { get; } = new NullLogger();

	private NullLogger()
	{
	}

	public IDisposable BeginScope<TState>(TState state) where TState : notnull
	{
		return NullScope.Instance;
	}

	public bool IsEnabled(LogLevel logLevel)
	{
		return false;
	}

	public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
	{
	}
}


using System;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

internal class NullLoggerFactory : ILoggerFactory, IDisposable
{
	public static readonly NullLoggerFactory Instance = new NullLoggerFactory();

	public ILogger CreateLogger(string name)
	{
		return NullLogger.Instance;
	}

	public void AddProvider(ILoggerProvider provider)
	{
	}

	public void Dispose()
	{
	}
}


using System;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

internal class NullLoggerProvider : ILoggerProvider, IDisposable
{
	public static NullLoggerProvider Instance { get; } = new NullLoggerProvider();

	private NullLoggerProvider()
	{
	}

	public ILogger CreateLogger(string categoryName)
	{
		return NullLogger.Instance;
	}

	public void Dispose()
	{
	}
}


using System;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

internal class NullLogger<T> : ILogger<T>, ILogger
{
	public static readonly NullLogger<T> Instance = new NullLogger<T>();

	public IDisposable BeginScope<TState>(TState state) where TState : notnull
	{
		return NullScope.Instance;
	}

	public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
	{
	}

	public bool IsEnabled(LogLevel logLevel)
	{
		return false;
	}
}


