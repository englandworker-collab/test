internal static class Consts
{
	public const string MonoVersion = "2.6.5.0";

	public const string MonoCompany = "MONO development team";

	public const string MonoProduct = "MONO Common language infrastructure";

	public const string MonoCopyright = "(c) various MONO Authors";

	public const string FxVersion = "2.0.0.0";

	public const string VsVersion = "8.0.0.0";

	public const string FxFileVersion = "2.0.50727.1433";

	public const string VsFileVersion = "8.0.50727.1433";

	public const string AssemblyI18N = "I18N, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMicrosoft_VisualStudio = "Microsoft.VisualStudio, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMicrosoft_VisualStudio_Web = "Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMicrosoft_VSDesigner = "Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMono_Http = "Mono.Http, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMono_Posix = "Mono.Posix, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMono_Security = "Mono.Security, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMono_Messaging_RabbitMQ = "Mono.Messaging.RabbitMQ, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyCorlib = "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem = "System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_Data = "System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_Design = "System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_DirectoryServices = "System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Drawing = "System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Drawing_Design = "System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Messaging = "System.Messaging, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Security = "System.Security, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_ServiceProcess = "System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Web = "System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Windows_Forms = "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_Core = "System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
}


internal sealed class Locale
{
	private Locale()
	{
	}

	public static string GetText(string msg)
	{
		return msg;
	}

	public static string GetText(string fmt, params object[] args)
	{
		return string.Format(fmt, args);
	}
}


using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using Mono.Unix;

[Serializable]
public class AbstractUnixEndPoint : EndPoint
{
	private string path;

	public string Path
	{
		get
		{
			return path;
		}
		set
		{
			path = value;
		}
	}

	public override AddressFamily AddressFamily => AddressFamily.Unix;

	public AbstractUnixEndPoint(string path)
	{
		if (path == null)
		{
			throw new ArgumentNullException("path");
		}
		if (path == string.Empty)
		{
			throw new ArgumentException("Cannot be empty.", "path");
		}
		this.path = path;
	}

	public override EndPoint Create(SocketAddress socketAddress)
	{
		byte[] array = new byte[socketAddress.Size - 2 - 1];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = socketAddress[3 + i];
		}
		string @string = Encoding.Default.GetString(array);
		return new AbstractUnixEndPoint(@string);
	}

	public override SocketAddress Serialize()
	{
		byte[] bytes = Encoding.Default.GetBytes(path);
		SocketAddress socketAddress = new SocketAddress(AddressFamily, 3 + bytes.Length);
		socketAddress[2] = 0;
		for (int i = 0; i < bytes.Length; i++)
		{
			socketAddress[i + 2 + 1] = bytes[i];
		}
		return socketAddress;
	}

	public override string ToString()
	{
		return path;
	}

	public override int GetHashCode()
	{
		return path.GetHashCode();
	}

	public override bool Equals(object o)
	{
		if (!(o is AbstractUnixEndPoint abstractUnixEndPoint))
		{
			return false;
		}
		return abstractUnixEndPoint.path == path;
	}
}


using System;
using System.Runtime.InteropServices;
using Mono.Unix;
using Mono.Unix.Native;

public class Catalog
{
	private Catalog()
	{
	}

	[DllImport("intl")]
	private static extern IntPtr bindtextdomain(IntPtr domainname, IntPtr dirname);

	[DllImport("intl")]
	private static extern IntPtr bind_textdomain_codeset(IntPtr domainname, IntPtr codeset);

	[DllImport("intl")]
	private static extern IntPtr textdomain(IntPtr domainname);

	public static void Init(string package, string localedir)
	{
		MarshalStrings(package, out var p, localedir, out var p2, "UTF-8", out var p3);
		try
		{
			if (bindtextdomain(p, p2) == IntPtr.Zero)
			{
				throw new UnixIOException(Errno.ENOMEM);
			}
			if (bind_textdomain_codeset(p, p3) == IntPtr.Zero)
			{
				throw new UnixIOException(Errno.ENOMEM);
			}
			if (textdomain(p) == IntPtr.Zero)
			{
				throw new UnixIOException(Errno.ENOMEM);
			}
		}
		finally
		{
			UnixMarshal.FreeHeap(p);
			UnixMarshal.FreeHeap(p2);
			UnixMarshal.FreeHeap(p3);
		}
	}

	private static void MarshalStrings(string s1, out IntPtr p1, string s2, out IntPtr p2, string s3, out IntPtr p3)
	{
		p1 = (p2 = (p3 = IntPtr.Zero));
		bool flag = true;
		try
		{
			p1 = UnixMarshal.StringToHeap(s1);
			p2 = UnixMarshal.StringToHeap(s2);
			if (s3 != null)
			{
				p3 = UnixMarshal.StringToHeap(s3);
			}
			flag = false;
		}
		finally
		{
			if (flag)
			{
				UnixMarshal.FreeHeap(p1);
				UnixMarshal.FreeHeap(p2);
				UnixMarshal.FreeHeap(p3);
			}
		}
	}

	[DllImport("intl")]
	private static extern IntPtr gettext(IntPtr instring);

	public static string GetString(string s)
	{
		IntPtr intPtr = UnixMarshal.StringToHeap(s);
		try
		{
			IntPtr intPtr2 = gettext(intPtr);
			if (intPtr2 != intPtr)
			{
				return UnixMarshal.PtrToStringUnix(intPtr2);
			}
			return s;
		}
		finally
		{
			UnixMarshal.FreeHeap(intPtr);
		}
	}

	[DllImport("intl")]
	private static extern IntPtr ngettext(IntPtr singular, IntPtr plural, int n);

	public static string GetPluralString(string s, string p, int n)
	{
		MarshalStrings(s, out var p2, p, out var p3, null, out var _);
		try
		{
			IntPtr intPtr = ngettext(p2, p3, n);
			if (intPtr == p2)
			{
				return s;
			}
			if (intPtr == p3)
			{
				return p;
			}
			return UnixMarshal.PtrToStringUnix(intPtr);
		}
		finally
		{
			UnixMarshal.FreeHeap(p2);
			UnixMarshal.FreeHeap(p3);
		}
	}
}


using System;

[Flags]
public enum FileAccessPermissions
{
	UserReadWriteExecute = 0x1C0,
	UserRead = 0x100,
	UserWrite = 0x80,
	UserExecute = 0x40,
	GroupReadWriteExecute = 0x38,
	GroupRead = 0x20,
	GroupWrite = 0x10,
	GroupExecute = 8,
	OtherReadWriteExecute = 7,
	OtherRead = 4,
	OtherWrite = 2,
	OtherExecute = 1,
	DefaultPermissions = 0x1B6,
	AllPermissions = 0x1FF
}


public enum FileAccessPattern
{
	Normal = 0,
	Sequential = 2,
	Random = 1,
	NoReuse = 5,
	PreLoad = 3,
	FlushCache = 4
}


using System;
using System.IO;
using Mono.Unix;
using Mono.Unix.Native;

public sealed class FileHandleOperations
{
	private FileHandleOperations()
	{
	}

	public static void AdviseFileAccessPattern(int fd, FileAccessPattern pattern, long offset, long len)
	{
		int retval = Syscall.posix_fadvise(fd, offset, len, (PosixFadviseAdvice)pattern);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public static void AdviseFileAccessPattern(int fd, FileAccessPattern pattern)
	{
		AdviseFileAccessPattern(fd, pattern, 0L, 0L);
	}

	public static void AdviseFileAccessPattern(FileStream file, FileAccessPattern pattern, long offset, long len)
	{
		if (file == null)
		{
			throw new ArgumentNullException("file");
		}
		int retval = Syscall.posix_fadvise(file.Handle.ToInt32(), offset, len, (PosixFadviseAdvice)pattern);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public static void AdviseFileAccessPattern(FileStream file, FileAccessPattern pattern)
	{
		AdviseFileAccessPattern(file, pattern, 0L, 0L);
	}

	public static void AdviseFileAccessPattern(UnixStream stream, FileAccessPattern pattern, long offset, long len)
	{
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
		int retval = Syscall.posix_fadvise(stream.Handle, offset, len, (PosixFadviseAdvice)pattern);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public static void AdviseFileAccessPattern(UnixStream stream, FileAccessPattern pattern)
	{
		AdviseFileAccessPattern(stream, pattern, 0L, 0L);
	}
}


using System;

[Flags]
public enum FileSpecialAttributes
{
	SetUserId = 0x800,
	SetGroupId = 0x400,
	Sticky = 0x200
}


public enum FileTypes
{
	Directory = 16384,
	CharacterDevice = 8192,
	BlockDevice = 24576,
	RegularFile = 32768,
	Fifo = 4096,
	SymbolicLink = 40960,
	Socket = 49152
}


using System;
using System.Net.Sockets;
using Mono.Posix;

public class PeerCred
{
	private const int so_peercred = 10001;

	private PeerCredData data;

	public int ProcessID => data.pid;

	public int UserID => data.uid;

	public int GroupID => data.gid;

	public PeerCred(Socket sock)
	{
		if (sock.AddressFamily != AddressFamily.Unix)
		{
			throw new ArgumentException("Only Unix sockets are supported", "sock");
		}
		data = (PeerCredData)sock.GetSocketOption(SocketOptionLevel.Socket, (SocketOptionName)10001);
	}
}


using System;
using System.IO;
using System.Runtime.InteropServices;
using Mono.Unix;
using Mono.Unix.Native;

public class StdioFileStream : Stream
{
	public static readonly IntPtr InvalidFileStream = IntPtr.Zero;

	public static readonly IntPtr StandardInput = Stdlib.stdin;

	public static readonly IntPtr StandardOutput = Stdlib.stdout;

	public static readonly IntPtr StandardError = Stdlib.stderr;

	private bool canSeek;

	private bool canRead;

	private bool canWrite;

	private bool owner = true;

	private IntPtr file = InvalidFileStream;

	public IntPtr Handle
	{
		get
		{
			AssertNotDisposed();
			GC.KeepAlive(this);
			return file;
		}
	}

	public override bool CanRead => canRead;

	public override bool CanSeek => canSeek;

	public override bool CanWrite => canWrite;

	public override long Length
	{
		get
		{
			AssertNotDisposed();
			if (!CanSeek)
			{
				throw new NotSupportedException("File Stream doesn't support seeking");
			}
			long num = Stdlib.ftell(file);
			if (num == -1)
			{
				throw new NotSupportedException("Unable to obtain current file position");
			}
			int retval = Stdlib.fseek(file, 0L, SeekFlags.SEEK_END);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			long num2 = Stdlib.ftell(file);
			if (num2 == -1)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			retval = Stdlib.fseek(file, num, SeekFlags.SEEK_SET);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			GC.KeepAlive(this);
			return num2;
		}
	}

	public override long Position
	{
		get
		{
			AssertNotDisposed();
			if (!CanSeek)
			{
				throw new NotSupportedException("The stream does not support seeking");
			}
			long num = Stdlib.ftell(file);
			if (num == -1)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			GC.KeepAlive(this);
			return num;
		}
		set
		{
			AssertNotDisposed();
			Seek(value, SeekOrigin.Begin);
		}
	}

	public StdioFileStream(IntPtr fileStream)
		: this(fileStream, ownsHandle: true)
	{
	}

	public StdioFileStream(IntPtr fileStream, bool ownsHandle)
	{
		InitStream(fileStream, ownsHandle);
	}

	public StdioFileStream(IntPtr fileStream, FileAccess access)
		: this(fileStream, access, ownsHandle: true)
	{
	}

	public StdioFileStream(IntPtr fileStream, FileAccess access, bool ownsHandle)
	{
		InitStream(fileStream, ownsHandle);
		InitCanReadWrite(access);
	}

	public StdioFileStream(string path)
	{
		InitStream(Fopen(path, "rb"), ownsHandle: true);
	}

	public StdioFileStream(string path, string mode)
	{
		InitStream(Fopen(path, mode), ownsHandle: true);
	}

	public StdioFileStream(string path, FileMode mode)
	{
		InitStream(Fopen(path, ToFopenMode(path, mode)), ownsHandle: true);
	}

	public StdioFileStream(string path, FileAccess access)
	{
		InitStream(Fopen(path, ToFopenMode(path, access)), ownsHandle: true);
		InitCanReadWrite(access);
	}

	public StdioFileStream(string path, FileMode mode, FileAccess access)
	{
		InitStream(Fopen(path, ToFopenMode(path, mode, access)), ownsHandle: true);
		InitCanReadWrite(access);
	}

	private static IntPtr Fopen(string path, string mode)
	{
		if (path == null)
		{
			throw new ArgumentNullException("path");
		}
		if (path.Length == 0)
		{
			throw new ArgumentException("path");
		}
		if (mode == null)
		{
			throw new ArgumentNullException("mode");
		}
		IntPtr intPtr = Stdlib.fopen(path, mode);
		if (intPtr == IntPtr.Zero)
		{
			throw new DirectoryNotFoundException("path", UnixMarshal.CreateExceptionForLastError());
		}
		return intPtr;
	}

	private void InitStream(IntPtr fileStream, bool ownsHandle)
	{
		if (InvalidFileStream == fileStream)
		{
			throw new ArgumentException(Locale.GetText("Invalid file stream"), "fileStream");
		}
		file = fileStream;
		owner = ownsHandle;
		try
		{
			long num = Stdlib.fseek(file, 0L, SeekFlags.SEEK_CUR);
			if (num != -1)
			{
				canSeek = true;
			}
			Stdlib.fread(IntPtr.Zero, 0uL, 0uL, file);
			if (Stdlib.ferror(file) == 0)
			{
				canRead = true;
			}
			Stdlib.fwrite(IntPtr.Zero, 0uL, 0uL, file);
			if (Stdlib.ferror(file) == 0)
			{
				canWrite = true;
			}
			Stdlib.clearerr(file);
		}
		catch (Exception)
		{
			throw new ArgumentException(Locale.GetText("Invalid file stream"), "fileStream");
		}
		GC.KeepAlive(this);
	}

	private void InitCanReadWrite(FileAccess access)
	{
		canRead = canRead && (access == FileAccess.Read || access == FileAccess.ReadWrite);
		canWrite = canWrite && (access == FileAccess.Write || access == FileAccess.ReadWrite);
	}

	private static string ToFopenMode(string file, FileMode mode)
	{
		string result = NativeConvert.ToFopenMode(mode);
		AssertFileMode(file, mode);
		return result;
	}

	private static string ToFopenMode(string file, FileAccess access)
	{
		return NativeConvert.ToFopenMode(access);
	}

	private static string ToFopenMode(string file, FileMode mode, FileAccess access)
	{
		string result = NativeConvert.ToFopenMode(mode, access);
		bool flag = AssertFileMode(file, mode);
		if (mode == FileMode.OpenOrCreate && access == FileAccess.Read && !flag)
		{
			result = "w+b";
		}
		return result;
	}

	private static bool AssertFileMode(string file, FileMode mode)
	{
		bool flag = FileExists(file);
		if (mode == FileMode.CreateNew && flag)
		{
			throw new IOException("File exists and FileMode.CreateNew specified");
		}
		if ((mode == FileMode.Open || mode == FileMode.Truncate) && !flag)
		{
			throw new FileNotFoundException("File doesn't exist and FileMode.Open specified", file);
		}
		return flag;
	}

	private static bool FileExists(string file)
	{
		bool flag = false;
		IntPtr intPtr = Stdlib.fopen(file, "r");
		flag = intPtr != IntPtr.Zero;
		if (intPtr != IntPtr.Zero)
		{
			Stdlib.fclose(intPtr);
		}
		return flag;
	}

	private void AssertNotDisposed()
	{
		if (file == InvalidFileStream)
		{
			throw new ObjectDisposedException("Invalid File Stream");
		}
		GC.KeepAlive(this);
	}

	public void SaveFilePosition(FilePosition pos)
	{
		AssertNotDisposed();
		int retval = Stdlib.fgetpos(file, pos);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		GC.KeepAlive(this);
	}

	public void RestoreFilePosition(FilePosition pos)
	{
		AssertNotDisposed();
		if (pos == null)
		{
			throw new ArgumentNullException("value");
		}
		int retval = Stdlib.fsetpos(file, pos);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		GC.KeepAlive(this);
	}

	public override void Flush()
	{
		AssertNotDisposed();
		if (Stdlib.fflush(file) != 0)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		GC.KeepAlive(this);
	}

	public unsafe override int Read([In][Out] byte[] buffer, int offset, int count)
	{
		AssertNotDisposed();
		AssertValidBuffer(buffer, offset, count);
		if (!CanRead)
		{
			throw new NotSupportedException("Stream does not support reading");
		}
		ulong num = 0uL;
		fixed (byte* ptr = &buffer[offset])
		{
			num = Stdlib.fread(ptr, 1uL, (ulong)count, file);
		}
		if (num != (ulong)count && Stdlib.ferror(file) != 0)
		{
			throw new IOException();
		}
		GC.KeepAlive(this);
		return (int)num;
	}

	private void AssertValidBuffer(byte[] buffer, int offset, int count)
	{
		if (buffer == null)
		{
			throw new ArgumentNullException("buffer");
		}
		if (offset < 0)
		{
			throw new ArgumentOutOfRangeException("offset", "< 0");
		}
		if (count < 0)
		{
			throw new ArgumentOutOfRangeException("count", "< 0");
		}
		if (offset > buffer.Length)
		{
			throw new ArgumentException("destination offset is beyond array size");
		}
		if (offset > buffer.Length - count)
		{
			throw new ArgumentException("would overrun buffer");
		}
	}

	public void Rewind()
	{
		AssertNotDisposed();
		Stdlib.rewind(file);
		GC.KeepAlive(this);
	}

	public override long Seek(long offset, SeekOrigin origin)
	{
		AssertNotDisposed();
		if (!CanSeek)
		{
			throw new NotSupportedException("The File Stream does not support seeking");
		}
		SeekFlags seekFlags = SeekFlags.SEEK_CUR;
		if (Stdlib.fseek(origin: origin switch
		{
			SeekOrigin.Begin => SeekFlags.SEEK_SET, 
			SeekOrigin.Current => SeekFlags.SEEK_CUR, 
			SeekOrigin.End => SeekFlags.SEEK_END, 
			_ => throw new ArgumentException("origin"), 
		}, stream: file, offset: offset) != 0)
		{
			throw new IOException("Unable to seek", UnixMarshal.CreateExceptionForLastError());
		}
		long num = Stdlib.ftell(file);
		if (num == -1)
		{
			throw new IOException("Unable to get current file position", UnixMarshal.CreateExceptionForLastError());
		}
		GC.KeepAlive(this);
		return num;
	}

	public override void SetLength(long value)
	{
		throw new NotSupportedException("ANSI C doesn't provide a way to truncate a file");
	}

	public unsafe override void Write(byte[] buffer, int offset, int count)
	{
		AssertNotDisposed();
		AssertValidBuffer(buffer, offset, count);
		if (!CanWrite)
		{
			throw new NotSupportedException("File Stream does not support writing");
		}
		ulong num = 0uL;
		fixed (byte* ptr = &buffer[offset])
		{
			num = Stdlib.fwrite(ptr, 1uL, (ulong)count, file);
		}
		if (num != (ulong)count)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		GC.KeepAlive(this);
	}

	~StdioFileStream()
	{
		Close();
	}

	public override void Close()
	{
		if (file == InvalidFileStream)
		{
			return;
		}
		if (owner)
		{
			if (Stdlib.fclose(file) != 0)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
		}
		else
		{
			Flush();
		}
		file = InvalidFileStream;
		canRead = false;
		canSeek = false;
		canWrite = false;
		GC.SuppressFinalize(this);
		GC.KeepAlive(this);
	}
}


using System;
using System.Net.Sockets;
using Mono.Unix;

public class UnixClient : MarshalByRefObject, IDisposable
{
	private NetworkStream stream;

	private Socket client;

	private bool disposed;

	public Socket Client
	{
		get
		{
			return client;
		}
		set
		{
			client = value;
			stream = null;
		}
	}

	public PeerCred PeerCredential
	{
		get
		{
			CheckDisposed();
			return new PeerCred(client);
		}
	}

	public LingerOption LingerState
	{
		get
		{
			CheckDisposed();
			return (LingerOption)client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Linger);
		}
		set
		{
			CheckDisposed();
			client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Linger, value);
		}
	}

	public int ReceiveBufferSize
	{
		get
		{
			CheckDisposed();
			return (int)client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer);
		}
		set
		{
			CheckDisposed();
			client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, value);
		}
	}

	public int ReceiveTimeout
	{
		get
		{
			CheckDisposed();
			return (int)client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout);
		}
		set
		{
			CheckDisposed();
			client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, value);
		}
	}

	public int SendBufferSize
	{
		get
		{
			CheckDisposed();
			return (int)client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer);
		}
		set
		{
			CheckDisposed();
			client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer, value);
		}
	}

	public int SendTimeout
	{
		get
		{
			CheckDisposed();
			return (int)client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout);
		}
		set
		{
			CheckDisposed();
			client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, value);
		}
	}

	public UnixClient()
	{
		if (client != null)
		{
			client.Close();
			client = null;
		}
		client = new Socket(AddressFamily.Unix, SocketType.Stream, ProtocolType.IP);
	}

	public UnixClient(string path)
		: this()
	{
		if (path == null)
		{
			throw new ArgumentNullException("ep");
		}
		Connect(path);
	}

	public UnixClient(UnixEndPoint ep)
		: this()
	{
		if (ep == null)
		{
			throw new ArgumentNullException("ep");
		}
		Connect(ep);
	}

	internal UnixClient(Socket sock)
	{
		Client = sock;
	}

	public void Close()
	{
		CheckDisposed();
		Dispose();
	}

	public void Connect(UnixEndPoint remoteEndPoint)
	{
		CheckDisposed();
		client.Connect(remoteEndPoint);
		stream = new NetworkStream(client, ownsSocket: true);
	}

	public void Connect(string path)
	{
		CheckDisposed();
		Connect(new UnixEndPoint(path));
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	protected virtual void Dispose(bool disposing)
	{
		if (disposed)
		{
			return;
		}
		if (disposing)
		{
			NetworkStream networkStream = stream;
			stream = null;
			if (networkStream != null)
			{
				networkStream.Close();
				networkStream = null;
			}
			else if (client != null)
			{
				client.Close();
			}
			client = null;
		}
		disposed = true;
	}

	public NetworkStream GetStream()
	{
		CheckDisposed();
		if (stream == null)
		{
			stream = new NetworkStream(client, ownsSocket: true);
		}
		return stream;
	}

	private void CheckDisposed()
	{
		if (disposed)
		{
			throw new ObjectDisposedException(GetType().FullName);
		}
	}

	~UnixClient()
	{
		Dispose(disposing: false);
	}
}


using System;
using System.Collections;
using System.Text;
using System.Text.RegularExpressions;
using Mono.Unix;
using Mono.Unix.Native;

public sealed class UnixDirectoryInfo : UnixFileSystemInfo
{
	public override string Name
	{
		get
		{
			string fileName = UnixPath.GetFileName(base.FullPath);
			if (fileName == null || fileName.Length == 0)
			{
				return base.FullPath;
			}
			return fileName;
		}
	}

	public UnixDirectoryInfo Parent
	{
		get
		{
			if (base.FullPath == "/")
			{
				return this;
			}
			string directoryName = UnixPath.GetDirectoryName(base.FullPath);
			if (directoryName == string.Empty)
			{
				throw new InvalidOperationException("Do not know parent directory for path `" + base.FullPath + "'");
			}
			return new UnixDirectoryInfo(directoryName);
		}
	}

	public UnixDirectoryInfo Root
	{
		get
		{
			string pathRoot = UnixPath.GetPathRoot(base.FullPath);
			if (pathRoot == null)
			{
				return null;
			}
			return new UnixDirectoryInfo(pathRoot);
		}
	}

	public UnixDirectoryInfo(string path)
		: base(path)
	{
	}

	internal UnixDirectoryInfo(string path, Stat stat)
		: base(path, stat)
	{
	}

	[CLSCompliant(false)]
	public void Create(FilePermissions mode)
	{
		int retval = Syscall.mkdir(base.FullPath, mode);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		Refresh();
	}

	public void Create(FileAccessPermissions mode)
	{
		Create((FilePermissions)mode);
	}

	public void Create()
	{
		FilePermissions mode = FilePermissions.ACCESSPERMS;
		Create(mode);
	}

	public override void Delete()
	{
		Delete(recursive: false);
	}

	public void Delete(bool recursive)
	{
		if (recursive)
		{
			UnixFileSystemInfo[] fileSystemEntries = GetFileSystemEntries();
			foreach (UnixFileSystemInfo unixFileSystemInfo in fileSystemEntries)
			{
				if (unixFileSystemInfo is UnixDirectoryInfo unixDirectoryInfo)
				{
					unixDirectoryInfo.Delete(recursive: true);
				}
				else
				{
					unixFileSystemInfo.Delete();
				}
			}
		}
		int retval = Syscall.rmdir(base.FullPath);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		Refresh();
	}

	public Dirent[] GetEntries()
	{
		IntPtr intPtr = Syscall.opendir(base.FullPath);
		if (intPtr == IntPtr.Zero)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		bool flag = false;
		try
		{
			Dirent[] entries = GetEntries(intPtr);
			flag = true;
			return entries;
		}
		finally
		{
			int retval = Syscall.closedir(intPtr);
			if (flag)
			{
				UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			}
		}
	}

	private static Dirent[] GetEntries(IntPtr dirp)
	{
		ArrayList arrayList = new ArrayList();
		int num;
		IntPtr result;
		do
		{
			Dirent dirent = new Dirent();
			num = Syscall.readdir_r(dirp, dirent, out result);
			if (num == 0 && result != IntPtr.Zero && dirent.d_name != "." && dirent.d_name != "..")
			{
				arrayList.Add(dirent);
			}
		}
		while (num == 0 && result != IntPtr.Zero);
		if (num != 0)
		{
			UnixMarshal.ThrowExceptionForLastErrorIf(num);
		}
		return (Dirent[])arrayList.ToArray(typeof(Dirent));
	}

	public Dirent[] GetEntries(Regex regex)
	{
		IntPtr intPtr = Syscall.opendir(base.FullPath);
		if (intPtr == IntPtr.Zero)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		try
		{
			return GetEntries(intPtr, regex);
		}
		finally
		{
			int retval = Syscall.closedir(intPtr);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}
	}

	private static Dirent[] GetEntries(IntPtr dirp, Regex regex)
	{
		ArrayList arrayList = new ArrayList();
		int num;
		IntPtr result;
		do
		{
			Dirent dirent = new Dirent();
			num = Syscall.readdir_r(dirp, dirent, out result);
			if (num == 0 && result != IntPtr.Zero && regex.Match(dirent.d_name).Success && dirent.d_name != "." && dirent.d_name != "..")
			{
				arrayList.Add(dirent);
			}
		}
		while (num == 0 && result != IntPtr.Zero);
		if (num != 0)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return (Dirent[])arrayList.ToArray(typeof(Dirent));
	}

	public Dirent[] GetEntries(string regex)
	{
		Regex regex2 = new Regex(regex);
		return GetEntries(regex2);
	}

	public UnixFileSystemInfo[] GetFileSystemEntries()
	{
		Dirent[] entries = GetEntries();
		return GetFileSystemEntries(entries);
	}

	private UnixFileSystemInfo[] GetFileSystemEntries(Dirent[] dentries)
	{
		UnixFileSystemInfo[] array = new UnixFileSystemInfo[dentries.Length];
		for (int i = 0; i != array.Length; i++)
		{
			array[i] = UnixFileSystemInfo.GetFileSystemEntry(UnixPath.Combine(base.FullPath, dentries[i].d_name));
		}
		return array;
	}

	public UnixFileSystemInfo[] GetFileSystemEntries(Regex regex)
	{
		Dirent[] entries = GetEntries(regex);
		return GetFileSystemEntries(entries);
	}

	public UnixFileSystemInfo[] GetFileSystemEntries(string regex)
	{
		Regex regex2 = new Regex(regex);
		return GetFileSystemEntries(regex2);
	}

	public static string GetCurrentDirectory()
	{
		StringBuilder stringBuilder = new StringBuilder(16);
		IntPtr zero = IntPtr.Zero;
		do
		{
			stringBuilder.Capacity *= 2;
			zero = Syscall.getcwd(stringBuilder, (ulong)stringBuilder.Capacity);
		}
		while (zero == IntPtr.Zero && Stdlib.GetLastError() == Errno.ERANGE);
		if (zero == IntPtr.Zero)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return stringBuilder.ToString();
	}

	public static void SetCurrentDirectory(string path)
	{
		int retval = Syscall.chdir(path);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}
}


public enum UnixDriveType
{
	Unknown,
	NoRootDirectory,
	Removable,
	Fixed,
	Network,
	CDRom,
	Ram
}


using System;
using System.Collections;
using System.IO;
using Mono.Unix;
using Mono.Unix.Native;

public sealed class UnixDriveInfo
{
	private Statvfs stat;

	private string fstype;

	private string mount_point;

	private string block_device;

	public long AvailableFreeSpace
	{
		get
		{
			Refresh();
			return Convert.ToInt64(stat.f_bavail * stat.f_frsize);
		}
	}

	public string DriveFormat => fstype;

	public UnixDriveType DriveType => UnixDriveType.Unknown;

	public bool IsReady
	{
		get
		{
			bool flag = Refresh(throwException: false);
			if (mount_point == "/" || !flag)
			{
				return flag;
			}
			if (Syscall.statvfs(RootDirectory.Parent.FullName, out var buf) != 0)
			{
				return false;
			}
			return buf.f_fsid != stat.f_fsid;
		}
	}

	public string Name => mount_point;

	public UnixDirectoryInfo RootDirectory => new UnixDirectoryInfo(mount_point);

	public long TotalFreeSpace
	{
		get
		{
			Refresh();
			return (long)(stat.f_bfree * stat.f_frsize);
		}
	}

	public long TotalSize
	{
		get
		{
			Refresh();
			return (long)(stat.f_frsize * stat.f_blocks);
		}
	}

	public string VolumeLabel => block_device;

	public long MaximumFilenameLength
	{
		get
		{
			Refresh();
			return Convert.ToInt64(stat.f_namemax);
		}
	}

	public UnixDriveInfo(string mountPoint)
	{
		if (mountPoint == null)
		{
			throw new ArgumentNullException("mountPoint");
		}
		Fstab fstab = Syscall.getfsfile(mountPoint);
		if (fstab != null)
		{
			FromFstab(fstab);
			return;
		}
		mount_point = mountPoint;
		block_device = string.Empty;
		fstype = "Unknown";
	}

	private UnixDriveInfo(Fstab fstab)
	{
		FromFstab(fstab);
	}

	private void FromFstab(Fstab fstab)
	{
		fstype = fstab.fs_vfstype;
		mount_point = fstab.fs_file;
		block_device = fstab.fs_spec;
	}

	public static UnixDriveInfo GetForSpecialFile(string specialFile)
	{
		if (specialFile == null)
		{
			throw new ArgumentNullException("specialFile");
		}
		Fstab fstab = Syscall.getfsspec(specialFile);
		if (fstab == null)
		{
			throw new ArgumentException("specialFile isn't valid: " + specialFile);
		}
		return new UnixDriveInfo(fstab);
	}

	public static UnixDriveInfo[] GetDrives()
	{
		ArrayList arrayList = new ArrayList();
		lock (Syscall.fstab_lock)
		{
			int num = Syscall.setfsent();
			if (num != 1)
			{
				throw new IOException("Error calling setfsent(3)", new UnixIOException());
			}
			try
			{
				Fstab fstab;
				while ((fstab = Syscall.getfsent()) != null)
				{
					if (fstab.fs_file.StartsWith("/"))
					{
						arrayList.Add(new UnixDriveInfo(fstab));
					}
				}
			}
			finally
			{
				Syscall.endfsent();
			}
		}
		return (UnixDriveInfo[])arrayList.ToArray(typeof(UnixDriveInfo));
	}

	public override string ToString()
	{
		return VolumeLabel;
	}

	private void Refresh()
	{
		Refresh(throwException: true);
	}

	private bool Refresh(bool throwException)
	{
		int num = Syscall.statvfs(mount_point, out stat);
		if (num == -1 && throwException)
		{
			Errno lastError = Stdlib.GetLastError();
			throw new InvalidOperationException(UnixMarshal.GetErrorDescription(lastError), new UnixIOException(lastError));
		}
		if (num == -1)
		{
			return false;
		}
		return true;
	}
}


using System;
using System.Text;
using Mono.Unix;

[Serializable]
public class UnixEncoding : Encoding
{
	[Serializable]
	private class UnixDecoder : Decoder
	{
		private uint leftOverBits;

		private uint leftOverCount;

		public UnixDecoder()
		{
			leftOverBits = 0u;
			leftOverCount = 0u;
		}

		public override int GetCharCount(byte[] bytes, int index, int count)
		{
			return InternalGetCharCount(bytes, index, count, leftOverBits, leftOverCount, throwOnInvalid: true, flush: false);
		}

		public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
		{
			return InternalGetChars(bytes, byteIndex, byteCount, chars, charIndex, ref leftOverBits, ref leftOverCount, throwOnInvalid: true, flush: false);
		}
	}

	[Serializable]
	private class UnixEncoder : Encoder
	{
		private uint leftOver;

		public UnixEncoder()
		{
			leftOver = 0u;
		}

		public override int GetByteCount(char[] chars, int index, int count, bool flush)
		{
			return InternalGetByteCount(chars, index, count, leftOver, flush);
		}

		public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteCount, bool flush)
		{
			return InternalGetBytes(chars, charIndex, charCount, bytes, byteCount, ref leftOver, flush);
		}
	}

	public static readonly Encoding Instance = new UnixEncoding();

	public static readonly char EscapeByte = '\0';

	private static int InternalGetByteCount(char[] chars, int index, int count, uint leftOver, bool flush)
	{
		if (chars == null)
		{
			throw new ArgumentNullException("chars");
		}
		if (index < 0 || index > chars.Length)
		{
			throw new ArgumentOutOfRangeException("index", _("ArgRange_Array"));
		}
		if (count < 0 || count > chars.Length - index)
		{
			throw new ArgumentOutOfRangeException("count", _("ArgRange_Array"));
		}
		int num = 0;
		uint num2 = leftOver;
		while (count > 0)
		{
			char c = chars[index];
			if (num2 == 0)
			{
				if (c == EscapeByte && count > 1)
				{
					num++;
					index++;
					count--;
				}
				else if (c < '\u0080')
				{
					num++;
				}
				else if (c < 'ࠀ')
				{
					num += 2;
				}
				else if (c >= '\ud800' && c <= '\udbff')
				{
					num2 = c;
				}
				else
				{
					num += 3;
				}
			}
			else
			{
				if (c < '\udc00' || c > '\udfff')
				{
					num += 3;
					num2 = 0u;
					continue;
				}
				num += 4;
				num2 = 0u;
			}
			index++;
			count--;
		}
		if (flush && num2 != 0)
		{
			num += 3;
		}
		return num;
	}

	public override int GetByteCount(char[] chars, int index, int count)
	{
		return InternalGetByteCount(chars, index, count, 0u, flush: true);
	}

	public override int GetByteCount(string s)
	{
		if (s == null)
		{
			throw new ArgumentNullException("s");
		}
		int num = 0;
		int num2 = s.Length;
		int num3 = 0;
		while (num2 > 0)
		{
			char c = s[num++];
			if (c == EscapeByte && num2 > 1)
			{
				num3++;
				num++;
				num2--;
			}
			else if (c < '\u0080')
			{
				num3++;
			}
			else if (c < 'ࠀ')
			{
				num3 += 2;
			}
			else if (c >= '\ud800' && c <= '\udbff' && num2 > 1)
			{
				uint num4 = s[num];
				if (num4 >= 56320 && num4 <= 57343)
				{
					num3 += 4;
					num++;
					num2--;
				}
				else
				{
					num3 += 3;
				}
			}
			else
			{
				num3 += 3;
			}
			num2--;
		}
		return num3;
	}

	private static int InternalGetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, ref uint leftOver, bool flush)
	{
		if (chars == null)
		{
			throw new ArgumentNullException("chars");
		}
		if (bytes == null)
		{
			throw new ArgumentNullException("bytes");
		}
		if (charIndex < 0 || charIndex > chars.Length)
		{
			throw new ArgumentOutOfRangeException("charIndex", _("ArgRange_Array"));
		}
		if (charCount < 0 || charCount > chars.Length - charIndex)
		{
			throw new ArgumentOutOfRangeException("charCount", _("ArgRange_Array"));
		}
		if (byteIndex < 0 || byteIndex > bytes.Length)
		{
			throw new ArgumentOutOfRangeException("byteIndex", _("ArgRange_Array"));
		}
		int num = bytes.Length;
		uint num2 = leftOver;
		int num3 = byteIndex;
		while (charCount > 0)
		{
			char c = chars[charIndex++];
			charCount--;
			uint num4;
			if (num2 == 0)
			{
				if (c >= '\ud800' && c <= '\udbff')
				{
					num2 = c;
					continue;
				}
				if (c == EscapeByte)
				{
					if (num3 >= num)
					{
						throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
					}
					if (--charCount >= 0)
					{
						bytes[num3++] = (byte)chars[charIndex++];
					}
					continue;
				}
				num4 = c;
			}
			else if (c >= '\udc00' && c <= '\udfff')
			{
				num4 = (uint)((int)(num2 - 55296 << 10) + (c - 56320) + 65536);
				num2 = 0u;
			}
			else
			{
				num4 = num2;
				num2 = 0u;
				charIndex--;
				charCount++;
			}
			if (num4 < 128)
			{
				if (num3 >= num)
				{
					throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
				}
				bytes[num3++] = (byte)num4;
				continue;
			}
			if (num4 < 2048)
			{
				if (num3 + 2 > num)
				{
					throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
				}
				bytes[num3++] = (byte)(0xC0 | (num4 >> 6));
				bytes[num3++] = (byte)(0x80 | (num4 & 0x3F));
				continue;
			}
			if (num4 < 65536)
			{
				if (num3 + 3 > num)
				{
					throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
				}
				bytes[num3++] = (byte)(0xE0 | (num4 >> 12));
				bytes[num3++] = (byte)(0x80 | ((num4 >> 6) & 0x3F));
				bytes[num3++] = (byte)(0x80 | (num4 & 0x3F));
				continue;
			}
			if (num3 + 4 > num)
			{
				throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
			}
			bytes[num3++] = (byte)(0xF0 | (num4 >> 18));
			bytes[num3++] = (byte)(0x80 | ((num4 >> 12) & 0x3F));
			bytes[num3++] = (byte)(0x80 | ((num4 >> 6) & 0x3F));
			bytes[num3++] = (byte)(0x80 | (num4 & 0x3F));
		}
		if (flush && num2 != 0)
		{
			if (num3 + 3 > num)
			{
				throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
			}
			bytes[num3++] = (byte)(0xE0 | (num2 >> 12));
			bytes[num3++] = (byte)(0x80 | ((num2 >> 6) & 0x3F));
			bytes[num3++] = (byte)(0x80 | (num2 & 0x3F));
			num2 = 0u;
		}
		leftOver = num2;
		return num3 - byteIndex;
	}

	public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
	{
		uint leftOver = 0u;
		return InternalGetBytes(chars, charIndex, charCount, bytes, byteIndex, ref leftOver, flush: true);
	}

	public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex)
	{
		if (s == null)
		{
			throw new ArgumentNullException("s");
		}
		if (bytes == null)
		{
			throw new ArgumentNullException("bytes");
		}
		if (charIndex < 0 || charIndex > s.Length)
		{
			throw new ArgumentOutOfRangeException("charIndex", _("ArgRange_StringIndex"));
		}
		if (charCount < 0 || charCount > s.Length - charIndex)
		{
			throw new ArgumentOutOfRangeException("charCount", _("ArgRange_StringRange"));
		}
		if (byteIndex < 0 || byteIndex > bytes.Length)
		{
			throw new ArgumentOutOfRangeException("byteIndex", _("ArgRange_Array"));
		}
		int num = bytes.Length;
		int num2 = byteIndex;
		while (charCount > 0)
		{
			char c = s[charIndex++];
			uint num3;
			if (c >= '\ud800' && c <= '\udbff' && charCount > 1)
			{
				num3 = s[charIndex];
				if (num3 >= 56320 && num3 <= 57343)
				{
					num3 = (uint)((int)(num3 - 56320) + (c - 55296 << 10) + 65536);
					charIndex++;
					charCount--;
				}
				else
				{
					num3 = c;
				}
			}
			else
			{
				if (c == EscapeByte && charCount > 1)
				{
					if (num2 >= num)
					{
						throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
					}
					charCount -= 2;
					if (charCount >= 0)
					{
						bytes[num2++] = (byte)s[charIndex++];
					}
					continue;
				}
				num3 = c;
			}
			charCount--;
			if (num3 < 128)
			{
				if (num2 >= num)
				{
					throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
				}
				bytes[num2++] = (byte)num3;
				continue;
			}
			if (num3 < 2048)
			{
				if (num2 + 2 > num)
				{
					throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
				}
				bytes[num2++] = (byte)(0xC0 | (num3 >> 6));
				bytes[num2++] = (byte)(0x80 | (num3 & 0x3F));
				continue;
			}
			if (num3 < 65536)
			{
				if (num2 + 3 > num)
				{
					throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
				}
				bytes[num2++] = (byte)(0xE0 | (num3 >> 12));
				bytes[num2++] = (byte)(0x80 | ((num3 >> 6) & 0x3F));
				bytes[num2++] = (byte)(0x80 | (num3 & 0x3F));
				continue;
			}
			if (num2 + 4 > num)
			{
				throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
			}
			bytes[num2++] = (byte)(0xF0 | (num3 >> 18));
			bytes[num2++] = (byte)(0x80 | ((num3 >> 12) & 0x3F));
			bytes[num2++] = (byte)(0x80 | ((num3 >> 6) & 0x3F));
			bytes[num2++] = (byte)(0x80 | (num3 & 0x3F));
		}
		return num2 - byteIndex;
	}

	private static int InternalGetCharCount(byte[] bytes, int index, int count, uint leftOverBits, uint leftOverCount, bool throwOnInvalid, bool flush)
	{
		if (bytes == null)
		{
			throw new ArgumentNullException("bytes");
		}
		if (index < 0 || index > bytes.Length)
		{
			throw new ArgumentOutOfRangeException("index", _("ArgRange_Array"));
		}
		if (count < 0 || count > bytes.Length - index)
		{
			throw new ArgumentOutOfRangeException("count", _("ArgRange_Array"));
		}
		int num = 0;
		int num2 = 0;
		uint num3 = leftOverBits;
		uint num4 = leftOverCount & 0xF;
		uint num5 = (leftOverCount >> 4) & 0xF;
		while (count > 0)
		{
			uint num6 = bytes[index++];
			num++;
			count--;
			if (num5 == 0)
			{
				if (num6 < 128)
				{
					num2++;
					num = 0;
					continue;
				}
				if ((num6 & 0xE0) == 192)
				{
					num3 = num6 & 0x1F;
					num4 = 1u;
					num5 = 2u;
					continue;
				}
				if ((num6 & 0xF0) == 224)
				{
					num3 = num6 & 0xF;
					num4 = 1u;
					num5 = 3u;
					continue;
				}
				if ((num6 & 0xF8) == 240)
				{
					num3 = num6 & 7;
					num4 = 1u;
					num5 = 4u;
					continue;
				}
				if ((num6 & 0xFC) == 248)
				{
					num3 = num6 & 3;
					num4 = 1u;
					num5 = 5u;
					continue;
				}
				if ((num6 & 0xFE) == 252)
				{
					num3 = num6 & 3;
					num4 = 1u;
					num5 = 6u;
					continue;
				}
				if (throwOnInvalid)
				{
				}
				num2 += num * 2;
				num = 0;
			}
			else if ((num6 & 0xC0) == 128)
			{
				num3 = (num3 << 6) | (num6 & 0x3F);
				if (++num4 < num5)
				{
					continue;
				}
				if (num3 < 65536)
				{
					bool flag = false;
					switch (num5)
					{
					case 2u:
						flag = num3 <= 127;
						break;
					case 3u:
						flag = num3 <= 2047;
						break;
					case 4u:
						flag = num3 <= 65535;
						break;
					case 5u:
						flag = num3 <= 2097151;
						break;
					case 6u:
						flag = num3 <= 67108863;
						break;
					}
					num2 = ((!flag) ? (num2 + 1) : (num2 + num * 2));
				}
				else if (num3 < 1114112)
				{
					num2 += 2;
				}
				else if (throwOnInvalid)
				{
					num2 += num * 2;
				}
				num5 = 0u;
				num = 0;
			}
			else
			{
				if (throwOnInvalid)
				{
				}
				if (num6 < 128)
				{
					index--;
					count++;
					num--;
				}
				num2 += num * 2;
				num5 = 0u;
				num = 0;
			}
		}
		if (flush && num5 != 0 && throwOnInvalid)
		{
			num2 += num * 2;
		}
		return num2;
	}

	public override int GetCharCount(byte[] bytes, int index, int count)
	{
		return InternalGetCharCount(bytes, index, count, 0u, 0u, throwOnInvalid: true, flush: true);
	}

	private static int InternalGetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, ref uint leftOverBits, ref uint leftOverCount, bool throwOnInvalid, bool flush)
	{
		if (bytes == null)
		{
			throw new ArgumentNullException("bytes");
		}
		if (chars == null)
		{
			throw new ArgumentNullException("chars");
		}
		if (byteIndex < 0 || byteIndex > bytes.Length)
		{
			throw new ArgumentOutOfRangeException("byteIndex", _("ArgRange_Array"));
		}
		if (byteCount < 0 || byteCount > bytes.Length - byteIndex)
		{
			throw new ArgumentOutOfRangeException("byteCount", _("ArgRange_Array"));
		}
		if (charIndex < 0 || charIndex > chars.Length)
		{
			throw new ArgumentOutOfRangeException("charIndex", _("ArgRange_Array"));
		}
		if (charIndex == chars.Length)
		{
			return 0;
		}
		byte[] array = new byte[6];
		int next_raw = 0;
		int num = chars.Length;
		int posn = charIndex;
		uint num2 = leftOverBits;
		uint num3 = leftOverCount & 0xF;
		uint num4 = (leftOverCount >> 4) & 0xF;
		while (byteCount > 0)
		{
			uint num5 = bytes[byteIndex++];
			array[next_raw++] = (byte)num5;
			byteCount--;
			if (num4 == 0)
			{
				if (num5 < 128)
				{
					if (posn >= num)
					{
						throw new ArgumentException(_("Arg_InsufficientSpace"), "chars");
					}
					next_raw = 0;
					chars[posn++] = (char)num5;
					continue;
				}
				if ((num5 & 0xE0) == 192)
				{
					num2 = num5 & 0x1F;
					num3 = 1u;
					num4 = 2u;
					continue;
				}
				if ((num5 & 0xF0) == 224)
				{
					num2 = num5 & 0xF;
					num3 = 1u;
					num4 = 3u;
					continue;
				}
				if ((num5 & 0xF8) == 240)
				{
					num2 = num5 & 7;
					num3 = 1u;
					num4 = 4u;
					continue;
				}
				if ((num5 & 0xFC) == 248)
				{
					num2 = num5 & 3;
					num3 = 1u;
					num4 = 5u;
					continue;
				}
				if ((num5 & 0xFE) == 252)
				{
					num2 = num5 & 3;
					num3 = 1u;
					num4 = 6u;
					continue;
				}
				if (throwOnInvalid)
				{
				}
				next_raw = 0;
				chars[posn++] = EscapeByte;
				chars[posn++] = (char)num5;
			}
			else if ((num5 & 0xC0) == 128)
			{
				num2 = (num2 << 6) | (num5 & 0x3F);
				if (++num3 < num4)
				{
					continue;
				}
				if (num2 < 65536)
				{
					bool flag = false;
					switch (num4)
					{
					case 2u:
						flag = num2 <= 127;
						break;
					case 3u:
						flag = num2 <= 2047;
						break;
					case 4u:
						flag = num2 <= 65535;
						break;
					case 5u:
						flag = num2 <= 2097151;
						break;
					case 6u:
						flag = num2 <= 67108863;
						break;
					}
					if (flag)
					{
						CopyRaw(array, ref next_raw, chars, ref posn, num);
					}
					else
					{
						if (posn >= num)
						{
							throw new ArgumentException(_("Arg_InsufficientSpace"), "chars");
						}
						chars[posn++] = (char)num2;
					}
				}
				else if (num2 < 1114112)
				{
					if (posn + 2 > num)
					{
						throw new ArgumentException(_("Arg_InsufficientSpace"), "chars");
					}
					num2 -= 65536;
					chars[posn++] = (char)((num2 >> 10) + 55296);
					chars[posn++] = (char)((num2 & 0x3FF) + 56320);
				}
				else if (throwOnInvalid)
				{
					CopyRaw(array, ref next_raw, chars, ref posn, num);
				}
				num4 = 0u;
				next_raw = 0;
			}
			else
			{
				if (throwOnInvalid)
				{
				}
				if (num5 < 128)
				{
					byteIndex--;
					byteCount++;
					next_raw--;
				}
				CopyRaw(array, ref next_raw, chars, ref posn, num);
				num4 = 0u;
				next_raw = 0;
			}
		}
		if (flush && num4 != 0 && throwOnInvalid)
		{
			CopyRaw(array, ref next_raw, chars, ref posn, num);
		}
		leftOverBits = num2;
		leftOverCount = num3 | (num4 << 4);
		return posn - charIndex;
	}

	private static void CopyRaw(byte[] raw, ref int next_raw, char[] chars, ref int posn, int length)
	{
		if (posn + next_raw * 2 > length)
		{
			throw new ArgumentException(_("Arg_InsufficientSpace"), "chars");
		}
		for (int i = 0; i < next_raw; i++)
		{
			chars[posn++] = EscapeByte;
			chars[posn++] = (char)raw[i];
		}
		next_raw = 0;
	}

	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
	{
		uint leftOverBits = 0u;
		uint leftOverCount = 0u;
		return InternalGetChars(bytes, byteIndex, byteCount, chars, charIndex, ref leftOverBits, ref leftOverCount, throwOnInvalid: true, flush: true);
	}

	public override int GetMaxByteCount(int charCount)
	{
		if (charCount < 0)
		{
			throw new ArgumentOutOfRangeException("charCount", _("ArgRange_NonNegative"));
		}
		return charCount * 4;
	}

	public override int GetMaxCharCount(int byteCount)
	{
		if (byteCount < 0)
		{
			throw new ArgumentOutOfRangeException("byteCount", _("ArgRange_NonNegative"));
		}
		return byteCount;
	}

	public override Decoder GetDecoder()
	{
		return new UnixDecoder();
	}

	public override Encoder GetEncoder()
	{
		return new UnixEncoder();
	}

	public override byte[] GetPreamble()
	{
		return new byte[0];
	}

	public override bool Equals(object value)
	{
		if (value is UnixEncoding)
		{
			return true;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return base.GetHashCode();
	}

	public override byte[] GetBytes(string s)
	{
		if (s == null)
		{
			throw new ArgumentNullException("s");
		}
		int byteCount = GetByteCount(s);
		byte[] array = new byte[byteCount];
		GetBytes(s, 0, s.Length, array, 0);
		return array;
	}

	private static string _(string arg)
	{
		return arg;
	}
}


using System;
using System.Text;

[Serializable]
private class UnixDecoder : Decoder
{
	private uint leftOverBits;

	private uint leftOverCount;

	public UnixDecoder()
	{
		leftOverBits = 0u;
		leftOverCount = 0u;
	}

	public override int GetCharCount(byte[] bytes, int index, int count)
	{
		return InternalGetCharCount(bytes, index, count, leftOverBits, leftOverCount, throwOnInvalid: true, flush: false);
	}

	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
	{
		return InternalGetChars(bytes, byteIndex, byteCount, chars, charIndex, ref leftOverBits, ref leftOverCount, throwOnInvalid: true, flush: false);
	}
}


using System;
using System.Text;

[Serializable]
private class UnixEncoder : Encoder
{
	private uint leftOver;

	public UnixEncoder()
	{
		leftOver = 0u;
	}

	public override int GetByteCount(char[] chars, int index, int count, bool flush)
	{
		return InternalGetByteCount(chars, index, count, leftOver, flush);
	}

	public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteCount, bool flush)
	{
		return InternalGetBytes(chars, charIndex, charCount, bytes, byteCount, ref leftOver, flush);
	}
}


using System;
using System.Collections;
using System.Text;
using Mono.Unix;
using Mono.Unix.Native;

public sealed class UnixEnvironment
{
	public static string CurrentDirectory
	{
		get
		{
			return UnixDirectoryInfo.GetCurrentDirectory();
		}
		set
		{
			UnixDirectoryInfo.SetCurrentDirectory(value);
		}
	}

	public static string MachineName
	{
		get
		{
			if (Syscall.uname(out var buf) != 0)
			{
				throw UnixMarshal.CreateExceptionForLastError();
			}
			return buf.nodename;
		}
		set
		{
			int retval = Syscall.sethostname(value);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}
	}

	public static string UserName => UnixUserInfo.GetRealUser().UserName;

	public static UnixGroupInfo RealGroup => new UnixGroupInfo(RealGroupId);

	public static long RealGroupId => Syscall.getgid();

	public static UnixUserInfo RealUser => new UnixUserInfo(RealUserId);

	public static long RealUserId => Syscall.getuid();

	public static UnixGroupInfo EffectiveGroup
	{
		get
		{
			return new UnixGroupInfo(EffectiveGroupId);
		}
		set
		{
			EffectiveGroupId = value.GroupId;
		}
	}

	public static long EffectiveGroupId
	{
		get
		{
			return Syscall.getegid();
		}
		set
		{
			Syscall.setegid(Convert.ToUInt32(value));
		}
	}

	public static UnixUserInfo EffectiveUser
	{
		get
		{
			return new UnixUserInfo(EffectiveUserId);
		}
		set
		{
			EffectiveUserId = value.UserId;
		}
	}

	public static long EffectiveUserId
	{
		get
		{
			return Syscall.geteuid();
		}
		set
		{
			Syscall.seteuid(Convert.ToUInt32(value));
		}
	}

	public static string Login => UnixUserInfo.GetRealUser().UserName;

	private UnixEnvironment()
	{
	}

	[CLSCompliant(false)]
	public static long GetConfigurationValue(SysconfName name)
	{
		long num = Syscall.sysconf(name);
		if (num == -1 && Stdlib.GetLastError() != 0)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return num;
	}

	[CLSCompliant(false)]
	public static string GetConfigurationString(ConfstrName name)
	{
		ulong num = Syscall.confstr(name, null, 0uL);
		if (num == ulong.MaxValue)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		if (num == 0L)
		{
			return string.Empty;
		}
		StringBuilder stringBuilder = new StringBuilder((int)num + 1);
		num = Syscall.confstr(name, stringBuilder, num);
		if (num == ulong.MaxValue)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return stringBuilder.ToString();
	}

	public static void SetNiceValue(int inc)
	{
		int retval = Syscall.nice(inc);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public static int CreateSession()
	{
		int num = Syscall.setsid();
		UnixMarshal.ThrowExceptionForLastErrorIf(num);
		return num;
	}

	public static void SetProcessGroup()
	{
		int retval = Syscall.setpgrp();
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public static int GetProcessGroup()
	{
		return Syscall.getpgrp();
	}

	public static UnixGroupInfo[] GetSupplementaryGroups()
	{
		uint[] array = _GetSupplementaryGroupIds();
		UnixGroupInfo[] array2 = new UnixGroupInfo[array.Length];
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i] = new UnixGroupInfo(array[i]);
		}
		return array2;
	}

	private static uint[] _GetSupplementaryGroupIds()
	{
		int num = Syscall.getgroups(0, new uint[0]);
		if (num == -1)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		uint[] array = new uint[num];
		int retval = Syscall.getgroups(array);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		return array;
	}

	public static void SetSupplementaryGroups(UnixGroupInfo[] groups)
	{
		uint[] array = new uint[groups.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = Convert.ToUInt32(groups[i].GroupId);
		}
		int retval = Syscall.setgroups(array);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public static long[] GetSupplementaryGroupIds()
	{
		uint[] array = _GetSupplementaryGroupIds();
		long[] array2 = new long[array.Length];
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i] = array[i];
		}
		return array2;
	}

	public static void SetSupplementaryGroupIds(long[] list)
	{
		uint[] array = new uint[list.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = Convert.ToUInt32(list[i]);
		}
		int retval = Syscall.setgroups(array);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public static int GetParentProcessId()
	{
		return Syscall.getppid();
	}

	public static UnixProcess GetParentProcess()
	{
		return new UnixProcess(GetParentProcessId());
	}

	public static string[] GetUserShells()
	{
		ArrayList arrayList = new ArrayList();
		lock (Syscall.usershell_lock)
		{
			try
			{
				if (Syscall.setusershell() != 0)
				{
					UnixMarshal.ThrowExceptionForLastError();
				}
				string value;
				while ((value = Syscall.getusershell()) != null)
				{
					arrayList.Add(value);
				}
			}
			finally
			{
				Syscall.endusershell();
			}
		}
		return (string[])arrayList.ToArray(typeof(string));
	}
}


using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using Mono.Unix;

[Serializable]
public class UnixEndPoint : EndPoint
{
	private string filename;

	public string Filename
	{
		get
		{
			return filename;
		}
		set
		{
			filename = value;
		}
	}

	public override AddressFamily AddressFamily => AddressFamily.Unix;

	public UnixEndPoint(string filename)
	{
		if (filename == null)
		{
			throw new ArgumentNullException("filename");
		}
		if (filename == string.Empty)
		{
			throw new ArgumentException("Cannot be empty.", "filename");
		}
		this.filename = filename;
	}

	public override EndPoint Create(SocketAddress socketAddress)
	{
		byte[] array = new byte[socketAddress.Size - 2 - 1];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = socketAddress[i + 2];
		}
		string @string = Encoding.Default.GetString(array);
		return new UnixEndPoint(@string);
	}

	public override SocketAddress Serialize()
	{
		byte[] bytes = Encoding.Default.GetBytes(filename);
		SocketAddress socketAddress = new SocketAddress(AddressFamily, 2 + bytes.Length + 1);
		for (int i = 0; i < bytes.Length; i++)
		{
			socketAddress[2 + i] = bytes[i];
		}
		socketAddress[2 + bytes.Length] = 0;
		return socketAddress;
	}

	public override string ToString()
	{
		return filename;
	}

	public override int GetHashCode()
	{
		return filename.GetHashCode();
	}

	public override bool Equals(object o)
	{
		if (!(o is UnixEndPoint unixEndPoint))
		{
			return false;
		}
		return unixEndPoint.filename == filename;
	}
}


using System;
using System.IO;
using Mono.Unix;
using Mono.Unix.Native;

public sealed class UnixFileInfo : UnixFileSystemInfo
{
	public override string Name => UnixPath.GetFileName(base.FullPath);

	public string DirectoryName => UnixPath.GetDirectoryName(base.FullPath);

	public UnixDirectoryInfo Directory => new UnixDirectoryInfo(DirectoryName);

	public UnixFileInfo(string path)
		: base(path)
	{
	}

	internal UnixFileInfo(string path, Stat stat)
		: base(path, stat)
	{
	}

	public override void Delete()
	{
		int retval = Syscall.unlink(base.FullPath);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		Refresh();
	}

	public UnixStream Create()
	{
		FilePermissions mode = FilePermissions.S_IRUSR | FilePermissions.S_IWUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH;
		return Create(mode);
	}

	[CLSCompliant(false)]
	public UnixStream Create(FilePermissions mode)
	{
		int num = Syscall.creat(base.FullPath, mode);
		if (num < 0)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		Refresh();
		return new UnixStream(num);
	}

	public UnixStream Create(FileAccessPermissions mode)
	{
		return Create((FilePermissions)mode);
	}

	[CLSCompliant(false)]
	public UnixStream Open(OpenFlags flags)
	{
		if ((flags & OpenFlags.O_CREAT) != 0)
		{
			throw new ArgumentException("Cannot specify OpenFlags.O_CREAT without providing FilePermissions.  Use the Open(OpenFlags, FilePermissions) method instead");
		}
		int num = Syscall.open(base.FullPath, flags);
		if (num < 0)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return new UnixStream(num);
	}

	[CLSCompliant(false)]
	public UnixStream Open(OpenFlags flags, FilePermissions mode)
	{
		int num = Syscall.open(base.FullPath, flags, mode);
		if (num < 0)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return new UnixStream(num);
	}

	public UnixStream Open(FileMode mode)
	{
		OpenFlags flags = NativeConvert.ToOpenFlags(mode, FileAccess.ReadWrite);
		return Open(flags);
	}

	public UnixStream Open(FileMode mode, FileAccess access)
	{
		OpenFlags flags = NativeConvert.ToOpenFlags(mode, access);
		return Open(flags);
	}

	[CLSCompliant(false)]
	public UnixStream Open(FileMode mode, FileAccess access, FilePermissions perms)
	{
		OpenFlags flags = NativeConvert.ToOpenFlags(mode, access);
		int num = Syscall.open(base.FullPath, flags, perms);
		if (num < 0)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return new UnixStream(num);
	}

	public UnixStream OpenRead()
	{
		return Open(FileMode.Open, FileAccess.Read);
	}

	public UnixStream OpenWrite()
	{
		return Open(FileMode.OpenOrCreate, FileAccess.Write);
	}
}


using System;
using Mono.Unix;
using Mono.Unix.Native;

public abstract class UnixFileSystemInfo
{
	internal const FileSpecialAttributes AllSpecialAttributes = FileSpecialAttributes.SetUserId | FileSpecialAttributes.SetGroupId | FileSpecialAttributes.Sticky;

	internal const FileTypes AllFileTypes = (FileTypes)61440;

	private Stat stat;

	private string fullPath;

	private string originalPath;

	private bool valid;

	protected string FullPath
	{
		get
		{
			return fullPath;
		}
		set
		{
			if (fullPath != value)
			{
				UnixPath.CheckPath(value);
				valid = false;
				fullPath = value;
			}
		}
	}

	protected string OriginalPath
	{
		get
		{
			return originalPath;
		}
		set
		{
			originalPath = value;
		}
	}

	public virtual string FullName => FullPath;

	public abstract string Name { get; }

	public bool Exists
	{
		get
		{
			Refresh(force: true);
			return valid;
		}
	}

	public long Device
	{
		get
		{
			AssertValid();
			return Convert.ToInt64(stat.st_dev);
		}
	}

	public long Inode
	{
		get
		{
			AssertValid();
			return Convert.ToInt64(stat.st_ino);
		}
	}

	[CLSCompliant(false)]
	public FilePermissions Protection
	{
		get
		{
			AssertValid();
			return stat.st_mode;
		}
		set
		{
			int retval = Syscall.chmod(FullPath, value);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}
	}

	public FileTypes FileType
	{
		get
		{
			AssertValid();
			return (FileTypes)(stat.st_mode & FilePermissions.S_IFMT);
		}
	}

	public FileAccessPermissions FileAccessPermissions
	{
		get
		{
			AssertValid();
			int st_mode = (int)stat.st_mode;
			return (FileAccessPermissions)(st_mode & 0x1FF);
		}
		set
		{
			AssertValid();
			int st_mode = (int)stat.st_mode;
			st_mode &= -512;
			st_mode |= (int)value;
			Protection = (FilePermissions)st_mode;
		}
	}

	public FileSpecialAttributes FileSpecialAttributes
	{
		get
		{
			AssertValid();
			int st_mode = (int)stat.st_mode;
			return (FileSpecialAttributes)(st_mode & 0xE00);
		}
		set
		{
			AssertValid();
			int st_mode = (int)stat.st_mode;
			st_mode &= -3585;
			st_mode |= (int)value;
			Protection = (FilePermissions)st_mode;
		}
	}

	public long LinkCount
	{
		get
		{
			AssertValid();
			return Convert.ToInt64(stat.st_nlink);
		}
	}

	public UnixUserInfo OwnerUser
	{
		get
		{
			AssertValid();
			return new UnixUserInfo(stat.st_uid);
		}
	}

	public long OwnerUserId
	{
		get
		{
			AssertValid();
			return stat.st_uid;
		}
	}

	public UnixGroupInfo OwnerGroup
	{
		get
		{
			AssertValid();
			return new UnixGroupInfo(stat.st_gid);
		}
	}

	public long OwnerGroupId
	{
		get
		{
			AssertValid();
			return stat.st_gid;
		}
	}

	public long DeviceType
	{
		get
		{
			AssertValid();
			return Convert.ToInt64(stat.st_rdev);
		}
	}

	public long Length
	{
		get
		{
			AssertValid();
			return stat.st_size;
		}
	}

	public long BlockSize
	{
		get
		{
			AssertValid();
			return stat.st_blksize;
		}
	}

	public long BlocksAllocated
	{
		get
		{
			AssertValid();
			return stat.st_blocks;
		}
	}

	public DateTime LastAccessTime
	{
		get
		{
			AssertValid();
			return NativeConvert.ToDateTime(stat.st_atime);
		}
	}

	public DateTime LastAccessTimeUtc => LastAccessTime.ToUniversalTime();

	public DateTime LastWriteTime
	{
		get
		{
			AssertValid();
			return NativeConvert.ToDateTime(stat.st_mtime);
		}
	}

	public DateTime LastWriteTimeUtc => LastWriteTime.ToUniversalTime();

	public DateTime LastStatusChangeTime
	{
		get
		{
			AssertValid();
			return NativeConvert.ToDateTime(stat.st_ctime);
		}
	}

	public DateTime LastStatusChangeTimeUtc => LastStatusChangeTime.ToUniversalTime();

	public bool IsDirectory
	{
		get
		{
			AssertValid();
			return IsFileType(stat.st_mode, FilePermissions.S_IFDIR);
		}
	}

	public bool IsCharacterDevice
	{
		get
		{
			AssertValid();
			return IsFileType(stat.st_mode, FilePermissions.S_IFCHR);
		}
	}

	public bool IsBlockDevice
	{
		get
		{
			AssertValid();
			return IsFileType(stat.st_mode, FilePermissions.S_IFBLK);
		}
	}

	public bool IsRegularFile
	{
		get
		{
			AssertValid();
			return IsFileType(stat.st_mode, FilePermissions.S_IFREG);
		}
	}

	public bool IsFifo
	{
		get
		{
			AssertValid();
			return IsFileType(stat.st_mode, FilePermissions.S_IFIFO);
		}
	}

	public bool IsSymbolicLink
	{
		get
		{
			AssertValid();
			return IsFileType(stat.st_mode, FilePermissions.S_IFLNK);
		}
	}

	public bool IsSocket
	{
		get
		{
			AssertValid();
			return IsFileType(stat.st_mode, FilePermissions.S_IFSOCK);
		}
	}

	public bool IsSetUser
	{
		get
		{
			AssertValid();
			return IsSet(stat.st_mode, FilePermissions.S_ISUID);
		}
	}

	public bool IsSetGroup
	{
		get
		{
			AssertValid();
			return IsSet(stat.st_mode, FilePermissions.S_ISGID);
		}
	}

	public bool IsSticky
	{
		get
		{
			AssertValid();
			return IsSet(stat.st_mode, FilePermissions.S_ISVTX);
		}
	}

	protected UnixFileSystemInfo(string path)
	{
		UnixPath.CheckPath(path);
		originalPath = path;
		fullPath = UnixPath.GetFullPath(path);
		Refresh(force: true);
	}

	internal UnixFileSystemInfo(string path, Stat stat)
	{
		originalPath = path;
		fullPath = UnixPath.GetFullPath(path);
		this.stat = stat;
		valid = true;
	}

	private void AssertValid()
	{
		Refresh(force: false);
		if (!valid)
		{
			throw new InvalidOperationException("Path doesn't exist!");
		}
	}

	internal static bool IsFileType(FilePermissions mode, FilePermissions type)
	{
		return (mode & FilePermissions.S_IFMT) == type;
	}

	internal static bool IsSet(FilePermissions mode, FilePermissions type)
	{
		return (mode & type) == type;
	}

	[CLSCompliant(false)]
	public bool CanAccess(AccessModes mode)
	{
		int num = Syscall.access(FullPath, mode);
		return num == 0;
	}

	public UnixFileSystemInfo CreateLink(string path)
	{
		int retval = Syscall.link(FullName, path);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		return GetFileSystemEntry(path);
	}

	public UnixSymbolicLinkInfo CreateSymbolicLink(string path)
	{
		int retval = Syscall.symlink(FullName, path);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		return new UnixSymbolicLinkInfo(path);
	}

	public abstract void Delete();

	[CLSCompliant(false)]
	public long GetConfigurationValue(PathconfName name)
	{
		long num = Syscall.pathconf(FullPath, name);
		if (num == -1 && Stdlib.GetLastError() != 0)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return num;
	}

	public void Refresh()
	{
		Refresh(force: true);
	}

	internal void Refresh(bool force)
	{
		if (!valid || force)
		{
			valid = GetFileStatus(FullPath, out stat);
		}
	}

	protected virtual bool GetFileStatus(string path, out Stat stat)
	{
		return Syscall.stat(path, out stat) == 0;
	}

	public void SetLength(long length)
	{
		int num;
		do
		{
			num = Syscall.truncate(FullPath, length);
		}
		while (UnixMarshal.ShouldRetrySyscall(num));
		UnixMarshal.ThrowExceptionForLastErrorIf(num);
	}

	public virtual void SetOwner(long owner, long group)
	{
		uint owner2 = Convert.ToUInt32(owner);
		uint group2 = Convert.ToUInt32(group);
		int retval = Syscall.chown(FullPath, owner2, group2);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public void SetOwner(string owner)
	{
		Passwd passwd = Syscall.getpwnam(owner);
		if (passwd == null)
		{
			throw new ArgumentException(Locale.GetText("invalid username"), "owner");
		}
		uint pw_uid = passwd.pw_uid;
		uint pw_gid = passwd.pw_gid;
		SetOwner(pw_uid, pw_gid);
	}

	public void SetOwner(string owner, string group)
	{
		long owner2 = -1L;
		if (owner != null)
		{
			owner2 = new UnixUserInfo(owner).UserId;
		}
		long group2 = -1L;
		if (group != null)
		{
			group2 = new UnixGroupInfo(group).GroupId;
		}
		SetOwner(owner2, group2);
	}

	public void SetOwner(UnixUserInfo owner)
	{
		long group;
		long owner2 = (group = -1L);
		if (owner != null)
		{
			owner2 = owner.UserId;
			group = owner.GroupId;
		}
		SetOwner(owner2, group);
	}

	public void SetOwner(UnixUserInfo owner, UnixGroupInfo group)
	{
		long group2;
		long owner2 = (group2 = -1L);
		if (owner != null)
		{
			owner2 = owner.UserId;
		}
		if (group != null)
		{
			group2 = owner.GroupId;
		}
		SetOwner(owner2, group2);
	}

	public override string ToString()
	{
		return FullPath;
	}

	public Stat ToStat()
	{
		AssertValid();
		return stat;
	}

	public static UnixFileSystemInfo GetFileSystemEntry(string path)
	{
		Stat buf;
		int num = Syscall.lstat(path, out buf);
		if (num == -1 && Stdlib.GetLastError() == Errno.ENOENT)
		{
			return new UnixFileInfo(path);
		}
		UnixMarshal.ThrowExceptionForLastErrorIf(num);
		if (IsFileType(buf.st_mode, FilePermissions.S_IFDIR))
		{
			return new UnixDirectoryInfo(path, buf);
		}
		if (IsFileType(buf.st_mode, FilePermissions.S_IFLNK))
		{
			return new UnixSymbolicLinkInfo(path, buf);
		}
		return new UnixFileInfo(path, buf);
	}
}


using System;
using System.Collections;
using Mono.Unix;
using Mono.Unix.Native;

public sealed class UnixGroupInfo
{
	private Group group;

	public string GroupName => group.gr_name;

	public string Password => group.gr_passwd;

	public long GroupId => group.gr_gid;

	public UnixGroupInfo(string group)
	{
		this.group = new Group();
		if (Syscall.getgrnam_r(group, this.group, out var grbufp) != 0 || grbufp == null)
		{
			throw new ArgumentException(Locale.GetText("invalid group name"), "group");
		}
	}

	public UnixGroupInfo(long group)
	{
		this.group = new Group();
		if (Syscall.getgrgid_r(Convert.ToUInt32(group), this.group, out var grbufp) != 0 || grbufp == null)
		{
			throw new ArgumentException(Locale.GetText("invalid group id"), "group");
		}
	}

	public UnixGroupInfo(Group group)
	{
		this.group = CopyGroup(group);
	}

	private static Group CopyGroup(Group group)
	{
		Group group2 = new Group();
		group2.gr_gid = group.gr_gid;
		group2.gr_mem = group.gr_mem;
		group2.gr_name = group.gr_name;
		group2.gr_passwd = group.gr_passwd;
		return group2;
	}

	public UnixUserInfo[] GetMembers()
	{
		ArrayList arrayList = new ArrayList(group.gr_mem.Length);
		for (int i = 0; i < group.gr_mem.Length; i++)
		{
			try
			{
				arrayList.Add(new UnixUserInfo(group.gr_mem[i]));
			}
			catch (ArgumentException)
			{
			}
		}
		return (UnixUserInfo[])arrayList.ToArray(typeof(UnixUserInfo));
	}

	public string[] GetMemberNames()
	{
		return (string[])group.gr_mem.Clone();
	}

	public override int GetHashCode()
	{
		return group.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)GetType() != obj.GetType())
		{
			return false;
		}
		return group.Equals(((UnixGroupInfo)obj).group);
	}

	public override string ToString()
	{
		return group.ToString();
	}

	public Group ToGroup()
	{
		return CopyGroup(group);
	}

	public static UnixGroupInfo[] GetLocalGroups()
	{
		ArrayList arrayList = new ArrayList();
		lock (Syscall.grp_lock)
		{
			if (Syscall.setgrent() != 0)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			try
			{
				Group group;
				while ((group = Syscall.getgrent()) != null)
				{
					arrayList.Add(new UnixGroupInfo(group));
				}
				if (Stdlib.GetLastError() != 0)
				{
					UnixMarshal.ThrowExceptionForLastError();
				}
			}
			finally
			{
				Syscall.endgrent();
			}
		}
		return (UnixGroupInfo[])arrayList.ToArray(typeof(UnixGroupInfo));
	}
}


using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using Mono.Unix;
using Mono.Unix.Native;

[Serializable]
public class UnixIOException : IOException
{
	private int errno;

	public int NativeErrorCode => errno;

	public Errno ErrorCode => NativeConvert.ToErrno(errno);

	public UnixIOException()
		: this(Marshal.GetLastWin32Error())
	{
	}

	public UnixIOException(int errno)
		: base(GetMessage(NativeConvert.ToErrno(errno)))
	{
		this.errno = errno;
	}

	public UnixIOException(int errno, Exception inner)
		: base(GetMessage(NativeConvert.ToErrno(errno)), inner)
	{
		this.errno = errno;
	}

	public UnixIOException(Errno errno)
		: base(GetMessage(errno))
	{
		this.errno = NativeConvert.FromErrno(errno);
	}

	public UnixIOException(Errno errno, Exception inner)
		: base(GetMessage(errno), inner)
	{
		this.errno = NativeConvert.FromErrno(errno);
	}

	public UnixIOException(string message)
		: base(message)
	{
		errno = 0;
	}

	public UnixIOException(string message, Exception inner)
		: base(message, inner)
	{
		errno = 0;
	}

	protected UnixIOException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}

	private static string GetMessage(Errno errno)
	{
		return $"{UnixMarshal.GetErrorDescription(errno)} [{errno}].";
	}
}


using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using Mono.Unix;

public class UnixListener : MarshalByRefObject, IDisposable
{
	private bool disposed;

	private bool listening;

	private Socket server;

	private EndPoint savedEP;

	public EndPoint LocalEndpoint => savedEP;

	protected Socket Server => server;

	public UnixListener(string path)
	{
		if (!Directory.Exists(Path.GetDirectoryName(path)))
		{
			Directory.CreateDirectory(Path.GetDirectoryName(path));
		}
		Init(new UnixEndPoint(path));
	}

	public UnixListener(UnixEndPoint localEndPoint)
	{
		if (localEndPoint == null)
		{
			throw new ArgumentNullException("localendPoint");
		}
		Init(localEndPoint);
	}

	private void Init(UnixEndPoint ep)
	{
		listening = false;
		string filename = ep.Filename;
		if (File.Exists(filename))
		{
			Socket socket = new Socket(AddressFamily.Unix, SocketType.Stream, ProtocolType.IP);
			try
			{
				socket.Connect(ep);
				socket.Close();
				throw new InvalidOperationException("There's already a server listening on " + filename);
			}
			catch (SocketException)
			{
			}
			File.Delete(filename);
		}
		server = new Socket(AddressFamily.Unix, SocketType.Stream, ProtocolType.IP);
		server.Bind(ep);
		savedEP = server.LocalEndPoint;
	}

	public Socket AcceptSocket()
	{
		CheckDisposed();
		if (!listening)
		{
			throw new InvalidOperationException("Socket is not listening");
		}
		return server.Accept();
	}

	public UnixClient AcceptUnixClient()
	{
		CheckDisposed();
		if (!listening)
		{
			throw new InvalidOperationException("Socket is not listening");
		}
		return new UnixClient(AcceptSocket());
	}

	~UnixListener()
	{
		Dispose(disposing: false);
	}

	public bool Pending()
	{
		CheckDisposed();
		if (!listening)
		{
			throw new InvalidOperationException("Socket is not listening");
		}
		return server.Poll(1000, SelectMode.SelectRead);
	}

	public void Start()
	{
		Start(5);
	}

	public void Start(int backlog)
	{
		CheckDisposed();
		if (!listening)
		{
			server.Listen(backlog);
			listening = true;
		}
	}

	public void Stop()
	{
		CheckDisposed();
		Dispose(disposing: true);
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	protected void Dispose(bool disposing)
	{
		if (disposed)
		{
			return;
		}
		if (disposing)
		{
			if (server != null)
			{
				server.Close();
			}
			server = null;
		}
		disposed = true;
	}

	private void CheckDisposed()
	{
		if (disposed)
		{
			throw new ObjectDisposedException(GetType().FullName);
		}
	}
}


using System;
using System.Text;
using Mono.Unix;
using Mono.Unix.Native;

internal class ErrorMarshal
{
	internal delegate string ErrorTranslator(Errno errno);

	internal static readonly ErrorTranslator Translate;

	static ErrorMarshal()
	{
		try
		{
			Translate = strerror_r;
			Translate(Errno.ERANGE);
		}
		catch (EntryPointNotFoundException)
		{
			Translate = strerror;
		}
	}

	private static string strerror(Errno errno)
	{
		return Stdlib.strerror(errno);
	}

	private static string strerror_r(Errno errno)
	{
		StringBuilder stringBuilder = new StringBuilder(16);
		int num = 0;
		do
		{
			stringBuilder.Capacity *= 2;
			num = Syscall.strerror_r(errno, stringBuilder);
		}
		while (num == -1 && Stdlib.GetLastError() == Errno.ERANGE);
		if (num == -1)
		{
			return "** Unknown error code: " + (int)errno + "**";
		}
		return stringBuilder.ToString();
	}
}


using Mono.Unix.Native;

internal delegate string ErrorTranslator(Errno errno);


using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using Mono.Unix;
using Mono.Unix.Native;

public sealed class UnixMarshal
{
	private UnixMarshal()
	{
	}

	[CLSCompliant(false)]
	public static string GetErrorDescription(Errno errno)
	{
		return ErrorMarshal.Translate(errno);
	}

	public static IntPtr AllocHeap(long size)
	{
		if (size < 0)
		{
			throw new ArgumentOutOfRangeException("size", "< 0");
		}
		return Stdlib.malloc((ulong)size);
	}

	public static IntPtr ReAllocHeap(IntPtr ptr, long size)
	{
		if (size < 0)
		{
			throw new ArgumentOutOfRangeException("size", "< 0");
		}
		return Stdlib.realloc(ptr, (ulong)size);
	}

	public static void FreeHeap(IntPtr ptr)
	{
		Stdlib.free(ptr);
	}

	public unsafe static string PtrToStringUnix(IntPtr p)
	{
		if (p == IntPtr.Zero)
		{
			return null;
		}
		int length = checked((int)Stdlib.strlen(p));
		return new string((sbyte*)(void*)p, 0, length, UnixEncoding.Instance);
	}

	public static string PtrToString(IntPtr p)
	{
		if (p == IntPtr.Zero)
		{
			return null;
		}
		return PtrToString(p, UnixEncoding.Instance);
	}

	public unsafe static string PtrToString(IntPtr p, Encoding encoding)
	{
		if (p == IntPtr.Zero)
		{
			return null;
		}
		if (encoding == null)
		{
			throw new ArgumentNullException("encoding");
		}
		int stringByteLength = GetStringByteLength(p, encoding);
		string text = new string((sbyte*)(void*)p, 0, stringByteLength, encoding);
		stringByteLength = text.Length;
		while (stringByteLength > 0 && text[stringByteLength - 1] == '\0')
		{
			stringByteLength--;
		}
		if (stringByteLength == text.Length)
		{
			return text;
		}
		return text.Substring(0, stringByteLength);
	}

	private static int GetStringByteLength(IntPtr p, Encoding encoding)
	{
		Type type = encoding.GetType();
		int num = -1;
		num = ((typeof(UTF8Encoding).IsAssignableFrom(type) || typeof(UTF7Encoding).IsAssignableFrom(type) || typeof(UnixEncoding).IsAssignableFrom(type) || typeof(ASCIIEncoding).IsAssignableFrom(type)) ? checked((int)Stdlib.strlen(p)) : ((!typeof(UnicodeEncoding).IsAssignableFrom(type)) ? GetRandomBufferLength(p, encoding.GetMaxByteCount(1)) : GetInt16BufferLength(p)));
		if (num == -1)
		{
			throw new NotSupportedException("Unable to determine native string buffer length");
		}
		return num;
	}

	private static int GetInt16BufferLength(IntPtr p)
	{
		int i;
		for (i = 0; Marshal.ReadInt16(p, i * 2) != 0; i = checked(i + 1))
		{
		}
		return checked(i * 2);
	}

	private static int GetInt32BufferLength(IntPtr p)
	{
		int i;
		for (i = 0; Marshal.ReadInt32(p, i * 4) != 0; i = checked(i + 1))
		{
		}
		return checked(i * 4);
	}

	private static int GetRandomBufferLength(IntPtr p, int nullLength)
	{
		switch (nullLength)
		{
		case 1:
			return checked((int)Stdlib.strlen(p));
		case 2:
			return GetInt16BufferLength(p);
		case 4:
			return GetInt32BufferLength(p);
		default:
		{
			int result = 0;
			int num = 0;
			do
			{
				num = ((Marshal.ReadByte(p, result++) == 0) ? (num + 1) : 0);
			}
			while (num != nullLength);
			return result;
		}
		}
	}

	public static string[] PtrToStringArray(IntPtr stringArray)
	{
		return PtrToStringArray(stringArray, UnixEncoding.Instance);
	}

	public static string[] PtrToStringArray(IntPtr stringArray, Encoding encoding)
	{
		if (stringArray == IntPtr.Zero)
		{
			return new string[0];
		}
		int count = CountStrings(stringArray);
		return PtrToStringArray(count, stringArray, encoding);
	}

	private static int CountStrings(IntPtr stringArray)
	{
		int i;
		for (i = 0; Marshal.ReadIntPtr(stringArray, i * IntPtr.Size) != IntPtr.Zero; i++)
		{
		}
		return i;
	}

	public static string[] PtrToStringArray(int count, IntPtr stringArray)
	{
		return PtrToStringArray(count, stringArray, UnixEncoding.Instance);
	}

	public static string[] PtrToStringArray(int count, IntPtr stringArray, Encoding encoding)
	{
		if (count < 0)
		{
			throw new ArgumentOutOfRangeException("count", "< 0");
		}
		if (encoding == null)
		{
			throw new ArgumentNullException("encoding");
		}
		if (stringArray == IntPtr.Zero)
		{
			return new string[count];
		}
		string[] array = new string[count];
		for (int i = 0; i < count; i++)
		{
			IntPtr p = Marshal.ReadIntPtr(stringArray, i * IntPtr.Size);
			array[i] = PtrToString(p, encoding);
		}
		return array;
	}

	public static IntPtr StringToHeap(string s)
	{
		return StringToHeap(s, UnixEncoding.Instance);
	}

	public static IntPtr StringToHeap(string s, Encoding encoding)
	{
		return StringToHeap(s, 0, s.Length, encoding);
	}

	public static IntPtr StringToHeap(string s, int index, int count)
	{
		return StringToHeap(s, index, count, UnixEncoding.Instance);
	}

	public static IntPtr StringToHeap(string s, int index, int count, Encoding encoding)
	{
		if (s == null)
		{
			return IntPtr.Zero;
		}
		if (encoding == null)
		{
			throw new ArgumentNullException("encoding");
		}
		int maxByteCount = encoding.GetMaxByteCount(1);
		char[] array = s.ToCharArray(index, count);
		byte[] array2 = new byte[encoding.GetByteCount(array) + maxByteCount];
		int bytes = encoding.GetBytes(array, 0, array.Length, array2, 0);
		if (bytes != array2.Length - maxByteCount)
		{
			throw new NotSupportedException("encoding.GetBytes() doesn't equal encoding.GetByteCount()!");
		}
		IntPtr intPtr = AllocHeap(array2.Length);
		if (intPtr == IntPtr.Zero)
		{
			throw new UnixIOException(Errno.ENOMEM);
		}
		bool flag = false;
		try
		{
			Marshal.Copy(array2, 0, intPtr, array2.Length);
			flag = true;
		}
		finally
		{
			if (!flag)
			{
				FreeHeap(intPtr);
			}
		}
		return intPtr;
	}

	public static bool ShouldRetrySyscall(int r)
	{
		if (r == -1 && Stdlib.GetLastError() == Errno.EINTR)
		{
			return true;
		}
		return false;
	}

	[CLSCompliant(false)]
	public static bool ShouldRetrySyscall(int r, out Errno errno)
	{
		errno = (Errno)0;
		if (r == -1 && (errno = Stdlib.GetLastError()) == Errno.EINTR)
		{
			return true;
		}
		return false;
	}

	internal static string EscapeFormatString(string message, char[] permitted)
	{
		if (message == null)
		{
			return string.Empty;
		}
		StringBuilder stringBuilder = new StringBuilder(message.Length);
		for (int i = 0; i < message.Length; i++)
		{
			char c = message[i];
			stringBuilder.Append(c);
			if (c == '%' && i + 1 < message.Length)
			{
				char c2 = message[i + 1];
				if (c2 == '%' || IsCharPresent(permitted, c2))
				{
					stringBuilder.Append(c2);
				}
				else
				{
					stringBuilder.Append('%').Append(c2);
				}
				i++;
			}
			else if (c == '%')
			{
				stringBuilder.Append('%');
			}
		}
		return stringBuilder.ToString();
	}

	private static bool IsCharPresent(char[] array, char c)
	{
		if (array == null)
		{
			return false;
		}
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == c)
			{
				return true;
			}
		}
		return false;
	}

	internal static Exception CreateExceptionForError(Errno errno)
	{
		string errorDescription = GetErrorDescription(errno);
		UnixIOException ex = new UnixIOException(errno);
		switch (errno)
		{
		case Errno.EBADF:
		case Errno.EINVAL:
			return new ArgumentException(errorDescription, ex);
		case Errno.ERANGE:
			return new ArgumentOutOfRangeException(errorDescription);
		case Errno.ENOTDIR:
			return new DirectoryNotFoundException(errorDescription, ex);
		case Errno.ENOENT:
			return new FileNotFoundException(errorDescription, ex);
		case Errno.EPERM:
		case Errno.EOPNOTSUPP:
			return new InvalidOperationException(errorDescription, ex);
		case Errno.ENOEXEC:
			return new InvalidProgramException(errorDescription, ex);
		case Errno.EIO:
		case Errno.ENXIO:
		case Errno.ENOSPC:
		case Errno.ESPIPE:
		case Errno.EROFS:
		case Errno.ENOTEMPTY:
			return new IOException(errorDescription, ex);
		case Errno.EFAULT:
			return new NullReferenceException(errorDescription, ex);
		case Errno.EOVERFLOW:
			return new OverflowException(errorDescription, ex);
		case Errno.ENAMETOOLONG:
			return new PathTooLongException(errorDescription, ex);
		case Errno.EACCES:
		case Errno.EISDIR:
			return new UnauthorizedAccessException(errorDescription, ex);
		default:
			return ex;
		}
	}

	internal static Exception CreateExceptionForLastError()
	{
		return CreateExceptionForError(Stdlib.GetLastError());
	}

	[CLSCompliant(false)]
	public static void ThrowExceptionForError(Errno errno)
	{
		throw CreateExceptionForError(errno);
	}

	public static void ThrowExceptionForLastError()
	{
		throw CreateExceptionForLastError();
	}

	[CLSCompliant(false)]
	public static void ThrowExceptionForErrorIf(int retval, Errno errno)
	{
		if (retval == -1)
		{
			ThrowExceptionForError(errno);
		}
	}

	public static void ThrowExceptionForLastErrorIf(int retval)
	{
		if (retval == -1)
		{
			ThrowExceptionForLastError();
		}
	}
}


using System;
using System.Text;
using Mono.Unix;
using Mono.Unix.Native;

public sealed class UnixPath
{
	public static readonly char DirectorySeparatorChar = '/';

	public static readonly char AltDirectorySeparatorChar = '/';

	public static readonly char PathSeparator = ':';

	public static readonly char VolumeSeparatorChar = '/';

	private static readonly char[] _InvalidPathChars = new char[0];

	private UnixPath()
	{
	}

	public static char[] GetInvalidPathChars()
	{
		return (char[])_InvalidPathChars.Clone();
	}

	public static string Combine(string path1, params string[] paths)
	{
		if (path1 == null)
		{
			throw new ArgumentNullException("path1");
		}
		if (paths == null)
		{
			throw new ArgumentNullException("paths");
		}
		if (path1.IndexOfAny(_InvalidPathChars) != -1)
		{
			throw new ArgumentException("Illegal characters in path", "path1");
		}
		int num = path1.Length;
		int num2 = -1;
		for (int i = 0; i < paths.Length; i++)
		{
			if (paths[i] == null)
			{
				throw new ArgumentNullException("paths[" + i + "]");
			}
			if (paths[i].IndexOfAny(_InvalidPathChars) != -1)
			{
				throw new ArgumentException("Illegal characters in path", "paths[" + i + "]");
			}
			if (IsPathRooted(paths[i]))
			{
				num = 0;
				num2 = i;
			}
			num += paths[i].Length + 1;
		}
		StringBuilder stringBuilder = new StringBuilder(num);
		if (num2 == -1)
		{
			stringBuilder.Append(path1);
			num2 = 0;
		}
		for (int j = num2; j < paths.Length; j++)
		{
			Combine(stringBuilder, paths[j]);
		}
		return stringBuilder.ToString();
	}

	private static void Combine(StringBuilder path, string part)
	{
		if (path.Length > 0 && part.Length > 0)
		{
			char c = path[path.Length - 1];
			if (c != DirectorySeparatorChar && c != AltDirectorySeparatorChar && c != VolumeSeparatorChar)
			{
				path.Append(DirectorySeparatorChar);
			}
		}
		path.Append(part);
	}

	public static string GetDirectoryName(string path)
	{
		CheckPath(path);
		int num = path.LastIndexOf(DirectorySeparatorChar);
		if (num > 0)
		{
			return path.Substring(0, num);
		}
		if (num == 0)
		{
			return "/";
		}
		return string.Empty;
	}

	public static string GetFileName(string path)
	{
		if (path == null || path.Length == 0)
		{
			return path;
		}
		int num = path.LastIndexOf(DirectorySeparatorChar);
		if (num >= 0)
		{
			return path.Substring(num + 1);
		}
		return path;
	}

	public static string GetFullPath(string path)
	{
		path = _GetFullPath(path);
		return GetCanonicalPath(path);
	}

	private static string _GetFullPath(string path)
	{
		if (path == null)
		{
			throw new ArgumentNullException("path");
		}
		if (!IsPathRooted(path))
		{
			path = UnixDirectoryInfo.GetCurrentDirectory() + DirectorySeparatorChar + path;
		}
		return path;
	}

	public static string GetCanonicalPath(string path)
	{
		GetPathComponents(path, out var components, out var lastIndex);
		string text = string.Join("/", components, 0, lastIndex);
		return (!IsPathRooted(path)) ? text : ("/" + text);
	}

	private static void GetPathComponents(string path, out string[] components, out int lastIndex)
	{
		string[] array = path.Split(new char[1] { DirectorySeparatorChar });
		int num = 0;
		for (int i = 0; i < array.Length; i++)
		{
			if (!(array[i] == ".") && !(array[i] == string.Empty))
			{
				if (array[i] == "..")
				{
					num = ((num == 0) ? (num + 1) : (num - 1));
				}
				else
				{
					array[num++] = array[i];
				}
			}
		}
		components = array;
		lastIndex = num;
	}

	public static string GetPathRoot(string path)
	{
		if (path == null)
		{
			return null;
		}
		if (!IsPathRooted(path))
		{
			return string.Empty;
		}
		return "/";
	}

	public static string GetCompleteRealPath(string path)
	{
		if (path == null)
		{
			throw new ArgumentNullException("path");
		}
		GetPathComponents(path, out var components, out var lastIndex);
		StringBuilder stringBuilder = new StringBuilder();
		if (components.Length > 0)
		{
			string text = ((!IsPathRooted(path)) ? string.Empty : "/");
			text += components[0];
			stringBuilder.Append(GetRealPath(text));
		}
		for (int i = 1; i < lastIndex; i++)
		{
			stringBuilder.Append("/").Append(components[i]);
			string realPath = GetRealPath(stringBuilder.ToString());
			stringBuilder.Remove(0, stringBuilder.Length);
			stringBuilder.Append(realPath);
		}
		return stringBuilder.ToString();
	}

	public static string GetRealPath(string path)
	{
		while (true)
		{
			string text = ReadSymbolicLink(path);
			if (text == null)
			{
				break;
			}
			if (IsPathRooted(text))
			{
				path = text;
				continue;
			}
			path = GetDirectoryName(path) + DirectorySeparatorChar + text;
			path = GetCanonicalPath(path);
		}
		return path;
	}

	internal static string ReadSymbolicLink(string path)
	{
		StringBuilder stringBuilder = new StringBuilder(256);
		int num;
		while (true)
		{
			num = Syscall.readlink(path, stringBuilder);
			if (num < 0)
			{
				Errno lastError;
				Errno errno = (lastError = Stdlib.GetLastError());
				if (errno == Errno.EINVAL)
				{
					return null;
				}
				UnixMarshal.ThrowExceptionForError(lastError);
			}
			else
			{
				if (num != stringBuilder.Capacity)
				{
					break;
				}
				stringBuilder.Capacity *= 2;
			}
		}
		return stringBuilder.ToString(0, num);
	}

	private static string ReadSymbolicLink(string path, out Errno errno)
	{
		errno = (Errno)0;
		StringBuilder stringBuilder = new StringBuilder(256);
		int num;
		while (true)
		{
			num = Syscall.readlink(path, stringBuilder);
			if (num < 0)
			{
				errno = Stdlib.GetLastError();
				return null;
			}
			if (num != stringBuilder.Capacity)
			{
				break;
			}
			stringBuilder.Capacity *= 2;
		}
		return stringBuilder.ToString(0, num);
	}

	public static string TryReadLink(string path)
	{
		Errno errno;
		return ReadSymbolicLink(path, out errno);
	}

	public static string ReadLink(string path)
	{
		path = ReadSymbolicLink(path, out var errno);
		if (errno != 0)
		{
			UnixMarshal.ThrowExceptionForError(errno);
		}
		return path;
	}

	public static bool IsPathRooted(string path)
	{
		if (path == null || path.Length == 0)
		{
			return false;
		}
		return path[0] == DirectorySeparatorChar;
	}

	internal static void CheckPath(string path)
	{
		if (path == null)
		{
			throw new ArgumentNullException();
		}
		if (path.Length == 0)
		{
			throw new ArgumentException("Path cannot contain a zero-length string", "path");
		}
		if (path.IndexOfAny(_InvalidPathChars) != -1)
		{
			throw new ArgumentException("Invalid characters in path.", "path");
		}
	}
}


using System;
using Mono.Unix;
using Mono.Unix.Native;

public struct UnixPipes : IEquatable<UnixPipes>
{
	public UnixStream Reading;

	public UnixStream Writing;

	public UnixPipes(UnixStream reading, UnixStream writing)
	{
		Reading = reading;
		Writing = writing;
	}

	public static UnixPipes CreatePipes()
	{
		int reading;
		int writing;
		int retval = Syscall.pipe(out reading, out writing);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		return new UnixPipes(new UnixStream(reading), new UnixStream(writing));
	}

	public override bool Equals(object value)
	{
		if (value == null || (object)value.GetType() != GetType())
		{
			return false;
		}
		UnixPipes unixPipes = (UnixPipes)value;
		return Reading.Handle == unixPipes.Reading.Handle && Writing.Handle == unixPipes.Writing.Handle;
	}

	public bool Equals(UnixPipes value)
	{
		return Reading.Handle == value.Reading.Handle && Writing.Handle == value.Writing.Handle;
	}

	public override int GetHashCode()
	{
		return Reading.Handle.GetHashCode() ^ Writing.Handle.GetHashCode();
	}

	public static bool operator ==(UnixPipes lhs, UnixPipes rhs)
	{
		return lhs.Equals(rhs);
	}

	public static bool operator !=(UnixPipes lhs, UnixPipes rhs)
	{
		return !lhs.Equals(rhs);
	}
}


using System;
using Mono.Unix;
using Mono.Unix.Native;

public sealed class UnixProcess
{
	private int pid;

	public int Id => pid;

	public bool HasExited
	{
		get
		{
			int processStatus = GetProcessStatus();
			return Syscall.WIFEXITED(processStatus);
		}
	}

	public int ExitCode
	{
		get
		{
			if (!HasExited)
			{
				throw new InvalidOperationException(Locale.GetText("Process hasn't exited"));
			}
			int processStatus = GetProcessStatus();
			return Syscall.WEXITSTATUS(processStatus);
		}
	}

	public bool HasSignaled
	{
		get
		{
			int processStatus = GetProcessStatus();
			return Syscall.WIFSIGNALED(processStatus);
		}
	}

	public Signum TerminationSignal
	{
		get
		{
			if (!HasSignaled)
			{
				throw new InvalidOperationException(Locale.GetText("Process wasn't terminated by a signal"));
			}
			int processStatus = GetProcessStatus();
			return Syscall.WTERMSIG(processStatus);
		}
	}

	public bool HasStopped
	{
		get
		{
			int processStatus = GetProcessStatus();
			return Syscall.WIFSTOPPED(processStatus);
		}
	}

	public Signum StopSignal
	{
		get
		{
			if (!HasStopped)
			{
				throw new InvalidOperationException(Locale.GetText("Process isn't stopped"));
			}
			int processStatus = GetProcessStatus();
			return Syscall.WSTOPSIG(processStatus);
		}
	}

	public int ProcessGroupId
	{
		get
		{
			return Syscall.getpgid(pid);
		}
		set
		{
			int retval = Syscall.setpgid(pid, value);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}
	}

	public int SessionId
	{
		get
		{
			int num = Syscall.getsid(pid);
			UnixMarshal.ThrowExceptionForLastErrorIf(num);
			return num;
		}
	}

	internal UnixProcess(int pid)
	{
		this.pid = pid;
	}

	private int GetProcessStatus()
	{
		int status;
		int num = Syscall.waitpid(pid, out status, WaitOptions.WNOHANG | WaitOptions.WUNTRACED);
		UnixMarshal.ThrowExceptionForLastErrorIf(num);
		return num;
	}

	public static UnixProcess GetCurrentProcess()
	{
		return new UnixProcess(GetCurrentProcessId());
	}

	public static int GetCurrentProcessId()
	{
		return Syscall.getpid();
	}

	public void Kill()
	{
		Signal(Signum.SIGKILL);
	}

	[CLSCompliant(false)]
	public void Signal(Signum signal)
	{
		int retval = Syscall.kill(pid, signal);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public void WaitForExit()
	{
		int num;
		do
		{
			num = Syscall.waitpid(pid, out var _, (WaitOptions)0);
		}
		while (UnixMarshal.ShouldRetrySyscall(num));
		UnixMarshal.ThrowExceptionForLastErrorIf(num);
	}
}


using System;
using System.Runtime.InteropServices;
using System.Threading;
using Mono.Unix;
using Mono.Unix.Native;

public class UnixSignal : WaitHandle
{
	[Map]
	private struct SignalInfo
	{
		public int signum;

		public int count;

		public int read_fd;

		public int write_fd;

		public int have_handler;

		public int pipecnt;

		public IntPtr handler;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	private delegate int Mono_Posix_RuntimeIsShuttingDown();

	private int signum;

	private IntPtr signal_info;

	public Signum Signum
	{
		get
		{
			if (IsRealTimeSignal)
			{
				throw new InvalidOperationException("This signal is a RealTimeSignum");
			}
			return NativeConvert.ToSignum(signum);
		}
	}

	public RealTimeSignum RealTimeSignum
	{
		get
		{
			if (!IsRealTimeSignal)
			{
				throw new InvalidOperationException("This signal is not a RealTimeSignum");
			}
			return NativeConvert.ToRealTimeSignum(signum - GetSIGRTMIN());
		}
	}

	public bool IsRealTimeSignal
	{
		get
		{
			AssertValid();
			int sIGRTMIN = GetSIGRTMIN();
			if (sIGRTMIN == -1)
			{
				return false;
			}
			return signum >= sIGRTMIN;
		}
	}

	private unsafe SignalInfo* Info
	{
		get
		{
			AssertValid();
			return (SignalInfo*)(void*)signal_info;
		}
	}

	public bool IsSet => Count > 0;

	public unsafe int Count
	{
		get
		{
			return Info->count;
		}
		set
		{
			Interlocked.Exchange(ref Info->count, value);
		}
	}

	public UnixSignal(Signum signum)
	{
		this.signum = NativeConvert.FromSignum(signum);
		signal_info = install(this.signum);
		if (signal_info == IntPtr.Zero)
		{
			throw new ArgumentException("Unable to handle signal", "signum");
		}
	}

	public UnixSignal(RealTimeSignum rtsig)
	{
		signum = NativeConvert.FromRealTimeSignum(rtsig);
		signal_info = install(signum);
		Errno lastError = Stdlib.GetLastError();
		if (signal_info == IntPtr.Zero)
		{
			if (lastError == Errno.EADDRINUSE)
			{
				throw new ArgumentException("Signal registered outside of Mono.Posix", "signum");
			}
			throw new ArgumentException("Unable to handle signal", "signum");
		}
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Unix_UnixSignal_install", SetLastError = true)]
	private static extern IntPtr install(int signum);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Unix_UnixSignal_uninstall")]
	private static extern int uninstall(IntPtr info);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Unix_UnixSignal_WaitAny")]
	private static extern int WaitAny(IntPtr[] infos, int count, int timeout, Mono_Posix_RuntimeIsShuttingDown shutting_down);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_SIGRTMIN")]
	internal static extern int GetSIGRTMIN();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_SIGRTMAX")]
	internal static extern int GetSIGRTMAX();

	private void AssertValid()
	{
		if (signal_info == IntPtr.Zero)
		{
			throw new ObjectDisposedException(GetType().FullName);
		}
	}

	public unsafe bool Reset()
	{
		int num = Interlocked.Exchange(ref Info->count, 0);
		return num != 0;
	}

	protected override void Dispose(bool disposing)
	{
		base.Dispose(disposing);
		if (!(signal_info == IntPtr.Zero))
		{
			uninstall(signal_info);
			signal_info = IntPtr.Zero;
		}
	}

	public override bool WaitOne()
	{
		return WaitOne(-1, exitContext: false);
	}

	public override bool WaitOne(TimeSpan timeout, bool exitContext)
	{
		long num = (long)timeout.TotalMilliseconds;
		if (num < -1 || num > int.MaxValue)
		{
			throw new ArgumentOutOfRangeException("timeout");
		}
		return WaitOne((int)num, exitContext);
	}

	public override bool WaitOne(int millisecondsTimeout, bool exitContext)
	{
		AssertValid();
		if (exitContext)
		{
			throw new InvalidOperationException("exitContext is not supported");
		}
		return WaitAny(new UnixSignal[1] { this }, millisecondsTimeout) == 0;
	}

	public static int WaitAny(UnixSignal[] signals)
	{
		return WaitAny(signals, -1);
	}

	public static int WaitAny(UnixSignal[] signals, TimeSpan timeout)
	{
		long num = (long)timeout.TotalMilliseconds;
		if (num < -1 || num > int.MaxValue)
		{
			throw new ArgumentOutOfRangeException("timeout");
		}
		return WaitAny(signals, (int)num);
	}

	public static int WaitAny(UnixSignal[] signals, int millisecondsTimeout)
	{
		if (signals == null)
		{
			throw new ArgumentNullException("signals");
		}
		if (millisecondsTimeout < -1)
		{
			throw new ArgumentOutOfRangeException("millisecondsTimeout");
		}
		IntPtr[] array = new IntPtr[signals.Length];
		for (int i = 0; i < signals.Length; i++)
		{
			ref IntPtr reference = ref array[i];
			reference = signals[i].signal_info;
			if (array[i] == IntPtr.Zero)
			{
				throw new InvalidOperationException("Disposed UnixSignal");
			}
		}
		return WaitAny(array, array.Length, millisecondsTimeout, () => Environment.HasShutdownStarted ? 1 : 0);
	}
}


using System;

[Map]
private struct SignalInfo
{
	public int signum;

	public int count;

	public int read_fd;

	public int write_fd;

	public int have_handler;

	public int pipecnt;

	public IntPtr handler;
}


using System.Runtime.InteropServices;

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
private delegate int Mono_Posix_RuntimeIsShuttingDown();


using System;
using System.IO;
using System.Runtime.InteropServices;
using Mono.Unix;
using Mono.Unix.Native;

public sealed class UnixStream : Stream, IDisposable
{
	public const int InvalidFileDescriptor = -1;

	public const int StandardInputFileDescriptor = 0;

	public const int StandardOutputFileDescriptor = 1;

	public const int StandardErrorFileDescriptor = 2;

	private bool canSeek;

	private bool canRead;

	private bool canWrite;

	private bool owner = true;

	private int fileDescriptor = -1;

	private Stat stat;

	public int Handle => fileDescriptor;

	public override bool CanRead => canRead;

	public override bool CanSeek => canSeek;

	public override bool CanWrite => canWrite;

	public override long Length
	{
		get
		{
			AssertNotDisposed();
			if (!CanSeek)
			{
				throw new NotSupportedException("File descriptor doesn't support seeking");
			}
			RefreshStat();
			return stat.st_size;
		}
	}

	public override long Position
	{
		get
		{
			AssertNotDisposed();
			if (!CanSeek)
			{
				throw new NotSupportedException("The stream does not support seeking");
			}
			long num = Syscall.lseek(fileDescriptor, 0L, SeekFlags.SEEK_CUR);
			if (num == -1)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return num;
		}
		set
		{
			Seek(value, SeekOrigin.Begin);
		}
	}

	[CLSCompliant(false)]
	public FilePermissions Protection
	{
		get
		{
			RefreshStat();
			return stat.st_mode;
		}
		set
		{
			value = (FilePermissions)((uint)value & 0xFFFF0FFFu);
			int retval = Syscall.fchmod(fileDescriptor, value);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}
	}

	public FileTypes FileType
	{
		get
		{
			int protection = (int)Protection;
			return (FileTypes)(protection & 0xF000);
		}
	}

	public FileAccessPermissions FileAccessPermissions
	{
		get
		{
			int protection = (int)Protection;
			return (FileAccessPermissions)(protection & 0x1FF);
		}
		set
		{
			int protection = (int)Protection;
			protection &= -512;
			protection |= (int)value;
			Protection = (FilePermissions)protection;
		}
	}

	public FileSpecialAttributes FileSpecialAttributes
	{
		get
		{
			int protection = (int)Protection;
			return (FileSpecialAttributes)(protection & 0xE00);
		}
		set
		{
			int protection = (int)Protection;
			protection &= -3585;
			protection |= (int)value;
			Protection = (FilePermissions)protection;
		}
	}

	public UnixUserInfo OwnerUser
	{
		get
		{
			RefreshStat();
			return new UnixUserInfo(stat.st_uid);
		}
	}

	public long OwnerUserId
	{
		get
		{
			RefreshStat();
			return stat.st_uid;
		}
	}

	public UnixGroupInfo OwnerGroup
	{
		get
		{
			RefreshStat();
			return new UnixGroupInfo(stat.st_gid);
		}
	}

	public long OwnerGroupId
	{
		get
		{
			RefreshStat();
			return stat.st_gid;
		}
	}

	public UnixStream(int fileDescriptor)
		: this(fileDescriptor, ownsHandle: true)
	{
	}

	public UnixStream(int fileDescriptor, bool ownsHandle)
	{
		if (fileDescriptor == -1)
		{
			throw new ArgumentException(Locale.GetText("Invalid file descriptor"), "fileDescriptor");
		}
		this.fileDescriptor = fileDescriptor;
		owner = ownsHandle;
		long num = Syscall.lseek(fileDescriptor, 0L, SeekFlags.SEEK_CUR);
		if (num != -1)
		{
			canSeek = true;
		}
		long num2 = Syscall.read(fileDescriptor, IntPtr.Zero, 0uL);
		if (num2 != -1)
		{
			canRead = true;
		}
		long num3 = Syscall.write(fileDescriptor, IntPtr.Zero, 0uL);
		if (num3 != -1)
		{
			canWrite = true;
		}
	}

	void IDisposable.Dispose()
	{
		AssertNotDisposed();
		if (owner)
		{
			Close();
		}
		GC.SuppressFinalize(this);
	}

	private void AssertNotDisposed()
	{
		if (fileDescriptor == -1)
		{
			throw new ObjectDisposedException("Invalid File Descriptor");
		}
	}

	private void RefreshStat()
	{
		AssertNotDisposed();
		int retval = Syscall.fstat(fileDescriptor, out stat);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public void AdviseFileAccessPattern(FileAccessPattern pattern, long offset, long len)
	{
		FileHandleOperations.AdviseFileAccessPattern(fileDescriptor, pattern, offset, len);
	}

	public void AdviseFileAccessPattern(FileAccessPattern pattern)
	{
		AdviseFileAccessPattern(pattern, 0L, 0L);
	}

	public override void Flush()
	{
	}

	public unsafe override int Read([In][Out] byte[] buffer, int offset, int count)
	{
		AssertNotDisposed();
		AssertValidBuffer(buffer, offset, count);
		if (!CanRead)
		{
			throw new NotSupportedException("Stream does not support reading");
		}
		if (buffer.Length == 0)
		{
			return 0;
		}
		long num = 0L;
		fixed (byte* buf = &buffer[offset])
		{
			do
			{
				num = Syscall.read(fileDescriptor, buf, (ulong)count);
			}
			while (UnixMarshal.ShouldRetrySyscall((int)num));
		}
		if (num == -1)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return (int)num;
	}

	private void AssertValidBuffer(byte[] buffer, int offset, int count)
	{
		if (buffer == null)
		{
			throw new ArgumentNullException("buffer");
		}
		if (offset < 0)
		{
			throw new ArgumentOutOfRangeException("offset", "< 0");
		}
		if (count < 0)
		{
			throw new ArgumentOutOfRangeException("count", "< 0");
		}
		if (offset > buffer.Length)
		{
			throw new ArgumentException("destination offset is beyond array size");
		}
		if (offset > buffer.Length - count)
		{
			throw new ArgumentException("would overrun buffer");
		}
	}

	public unsafe int ReadAtOffset([In][Out] byte[] buffer, int offset, int count, long fileOffset)
	{
		AssertNotDisposed();
		AssertValidBuffer(buffer, offset, count);
		if (!CanRead)
		{
			throw new NotSupportedException("Stream does not support reading");
		}
		if (buffer.Length == 0)
		{
			return 0;
		}
		long num = 0L;
		fixed (byte* buf = &buffer[offset])
		{
			do
			{
				num = Syscall.pread(fileDescriptor, buf, (ulong)count, fileOffset);
			}
			while (UnixMarshal.ShouldRetrySyscall((int)num));
		}
		if (num == -1)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return (int)num;
	}

	public override long Seek(long offset, SeekOrigin origin)
	{
		AssertNotDisposed();
		if (!CanSeek)
		{
			throw new NotSupportedException("The File Descriptor does not support seeking");
		}
		SeekFlags whence = SeekFlags.SEEK_CUR;
		switch (origin)
		{
		case SeekOrigin.Begin:
			whence = SeekFlags.SEEK_SET;
			break;
		case SeekOrigin.Current:
			whence = SeekFlags.SEEK_CUR;
			break;
		case SeekOrigin.End:
			whence = SeekFlags.SEEK_END;
			break;
		}
		long num = Syscall.lseek(fileDescriptor, offset, whence);
		if (num == -1)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return num;
	}

	public override void SetLength(long value)
	{
		AssertNotDisposed();
		if (value < 0)
		{
			throw new ArgumentOutOfRangeException("value", "< 0");
		}
		if (!CanSeek && !CanWrite)
		{
			throw new NotSupportedException("You can't truncating the current file descriptor");
		}
		int num;
		do
		{
			num = Syscall.ftruncate(fileDescriptor, value);
		}
		while (UnixMarshal.ShouldRetrySyscall(num));
		UnixMarshal.ThrowExceptionForLastErrorIf(num);
	}

	public unsafe override void Write(byte[] buffer, int offset, int count)
	{
		AssertNotDisposed();
		AssertValidBuffer(buffer, offset, count);
		if (!CanWrite)
		{
			throw new NotSupportedException("File Descriptor does not support writing");
		}
		if (buffer.Length == 0)
		{
			return;
		}
		long num = 0L;
		fixed (byte* buf = &buffer[offset])
		{
			do
			{
				num = Syscall.write(fileDescriptor, buf, (ulong)count);
			}
			while (UnixMarshal.ShouldRetrySyscall((int)num));
		}
		if (num == -1)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
	}

	public unsafe void WriteAtOffset(byte[] buffer, int offset, int count, long fileOffset)
	{
		AssertNotDisposed();
		AssertValidBuffer(buffer, offset, count);
		if (!CanWrite)
		{
			throw new NotSupportedException("File Descriptor does not support writing");
		}
		if (buffer.Length == 0)
		{
			return;
		}
		long num = 0L;
		fixed (byte* buf = &buffer[offset])
		{
			do
			{
				num = Syscall.pwrite(fileDescriptor, buf, (ulong)count, fileOffset);
			}
			while (UnixMarshal.ShouldRetrySyscall((int)num));
		}
		if (num == -1)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
	}

	public void SendTo(UnixStream output)
	{
		SendTo(output, (ulong)output.Length);
	}

	[CLSCompliant(false)]
	public void SendTo(UnixStream output, ulong count)
	{
		SendTo(output.Handle, count);
	}

	[CLSCompliant(false)]
	public void SendTo(int out_fd, ulong count)
	{
		if (!CanWrite)
		{
			throw new NotSupportedException("Unable to write to the current file descriptor");
		}
		long offset = Position;
		long num = Syscall.sendfile(out_fd, fileDescriptor, ref offset, count);
		if (num == -1)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
	}

	public void SetOwner(long user, long group)
	{
		AssertNotDisposed();
		int retval = Syscall.fchown(fileDescriptor, Convert.ToUInt32(user), Convert.ToUInt32(group));
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public void SetOwner(string user, string group)
	{
		AssertNotDisposed();
		long userId = new UnixUserInfo(user).UserId;
		long groupId = new UnixGroupInfo(group).GroupId;
		SetOwner(userId, groupId);
	}

	public void SetOwner(string user)
	{
		AssertNotDisposed();
		Passwd passwd = Syscall.getpwnam(user);
		if (passwd == null)
		{
			throw new ArgumentException(Locale.GetText("invalid username"), "user");
		}
		long user2 = passwd.pw_uid;
		long group = passwd.pw_gid;
		SetOwner(user2, group);
	}

	[CLSCompliant(false)]
	public long GetConfigurationValue(PathconfName name)
	{
		AssertNotDisposed();
		long num = Syscall.fpathconf(fileDescriptor, name);
		if (num == -1 && Stdlib.GetLastError() != 0)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return num;
	}

	~UnixStream()
	{
		Close();
	}

	public override void Close()
	{
		if (fileDescriptor == -1)
		{
			return;
		}
		Flush();
		if (owner)
		{
			int num;
			do
			{
				num = Syscall.close(fileDescriptor);
			}
			while (UnixMarshal.ShouldRetrySyscall(num));
			UnixMarshal.ThrowExceptionForLastErrorIf(num);
			fileDescriptor = -1;
			GC.SuppressFinalize(this);
		}
	}
}


using System;
using System.Text;
using Mono.Unix;
using Mono.Unix.Native;

public sealed class UnixSymbolicLinkInfo : UnixFileSystemInfo
{
	public override string Name => UnixPath.GetFileName(base.FullPath);

	[Obsolete("Use GetContents()")]
	public UnixFileSystemInfo Contents => GetContents();

	public string ContentsPath => ReadLink();

	public bool HasContents => TryReadLink() != null;

	public UnixSymbolicLinkInfo(string path)
		: base(path)
	{
	}

	internal UnixSymbolicLinkInfo(string path, Stat stat)
		: base(path, stat)
	{
	}

	public UnixFileSystemInfo GetContents()
	{
		string text = ReadLink();
		return UnixFileSystemInfo.GetFileSystemEntry(UnixPath.Combine(UnixPath.GetDirectoryName(base.FullPath), ContentsPath));
	}

	public void CreateSymbolicLinkTo(string path)
	{
		int retval = Syscall.symlink(path, FullName);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public void CreateSymbolicLinkTo(UnixFileSystemInfo path)
	{
		int retval = Syscall.symlink(path.FullName, FullName);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	public override void Delete()
	{
		int retval = Syscall.unlink(base.FullPath);
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		Refresh();
	}

	public override void SetOwner(long owner, long group)
	{
		int retval = Syscall.lchown(base.FullPath, Convert.ToUInt32(owner), Convert.ToUInt32(group));
		UnixMarshal.ThrowExceptionForLastErrorIf(retval);
	}

	protected override bool GetFileStatus(string path, out Stat stat)
	{
		return Syscall.lstat(path, out stat) == 0;
	}

	private string ReadLink()
	{
		string text = TryReadLink();
		if (text == null)
		{
			UnixMarshal.ThrowExceptionForLastError();
		}
		return text;
	}

	private string TryReadLink()
	{
		StringBuilder stringBuilder = new StringBuilder((int)base.Length + 1);
		int num = Syscall.readlink(base.FullPath, stringBuilder);
		if (num == -1)
		{
			return null;
		}
		return stringBuilder.ToString(0, num);
	}
}


using System;
using System.Collections;
using System.Text;
using Mono.Unix;
using Mono.Unix.Native;

public sealed class UnixUserInfo
{
	private Passwd passwd;

	public string UserName => passwd.pw_name;

	public string Password => passwd.pw_passwd;

	public long UserId => passwd.pw_uid;

	public UnixGroupInfo Group => new UnixGroupInfo(passwd.pw_gid);

	public long GroupId => passwd.pw_gid;

	public string GroupName => Group.GroupName;

	public string RealName => passwd.pw_gecos;

	public string HomeDirectory => passwd.pw_dir;

	public string ShellProgram => passwd.pw_shell;

	public UnixUserInfo(string user)
	{
		passwd = new Passwd();
		if (Syscall.getpwnam_r(user, passwd, out var pwbufp) != 0 || pwbufp == null)
		{
			throw new ArgumentException(Locale.GetText("invalid username"), "user");
		}
	}

	[CLSCompliant(false)]
	public UnixUserInfo(uint user)
	{
		passwd = new Passwd();
		if (Syscall.getpwuid_r(user, passwd, out var pwbufp) != 0 || pwbufp == null)
		{
			throw new ArgumentException(Locale.GetText("invalid user id"), "user");
		}
	}

	public UnixUserInfo(long user)
	{
		passwd = new Passwd();
		if (Syscall.getpwuid_r(Convert.ToUInt32(user), passwd, out var pwbufp) != 0 || pwbufp == null)
		{
			throw new ArgumentException(Locale.GetText("invalid user id"), "user");
		}
	}

	public UnixUserInfo(Passwd passwd)
	{
		this.passwd = CopyPasswd(passwd);
	}

	private static Passwd CopyPasswd(Passwd pw)
	{
		Passwd passwd = new Passwd();
		passwd.pw_name = pw.pw_name;
		passwd.pw_passwd = pw.pw_passwd;
		passwd.pw_uid = pw.pw_uid;
		passwd.pw_gid = pw.pw_gid;
		passwd.pw_gecos = pw.pw_gecos;
		passwd.pw_dir = pw.pw_dir;
		passwd.pw_shell = pw.pw_shell;
		return passwd;
	}

	public override int GetHashCode()
	{
		return passwd.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)GetType() != obj.GetType())
		{
			return false;
		}
		return passwd.Equals(((UnixUserInfo)obj).passwd);
	}

	public override string ToString()
	{
		return passwd.ToString();
	}

	public static UnixUserInfo GetRealUser()
	{
		return new UnixUserInfo(GetRealUserId());
	}

	public static long GetRealUserId()
	{
		return Syscall.getuid();
	}

	public static string GetLoginName()
	{
		StringBuilder stringBuilder = new StringBuilder(4);
		int num;
		do
		{
			stringBuilder.Capacity *= 2;
			num = Syscall.getlogin_r(stringBuilder, (ulong)stringBuilder.Capacity);
		}
		while (num == -1 && Stdlib.GetLastError() == Errno.ERANGE);
		UnixMarshal.ThrowExceptionForLastErrorIf(num);
		return stringBuilder.ToString();
	}

	public Passwd ToPasswd()
	{
		return CopyPasswd(passwd);
	}

	public static UnixUserInfo[] GetLocalUsers()
	{
		ArrayList arrayList = new ArrayList();
		lock (Syscall.pwd_lock)
		{
			if (Syscall.setpwent() != 0)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			try
			{
				Passwd passwd;
				while ((passwd = Syscall.getpwent()) != null)
				{
					arrayList.Add(new UnixUserInfo(passwd));
				}
				if (Stdlib.GetLastError() != 0)
				{
					UnixMarshal.ThrowExceptionForLastError();
				}
			}
			finally
			{
				Syscall.endpwent();
			}
		}
		return (UnixUserInfo[])arrayList.ToArray(typeof(UnixUserInfo));
	}
}


using System;
using System.Collections;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using System.Text;

public sealed class CdeclFunction
{
	private readonly string library;

	private readonly string method;

	private readonly Type returnType;

	private readonly AssemblyName assemblyName;

	private readonly AssemblyBuilder assemblyBuilder;

	private readonly ModuleBuilder moduleBuilder;

	private Hashtable overloads;

	public CdeclFunction(string library, string method)
		: this(library, method, typeof(void))
	{
	}

	public CdeclFunction(string library, string method, Type returnType)
	{
		this.library = library;
		this.method = method;
		this.returnType = returnType;
		overloads = new Hashtable();
		assemblyName = new AssemblyName();
		assemblyName.Name = "Mono.Posix.Imports." + library;
		assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
		moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName.Name);
	}

	public object Invoke(object[] parameters)
	{
		Type[] parameterTypes = GetParameterTypes(parameters);
		MethodInfo methodInfo = CreateMethod(parameterTypes);
		return methodInfo.Invoke(null, parameters);
	}

	private MethodInfo CreateMethod(Type[] parameterTypes)
	{
		string typeName = GetTypeName(parameterTypes);
		lock (overloads)
		{
			MethodInfo methodInfo = (MethodInfo)overloads[typeName];
			if ((object)methodInfo != null)
			{
				return methodInfo;
			}
			TypeBuilder typeBuilder = CreateType(typeName);
			typeBuilder.DefinePInvokeMethod(method, library, MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.PinvokeImpl, CallingConventions.Standard, returnType, parameterTypes, CallingConvention.Cdecl, CharSet.Ansi);
			methodInfo = typeBuilder.CreateType().GetMethod(method);
			overloads.Add(typeName, methodInfo);
			return methodInfo;
		}
	}

	private TypeBuilder CreateType(string typeName)
	{
		return moduleBuilder.DefineType(typeName, TypeAttributes.Public);
	}

	private static Type GetMarshalType(Type t)
	{
		switch (Type.GetTypeCode(t))
		{
		case TypeCode.Boolean:
		case TypeCode.Char:
		case TypeCode.SByte:
		case TypeCode.Int16:
		case TypeCode.Int32:
			return typeof(int);
		case TypeCode.Byte:
		case TypeCode.UInt16:
		case TypeCode.UInt32:
			return typeof(uint);
		case TypeCode.Int64:
			return typeof(long);
		case TypeCode.UInt64:
			return typeof(ulong);
		case TypeCode.Single:
		case TypeCode.Double:
			return typeof(double);
		default:
			return t;
		}
	}

	private string GetTypeName(Type[] parameterTypes)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("[").Append(library).Append("] ")
			.Append(method);
		stringBuilder.Append("(");
		if (parameterTypes.Length > 0)
		{
			stringBuilder.Append(parameterTypes[0]);
		}
		for (int i = 1; i < parameterTypes.Length; i++)
		{
			stringBuilder.Append(",").Append(parameterTypes[i]);
		}
		stringBuilder.Append(") : ").Append(returnType.FullName);
		return stringBuilder.ToString();
	}

	private static Type[] GetParameterTypes(object[] parameters)
	{
		Type[] array = new Type[parameters.Length];
		for (int i = 0; i < parameters.Length; i++)
		{
			array[i] = GetMarshalType(parameters[i].GetType());
		}
		return array;
	}
}


using System;
using System.Runtime.InteropServices;
using Mono.Unix;
using Mono.Unix.Native;

internal class FileNameMarshaler : ICustomMarshaler
{
	private static FileNameMarshaler Instance = new FileNameMarshaler();

	public static ICustomMarshaler GetInstance(string s)
	{
		return Instance;
	}

	public void CleanUpManagedData(object o)
	{
	}

	public void CleanUpNativeData(IntPtr pNativeData)
	{
		UnixMarshal.FreeHeap(pNativeData);
	}

	public int GetNativeDataSize()
	{
		return IntPtr.Size;
	}

	public IntPtr MarshalManagedToNative(object obj)
	{
		if (!(obj is string s))
		{
			return IntPtr.Zero;
		}
		return UnixMarshal.StringToHeap(s, UnixEncoding.Instance);
	}

	public object MarshalNativeToManaged(IntPtr pNativeData)
	{
		return UnixMarshal.PtrToString(pNativeData, UnixEncoding.Instance);
	}
}


using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Field | AttributeTargets.Delegate)]
internal class MapAttribute : Attribute
{
	private string nativeType;

	private string suppressFlags;

	public string NativeType => nativeType;

	public string SuppressFlags
	{
		get
		{
			return suppressFlags;
		}
		set
		{
			suppressFlags = value;
		}
	}

	public MapAttribute()
	{
	}

	public MapAttribute(string nativeType)
	{
		this.nativeType = nativeType;
	}
}


using System;
using System.IO;
using System.Runtime.InteropServices;
using Mono.Unix;
using Mono.Unix.Native;

[CLSCompliant(false)]
public sealed class NativeConvert
{
	private const string LIB = "MonoPosixHelper";

	public static readonly DateTime LocalUnixEpoch = new DateTime(1970, 1, 1);

	public static readonly TimeSpan LocalUtcOffset = TimeZone.CurrentTimeZone.GetUtcOffset(DateTime.UtcNow);

	private static readonly string[][] fopen_modes = new string[6][]
	{
		new string[3] { "Can't Read+Create", "wb", "w+b" },
		new string[3] { "Can't Read+Create", "wb", "w+b" },
		new string[3] { "rb", "wb", "r+b" },
		new string[3] { "rb", "wb", "r+b" },
		new string[3] { "Cannot Truncate and Read", "wb", "w+b" },
		new string[3] { "Cannot Append and Read", "ab", "a+b" }
	};

	private NativeConvert()
	{
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromRealTimeSignum")]
	private static extern int FromRealTimeSignum(int offset, out int rval);

	public static int FromRealTimeSignum(RealTimeSignum sig)
	{
		if (FromRealTimeSignum(sig.Offset, out var rval) == -1)
		{
			ThrowArgumentException(sig.Offset);
		}
		return rval;
	}

	public static RealTimeSignum ToRealTimeSignum(int offset)
	{
		return new RealTimeSignum(offset);
	}

	public static FilePermissions FromOctalPermissionString(string value)
	{
		uint value2 = Convert.ToUInt32(value, 8);
		return ToFilePermissions(value2);
	}

	public static string ToOctalPermissionString(FilePermissions value)
	{
		string text = Convert.ToString((int)value & -61441, 8);
		return new string('0', 4 - text.Length) + text;
	}

	public static FilePermissions FromUnixPermissionString(string value)
	{
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		if (value.Length != 9 && value.Length != 10)
		{
			throw new ArgumentException("value", "must contain 9 or 10 characters");
		}
		int num = 0;
		FilePermissions filePermissions = (FilePermissions)0u;
		if (value.Length == 10)
		{
			filePermissions |= GetUnixPermissionDevice(value[num]);
			num++;
		}
		filePermissions |= GetUnixPermissionGroup(value[num++], FilePermissions.S_IRUSR, value[num++], FilePermissions.S_IWUSR, value[num++], FilePermissions.S_IXUSR, 's', 'S', FilePermissions.S_ISUID);
		filePermissions |= GetUnixPermissionGroup(value[num++], FilePermissions.S_IRGRP, value[num++], FilePermissions.S_IWGRP, value[num++], FilePermissions.S_IXGRP, 's', 'S', FilePermissions.S_ISGID);
		return filePermissions | GetUnixPermissionGroup(value[num++], FilePermissions.S_IROTH, value[num++], FilePermissions.S_IWOTH, value[num++], FilePermissions.S_IXOTH, 't', 'T', FilePermissions.S_ISVTX);
	}

	private static FilePermissions GetUnixPermissionDevice(char value)
	{
		return value switch
		{
			'd' => FilePermissions.S_IFDIR, 
			'c' => FilePermissions.S_IFCHR, 
			'b' => FilePermissions.S_IFBLK, 
			'-' => FilePermissions.S_IFREG, 
			'p' => FilePermissions.S_IFIFO, 
			'l' => FilePermissions.S_IFLNK, 
			's' => FilePermissions.S_IFSOCK, 
			_ => throw new ArgumentException("value", "invalid device specification: " + value), 
		};
	}

	private static FilePermissions GetUnixPermissionGroup(char read, FilePermissions readb, char write, FilePermissions writeb, char exec, FilePermissions execb, char xboth, char xbitonly, FilePermissions xbit)
	{
		FilePermissions filePermissions = (FilePermissions)0u;
		if (read == 'r')
		{
			filePermissions |= readb;
		}
		if (write == 'w')
		{
			filePermissions |= writeb;
		}
		if (exec == 'x')
		{
			filePermissions |= execb;
		}
		else if (exec == xbitonly)
		{
			filePermissions |= xbit;
		}
		else if (exec == xboth)
		{
			filePermissions |= execb | xbit;
		}
		return filePermissions;
	}

	public static string ToUnixPermissionString(FilePermissions value)
	{
		char[] array = new char[10] { '-', '-', '-', '-', '-', '-', '-', '-', '-', '-' };
		bool flag = true;
		switch (value & FilePermissions.S_IFMT)
		{
		case FilePermissions.S_IFDIR:
			array[0] = 'd';
			break;
		case FilePermissions.S_IFCHR:
			array[0] = 'c';
			break;
		case FilePermissions.S_IFBLK:
			array[0] = 'b';
			break;
		case FilePermissions.S_IFREG:
			array[0] = '-';
			break;
		case FilePermissions.S_IFIFO:
			array[0] = 'p';
			break;
		case FilePermissions.S_IFLNK:
			array[0] = 'l';
			break;
		case FilePermissions.S_IFSOCK:
			array[0] = 's';
			break;
		default:
			flag = false;
			break;
		}
		SetUnixPermissionGroup(value, array, 1, FilePermissions.S_IRUSR, FilePermissions.S_IWUSR, FilePermissions.S_IXUSR, 's', 'S', FilePermissions.S_ISUID);
		SetUnixPermissionGroup(value, array, 4, FilePermissions.S_IRGRP, FilePermissions.S_IWGRP, FilePermissions.S_IXGRP, 's', 'S', FilePermissions.S_ISGID);
		SetUnixPermissionGroup(value, array, 7, FilePermissions.S_IROTH, FilePermissions.S_IWOTH, FilePermissions.S_IXOTH, 't', 'T', FilePermissions.S_ISVTX);
		return (!flag) ? new string(array, 1, 9) : new string(array);
	}

	private static void SetUnixPermissionGroup(FilePermissions value, char[] access, int index, FilePermissions read, FilePermissions write, FilePermissions exec, char both, char setonly, FilePermissions setxbit)
	{
		if (UnixFileSystemInfo.IsSet(value, read))
		{
			access[index] = 'r';
		}
		if (UnixFileSystemInfo.IsSet(value, write))
		{
			access[index + 1] = 'w';
		}
		access[index + 2] = GetSymbolicMode(value, exec, both, setonly, setxbit);
	}

	private static char GetSymbolicMode(FilePermissions value, FilePermissions xbit, char both, char setonly, FilePermissions setxbit)
	{
		bool flag = UnixFileSystemInfo.IsSet(value, xbit);
		bool flag2 = UnixFileSystemInfo.IsSet(value, setxbit);
		if (flag && flag2)
		{
			return both;
		}
		if (flag2)
		{
			return setonly;
		}
		if (flag)
		{
			return 'x';
		}
		return '-';
	}

	public static DateTime ToDateTime(long time)
	{
		return FromTimeT(time);
	}

	public static long FromDateTime(DateTime time)
	{
		return ToTimeT(time);
	}

	public static DateTime FromTimeT(long time)
	{
		DateTime localUnixEpoch = LocalUnixEpoch;
		double num = time;
		TimeSpan localUtcOffset = LocalUtcOffset;
		return localUnixEpoch.AddSeconds(num + localUtcOffset.TotalSeconds);
	}

	public static long ToTimeT(DateTime time)
	{
		return (long)(time.Subtract(LocalUnixEpoch) - LocalUtcOffset).TotalSeconds;
	}

	public static OpenFlags ToOpenFlags(FileMode mode, FileAccess access)
	{
		OpenFlags openFlags = OpenFlags.O_RDONLY;
		switch (mode)
		{
		case FileMode.CreateNew:
			openFlags = OpenFlags.O_CREAT | OpenFlags.O_EXCL;
			break;
		case FileMode.Create:
			openFlags = OpenFlags.O_CREAT | OpenFlags.O_TRUNC;
			break;
		case FileMode.OpenOrCreate:
			openFlags = OpenFlags.O_CREAT;
			break;
		case FileMode.Truncate:
			openFlags = OpenFlags.O_TRUNC;
			break;
		case FileMode.Append:
			openFlags = OpenFlags.O_APPEND;
			break;
		default:
			throw new ArgumentException(Locale.GetText("Unsupported mode value"), "mode");
		case FileMode.Open:
			break;
		}
		if (TryFromOpenFlags(OpenFlags.O_LARGEFILE, out var _))
		{
			openFlags |= OpenFlags.O_LARGEFILE;
		}
		return access switch
		{
			FileAccess.Read => openFlags | OpenFlags.O_RDONLY, 
			FileAccess.Write => openFlags | OpenFlags.O_WRONLY, 
			FileAccess.ReadWrite => openFlags | OpenFlags.O_RDWR, 
			_ => throw new ArgumentOutOfRangeException(Locale.GetText("Unsupported access value"), "access"), 
		};
	}

	public static string ToFopenMode(FileAccess access)
	{
		return access switch
		{
			FileAccess.Read => "rb", 
			FileAccess.Write => "wb", 
			FileAccess.ReadWrite => "r+b", 
			_ => throw new ArgumentOutOfRangeException("access"), 
		};
	}

	public static string ToFopenMode(FileMode mode)
	{
		switch (mode)
		{
		case FileMode.CreateNew:
		case FileMode.Create:
			return "w+b";
		case FileMode.Open:
		case FileMode.OpenOrCreate:
			return "r+b";
		case FileMode.Truncate:
			return "w+b";
		case FileMode.Append:
			return "a+b";
		default:
			throw new ArgumentOutOfRangeException("mode");
		}
	}

	public static string ToFopenMode(FileMode mode, FileAccess access)
	{
		int num = -1;
		int num2 = -1;
		switch (mode)
		{
		case FileMode.CreateNew:
			num = 0;
			break;
		case FileMode.Create:
			num = 1;
			break;
		case FileMode.Open:
			num = 2;
			break;
		case FileMode.OpenOrCreate:
			num = 3;
			break;
		case FileMode.Truncate:
			num = 4;
			break;
		case FileMode.Append:
			num = 5;
			break;
		}
		switch (access)
		{
		case FileAccess.Read:
			num2 = 0;
			break;
		case FileAccess.Write:
			num2 = 1;
			break;
		case FileAccess.ReadWrite:
			num2 = 2;
			break;
		}
		if (num == -1)
		{
			throw new ArgumentOutOfRangeException("mode");
		}
		if (num2 == -1)
		{
			throw new ArgumentOutOfRangeException("access");
		}
		string text = fopen_modes[num][num2];
		if (text[0] != 'r' && text[0] != 'w' && text[0] != 'a')
		{
			throw new ArgumentException(text);
		}
		return text;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromStatvfs")]
	private static extern int FromStatvfs(ref Statvfs source, IntPtr destination);

	public static bool TryCopy(ref Statvfs source, IntPtr destination)
	{
		return FromStatvfs(ref source, destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToStatvfs")]
	private static extern int ToStatvfs(IntPtr source, out Statvfs destination);

	public static bool TryCopy(IntPtr source, out Statvfs destination)
	{
		return ToStatvfs(source, out destination) == 0;
	}

	private static void ThrowArgumentException(object value)
	{
		throw new ArgumentOutOfRangeException("value", value, Locale.GetText("Current platform doesn't support this value."));
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromAccessModes")]
	private static extern int FromAccessModes(AccessModes value, out int rval);

	public static bool TryFromAccessModes(AccessModes value, out int rval)
	{
		return FromAccessModes(value, out rval) == 0;
	}

	public static int FromAccessModes(AccessModes value)
	{
		if (FromAccessModes(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToAccessModes")]
	private static extern int ToAccessModes(int value, out AccessModes rval);

	public static bool TryToAccessModes(int value, out AccessModes rval)
	{
		return ToAccessModes(value, out rval) == 0;
	}

	public static AccessModes ToAccessModes(int value)
	{
		if (ToAccessModes(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromConfstrName")]
	private static extern int FromConfstrName(ConfstrName value, out int rval);

	public static bool TryFromConfstrName(ConfstrName value, out int rval)
	{
		return FromConfstrName(value, out rval) == 0;
	}

	public static int FromConfstrName(ConfstrName value)
	{
		if (FromConfstrName(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToConfstrName")]
	private static extern int ToConfstrName(int value, out ConfstrName rval);

	public static bool TryToConfstrName(int value, out ConfstrName rval)
	{
		return ToConfstrName(value, out rval) == 0;
	}

	public static ConfstrName ToConfstrName(int value)
	{
		if (ToConfstrName(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromDirectoryNotifyFlags")]
	private static extern int FromDirectoryNotifyFlags(DirectoryNotifyFlags value, out int rval);

	public static bool TryFromDirectoryNotifyFlags(DirectoryNotifyFlags value, out int rval)
	{
		return FromDirectoryNotifyFlags(value, out rval) == 0;
	}

	public static int FromDirectoryNotifyFlags(DirectoryNotifyFlags value)
	{
		if (FromDirectoryNotifyFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToDirectoryNotifyFlags")]
	private static extern int ToDirectoryNotifyFlags(int value, out DirectoryNotifyFlags rval);

	public static bool TryToDirectoryNotifyFlags(int value, out DirectoryNotifyFlags rval)
	{
		return ToDirectoryNotifyFlags(value, out rval) == 0;
	}

	public static DirectoryNotifyFlags ToDirectoryNotifyFlags(int value)
	{
		if (ToDirectoryNotifyFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromErrno")]
	private static extern int FromErrno(Errno value, out int rval);

	public static bool TryFromErrno(Errno value, out int rval)
	{
		return FromErrno(value, out rval) == 0;
	}

	public static int FromErrno(Errno value)
	{
		if (FromErrno(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToErrno")]
	private static extern int ToErrno(int value, out Errno rval);

	public static bool TryToErrno(int value, out Errno rval)
	{
		return ToErrno(value, out rval) == 0;
	}

	public static Errno ToErrno(int value)
	{
		if (ToErrno(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromFcntlCommand")]
	private static extern int FromFcntlCommand(FcntlCommand value, out int rval);

	public static bool TryFromFcntlCommand(FcntlCommand value, out int rval)
	{
		return FromFcntlCommand(value, out rval) == 0;
	}

	public static int FromFcntlCommand(FcntlCommand value)
	{
		if (FromFcntlCommand(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToFcntlCommand")]
	private static extern int ToFcntlCommand(int value, out FcntlCommand rval);

	public static bool TryToFcntlCommand(int value, out FcntlCommand rval)
	{
		return ToFcntlCommand(value, out rval) == 0;
	}

	public static FcntlCommand ToFcntlCommand(int value)
	{
		if (ToFcntlCommand(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromFilePermissions")]
	private static extern int FromFilePermissions(FilePermissions value, out uint rval);

	public static bool TryFromFilePermissions(FilePermissions value, out uint rval)
	{
		return FromFilePermissions(value, out rval) == 0;
	}

	public static uint FromFilePermissions(FilePermissions value)
	{
		if (FromFilePermissions(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToFilePermissions")]
	private static extern int ToFilePermissions(uint value, out FilePermissions rval);

	public static bool TryToFilePermissions(uint value, out FilePermissions rval)
	{
		return ToFilePermissions(value, out rval) == 0;
	}

	public static FilePermissions ToFilePermissions(uint value)
	{
		if (ToFilePermissions(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromFlock")]
	private static extern int FromFlock(ref Flock source, IntPtr destination);

	public static bool TryCopy(ref Flock source, IntPtr destination)
	{
		return FromFlock(ref source, destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToFlock")]
	private static extern int ToFlock(IntPtr source, out Flock destination);

	public static bool TryCopy(IntPtr source, out Flock destination)
	{
		return ToFlock(source, out destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromLockType")]
	private static extern int FromLockType(LockType value, out short rval);

	public static bool TryFromLockType(LockType value, out short rval)
	{
		return FromLockType(value, out rval) == 0;
	}

	public static short FromLockType(LockType value)
	{
		if (FromLockType(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToLockType")]
	private static extern int ToLockType(short value, out LockType rval);

	public static bool TryToLockType(short value, out LockType rval)
	{
		return ToLockType(value, out rval) == 0;
	}

	public static LockType ToLockType(short value)
	{
		if (ToLockType(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromLockfCommand")]
	private static extern int FromLockfCommand(LockfCommand value, out int rval);

	public static bool TryFromLockfCommand(LockfCommand value, out int rval)
	{
		return FromLockfCommand(value, out rval) == 0;
	}

	public static int FromLockfCommand(LockfCommand value)
	{
		if (FromLockfCommand(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToLockfCommand")]
	private static extern int ToLockfCommand(int value, out LockfCommand rval);

	public static bool TryToLockfCommand(int value, out LockfCommand rval)
	{
		return ToLockfCommand(value, out rval) == 0;
	}

	public static LockfCommand ToLockfCommand(int value)
	{
		if (ToLockfCommand(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromMlockallFlags")]
	private static extern int FromMlockallFlags(MlockallFlags value, out int rval);

	public static bool TryFromMlockallFlags(MlockallFlags value, out int rval)
	{
		return FromMlockallFlags(value, out rval) == 0;
	}

	public static int FromMlockallFlags(MlockallFlags value)
	{
		if (FromMlockallFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToMlockallFlags")]
	private static extern int ToMlockallFlags(int value, out MlockallFlags rval);

	public static bool TryToMlockallFlags(int value, out MlockallFlags rval)
	{
		return ToMlockallFlags(value, out rval) == 0;
	}

	public static MlockallFlags ToMlockallFlags(int value)
	{
		if (ToMlockallFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromMmapFlags")]
	private static extern int FromMmapFlags(MmapFlags value, out int rval);

	public static bool TryFromMmapFlags(MmapFlags value, out int rval)
	{
		return FromMmapFlags(value, out rval) == 0;
	}

	public static int FromMmapFlags(MmapFlags value)
	{
		if (FromMmapFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToMmapFlags")]
	private static extern int ToMmapFlags(int value, out MmapFlags rval);

	public static bool TryToMmapFlags(int value, out MmapFlags rval)
	{
		return ToMmapFlags(value, out rval) == 0;
	}

	public static MmapFlags ToMmapFlags(int value)
	{
		if (ToMmapFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromMmapProts")]
	private static extern int FromMmapProts(MmapProts value, out int rval);

	public static bool TryFromMmapProts(MmapProts value, out int rval)
	{
		return FromMmapProts(value, out rval) == 0;
	}

	public static int FromMmapProts(MmapProts value)
	{
		if (FromMmapProts(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToMmapProts")]
	private static extern int ToMmapProts(int value, out MmapProts rval);

	public static bool TryToMmapProts(int value, out MmapProts rval)
	{
		return ToMmapProts(value, out rval) == 0;
	}

	public static MmapProts ToMmapProts(int value)
	{
		if (ToMmapProts(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromMountFlags")]
	private static extern int FromMountFlags(MountFlags value, out ulong rval);

	public static bool TryFromMountFlags(MountFlags value, out ulong rval)
	{
		return FromMountFlags(value, out rval) == 0;
	}

	public static ulong FromMountFlags(MountFlags value)
	{
		if (FromMountFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToMountFlags")]
	private static extern int ToMountFlags(ulong value, out MountFlags rval);

	public static bool TryToMountFlags(ulong value, out MountFlags rval)
	{
		return ToMountFlags(value, out rval) == 0;
	}

	public static MountFlags ToMountFlags(ulong value)
	{
		if (ToMountFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromMremapFlags")]
	private static extern int FromMremapFlags(MremapFlags value, out ulong rval);

	public static bool TryFromMremapFlags(MremapFlags value, out ulong rval)
	{
		return FromMremapFlags(value, out rval) == 0;
	}

	public static ulong FromMremapFlags(MremapFlags value)
	{
		if (FromMremapFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToMremapFlags")]
	private static extern int ToMremapFlags(ulong value, out MremapFlags rval);

	public static bool TryToMremapFlags(ulong value, out MremapFlags rval)
	{
		return ToMremapFlags(value, out rval) == 0;
	}

	public static MremapFlags ToMremapFlags(ulong value)
	{
		if (ToMremapFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromMsyncFlags")]
	private static extern int FromMsyncFlags(MsyncFlags value, out int rval);

	public static bool TryFromMsyncFlags(MsyncFlags value, out int rval)
	{
		return FromMsyncFlags(value, out rval) == 0;
	}

	public static int FromMsyncFlags(MsyncFlags value)
	{
		if (FromMsyncFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToMsyncFlags")]
	private static extern int ToMsyncFlags(int value, out MsyncFlags rval);

	public static bool TryToMsyncFlags(int value, out MsyncFlags rval)
	{
		return ToMsyncFlags(value, out rval) == 0;
	}

	public static MsyncFlags ToMsyncFlags(int value)
	{
		if (ToMsyncFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromOpenFlags")]
	private static extern int FromOpenFlags(OpenFlags value, out int rval);

	public static bool TryFromOpenFlags(OpenFlags value, out int rval)
	{
		return FromOpenFlags(value, out rval) == 0;
	}

	public static int FromOpenFlags(OpenFlags value)
	{
		if (FromOpenFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToOpenFlags")]
	private static extern int ToOpenFlags(int value, out OpenFlags rval);

	public static bool TryToOpenFlags(int value, out OpenFlags rval)
	{
		return ToOpenFlags(value, out rval) == 0;
	}

	public static OpenFlags ToOpenFlags(int value)
	{
		if (ToOpenFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromPathconfName")]
	private static extern int FromPathconfName(PathconfName value, out int rval);

	public static bool TryFromPathconfName(PathconfName value, out int rval)
	{
		return FromPathconfName(value, out rval) == 0;
	}

	public static int FromPathconfName(PathconfName value)
	{
		if (FromPathconfName(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToPathconfName")]
	private static extern int ToPathconfName(int value, out PathconfName rval);

	public static bool TryToPathconfName(int value, out PathconfName rval)
	{
		return ToPathconfName(value, out rval) == 0;
	}

	public static PathconfName ToPathconfName(int value)
	{
		if (ToPathconfName(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromPollEvents")]
	private static extern int FromPollEvents(PollEvents value, out short rval);

	public static bool TryFromPollEvents(PollEvents value, out short rval)
	{
		return FromPollEvents(value, out rval) == 0;
	}

	public static short FromPollEvents(PollEvents value)
	{
		if (FromPollEvents(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToPollEvents")]
	private static extern int ToPollEvents(short value, out PollEvents rval);

	public static bool TryToPollEvents(short value, out PollEvents rval)
	{
		return ToPollEvents(value, out rval) == 0;
	}

	public static PollEvents ToPollEvents(short value)
	{
		if (ToPollEvents(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromPollfd")]
	private static extern int FromPollfd(ref Pollfd source, IntPtr destination);

	public static bool TryCopy(ref Pollfd source, IntPtr destination)
	{
		return FromPollfd(ref source, destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToPollfd")]
	private static extern int ToPollfd(IntPtr source, out Pollfd destination);

	public static bool TryCopy(IntPtr source, out Pollfd destination)
	{
		return ToPollfd(source, out destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromPosixFadviseAdvice")]
	private static extern int FromPosixFadviseAdvice(PosixFadviseAdvice value, out int rval);

	public static bool TryFromPosixFadviseAdvice(PosixFadviseAdvice value, out int rval)
	{
		return FromPosixFadviseAdvice(value, out rval) == 0;
	}

	public static int FromPosixFadviseAdvice(PosixFadviseAdvice value)
	{
		if (FromPosixFadviseAdvice(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToPosixFadviseAdvice")]
	private static extern int ToPosixFadviseAdvice(int value, out PosixFadviseAdvice rval);

	public static bool TryToPosixFadviseAdvice(int value, out PosixFadviseAdvice rval)
	{
		return ToPosixFadviseAdvice(value, out rval) == 0;
	}

	public static PosixFadviseAdvice ToPosixFadviseAdvice(int value)
	{
		if (ToPosixFadviseAdvice(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromPosixMadviseAdvice")]
	private static extern int FromPosixMadviseAdvice(PosixMadviseAdvice value, out int rval);

	public static bool TryFromPosixMadviseAdvice(PosixMadviseAdvice value, out int rval)
	{
		return FromPosixMadviseAdvice(value, out rval) == 0;
	}

	public static int FromPosixMadviseAdvice(PosixMadviseAdvice value)
	{
		if (FromPosixMadviseAdvice(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToPosixMadviseAdvice")]
	private static extern int ToPosixMadviseAdvice(int value, out PosixMadviseAdvice rval);

	public static bool TryToPosixMadviseAdvice(int value, out PosixMadviseAdvice rval)
	{
		return ToPosixMadviseAdvice(value, out rval) == 0;
	}

	public static PosixMadviseAdvice ToPosixMadviseAdvice(int value)
	{
		if (ToPosixMadviseAdvice(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromSeekFlags")]
	private static extern int FromSeekFlags(SeekFlags value, out short rval);

	public static bool TryFromSeekFlags(SeekFlags value, out short rval)
	{
		return FromSeekFlags(value, out rval) == 0;
	}

	public static short FromSeekFlags(SeekFlags value)
	{
		if (FromSeekFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToSeekFlags")]
	private static extern int ToSeekFlags(short value, out SeekFlags rval);

	public static bool TryToSeekFlags(short value, out SeekFlags rval)
	{
		return ToSeekFlags(value, out rval) == 0;
	}

	public static SeekFlags ToSeekFlags(short value)
	{
		if (ToSeekFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromSignum")]
	private static extern int FromSignum(Signum value, out int rval);

	public static bool TryFromSignum(Signum value, out int rval)
	{
		return FromSignum(value, out rval) == 0;
	}

	public static int FromSignum(Signum value)
	{
		if (FromSignum(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToSignum")]
	private static extern int ToSignum(int value, out Signum rval);

	public static bool TryToSignum(int value, out Signum rval)
	{
		return ToSignum(value, out rval) == 0;
	}

	public static Signum ToSignum(int value)
	{
		if (ToSignum(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromStat")]
	private static extern int FromStat(ref Stat source, IntPtr destination);

	public static bool TryCopy(ref Stat source, IntPtr destination)
	{
		return FromStat(ref source, destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToStat")]
	private static extern int ToStat(IntPtr source, out Stat destination);

	public static bool TryCopy(IntPtr source, out Stat destination)
	{
		return ToStat(source, out destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromSysconfName")]
	private static extern int FromSysconfName(SysconfName value, out int rval);

	public static bool TryFromSysconfName(SysconfName value, out int rval)
	{
		return FromSysconfName(value, out rval) == 0;
	}

	public static int FromSysconfName(SysconfName value)
	{
		if (FromSysconfName(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToSysconfName")]
	private static extern int ToSysconfName(int value, out SysconfName rval);

	public static bool TryToSysconfName(int value, out SysconfName rval)
	{
		return ToSysconfName(value, out rval) == 0;
	}

	public static SysconfName ToSysconfName(int value)
	{
		if (ToSysconfName(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromSyslogFacility")]
	private static extern int FromSyslogFacility(SyslogFacility value, out int rval);

	public static bool TryFromSyslogFacility(SyslogFacility value, out int rval)
	{
		return FromSyslogFacility(value, out rval) == 0;
	}

	public static int FromSyslogFacility(SyslogFacility value)
	{
		if (FromSyslogFacility(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToSyslogFacility")]
	private static extern int ToSyslogFacility(int value, out SyslogFacility rval);

	public static bool TryToSyslogFacility(int value, out SyslogFacility rval)
	{
		return ToSyslogFacility(value, out rval) == 0;
	}

	public static SyslogFacility ToSyslogFacility(int value)
	{
		if (ToSyslogFacility(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromSyslogLevel")]
	private static extern int FromSyslogLevel(SyslogLevel value, out int rval);

	public static bool TryFromSyslogLevel(SyslogLevel value, out int rval)
	{
		return FromSyslogLevel(value, out rval) == 0;
	}

	public static int FromSyslogLevel(SyslogLevel value)
	{
		if (FromSyslogLevel(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToSyslogLevel")]
	private static extern int ToSyslogLevel(int value, out SyslogLevel rval);

	public static bool TryToSyslogLevel(int value, out SyslogLevel rval)
	{
		return ToSyslogLevel(value, out rval) == 0;
	}

	public static SyslogLevel ToSyslogLevel(int value)
	{
		if (ToSyslogLevel(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromSyslogOptions")]
	private static extern int FromSyslogOptions(SyslogOptions value, out int rval);

	public static bool TryFromSyslogOptions(SyslogOptions value, out int rval)
	{
		return FromSyslogOptions(value, out rval) == 0;
	}

	public static int FromSyslogOptions(SyslogOptions value)
	{
		if (FromSyslogOptions(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToSyslogOptions")]
	private static extern int ToSyslogOptions(int value, out SyslogOptions rval);

	public static bool TryToSyslogOptions(int value, out SyslogOptions rval)
	{
		return ToSyslogOptions(value, out rval) == 0;
	}

	public static SyslogOptions ToSyslogOptions(int value)
	{
		if (ToSyslogOptions(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromTimespec")]
	private static extern int FromTimespec(ref Timespec source, IntPtr destination);

	public static bool TryCopy(ref Timespec source, IntPtr destination)
	{
		return FromTimespec(ref source, destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToTimespec")]
	private static extern int ToTimespec(IntPtr source, out Timespec destination);

	public static bool TryCopy(IntPtr source, out Timespec destination)
	{
		return ToTimespec(source, out destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromTimeval")]
	private static extern int FromTimeval(ref Timeval source, IntPtr destination);

	public static bool TryCopy(ref Timeval source, IntPtr destination)
	{
		return FromTimeval(ref source, destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToTimeval")]
	private static extern int ToTimeval(IntPtr source, out Timeval destination);

	public static bool TryCopy(IntPtr source, out Timeval destination)
	{
		return ToTimeval(source, out destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromTimezone")]
	private static extern int FromTimezone(ref Timezone source, IntPtr destination);

	public static bool TryCopy(ref Timezone source, IntPtr destination)
	{
		return FromTimezone(ref source, destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToTimezone")]
	private static extern int ToTimezone(IntPtr source, out Timezone destination);

	public static bool TryCopy(IntPtr source, out Timezone destination)
	{
		return ToTimezone(source, out destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromUtimbuf")]
	private static extern int FromUtimbuf(ref Utimbuf source, IntPtr destination);

	public static bool TryCopy(ref Utimbuf source, IntPtr destination)
	{
		return FromUtimbuf(ref source, destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToUtimbuf")]
	private static extern int ToUtimbuf(IntPtr source, out Utimbuf destination);

	public static bool TryCopy(IntPtr source, out Utimbuf destination)
	{
		return ToUtimbuf(source, out destination) == 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromWaitOptions")]
	private static extern int FromWaitOptions(WaitOptions value, out int rval);

	public static bool TryFromWaitOptions(WaitOptions value, out int rval)
	{
		return FromWaitOptions(value, out rval) == 0;
	}

	public static int FromWaitOptions(WaitOptions value)
	{
		if (FromWaitOptions(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToWaitOptions")]
	private static extern int ToWaitOptions(int value, out WaitOptions rval);

	public static bool TryToWaitOptions(int value, out WaitOptions rval)
	{
		return ToWaitOptions(value, out rval) == 0;
	}

	public static WaitOptions ToWaitOptions(int value)
	{
		if (ToWaitOptions(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromXattrFlags")]
	private static extern int FromXattrFlags(XattrFlags value, out int rval);

	public static bool TryFromXattrFlags(XattrFlags value, out int rval)
	{
		return FromXattrFlags(value, out rval) == 0;
	}

	public static int FromXattrFlags(XattrFlags value)
	{
		if (FromXattrFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToXattrFlags")]
	private static extern int ToXattrFlags(int value, out XattrFlags rval);

	public static bool TryToXattrFlags(int value, out XattrFlags rval)
	{
		return ToXattrFlags(value, out rval) == 0;
	}

	public static XattrFlags ToXattrFlags(int value)
	{
		if (ToXattrFlags(value, out var rval) == -1)
		{
			ThrowArgumentException(value);
		}
		return rval;
	}
}


using System;
using Mono.Unix;
using Mono.Unix.Native;

public struct RealTimeSignum : IEquatable<RealTimeSignum>
{
	private int rt_offset;

	private static readonly int MaxOffset = UnixSignal.GetSIGRTMAX() - UnixSignal.GetSIGRTMIN() - 1;

	public static readonly RealTimeSignum MinValue = new RealTimeSignum(0);

	public static readonly RealTimeSignum MaxValue = new RealTimeSignum(MaxOffset);

	public int Offset => rt_offset;

	public RealTimeSignum(int offset)
	{
		if (offset < 0)
		{
			throw new ArgumentOutOfRangeException("Offset cannot be negative");
		}
		if (offset > MaxOffset)
		{
			throw new ArgumentOutOfRangeException("Offset greater than maximum supported SIGRT");
		}
		rt_offset = offset;
	}

	public override int GetHashCode()
	{
		return rt_offset.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)obj.GetType() != GetType())
		{
			return false;
		}
		return Equals((RealTimeSignum)obj);
	}

	public bool Equals(RealTimeSignum value)
	{
		return Offset == value.Offset;
	}

	public static bool operator ==(RealTimeSignum lhs, RealTimeSignum rhs)
	{
		return lhs.Equals(rhs);
	}

	public static bool operator !=(RealTimeSignum lhs, RealTimeSignum rhs)
	{
		return !lhs.Equals(rhs);
	}
}


[Map]
public enum Errno
{
	EPERM = 1,
	ENOENT = 2,
	ESRCH = 3,
	EINTR = 4,
	EIO = 5,
	ENXIO = 6,
	E2BIG = 7,
	ENOEXEC = 8,
	EBADF = 9,
	ECHILD = 10,
	EAGAIN = 11,
	ENOMEM = 12,
	EACCES = 13,
	EFAULT = 14,
	ENOTBLK = 15,
	EBUSY = 16,
	EEXIST = 17,
	EXDEV = 18,
	ENODEV = 19,
	ENOTDIR = 20,
	EISDIR = 21,
	EINVAL = 22,
	ENFILE = 23,
	EMFILE = 24,
	ENOTTY = 25,
	ETXTBSY = 26,
	EFBIG = 27,
	ENOSPC = 28,
	ESPIPE = 29,
	EROFS = 30,
	EMLINK = 31,
	EPIPE = 32,
	EDOM = 33,
	ERANGE = 34,
	EDEADLK = 35,
	ENAMETOOLONG = 36,
	ENOLCK = 37,
	ENOSYS = 38,
	ENOTEMPTY = 39,
	ELOOP = 40,
	EWOULDBLOCK = 11,
	ENOMSG = 42,
	EIDRM = 43,
	ECHRNG = 44,
	EL2NSYNC = 45,
	EL3HLT = 46,
	EL3RST = 47,
	ELNRNG = 48,
	EUNATCH = 49,
	ENOCSI = 50,
	EL2HLT = 51,
	EBADE = 52,
	EBADR = 53,
	EXFULL = 54,
	ENOANO = 55,
	EBADRQC = 56,
	EBADSLT = 57,
	EDEADLOCK = 35,
	EBFONT = 59,
	ENOSTR = 60,
	ENODATA = 61,
	ETIME = 62,
	ENOSR = 63,
	ENONET = 64,
	ENOPKG = 65,
	EREMOTE = 66,
	ENOLINK = 67,
	EADV = 68,
	ESRMNT = 69,
	ECOMM = 70,
	EPROTO = 71,
	EMULTIHOP = 72,
	EDOTDOT = 73,
	EBADMSG = 74,
	EOVERFLOW = 75,
	ENOTUNIQ = 76,
	EBADFD = 77,
	EREMCHG = 78,
	ELIBACC = 79,
	ELIBBAD = 80,
	ELIBSCN = 81,
	ELIBMAX = 82,
	ELIBEXEC = 83,
	EILSEQ = 84,
	ERESTART = 85,
	ESTRPIPE = 86,
	EUSERS = 87,
	ENOTSOCK = 88,
	EDESTADDRREQ = 89,
	EMSGSIZE = 90,
	EPROTOTYPE = 91,
	ENOPROTOOPT = 92,
	EPROTONOSUPPORT = 93,
	ESOCKTNOSUPPORT = 94,
	EOPNOTSUPP = 95,
	EPFNOSUPPORT = 96,
	EAFNOSUPPORT = 97,
	EADDRINUSE = 98,
	EADDRNOTAVAIL = 99,
	ENETDOWN = 100,
	ENETUNREACH = 101,
	ENETRESET = 102,
	ECONNABORTED = 103,
	ECONNRESET = 104,
	ENOBUFS = 105,
	EISCONN = 106,
	ENOTCONN = 107,
	ESHUTDOWN = 108,
	ETOOMANYREFS = 109,
	ETIMEDOUT = 110,
	ECONNREFUSED = 111,
	EHOSTDOWN = 112,
	EHOSTUNREACH = 113,
	EALREADY = 114,
	EINPROGRESS = 115,
	ESTALE = 116,
	EUCLEAN = 117,
	ENOTNAM = 118,
	ENAVAIL = 119,
	EISNAM = 120,
	EREMOTEIO = 121,
	EDQUOT = 122,
	ENOMEDIUM = 123,
	EMEDIUMTYPE = 124
}


using System;
using System.Runtime.InteropServices;
using System.Text;
using Mono.Unix.Native;

public sealed class FilePosition : MarshalByRefObject, IEquatable<FilePosition>, IDisposable
{
	private static readonly int FilePositionDumpSize = Stdlib.DumpFilePosition(null, new HandleRef(null, IntPtr.Zero), 0);

	private HandleRef pos;

	internal HandleRef Handle => pos;

	public FilePosition()
	{
		IntPtr intPtr = Stdlib.CreateFilePosition();
		if (intPtr == IntPtr.Zero)
		{
			throw new OutOfMemoryException("Unable to malloc fpos_t!");
		}
		pos = new HandleRef(this, intPtr);
	}

	public void Dispose()
	{
		Cleanup();
		GC.SuppressFinalize(this);
	}

	private void Cleanup()
	{
		if (pos.Handle != IntPtr.Zero)
		{
			Stdlib.free(pos.Handle);
			pos = new HandleRef(this, IntPtr.Zero);
		}
	}

	public override string ToString()
	{
		return "(" + base.ToString() + " " + GetDump() + ")";
	}

	private string GetDump()
	{
		if (FilePositionDumpSize <= 0)
		{
			return "internal error";
		}
		StringBuilder stringBuilder = new StringBuilder(FilePositionDumpSize + 1);
		if (Stdlib.DumpFilePosition(stringBuilder, Handle, FilePositionDumpSize + 1) <= 0)
		{
			return "internal error dumping fpos_t";
		}
		return stringBuilder.ToString();
	}

	public override bool Equals(object obj)
	{
		FilePosition filePosition = obj as FilePosition;
		if (obj == null || filePosition == null)
		{
			return false;
		}
		return ToString().Equals(obj.ToString());
	}

	public bool Equals(FilePosition value)
	{
		if (object.ReferenceEquals(this, value))
		{
			return true;
		}
		return ToString().Equals(value.ToString());
	}

	public override int GetHashCode()
	{
		return ToString().GetHashCode();
	}

	~FilePosition()
	{
		Cleanup();
	}

	public static bool operator ==(FilePosition lhs, FilePosition rhs)
	{
		return object.Equals(lhs, rhs);
	}

	public static bool operator !=(FilePosition lhs, FilePosition rhs)
	{
		return !object.Equals(lhs, rhs);
	}
}


public enum SignalAction
{
	Default,
	Ignore,
	Error
}


using Mono.Unix.Native;

internal class XPrintfFunctions
{
	internal delegate object XPrintf(object[] parameters);

	internal static XPrintf printf;

	internal static XPrintf fprintf;

	internal static XPrintf snprintf;

	internal static XPrintf syslog;

	static XPrintfFunctions()
	{
		CdeclFunction @object = new CdeclFunction("msvcrt", "printf", typeof(int));
		printf = @object.Invoke;
		CdeclFunction object2 = new CdeclFunction("msvcrt", "fprintf", typeof(int));
		fprintf = object2.Invoke;
		CdeclFunction object3 = new CdeclFunction("MonoPosixHelper", "Mono_Posix_Stdlib_snprintf", typeof(int));
		snprintf = object3.Invoke;
		CdeclFunction object4 = new CdeclFunction("MonoPosixHelper", "Mono_Posix_Stdlib_syslog2", typeof(int));
		syslog = object4.Invoke;
	}
}


internal delegate object XPrintf(object[] parameters);


using System;
using System.Runtime.InteropServices;
using System.Text;
using Mono.Unix;
using Mono.Unix.Native;

public class Stdlib
{
	internal const string LIBC = "msvcrt";

	internal const string MPH = "MonoPosixHelper";

	private static readonly IntPtr _SIG_DFL;

	private static readonly IntPtr _SIG_ERR;

	private static readonly IntPtr _SIG_IGN;

	[CLSCompliant(false)]
	public static readonly SignalHandler SIG_DFL;

	[CLSCompliant(false)]
	public static readonly SignalHandler SIG_ERR;

	[CLSCompliant(false)]
	public static readonly SignalHandler SIG_IGN;

	private static readonly SignalHandler[] registered_signals;

	[CLSCompliant(false)]
	public static readonly int _IOFBF;

	[CLSCompliant(false)]
	public static readonly int _IOLBF;

	[CLSCompliant(false)]
	public static readonly int _IONBF;

	[CLSCompliant(false)]
	public static readonly int BUFSIZ;

	[CLSCompliant(false)]
	public static readonly int EOF;

	[CLSCompliant(false)]
	public static readonly int FOPEN_MAX;

	[CLSCompliant(false)]
	public static readonly int FILENAME_MAX;

	[CLSCompliant(false)]
	public static readonly int L_tmpnam;

	public static readonly IntPtr stderr;

	public static readonly IntPtr stdin;

	public static readonly IntPtr stdout;

	[CLSCompliant(false)]
	public static readonly int TMP_MAX;

	private static object tmpnam_lock;

	[CLSCompliant(false)]
	public static readonly int EXIT_FAILURE;

	[CLSCompliant(false)]
	public static readonly int EXIT_SUCCESS;

	[CLSCompliant(false)]
	public static readonly int MB_CUR_MAX;

	[CLSCompliant(false)]
	public static readonly int RAND_MAX;

	private static object strerror_lock;

	internal Stdlib()
	{
	}

	static Stdlib()
	{
		_SIG_DFL = GetDefaultSignal();
		_SIG_ERR = GetErrorSignal();
		_SIG_IGN = GetIgnoreSignal();
		SIG_DFL = _DefaultHandler;
		SIG_ERR = _ErrorHandler;
		SIG_IGN = _IgnoreHandler;
		_IOFBF = GetFullyBuffered();
		_IOLBF = GetLineBuffered();
		_IONBF = GetNonBuffered();
		BUFSIZ = GetBufferSize();
		EOF = GetEOF();
		FOPEN_MAX = GetFopenMax();
		FILENAME_MAX = GetFilenameMax();
		L_tmpnam = GetTmpnamLength();
		stderr = GetStandardError();
		stdin = GetStandardInput();
		stdout = GetStandardOutput();
		TMP_MAX = GetTmpMax();
		tmpnam_lock = new object();
		EXIT_FAILURE = GetExitFailure();
		EXIT_SUCCESS = GetExitSuccess();
		MB_CUR_MAX = GetMbCurMax();
		RAND_MAX = GetRandMax();
		strerror_lock = new object();
		Array values = Enum.GetValues(typeof(Signum));
		registered_signals = new SignalHandler[(int)values.GetValue(values.Length - 1)];
	}

	public static Errno GetLastError()
	{
		int lastWin32Error = Marshal.GetLastWin32Error();
		return NativeConvert.ToErrno(lastWin32Error);
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_SetLastError")]
	private static extern void SetLastError(int error);

	protected static void SetLastError(Errno error)
	{
		int lastError = NativeConvert.FromErrno(error);
		SetLastError(lastError);
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_InvokeSignalHandler")]
	internal static extern void InvokeSignalHandler(int signum, IntPtr handler);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_SIG_DFL")]
	private static extern IntPtr GetDefaultSignal();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_SIG_ERR")]
	private static extern IntPtr GetErrorSignal();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_SIG_IGN")]
	private static extern IntPtr GetIgnoreSignal();

	private static void _ErrorHandler(int signum)
	{
		Console.Error.WriteLine("Error handler invoked for signum " + signum + ".  Don't do that.");
	}

	private static void _DefaultHandler(int signum)
	{
		Console.Error.WriteLine("Default handler invoked for signum " + signum + ".  Don't do that.");
	}

	private static void _IgnoreHandler(int signum)
	{
		Console.Error.WriteLine("Ignore handler invoked for signum " + signum + ".  Don't do that.");
	}

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "signal", SetLastError = true)]
	private static extern IntPtr sys_signal(int signum, SignalHandler handler);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "signal", SetLastError = true)]
	private static extern IntPtr sys_signal(int signum, IntPtr handler);

	[Obsolete("This is not safe; use Mono.Unix.UnixSignal for signal delivery or SetSignalAction()")]
	[CLSCompliant(false)]
	public static SignalHandler signal(Signum signum, SignalHandler handler)
	{
		int signum2 = NativeConvert.FromSignum(signum);
		Delegate[] invocationList = handler.GetInvocationList();
		for (int i = 0; i < invocationList.Length; i++)
		{
			Marshal.Prelink(invocationList[i].Method);
		}
		lock (registered_signals)
		{
			registered_signals[(int)signum] = handler;
		}
		IntPtr handler2 = ((handler == SIG_DFL) ? sys_signal(signum2, _SIG_DFL) : ((handler == SIG_ERR) ? sys_signal(signum2, _SIG_ERR) : ((!(handler == SIG_IGN)) ? sys_signal(signum2, handler) : sys_signal(signum2, _SIG_IGN))));
		return TranslateHandler(handler2);
	}

	private static SignalHandler TranslateHandler(IntPtr handler)
	{
		if (handler == _SIG_DFL)
		{
			return SIG_DFL;
		}
		if (handler == _SIG_ERR)
		{
			return SIG_ERR;
		}
		if (handler == _SIG_IGN)
		{
			return SIG_IGN;
		}
		return (SignalHandler)Marshal.GetDelegateForFunctionPointer(handler, typeof(SignalHandler));
	}

	public static int SetSignalAction(Signum signal, SignalAction action)
	{
		return SetSignalAction(NativeConvert.FromSignum(signal), action);
	}

	public static int SetSignalAction(RealTimeSignum rts, SignalAction action)
	{
		return SetSignalAction(NativeConvert.FromRealTimeSignum(rts), action);
	}

	private static int SetSignalAction(int signum, SignalAction action)
	{
		IntPtr zero = IntPtr.Zero;
		IntPtr intPtr = sys_signal(signum, action switch
		{
			SignalAction.Default => _SIG_DFL, 
			SignalAction.Ignore => _SIG_IGN, 
			SignalAction.Error => _SIG_ERR, 
			_ => throw new ArgumentException("Invalid action value.", "action"), 
		});
		if (intPtr == _SIG_ERR)
		{
			return -1;
		}
		return 0;
	}

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "raise")]
	private static extern int sys_raise(int sig);

	[CLSCompliant(false)]
	public static int raise(Signum sig)
	{
		return sys_raise(NativeConvert.FromSignum(sig));
	}

	public static int raise(RealTimeSignum rts)
	{
		return sys_raise(NativeConvert.FromRealTimeSignum(rts));
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib__IOFBF")]
	private static extern int GetFullyBuffered();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib__IOLBF")]
	private static extern int GetLineBuffered();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib__IONBF")]
	private static extern int GetNonBuffered();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_BUFSIZ")]
	private static extern int GetBufferSize();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_CreateFilePosition")]
	internal static extern IntPtr CreateFilePosition();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_DumpFilePosition")]
	internal static extern int DumpFilePosition(StringBuilder buf, HandleRef handle, int len);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_EOF")]
	private static extern int GetEOF();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_FILENAME_MAX")]
	private static extern int GetFilenameMax();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_FOPEN_MAX")]
	private static extern int GetFopenMax();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_L_tmpnam")]
	private static extern int GetTmpnamLength();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_stdin")]
	private static extern IntPtr GetStandardInput();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_stdout")]
	private static extern IntPtr GetStandardOutput();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_stderr")]
	private static extern IntPtr GetStandardError();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_TMP_MAX")]
	private static extern int GetTmpMax();

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int remove([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string filename);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int rename([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string oldpath, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string newpath);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern IntPtr tmpfile();

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "tmpnam", SetLastError = true)]
	private static extern IntPtr sys_tmpnam(StringBuilder s);

	[Obsolete("Syscall.mkstemp() should be preferred.")]
	public static string tmpnam(StringBuilder s)
	{
		if (s != null && s.Capacity < L_tmpnam)
		{
			throw new ArgumentOutOfRangeException("s", "s.Capacity < L_tmpnam");
		}
		lock (tmpnam_lock)
		{
			IntPtr p = sys_tmpnam(s);
			return UnixMarshal.PtrToString(p);
		}
	}

	[Obsolete("Syscall.mkstemp() should be preferred.")]
	public static string tmpnam()
	{
		lock (tmpnam_lock)
		{
			IntPtr p = sys_tmpnam(null);
			return UnixMarshal.PtrToString(p);
		}
	}

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int fclose(IntPtr stream);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int fflush(IntPtr stream);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern IntPtr fopen([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, string mode);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern IntPtr freopen([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, string mode, IntPtr stream);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_setbuf", SetLastError = true)]
	public static extern int setbuf(IntPtr stream, IntPtr buf);

	[CLSCompliant(false)]
	public unsafe static int setbuf(IntPtr stream, byte* buf)
	{
		return setbuf(stream, (IntPtr)buf);
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_setvbuf", SetLastError = true)]
	[CLSCompliant(false)]
	public static extern int setvbuf(IntPtr stream, IntPtr buf, int mode, ulong size);

	[CLSCompliant(false)]
	public unsafe static int setvbuf(IntPtr stream, byte* buf, int mode, ulong size)
	{
		return setvbuf(stream, (IntPtr)buf, mode, size);
	}

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fprintf")]
	private static extern int sys_fprintf(IntPtr stream, string format, string message);

	public static int fprintf(IntPtr stream, string message)
	{
		return sys_fprintf(stream, "%s", message);
	}

	[Obsolete("Not necessarily portable due to cdecl restrictions.\nUse fprintf (IntPtr, string) instead.")]
	public static int fprintf(IntPtr stream, string format, params object[] parameters)
	{
		object[] array = new object[checked(parameters.Length + 2)];
		array[0] = stream;
		array[1] = format;
		Array.Copy(parameters, 0, array, 2, parameters.Length);
		return (int)XPrintfFunctions.fprintf(array);
	}

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "printf")]
	private static extern int sys_printf(string format, string message);

	public static int printf(string message)
	{
		return sys_printf("%s", message);
	}

	[Obsolete("Not necessarily portable due to cdecl restrictions.\nUse printf (string) instead.")]
	public static int printf(string format, params object[] parameters)
	{
		object[] array = new object[checked(parameters.Length + 1)];
		array[0] = format;
		Array.Copy(parameters, 0, array, 1, parameters.Length);
		return (int)XPrintfFunctions.printf(array);
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_snprintf")]
	private static extern int sys_snprintf(StringBuilder s, ulong n, string format, string message);

	[CLSCompliant(false)]
	public static int snprintf(StringBuilder s, ulong n, string message)
	{
		if (n > (ulong)s.Capacity)
		{
			throw new ArgumentOutOfRangeException("n", "n must be <= s.Capacity");
		}
		return sys_snprintf(s, n, "%s", message);
	}

	public static int snprintf(StringBuilder s, string message)
	{
		return sys_snprintf(s, (ulong)s.Capacity, "%s", message);
	}

	[Obsolete("Not necessarily portable due to cdecl restrictions.\nUse snprintf (StringBuilder, string) instead.")]
	[CLSCompliant(false)]
	public static int snprintf(StringBuilder s, ulong n, string format, params object[] parameters)
	{
		if (n > (ulong)s.Capacity)
		{
			throw new ArgumentOutOfRangeException("n", "n must be <= s.Capacity");
		}
		object[] array = new object[checked(parameters.Length + 3)];
		array[0] = s;
		array[1] = n;
		array[2] = format;
		Array.Copy(parameters, 0, array, 3, parameters.Length);
		return (int)XPrintfFunctions.snprintf(array);
	}

	[CLSCompliant(false)]
	[Obsolete("Not necessarily portable due to cdecl restrictions.\nUse snprintf (StringBuilder, string) instead.")]
	public static int snprintf(StringBuilder s, string format, params object[] parameters)
	{
		object[] array = new object[checked(parameters.Length + 3)];
		array[0] = s;
		array[1] = (ulong)s.Capacity;
		array[2] = format;
		Array.Copy(parameters, 0, array, 3, parameters.Length);
		return (int)XPrintfFunctions.snprintf(array);
	}

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int fgetc(IntPtr stream);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fgets", SetLastError = true)]
	private static extern IntPtr sys_fgets(StringBuilder sb, int size, IntPtr stream);

	public static StringBuilder fgets(StringBuilder sb, int size, IntPtr stream)
	{
		IntPtr intPtr = sys_fgets(sb, size, stream);
		if (intPtr == IntPtr.Zero)
		{
			return null;
		}
		return sb;
	}

	public static StringBuilder fgets(StringBuilder sb, IntPtr stream)
	{
		return fgets(sb, sb.Capacity, stream);
	}

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int fputc(int c, IntPtr stream);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int fputs(string s, IntPtr stream);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int getc(IntPtr stream);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int getchar();

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int putc(int c, IntPtr stream);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int putchar(int c);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int puts(string s);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	public static extern int ungetc(int c, IntPtr stream);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fread", SetLastError = true)]
	[CLSCompliant(false)]
	public static extern ulong fread(IntPtr ptr, ulong size, ulong nmemb, IntPtr stream);

	[CLSCompliant(false)]
	public unsafe static ulong fread(void* ptr, ulong size, ulong nmemb, IntPtr stream)
	{
		return fread((IntPtr)ptr, size, nmemb, stream);
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fread", SetLastError = true)]
	private static extern ulong sys_fread([Out] byte[] ptr, ulong size, ulong nmemb, IntPtr stream);

	[CLSCompliant(false)]
	public static ulong fread(byte[] ptr, ulong size, ulong nmemb, IntPtr stream)
	{
		if (size * nmemb > (ulong)ptr.Length)
		{
			throw new ArgumentOutOfRangeException("nmemb");
		}
		return sys_fread(ptr, size, nmemb, stream);
	}

	[CLSCompliant(false)]
	public static ulong fread(byte[] ptr, IntPtr stream)
	{
		return fread(ptr, 1uL, (ulong)ptr.Length, stream);
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fwrite", SetLastError = true)]
	[CLSCompliant(false)]
	public static extern ulong fwrite(IntPtr ptr, ulong size, ulong nmemb, IntPtr stream);

	[CLSCompliant(false)]
	public unsafe static ulong fwrite(void* ptr, ulong size, ulong nmemb, IntPtr stream)
	{
		return fwrite((IntPtr)ptr, size, nmemb, stream);
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fwrite", SetLastError = true)]
	private static extern ulong sys_fwrite(byte[] ptr, ulong size, ulong nmemb, IntPtr stream);

	[CLSCompliant(false)]
	public static ulong fwrite(byte[] ptr, ulong size, ulong nmemb, IntPtr stream)
	{
		if (size * nmemb > (ulong)ptr.Length)
		{
			throw new ArgumentOutOfRangeException("nmemb");
		}
		return sys_fwrite(ptr, size, nmemb, stream);
	}

	[CLSCompliant(false)]
	public static ulong fwrite(byte[] ptr, IntPtr stream)
	{
		return fwrite(ptr, 1uL, (ulong)ptr.Length, stream);
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fgetpos", SetLastError = true)]
	private static extern int sys_fgetpos(IntPtr stream, HandleRef pos);

	public static int fgetpos(IntPtr stream, FilePosition pos)
	{
		return sys_fgetpos(stream, pos.Handle);
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fseek", SetLastError = true)]
	private static extern int sys_fseek(IntPtr stream, long offset, int origin);

	[CLSCompliant(false)]
	public static int fseek(IntPtr stream, long offset, SeekFlags origin)
	{
		int origin2 = NativeConvert.FromSeekFlags(origin);
		return sys_fseek(stream, offset, origin2);
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fsetpos", SetLastError = true)]
	private static extern int sys_fsetpos(IntPtr stream, HandleRef pos);

	public static int fsetpos(IntPtr stream, FilePosition pos)
	{
		return sys_fsetpos(stream, pos.Handle);
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_ftell", SetLastError = true)]
	public static extern long ftell(IntPtr stream);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_rewind", SetLastError = true)]
	public static extern int rewind(IntPtr stream);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_clearerr", SetLastError = true)]
	public static extern int clearerr(IntPtr stream);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
	public static extern int feof(IntPtr stream);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
	public static extern int ferror(IntPtr stream);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_perror", SetLastError = true)]
	private static extern int perror(string s, int err);

	public static int perror(string s)
	{
		return perror(s, Marshal.GetLastWin32Error());
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_EXIT_FAILURE")]
	private static extern int GetExitFailure();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_EXIT_SUCCESS")]
	private static extern int GetExitSuccess();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_MB_CUR_MAX")]
	private static extern int GetMbCurMax();

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_RAND_MAX")]
	private static extern int GetRandMax();

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
	public static extern int rand();

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
	[CLSCompliant(false)]
	public static extern void srand(uint seed);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_calloc", SetLastError = true)]
	[CLSCompliant(false)]
	public static extern IntPtr calloc(ulong nmemb, ulong size);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
	public static extern void free(IntPtr ptr);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_malloc", SetLastError = true)]
	[CLSCompliant(false)]
	public static extern IntPtr malloc(ulong size);

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_realloc", SetLastError = true)]
	[CLSCompliant(false)]
	public static extern IntPtr realloc(IntPtr ptr, ulong size);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
	public static extern void abort();

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
	public static extern void exit(int status);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
	[CLSCompliant(false)]
	public static extern void _Exit(int status);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "getenv")]
	private static extern IntPtr sys_getenv(string name);

	public static string getenv(string name)
	{
		IntPtr p = sys_getenv(name);
		return UnixMarshal.PtrToString(p);
	}

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[CLSCompliant(false)]
	public static extern int system(string @string);

	[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "strerror", SetLastError = true)]
	private static extern IntPtr sys_strerror(int errnum);

	[CLSCompliant(false)]
	public static string strerror(Errno errnum)
	{
		int errnum2 = NativeConvert.FromErrno(errnum);
		lock (strerror_lock)
		{
			IntPtr p = sys_strerror(errnum2);
			return UnixMarshal.PtrToString(p);
		}
	}

	[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_strlen", SetLastError = true)]
	[CLSCompliant(false)]
	public static extern ulong strlen(IntPtr s);
}


using System;

[Map]
[CLSCompliant(false)]
[Flags]
public enum SyslogOptions
{
	LOG_PID = 1,
	LOG_CONS = 2,
	LOG_ODELAY = 4,
	LOG_NDELAY = 8,
	LOG_NOWAIT = 0x10,
	LOG_PERROR = 0x20
}


using System;

[CLSCompliant(false)]
[Map]
public enum SyslogFacility
{
	LOG_KERN = 0,
	LOG_USER = 8,
	LOG_MAIL = 16,
	LOG_DAEMON = 24,
	LOG_AUTH = 32,
	LOG_SYSLOG = 40,
	LOG_LPR = 48,
	LOG_NEWS = 56,
	LOG_UUCP = 64,
	LOG_CRON = 72,
	LOG_AUTHPRIV = 80,
	LOG_FTP = 88,
	LOG_LOCAL0 = 128,
	LOG_LOCAL1 = 136,
	LOG_LOCAL2 = 144,
	LOG_LOCAL3 = 152,
	LOG_LOCAL4 = 160,
	LOG_LOCAL5 = 168,
	LOG_LOCAL6 = 176,
	LOG_LOCAL7 = 184
}


using System;

[Map]
[CLSCompliant(false)]
public enum SyslogLevel
{
	LOG_EMERG,
	LOG_ALERT,
	LOG_CRIT,
	LOG_ERR,
	LOG_WARNING,
	LOG_NOTICE,
	LOG_INFO,
	LOG_DEBUG
}


using System;

[Map]
[CLSCompliant(false)]
[Flags]
public enum OpenFlags
{
	O_RDONLY = 0,
	O_WRONLY = 1,
	O_RDWR = 2,
	O_CREAT = 0x40,
	O_EXCL = 0x80,
	O_NOCTTY = 0x100,
	O_TRUNC = 0x200,
	O_APPEND = 0x400,
	O_NONBLOCK = 0x800,
	O_SYNC = 0x1000,
	O_NOFOLLOW = 0x20000,
	O_DIRECTORY = 0x10000,
	O_DIRECT = 0x4000,
	O_ASYNC = 0x2000,
	O_LARGEFILE = 0x8000
}


using System;

[CLSCompliant(false)]
[Flags]
[Map]
public enum FilePermissions : uint
{
	S_ISUID = 0x800u,
	S_ISGID = 0x400u,
	S_ISVTX = 0x200u,
	S_IRUSR = 0x100u,
	S_IWUSR = 0x80u,
	S_IXUSR = 0x40u,
	S_IRGRP = 0x20u,
	S_IWGRP = 0x10u,
	S_IXGRP = 8u,
	S_IROTH = 4u,
	S_IWOTH = 2u,
	S_IXOTH = 1u,
	S_IRWXG = 0x38u,
	S_IRWXU = 0x1C0u,
	S_IRWXO = 7u,
	ACCESSPERMS = 0x1FFu,
	ALLPERMS = 0xFFFu,
	DEFFILEMODE = 0x1B6u,
	S_IFMT = 0xF000u,
	[Map(SuppressFlags = "S_IFMT")]
	S_IFDIR = 0x4000u,
	[Map(SuppressFlags = "S_IFMT")]
	S_IFCHR = 0x2000u,
	[Map(SuppressFlags = "S_IFMT")]
	S_IFBLK = 0x6000u,
	[Map(SuppressFlags = "S_IFMT")]
	S_IFREG = 0x8000u,
	[Map(SuppressFlags = "S_IFMT")]
	S_IFIFO = 0x1000u,
	[Map(SuppressFlags = "S_IFMT")]
	S_IFLNK = 0xA000u,
	[Map(SuppressFlags = "S_IFMT")]
	S_IFSOCK = 0xC000u
}


using System;

[CLSCompliant(false)]
[Map]
public enum FcntlCommand
{
	F_DUPFD = 0,
	F_GETFD = 1,
	F_SETFD = 2,
	F_GETFL = 3,
	F_SETFL = 4,
	F_GETLK = 12,
	F_SETLK = 13,
	F_SETLKW = 14,
	F_SETOWN = 8,
	F_GETOWN = 9,
	F_SETSIG = 10,
	F_GETSIG = 11,
	F_SETLEASE = 1024,
	F_GETLEASE = 1025,
	F_NOTIFY = 1026
}


using System;

[Map]
[CLSCompliant(false)]
public enum LockType : short
{
	F_RDLCK,
	F_WRLCK,
	F_UNLCK
}


using System;

[CLSCompliant(false)]
[Map]
public enum SeekFlags : short
{
	SEEK_SET = 0,
	SEEK_CUR = 1,
	SEEK_END = 2,
	L_SET = 0,
	L_INCR = 1,
	L_XTND = 2
}


using System;

[CLSCompliant(false)]
[Flags]
[Map]
public enum DirectoryNotifyFlags
{
	DN_ACCESS = 1,
	DN_MODIFY = 2,
	DN_CREATE = 4,
	DN_DELETE = 8,
	DN_RENAME = 0x10,
	DN_ATTRIB = 0x20,
	DN_MULTISHOT = int.MinValue
}


using System;

[Map]
[CLSCompliant(false)]
public enum PosixFadviseAdvice
{
	POSIX_FADV_NORMAL,
	POSIX_FADV_RANDOM,
	POSIX_FADV_SEQUENTIAL,
	POSIX_FADV_WILLNEED,
	POSIX_FADV_DONTNEED,
	POSIX_FADV_NOREUSE
}


using System;

[CLSCompliant(false)]
[Map]
public enum PosixMadviseAdvice
{
	POSIX_MADV_NORMAL,
	POSIX_MADV_RANDOM,
	POSIX_MADV_SEQUENTIAL,
	POSIX_MADV_WILLNEED,
	POSIX_MADV_DONTNEED
}


[Map]
public enum Signum
{
	SIGHUP = 1,
	SIGINT = 2,
	SIGQUIT = 3,
	SIGILL = 4,
	SIGTRAP = 5,
	SIGABRT = 6,
	SIGIOT = 6,
	SIGBUS = 7,
	SIGFPE = 8,
	SIGKILL = 9,
	SIGUSR1 = 10,
	SIGSEGV = 11,
	SIGUSR2 = 12,
	SIGPIPE = 13,
	SIGALRM = 14,
	SIGTERM = 15,
	SIGSTKFLT = 16,
	SIGCLD = 17,
	SIGCHLD = 17,
	SIGCONT = 18,
	SIGSTOP = 19,
	SIGTSTP = 20,
	SIGTTIN = 21,
	SIGTTOU = 22,
	SIGURG = 23,
	SIGXCPU = 24,
	SIGXFSZ = 25,
	SIGVTALRM = 26,
	SIGPROF = 27,
	SIGWINCH = 28,
	SIGPOLL = 29,
	SIGIO = 29,
	SIGPWR = 30,
	SIGSYS = 31,
	SIGUNUSED = 31
}


using System;

[Flags]
[Map]
public enum WaitOptions
{
	WNOHANG = 1,
	WUNTRACED = 2
}


using System;

[CLSCompliant(false)]
[Map]
[Flags]
public enum AccessModes
{
	R_OK = 1,
	W_OK = 2,
	X_OK = 4,
	F_OK = 8
}


using System;

[Map]
[CLSCompliant(false)]
public enum PathconfName
{
	_PC_LINK_MAX,
	_PC_MAX_CANON,
	_PC_MAX_INPUT,
	_PC_NAME_MAX,
	_PC_PATH_MAX,
	_PC_PIPE_BUF,
	_PC_CHOWN_RESTRICTED,
	_PC_NO_TRUNC,
	_PC_VDISABLE,
	_PC_SYNC_IO,
	_PC_ASYNC_IO,
	_PC_PRIO_IO,
	_PC_SOCK_MAXBUF,
	_PC_FILESIZEBITS,
	_PC_REC_INCR_XFER_SIZE,
	_PC_REC_MAX_XFER_SIZE,
	_PC_REC_MIN_XFER_SIZE,
	_PC_REC_XFER_ALIGN,
	_PC_ALLOC_SIZE_MIN,
	_PC_SYMLINK_MAX,
	_PC_2_SYMLINKS
}


using System;

[Map]
[CLSCompliant(false)]
public enum SysconfName
{
	_SC_ARG_MAX = 0,
	_SC_CHILD_MAX = 1,
	_SC_CLK_TCK = 2,
	_SC_NGROUPS_MAX = 3,
	_SC_OPEN_MAX = 4,
	_SC_STREAM_MAX = 5,
	_SC_TZNAME_MAX = 6,
	_SC_JOB_CONTROL = 7,
	_SC_SAVED_IDS = 8,
	_SC_REALTIME_SIGNALS = 9,
	_SC_PRIORITY_SCHEDULING = 10,
	_SC_TIMERS = 11,
	_SC_ASYNCHRONOUS_IO = 12,
	_SC_PRIORITIZED_IO = 13,
	_SC_SYNCHRONIZED_IO = 14,
	_SC_FSYNC = 15,
	_SC_MAPPED_FILES = 16,
	_SC_MEMLOCK = 17,
	_SC_MEMLOCK_RANGE = 18,
	_SC_MEMORY_PROTECTION = 19,
	_SC_MESSAGE_PASSING = 20,
	_SC_SEMAPHORES = 21,
	_SC_SHARED_MEMORY_OBJECTS = 22,
	_SC_AIO_LISTIO_MAX = 23,
	_SC_AIO_MAX = 24,
	_SC_AIO_PRIO_DELTA_MAX = 25,
	_SC_DELAYTIMER_MAX = 26,
	_SC_MQ_OPEN_MAX = 27,
	_SC_MQ_PRIO_MAX = 28,
	_SC_VERSION = 29,
	_SC_PAGESIZE = 30,
	_SC_RTSIG_MAX = 31,
	_SC_SEM_NSEMS_MAX = 32,
	_SC_SEM_VALUE_MAX = 33,
	_SC_SIGQUEUE_MAX = 34,
	_SC_TIMER_MAX = 35,
	_SC_BC_BASE_MAX = 36,
	_SC_BC_DIM_MAX = 37,
	_SC_BC_SCALE_MAX = 38,
	_SC_BC_STRING_MAX = 39,
	_SC_COLL_WEIGHTS_MAX = 40,
	_SC_EQUIV_CLASS_MAX = 41,
	_SC_EXPR_NEST_MAX = 42,
	_SC_LINE_MAX = 43,
	_SC_RE_DUP_MAX = 44,
	_SC_CHARCLASS_NAME_MAX = 45,
	_SC_2_VERSION = 46,
	_SC_2_C_BIND = 47,
	_SC_2_C_DEV = 48,
	_SC_2_FORT_DEV = 49,
	_SC_2_FORT_RUN = 50,
	_SC_2_SW_DEV = 51,
	_SC_2_LOCALEDEF = 52,
	_SC_PII = 53,
	_SC_PII_XTI = 54,
	_SC_PII_SOCKET = 55,
	_SC_PII_INTERNET = 56,
	_SC_PII_OSI = 57,
	_SC_POLL = 58,
	_SC_SELECT = 59,
	_SC_UIO_MAXIOV = 60,
	_SC_IOV_MAX = 60,
	_SC_PII_INTERNET_STREAM = 61,
	_SC_PII_INTERNET_DGRAM = 62,
	_SC_PII_OSI_COTS = 63,
	_SC_PII_OSI_CLTS = 64,
	_SC_PII_OSI_M = 65,
	_SC_T_IOV_MAX = 66,
	_SC_THREADS = 67,
	_SC_THREAD_SAFE_FUNCTIONS = 68,
	_SC_GETGR_R_SIZE_MAX = 69,
	_SC_GETPW_R_SIZE_MAX = 70,
	_SC_LOGIN_NAME_MAX = 71,
	_SC_TTY_NAME_MAX = 72,
	_SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
	_SC_THREAD_KEYS_MAX = 74,
	_SC_THREAD_STACK_MIN = 75,
	_SC_THREAD_THREADS_MAX = 76,
	_SC_THREAD_ATTR_STACKADDR = 77,
	_SC_THREAD_ATTR_STACKSIZE = 78,
	_SC_THREAD_PRIORITY_SCHEDULING = 79,
	_SC_THREAD_PRIO_INHERIT = 80,
	_SC_THREAD_PRIO_PROTECT = 81,
	_SC_THREAD_PROCESS_SHARED = 82,
	_SC_NPROCESSORS_CONF = 83,
	_SC_NPROCESSORS_ONLN = 84,
	_SC_PHYS_PAGES = 85,
	_SC_AVPHYS_PAGES = 86,
	_SC_ATEXIT_MAX = 87,
	_SC_PASS_MAX = 88,
	_SC_XOPEN_VERSION = 89,
	_SC_XOPEN_XCU_VERSION = 90,
	_SC_XOPEN_UNIX = 91,
	_SC_XOPEN_CRYPT = 92,
	_SC_XOPEN_ENH_I18N = 93,
	_SC_XOPEN_SHM = 94,
	_SC_2_CHAR_TERM = 95,
	_SC_2_C_VERSION = 96,
	_SC_2_UPE = 97,
	_SC_XOPEN_XPG2 = 98,
	_SC_XOPEN_XPG3 = 99,
	_SC_XOPEN_XPG4 = 100,
	_SC_CHAR_BIT = 101,
	_SC_CHAR_MAX = 102,
	_SC_CHAR_MIN = 103,
	_SC_INT_MAX = 104,
	_SC_INT_MIN = 105,
	_SC_LONG_BIT = 106,
	_SC_WORD_BIT = 107,
	_SC_MB_LEN_MAX = 108,
	_SC_NZERO = 109,
	_SC_SSIZE_MAX = 110,
	_SC_SCHAR_MAX = 111,
	_SC_SCHAR_MIN = 112,
	_SC_SHRT_MAX = 113,
	_SC_SHRT_MIN = 114,
	_SC_UCHAR_MAX = 115,
	_SC_UINT_MAX = 116,
	_SC_ULONG_MAX = 117,
	_SC_USHRT_MAX = 118,
	_SC_NL_ARGMAX = 119,
	_SC_NL_LANGMAX = 120,
	_SC_NL_MSGMAX = 121,
	_SC_NL_NMAX = 122,
	_SC_NL_SETMAX = 123,
	_SC_NL_TEXTMAX = 124,
	_SC_XBS5_ILP32_OFF32 = 125,
	_SC_XBS5_ILP32_OFFBIG = 126,
	_SC_XBS5_LP64_OFF64 = 127,
	_SC_XBS5_LPBIG_OFFBIG = 128,
	_SC_XOPEN_LEGACY = 129,
	_SC_XOPEN_REALTIME = 130,
	_SC_XOPEN_REALTIME_THREADS = 131,
	_SC_ADVISORY_INFO = 132,
	_SC_BARRIERS = 133,
	_SC_BASE = 134,
	_SC_C_LANG_SUPPORT = 135,
	_SC_C_LANG_SUPPORT_R = 136,
	_SC_CLOCK_SELECTION = 137,
	_SC_CPUTIME = 138,
	_SC_THREAD_CPUTIME = 139,
	_SC_DEVICE_IO = 140,
	_SC_DEVICE_SPECIFIC = 141,
	_SC_DEVICE_SPECIFIC_R = 142,
	_SC_FD_MGMT = 143,
	_SC_FIFO = 144,
	_SC_PIPE = 145,
	_SC_FILE_ATTRIBUTES = 146,
	_SC_FILE_LOCKING = 147,
	_SC_FILE_SYSTEM = 148,
	_SC_MONOTONIC_CLOCK = 149,
	_SC_MULTI_PROCESS = 150,
	_SC_SINGLE_PROCESS = 151,
	_SC_NETWORKING = 152,
	_SC_READER_WRITER_LOCKS = 153,
	_SC_SPIN_LOCKS = 154,
	_SC_REGEXP = 155,
	_SC_REGEX_VERSION = 156,
	_SC_SHELL = 157,
	_SC_SIGNALS = 158,
	_SC_SPAWN = 159,
	_SC_SPORADIC_SERVER = 160,
	_SC_THREAD_SPORADIC_SERVER = 161,
	_SC_SYSTEM_DATABASE = 162,
	_SC_SYSTEM_DATABASE_R = 163,
	_SC_TIMEOUTS = 164,
	_SC_TYPED_MEMORY_OBJECTS = 165,
	_SC_USER_GROUPS = 166,
	_SC_USER_GROUPS_R = 167,
	_SC_2_PBS = 168,
	_SC_2_PBS_ACCOUNTING = 169,
	_SC_2_PBS_LOCATE = 170,
	_SC_2_PBS_MESSAGE = 171,
	_SC_2_PBS_TRACK = 172,
	_SC_SYMLOOP_MAX = 173,
	_SC_STREAMS = 174,
	_SC_2_PBS_CHECKPOINT = 175,
	_SC_V6_ILP32_OFF32 = 176,
	_SC_V6_ILP32_OFFBIG = 177,
	_SC_V6_LP64_OFF64 = 178,
	_SC_V6_LPBIG_OFFBIG = 179,
	_SC_HOST_NAME_MAX = 180,
	_SC_TRACE = 181,
	_SC_TRACE_EVENT_FILTER = 182,
	_SC_TRACE_INHERIT = 183,
	_SC_TRACE_LOG = 184,
	_SC_LEVEL1_ICACHE_SIZE = 185,
	_SC_LEVEL1_ICACHE_ASSOC = 186,
	_SC_LEVEL1_ICACHE_LINESIZE = 187,
	_SC_LEVEL1_DCACHE_SIZE = 188,
	_SC_LEVEL1_DCACHE_ASSOC = 189,
	_SC_LEVEL1_DCACHE_LINESIZE = 190,
	_SC_LEVEL2_CACHE_SIZE = 191,
	_SC_LEVEL2_CACHE_ASSOC = 192,
	_SC_LEVEL2_CACHE_LINESIZE = 193,
	_SC_LEVEL3_CACHE_SIZE = 194,
	_SC_LEVEL3_CACHE_ASSOC = 195,
	_SC_LEVEL3_CACHE_LINESIZE = 196,
	_SC_LEVEL4_CACHE_SIZE = 197,
	_SC_LEVEL4_CACHE_ASSOC = 198,
	_SC_LEVEL4_CACHE_LINESIZE = 199
}


using System;

[Map]
[CLSCompliant(false)]
public enum ConfstrName
{
	_CS_PATH = 0,
	_CS_V6_WIDTH_RESTRICTED_ENVS = 1,
	_CS_GNU_LIBC_VERSION = 2,
	_CS_GNU_LIBPTHREAD_VERSION = 3,
	_CS_LFS_CFLAGS = 1000,
	_CS_LFS_LDFLAGS = 1001,
	_CS_LFS_LIBS = 1002,
	_CS_LFS_LINTFLAGS = 1003,
	_CS_LFS64_CFLAGS = 1004,
	_CS_LFS64_LDFLAGS = 1005,
	_CS_LFS64_LIBS = 1006,
	_CS_LFS64_LINTFLAGS = 1007,
	_CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
	_CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
	_CS_XBS5_ILP32_OFF32_LIBS = 1102,
	_CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
	_CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
	_CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
	_CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
	_CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
	_CS_XBS5_LP64_OFF64_CFLAGS = 1108,
	_CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
	_CS_XBS5_LP64_OFF64_LIBS = 1110,
	_CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
	_CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
	_CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
	_CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
	_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
	_CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
	_CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
	_CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
	_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
	_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
	_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
	_CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
	_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
	_CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
	_CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
	_CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
	_CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
	_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
	_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
	_CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
	_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131
}


using System;

[CLSCompliant(false)]
[Map]
public enum LockfCommand
{
	F_ULOCK,
	F_LOCK,
	F_TLOCK,
	F_TEST
}


using System;

[Map]
[Flags]
public enum PollEvents : short
{
	POLLIN = 1,
	POLLPRI = 2,
	POLLOUT = 4,
	POLLERR = 8,
	POLLHUP = 0x10,
	POLLNVAL = 0x20,
	POLLRDNORM = 0x40,
	POLLRDBAND = 0x80,
	POLLWRNORM = 0x100,
	POLLWRBAND = 0x200
}


using System;

[CLSCompliant(false)]
[Flags]
[Map]
public enum XattrFlags
{
	XATTR_AUTO = 0,
	XATTR_CREATE = 1,
	XATTR_REPLACE = 2
}


using System;

[Map]
[Flags]
[CLSCompliant(false)]
public enum MountFlags : ulong
{
	ST_RDONLY = 1uL,
	ST_NOSUID = 2uL,
	ST_NODEV = 4uL,
	ST_NOEXEC = 8uL,
	ST_SYNCHRONOUS = 0x10uL,
	ST_REMOUNT = 0x20uL,
	ST_MANDLOCK = 0x40uL,
	ST_WRITE = 0x80uL,
	ST_APPEND = 0x100uL,
	ST_IMMUTABLE = 0x200uL,
	ST_NOATIME = 0x400uL,
	ST_NODIRATIME = 0x800uL,
	ST_BIND = 0x1000uL
}


using System;

[Map]
[Flags]
[CLSCompliant(false)]
public enum MmapFlags
{
	MAP_SHARED = 1,
	MAP_PRIVATE = 2,
	MAP_TYPE = 0xF,
	MAP_FIXED = 0x10,
	MAP_FILE = 0,
	MAP_ANONYMOUS = 0x20,
	MAP_ANON = 0x20,
	MAP_GROWSDOWN = 0x100,
	MAP_DENYWRITE = 0x800,
	MAP_EXECUTABLE = 0x1000,
	MAP_LOCKED = 0x2000,
	MAP_NORESERVE = 0x4000,
	MAP_POPULATE = 0x8000,
	MAP_NONBLOCK = 0x10000
}


using System;

[CLSCompliant(false)]
[Map]
[Flags]
public enum MmapProts
{
	PROT_READ = 1,
	PROT_WRITE = 2,
	PROT_EXEC = 4,
	PROT_NONE = 0,
	PROT_GROWSDOWN = 0x1000000,
	PROT_GROWSUP = 0x2000000
}


using System;

[Flags]
[CLSCompliant(false)]
[Map]
public enum MsyncFlags
{
	MS_ASYNC = 1,
	MS_SYNC = 4,
	MS_INVALIDATE = 2
}


using System;

[CLSCompliant(false)]
[Flags]
[Map]
public enum MlockallFlags
{
	MCL_CURRENT = 1,
	MCL_FUTURE = 2
}


using System;

[CLSCompliant(false)]
[Map]
[Flags]
public enum MremapFlags : ulong
{
	MREMAP_MAYMOVE = 1uL
}


using System;
using Mono.Unix.Native;

[Map("struct flock")]
public struct Flock : IEquatable<Flock>
{
	[CLSCompliant(false)]
	public LockType l_type;

	[CLSCompliant(false)]
	public SeekFlags l_whence;

	[off_t]
	public long l_start;

	[off_t]
	public long l_len;

	[pid_t]
	public int l_pid;

	public override int GetHashCode()
	{
		return l_type.GetHashCode() ^ l_whence.GetHashCode() ^ l_start.GetHashCode() ^ l_len.GetHashCode() ^ l_pid.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)obj.GetType() != GetType())
		{
			return false;
		}
		Flock flock = (Flock)obj;
		return l_type == flock.l_type && l_whence == flock.l_whence && l_start == flock.l_start && l_len == flock.l_len && l_pid == flock.l_pid;
	}

	public bool Equals(Flock value)
	{
		return l_type == value.l_type && l_whence == value.l_whence && l_start == value.l_start && l_len == value.l_len && l_pid == value.l_pid;
	}

	public static bool operator ==(Flock lhs, Flock rhs)
	{
		return lhs.Equals(rhs);
	}

	public static bool operator !=(Flock lhs, Flock rhs)
	{
		return !lhs.Equals(rhs);
	}
}


using System;
using Mono.Unix.Native;

[Map("struct pollfd")]
public struct Pollfd : IEquatable<Pollfd>
{
	public int fd;

	[CLSCompliant(false)]
	public PollEvents events;

	[CLSCompliant(false)]
	public PollEvents revents;

	public override int GetHashCode()
	{
		return events.GetHashCode() ^ revents.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)obj.GetType() != GetType())
		{
			return false;
		}
		Pollfd pollfd = (Pollfd)obj;
		return pollfd.events == events && pollfd.revents == revents;
	}

	public bool Equals(Pollfd value)
	{
		return value.events == events && value.revents == revents;
	}

	public static bool operator ==(Pollfd lhs, Pollfd rhs)
	{
		return lhs.Equals(rhs);
	}

	public static bool operator !=(Pollfd lhs, Pollfd rhs)
	{
		return !lhs.Equals(rhs);
	}
}


using System;
using Mono.Unix.Native;

[Map("struct stat")]
public struct Stat : IEquatable<Stat>
{
	[dev_t]
	[CLSCompliant(false)]
	public ulong st_dev;

	[ino_t]
	[CLSCompliant(false)]
	public ulong st_ino;

	[CLSCompliant(false)]
	public FilePermissions st_mode;

	[NonSerialized]
	private uint _padding_;

	[nlink_t]
	[CLSCompliant(false)]
	public ulong st_nlink;

	[CLSCompliant(false)]
	[uid_t]
	public uint st_uid;

	[gid_t]
	[CLSCompliant(false)]
	public uint st_gid;

	[CLSCompliant(false)]
	[dev_t]
	public ulong st_rdev;

	[off_t]
	public long st_size;

	[blksize_t]
	public long st_blksize;

	[blkcnt_t]
	public long st_blocks;

	[time_t]
	public long st_atime;

	[time_t]
	public long st_mtime;

	[time_t]
	public long st_ctime;

	public override int GetHashCode()
	{
		return st_dev.GetHashCode() ^ st_ino.GetHashCode() ^ st_mode.GetHashCode() ^ st_nlink.GetHashCode() ^ st_uid.GetHashCode() ^ st_gid.GetHashCode() ^ st_rdev.GetHashCode() ^ st_size.GetHashCode() ^ st_blksize.GetHashCode() ^ st_blocks.GetHashCode() ^ st_atime.GetHashCode() ^ st_mtime.GetHashCode() ^ st_ctime.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)obj.GetType() != GetType())
		{
			return false;
		}
		Stat stat = (Stat)obj;
		return stat.st_dev == st_dev && stat.st_ino == st_ino && stat.st_mode == st_mode && stat.st_nlink == st_nlink && stat.st_uid == st_uid && stat.st_gid == st_gid && stat.st_rdev == st_rdev && stat.st_size == st_size && stat.st_blksize == st_blksize && stat.st_blocks == st_blocks && stat.st_atime == st_atime && stat.st_mtime == st_mtime && stat.st_ctime == st_ctime;
	}

	public bool Equals(Stat value)
	{
		return value.st_dev == st_dev && value.st_ino == st_ino && value.st_mode == st_mode && value.st_nlink == st_nlink && value.st_uid == st_uid && value.st_gid == st_gid && value.st_rdev == st_rdev && value.st_size == st_size && value.st_blksize == st_blksize && value.st_blocks == st_blocks && value.st_atime == st_atime && value.st_mtime == st_mtime && value.st_ctime == st_ctime;
	}

	public static bool operator ==(Stat lhs, Stat rhs)
	{
		return lhs.Equals(rhs);
	}

	public static bool operator !=(Stat lhs, Stat rhs)
	{
		return !lhs.Equals(rhs);
	}
}


using System;
using Mono.Unix.Native;

[CLSCompliant(false)]
[Map]
public struct Statvfs : IEquatable<Statvfs>
{
	public ulong f_bsize;

	public ulong f_frsize;

	[fsblkcnt_t]
	public ulong f_blocks;

	[fsblkcnt_t]
	public ulong f_bfree;

	[fsblkcnt_t]
	public ulong f_bavail;

	[fsfilcnt_t]
	public ulong f_files;

	[fsfilcnt_t]
	public ulong f_ffree;

	[fsfilcnt_t]
	public ulong f_favail;

	public ulong f_fsid;

	public MountFlags f_flag;

	public ulong f_namemax;

	public override int GetHashCode()
	{
		return f_bsize.GetHashCode() ^ f_frsize.GetHashCode() ^ f_blocks.GetHashCode() ^ f_bfree.GetHashCode() ^ f_bavail.GetHashCode() ^ f_files.GetHashCode() ^ f_ffree.GetHashCode() ^ f_favail.GetHashCode() ^ f_fsid.GetHashCode() ^ f_flag.GetHashCode() ^ f_namemax.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)obj.GetType() != GetType())
		{
			return false;
		}
		Statvfs statvfs = (Statvfs)obj;
		return statvfs.f_bsize == f_bsize && statvfs.f_frsize == f_frsize && statvfs.f_blocks == f_blocks && statvfs.f_bfree == f_bfree && statvfs.f_bavail == f_bavail && statvfs.f_files == f_files && statvfs.f_ffree == f_ffree && statvfs.f_favail == f_favail && statvfs.f_fsid == f_fsid && statvfs.f_flag == f_flag && statvfs.f_namemax == f_namemax;
	}

	public bool Equals(Statvfs value)
	{
		return value.f_bsize == f_bsize && value.f_frsize == f_frsize && value.f_blocks == f_blocks && value.f_bfree == f_bfree && value.f_bavail == f_bavail && value.f_files == f_files && value.f_ffree == f_ffree && value.f_favail == f_favail && value.f_fsid == f_fsid && value.f_flag == f_flag && value.f_namemax == f_namemax;
	}

	public static bool operator ==(Statvfs lhs, Statvfs rhs)
	{
		return lhs.Equals(rhs);
	}

	public static bool operator !=(Statvfs lhs, Statvfs rhs)
	{
		return !lhs.Equals(rhs);
	}
}


using System;
using Mono.Unix.Native;

[Map("struct timeval")]
public struct Timeval : IEquatable<Timeval>
{
	[time_t]
	public long tv_sec;

	[suseconds_t]
	public long tv_usec;

	public override int GetHashCode()
	{
		return tv_sec.GetHashCode() ^ tv_usec.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)obj.GetType() != GetType())
		{
			return false;
		}
		Timeval timeval = (Timeval)obj;
		return timeval.tv_sec == tv_sec && timeval.tv_usec == tv_usec;
	}

	public bool Equals(Timeval value)
	{
		return value.tv_sec == tv_sec && value.tv_usec == tv_usec;
	}

	public static bool operator ==(Timeval lhs, Timeval rhs)
	{
		return lhs.Equals(rhs);
	}

	public static bool operator !=(Timeval lhs, Timeval rhs)
	{
		return !lhs.Equals(rhs);
	}
}


using System;
using Mono.Unix.Native;

[Map("struct timezone")]
public struct Timezone : IEquatable<Timezone>
{
	public int tz_minuteswest;

	private int tz_dsttime;

	public override int GetHashCode()
	{
		return tz_minuteswest.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)obj.GetType() != GetType())
		{
			return false;
		}
		return ((Timezone)obj).tz_minuteswest == tz_minuteswest;
	}

	public bool Equals(Timezone value)
	{
		return value.tz_minuteswest == tz_minuteswest;
	}

	public static bool operator ==(Timezone lhs, Timezone rhs)
	{
		return lhs.Equals(rhs);
	}

	public static bool operator !=(Timezone lhs, Timezone rhs)
	{
		return !lhs.Equals(rhs);
	}
}


using System;
using Mono.Unix.Native;

[Map("struct utimbuf")]
public struct Utimbuf : IEquatable<Utimbuf>
{
	[time_t]
	public long actime;

	[time_t]
	public long modtime;

	public override int GetHashCode()
	{
		return actime.GetHashCode() ^ modtime.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)obj.GetType() != GetType())
		{
			return false;
		}
		Utimbuf utimbuf = (Utimbuf)obj;
		return utimbuf.actime == actime && utimbuf.modtime == modtime;
	}

	public bool Equals(Utimbuf value)
	{
		return value.actime == actime && value.modtime == modtime;
	}

	public static bool operator ==(Utimbuf lhs, Utimbuf rhs)
	{
		return lhs.Equals(rhs);
	}

	public static bool operator !=(Utimbuf lhs, Utimbuf rhs)
	{
		return !lhs.Equals(rhs);
	}
}


using System;
using Mono.Unix.Native;

[Map("struct timespec")]
public struct Timespec : IEquatable<Timespec>
{
	[time_t]
	public long tv_sec;

	public long tv_nsec;

	public override int GetHashCode()
	{
		return tv_sec.GetHashCode() ^ tv_nsec.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)obj.GetType() != GetType())
		{
			return false;
		}
		Timespec timespec = (Timespec)obj;
		return timespec.tv_sec == tv_sec && timespec.tv_nsec == tv_nsec;
	}

	public bool Equals(Timespec value)
	{
		return value.tv_sec == tv_sec && value.tv_nsec == tv_nsec;
	}

	public static bool operator ==(Timespec lhs, Timespec rhs)
	{
		return lhs.Equals(rhs);
	}

	public static bool operator !=(Timespec lhs, Timespec rhs)
	{
		return !lhs.Equals(rhs);
	}
}


using System;
using Mono.Unix.Native;

public sealed class Dirent : IEquatable<Dirent>
{
	[CLSCompliant(false)]
	public ulong d_ino;

	public long d_off;

	[CLSCompliant(false)]
	public ushort d_reclen;

	public byte d_type;

	public string d_name;

	public override int GetHashCode()
	{
		return d_ino.GetHashCode() ^ d_off.GetHashCode() ^ d_reclen.GetHashCode() ^ d_type.GetHashCode() ^ d_name.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)GetType() != obj.GetType())
		{
			return false;
		}
		Dirent value = (Dirent)obj;
		return Equals(value);
	}

	public bool Equals(Dirent value)
	{
		if (value == null)
		{
			return false;
		}
		return value.d_ino == d_ino && value.d_off == d_off && value.d_reclen == d_reclen && value.d_type == d_type && value.d_name == d_name;
	}

	public override string ToString()
	{
		return d_name;
	}

	public static bool operator ==(Dirent lhs, Dirent rhs)
	{
		return object.Equals(lhs, rhs);
	}

	public static bool operator !=(Dirent lhs, Dirent rhs)
	{
		return !object.Equals(lhs, rhs);
	}
}


using System;
using Mono.Unix.Native;

public sealed class Fstab : IEquatable<Fstab>
{
	public string fs_spec;

	public string fs_file;

	public string fs_vfstype;

	public string fs_mntops;

	public string fs_type;

	public int fs_freq;

	public int fs_passno;

	public override int GetHashCode()
	{
		return fs_spec.GetHashCode() ^ fs_file.GetHashCode() ^ fs_vfstype.GetHashCode() ^ fs_mntops.GetHashCode() ^ fs_type.GetHashCode() ^ fs_freq ^ fs_passno;
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)GetType() != obj.GetType())
		{
			return false;
		}
		Fstab value = (Fstab)obj;
		return Equals(value);
	}

	public bool Equals(Fstab value)
	{
		if (value == null)
		{
			return false;
		}
		return value.fs_spec == fs_spec && value.fs_file == fs_file && value.fs_vfstype == fs_vfstype && value.fs_mntops == fs_mntops && value.fs_type == fs_type && value.fs_freq == fs_freq && value.fs_passno == fs_passno;
	}

	public override string ToString()
	{
		return fs_spec;
	}

	public static bool operator ==(Fstab lhs, Fstab rhs)
	{
		return object.Equals(lhs, rhs);
	}

	public static bool operator !=(Fstab lhs, Fstab rhs)
	{
		return !object.Equals(lhs, rhs);
	}
}


using System;
using System.Text;
using Mono.Unix.Native;

public sealed class Group : IEquatable<Group>
{
	public string gr_name;

	public string gr_passwd;

	[CLSCompliant(false)]
	public uint gr_gid;

	public string[] gr_mem;

	public override int GetHashCode()
	{
		int num = 0;
		for (int i = 0; i < gr_mem.Length; i++)
		{
			num ^= gr_mem[i].GetHashCode();
		}
		return gr_name.GetHashCode() ^ gr_passwd.GetHashCode() ^ gr_gid.GetHashCode() ^ num;
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)GetType() != obj.GetType())
		{
			return false;
		}
		Group value = (Group)obj;
		return Equals(value);
	}

	public bool Equals(Group value)
	{
		if (value == null)
		{
			return false;
		}
		if (value.gr_gid != gr_gid)
		{
			return false;
		}
		if (value.gr_gid == gr_gid && value.gr_name == gr_name && value.gr_passwd == gr_passwd)
		{
			if (value.gr_mem == gr_mem)
			{
				return true;
			}
			if (value.gr_mem == null || gr_mem == null)
			{
				return false;
			}
			if (value.gr_mem.Length != gr_mem.Length)
			{
				return false;
			}
			for (int i = 0; i < gr_mem.Length; i++)
			{
				if (gr_mem[i] != value.gr_mem[i])
				{
					return false;
				}
			}
			return true;
		}
		return false;
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append(gr_name).Append(":").Append(gr_passwd)
			.Append(":");
		stringBuilder.Append(gr_gid).Append(":");
		GetMembers(stringBuilder, gr_mem);
		return stringBuilder.ToString();
	}

	private static void GetMembers(StringBuilder sb, string[] members)
	{
		if (members.Length > 0)
		{
			sb.Append(members[0]);
		}
		for (int i = 1; i < members.Length; i++)
		{
			sb.Append(",");
			sb.Append(members[i]);
		}
	}

	public static bool operator ==(Group lhs, Group rhs)
	{
		return object.Equals(lhs, rhs);
	}

	public static bool operator !=(Group lhs, Group rhs)
	{
		return !object.Equals(lhs, rhs);
	}
}


using System;
using Mono.Unix.Native;

public sealed class Passwd : IEquatable<Passwd>
{
	public string pw_name;

	public string pw_passwd;

	[CLSCompliant(false)]
	public uint pw_uid;

	[CLSCompliant(false)]
	public uint pw_gid;

	public string pw_gecos;

	public string pw_dir;

	public string pw_shell;

	public override int GetHashCode()
	{
		return pw_name.GetHashCode() ^ pw_passwd.GetHashCode() ^ pw_uid.GetHashCode() ^ pw_gid.GetHashCode() ^ pw_gecos.GetHashCode() ^ pw_dir.GetHashCode() ^ pw_dir.GetHashCode() ^ pw_shell.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)GetType() != obj.GetType())
		{
			return false;
		}
		Passwd value = (Passwd)obj;
		return Equals(value);
	}

	public bool Equals(Passwd value)
	{
		if (value == null)
		{
			return false;
		}
		return value.pw_uid == pw_uid && value.pw_gid == pw_gid && value.pw_name == pw_name && value.pw_passwd == pw_passwd && value.pw_gecos == pw_gecos && value.pw_dir == pw_dir && value.pw_shell == pw_shell;
	}

	public override string ToString()
	{
		return $"{pw_name}:{pw_passwd}:{pw_uid}:{pw_gid}:{pw_gecos}:{pw_dir}:{pw_shell}";
	}

	public static bool operator ==(Passwd lhs, Passwd rhs)
	{
		return object.Equals(lhs, rhs);
	}

	public static bool operator !=(Passwd lhs, Passwd rhs)
	{
		return !object.Equals(lhs, rhs);
	}
}


using System;
using Mono.Unix.Native;

public sealed class Utsname : IEquatable<Utsname>
{
	public string sysname;

	public string nodename;

	public string release;

	public string version;

	public string machine;

	public string domainname;

	public override int GetHashCode()
	{
		return sysname.GetHashCode() ^ nodename.GetHashCode() ^ release.GetHashCode() ^ version.GetHashCode() ^ machine.GetHashCode() ^ domainname.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || (object)GetType() != obj.GetType())
		{
			return false;
		}
		Utsname value = (Utsname)obj;
		return Equals(value);
	}

	public bool Equals(Utsname value)
	{
		return value.sysname == sysname && value.nodename == nodename && value.release == release && value.version == version && value.machine == machine && value.domainname == domainname;
	}

	public override string ToString()
	{
		return $"{sysname} {nodename} {release} {version} {machine}";
	}

	public static bool operator ==(Utsname lhs, Utsname rhs)
	{
		return object.Equals(lhs, rhs);
	}

	public static bool operator !=(Utsname lhs, Utsname rhs)
	{
		return !object.Equals(lhs, rhs);
	}
}


using System;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using Mono.Unix;
using Mono.Unix.Native;

[CLSCompliant(false)]
public sealed class Syscall : Stdlib
{
	private struct _Dirent
	{
		[ino_t]
		public ulong d_ino;

		[off_t]
		public long d_off;

		public ushort d_reclen;

		public byte d_type;

		public IntPtr d_name;
	}

	[Map]
	private struct _Fstab
	{
		public IntPtr fs_spec;

		public IntPtr fs_file;

		public IntPtr fs_vfstype;

		public IntPtr fs_mntops;

		public IntPtr fs_type;

		public int fs_freq;

		public int fs_passno;

		public IntPtr _fs_buf_;
	}

	[Map]
	private struct _Group
	{
		public IntPtr gr_name;

		public IntPtr gr_passwd;

		[gid_t]
		public uint gr_gid;

		public int _gr_nmem_;

		public IntPtr gr_mem;

		public IntPtr _gr_buf_;
	}

	[Map]
	private struct _Passwd
	{
		public IntPtr pw_name;

		public IntPtr pw_passwd;

		[uid_t]
		public uint pw_uid;

		[gid_t]
		public uint pw_gid;

		public IntPtr pw_gecos;

		public IntPtr pw_dir;

		public IntPtr pw_shell;

		public IntPtr _pw_buf_;
	}

	private struct _pollfd
	{
		public int fd;

		public short events;

		public short revents;
	}

	[Map]
	private struct _Utsname
	{
		public IntPtr sysname;

		public IntPtr nodename;

		public IntPtr release;

		public IntPtr version;

		public IntPtr machine;

		public IntPtr domainname;

		public IntPtr _buf_;
	}

	internal new const string LIBC = "libc";

	internal static object readdir_lock = new object();

	internal static object fstab_lock = new object();

	internal static object grp_lock = new object();

	internal static object pwd_lock = new object();

	private static object signal_lock = new object();

	public static readonly int L_ctermid = _L_ctermid();

	public static readonly int L_cuserid = _L_cuserid();

	internal static object getlogin_lock = new object();

	public static readonly IntPtr MAP_FAILED = (IntPtr)(-1);

	private static object tty_lock = new object();

	internal static object usershell_lock = new object();

	private Syscall()
	{
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setxattr", SetLastError = true)]
	public static extern int setxattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, byte[] value, ulong size, XattrFlags flags);

	public static int setxattr(string path, string name, byte[] value, ulong size)
	{
		return setxattr(path, name, value, size, XattrFlags.XATTR_AUTO);
	}

	public static int setxattr(string path, string name, byte[] value, XattrFlags flags)
	{
		return setxattr(path, name, value, (ulong)value.Length, flags);
	}

	public static int setxattr(string path, string name, byte[] value)
	{
		return setxattr(path, name, value, (ulong)value.Length);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lsetxattr", SetLastError = true)]
	public static extern int lsetxattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, byte[] value, ulong size, XattrFlags flags);

	public static int lsetxattr(string path, string name, byte[] value, ulong size)
	{
		return lsetxattr(path, name, value, size, XattrFlags.XATTR_AUTO);
	}

	public static int lsetxattr(string path, string name, byte[] value, XattrFlags flags)
	{
		return lsetxattr(path, name, value, (ulong)value.Length, flags);
	}

	public static int lsetxattr(string path, string name, byte[] value)
	{
		return lsetxattr(path, name, value, (ulong)value.Length);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fsetxattr", SetLastError = true)]
	public static extern int fsetxattr(int fd, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, byte[] value, ulong size, XattrFlags flags);

	public static int fsetxattr(int fd, string name, byte[] value, ulong size)
	{
		return fsetxattr(fd, name, value, size, XattrFlags.XATTR_AUTO);
	}

	public static int fsetxattr(int fd, string name, byte[] value, XattrFlags flags)
	{
		return fsetxattr(fd, name, value, (ulong)value.Length, flags);
	}

	public static int fsetxattr(int fd, string name, byte[] value)
	{
		return fsetxattr(fd, name, value, (ulong)value.Length);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getxattr", SetLastError = true)]
	public static extern long getxattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, byte[] value, ulong size);

	public static long getxattr(string path, string name, byte[] value)
	{
		return getxattr(path, name, value, (ulong)value.Length);
	}

	public static long getxattr(string path, string name, out byte[] value)
	{
		value = null;
		long num = getxattr(path, name, value, 0uL);
		if (num <= 0)
		{
			return num;
		}
		value = new byte[num];
		return getxattr(path, name, value, (ulong)num);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lgetxattr", SetLastError = true)]
	public static extern long lgetxattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, byte[] value, ulong size);

	public static long lgetxattr(string path, string name, byte[] value)
	{
		return lgetxattr(path, name, value, (ulong)value.Length);
	}

	public static long lgetxattr(string path, string name, out byte[] value)
	{
		value = null;
		long num = lgetxattr(path, name, value, 0uL);
		if (num <= 0)
		{
			return num;
		}
		value = new byte[num];
		return lgetxattr(path, name, value, (ulong)num);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fgetxattr", SetLastError = true)]
	public static extern long fgetxattr(int fd, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, byte[] value, ulong size);

	public static long fgetxattr(int fd, string name, byte[] value)
	{
		return fgetxattr(fd, name, value, (ulong)value.Length);
	}

	public static long fgetxattr(int fd, string name, out byte[] value)
	{
		value = null;
		long num = fgetxattr(fd, name, value, 0uL);
		if (num <= 0)
		{
			return num;
		}
		value = new byte[num];
		return fgetxattr(fd, name, value, (ulong)num);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_listxattr", SetLastError = true)]
	public static extern long listxattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, byte[] list, ulong size);

	public static long listxattr(string path, Encoding encoding, out string[] values)
	{
		values = null;
		long num = listxattr(path, null, 0uL);
		if (num == 0L)
		{
			values = new string[0];
		}
		if (num <= 0)
		{
			return (int)num;
		}
		byte[] list = new byte[num];
		long num2 = listxattr(path, list, (ulong)num);
		if (num2 < 0)
		{
			return (int)num2;
		}
		GetValues(list, encoding, out values);
		return 0L;
	}

	public static long listxattr(string path, out string[] values)
	{
		return listxattr(path, UnixEncoding.Instance, out values);
	}

	private static void GetValues(byte[] list, Encoding encoding, out string[] values)
	{
		int num = 0;
		for (int i = 0; i < list.Length; i++)
		{
			if (list[i] == 0)
			{
				num++;
			}
		}
		values = new string[num];
		num = 0;
		int num2 = 0;
		for (int j = 0; j < list.Length; j++)
		{
			if (list[j] == 0)
			{
				values[num++] = encoding.GetString(list, num2, j - num2);
				num2 = j + 1;
			}
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_llistxattr", SetLastError = true)]
	public static extern long llistxattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, byte[] list, ulong size);

	public static long llistxattr(string path, Encoding encoding, out string[] values)
	{
		values = null;
		long num = llistxattr(path, null, 0uL);
		if (num == 0L)
		{
			values = new string[0];
		}
		if (num <= 0)
		{
			return (int)num;
		}
		byte[] list = new byte[num];
		long num2 = llistxattr(path, list, (ulong)num);
		if (num2 < 0)
		{
			return (int)num2;
		}
		GetValues(list, encoding, out values);
		return 0L;
	}

	public static long llistxattr(string path, out string[] values)
	{
		return llistxattr(path, UnixEncoding.Instance, out values);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_flistxattr", SetLastError = true)]
	public static extern long flistxattr(int fd, byte[] list, ulong size);

	public static long flistxattr(int fd, Encoding encoding, out string[] values)
	{
		values = null;
		long num = flistxattr(fd, null, 0uL);
		if (num == 0L)
		{
			values = new string[0];
		}
		if (num <= 0)
		{
			return (int)num;
		}
		byte[] list = new byte[num];
		long num2 = flistxattr(fd, list, (ulong)num);
		if (num2 < 0)
		{
			return (int)num2;
		}
		GetValues(list, encoding, out values);
		return 0L;
	}

	public static long flistxattr(int fd, out string[] values)
	{
		return flistxattr(fd, UnixEncoding.Instance, out values);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_removexattr", SetLastError = true)]
	public static extern int removexattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lremovexattr", SetLastError = true)]
	public static extern int lremovexattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fremovexattr", SetLastError = true)]
	public static extern int fremovexattr(int fd, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name);

	[DllImport("libc", SetLastError = true)]
	public static extern IntPtr opendir([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name);

	[DllImport("libc", SetLastError = true)]
	public static extern int closedir(IntPtr dir);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_seekdir", SetLastError = true)]
	public static extern int seekdir(IntPtr dir, long offset);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_telldir", SetLastError = true)]
	public static extern long telldir(IntPtr dir);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_rewinddir", SetLastError = true)]
	public static extern int rewinddir(IntPtr dir);

	private static void CopyDirent(Dirent to, ref _Dirent from)
	{
		try
		{
			to.d_ino = from.d_ino;
			to.d_off = from.d_off;
			to.d_reclen = from.d_reclen;
			to.d_type = from.d_type;
			to.d_name = UnixMarshal.PtrToString(from.d_name);
		}
		finally
		{
			Stdlib.free(from.d_name);
			from.d_name = IntPtr.Zero;
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_readdir", SetLastError = true)]
	private static extern int sys_readdir(IntPtr dir, out _Dirent dentry);

	public static Dirent readdir(IntPtr dir)
	{
		int num;
		_Dirent dentry;
		lock (readdir_lock)
		{
			num = sys_readdir(dir, out dentry);
		}
		if (num != 0)
		{
			return null;
		}
		Dirent dirent = new Dirent();
		CopyDirent(dirent, ref dentry);
		return dirent;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_readdir_r", SetLastError = true)]
	private static extern int sys_readdir_r(IntPtr dirp, out _Dirent entry, out IntPtr result);

	public static int readdir_r(IntPtr dirp, Dirent entry, out IntPtr result)
	{
		entry.d_ino = 0uL;
		entry.d_off = 0L;
		entry.d_reclen = 0;
		entry.d_type = 0;
		entry.d_name = null;
		_Dirent entry2;
		int num = sys_readdir_r(dirp, out entry2, out result);
		if (num == 0 && result != IntPtr.Zero)
		{
			CopyDirent(entry, ref entry2);
		}
		return num;
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int dirfd(IntPtr dir);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fcntl", SetLastError = true)]
	public static extern int fcntl(int fd, FcntlCommand cmd);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fcntl_arg", SetLastError = true)]
	public static extern int fcntl(int fd, FcntlCommand cmd, long arg);

	public static int fcntl(int fd, FcntlCommand cmd, DirectoryNotifyFlags arg)
	{
		if (cmd != FcntlCommand.F_NOTIFY)
		{
			Stdlib.SetLastError(Errno.EINVAL);
			return -1;
		}
		long arg2 = NativeConvert.FromDirectoryNotifyFlags(arg);
		return fcntl(fd, FcntlCommand.F_NOTIFY, arg2);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fcntl_lock", SetLastError = true)]
	public static extern int fcntl(int fd, FcntlCommand cmd, ref Flock @lock);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_open", SetLastError = true)]
	public static extern int open([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname, OpenFlags flags);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_open_mode", SetLastError = true)]
	public static extern int open([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname, OpenFlags flags, FilePermissions mode);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_creat", SetLastError = true)]
	public static extern int creat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname, FilePermissions mode);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_posix_fadvise", SetLastError = true)]
	public static extern int posix_fadvise(int fd, long offset, long len, PosixFadviseAdvice advice);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_posix_fallocate", SetLastError = true)]
	public static extern int posix_fallocate(int fd, long offset, ulong len);

	private static void CopyFstab(Fstab to, ref _Fstab from)
	{
		try
		{
			to.fs_spec = UnixMarshal.PtrToString(from.fs_spec);
			to.fs_file = UnixMarshal.PtrToString(from.fs_file);
			to.fs_vfstype = UnixMarshal.PtrToString(from.fs_vfstype);
			to.fs_mntops = UnixMarshal.PtrToString(from.fs_mntops);
			to.fs_type = UnixMarshal.PtrToString(from.fs_type);
			to.fs_freq = from.fs_freq;
			to.fs_passno = from.fs_passno;
		}
		finally
		{
			Stdlib.free(from._fs_buf_);
			from._fs_buf_ = IntPtr.Zero;
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_endfsent", SetLastError = true)]
	private static extern int sys_endfsent();

	public static int endfsent()
	{
		lock (fstab_lock)
		{
			return sys_endfsent();
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getfsent", SetLastError = true)]
	private static extern int sys_getfsent(out _Fstab fs);

	public static Fstab getfsent()
	{
		int num;
		_Fstab fs;
		lock (fstab_lock)
		{
			num = sys_getfsent(out fs);
		}
		if (num != 0)
		{
			return null;
		}
		Fstab fstab = new Fstab();
		CopyFstab(fstab, ref fs);
		return fstab;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getfsfile", SetLastError = true)]
	private static extern int sys_getfsfile([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string mount_point, out _Fstab fs);

	public static Fstab getfsfile(string mount_point)
	{
		int num;
		_Fstab fs;
		lock (fstab_lock)
		{
			num = sys_getfsfile(mount_point, out fs);
		}
		if (num != 0)
		{
			return null;
		}
		Fstab fstab = new Fstab();
		CopyFstab(fstab, ref fs);
		return fstab;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getfsspec", SetLastError = true)]
	private static extern int sys_getfsspec([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string special_file, out _Fstab fs);

	public static Fstab getfsspec(string special_file)
	{
		int num;
		_Fstab fs;
		lock (fstab_lock)
		{
			num = sys_getfsspec(special_file, out fs);
		}
		if (num != 0)
		{
			return null;
		}
		Fstab fstab = new Fstab();
		CopyFstab(fstab, ref fs);
		return fstab;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setfsent", SetLastError = true)]
	private static extern int sys_setfsent();

	public static int setfsent()
	{
		lock (fstab_lock)
		{
			return sys_setfsent();
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setgroups", SetLastError = true)]
	public static extern int setgroups(ulong size, uint[] list);

	public static int setgroups(uint[] list)
	{
		return setgroups((ulong)list.Length, list);
	}

	private static void CopyGroup(Group to, ref _Group from)
	{
		try
		{
			to.gr_gid = from.gr_gid;
			to.gr_name = UnixMarshal.PtrToString(from.gr_name);
			to.gr_passwd = UnixMarshal.PtrToString(from.gr_passwd);
			to.gr_mem = UnixMarshal.PtrToStringArray(from._gr_nmem_, from.gr_mem);
		}
		finally
		{
			Stdlib.free(from.gr_mem);
			Stdlib.free(from._gr_buf_);
			from.gr_mem = IntPtr.Zero;
			from._gr_buf_ = IntPtr.Zero;
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getgrnam", SetLastError = true)]
	private static extern int sys_getgrnam(string name, out _Group group);

	public static Group getgrnam(string name)
	{
		int num;
		_Group group;
		lock (grp_lock)
		{
			num = sys_getgrnam(name, out group);
		}
		if (num != 0)
		{
			return null;
		}
		Group group2 = new Group();
		CopyGroup(group2, ref group);
		return group2;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getgrgid", SetLastError = true)]
	private static extern int sys_getgrgid(uint uid, out _Group group);

	public static Group getgrgid(uint uid)
	{
		int num;
		_Group group;
		lock (grp_lock)
		{
			num = sys_getgrgid(uid, out group);
		}
		if (num != 0)
		{
			return null;
		}
		Group group2 = new Group();
		CopyGroup(group2, ref group);
		return group2;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getgrnam_r", SetLastError = true)]
	private static extern int sys_getgrnam_r([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, out _Group grbuf, out IntPtr grbufp);

	public static int getgrnam_r(string name, Group grbuf, out Group grbufp)
	{
		grbufp = null;
		_Group grbuf2;
		IntPtr grbufp2;
		int num = sys_getgrnam_r(name, out grbuf2, out grbufp2);
		if (num == 0 && grbufp2 != IntPtr.Zero)
		{
			CopyGroup(grbuf, ref grbuf2);
			grbufp = grbuf;
		}
		return num;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getgrgid_r", SetLastError = true)]
	private static extern int sys_getgrgid_r(uint uid, out _Group grbuf, out IntPtr grbufp);

	public static int getgrgid_r(uint uid, Group grbuf, out Group grbufp)
	{
		grbufp = null;
		_Group grbuf2;
		IntPtr grbufp2;
		int num = sys_getgrgid_r(uid, out grbuf2, out grbufp2);
		if (num == 0 && grbufp2 != IntPtr.Zero)
		{
			CopyGroup(grbuf, ref grbuf2);
			grbufp = grbuf;
		}
		return num;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getgrent", SetLastError = true)]
	private static extern int sys_getgrent(out _Group grbuf);

	public static Group getgrent()
	{
		int num;
		_Group grbuf;
		lock (grp_lock)
		{
			num = sys_getgrent(out grbuf);
		}
		if (num != 0)
		{
			return null;
		}
		Group group = new Group();
		CopyGroup(group, ref grbuf);
		return group;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setgrent", SetLastError = true)]
	private static extern int sys_setgrent();

	public static int setgrent()
	{
		lock (grp_lock)
		{
			return sys_setgrent();
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_endgrent", SetLastError = true)]
	private static extern int sys_endgrent();

	public static int endgrent()
	{
		lock (grp_lock)
		{
			return sys_endgrent();
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fgetgrent", SetLastError = true)]
	private static extern int sys_fgetgrent(IntPtr stream, out _Group grbuf);

	public static Group fgetgrent(IntPtr stream)
	{
		int num;
		_Group grbuf;
		lock (grp_lock)
		{
			num = sys_fgetgrent(stream, out grbuf);
		}
		if (num != 0)
		{
			return null;
		}
		Group group = new Group();
		CopyGroup(group, ref grbuf);
		return group;
	}

	private static void CopyPasswd(Passwd to, ref _Passwd from)
	{
		try
		{
			to.pw_name = UnixMarshal.PtrToString(from.pw_name);
			to.pw_passwd = UnixMarshal.PtrToString(from.pw_passwd);
			to.pw_uid = from.pw_uid;
			to.pw_gid = from.pw_gid;
			to.pw_gecos = UnixMarshal.PtrToString(from.pw_gecos);
			to.pw_dir = UnixMarshal.PtrToString(from.pw_dir);
			to.pw_shell = UnixMarshal.PtrToString(from.pw_shell);
		}
		finally
		{
			Stdlib.free(from._pw_buf_);
			from._pw_buf_ = IntPtr.Zero;
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getpwnam", SetLastError = true)]
	private static extern int sys_getpwnam(string name, out _Passwd passwd);

	public static Passwd getpwnam(string name)
	{
		int num;
		_Passwd passwd;
		lock (pwd_lock)
		{
			num = sys_getpwnam(name, out passwd);
		}
		if (num != 0)
		{
			return null;
		}
		Passwd passwd2 = new Passwd();
		CopyPasswd(passwd2, ref passwd);
		return passwd2;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getpwuid", SetLastError = true)]
	private static extern int sys_getpwuid(uint uid, out _Passwd passwd);

	public static Passwd getpwuid(uint uid)
	{
		int num;
		_Passwd passwd;
		lock (pwd_lock)
		{
			num = sys_getpwuid(uid, out passwd);
		}
		if (num != 0)
		{
			return null;
		}
		Passwd passwd2 = new Passwd();
		CopyPasswd(passwd2, ref passwd);
		return passwd2;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getpwnam_r", SetLastError = true)]
	private static extern int sys_getpwnam_r([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, out _Passwd pwbuf, out IntPtr pwbufp);

	public static int getpwnam_r(string name, Passwd pwbuf, out Passwd pwbufp)
	{
		pwbufp = null;
		_Passwd pwbuf2;
		IntPtr pwbufp2;
		int num = sys_getpwnam_r(name, out pwbuf2, out pwbufp2);
		if (num == 0 && pwbufp2 != IntPtr.Zero)
		{
			CopyPasswd(pwbuf, ref pwbuf2);
			pwbufp = pwbuf;
		}
		return num;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getpwuid_r", SetLastError = true)]
	private static extern int sys_getpwuid_r(uint uid, out _Passwd pwbuf, out IntPtr pwbufp);

	public static int getpwuid_r(uint uid, Passwd pwbuf, out Passwd pwbufp)
	{
		pwbufp = null;
		_Passwd pwbuf2;
		IntPtr pwbufp2;
		int num = sys_getpwuid_r(uid, out pwbuf2, out pwbufp2);
		if (num == 0 && pwbufp2 != IntPtr.Zero)
		{
			CopyPasswd(pwbuf, ref pwbuf2);
			pwbufp = pwbuf;
		}
		return num;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getpwent", SetLastError = true)]
	private static extern int sys_getpwent(out _Passwd pwbuf);

	public static Passwd getpwent()
	{
		int num;
		_Passwd pwbuf;
		lock (pwd_lock)
		{
			num = sys_getpwent(out pwbuf);
		}
		if (num != 0)
		{
			return null;
		}
		Passwd passwd = new Passwd();
		CopyPasswd(passwd, ref pwbuf);
		return passwd;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setpwent", SetLastError = true)]
	private static extern int sys_setpwent();

	public static int setpwent()
	{
		lock (pwd_lock)
		{
			return sys_setpwent();
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_endpwent", SetLastError = true)]
	private static extern int sys_endpwent();

	public static int endpwent()
	{
		lock (pwd_lock)
		{
			return sys_endpwent();
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fgetpwent", SetLastError = true)]
	private static extern int sys_fgetpwent(IntPtr stream, out _Passwd pwbuf);

	public static Passwd fgetpwent(IntPtr stream)
	{
		int num;
		_Passwd pwbuf;
		lock (pwd_lock)
		{
			num = sys_fgetpwent(stream, out pwbuf);
		}
		if (num != 0)
		{
			return null;
		}
		Passwd passwd = new Passwd();
		CopyPasswd(passwd, ref pwbuf);
		return passwd;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_psignal", SetLastError = true)]
	private static extern int psignal(int sig, string s);

	public static int psignal(Signum sig, string s)
	{
		int sig2 = NativeConvert.FromSignum(sig);
		return psignal(sig2, s);
	}

	[DllImport("libc", EntryPoint = "kill", SetLastError = true)]
	private static extern int sys_kill(int pid, int sig);

	public static int kill(int pid, Signum sig)
	{
		int sig2 = NativeConvert.FromSignum(sig);
		return sys_kill(pid, sig2);
	}

	[DllImport("libc", EntryPoint = "strsignal", SetLastError = true)]
	private static extern IntPtr sys_strsignal(int sig);

	public static string strsignal(Signum sig)
	{
		int sig2 = NativeConvert.FromSignum(sig);
		lock (signal_lock)
		{
			IntPtr p = sys_strsignal(sig2);
			return UnixMarshal.PtrToString(p);
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_L_ctermid")]
	private static extern int _L_ctermid();

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_L_cuserid")]
	private static extern int _L_cuserid();

	[DllImport("libc", EntryPoint = "cuserid", SetLastError = true)]
	private static extern IntPtr sys_cuserid([Out] StringBuilder @string);

	[Obsolete("\"Nobody knows precisely what cuserid() does... DO NOT USE cuserid().\n`string' must hold L_cuserid characters.  Use getlogin_r instead.")]
	public static string cuserid(StringBuilder @string)
	{
		if (@string.Capacity < L_cuserid)
		{
			throw new ArgumentOutOfRangeException("string", "string.Capacity < L_cuserid");
		}
		lock (getlogin_lock)
		{
			IntPtr p = sys_cuserid(@string);
			return UnixMarshal.PtrToString(p);
		}
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int mkstemp(StringBuilder template);

	[DllImport("libc", SetLastError = true)]
	public static extern int ttyslot();

	[Obsolete("This is insecure and should not be used", true)]
	public static int setkey(string key)
	{
		throw new SecurityException("crypt(3) has been broken.  Use something more secure.");
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_strerror_r", SetLastError = true)]
	private static extern int sys_strerror_r(int errnum, [Out] StringBuilder buf, ulong n);

	public static int strerror_r(Errno errnum, StringBuilder buf, ulong n)
	{
		int errnum2 = NativeConvert.FromErrno(errnum);
		return sys_strerror_r(errnum2, buf, n);
	}

	public static int strerror_r(Errno errnum, StringBuilder buf)
	{
		return strerror_r(errnum, buf, (ulong)buf.Capacity);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_posix_madvise", SetLastError = true)]
	public static extern int posix_madvise(IntPtr addr, ulong len, PosixMadviseAdvice advice);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_mmap", SetLastError = true)]
	public static extern IntPtr mmap(IntPtr start, ulong length, MmapProts prot, MmapFlags flags, int fd, long offset);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_munmap", SetLastError = true)]
	public static extern int munmap(IntPtr start, ulong length);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_mprotect", SetLastError = true)]
	public static extern int mprotect(IntPtr start, ulong len, MmapProts prot);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_msync", SetLastError = true)]
	public static extern int msync(IntPtr start, ulong len, MsyncFlags flags);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_mlock", SetLastError = true)]
	public static extern int mlock(IntPtr start, ulong len);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_munlock", SetLastError = true)]
	public static extern int munlock(IntPtr start, ulong len);

	[DllImport("libc", EntryPoint = "mlockall", SetLastError = true)]
	private static extern int sys_mlockall(int flags);

	public static int mlockall(MlockallFlags flags)
	{
		int flags2 = NativeConvert.FromMlockallFlags(flags);
		return sys_mlockall(flags2);
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int munlockall();

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_mremap", SetLastError = true)]
	public static extern IntPtr mremap(IntPtr old_address, ulong old_size, ulong new_size, MremapFlags flags);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_mincore", SetLastError = true)]
	public static extern int mincore(IntPtr start, ulong length, byte[] vec);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_remap_file_pages", SetLastError = true)]
	public static extern int remap_file_pages(IntPtr start, ulong size, MmapProts prot, long pgoff, MmapFlags flags);

	[DllImport("libc", EntryPoint = "poll", SetLastError = true)]
	private static extern int sys_poll(_pollfd[] ufds, uint nfds, int timeout);

	public static int poll(Pollfd[] fds, uint nfds, int timeout)
	{
		if (fds.Length < nfds)
		{
			throw new ArgumentOutOfRangeException("fds", "Must refer to at least `nfds' elements");
		}
		_pollfd[] array = new _pollfd[nfds];
		for (int i = 0; i < array.Length; i++)
		{
			array[i].fd = fds[i].fd;
			array[i].events = NativeConvert.FromPollEvents(fds[i].events);
		}
		int result = sys_poll(array, nfds, timeout);
		for (int j = 0; j < array.Length; j++)
		{
			fds[j].revents = NativeConvert.ToPollEvents(array[j].revents);
		}
		return result;
	}

	public static int poll(Pollfd[] fds, int timeout)
	{
		return poll(fds, (uint)fds.Length, timeout);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_sendfile", SetLastError = true)]
	public static extern long sendfile(int out_fd, int in_fd, ref long offset, ulong count);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_stat", SetLastError = true)]
	public static extern int stat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string file_name, out Stat buf);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fstat", SetLastError = true)]
	public static extern int fstat(int filedes, out Stat buf);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lstat", SetLastError = true)]
	public static extern int lstat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string file_name, out Stat buf);

	[DllImport("libc", EntryPoint = "chmod", SetLastError = true)]
	private static extern int sys_chmod([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, uint mode);

	public static int chmod(string path, FilePermissions mode)
	{
		uint mode2 = NativeConvert.FromFilePermissions(mode);
		return sys_chmod(path, mode2);
	}

	[DllImport("libc", EntryPoint = "fchmod", SetLastError = true)]
	private static extern int sys_fchmod(int filedes, uint mode);

	public static int fchmod(int filedes, FilePermissions mode)
	{
		uint mode2 = NativeConvert.FromFilePermissions(mode);
		return sys_fchmod(filedes, mode2);
	}

	[DllImport("libc", EntryPoint = "umask", SetLastError = true)]
	private static extern uint sys_umask(uint mask);

	public static FilePermissions umask(FilePermissions mask)
	{
		uint mask2 = NativeConvert.FromFilePermissions(mask);
		uint value = sys_umask(mask2);
		return NativeConvert.ToFilePermissions(value);
	}

	[DllImport("libc", EntryPoint = "mkdir", SetLastError = true)]
	private static extern int sys_mkdir([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string oldpath, uint mode);

	public static int mkdir(string oldpath, FilePermissions mode)
	{
		uint mode2 = NativeConvert.FromFilePermissions(mode);
		return sys_mkdir(oldpath, mode2);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_mknod", SetLastError = true)]
	public static extern int mknod([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname, FilePermissions mode, ulong dev);

	[DllImport("libc", EntryPoint = "mkfifo", SetLastError = true)]
	private static extern int sys_mkfifo([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname, uint mode);

	public static int mkfifo(string pathname, FilePermissions mode)
	{
		uint mode2 = NativeConvert.FromFilePermissions(mode);
		return sys_mkfifo(pathname, mode2);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_statvfs", SetLastError = true)]
	public static extern int statvfs([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, out Statvfs buf);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fstatvfs", SetLastError = true)]
	public static extern int fstatvfs(int fd, out Statvfs buf);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_gettimeofday", SetLastError = true)]
	public static extern int gettimeofday(out Timeval tv, out Timezone tz);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_gettimeofday", SetLastError = true)]
	private static extern int gettimeofday(out Timeval tv, IntPtr ignore);

	public static int gettimeofday(out Timeval tv)
	{
		return gettimeofday(out tv, IntPtr.Zero);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_gettimeofday", SetLastError = true)]
	private static extern int gettimeofday(IntPtr ignore, out Timezone tz);

	public static int gettimeofday(out Timezone tz)
	{
		return gettimeofday(IntPtr.Zero, out tz);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_settimeofday", SetLastError = true)]
	public static extern int settimeofday(ref Timeval tv, ref Timezone tz);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_gettimeofday", SetLastError = true)]
	private static extern int settimeofday(ref Timeval tv, IntPtr ignore);

	public static int settimeofday(ref Timeval tv)
	{
		return settimeofday(ref tv, IntPtr.Zero);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_utimes", SetLastError = true)]
	private static extern int sys_utimes([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string filename, Timeval[] tvp);

	public static int utimes(string filename, Timeval[] tvp)
	{
		if (tvp != null && tvp.Length != 2)
		{
			Stdlib.SetLastError(Errno.EINVAL);
			return -1;
		}
		return sys_utimes(filename, tvp);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lutimes", SetLastError = true)]
	private static extern int sys_lutimes([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string filename, Timeval[] tvp);

	public static int lutimes(string filename, Timeval[] tvp)
	{
		if (tvp != null && tvp.Length != 2)
		{
			Stdlib.SetLastError(Errno.EINVAL);
			return -1;
		}
		return sys_lutimes(filename, tvp);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_futimes", SetLastError = true)]
	private static extern int sys_futimes(int fd, Timeval[] tvp);

	public static int futimes(int fd, Timeval[] tvp)
	{
		if (tvp != null && tvp.Length != 2)
		{
			Stdlib.SetLastError(Errno.EINVAL);
			return -1;
		}
		return sys_futimes(fd, tvp);
	}

	private static void CopyUtsname(ref Utsname to, ref _Utsname from)
	{
		try
		{
			to = new Utsname();
			to.sysname = UnixMarshal.PtrToString(from.sysname);
			to.nodename = UnixMarshal.PtrToString(from.nodename);
			to.release = UnixMarshal.PtrToString(from.release);
			to.version = UnixMarshal.PtrToString(from.version);
			to.machine = UnixMarshal.PtrToString(from.machine);
			to.domainname = UnixMarshal.PtrToString(from.domainname);
		}
		finally
		{
			Stdlib.free(from._buf_);
			from._buf_ = IntPtr.Zero;
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_uname", SetLastError = true)]
	private static extern int sys_uname(out _Utsname buf);

	public static int uname(out Utsname buf)
	{
		_Utsname buf2;
		int num = sys_uname(out buf2);
		buf = new Utsname();
		if (num == 0)
		{
			CopyUtsname(ref buf, ref buf2);
		}
		return num;
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int wait(out int status);

	[DllImport("libc", SetLastError = true)]
	private static extern int waitpid(int pid, out int status, int options);

	public static int waitpid(int pid, out int status, WaitOptions options)
	{
		int options2 = NativeConvert.FromWaitOptions(options);
		return waitpid(pid, out status, options2);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_WIFEXITED")]
	private static extern int _WIFEXITED(int status);

	public static bool WIFEXITED(int status)
	{
		return _WIFEXITED(status) != 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_WEXITSTATUS")]
	public static extern int WEXITSTATUS(int status);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_WIFSIGNALED")]
	private static extern int _WIFSIGNALED(int status);

	public static bool WIFSIGNALED(int status)
	{
		return _WIFSIGNALED(status) != 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_WTERMSIG")]
	private static extern int _WTERMSIG(int status);

	public static Signum WTERMSIG(int status)
	{
		int value = _WTERMSIG(status);
		return NativeConvert.ToSignum(value);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_WIFSTOPPED")]
	private static extern int _WIFSTOPPED(int status);

	public static bool WIFSTOPPED(int status)
	{
		return _WIFSTOPPED(status) != 0;
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_WSTOPSIG")]
	private static extern int _WSTOPSIG(int status);

	public static Signum WSTOPSIG(int status)
	{
		int value = _WSTOPSIG(status);
		return NativeConvert.ToSignum(value);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_openlog", SetLastError = true)]
	private static extern int sys_openlog(IntPtr ident, int option, int facility);

	public static int openlog(IntPtr ident, SyslogOptions option, SyslogFacility defaultFacility)
	{
		int option2 = NativeConvert.FromSyslogOptions(option);
		int facility = NativeConvert.FromSyslogFacility(defaultFacility);
		return sys_openlog(ident, option2, facility);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_syslog", SetLastError = true)]
	private static extern int sys_syslog(int priority, string message);

	public static int syslog(SyslogFacility facility, SyslogLevel level, string message)
	{
		int num = NativeConvert.FromSyslogFacility(facility);
		int num2 = NativeConvert.FromSyslogLevel(level);
		return sys_syslog(num | num2, GetSyslogMessage(message));
	}

	public static int syslog(SyslogLevel level, string message)
	{
		int priority = NativeConvert.FromSyslogLevel(level);
		return sys_syslog(priority, GetSyslogMessage(message));
	}

	private static string GetSyslogMessage(string message)
	{
		return UnixMarshal.EscapeFormatString(message, new char[1] { 'm' });
	}

	[Obsolete("Not necessarily portable due to cdecl restrictions.\nUse syslog(SyslogFacility, SyslogLevel, string) instead.")]
	public static int syslog(SyslogFacility facility, SyslogLevel level, string format, params object[] parameters)
	{
		int num = NativeConvert.FromSyslogFacility(facility);
		int num2 = NativeConvert.FromSyslogLevel(level);
		object[] array = new object[checked(parameters.Length + 2)];
		array[0] = num | num2;
		array[1] = format;
		Array.Copy(parameters, 0, array, 2, parameters.Length);
		return (int)XPrintfFunctions.syslog(array);
	}

	[Obsolete("Not necessarily portable due to cdecl restrictions.\nUse syslog(SyslogLevel, string) instead.")]
	public static int syslog(SyslogLevel level, string format, params object[] parameters)
	{
		int num = NativeConvert.FromSyslogLevel(level);
		object[] array = new object[checked(parameters.Length + 2)];
		array[0] = num;
		array[1] = format;
		Array.Copy(parameters, 0, array, 2, parameters.Length);
		return (int)XPrintfFunctions.syslog(array);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_closelog", SetLastError = true)]
	public static extern int closelog();

	[DllImport("libc", EntryPoint = "setlogmask", SetLastError = true)]
	private static extern int sys_setlogmask(int mask);

	public static int setlogmask(SyslogLevel mask)
	{
		int mask2 = NativeConvert.FromSyslogLevel(mask);
		return sys_setlogmask(mask2);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_nanosleep", SetLastError = true)]
	public static extern int nanosleep(ref Timespec req, ref Timespec rem);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_stime", SetLastError = true)]
	public static extern int stime(ref long t);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_time", SetLastError = true)]
	public static extern long time(out long t);

	[DllImport("libc", EntryPoint = "access", SetLastError = true)]
	private static extern int sys_access([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname, int mode);

	public static int access(string pathname, AccessModes mode)
	{
		int mode2 = NativeConvert.FromAccessModes(mode);
		return sys_access(pathname, mode2);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lseek", SetLastError = true)]
	private static extern long sys_lseek(int fd, long offset, int whence);

	public static long lseek(int fd, long offset, SeekFlags whence)
	{
		short whence2 = NativeConvert.FromSeekFlags(whence);
		return sys_lseek(fd, offset, whence2);
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int close(int fd);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_read", SetLastError = true)]
	public static extern long read(int fd, IntPtr buf, ulong count);

	public unsafe static long read(int fd, void* buf, ulong count)
	{
		return read(fd, (IntPtr)buf, count);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_write", SetLastError = true)]
	public static extern long write(int fd, IntPtr buf, ulong count);

	public unsafe static long write(int fd, void* buf, ulong count)
	{
		return write(fd, (IntPtr)buf, count);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_pread", SetLastError = true)]
	public static extern long pread(int fd, IntPtr buf, ulong count, long offset);

	public unsafe static long pread(int fd, void* buf, ulong count, long offset)
	{
		return pread(fd, (IntPtr)buf, count, offset);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_pwrite", SetLastError = true)]
	public static extern long pwrite(int fd, IntPtr buf, ulong count, long offset);

	public unsafe static long pwrite(int fd, void* buf, ulong count, long offset)
	{
		return pwrite(fd, (IntPtr)buf, count, offset);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_pipe", SetLastError = true)]
	public static extern int pipe(out int reading, out int writing);

	public static int pipe(int[] filedes)
	{
		if (filedes == null || filedes.Length != 2)
		{
			return -1;
		}
		int reading;
		int writing;
		int result = pipe(out reading, out writing);
		filedes[0] = reading;
		filedes[1] = writing;
		return result;
	}

	[DllImport("libc", SetLastError = true)]
	public static extern uint alarm(uint seconds);

	[DllImport("libc", SetLastError = true)]
	public static extern uint sleep(uint seconds);

	[DllImport("libc", SetLastError = true)]
	public static extern uint ualarm(uint usecs, uint interval);

	[DllImport("libc", SetLastError = true)]
	public static extern int pause();

	[DllImport("libc", SetLastError = true)]
	public static extern int chown([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, uint owner, uint group);

	[DllImport("libc", SetLastError = true)]
	public static extern int fchown(int fd, uint owner, uint group);

	[DllImport("libc", SetLastError = true)]
	public static extern int lchown([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, uint owner, uint group);

	[DllImport("libc", SetLastError = true)]
	public static extern int chdir([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path);

	[DllImport("libc", SetLastError = true)]
	public static extern int fchdir(int fd);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getcwd", SetLastError = true)]
	public static extern IntPtr getcwd([Out] StringBuilder buf, ulong size);

	public static StringBuilder getcwd(StringBuilder buf)
	{
		getcwd(buf, (ulong)buf.Capacity);
		return buf;
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int dup(int fd);

	[DllImport("libc", SetLastError = true)]
	public static extern int dup2(int fd, int fd2);

	[DllImport("libc", SetLastError = true)]
	public static extern int execve([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, string[] argv, string[] envp);

	[DllImport("libc", SetLastError = true)]
	public static extern int fexecve(int fd, string[] argv, string[] envp);

	[DllImport("libc", SetLastError = true)]
	public static extern int execv([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, string[] argv);

	[DllImport("libc", SetLastError = true)]
	public static extern int execvp([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, string[] argv);

	[DllImport("libc", SetLastError = true)]
	public static extern int nice(int inc);

	[DllImport("libc", SetLastError = true)]
	[CLSCompliant(false)]
	public static extern int _exit(int status);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fpathconf", SetLastError = true)]
	public static extern long fpathconf(int filedes, PathconfName name, Errno defaultError);

	public static long fpathconf(int filedes, PathconfName name)
	{
		return fpathconf(filedes, name, (Errno)0);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_pathconf", SetLastError = true)]
	public static extern long pathconf([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, PathconfName name, Errno defaultError);

	public static long pathconf(string path, PathconfName name)
	{
		return pathconf(path, name, (Errno)0);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_sysconf", SetLastError = true)]
	public static extern long sysconf(SysconfName name, Errno defaultError);

	public static long sysconf(SysconfName name)
	{
		return sysconf(name, (Errno)0);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_confstr", SetLastError = true)]
	public static extern ulong confstr(ConfstrName name, [Out] StringBuilder buf, ulong len);

	[DllImport("libc", SetLastError = true)]
	public static extern int getpid();

	[DllImport("libc", SetLastError = true)]
	public static extern int getppid();

	[DllImport("libc", SetLastError = true)]
	public static extern int setpgid(int pid, int pgid);

	[DllImport("libc", SetLastError = true)]
	public static extern int getpgid(int pid);

	[DllImport("libc", SetLastError = true)]
	public static extern int setpgrp();

	[DllImport("libc", SetLastError = true)]
	public static extern int getpgrp();

	[DllImport("libc", SetLastError = true)]
	public static extern int setsid();

	[DllImport("libc", SetLastError = true)]
	public static extern int getsid(int pid);

	[DllImport("libc", SetLastError = true)]
	public static extern uint getuid();

	[DllImport("libc", SetLastError = true)]
	public static extern uint geteuid();

	[DllImport("libc", SetLastError = true)]
	public static extern uint getgid();

	[DllImport("libc", SetLastError = true)]
	public static extern uint getegid();

	[DllImport("libc", SetLastError = true)]
	public static extern int getgroups(int size, uint[] list);

	public static int getgroups(uint[] list)
	{
		return getgroups(list.Length, list);
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int setuid(uint uid);

	[DllImport("libc", SetLastError = true)]
	public static extern int setreuid(uint ruid, uint euid);

	[DllImport("libc", SetLastError = true)]
	public static extern int setregid(uint rgid, uint egid);

	[DllImport("libc", SetLastError = true)]
	public static extern int seteuid(uint euid);

	[DllImport("libc", SetLastError = true)]
	public static extern int setegid(uint uid);

	[DllImport("libc", SetLastError = true)]
	public static extern int setgid(uint gid);

	[DllImport("libc", SetLastError = true)]
	public static extern int getresuid(out uint ruid, out uint euid, out uint suid);

	[DllImport("libc", SetLastError = true)]
	public static extern int getresgid(out uint rgid, out uint egid, out uint sgid);

	[DllImport("libc", SetLastError = true)]
	public static extern int setresuid(uint ruid, uint euid, uint suid);

	[DllImport("libc", SetLastError = true)]
	public static extern int setresgid(uint rgid, uint egid, uint sgid);

	[DllImport("libc", EntryPoint = "ttyname", SetLastError = true)]
	private static extern IntPtr sys_ttyname(int fd);

	public static string ttyname(int fd)
	{
		lock (tty_lock)
		{
			IntPtr p = sys_ttyname(fd);
			return UnixMarshal.PtrToString(p);
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_ttyname_r", SetLastError = true)]
	public static extern int ttyname_r(int fd, [Out] StringBuilder buf, ulong buflen);

	public static int ttyname_r(int fd, StringBuilder buf)
	{
		return ttyname_r(fd, buf, (ulong)buf.Capacity);
	}

	[DllImport("libc", EntryPoint = "isatty")]
	private static extern int sys_isatty(int fd);

	public static bool isatty(int fd)
	{
		return sys_isatty(fd) == 1;
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int link([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string oldpath, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string newpath);

	[DllImport("libc", SetLastError = true)]
	public static extern int symlink([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string oldpath, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string newpath);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_readlink", SetLastError = true)]
	public static extern int readlink([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [Out] StringBuilder buf, ulong bufsiz);

	public static int readlink(string path, [Out] StringBuilder buf)
	{
		return readlink(path, buf, (ulong)buf.Capacity);
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int unlink([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname);

	[DllImport("libc", SetLastError = true)]
	public static extern int rmdir([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname);

	[DllImport("libc", SetLastError = true)]
	public static extern int tcgetpgrp(int fd);

	[DllImport("libc", SetLastError = true)]
	public static extern int tcsetpgrp(int fd, int pgrp);

	[DllImport("libc", EntryPoint = "getlogin", SetLastError = true)]
	private static extern IntPtr sys_getlogin();

	public static string getlogin()
	{
		lock (getlogin_lock)
		{
			IntPtr p = sys_getlogin();
			return UnixMarshal.PtrToString(p);
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getlogin_r", SetLastError = true)]
	public static extern int getlogin_r([Out] StringBuilder name, ulong bufsize);

	public static int getlogin_r(StringBuilder name)
	{
		return getlogin_r(name, (ulong)name.Capacity);
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int setlogin(string name);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_gethostname", SetLastError = true)]
	public static extern int gethostname([Out] StringBuilder name, ulong len);

	public static int gethostname(StringBuilder name)
	{
		return gethostname(name, (ulong)name.Capacity);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_sethostname", SetLastError = true)]
	public static extern int sethostname(string name, ulong len);

	public static int sethostname(string name)
	{
		return sethostname(name, (ulong)name.Length);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_gethostid", SetLastError = true)]
	public static extern long gethostid();

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_sethostid", SetLastError = true)]
	public static extern int sethostid(long hostid);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getdomainname", SetLastError = true)]
	public static extern int getdomainname([Out] StringBuilder name, ulong len);

	public static int getdomainname(StringBuilder name)
	{
		return getdomainname(name, (ulong)name.Capacity);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setdomainname", SetLastError = true)]
	public static extern int setdomainname(string name, ulong len);

	public static int setdomainname(string name)
	{
		return setdomainname(name, (ulong)name.Length);
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int vhangup();

	[DllImport("libc", SetLastError = true)]
	public static extern int revoke([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string file);

	[DllImport("libc", SetLastError = true)]
	public static extern int acct([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string filename);

	[DllImport("libc", EntryPoint = "getusershell", SetLastError = true)]
	private static extern IntPtr sys_getusershell();

	public static string getusershell()
	{
		lock (usershell_lock)
		{
			IntPtr p = sys_getusershell();
			return UnixMarshal.PtrToString(p);
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setusershell", SetLastError = true)]
	private static extern int sys_setusershell();

	public static int setusershell()
	{
		lock (usershell_lock)
		{
			return sys_setusershell();
		}
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_endusershell", SetLastError = true)]
	private static extern int sys_endusershell();

	public static int endusershell()
	{
		lock (usershell_lock)
		{
			return sys_endusershell();
		}
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int chroot([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path);

	[DllImport("libc", SetLastError = true)]
	public static extern int fsync(int fd);

	[DllImport("libc", SetLastError = true)]
	public static extern int fdatasync(int fd);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_sync", SetLastError = true)]
	public static extern int sync();

	[DllImport("libc", SetLastError = true)]
	[Obsolete("Dropped in POSIX 1003.1-2001.  Use Syscall.sysconf (SysconfName._SC_PAGESIZE).")]
	public static extern int getpagesize();

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_truncate", SetLastError = true)]
	public static extern int truncate([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, long length);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_ftruncate", SetLastError = true)]
	public static extern int ftruncate(int fd, long length);

	[DllImport("libc", SetLastError = true)]
	public static extern int getdtablesize();

	[DllImport("libc", SetLastError = true)]
	public static extern int brk(IntPtr end_data_segment);

	[DllImport("libc", SetLastError = true)]
	public static extern IntPtr sbrk(IntPtr increment);

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lockf", SetLastError = true)]
	public static extern int lockf(int fd, LockfCommand cmd, long len);

	[Obsolete("This is insecure and should not be used", true)]
	public static string crypt(string key, string salt)
	{
		throw new SecurityException("crypt(3) has been broken.  Use something more secure.");
	}

	[Obsolete("This is insecure and should not be used", true)]
	public static int encrypt(byte[] block, bool decode)
	{
		throw new SecurityException("crypt(3) has been broken.  Use something more secure.");
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_swab", SetLastError = true)]
	public static extern int swab(IntPtr from, IntPtr to, long n);

	public unsafe static void swab(void* from, void* to, long n)
	{
		swab((IntPtr)from, (IntPtr)to, n);
	}

	[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_utime", SetLastError = true)]
	private static extern int sys_utime([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string filename, ref Utimbuf buf, int use_buf);

	public static int utime(string filename, ref Utimbuf buf)
	{
		return sys_utime(filename, ref buf, 1);
	}

	public static int utime(string filename)
	{
		Utimbuf buf = default(Utimbuf);
		return sys_utime(filename, ref buf, 0);
	}
}


using System;

private struct _Dirent
{
	[ino_t]
	public ulong d_ino;

	[off_t]
	public long d_off;

	public ushort d_reclen;

	public byte d_type;

	public IntPtr d_name;
}


using System;

[Map]
private struct _Fstab
{
	public IntPtr fs_spec;

	public IntPtr fs_file;

	public IntPtr fs_vfstype;

	public IntPtr fs_mntops;

	public IntPtr fs_type;

	public int fs_freq;

	public int fs_passno;

	public IntPtr _fs_buf_;
}


using System;

[Map]
private struct _Group
{
	public IntPtr gr_name;

	public IntPtr gr_passwd;

	[gid_t]
	public uint gr_gid;

	public int _gr_nmem_;

	public IntPtr gr_mem;

	public IntPtr _gr_buf_;
}


using System;

[Map]
private struct _Passwd
{
	public IntPtr pw_name;

	public IntPtr pw_passwd;

	[uid_t]
	public uint pw_uid;

	[gid_t]
	public uint pw_gid;

	public IntPtr pw_gecos;

	public IntPtr pw_dir;

	public IntPtr pw_shell;

	public IntPtr _pw_buf_;
}


private struct _pollfd
{
	public int fd;

	public short events;

	public short revents;
}


using System;

[Map]
private struct _Utsname
{
	public IntPtr sysname;

	public IntPtr nodename;

	public IntPtr release;

	public IntPtr version;

	public IntPtr machine;

	public IntPtr domainname;

	public IntPtr _buf_;
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class blkcnt_tAttribute : MapAttribute
{
	public blkcnt_tAttribute()
		: base("blkcnt_t")
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class blksize_tAttribute : MapAttribute
{
	public blksize_tAttribute()
		: base("blksize_t")
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class dev_tAttribute : MapAttribute
{
	public dev_tAttribute()
		: base("dev_t")
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class gid_tAttribute : MapAttribute
{
	public gid_tAttribute()
		: base("gid_t")
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class fsblkcnt_tAttribute : MapAttribute
{
	public fsblkcnt_tAttribute()
		: base("fsblkcnt_t")
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class fsfilcnt_tAttribute : MapAttribute
{
	public fsfilcnt_tAttribute()
		: base("fsfilcnt_t")
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class ino_tAttribute : MapAttribute
{
	public ino_tAttribute()
		: base("ino_t")
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class nlink_tAttribute : MapAttribute
{
	public nlink_tAttribute()
		: base("nlink_t")
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class off_tAttribute : MapAttribute
{
	public off_tAttribute()
		: base("off_t")
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class pid_tAttribute : MapAttribute
{
	public pid_tAttribute()
		: base("pid_t")
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class suseconds_tAttribute : MapAttribute
{
	public suseconds_tAttribute()
		: base("suseconds_t")
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class uid_tAttribute : MapAttribute
{
	public uid_tAttribute()
		: base("uid_t")
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Field)]
internal class time_tAttribute : MapAttribute
{
	public time_tAttribute()
		: base("time_t")
	{
	}
}


using System;
using System.Runtime.InteropServices;

[Obsolete("Use Mono.Unix.Catalog")]
public class Catalog
{
	[DllImport("intl")]
	private static extern IntPtr bindtextdomain(IntPtr domainname, IntPtr dirname);

	[DllImport("intl")]
	private static extern IntPtr bind_textdomain_codeset(IntPtr domainname, IntPtr codeset);

	[DllImport("intl")]
	private static extern IntPtr textdomain(IntPtr domainname);

	public static void Init(string package, string localedir)
	{
		IntPtr intPtr = Marshal.StringToHGlobalAuto(package);
		IntPtr intPtr2 = Marshal.StringToHGlobalAuto(localedir);
		IntPtr intPtr3 = Marshal.StringToHGlobalAuto("UTF-8");
		bindtextdomain(intPtr, intPtr2);
		bind_textdomain_codeset(intPtr, intPtr3);
		textdomain(intPtr);
		Marshal.FreeHGlobal(intPtr);
		Marshal.FreeHGlobal(intPtr2);
		Marshal.FreeHGlobal(intPtr3);
	}

	[DllImport("intl")]
	private static extern IntPtr gettext(IntPtr instring);

	public static string GetString(string s)
	{
		IntPtr intPtr = Marshal.StringToHGlobalAuto(s);
		string result = Marshal.PtrToStringAuto(gettext(intPtr));
		Marshal.FreeHGlobal(intPtr);
		return result;
	}

	[DllImport("intl")]
	private static extern IntPtr ngettext(IntPtr singular, IntPtr plural, int n);

	public static string GetPluralString(string s, string p, int n)
	{
		IntPtr intPtr = Marshal.StringToHGlobalAuto(s);
		IntPtr intPtr2 = Marshal.StringToHGlobalAuto(p);
		string result = Marshal.PtrToStringAnsi(ngettext(intPtr, intPtr2, n));
		Marshal.FreeHGlobal(intPtr);
		Marshal.FreeHGlobal(intPtr2);
		return result;
	}
}


internal struct PeerCredData
{
	public int pid;

	public int uid;

	public int gid;
}


using System;
using System.Net.Sockets;
using Mono.Posix;

[Obsolete("Use Mono.Unix.PeerCred")]
public class PeerCred
{
	private const int so_peercred = 10001;

	private PeerCredData data;

	public int ProcessID => data.pid;

	public int UserID => data.uid;

	public int GroupID => data.gid;

	public PeerCred(Socket sock)
	{
		if (sock.AddressFamily != AddressFamily.Unix)
		{
			throw new ArgumentException("Only Unix sockets are supported", "sock");
		}
		data = (PeerCredData)sock.GetSocketOption(SocketOptionLevel.Socket, (SocketOptionName)10001);
	}
}


using System;

[Obsolete("Use Mono.Unix.Native.OpenFlags")]
[CLSCompliant(false)]
[Flags]
public enum OpenFlags
{
	O_RDONLY = 0,
	O_WRONLY = 1,
	O_RDWR = 2,
	O_CREAT = 4,
	O_EXCL = 8,
	O_NOCTTY = 0x10,
	O_TRUNC = 0x20,
	O_APPEND = 0x40,
	O_NONBLOCK = 0x80,
	O_SYNC = 0x100
}


using System;

[Obsolete("Use Mono.Unix.Native.FilePermissions")]
[Flags]
[CLSCompliant(false)]
public enum FileMode
{
	S_ISUID = 0x800,
	S_ISGID = 0x400,
	S_ISVTX = 0x200,
	S_IRUSR = 0x100,
	S_IWUSR = 0x80,
	S_IXUSR = 0x40,
	S_IRGRP = 0x20,
	S_IWGRP = 0x10,
	S_IXGRP = 8,
	S_IROTH = 4,
	S_IWOTH = 2,
	S_IXOTH = 1
}


using System;

[Flags]
[Obsolete("Use Mono.Unix.Native.WaitOptions")]
[CLSCompliant(false)]
public enum WaitOptions
{
	WNOHANG = 0,
	WUNTRACED = 1
}


using System;

[Flags]
[CLSCompliant(false)]
[Obsolete("Use Mono.Unix.Native.AccessModes")]
public enum AccessMode
{
	R_OK = 1,
	W_OK = 2,
	X_OK = 4,
	F_OK = 8
}


using System;

[Obsolete("Use Mono.Unix.Native.Signum")]
[CLSCompliant(false)]
public enum Signals
{
	SIGHUP,
	SIGINT,
	SIGQUIT,
	SIGILL,
	SIGTRAP,
	SIGABRT,
	SIGBUS,
	SIGFPE,
	SIGKILL,
	SIGUSR1,
	SIGSEGV,
	SIGUSR2,
	SIGPIPE,
	SIGALRM,
	SIGTERM,
	SIGCHLD,
	SIGCONT,
	SIGSTOP,
	SIGTSTP,
	SIGTTIN,
	SIGTTOU,
	SIGURG,
	SIGXCPU,
	SIGXFSZ,
	SIGVTALRM,
	SIGPROF,
	SIGWINCH,
	SIGIO,
	SIGSYS
}


using System;
using System.Runtime.InteropServices;
using System.Text;
using Mono.Posix;

[CLSCompliant(false)]
[Obsolete("Use Mono.Unix.Native.Syscall.")]
public class Syscall
{
	public delegate void sighandler_t(int v);

	[DllImport("libc", SetLastError = true)]
	public static extern int exit(int status);

	[DllImport("libc", SetLastError = true)]
	public static extern int fork();

	[DllImport("libc", SetLastError = true)]
	public unsafe static extern IntPtr read(int fileDescriptor, void* buf, IntPtr count);

	[DllImport("libc", SetLastError = true)]
	public unsafe static extern IntPtr write(int fileDescriptor, void* buf, IntPtr count);

	[DllImport("libc", EntryPoint = "open", SetLastError = true)]
	internal static extern int syscall_open(string pathname, int flags, int mode);

	[DllImport("MonoPosixHelper")]
	internal static extern int map_Mono_Posix_OpenFlags(OpenFlags flags);

	[DllImport("MonoPosixHelper")]
	internal static extern int map_Mono_Posix_FileMode(FileMode mode);

	public static int open(string pathname, OpenFlags flags)
	{
		if ((flags & OpenFlags.O_CREAT) != 0)
		{
			throw new ArgumentException("If you pass O_CREAT, you must call the method with the mode flag");
		}
		int flags2 = map_Mono_Posix_OpenFlags(flags);
		return syscall_open(pathname, flags2, 0);
	}

	public static int open(string pathname, OpenFlags flags, FileMode mode)
	{
		int flags2 = map_Mono_Posix_OpenFlags(flags);
		int mode2 = map_Mono_Posix_FileMode(mode);
		return syscall_open(pathname, flags2, mode2);
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int close(int fileDescriptor);

	[DllImport("libc", EntryPoint = "waitpid", SetLastError = true)]
	internal unsafe static extern int syscall_waitpid(int pid, int* status, int options);

	[DllImport("MonoPosixHelper")]
	internal static extern int map_Mono_Posix_WaitOptions(WaitOptions wait_options);

	public unsafe static int waitpid(int pid, out int status, WaitOptions options)
	{
		int num = 0;
		int result = syscall_waitpid(pid, &num, map_Mono_Posix_WaitOptions(options));
		status = num;
		return result;
	}

	public unsafe static int waitpid(int pid, WaitOptions options)
	{
		return syscall_waitpid(pid, null, map_Mono_Posix_WaitOptions(options));
	}

	[DllImport("MonoPosixHelper", EntryPoint = "wifexited")]
	public static extern int WIFEXITED(int status);

	[DllImport("MonoPosixHelper", EntryPoint = "wexitstatus")]
	public static extern int WEXITSTATUS(int status);

	[DllImport("MonoPosixHelper", EntryPoint = "wifsignaled")]
	public static extern int WIFSIGNALED(int status);

	[DllImport("MonoPosixHelper", EntryPoint = "wtermsig")]
	public static extern int WTERMSIG(int status);

	[DllImport("MonoPosixHelper", EntryPoint = "wifstopped")]
	public static extern int WIFSTOPPED(int status);

	[DllImport("MonoPosixHelper", EntryPoint = "wstopsig")]
	public static extern int WSTOPSIG(int status);

	[DllImport("libc", EntryPoint = "creat", SetLastError = true)]
	internal static extern int syscall_creat(string pathname, int flags);

	public static int creat(string pathname, FileMode flags)
	{
		return syscall_creat(pathname, map_Mono_Posix_FileMode(flags));
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int link(string oldPath, string newPath);

	[DllImport("libc", SetLastError = true)]
	public static extern int unlink(string path);

	[DllImport("libc", SetLastError = true)]
	public static extern int symlink(string oldpath, string newpath);

	[DllImport("libc", SetLastError = true)]
	public static extern int chdir(string path);

	[DllImport("libc", EntryPoint = "chmod", SetLastError = true)]
	internal static extern int syscall_chmod(string path, int mode);

	public static int chmod(string path, FileMode mode)
	{
		return syscall_chmod(path, map_Mono_Posix_FileMode(mode));
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int chown(string path, int owner, int group);

	[DllImport("libc", SetLastError = true)]
	public static extern int lchown(string path, int owner, int group);

	[DllImport("libc", SetLastError = true)]
	public static extern int lseek(int fileDescriptor, int offset, int whence);

	[DllImport("libc", SetLastError = true)]
	public static extern int getpid();

	[DllImport("libc", SetLastError = true)]
	public static extern int setuid(int uid);

	[DllImport("libc", SetLastError = true)]
	public static extern int getuid();

	[DllImport("libc")]
	public static extern uint alarm(uint seconds);

	[DllImport("libc", SetLastError = true)]
	public static extern int pause();

	[DllImport("libc", EntryPoint = "access", SetLastError = true)]
	internal static extern int syscall_access(string pathname, int mode);

	[DllImport("MonoPosixHelper")]
	internal static extern int map_Mono_Posix_AccessMode(AccessMode mode);

	public static int access(string pathname, AccessMode mode)
	{
		return syscall_access(pathname, map_Mono_Posix_AccessMode(mode));
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int nice(int increment);

	[DllImport("libc")]
	public static extern void sync();

	[DllImport("libc", SetLastError = true)]
	public static extern void kill(int pid, int sig);

	[DllImport("libc", SetLastError = true)]
	public static extern int rename(string oldPath, string newPath);

	[DllImport("libc", EntryPoint = "mkdir", SetLastError = true)]
	internal static extern int syscall_mkdir(string pathname, int mode);

	public static int mkdir(string pathname, FileMode mode)
	{
		return syscall_mkdir(pathname, map_Mono_Posix_FileMode(mode));
	}

	[DllImport("libc", SetLastError = true)]
	public static extern int rmdir(string path);

	[DllImport("libc", SetLastError = true)]
	public static extern int dup(int fileDescriptor);

	[DllImport("libc", SetLastError = true)]
	public static extern int setgid(int gid);

	[DllImport("libc", SetLastError = true)]
	public static extern int getgid();

	[DllImport("libc", SetLastError = true)]
	public static extern int signal(int signum, sighandler_t handler);

	[DllImport("libc", SetLastError = true)]
	public static extern int geteuid();

	[DllImport("libc", SetLastError = true)]
	public static extern int getegid();

	[DllImport("libc", SetLastError = true)]
	public static extern int setpgid(int pid, int pgid);

	[DllImport("libc")]
	public static extern int umask(int umask);

	[DllImport("libc", SetLastError = true)]
	public static extern int chroot(string path);

	[DllImport("libc", SetLastError = true)]
	public static extern int dup2(int oldFileDescriptor, int newFileDescriptor);

	[DllImport("libc", SetLastError = true)]
	public static extern int getppid();

	[DllImport("libc", SetLastError = true)]
	public static extern int getpgrp();

	[DllImport("libc", SetLastError = true)]
	public static extern int setsid();

	[DllImport("libc", SetLastError = true)]
	public static extern int setreuid(int ruid, int euid);

	[DllImport("libc", SetLastError = true)]
	public static extern int setregid(int rgid, int egid);

	[DllImport("MonoPosixHelper", SetLastError = true)]
	private static extern string helper_Mono_Posix_GetUserName(int uid);

	[DllImport("MonoPosixHelper", SetLastError = true)]
	private static extern string helper_Mono_Posix_GetGroupName(int gid);

	public static string getusername(int uid)
	{
		return helper_Mono_Posix_GetUserName(uid);
	}

	public static string getgroupname(int gid)
	{
		return helper_Mono_Posix_GetGroupName(gid);
	}

	[DllImport("libc", EntryPoint = "gethostname", SetLastError = true)]
	private static extern int syscall_gethostname(byte[] p, int len);

	public static string GetHostName()
	{
		byte[] array = new byte[256];
		int num = syscall_gethostname(array, array.Length);
		if (num == -1)
		{
			return "localhost";
		}
		for (num = 0; num < array.Length && array[num] != 0; num++)
		{
		}
		return Encoding.UTF8.GetString(array, 0, num);
	}

	[CLSCompliant(false)]
	public static string gethostname()
	{
		return GetHostName();
	}

	[DllImport("libc", EntryPoint = "isatty")]
	private static extern int syscall_isatty(int desc);

	public static bool isatty(int desc)
	{
		int num = syscall_isatty(desc);
		if (num == 1)
		{
			return true;
		}
		return false;
	}

	[DllImport("MonoPosixHelper")]
	internal static extern int helper_Mono_Posix_Stat(string filename, bool dereference, out int device, out int inode, out int mode, out int nlinks, out int uid, out int gid, out int rdev, out long size, out long blksize, out long blocks, out long atime, out long mtime, out long ctime);

	private static int stat2(string filename, bool dereference, out Stat stat)
	{
		int device;
		int inode;
		int mode;
		int nlinks;
		int uid;
		int gid;
		int rdev;
		long size;
		long blksize;
		long blocks;
		long atime;
		long mtime;
		long ctime;
		int num = helper_Mono_Posix_Stat(filename, dereference, out device, out inode, out mode, out nlinks, out uid, out gid, out rdev, out size, out blksize, out blocks, out atime, out mtime, out ctime);
		stat = new Stat(device, inode, mode, nlinks, uid, gid, rdev, size, blksize, blocks, atime, mtime, ctime);
		if (num != 0)
		{
			return num;
		}
		return 0;
	}

	public static int stat(string filename, out Stat stat)
	{
		return stat2(filename, dereference: false, out stat);
	}

	public static int lstat(string filename, out Stat stat)
	{
		return stat2(filename, dereference: true, out stat);
	}

	[DllImport("libc")]
	private static extern int readlink(string path, byte[] buffer, int buflen);

	public static string readlink(string path)
	{
		byte[] array = new byte[512];
		int num = readlink(path, array, array.Length);
		if (num == -1)
		{
			return null;
		}
		char[] array2 = new char[512];
		int chars = Encoding.Default.GetChars(array, 0, num, array2, 0);
		return new string(array2, 0, chars);
	}

	[DllImport("libc", EntryPoint = "strerror")]
	private static extern IntPtr _strerror(int errnum);

	public static string strerror(int errnum)
	{
		return Marshal.PtrToStringAnsi(_strerror(errnum));
	}

	[DllImport("libc")]
	public static extern IntPtr opendir(string path);

	[DllImport("libc")]
	public static extern int closedir(IntPtr dir);

	[DllImport("MonoPosixHelper", EntryPoint = "helper_Mono_Posix_readdir")]
	public static extern string readdir(IntPtr dir);
}


public delegate void sighandler_t(int v);


using System;

[Obsolete("Use Mono.Unix.Native.FilePermissions")]
public enum StatModeMasks
{
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFMT")]
	TypeMask = 61440,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_RWXU")]
	OwnerMask = 448,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_RWXG")]
	GroupMask = 56,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_RWXO")]
	OthersMask = 7
}


using System;

[Flags]
[Obsolete("Use Mono.Unix.Native.FilePermissions")]
public enum StatMode
{
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFSOCK")]
	Socket = 0xC000,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFLNK")]
	SymLink = 0xA000,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFREG")]
	Regular = 0x8000,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFBLK")]
	BlockDevice = 0x6000,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFDIR")]
	Directory = 0x4000,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFCHR")]
	CharDevice = 0x2000,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFIFO")]
	FIFO = 0x1000,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_ISUID")]
	SUid = 0x800,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_ISGID")]
	SGid = 0x400,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_ISVTX")]
	Sticky = 0x200,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IRUSR")]
	OwnerRead = 0x100,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IWUSR")]
	OwnerWrite = 0x80,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IXUSR")]
	OwnerExecute = 0x40,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IRGRP")]
	GroupRead = 0x20,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IWGRP")]
	GroupWrite = 0x10,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IXGRP")]
	GroupExecute = 8,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IROTH")]
	OthersRead = 4,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IWOTH")]
	OthersWrite = 2,
	[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IXOTH")]
	OthersExecute = 1
}


using System;
using Mono.Posix;

[Obsolete("Use Mono.Unix.Native.Stat")]
public struct Stat
{
	[Obsolete("Use Mono.Unix.Native.Stat.st_dev")]
	public readonly int Device;

	[Obsolete("Use Mono.Unix.Native.Stat.st_ino")]
	public readonly int INode;

	[Obsolete("Use Mono.Unix.Native.Stat.st_mode")]
	public readonly StatMode Mode;

	[Obsolete("Use Mono.Unix.Native.Stat.st_nlink")]
	public readonly int NLinks;

	[Obsolete("Use Mono.Unix.Native.Stat.st_uid")]
	public readonly int Uid;

	[Obsolete("Use Mono.Unix.Native.Stat.st_gid")]
	public readonly int Gid;

	[Obsolete("Use Mono.Unix.Native.Stat.st_rdev")]
	public readonly long DeviceType;

	[Obsolete("Use Mono.Unix.Native.Stat.st_size")]
	public readonly long Size;

	[Obsolete("Use Mono.Unix.Native.Stat.st_blksize")]
	public readonly long BlockSize;

	[Obsolete("Use Mono.Unix.Native.Stat.st_blocks")]
	public readonly long Blocks;

	[Obsolete("Use Mono.Unix.Native.Stat.st_atime")]
	public readonly DateTime ATime;

	[Obsolete("Use Mono.Unix.Native.Stat.st_mtime")]
	public readonly DateTime MTime;

	[Obsolete("Use Mono.Unix.Native.Stat.st_ctime")]
	public readonly DateTime CTime;

	[Obsolete("Use Mono.Unix.Native.NativeConvert.LocalUnixEpoch")]
	public static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1);

	internal Stat(int device, int inode, int mode, int nlinks, int uid, int gid, int rdev, long size, long blksize, long blocks, long atime, long mtime, long ctime)
	{
		Device = device;
		INode = inode;
		Mode = (StatMode)mode;
		NLinks = nlinks;
		Uid = uid;
		Gid = gid;
		DeviceType = rdev;
		Size = size;
		BlockSize = blksize;
		Blocks = blocks;
		if (atime != 0L)
		{
			ATime = UnixToDateTime(atime);
		}
		else
		{
			ATime = default(DateTime);
		}
		if (mtime != 0L)
		{
			MTime = UnixToDateTime(mtime);
		}
		else
		{
			MTime = default(DateTime);
		}
		if (ctime != 0L)
		{
			CTime = UnixToDateTime(ctime);
		}
		else
		{
			CTime = default(DateTime);
		}
	}

	[Obsolete("Use Mono.Unix.Native.NativeConvert.ToDateTime")]
	public static DateTime UnixToDateTime(long unix)
	{
		DateTime unixEpoch = UnixEpoch;
		return unixEpoch.Add(TimeSpan.FromSeconds(unix)).ToLocalTime();
	}
}


using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using Mono.Posix;

[Serializable]
[Obsolete("Use Mono.Unix.UnixEndPoint")]
public class UnixEndPoint : EndPoint
{
	private string filename;

	public string Filename
	{
		get
		{
			return filename;
		}
		set
		{
			filename = value;
		}
	}

	public override AddressFamily AddressFamily => AddressFamily.Unix;

	public UnixEndPoint(string filename)
	{
		if (filename == null)
		{
			throw new ArgumentNullException("filename");
		}
		if (filename == string.Empty)
		{
			throw new ArgumentException("Cannot be empty.", "filename");
		}
		this.filename = filename;
	}

	public override EndPoint Create(SocketAddress socketAddress)
	{
		byte[] array = new byte[socketAddress.Size - 2];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = socketAddress[i + 2];
		}
		string @string = Encoding.Default.GetString(array);
		return new UnixEndPoint(@string);
	}

	public override SocketAddress Serialize()
	{
		byte[] bytes = Encoding.Default.GetBytes(filename);
		SocketAddress socketAddress = new SocketAddress(AddressFamily, bytes.Length + 2);
		for (int i = 0; i < bytes.Length; i++)
		{
			socketAddress[i + 2] = bytes[i];
		}
		return socketAddress;
	}

	public override string ToString()
	{
		return filename;
	}

	public override int GetHashCode()
	{
		return filename.GetHashCode();
	}

	public override bool Equals(object o)
	{
		if (!(o is UnixEndPoint unixEndPoint))
		{
			return false;
		}
		return unixEndPoint.filename == filename;
	}
}


using System;
using System.Collections;
using System.IO;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using Mono.Remoting.Channels.Unix;

internal class UnixBinaryClientFormatterSink : IClientChannelSink, IMessageSink, IChannelSinkBase, IClientFormatterSink
{
	private UnixBinaryCore _binaryCore = UnixBinaryCore.DefaultInstance;

	private IClientChannelSink _nextInChain;

	internal UnixBinaryCore BinaryCore
	{
		get
		{
			return _binaryCore;
		}
		set
		{
			_binaryCore = value;
		}
	}

	public IClientChannelSink NextChannelSink => _nextInChain;

	public IMessageSink NextSink => null;

	public IDictionary Properties => null;

	public UnixBinaryClientFormatterSink(IClientChannelSink nextSink)
	{
		_nextInChain = nextSink;
	}

	public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream stream)
	{
		throw new NotSupportedException("UnixBinaryClientFormatterSink must be the first sink in the IClientChannelSink chain");
	}

	public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Expected O, but got Unknown
		IMessage val = (IMessage)_binaryCore.Deserializer.DeserializeMethodResponse(stream, (HeaderHandler)null, (IMethodCallMessage)state);
		sinkStack.DispatchReplyMessage(val);
	}

	public Stream GetRequestStream(IMessage msg, ITransportHeaders headers)
	{
		throw new NotSupportedException();
	}

	public void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, out ITransportHeaders responseHeaders, out Stream responseStream)
	{
		throw new NotSupportedException();
	}

	public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Expected O, but got Unknown
		ITransportHeaders val = (ITransportHeaders)new TransportHeaders();
		Stream stream = _nextInChain.GetRequestStream(msg, val);
		if (stream == null)
		{
			stream = new MemoryStream();
		}
		_binaryCore.Serializer.Serialize(stream, (object)msg, (Header[])null);
		if (stream is MemoryStream)
		{
			stream.Position = 0L;
		}
		ClientChannelSinkStack val2 = new ClientChannelSinkStack(replySink);
		val2.Push((IClientChannelSink)(object)this, (object)msg);
		_nextInChain.AsyncProcessRequest((IClientChannelSinkStack)(object)val2, msg, val, stream);
		return null;
	}

	public IMessage SyncProcessMessage(IMessage msg)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Expected O, but got Unknown
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Expected O, but got Unknown
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Expected O, but got Unknown
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Expected O, but got Unknown
		try
		{
			ITransportHeaders val = (ITransportHeaders)new TransportHeaders();
			val[(object)"__RequestUri"] = ((IMethodMessage)(IMethodCallMessage)msg).Uri;
			val[(object)"Content-Type"] = "application/octet-stream";
			Stream stream = _nextInChain.GetRequestStream(msg, val);
			if (stream == null)
			{
				stream = new MemoryStream();
			}
			_binaryCore.Serializer.Serialize(stream, (object)msg, (Header[])null);
			if (stream is MemoryStream)
			{
				stream.Position = 0L;
			}
			ITransportHeaders val2 = default(ITransportHeaders);
			Stream stream2 = default(Stream);
			_nextInChain.ProcessMessage(msg, val, stream, ref val2, ref stream2);
			return (IMessage)_binaryCore.Deserializer.DeserializeMethodResponse(stream2, (HeaderHandler)null, (IMethodCallMessage)msg);
		}
		catch (Exception ex)
		{
			return (IMessage)new ReturnMessage(ex, (IMethodCallMessage)msg);
		}
	}
}


using System.Collections;
using System.Runtime.Remoting.Channels;
using Mono.Remoting.Channels.Unix;

internal class UnixBinaryClientFormatterSinkProvider : IClientChannelSinkProvider, IClientFormatterSinkProvider
{
	private IClientChannelSinkProvider next;

	private UnixBinaryCore _binaryCore;

	private static string[] allowedProperties = new string[2] { "includeVersions", "strictBinding" };

	public IClientChannelSinkProvider Next
	{
		get
		{
			return next;
		}
		set
		{
			next = value;
		}
	}

	public UnixBinaryClientFormatterSinkProvider()
	{
		_binaryCore = UnixBinaryCore.DefaultInstance;
	}

	public UnixBinaryClientFormatterSinkProvider(IDictionary properties, ICollection providerData)
	{
		_binaryCore = new UnixBinaryCore(this, properties, allowedProperties);
	}

	public IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData)
	{
		IClientChannelSink nextSink = null;
		if (next != null)
		{
			nextSink = next.CreateSink(channel, url, remoteChannelData);
		}
		UnixBinaryClientFormatterSink unixBinaryClientFormatterSink = new UnixBinaryClientFormatterSink(nextSink);
		unixBinaryClientFormatterSink.BinaryCore = _binaryCore;
		return (IClientChannelSink)(object)unixBinaryClientFormatterSink;
	}
}


using System;
using System.Collections;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Runtime.Serialization.Formatters.Binary;
using Mono.Remoting.Channels.Unix;

internal class UnixBinaryCore
{
	private BinaryFormatter _serializationFormatter;

	private BinaryFormatter _deserializationFormatter;

	private bool _includeVersions = true;

	private bool _strictBinding;

	private IDictionary _properties;

	public static UnixBinaryCore DefaultInstance = new UnixBinaryCore();

	public BinaryFormatter Serializer => _serializationFormatter;

	public BinaryFormatter Deserializer => _deserializationFormatter;

	public IDictionary Properties => _properties;

	public UnixBinaryCore(object owner, IDictionary properties, string[] allowedProperties)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		_properties = properties;
		foreach (DictionaryEntry property in properties)
		{
			string text = (string)property.Key;
			if (Array.IndexOf(allowedProperties, text) == -1)
			{
				throw new RemotingException(owner.GetType().Name + " does not recognize '" + text + "' configuration property");
			}
			switch (text)
			{
			case "includeVersions":
				_includeVersions = Convert.ToBoolean(property.Value);
				break;
			case "strictBinding":
				_strictBinding = Convert.ToBoolean(property.Value);
				break;
			}
		}
		Init();
	}

	public UnixBinaryCore()
	{
		_properties = new Hashtable();
		Init();
	}

	public void Init()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		RemotingSurrogateSelector selector = new RemotingSurrogateSelector();
		StreamingContext context = new StreamingContext(StreamingContextStates.Remoting, null);
		_serializationFormatter = new BinaryFormatter((ISurrogateSelector?)selector, context);
		_deserializationFormatter = new BinaryFormatter(null, context);
		if (!_includeVersions)
		{
			_serializationFormatter.AssemblyFormat = FormatterAssemblyStyle.Simple;
			_deserializationFormatter.AssemblyFormat = FormatterAssemblyStyle.Simple;
		}
		if (!_strictBinding)
		{
			_serializationFormatter.Binder = SimpleBinder.Instance;
			_deserializationFormatter.Binder = SimpleBinder.Instance;
		}
	}
}


using System;
using System.Reflection;
using System.Runtime.Serialization;
using Mono.Remoting.Channels.Unix;

internal class SimpleBinder : SerializationBinder
{
	public static SimpleBinder Instance = new SimpleBinder();

	public override Type BindToType(string assemblyName, string typeName)
	{
		if (assemblyName.IndexOf(',') != -1)
		{
			try
			{
				Assembly assembly = Assembly.Load(assemblyName);
				if ((object)assembly == null)
				{
					return null;
				}
				Type type = assembly.GetType(typeName);
				if ((object)type != null)
				{
					return type;
				}
			}
			catch
			{
			}
		}
		return Assembly.LoadWithPartialName(assemblyName)?.GetType(typeName, throwOnError: true);
	}
}


using System;
using System.Collections;
using System.IO;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using Mono.Remoting.Channels.Unix;

internal class UnixBinaryServerFormatterSink : IServerChannelSink, IChannelSinkBase
{
	private UnixBinaryCore _binaryCore = UnixBinaryCore.DefaultInstance;

	private IServerChannelSink next_sink;

	private IChannelReceiver receiver;

	internal UnixBinaryCore BinaryCore
	{
		get
		{
			return _binaryCore;
		}
		set
		{
			_binaryCore = value;
		}
	}

	public IServerChannelSink NextChannelSink => next_sink;

	public IDictionary Properties => null;

	public UnixBinaryServerFormatterSink(IServerChannelSink nextSink, IChannelReceiver receiver)
	{
		next_sink = nextSink;
		this.receiver = receiver;
	}

	public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage message, ITransportHeaders headers, Stream stream)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		ITransportHeaders val = (ITransportHeaders)new TransportHeaders();
		if (sinkStack != null)
		{
			stream = sinkStack.GetResponseStream(message, val);
		}
		if (stream == null)
		{
			stream = new MemoryStream();
		}
		_binaryCore.Serializer.Serialize(stream, (object)message, (Header[])null);
		if (stream is MemoryStream)
		{
			stream.Position = 0L;
		}
		sinkStack.AsyncProcessResponse(message, val, stream);
	}

	public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers)
	{
		return null;
	}

	public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, out IMessage responseMsg, out ITransportHeaders responseHeaders, out Stream responseStream)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Expected O, but got Unknown
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Expected O, but got Unknown
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Expected O, but got Unknown
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Expected O, but got Unknown
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Expected O, but got Unknown
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Expected O, but got Unknown
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Expected O, but got Unknown
		sinkStack.Push((IServerChannelSink)(object)this, (object)null);
		ServerProcessing val;
		try
		{
			string text = (string)requestHeaders[(object)"__RequestUri"];
			string text2 = default(string);
			((IChannel)receiver).Parse(text, ref text2);
			if (text2 == null)
			{
				text2 = text;
			}
			MethodCallHeaderHandler methodCallHeaderHandler = new MethodCallHeaderHandler(text2);
			requestMsg = (IMessage)_binaryCore.Deserializer.Deserialize(requestStream, new HeaderHandler(methodCallHeaderHandler.HandleHeaders));
			val = next_sink.ProcessMessage(sinkStack, requestMsg, requestHeaders, (Stream)null, ref responseMsg, ref responseHeaders, ref responseStream);
		}
		catch (Exception ex)
		{
			responseMsg = (IMessage)new ReturnMessage(ex, (IMethodCallMessage)requestMsg);
			val = (ServerProcessing)0;
			responseHeaders = null;
			responseStream = null;
		}
		if ((int)val == 0)
		{
			for (int i = 0; i < 3; i++)
			{
				responseStream = null;
				responseHeaders = (ITransportHeaders)new TransportHeaders();
				if (sinkStack != null)
				{
					responseStream = ((IServerResponseChannelSinkStack)sinkStack).GetResponseStream(responseMsg, responseHeaders);
				}
				if (responseStream == null)
				{
					responseStream = new MemoryStream();
				}
				try
				{
					_binaryCore.Serializer.Serialize(responseStream, responseMsg);
				}
				catch (Exception ex2)
				{
					if (i == 2)
					{
						throw ex2;
					}
					responseMsg = (IMessage)new ReturnMessage(ex2, (IMethodCallMessage)requestMsg);
					continue;
				}
				break;
			}
			if (responseStream is MemoryStream)
			{
				responseStream.Position = 0L;
			}
			sinkStack.Pop((IServerChannelSink)(object)this);
		}
		return val;
	}
}


using System.Runtime.Remoting.Messaging;

internal class MethodCallHeaderHandler
{
	private string _uri;

	public MethodCallHeaderHandler(string uri)
	{
		_uri = uri;
	}

	public object HandleHeaders(Header[] headers)
	{
		return _uri;
	}
}


using System.Collections;
using System.Runtime.Remoting.Channels;
using Mono.Remoting.Channels.Unix;

internal class UnixBinaryServerFormatterSinkProvider : IServerChannelSinkProvider, IServerFormatterSinkProvider
{
	private IServerChannelSinkProvider next;

	private UnixBinaryCore _binaryCore;

	internal static string[] AllowedProperties = new string[2] { "includeVersions", "strictBinding" };

	public IServerChannelSinkProvider Next
	{
		get
		{
			return next;
		}
		set
		{
			next = value;
		}
	}

	public UnixBinaryServerFormatterSinkProvider()
	{
		_binaryCore = UnixBinaryCore.DefaultInstance;
	}

	public UnixBinaryServerFormatterSinkProvider(IDictionary properties, ICollection providerData)
	{
		_binaryCore = new UnixBinaryCore(this, properties, AllowedProperties);
	}

	public IServerChannelSink CreateSink(IChannelReceiver channel)
	{
		IServerChannelSink nextSink = null;
		if (next != null)
		{
			nextSink = next.CreateSink(channel);
		}
		UnixBinaryServerFormatterSink unixBinaryServerFormatterSink = new UnixBinaryServerFormatterSink(nextSink, channel);
		unixBinaryServerFormatterSink.BinaryCore = _binaryCore;
		return (IServerChannelSink)(object)unixBinaryServerFormatterSink;
	}

	public void GetChannelData(IChannelDataStore channelData)
	{
	}
}


using System;
using System.Collections;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using Mono.Remoting.Channels.Unix;

public class UnixChannel : IChannelSender, IChannel, IChannelReceiver
{
	private UnixClientChannel _clientChannel;

	private UnixServerChannel _serverChannel;

	private string _name = "unix";

	private int _priority = 1;

	public string ChannelName => _name;

	public int ChannelPriority => _priority;

	public object ChannelData
	{
		get
		{
			if (_serverChannel != null)
			{
				return _serverChannel.ChannelData;
			}
			return null;
		}
	}

	public UnixChannel()
		: this(null)
	{
	}

	public UnixChannel(string path)
	{
		Init(new Hashtable { ["path"] = path }, null, null);
	}

	public UnixChannel(IDictionary properties, IClientChannelSinkProvider clientSinkProvider, IServerChannelSinkProvider serverSinkProvider)
	{
		Init(properties, clientSinkProvider, serverSinkProvider);
	}

	private void Init(IDictionary properties, IClientChannelSinkProvider clientSink, IServerChannelSinkProvider serverSink)
	{
		_clientChannel = new UnixClientChannel(properties, clientSink);
		if (properties["path"] != null)
		{
			_serverChannel = new UnixServerChannel(properties, serverSink);
		}
		object obj = properties["name"];
		if (obj != null)
		{
			_name = obj as string;
		}
		obj = properties["priority"];
		if (obj != null)
		{
			_priority = Convert.ToInt32(obj);
		}
	}

	public IMessageSink CreateMessageSink(string url, object remoteChannelData, out string objectURI)
	{
		return _clientChannel.CreateMessageSink(url, remoteChannelData, out objectURI);
	}

	public void StartListening(object data)
	{
		if (_serverChannel != null)
		{
			_serverChannel.StartListening(data);
		}
	}

	public void StopListening(object data)
	{
		if (_serverChannel != null)
		{
			_serverChannel.StopListening(data);
		}
	}

	public string[] GetUrlsForUri(string uri)
	{
		if (_serverChannel != null)
		{
			return _serverChannel.GetUrlsForUri(uri);
		}
		return null;
	}

	public string Parse(string url, out string objectURI)
	{
		return ParseUnixURL(url, out objectURI);
	}

	internal static string ParseUnixURL(string url, out string objectURI)
	{
		objectURI = null;
		if (!url.StartsWith("unix://"))
		{
			return null;
		}
		int num = url.IndexOf('?');
		if (num == -1)
		{
			return url.Substring(7);
		}
		objectURI = url.Substring(num + 1);
		if (objectURI.Length == 0)
		{
			objectURI = null;
		}
		return url.Substring(7, num - 7);
	}
}


using System;
using System.Collections;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using Mono.Remoting.Channels.Unix;

public class UnixClientChannel : IChannelSender, IChannel
{
	private int priority = 1;

	private string name = "unix";

	private IClientChannelSinkProvider _sinkProvider;

	public string ChannelName => name;

	public int ChannelPriority => priority;

	public UnixClientChannel()
	{
		_sinkProvider = (IClientChannelSinkProvider)(object)new UnixBinaryClientFormatterSinkProvider();
		_sinkProvider.Next = (IClientChannelSinkProvider)(object)new UnixClientTransportSinkProvider();
	}

	public UnixClientChannel(IDictionary properties, IClientChannelSinkProvider sinkProvider)
	{
		object obj = properties["name"];
		if (obj != null)
		{
			name = obj as string;
		}
		obj = properties["priority"];
		if (obj != null)
		{
			priority = Convert.ToInt32(obj);
		}
		if (sinkProvider != null)
		{
			_sinkProvider = sinkProvider;
			IClientChannelSinkProvider val = sinkProvider;
			while (val.Next != null)
			{
				val = val.Next;
			}
			val.Next = (IClientChannelSinkProvider)(object)new UnixClientTransportSinkProvider();
		}
		else
		{
			_sinkProvider = (IClientChannelSinkProvider)(object)new UnixBinaryClientFormatterSinkProvider();
			_sinkProvider.Next = (IClientChannelSinkProvider)(object)new UnixClientTransportSinkProvider();
		}
	}

	public UnixClientChannel(string name, IClientChannelSinkProvider sinkProvider)
	{
		this.name = name;
		_sinkProvider = sinkProvider;
		IClientChannelSinkProvider val = sinkProvider;
		while (val.Next != null)
		{
			val = val.Next;
		}
		val.Next = (IClientChannelSinkProvider)(object)new UnixClientTransportSinkProvider();
	}

	public IMessageSink CreateMessageSink(string url, object remoteChannelData, out string objectURI)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Expected O, but got Unknown
		if (url != null && Parse(url, out objectURI) != null)
		{
			return (IMessageSink)_sinkProvider.CreateSink((IChannelSender)(object)this, url, remoteChannelData);
		}
		if (remoteChannelData != null)
		{
			IChannelDataStore val = (IChannelDataStore)((remoteChannelData is IChannelDataStore) ? remoteChannelData : null);
			if (val == null || val.ChannelUris.Length <= 0)
			{
				objectURI = null;
				return null;
			}
			url = val.ChannelUris[0];
		}
		if (Parse(url, out objectURI) == null)
		{
			return null;
		}
		return (IMessageSink)_sinkProvider.CreateSink((IChannelSender)(object)this, url, remoteChannelData);
	}

	public string Parse(string url, out string objectURI)
	{
		return UnixChannel.ParseUnixURL(url, out objectURI);
	}
}


using System;
using System.Collections;
using System.IO;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using System.Threading;
using Mono.Remoting.Channels.Unix;

internal class UnixClientTransportSink : IClientChannelSink, IChannelSinkBase
{
	private string _path;

	public IDictionary Properties => null;

	public IClientChannelSink NextChannelSink => null;

	public UnixClientTransportSink(string url)
	{
		_path = UnixChannel.ParseUnixURL(url, out var _);
	}

	public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream requestStream)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Expected O, but got Unknown
		UnixConnection unixConnection = null;
		bool flag = RemotingServices.IsOneWay(((IMethodMessage)msg).MethodBase);
		try
		{
			if (headers == null)
			{
				headers = (ITransportHeaders)new TransportHeaders();
			}
			headers[(object)"__RequestUri"] = ((IMethodMessage)msg).Uri;
			unixConnection = UnixConnectionPool.GetConnection(_path);
			UnixMessageIO.SendMessageStream(unixConnection.Stream, requestStream, headers, unixConnection.Buffer);
			unixConnection.Stream.Flush();
			if (!flag)
			{
				sinkStack.Push((IClientChannelSink)(object)this, (object)unixConnection);
				ThreadPool.QueueUserWorkItem(ReadAsyncUnixMessage, sinkStack);
			}
			else
			{
				unixConnection.Release();
			}
		}
		catch
		{
			unixConnection?.Release();
			if (!flag)
			{
				throw;
			}
		}
	}

	private void ReadAsyncUnixMessage(object data)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		IClientChannelSinkStack val = (IClientChannelSinkStack)data;
		UnixConnection unixConnection = (UnixConnection)val.Pop((IClientChannelSink)(object)this);
		try
		{
			if (UnixMessageIO.ReceiveMessageStatus(unixConnection.Stream, unixConnection.Buffer) != 0)
			{
				throw new RemotingException("Unknown response message from server");
			}
			ITransportHeaders headers;
			Stream stream = UnixMessageIO.ReceiveMessageStream(unixConnection.Stream, out headers, unixConnection.Buffer);
			unixConnection.Release();
			unixConnection = null;
			((IClientResponseChannelSinkStack)val).AsyncProcessResponse(headers, stream);
		}
		catch
		{
			unixConnection?.Release();
			throw;
		}
	}

	public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream)
	{
		throw new NotSupportedException();
	}

	public Stream GetRequestStream(IMessage msg, ITransportHeaders headers)
	{
		return null;
	}

	public void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, out ITransportHeaders responseHeaders, out Stream responseStream)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Expected O, but got Unknown
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		UnixConnection unixConnection = null;
		try
		{
			if (requestHeaders == null)
			{
				requestHeaders = (ITransportHeaders)new TransportHeaders();
			}
			requestHeaders[(object)"__RequestUri"] = ((IMethodMessage)msg).Uri;
			unixConnection = UnixConnectionPool.GetConnection(_path);
			UnixMessageIO.SendMessageStream(unixConnection.Stream, requestStream, requestHeaders, unixConnection.Buffer);
			unixConnection.Stream.Flush();
			if (UnixMessageIO.ReceiveMessageStatus(unixConnection.Stream, unixConnection.Buffer) != 0)
			{
				throw new RemotingException("Unknown response message from server");
			}
			responseStream = UnixMessageIO.ReceiveMessageStream(unixConnection.Stream, out responseHeaders, unixConnection.Buffer);
		}
		finally
		{
			unixConnection?.Release();
		}
	}
}


using System.Runtime.Remoting.Channels;
using Mono.Remoting.Channels.Unix;

internal class UnixClientTransportSinkProvider : IClientChannelSinkProvider
{
	public IClientChannelSinkProvider Next
	{
		get
		{
			return null;
		}
		set
		{
		}
	}

	public IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData)
	{
		return (IClientChannelSink)(object)new UnixClientTransportSink(url);
	}
}


internal enum MessageStatus
{
	MethodMessage = 0,
	CancelSignal = 1,
	Unknown = 10
}


using System;
using System.Collections;
using System.IO;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Text;
using Mono.Remoting.Channels.Unix;

internal class UnixMessageIO
{
	private static byte[][] _msgHeaders = new byte[2][]
	{
		new byte[6] { 46, 78, 69, 84, 1, 0 },
		new byte[6] { 255, 255, 255, 255, 255, 255 }
	};

	public static int DefaultStreamBufferSize = 1000;

	private static byte[] msgUriTransportKey = new byte[4] { 4, 0, 1, 1 };

	private static byte[] msgContentTypeTransportKey = new byte[4] { 6, 0, 1, 1 };

	private static byte[] msgDefaultTransportKey = new byte[3] { 1, 0, 1 };

	private static byte[] msgHeaderTerminator = new byte[2];

	public static MessageStatus ReceiveMessageStatus(Stream networkStream, byte[] buffer)
	{
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			StreamRead(networkStream, buffer, 6);
		}
		catch (Exception ex)
		{
			throw new RemotingException("Unix transport error.", ex);
		}
		try
		{
			bool[] array = new bool[_msgHeaders.Length];
			bool flag = true;
			int num = 0;
			while (flag)
			{
				flag = false;
				byte b = buffer[num];
				for (int i = 0; i < _msgHeaders.Length; i++)
				{
					if (num <= 0 || array[i])
					{
						array[i] = b == _msgHeaders[i][num];
						if (array[i] && num == _msgHeaders[i].Length - 1)
						{
							return (MessageStatus)i;
						}
						flag = flag || array[i];
					}
				}
				num++;
			}
			return MessageStatus.Unknown;
		}
		catch (Exception ex2)
		{
			throw new RemotingException("Unix transport error.", ex2);
		}
	}

	private static bool StreamRead(Stream networkStream, byte[] buffer, int count)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		do
		{
			int num2 = networkStream.Read(buffer, num, count - num);
			if (num2 == 0)
			{
				throw new RemotingException("Connection closed");
			}
			num += num2;
		}
		while (num < count);
		return true;
	}

	public static void SendMessageStream(Stream networkStream, Stream data, ITransportHeaders requestHeaders, byte[] buffer)
	{
		if (buffer == null)
		{
			buffer = new byte[DefaultStreamBufferSize];
		}
		byte[] array = _msgHeaders[0];
		networkStream.Write(array, 0, array.Length);
		if (requestHeaders[(object)"__RequestUri"] != null)
		{
			buffer[0] = 0;
		}
		else
		{
			buffer[0] = 2;
		}
		buffer[1] = 0;
		buffer[2] = 0;
		buffer[3] = 0;
		int num = (int)data.Length;
		buffer[4] = (byte)num;
		buffer[5] = (byte)(num >> 8);
		buffer[6] = (byte)(num >> 16);
		buffer[7] = (byte)(num >> 24);
		networkStream.Write(buffer, 0, 8);
		SendHeaders(networkStream, requestHeaders, buffer);
		if (data is MemoryStream)
		{
			MemoryStream memoryStream = (MemoryStream)data;
			networkStream.Write(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
			return;
		}
		for (int num2 = data.Read(buffer, 0, buffer.Length); num2 > 0; num2 = data.Read(buffer, 0, buffer.Length))
		{
			networkStream.Write(buffer, 0, num2);
		}
	}

	private static void SendHeaders(Stream networkStream, ITransportHeaders requestHeaders, byte[] buffer)
	{
		if (networkStream != null)
		{
			IEnumerator enumerator = requestHeaders.GetEnumerator();
			while (enumerator.MoveNext())
			{
				DictionaryEntry dictionaryEntry = (DictionaryEntry)enumerator.Current;
				switch (dictionaryEntry.Key.ToString())
				{
				case "__RequestUri":
					networkStream.Write(msgUriTransportKey, 0, 4);
					break;
				case "Content-Type":
					networkStream.Write(msgContentTypeTransportKey, 0, 4);
					break;
				default:
					networkStream.Write(msgDefaultTransportKey, 0, 3);
					SendString(networkStream, dictionaryEntry.Key.ToString(), buffer);
					networkStream.WriteByte(1);
					break;
				}
				SendString(networkStream, dictionaryEntry.Value.ToString(), buffer);
			}
		}
		networkStream.Write(msgHeaderTerminator, 0, 2);
	}

	public static ITransportHeaders ReceiveHeaders(Stream networkStream, byte[] buffer)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		StreamRead(networkStream, buffer, 2);
		byte b = buffer[0];
		TransportHeaders val = new TransportHeaders();
		while (b != 0)
		{
			StreamRead(networkStream, buffer, 1);
			string text = b switch
			{
				4 => "__RequestUri", 
				6 => "Content-Type", 
				1 => ReceiveString(networkStream, buffer), 
				_ => throw new NotSupportedException("Unknown header code: " + b), 
			};
			StreamRead(networkStream, buffer, 1);
			val[(object)text] = ReceiveString(networkStream, buffer);
			StreamRead(networkStream, buffer, 2);
			b = buffer[0];
		}
		return (ITransportHeaders)(object)val;
	}

	public static Stream ReceiveMessageStream(Stream networkStream, out ITransportHeaders headers, byte[] buffer)
	{
		headers = null;
		if (buffer == null)
		{
			buffer = new byte[DefaultStreamBufferSize];
		}
		StreamRead(networkStream, buffer, 8);
		int num = buffer[4] | (buffer[5] << 8) | (buffer[6] << 16) | (buffer[7] << 24);
		headers = ReceiveHeaders(networkStream, buffer);
		byte[] buffer2 = new byte[num];
		StreamRead(networkStream, buffer2, num);
		return new MemoryStream(buffer2);
	}

	private static void SendString(Stream networkStream, string str, byte[] buffer)
	{
		int num = Encoding.UTF8.GetMaxByteCount(str.Length) + 4;
		if (num > buffer.Length)
		{
			buffer = new byte[num];
		}
		int bytes = Encoding.UTF8.GetBytes(str, 0, str.Length, buffer, 4);
		buffer[0] = (byte)bytes;
		buffer[1] = (byte)(bytes >> 8);
		buffer[2] = (byte)(bytes >> 16);
		buffer[3] = (byte)(bytes >> 24);
		networkStream.Write(buffer, 0, bytes + 4);
	}

	private static string ReceiveString(Stream networkStream, byte[] buffer)
	{
		StreamRead(networkStream, buffer, 4);
		int num = buffer[0] | (buffer[1] << 8) | (buffer[2] << 16) | (buffer[3] << 24);
		if (num == 0)
		{
			return string.Empty;
		}
		if (num > buffer.Length)
		{
			buffer = new byte[num];
		}
		StreamRead(networkStream, buffer, num);
		char[] chars = Encoding.UTF8.GetChars(buffer, 0, num);
		return new string(chars);
	}
}


using System;
using System.Collections;
using System.Net.Sockets;
using System.Runtime.Remoting.Channels;
using System.Threading;
using Mono.Remoting.Channels.Unix;
using Mono.Unix;
using Mono.Unix.Native;

public class UnixServerChannel : IChannel, IChannelReceiver
{
	private string path;

	private string name = "unix";

	private int priority = 1;

	private bool supressChannelData;

	private Thread server_thread;

	private UnixListener listener;

	private UnixServerTransportSink sink;

	private ChannelDataStore channel_data;

	private int _maxConcurrentConnections = 100;

	private ArrayList _activeConnections = new ArrayList();

	public object ChannelData
	{
		get
		{
			if (supressChannelData)
			{
				return null;
			}
			return channel_data;
		}
	}

	public string ChannelName => name;

	public int ChannelPriority => priority;

	public UnixServerChannel(string path)
	{
		this.path = path;
		Init(null);
	}

	public UnixServerChannel(IDictionary properties, IServerChannelSinkProvider serverSinkProvider)
	{
		foreach (DictionaryEntry property in properties)
		{
			switch ((string)property.Key)
			{
			case "path":
				path = property.Value as string;
				break;
			case "priority":
				priority = Convert.ToInt32(property.Value);
				break;
			case "supressChannelData":
				supressChannelData = Convert.ToBoolean(property.Value);
				break;
			}
		}
		Init(serverSinkProvider);
	}

	public UnixServerChannel(string name, string path, IServerChannelSinkProvider serverSinkProvider)
	{
		this.name = name;
		this.path = path;
		Init(serverSinkProvider);
	}

	public UnixServerChannel(string name, string path)
	{
		this.name = name;
		this.path = path;
		Init(null);
	}

	private void Init(IServerChannelSinkProvider serverSinkProvider)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		if (serverSinkProvider == null)
		{
			serverSinkProvider = (IServerChannelSinkProvider)(object)new UnixBinaryServerFormatterSinkProvider();
		}
		channel_data = new ChannelDataStore((string[])null);
		for (IServerChannelSinkProvider val = serverSinkProvider; val != null; val = val.Next)
		{
			val.GetChannelData((IChannelDataStore)(object)channel_data);
		}
		IServerChannelSink next = ChannelServices.CreateServerChannelSinkChain(serverSinkProvider, (IChannelReceiver)(object)this);
		sink = new UnixServerTransportSink(next);
		StartListening(null);
	}

	public string GetChannelUri()
	{
		return "unix://" + path;
	}

	public string[] GetUrlsForUri(string uri)
	{
		if (!uri.StartsWith("/"))
		{
			uri = "/" + uri;
		}
		string[] channelUris = channel_data.ChannelUris;
		string[] array = new string[channelUris.Length];
		for (int i = 0; i < channelUris.Length; i++)
		{
			array[i] = channelUris[i] + "?" + uri;
		}
		return array;
	}

	public string Parse(string url, out string objectURI)
	{
		return UnixChannel.ParseUnixURL(url, out objectURI);
	}

	private void WaitForConnections()
	{
		try
		{
			while (true)
			{
				Socket client = listener.AcceptSocket();
				CreateListenerConnection(client);
			}
		}
		catch
		{
		}
	}

	internal void CreateListenerConnection(Socket client)
	{
		lock (_activeConnections)
		{
			if (_activeConnections.Count >= _maxConcurrentConnections)
			{
				Monitor.Wait(_activeConnections);
			}
			if (server_thread != null)
			{
				ClientConnection @object = new ClientConnection(this, client, sink);
				Thread thread = new Thread(@object.ProcessMessages);
				thread.Start();
				thread.IsBackground = true;
				_activeConnections.Add(thread);
			}
		}
	}

	internal void ReleaseConnection(Thread thread)
	{
		lock (_activeConnections)
		{
			_activeConnections.Remove(thread);
			Monitor.Pulse(_activeConnections);
		}
	}

	public void StartListening(object data)
	{
		listener = new UnixListener(path);
		Syscall.chmod(path, FilePermissions.DEFFILEMODE);
		if (server_thread == null)
		{
			listener.Start();
			string[] array = new string[1];
			array = new string[1] { GetChannelUri() };
			channel_data.ChannelUris = array;
			server_thread = new Thread(WaitForConnections);
			server_thread.IsBackground = true;
			server_thread.Start();
		}
	}

	public void StopListening(object data)
	{
		if (server_thread == null)
		{
			return;
		}
		lock (_activeConnections)
		{
			server_thread.Abort();
			server_thread = null;
			listener.Stop();
			foreach (Thread activeConnection in _activeConnections)
			{
				activeConnection.Abort();
			}
			_activeConnections.Clear();
			Monitor.PulseAll(_activeConnections);
		}
	}
}


using System;
using System.IO;
using System.Net.Sockets;
using System.Threading;
using Mono.Remoting.Channels.Unix;

internal class ClientConnection
{
	private Socket _client;

	private UnixServerTransportSink _sink;

	private Stream _stream;

	private UnixServerChannel _serverChannel;

	private byte[] _buffer = new byte[UnixMessageIO.DefaultStreamBufferSize];

	public Socket Client => _client;

	public byte[] Buffer => _buffer;

	public bool IsLocal => true;

	public ClientConnection(UnixServerChannel serverChannel, Socket client, UnixServerTransportSink sink)
	{
		_serverChannel = serverChannel;
		_client = client;
		_sink = sink;
	}

	public void ProcessMessages()
	{
		byte[] buffer = new byte[256];
		_stream = new BufferedStream(new NetworkStream(_client));
		try
		{
			bool flag = false;
			while (!flag)
			{
				switch (UnixMessageIO.ReceiveMessageStatus(_stream, buffer))
				{
				case MessageStatus.MethodMessage:
					_sink.InternalProcessMessage(this, _stream);
					break;
				case MessageStatus.CancelSignal:
				case MessageStatus.Unknown:
					flag = true;
					break;
				}
			}
		}
		catch (Exception)
		{
		}
		finally
		{
			_stream.Close();
			_client.Close();
			_serverChannel.ReleaseConnection(Thread.CurrentThread);
		}
	}
}


using System;
using System.Collections;
using System.IO;
using System.Net.Sockets;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using Mono.Remoting.Channels.Unix;

internal class UnixServerTransportSink : IServerChannelSink, IChannelSinkBase
{
	private IServerChannelSink next_sink;

	public IServerChannelSink NextChannelSink => next_sink;

	public IDictionary Properties
	{
		get
		{
			if (next_sink != null)
			{
				return ((IChannelSinkBase)next_sink).Properties;
			}
			return null;
		}
	}

	public UnixServerTransportSink(IServerChannelSink next)
	{
		next_sink = next;
	}

	public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream responseStream)
	{
		ClientConnection clientConnection = (ClientConnection)state;
		NetworkStream networkStream = new NetworkStream(clientConnection.Client);
		UnixMessageIO.SendMessageStream(networkStream, responseStream, headers, clientConnection.Buffer);
		networkStream.Flush();
		networkStream.Close();
	}

	public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers)
	{
		return null;
	}

	public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, out IMessage responseMsg, out ITransportHeaders responseHeaders, out Stream responseStream)
	{
		throw new NotSupportedException();
	}

	internal void InternalProcessMessage(ClientConnection connection, Stream stream)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Expected O, but got Unknown
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Expected I4, but got Unknown
		ITransportHeaders headers;
		Stream stream2 = UnixMessageIO.ReceiveMessageStream(stream, out headers, connection.Buffer);
		ServerChannelSinkStack val = new ServerChannelSinkStack();
		val.Push((IServerChannelSink)(object)this, (object)connection);
		IMessage val2 = default(IMessage);
		ITransportHeaders requestHeaders = default(ITransportHeaders);
		Stream data = default(Stream);
		ServerProcessing val3 = next_sink.ProcessMessage((IServerChannelSinkStack)(object)val, (IMessage)null, headers, stream2, ref val2, ref requestHeaders, ref data);
		ServerProcessing val4 = val3;
		switch ((int)val4)
		{
		case 0:
			UnixMessageIO.SendMessageStream(stream, data, requestHeaders, connection.Buffer);
			stream.Flush();
			break;
		case 1:
		case 2:
			break;
		}
	}
}


using System.Collections;
using System.Runtime.Remoting;
using System.Threading;
using Mono.Remoting.Channels.Unix;

internal class UnixConnectionPool
{
	private static Hashtable _pools;

	private static int _maxOpenConnections;

	private static int _keepAliveSeconds;

	private static Thread _poolThread;

	public static int MaxOpenConnections
	{
		get
		{
			return _maxOpenConnections;
		}
		set
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			if (value < 1)
			{
				throw new RemotingException("MaxOpenConnections must be greater than zero");
			}
			_maxOpenConnections = value;
		}
	}

	public static int KeepAliveSeconds
	{
		get
		{
			return _keepAliveSeconds;
		}
		set
		{
			_keepAliveSeconds = value;
		}
	}

	static UnixConnectionPool()
	{
		_pools = new Hashtable();
		_maxOpenConnections = int.MaxValue;
		_keepAliveSeconds = 15;
		_poolThread = new Thread(ConnectionCollector);
		_poolThread.Start();
		_poolThread.IsBackground = true;
	}

	public static void Shutdown()
	{
		if (_poolThread != null)
		{
			_poolThread.Abort();
		}
	}

	public static UnixConnection GetConnection(string path)
	{
		HostConnectionPool hostConnectionPool;
		lock (_pools)
		{
			hostConnectionPool = (HostConnectionPool)_pools[path];
			if (hostConnectionPool == null)
			{
				hostConnectionPool = new HostConnectionPool(path);
				_pools[path] = hostConnectionPool;
			}
		}
		return hostConnectionPool.GetConnection();
	}

	private static void ConnectionCollector()
	{
		while (true)
		{
			Thread.Sleep(3000);
			lock (_pools)
			{
				ICollection values = _pools.Values;
				foreach (HostConnectionPool item in values)
				{
					item.PurgeConnections();
				}
			}
		}
	}
}


using System.Net.Sockets;
using Mono.Unix;

internal class ReusableUnixClient : UnixClient
{
	public bool IsAlive => !base.Client.Poll(0, SelectMode.SelectRead);

	public ReusableUnixClient(string path)
		: base(path)
	{
	}
}


using System;
using System.IO;
using Mono.Remoting.Channels.Unix;

internal class UnixConnection
{
	private DateTime _controlTime;

	private Stream _stream;

	private ReusableUnixClient _client;

	private HostConnectionPool _pool;

	private byte[] _buffer;

	public Stream Stream => _stream;

	public DateTime ControlTime
	{
		get
		{
			return _controlTime;
		}
		set
		{
			_controlTime = value;
		}
	}

	public bool IsAlive => _client.IsAlive;

	public byte[] Buffer => _buffer;

	public UnixConnection(HostConnectionPool pool, ReusableUnixClient client)
	{
		_pool = pool;
		_client = client;
		_stream = new BufferedStream(client.GetStream());
		_controlTime = DateTime.Now;
		_buffer = new byte[UnixMessageIO.DefaultStreamBufferSize];
	}

	public void Release()
	{
		_pool.ReleaseConnection(this);
	}

	public void Close()
	{
		_client.Close();
	}
}


using System;
using System.Collections;
using System.Runtime.Remoting;
using System.Threading;
using Mono.Remoting.Channels.Unix;

internal class HostConnectionPool
{
	private ArrayList _pool = new ArrayList();

	private int _activeConnections;

	private string _path;

	public HostConnectionPool(string path)
	{
		_path = path;
	}

	public UnixConnection GetConnection()
	{
		UnixConnection unixConnection = null;
		lock (_pool)
		{
			do
			{
				if (_pool.Count > 0)
				{
					unixConnection = (UnixConnection)_pool[_pool.Count - 1];
					_pool.RemoveAt(_pool.Count - 1);
					if (!unixConnection.IsAlive)
					{
						CancelConnection(unixConnection);
						unixConnection = null;
						continue;
					}
				}
				if (unixConnection == null && _activeConnections < UnixConnectionPool.MaxOpenConnections)
				{
					break;
				}
				if (unixConnection == null)
				{
					Monitor.Wait(_pool);
				}
			}
			while (unixConnection == null);
		}
		if (unixConnection == null)
		{
			return CreateConnection();
		}
		return unixConnection;
	}

	private UnixConnection CreateConnection()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			ReusableUnixClient client = new ReusableUnixClient(_path);
			UnixConnection result = new UnixConnection(this, client);
			_activeConnections++;
			return result;
		}
		catch (Exception ex)
		{
			throw new RemotingException(ex.Message);
		}
	}

	public void ReleaseConnection(UnixConnection entry)
	{
		lock (_pool)
		{
			entry.ControlTime = DateTime.Now;
			_pool.Add(entry);
			Monitor.Pulse(_pool);
		}
	}

	private void CancelConnection(UnixConnection entry)
	{
		try
		{
			entry.Stream.Close();
			_activeConnections--;
		}
		catch
		{
		}
	}

	public void PurgeConnections()
	{
		lock (_pool)
		{
			for (int i = 0; i < _pool.Count; i++)
			{
				UnixConnection unixConnection = (UnixConnection)_pool[i];
				if ((DateTime.Now - unixConnection.ControlTime).TotalSeconds > (double)UnixConnectionPool.KeepAliveSeconds)
				{
					CancelConnection(unixConnection);
					_pool.RemoveAt(i);
					i--;
				}
			}
		}
	}
}


public delegate void SignalHandler(int signal);


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 20)]
private struct $ArrayType$20
{
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 8)]
private struct $ArrayType$8
{
}


using Newtonsoft.Json.Shims;

[Preserve]
public class AddingNewEventArgs
{
	public object NewObject { get; set; }

	public AddingNewEventArgs()
	{
	}

	public AddingNewEventArgs(object newObject)
	{
		NewObject = newObject;
	}
}


using System.ComponentModel;
using Newtonsoft.Json.Shims;

[Preserve]
public delegate void AddingNewEventHandler(object sender, AddingNewEventArgs e);


using System.ComponentModel;
using Newtonsoft.Json.Shims;

[Preserve]
public interface INotifyCollectionChanged
{
	event NotifyCollectionChangedEventHandler CollectionChanged;
}


using System.ComponentModel;
using Newtonsoft.Json.Shims;

[Preserve]
public interface INotifyPropertyChanging
{
	event PropertyChangingEventHandler PropertyChanging;
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum NotifyCollectionChangedAction
{
	Add,
	Remove,
	Replace,
	Move,
	Reset
}


using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json.Shims;

[Preserve]
public class NotifyCollectionChangedEventArgs
{
	internal NotifyCollectionChangedAction Action { get; set; }

	internal IList NewItems { get; set; }

	internal int NewStartingIndex { get; set; }

	internal IList OldItems { get; set; }

	internal int OldStartingIndex { get; set; }

	internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action)
	{
		Action = action;
	}

	internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems)
		: this(action)
	{
		NewItems = changedItems;
	}

	internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem)
		: this(action)
	{
		NewItems = new List<object> { changedItem };
	}

	internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems)
		: this(action, newItems)
	{
		OldItems = oldItems;
	}

	internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int startingIndex)
		: this(action, changedItems)
	{
		NewStartingIndex = startingIndex;
	}

	internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index)
		: this(action, changedItem)
	{
		NewStartingIndex = index;
	}

	internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem)
		: this(action, newItem)
	{
		OldItems = new List<object> { oldItem };
	}

	internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex)
		: this(action, newItems, oldItems)
	{
		NewStartingIndex = startingIndex;
	}

	internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex)
		: this(action, changedItems, index)
	{
		OldStartingIndex = oldIndex;
	}

	internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex)
		: this(action, changedItem, index)
	{
		OldStartingIndex = oldIndex;
	}

	internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem, int index)
		: this(action, newItem, oldItem)
	{
		NewStartingIndex = index;
	}
}


using System.ComponentModel;
using Newtonsoft.Json.Shims;

[Preserve]
public delegate void NotifyCollectionChangedEventHandler(object sender, NotifyCollectionChangedEventArgs e);


using System;
using Newtonsoft.Json.Shims;

[Preserve]
public class PropertyChangingEventArgs : EventArgs
{
	public virtual string PropertyName { get; set; }

	public PropertyChangingEventArgs(string propertyName)
	{
		PropertyName = propertyName;
	}
}


using System.ComponentModel;
using Newtonsoft.Json.Shims;

[Preserve]
public delegate void PropertyChangingEventHandler(object sender, PropertyChangingEventArgs e);


using Newtonsoft.Json.Shims;

[Preserve]
public enum ConstructorHandling
{
	Default,
	AllowNonPublicDefaultConstructor
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum DateFormatHandling
{
	IsoDateFormat,
	MicrosoftDateFormat
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum DateParseHandling
{
	None,
	DateTime,
	DateTimeOffset
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum DateTimeZoneHandling
{
	Local,
	Utc,
	Unspecified,
	RoundtripKind
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum FloatFormatHandling
{
	String,
	Symbol,
	DefaultValue
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum FloatParseHandling
{
	Double,
	Decimal
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum Formatting
{
	None,
	Indented
}


using Newtonsoft.Json.Shims;

[Preserve]
public interface IArrayPool<T>
{
	T[] Rent(int minimumLength);

	void Return(T[] array);
}


using System;
using Newtonsoft.Json.Shims;

[Preserve]
[AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false)]
public sealed class JsonConstructorAttribute : Attribute
{
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
[Preserve]
public sealed class JsonDictionaryAttribute : JsonContainerAttribute
{
	public JsonDictionaryAttribute()
	{
	}

	public JsonDictionaryAttribute(string id)
		: base(id)
	{
	}
}


using System;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Serializable]
[Preserve]
public class JsonException : Exception
{
	public JsonException()
	{
	}

	public JsonException(string message)
		: base(message)
	{
	}

	public JsonException(string message, Exception innerException)
		: base(message, innerException)
	{
	}

	public JsonException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}

	internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message)
	{
		message = JsonPosition.FormatMessage(lineInfo, path, message);
		return new JsonException(message);
	}
}


using System;
using Newtonsoft.Json.Shims;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
[Preserve]
public class JsonExtensionDataAttribute : Attribute
{
	public bool WriteData { get; set; }

	public bool ReadData { get; set; }

	public JsonExtensionDataAttribute()
	{
		WriteData = true;
		ReadData = true;
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
internal enum JsonContainerType
{
	None,
	Object,
	Array,
	Constructor
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal struct JsonPosition
{
	private static readonly char[] SpecialCharacters = new char[6] { '.', ' ', '[', ']', '(', ')' };

	internal JsonContainerType Type;

	internal int Position;

	internal string PropertyName;

	internal bool HasIndex;

	public JsonPosition(JsonContainerType type)
	{
		Type = type;
		HasIndex = TypeHasIndex(type);
		Position = -1;
		PropertyName = null;
	}

	internal int CalculateLength()
	{
		switch (Type)
		{
		case JsonContainerType.Object:
			return PropertyName.Length + 5;
		case JsonContainerType.Array:
		case JsonContainerType.Constructor:
			return MathUtils.IntLength((ulong)Position) + 2;
		default:
			throw new ArgumentOutOfRangeException("Type");
		}
	}

	internal void WriteTo(StringBuilder sb)
	{
		switch (Type)
		{
		case JsonContainerType.Object:
		{
			string propertyName = PropertyName;
			if (propertyName.IndexOfAny(SpecialCharacters) != -1)
			{
				sb.Append("['");
				sb.Append(propertyName);
				sb.Append("']");
				break;
			}
			if (sb.Length > 0)
			{
				sb.Append('.');
			}
			sb.Append(propertyName);
			break;
		}
		case JsonContainerType.Array:
		case JsonContainerType.Constructor:
			sb.Append('[');
			sb.Append(Position);
			sb.Append(']');
			break;
		}
	}

	internal static bool TypeHasIndex(JsonContainerType type)
	{
		if (type != JsonContainerType.Array)
		{
			return type == JsonContainerType.Constructor;
		}
		return true;
	}

	internal static string BuildPath(List<JsonPosition> positions, JsonPosition? currentPosition)
	{
		int num = 0;
		if (positions != null)
		{
			for (int i = 0; i < positions.Count; i++)
			{
				num += positions[i].CalculateLength();
			}
		}
		if (currentPosition.HasValue)
		{
			num += currentPosition.GetValueOrDefault().CalculateLength();
		}
		StringBuilder stringBuilder = new StringBuilder(num);
		if (positions != null)
		{
			foreach (JsonPosition position in positions)
			{
				position.WriteTo(stringBuilder);
			}
		}
		currentPosition?.WriteTo(stringBuilder);
		return stringBuilder.ToString();
	}

	internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message)
	{
		if (!message.EndsWith(Environment.NewLine, StringComparison.Ordinal))
		{
			message = message.Trim();
			if (!StringUtils.EndsWith(message, '.'))
			{
				message += ".";
			}
			message += " ";
		}
		message += "Path '{0}'".FormatWith(CultureInfo.InvariantCulture, path);
		if (lineInfo != null && lineInfo.HasLineInfo())
		{
			message += ", line {0}, position {1}".FormatWith(CultureInfo.InvariantCulture, lineInfo.LineNumber, lineInfo.LinePosition);
		}
		message += ".";
		return message;
	}
}


using System;
using Newtonsoft.Json.Shims;

[Preserve]
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
public sealed class JsonRequiredAttribute : Attribute
{
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum MetadataPropertyHandling
{
	Default,
	ReadAhead,
	Ignore
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum StringEscapeHandling
{
	Default,
	EscapeNonAscii,
	EscapeHtml
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum Required
{
	Default,
	AllowNull,
	Always,
	DisallowNull
}


using System;
using Newtonsoft.Json.Shims;

[Preserve]
[Flags]
public enum PreserveReferencesHandling
{
	None = 0,
	Objects = 1,
	Arrays = 2,
	All = 3
}


using Newtonsoft.Json.Shims;

[Preserve]
public interface IJsonLineInfo
{
	int LineNumber { get; }

	int LinePosition { get; }

	bool HasLineInfo();
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Preserve]
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
public sealed class JsonArrayAttribute : JsonContainerAttribute
{
	private bool _allowNullItems;

	public bool AllowNullItems
	{
		get
		{
			return _allowNullItems;
		}
		set
		{
			_allowNullItems = value;
		}
	}

	public JsonArrayAttribute()
	{
	}

	public JsonArrayAttribute(bool allowNullItems)
	{
		_allowNullItems = allowNullItems;
	}

	public JsonArrayAttribute(string id)
		: base(id)
	{
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
[Preserve]
public abstract class JsonContainerAttribute : Attribute
{
	internal bool? _isReference;

	internal bool? _itemIsReference;

	internal ReferenceLoopHandling? _itemReferenceLoopHandling;

	internal TypeNameHandling? _itemTypeNameHandling;

	public string Id { get; set; }

	public string Title { get; set; }

	public string Description { get; set; }

	public Type ItemConverterType { get; set; }

	public object[] ItemConverterParameters { get; set; }

	public bool IsReference
	{
		get
		{
			return _isReference ?? false;
		}
		set
		{
			_isReference = value;
		}
	}

	public bool ItemIsReference
	{
		get
		{
			return _itemIsReference ?? false;
		}
		set
		{
			_itemIsReference = value;
		}
	}

	public ReferenceLoopHandling ItemReferenceLoopHandling
	{
		get
		{
			return _itemReferenceLoopHandling ?? ReferenceLoopHandling.Error;
		}
		set
		{
			_itemReferenceLoopHandling = value;
		}
	}

	public TypeNameHandling ItemTypeNameHandling
	{
		get
		{
			return _itemTypeNameHandling ?? TypeNameHandling.None;
		}
		set
		{
			_itemTypeNameHandling = value;
		}
	}

	protected JsonContainerAttribute()
	{
	}

	protected JsonContainerAttribute(string id)
	{
		Id = id;
	}
}


using System;
using Newtonsoft.Json.Shims;

[Preserve]
[Flags]
public enum DefaultValueHandling
{
	Include = 0,
	Ignore = 1,
	Populate = 2,
	IgnoreAndPopulate = 3
}


using System;
using Newtonsoft.Json.Shims;

[Preserve]
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface | AttributeTargets.Parameter, AllowMultiple = false)]
public sealed class JsonConverterAttribute : Attribute
{
	private readonly Type _converterType;

	public Type ConverterType => _converterType;

	public object[] ConverterParameters { get; private set; }

	public JsonConverterAttribute(Type converterType)
	{
		if ((object)converterType == null)
		{
			throw new ArgumentNullException("converterType");
		}
		_converterType = converterType;
	}

	public JsonConverterAttribute(Type converterType, params object[] converterParameters)
		: this(converterType)
	{
		ConverterParameters = converterParameters;
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Preserve]
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface, AllowMultiple = false)]
public sealed class JsonObjectAttribute : JsonContainerAttribute
{
	private MemberSerialization _memberSerialization;

	internal Required? _itemRequired;

	public MemberSerialization MemberSerialization
	{
		get
		{
			return _memberSerialization;
		}
		set
		{
			_memberSerialization = value;
		}
	}

	public Required ItemRequired
	{
		get
		{
			return _itemRequired ?? Required.Default;
		}
		set
		{
			_itemRequired = value;
		}
	}

	public JsonObjectAttribute()
	{
	}

	public JsonObjectAttribute(MemberSerialization memberSerialization)
	{
		MemberSerialization = memberSerialization;
	}

	public JsonObjectAttribute(string id)
		: base(id)
	{
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;

[Preserve]
public class JsonSerializerSettings
{
	internal const ReferenceLoopHandling DefaultReferenceLoopHandling = ReferenceLoopHandling.Error;

	internal const MissingMemberHandling DefaultMissingMemberHandling = MissingMemberHandling.Ignore;

	internal const NullValueHandling DefaultNullValueHandling = NullValueHandling.Include;

	internal const DefaultValueHandling DefaultDefaultValueHandling = DefaultValueHandling.Include;

	internal const ObjectCreationHandling DefaultObjectCreationHandling = ObjectCreationHandling.Auto;

	internal const PreserveReferencesHandling DefaultPreserveReferencesHandling = PreserveReferencesHandling.None;

	internal const ConstructorHandling DefaultConstructorHandling = ConstructorHandling.Default;

	internal const TypeNameHandling DefaultTypeNameHandling = TypeNameHandling.None;

	internal const MetadataPropertyHandling DefaultMetadataPropertyHandling = MetadataPropertyHandling.Default;

	internal const FormatterAssemblyStyle DefaultTypeNameAssemblyFormat = FormatterAssemblyStyle.Simple;

	internal static readonly StreamingContext DefaultContext;

	internal const Formatting DefaultFormatting = Formatting.None;

	internal const DateFormatHandling DefaultDateFormatHandling = DateFormatHandling.IsoDateFormat;

	internal const DateTimeZoneHandling DefaultDateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;

	internal const DateParseHandling DefaultDateParseHandling = DateParseHandling.DateTime;

	internal const FloatParseHandling DefaultFloatParseHandling = FloatParseHandling.Double;

	internal const FloatFormatHandling DefaultFloatFormatHandling = FloatFormatHandling.String;

	internal const StringEscapeHandling DefaultStringEscapeHandling = StringEscapeHandling.Default;

	internal const FormatterAssemblyStyle DefaultFormatterAssemblyStyle = FormatterAssemblyStyle.Simple;

	internal static readonly CultureInfo DefaultCulture;

	internal const bool DefaultCheckAdditionalContent = false;

	internal const string DefaultDateFormatString = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

	internal Formatting? _formatting;

	internal DateFormatHandling? _dateFormatHandling;

	internal DateTimeZoneHandling? _dateTimeZoneHandling;

	internal DateParseHandling? _dateParseHandling;

	internal FloatFormatHandling? _floatFormatHandling;

	internal FloatParseHandling? _floatParseHandling;

	internal StringEscapeHandling? _stringEscapeHandling;

	internal CultureInfo _culture;

	internal bool? _checkAdditionalContent;

	internal int? _maxDepth;

	internal bool _maxDepthSet;

	internal string _dateFormatString;

	internal bool _dateFormatStringSet;

	internal FormatterAssemblyStyle? _typeNameAssemblyFormat;

	internal DefaultValueHandling? _defaultValueHandling;

	internal PreserveReferencesHandling? _preserveReferencesHandling;

	internal NullValueHandling? _nullValueHandling;

	internal ObjectCreationHandling? _objectCreationHandling;

	internal MissingMemberHandling? _missingMemberHandling;

	internal ReferenceLoopHandling? _referenceLoopHandling;

	internal StreamingContext? _context;

	internal ConstructorHandling? _constructorHandling;

	internal TypeNameHandling? _typeNameHandling;

	internal MetadataPropertyHandling? _metadataPropertyHandling;

	public ReferenceLoopHandling ReferenceLoopHandling
	{
		get
		{
			return _referenceLoopHandling ?? ReferenceLoopHandling.Error;
		}
		set
		{
			_referenceLoopHandling = value;
		}
	}

	public MissingMemberHandling MissingMemberHandling
	{
		get
		{
			return _missingMemberHandling ?? MissingMemberHandling.Ignore;
		}
		set
		{
			_missingMemberHandling = value;
		}
	}

	public ObjectCreationHandling ObjectCreationHandling
	{
		get
		{
			return _objectCreationHandling ?? ObjectCreationHandling.Auto;
		}
		set
		{
			_objectCreationHandling = value;
		}
	}

	public NullValueHandling NullValueHandling
	{
		get
		{
			return _nullValueHandling ?? NullValueHandling.Include;
		}
		set
		{
			_nullValueHandling = value;
		}
	}

	public DefaultValueHandling DefaultValueHandling
	{
		get
		{
			return _defaultValueHandling ?? DefaultValueHandling.Include;
		}
		set
		{
			_defaultValueHandling = value;
		}
	}

	public IList<JsonConverter> Converters { get; set; }

	public PreserveReferencesHandling PreserveReferencesHandling
	{
		get
		{
			return _preserveReferencesHandling ?? PreserveReferencesHandling.None;
		}
		set
		{
			_preserveReferencesHandling = value;
		}
	}

	public TypeNameHandling TypeNameHandling
	{
		get
		{
			return _typeNameHandling ?? TypeNameHandling.None;
		}
		set
		{
			_typeNameHandling = value;
		}
	}

	public MetadataPropertyHandling MetadataPropertyHandling
	{
		get
		{
			return _metadataPropertyHandling ?? MetadataPropertyHandling.Default;
		}
		set
		{
			_metadataPropertyHandling = value;
		}
	}

	public FormatterAssemblyStyle TypeNameAssemblyFormat
	{
		get
		{
			return _typeNameAssemblyFormat ?? FormatterAssemblyStyle.Simple;
		}
		set
		{
			_typeNameAssemblyFormat = value;
		}
	}

	public ConstructorHandling ConstructorHandling
	{
		get
		{
			return _constructorHandling ?? ConstructorHandling.Default;
		}
		set
		{
			_constructorHandling = value;
		}
	}

	public IContractResolver ContractResolver { get; set; }

	public IEqualityComparer EqualityComparer { get; set; }

	[Obsolete("ReferenceResolver property is obsolete. Use the ReferenceResolverProvider property to set the IReferenceResolver: settings.ReferenceResolverProvider = () => resolver")]
	public IReferenceResolver ReferenceResolver
	{
		get
		{
			if (ReferenceResolverProvider == null)
			{
				return null;
			}
			return ReferenceResolverProvider();
		}
		set
		{
			ReferenceResolverProvider = ((value != null) ? ((Func<IReferenceResolver>)(() => value)) : null);
		}
	}

	public Func<IReferenceResolver> ReferenceResolverProvider { get; set; }

	public ITraceWriter TraceWriter { get; set; }

	public SerializationBinder Binder { get; set; }

	public EventHandler<ErrorEventArgs> Error { get; set; }

	public StreamingContext Context
	{
		get
		{
			return _context ?? DefaultContext;
		}
		set
		{
			_context = value;
		}
	}

	public string DateFormatString
	{
		get
		{
			return _dateFormatString ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";
		}
		set
		{
			_dateFormatString = value;
			_dateFormatStringSet = true;
		}
	}

	public int? MaxDepth
	{
		get
		{
			return _maxDepth;
		}
		set
		{
			if (value <= 0)
			{
				throw new ArgumentException("Value must be positive.", "value");
			}
			_maxDepth = value;
			_maxDepthSet = true;
		}
	}

	public Formatting Formatting
	{
		get
		{
			return _formatting ?? Formatting.None;
		}
		set
		{
			_formatting = value;
		}
	}

	public DateFormatHandling DateFormatHandling
	{
		get
		{
			return _dateFormatHandling ?? DateFormatHandling.IsoDateFormat;
		}
		set
		{
			_dateFormatHandling = value;
		}
	}

	public DateTimeZoneHandling DateTimeZoneHandling
	{
		get
		{
			return _dateTimeZoneHandling ?? DateTimeZoneHandling.RoundtripKind;
		}
		set
		{
			_dateTimeZoneHandling = value;
		}
	}

	public DateParseHandling DateParseHandling
	{
		get
		{
			return _dateParseHandling ?? DateParseHandling.DateTime;
		}
		set
		{
			_dateParseHandling = value;
		}
	}

	public FloatFormatHandling FloatFormatHandling
	{
		get
		{
			return _floatFormatHandling ?? FloatFormatHandling.String;
		}
		set
		{
			_floatFormatHandling = value;
		}
	}

	public FloatParseHandling FloatParseHandling
	{
		get
		{
			return _floatParseHandling ?? FloatParseHandling.Double;
		}
		set
		{
			_floatParseHandling = value;
		}
	}

	public StringEscapeHandling StringEscapeHandling
	{
		get
		{
			return _stringEscapeHandling ?? StringEscapeHandling.Default;
		}
		set
		{
			_stringEscapeHandling = value;
		}
	}

	public CultureInfo Culture
	{
		get
		{
			return _culture ?? DefaultCulture;
		}
		set
		{
			_culture = value;
		}
	}

	public bool CheckAdditionalContent
	{
		get
		{
			return _checkAdditionalContent ?? false;
		}
		set
		{
			_checkAdditionalContent = value;
		}
	}

	static JsonSerializerSettings()
	{
		DefaultContext = default(StreamingContext);
		DefaultCulture = CultureInfo.InvariantCulture;
	}

	public JsonSerializerSettings()
	{
		Converters = new List<JsonConverter>
		{
			new VectorConverter()
		};
		Converters.Add(new HashSetConverter());
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum MemberSerialization
{
	OptOut,
	OptIn,
	Fields
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum ObjectCreationHandling
{
	Auto,
	Reuse,
	Replace
}


using Newtonsoft.Json.Shims;

[Preserve]
internal enum ReadType
{
	Read,
	ReadAsInt32,
	ReadAsBytes,
	ReadAsString,
	ReadAsDecimal,
	ReadAsDateTime,
	ReadAsDateTimeOffset,
	ReadAsDouble,
	ReadAsBoolean
}


using System;
using System.Globalization;
using System.IO;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JsonTextReader : JsonReader, IJsonLineInfo
{
	private const char UnicodeReplacementChar = '\ufffd';

	private const int MaximumJavascriptIntegerCharacterLength = 380;

	private readonly TextReader _reader;

	private char[] _chars;

	private int _charsUsed;

	private int _charPos;

	private int _lineStartPos;

	private int _lineNumber;

	private bool _isEndOfFile;

	private StringBuffer _stringBuffer;

	private StringReference _stringReference;

	private IArrayPool<char> _arrayPool;

	internal PropertyNameTable NameTable;

	public IArrayPool<char> ArrayPool
	{
		get
		{
			return _arrayPool;
		}
		set
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			_arrayPool = value;
		}
	}

	public int LineNumber
	{
		get
		{
			if (base.CurrentState == State.Start && LinePosition == 0 && TokenType != JsonToken.Comment)
			{
				return 0;
			}
			return _lineNumber;
		}
	}

	public int LinePosition => _charPos - _lineStartPos;

	public JsonTextReader(TextReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		_reader = reader;
		_lineNumber = 1;
	}

	private void EnsureBufferNotEmpty()
	{
		if (_stringBuffer.IsEmpty)
		{
			_stringBuffer = new StringBuffer(_arrayPool, 1024);
		}
	}

	private void OnNewLine(int pos)
	{
		_lineNumber++;
		_lineStartPos = pos;
	}

	private void ParseString(char quote, ReadType readType)
	{
		_charPos++;
		ShiftBufferIfNeeded();
		ReadStringIntoBuffer(quote);
		SetPostValueState(updateIndex: true);
		switch (readType)
		{
		case ReadType.ReadAsBytes:
		{
			Guid g;
			byte[] value2 = ((_stringReference.Length == 0) ? new byte[0] : ((_stringReference.Length != 36 || !ConvertUtils.TryConvertGuid(_stringReference.ToString(), out g)) ? Convert.FromBase64CharArray(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length) : g.ToByteArray()));
			SetToken(JsonToken.Bytes, value2, updateIndex: false);
			return;
		}
		case ReadType.ReadAsString:
		{
			string value = _stringReference.ToString();
			SetToken(JsonToken.String, value, updateIndex: false);
			_quoteChar = quote;
			return;
		}
		case ReadType.ReadAsInt32:
		case ReadType.ReadAsDecimal:
		case ReadType.ReadAsBoolean:
			return;
		}
		if (_dateParseHandling != 0)
		{
			DateTimeOffset dt2;
			if (readType switch
			{
				ReadType.ReadAsDateTime => 1, 
				ReadType.ReadAsDateTimeOffset => 2, 
				_ => (int)_dateParseHandling, 
			} == 1)
			{
				if (DateTimeUtils.TryParseDateTime(_stringReference, base.DateTimeZoneHandling, base.DateFormatString, base.Culture, out var dt))
				{
					SetToken(JsonToken.Date, dt, updateIndex: false);
					return;
				}
			}
			else if (DateTimeUtils.TryParseDateTimeOffset(_stringReference, base.DateFormatString, base.Culture, out dt2))
			{
				SetToken(JsonToken.Date, dt2, updateIndex: false);
				return;
			}
		}
		SetToken(JsonToken.String, _stringReference.ToString(), updateIndex: false);
		_quoteChar = quote;
	}

	private static void BlockCopyChars(char[] src, int srcOffset, char[] dst, int dstOffset, int count)
	{
		Buffer.BlockCopy(src, srcOffset * 2, dst, dstOffset * 2, count * 2);
	}

	private void ShiftBufferIfNeeded()
	{
		int num = _chars.Length;
		if ((double)(num - _charPos) <= (double)num * 0.1)
		{
			int num2 = _charsUsed - _charPos;
			if (num2 > 0)
			{
				BlockCopyChars(_chars, _charPos, _chars, 0, num2);
			}
			_lineStartPos -= _charPos;
			_charPos = 0;
			_charsUsed = num2;
			_chars[_charsUsed] = '\0';
		}
	}

	private int ReadData(bool append)
	{
		return ReadData(append, 0);
	}

	private int ReadData(bool append, int charsRequired)
	{
		if (_isEndOfFile)
		{
			return 0;
		}
		if (_charsUsed + charsRequired >= _chars.Length - 1)
		{
			if (append)
			{
				int minSize = Math.Max(_chars.Length * 2, _charsUsed + charsRequired + 1);
				char[] array = BufferUtils.RentBuffer(_arrayPool, minSize);
				BlockCopyChars(_chars, 0, array, 0, _chars.Length);
				BufferUtils.ReturnBuffer(_arrayPool, _chars);
				_chars = array;
			}
			else
			{
				int num = _charsUsed - _charPos;
				if (num + charsRequired + 1 >= _chars.Length)
				{
					char[] array2 = BufferUtils.RentBuffer(_arrayPool, num + charsRequired + 1);
					if (num > 0)
					{
						BlockCopyChars(_chars, _charPos, array2, 0, num);
					}
					BufferUtils.ReturnBuffer(_arrayPool, _chars);
					_chars = array2;
				}
				else if (num > 0)
				{
					BlockCopyChars(_chars, _charPos, _chars, 0, num);
				}
				_lineStartPos -= _charPos;
				_charPos = 0;
				_charsUsed = num;
			}
		}
		int count = _chars.Length - _charsUsed - 1;
		int num2 = _reader.Read(_chars, _charsUsed, count);
		_charsUsed += num2;
		if (num2 == 0)
		{
			_isEndOfFile = true;
		}
		_chars[_charsUsed] = '\0';
		return num2;
	}

	private bool EnsureChars(int relativePosition, bool append)
	{
		if (_charPos + relativePosition >= _charsUsed)
		{
			return ReadChars(relativePosition, append);
		}
		return true;
	}

	private bool ReadChars(int relativePosition, bool append)
	{
		if (_isEndOfFile)
		{
			return false;
		}
		int num = _charPos + relativePosition - _charsUsed + 1;
		int num2 = 0;
		do
		{
			int num3 = ReadData(append, num - num2);
			if (num3 == 0)
			{
				break;
			}
			num2 += num3;
		}
		while (num2 < num);
		if (num2 < num)
		{
			return false;
		}
		return true;
	}

	public override bool Read()
	{
		EnsureBuffer();
		do
		{
			switch (_currentState)
			{
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.ConstructorStart:
			case State.Constructor:
				return ParseValue();
			case State.ObjectStart:
			case State.Object:
				return ParseObject();
			case State.PostValue:
				break;
			case State.Finished:
				if (EnsureChars(0, append: false))
				{
					EatWhitespace(oneOrMore: false);
					if (_isEndOfFile)
					{
						SetToken(JsonToken.None);
						return false;
					}
					if (_chars[_charPos] == '/')
					{
						ParseComment(setToken: true);
						return true;
					}
					throw JsonReaderException.Create(this, "Additional text encountered after finished reading JSON content: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				SetToken(JsonToken.None);
				return false;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}
		while (!ParsePostValue());
		return true;
	}

	public override int? ReadAsInt32()
	{
		return (int?)ReadNumberValue(ReadType.ReadAsInt32);
	}

	public override DateTime? ReadAsDateTime()
	{
		return (DateTime?)ReadStringValue(ReadType.ReadAsDateTime);
	}

	public override string ReadAsString()
	{
		return (string)ReadStringValue(ReadType.ReadAsString);
	}

	public override byte[] ReadAsBytes()
	{
		EnsureBuffer();
		bool flag = false;
		switch (_currentState)
		{
		case State.Start:
		case State.Property:
		case State.ArrayStart:
		case State.Array:
		case State.PostValue:
		case State.ConstructorStart:
		case State.Constructor:
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (ReadNullChar())
					{
						SetToken(JsonToken.None, null, updateIndex: false);
						return null;
					}
					break;
				case '"':
				case '\'':
				{
					ParseString(c, ReadType.ReadAsBytes);
					byte[] array = (byte[])Value;
					if (flag)
					{
						ReaderReadAndAssert();
						if (TokenType != JsonToken.EndObject)
						{
							throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
						}
						SetToken(JsonToken.Bytes, array, updateIndex: false);
					}
					return array;
				}
				case '{':
					_charPos++;
					SetToken(JsonToken.StartObject);
					ReadIntoWrappedTypeObject();
					flag = true;
					break;
				case '[':
					_charPos++;
					SetToken(JsonToken.StartArray);
					return ReadArrayIntoByteArray();
				case 'n':
					HandleNull();
					return null;
				case '/':
					ParseComment(setToken: false);
					break;
				case ',':
					ProcessValueComma();
					break;
				case ']':
					_charPos++;
					if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
					{
						SetToken(JsonToken.EndArray);
						return null;
					}
					throw CreateUnexpectedCharacterException(c);
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				case '\t':
				case ' ':
					_charPos++;
					break;
				default:
					_charPos++;
					if (!char.IsWhiteSpace(c))
					{
						throw CreateUnexpectedCharacterException(c);
					}
					break;
				}
			}
		case State.Finished:
			ReadFinished();
			return null;
		default:
			throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
		}
	}

	private object ReadStringValue(ReadType readType)
	{
		EnsureBuffer();
		switch (_currentState)
		{
		case State.Start:
		case State.Property:
		case State.ArrayStart:
		case State.Array:
		case State.PostValue:
		case State.ConstructorStart:
		case State.Constructor:
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (ReadNullChar())
					{
						SetToken(JsonToken.None, null, updateIndex: false);
						return null;
					}
					break;
				case '"':
				case '\'':
					ParseString(c, readType);
					switch (readType)
					{
					case ReadType.ReadAsBytes:
						return Value;
					case ReadType.ReadAsString:
						return Value;
					case ReadType.ReadAsDateTime:
						if (Value is DateTime)
						{
							return (DateTime)Value;
						}
						return ReadDateTimeString((string)Value);
					case ReadType.ReadAsDateTimeOffset:
						if (Value is DateTimeOffset)
						{
							return (DateTimeOffset)Value;
						}
						return ReadDateTimeOffsetString((string)Value);
					default:
						throw new ArgumentOutOfRangeException("readType");
					}
				case '-':
					if (EnsureChars(1, append: true) && _chars[_charPos + 1] == 'I')
					{
						return ParseNumberNegativeInfinity(readType);
					}
					ParseNumber(readType);
					return Value;
				case '.':
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					if (readType != ReadType.ReadAsString)
					{
						_charPos++;
						throw CreateUnexpectedCharacterException(c);
					}
					ParseNumber(ReadType.ReadAsString);
					return Value;
				case 'f':
				case 't':
				{
					if (readType != ReadType.ReadAsString)
					{
						_charPos++;
						throw CreateUnexpectedCharacterException(c);
					}
					string text = ((c == 't') ? JsonConvert.True : JsonConvert.False);
					if (!MatchValueWithTrailingSeparator(text))
					{
						throw CreateUnexpectedCharacterException(_chars[_charPos]);
					}
					SetToken(JsonToken.String, text);
					return text;
				}
				case 'I':
					return ParseNumberPositiveInfinity(readType);
				case 'N':
					return ParseNumberNaN(readType);
				case 'n':
					HandleNull();
					return null;
				case '/':
					ParseComment(setToken: false);
					break;
				case ',':
					ProcessValueComma();
					break;
				case ']':
					_charPos++;
					if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
					{
						SetToken(JsonToken.EndArray);
						return null;
					}
					throw CreateUnexpectedCharacterException(c);
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				case '\t':
				case ' ':
					_charPos++;
					break;
				default:
					_charPos++;
					if (!char.IsWhiteSpace(c))
					{
						throw CreateUnexpectedCharacterException(c);
					}
					break;
				}
			}
		case State.Finished:
			ReadFinished();
			return null;
		default:
			throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
		}
	}

	private JsonReaderException CreateUnexpectedCharacterException(char c)
	{
		return JsonReaderException.Create(this, "Unexpected character encountered while parsing value: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
	}

	public override bool? ReadAsBoolean()
	{
		EnsureBuffer();
		switch (_currentState)
		{
		case State.Start:
		case State.Property:
		case State.ArrayStart:
		case State.Array:
		case State.PostValue:
		case State.ConstructorStart:
		case State.Constructor:
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (ReadNullChar())
					{
						SetToken(JsonToken.None, null, updateIndex: false);
						return null;
					}
					break;
				case '"':
				case '\'':
					ParseString(c, ReadType.Read);
					return ReadBooleanString(_stringReference.ToString());
				case 'n':
					HandleNull();
					return null;
				case '-':
				case '.':
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					ParseNumber(ReadType.Read);
					bool flag2 = Convert.ToBoolean(Value, CultureInfo.InvariantCulture);
					SetToken(JsonToken.Boolean, flag2, updateIndex: false);
					return flag2;
				}
				case 'f':
				case 't':
				{
					bool flag = c == 't';
					string value = (flag ? JsonConvert.True : JsonConvert.False);
					if (!MatchValueWithTrailingSeparator(value))
					{
						throw CreateUnexpectedCharacterException(_chars[_charPos]);
					}
					SetToken(JsonToken.Boolean, flag);
					return flag;
				}
				case '/':
					ParseComment(setToken: false);
					break;
				case ',':
					ProcessValueComma();
					break;
				case ']':
					_charPos++;
					if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
					{
						SetToken(JsonToken.EndArray);
						return null;
					}
					throw CreateUnexpectedCharacterException(c);
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				case '\t':
				case ' ':
					_charPos++;
					break;
				default:
					_charPos++;
					if (!char.IsWhiteSpace(c))
					{
						throw CreateUnexpectedCharacterException(c);
					}
					break;
				}
			}
		case State.Finished:
			ReadFinished();
			return null;
		default:
			throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
		}
	}

	private void ProcessValueComma()
	{
		_charPos++;
		if (_currentState != State.PostValue)
		{
			SetToken(JsonToken.Undefined);
			throw CreateUnexpectedCharacterException(',');
		}
		SetStateBasedOnCurrent();
	}

	private object ReadNumberValue(ReadType readType)
	{
		EnsureBuffer();
		switch (_currentState)
		{
		case State.Start:
		case State.Property:
		case State.ArrayStart:
		case State.Array:
		case State.PostValue:
		case State.ConstructorStart:
		case State.Constructor:
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (ReadNullChar())
					{
						SetToken(JsonToken.None, null, updateIndex: false);
						return null;
					}
					break;
				case '"':
				case '\'':
					ParseString(c, readType);
					return readType switch
					{
						ReadType.ReadAsInt32 => ReadInt32String(_stringReference.ToString()), 
						ReadType.ReadAsDecimal => ReadDecimalString(_stringReference.ToString()), 
						ReadType.ReadAsDouble => ReadDoubleString(_stringReference.ToString()), 
						_ => throw new ArgumentOutOfRangeException("readType"), 
					};
				case 'n':
					HandleNull();
					return null;
				case 'N':
					return ParseNumberNaN(readType);
				case 'I':
					return ParseNumberPositiveInfinity(readType);
				case '-':
					if (EnsureChars(1, append: true) && _chars[_charPos + 1] == 'I')
					{
						return ParseNumberNegativeInfinity(readType);
					}
					ParseNumber(readType);
					return Value;
				case '.':
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					ParseNumber(readType);
					return Value;
				case '/':
					ParseComment(setToken: false);
					break;
				case ',':
					ProcessValueComma();
					break;
				case ']':
					_charPos++;
					if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
					{
						SetToken(JsonToken.EndArray);
						return null;
					}
					throw CreateUnexpectedCharacterException(c);
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				case '\t':
				case ' ':
					_charPos++;
					break;
				default:
					_charPos++;
					if (!char.IsWhiteSpace(c))
					{
						throw CreateUnexpectedCharacterException(c);
					}
					break;
				}
			}
		case State.Finished:
			ReadFinished();
			return null;
		default:
			throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
		}
	}

	public override DateTimeOffset? ReadAsDateTimeOffset()
	{
		return (DateTimeOffset?)ReadStringValue(ReadType.ReadAsDateTimeOffset);
	}

	public override decimal? ReadAsDecimal()
	{
		return (decimal?)ReadNumberValue(ReadType.ReadAsDecimal);
	}

	public override double? ReadAsDouble()
	{
		return (double?)ReadNumberValue(ReadType.ReadAsDouble);
	}

	private void HandleNull()
	{
		if (EnsureChars(1, append: true))
		{
			if (_chars[_charPos + 1] == 'u')
			{
				ParseNull();
				return;
			}
			_charPos += 2;
			throw CreateUnexpectedCharacterException(_chars[_charPos - 1]);
		}
		_charPos = _charsUsed;
		throw CreateUnexpectedEndException();
	}

	private void ReadFinished()
	{
		if (EnsureChars(0, append: false))
		{
			EatWhitespace(oneOrMore: false);
			if (_isEndOfFile)
			{
				return;
			}
			if (_chars[_charPos] != '/')
			{
				throw JsonReaderException.Create(this, "Additional text encountered after finished reading JSON content: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
			}
			ParseComment(setToken: false);
		}
		SetToken(JsonToken.None);
	}

	private bool ReadNullChar()
	{
		if (_charsUsed == _charPos)
		{
			if (ReadData(append: false) == 0)
			{
				_isEndOfFile = true;
				return true;
			}
		}
		else
		{
			_charPos++;
		}
		return false;
	}

	private void EnsureBuffer()
	{
		if (_chars == null)
		{
			_chars = BufferUtils.RentBuffer(_arrayPool, 1024);
			_chars[0] = '\0';
		}
	}

	private void ReadStringIntoBuffer(char quote)
	{
		int num = _charPos;
		int charPos = _charPos;
		int num2 = _charPos;
		_stringBuffer.Position = 0;
		while (true)
		{
			switch (_chars[num++])
			{
			case '\0':
				if (_charsUsed == num - 1)
				{
					num--;
					if (ReadData(append: true) == 0)
					{
						_charPos = num;
						throw JsonReaderException.Create(this, "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture, quote));
					}
				}
				break;
			case '\\':
			{
				_charPos = num;
				if (!EnsureChars(0, append: true))
				{
					throw JsonReaderException.Create(this, "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture, quote));
				}
				int writeToPosition = num - 1;
				char c = _chars[num];
				num++;
				char c2;
				switch (c)
				{
				case 'b':
					c2 = '\b';
					break;
				case 't':
					c2 = '\t';
					break;
				case 'n':
					c2 = '\n';
					break;
				case 'f':
					c2 = '\f';
					break;
				case 'r':
					c2 = '\r';
					break;
				case '\\':
					c2 = '\\';
					break;
				case '"':
				case '\'':
				case '/':
					c2 = c;
					break;
				case 'u':
					_charPos = num;
					c2 = ParseUnicode();
					if (StringUtils.IsLowSurrogate(c2))
					{
						c2 = '\ufffd';
					}
					else if (StringUtils.IsHighSurrogate(c2))
					{
						bool flag;
						do
						{
							flag = false;
							if (EnsureChars(2, append: true) && _chars[_charPos] == '\\' && _chars[_charPos + 1] == 'u')
							{
								char writeChar = c2;
								_charPos += 2;
								c2 = ParseUnicode();
								if (!StringUtils.IsLowSurrogate(c2))
								{
									if (StringUtils.IsHighSurrogate(c2))
									{
										writeChar = '\ufffd';
										flag = true;
									}
									else
									{
										writeChar = '\ufffd';
									}
								}
								EnsureBufferNotEmpty();
								WriteCharToBuffer(writeChar, num2, writeToPosition);
								num2 = _charPos;
							}
							else
							{
								c2 = '\ufffd';
							}
						}
						while (flag);
					}
					num = _charPos;
					break;
				default:
					_charPos = num;
					throw JsonReaderException.Create(this, "Bad JSON escape sequence: {0}.".FormatWith(CultureInfo.InvariantCulture, "\\" + c));
				}
				EnsureBufferNotEmpty();
				WriteCharToBuffer(c2, num2, writeToPosition);
				num2 = num;
				break;
			}
			case '\r':
				_charPos = num - 1;
				ProcessCarriageReturn(append: true);
				num = _charPos;
				break;
			case '\n':
				_charPos = num - 1;
				ProcessLineFeed();
				num = _charPos;
				break;
			case '"':
			case '\'':
				if (_chars[num - 1] != quote)
				{
					break;
				}
				num--;
				if (charPos == num2)
				{
					_stringReference = new StringReference(_chars, charPos, num - charPos);
				}
				else
				{
					EnsureBufferNotEmpty();
					if (num > num2)
					{
						_stringBuffer.Append(_arrayPool, _chars, num2, num - num2);
					}
					_stringReference = new StringReference(_stringBuffer.InternalBuffer, 0, _stringBuffer.Position);
				}
				num++;
				_charPos = num;
				return;
			}
		}
	}

	private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition)
	{
		if (writeToPosition > lastWritePosition)
		{
			_stringBuffer.Append(_arrayPool, _chars, lastWritePosition, writeToPosition - lastWritePosition);
		}
		_stringBuffer.Append(_arrayPool, writeChar);
	}

	private char ParseUnicode()
	{
		if (EnsureChars(4, append: true))
		{
			char result = Convert.ToChar(ConvertUtils.HexTextToInt(_chars, _charPos, _charPos + 4));
			_charPos += 4;
			return result;
		}
		throw JsonReaderException.Create(this, "Unexpected end while parsing unicode character.");
	}

	private void ReadNumberIntoBuffer()
	{
		int num = _charPos;
		while (true)
		{
			switch (_chars[num])
			{
			case '\0':
				_charPos = num;
				if (_charsUsed != num || ReadData(append: true) == 0)
				{
					return;
				}
				continue;
			case '+':
			case '-':
			case '.':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'X':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'x':
				num++;
				continue;
			}
			_charPos = num;
			char c = _chars[_charPos];
			if (char.IsWhiteSpace(c) || c == ',' || c == '}' || c == ']' || c == ')' || c == '/')
			{
				return;
			}
			throw JsonReaderException.Create(this, "Unexpected character encountered while parsing number: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
		}
	}

	private void ClearRecentString()
	{
		_stringBuffer.Position = 0;
		_stringReference = default(StringReference);
	}

	private bool ParsePostValue()
	{
		while (true)
		{
			char c = _chars[_charPos];
			switch (c)
			{
			case '\0':
				if (_charsUsed == _charPos)
				{
					if (ReadData(append: false) == 0)
					{
						_currentState = State.Finished;
						return false;
					}
				}
				else
				{
					_charPos++;
				}
				break;
			case '}':
				_charPos++;
				SetToken(JsonToken.EndObject);
				return true;
			case ']':
				_charPos++;
				SetToken(JsonToken.EndArray);
				return true;
			case ')':
				_charPos++;
				SetToken(JsonToken.EndConstructor);
				return true;
			case '/':
				ParseComment(setToken: true);
				return true;
			case ',':
				_charPos++;
				SetStateBasedOnCurrent();
				return false;
			case '\t':
			case ' ':
				_charPos++;
				break;
			case '\r':
				ProcessCarriageReturn(append: false);
				break;
			case '\n':
				ProcessLineFeed();
				break;
			default:
				if (char.IsWhiteSpace(c))
				{
					_charPos++;
					break;
				}
				throw JsonReaderException.Create(this, "After parsing a value an unexpected character was encountered: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
			}
		}
	}

	private bool ParseObject()
	{
		while (true)
		{
			char c = _chars[_charPos];
			switch (c)
			{
			case '\0':
				if (_charsUsed == _charPos)
				{
					if (ReadData(append: false) == 0)
					{
						return false;
					}
				}
				else
				{
					_charPos++;
				}
				break;
			case '}':
				SetToken(JsonToken.EndObject);
				_charPos++;
				return true;
			case '/':
				ParseComment(setToken: true);
				return true;
			case '\r':
				ProcessCarriageReturn(append: false);
				break;
			case '\n':
				ProcessLineFeed();
				break;
			case '\t':
			case ' ':
				_charPos++;
				break;
			default:
				if (char.IsWhiteSpace(c))
				{
					_charPos++;
					break;
				}
				return ParseProperty();
			}
		}
	}

	private bool ParseProperty()
	{
		char c = _chars[_charPos];
		char c2;
		if (c == '"' || c == '\'')
		{
			_charPos++;
			c2 = c;
			ShiftBufferIfNeeded();
			ReadStringIntoBuffer(c2);
		}
		else
		{
			if (!ValidIdentifierChar(c))
			{
				throw JsonReaderException.Create(this, "Invalid property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
			}
			c2 = '\0';
			ShiftBufferIfNeeded();
			ParseUnquotedProperty();
		}
		string text;
		if (NameTable != null)
		{
			text = NameTable.Get(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length);
			if (text == null)
			{
				text = _stringReference.ToString();
			}
		}
		else
		{
			text = _stringReference.ToString();
		}
		EatWhitespace(oneOrMore: false);
		if (_chars[_charPos] != ':')
		{
			throw JsonReaderException.Create(this, "Invalid character after parsing property name. Expected ':' but got: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
		}
		_charPos++;
		SetToken(JsonToken.PropertyName, text);
		_quoteChar = c2;
		ClearRecentString();
		return true;
	}

	private bool ValidIdentifierChar(char value)
	{
		if (!char.IsLetterOrDigit(value) && value != '_')
		{
			return value == '$';
		}
		return true;
	}

	private void ParseUnquotedProperty()
	{
		int charPos = _charPos;
		char c;
		while (true)
		{
			if (_chars[_charPos] == '\0')
			{
				if (_charsUsed != _charPos)
				{
					_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
					return;
				}
				if (ReadData(append: true) == 0)
				{
					throw JsonReaderException.Create(this, "Unexpected end while parsing unquoted property name.");
				}
			}
			else
			{
				c = _chars[_charPos];
				if (!ValidIdentifierChar(c))
				{
					break;
				}
				_charPos++;
			}
		}
		if (char.IsWhiteSpace(c) || c == ':')
		{
			_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
			return;
		}
		throw JsonReaderException.Create(this, "Invalid JavaScript property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
	}

	private bool ParseValue()
	{
		while (true)
		{
			char c = _chars[_charPos];
			switch (c)
			{
			case '\0':
				if (_charsUsed == _charPos)
				{
					if (ReadData(append: false) == 0)
					{
						return false;
					}
				}
				else
				{
					_charPos++;
				}
				break;
			case '"':
			case '\'':
				ParseString(c, ReadType.Read);
				return true;
			case 't':
				ParseTrue();
				return true;
			case 'f':
				ParseFalse();
				return true;
			case 'n':
				if (EnsureChars(1, append: true))
				{
					switch (_chars[_charPos + 1])
					{
					case 'u':
						ParseNull();
						break;
					case 'e':
						ParseConstructor();
						break;
					default:
						throw CreateUnexpectedCharacterException(_chars[_charPos]);
					}
					return true;
				}
				_charPos++;
				throw CreateUnexpectedEndException();
			case 'N':
				ParseNumberNaN(ReadType.Read);
				return true;
			case 'I':
				ParseNumberPositiveInfinity(ReadType.Read);
				return true;
			case '-':
				if (EnsureChars(1, append: true) && _chars[_charPos + 1] == 'I')
				{
					ParseNumberNegativeInfinity(ReadType.Read);
				}
				else
				{
					ParseNumber(ReadType.Read);
				}
				return true;
			case '/':
				ParseComment(setToken: true);
				return true;
			case 'u':
				ParseUndefined();
				return true;
			case '{':
				_charPos++;
				SetToken(JsonToken.StartObject);
				return true;
			case '[':
				_charPos++;
				SetToken(JsonToken.StartArray);
				return true;
			case ']':
				_charPos++;
				SetToken(JsonToken.EndArray);
				return true;
			case ',':
				SetToken(JsonToken.Undefined);
				return true;
			case ')':
				_charPos++;
				SetToken(JsonToken.EndConstructor);
				return true;
			case '\r':
				ProcessCarriageReturn(append: false);
				break;
			case '\n':
				ProcessLineFeed();
				break;
			case '\t':
			case ' ':
				_charPos++;
				break;
			default:
				if (char.IsWhiteSpace(c))
				{
					_charPos++;
					break;
				}
				if (char.IsNumber(c) || c == '-' || c == '.')
				{
					ParseNumber(ReadType.Read);
					return true;
				}
				throw CreateUnexpectedCharacterException(c);
			}
		}
	}

	private void ProcessLineFeed()
	{
		_charPos++;
		OnNewLine(_charPos);
	}

	private void ProcessCarriageReturn(bool append)
	{
		_charPos++;
		if (EnsureChars(1, append) && _chars[_charPos] == '\n')
		{
			_charPos++;
		}
		OnNewLine(_charPos);
	}

	private bool EatWhitespace(bool oneOrMore)
	{
		bool flag = false;
		bool flag2 = false;
		while (!flag)
		{
			char c = _chars[_charPos];
			switch (c)
			{
			case '\0':
				if (_charsUsed == _charPos)
				{
					if (ReadData(append: false) == 0)
					{
						flag = true;
					}
				}
				else
				{
					_charPos++;
				}
				break;
			case '\r':
				ProcessCarriageReturn(append: false);
				break;
			case '\n':
				ProcessLineFeed();
				break;
			default:
				if (!char.IsWhiteSpace(c))
				{
					flag = true;
					break;
				}
				goto case ' ';
			case ' ':
				flag2 = true;
				_charPos++;
				break;
			}
		}
		return !oneOrMore || flag2;
	}

	private void ParseConstructor()
	{
		if (MatchValueWithTrailingSeparator("new"))
		{
			EatWhitespace(oneOrMore: false);
			int charPos = _charPos;
			int charPos2;
			while (true)
			{
				char c = _chars[_charPos];
				if (c == '\0')
				{
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: true) == 0)
						{
							throw JsonReaderException.Create(this, "Unexpected end while parsing constructor.");
						}
						continue;
					}
					charPos2 = _charPos;
					_charPos++;
					break;
				}
				if (char.IsLetterOrDigit(c))
				{
					_charPos++;
					continue;
				}
				switch (c)
				{
				case '\r':
					charPos2 = _charPos;
					ProcessCarriageReturn(append: true);
					break;
				case '\n':
					charPos2 = _charPos;
					ProcessLineFeed();
					break;
				default:
					if (char.IsWhiteSpace(c))
					{
						charPos2 = _charPos;
						_charPos++;
						break;
					}
					if (c == '(')
					{
						charPos2 = _charPos;
						break;
					}
					throw JsonReaderException.Create(this, "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
				}
				break;
			}
			_stringReference = new StringReference(_chars, charPos, charPos2 - charPos);
			string value = _stringReference.ToString();
			EatWhitespace(oneOrMore: false);
			if (_chars[_charPos] != '(')
			{
				throw JsonReaderException.Create(this, "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
			}
			_charPos++;
			ClearRecentString();
			SetToken(JsonToken.StartConstructor, value);
			return;
		}
		throw JsonReaderException.Create(this, "Unexpected content while parsing JSON.");
	}

	private void ParseNumber(ReadType readType)
	{
		ShiftBufferIfNeeded();
		char c = _chars[_charPos];
		int charPos = _charPos;
		ReadNumberIntoBuffer();
		SetPostValueState(updateIndex: true);
		_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
		bool flag = char.IsDigit(c) && _stringReference.Length == 1;
		bool flag2 = c == '0' && _stringReference.Length > 1 && _stringReference.Chars[_stringReference.StartIndex + 1] != '.' && _stringReference.Chars[_stringReference.StartIndex + 1] != 'e' && _stringReference.Chars[_stringReference.StartIndex + 1] != 'E';
		JsonToken newToken;
		object value;
		switch (readType)
		{
		case ReadType.ReadAsString:
		{
			string text5 = _stringReference.ToString();
			double result5;
			if (flag2)
			{
				try
				{
					if (text5.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
					{
						Convert.ToInt64(text5, 16);
					}
					else
					{
						Convert.ToInt64(text5, 8);
					}
				}
				catch (Exception ex4)
				{
					throw JsonReaderException.Create(this, "Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, text5), ex4);
				}
			}
			else if (!double.TryParse(text5, NumberStyles.Float, CultureInfo.InvariantCulture, out result5))
			{
				throw JsonReaderException.Create(this, "Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
			}
			newToken = JsonToken.String;
			value = text5;
			break;
		}
		case ReadType.ReadAsInt32:
			if (flag)
			{
				value = c - 48;
			}
			else if (flag2)
			{
				string text6 = _stringReference.ToString();
				try
				{
					value = (text6.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt32(text6, 16) : Convert.ToInt32(text6, 8));
				}
				catch (Exception ex5)
				{
					throw JsonReaderException.Create(this, "Input string '{0}' is not a valid integer.".FormatWith(CultureInfo.InvariantCulture, text6), ex5);
				}
			}
			else
			{
				int value3;
				switch (ConvertUtils.Int32TryParse(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length, out value3))
				{
				case ParseResult.Success:
					break;
				case ParseResult.Overflow:
					throw JsonReaderException.Create(this, "JSON integer {0} is too large or small for an Int32.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
				default:
					throw JsonReaderException.Create(this, "Input string '{0}' is not a valid integer.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
				}
				value = value3;
			}
			newToken = JsonToken.Integer;
			break;
		case ReadType.ReadAsDecimal:
			if (flag)
			{
				value = (decimal)c - 48m;
			}
			else if (flag2)
			{
				string text3 = _stringReference.ToString();
				try
				{
					value = Convert.ToDecimal(text3.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt64(text3, 16) : Convert.ToInt64(text3, 8));
				}
				catch (Exception ex2)
				{
					throw JsonReaderException.Create(this, "Input string '{0}' is not a valid decimal.".FormatWith(CultureInfo.InvariantCulture, text3), ex2);
				}
			}
			else
			{
				if (!decimal.TryParse(_stringReference.ToString(), NumberStyles.Number | NumberStyles.AllowExponent, CultureInfo.InvariantCulture, out var result3))
				{
					throw JsonReaderException.Create(this, "Input string '{0}' is not a valid decimal.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
				}
				value = result3;
			}
			newToken = JsonToken.Float;
			break;
		case ReadType.ReadAsDouble:
			if (flag)
			{
				value = (double)(int)c - 48.0;
			}
			else if (flag2)
			{
				string text4 = _stringReference.ToString();
				try
				{
					value = Convert.ToDouble(text4.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt64(text4, 16) : Convert.ToInt64(text4, 8));
				}
				catch (Exception ex3)
				{
					throw JsonReaderException.Create(this, "Input string '{0}' is not a valid double.".FormatWith(CultureInfo.InvariantCulture, text4), ex3);
				}
			}
			else
			{
				if (!double.TryParse(_stringReference.ToString(), NumberStyles.Float, CultureInfo.InvariantCulture, out var result4))
				{
					throw JsonReaderException.Create(this, "Input string '{0}' is not a valid double.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
				}
				value = result4;
			}
			newToken = JsonToken.Float;
			break;
		default:
		{
			if (flag)
			{
				value = (long)c - 48L;
				newToken = JsonToken.Integer;
				break;
			}
			if (flag2)
			{
				string text = _stringReference.ToString();
				try
				{
					value = (text.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt64(text, 16) : Convert.ToInt64(text, 8));
				}
				catch (Exception ex)
				{
					throw JsonReaderException.Create(this, "Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, text), ex);
				}
				newToken = JsonToken.Integer;
				break;
			}
			long value2;
			switch (ConvertUtils.Int64TryParse(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length, out value2))
			{
			case ParseResult.Success:
				value = value2;
				newToken = JsonToken.Integer;
				break;
			case ParseResult.Overflow:
				throw JsonReaderException.Create(this, "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
			default:
			{
				string text2 = _stringReference.ToString();
				if (_floatParseHandling == FloatParseHandling.Decimal)
				{
					if (!decimal.TryParse(text2, NumberStyles.Number | NumberStyles.AllowExponent, CultureInfo.InvariantCulture, out var result))
					{
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid decimal.".FormatWith(CultureInfo.InvariantCulture, text2));
					}
					value = result;
				}
				else
				{
					if (!double.TryParse(text2, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out var result2))
					{
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, text2));
					}
					value = result2;
				}
				newToken = JsonToken.Float;
				break;
			}
			}
			break;
		}
		}
		ClearRecentString();
		SetToken(newToken, value, updateIndex: false);
	}

	private void ParseComment(bool setToken)
	{
		_charPos++;
		if (!EnsureChars(1, append: false))
		{
			throw JsonReaderException.Create(this, "Unexpected end while parsing comment.");
		}
		bool flag;
		if (_chars[_charPos] == '*')
		{
			flag = false;
		}
		else
		{
			if (_chars[_charPos] != '/')
			{
				throw JsonReaderException.Create(this, "Error parsing comment. Expected: *, got {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
			}
			flag = true;
		}
		_charPos++;
		int charPos = _charPos;
		while (true)
		{
			switch (_chars[_charPos])
			{
			case '\0':
				if (_charsUsed == _charPos)
				{
					if (ReadData(append: true) == 0)
					{
						if (!flag)
						{
							throw JsonReaderException.Create(this, "Unexpected end while parsing comment.");
						}
						EndComment(setToken, charPos, _charPos);
						return;
					}
				}
				else
				{
					_charPos++;
				}
				break;
			case '*':
				_charPos++;
				if (!flag && EnsureChars(0, append: true) && _chars[_charPos] == '/')
				{
					EndComment(setToken, charPos, _charPos - 1);
					_charPos++;
					return;
				}
				break;
			case '\r':
				if (flag)
				{
					EndComment(setToken, charPos, _charPos);
					return;
				}
				ProcessCarriageReturn(append: true);
				break;
			case '\n':
				if (flag)
				{
					EndComment(setToken, charPos, _charPos);
					return;
				}
				ProcessLineFeed();
				break;
			default:
				_charPos++;
				break;
			}
		}
	}

	private void EndComment(bool setToken, int initialPosition, int endPosition)
	{
		if (setToken)
		{
			SetToken(JsonToken.Comment, new string(_chars, initialPosition, endPosition - initialPosition));
		}
	}

	private bool MatchValue(string value)
	{
		if (!EnsureChars(value.Length - 1, append: true))
		{
			_charPos = _charsUsed;
			throw CreateUnexpectedEndException();
		}
		for (int i = 0; i < value.Length; i++)
		{
			if (_chars[_charPos + i] != value[i])
			{
				_charPos += i;
				return false;
			}
		}
		_charPos += value.Length;
		return true;
	}

	private bool MatchValueWithTrailingSeparator(string value)
	{
		if (!MatchValue(value))
		{
			return false;
		}
		if (!EnsureChars(0, append: false))
		{
			return true;
		}
		if (!IsSeparator(_chars[_charPos]))
		{
			return _chars[_charPos] == '\0';
		}
		return true;
	}

	private bool IsSeparator(char c)
	{
		switch (c)
		{
		case ',':
		case ']':
		case '}':
			return true;
		case '/':
		{
			if (!EnsureChars(1, append: false))
			{
				return false;
			}
			char c2 = _chars[_charPos + 1];
			if (c2 != '*')
			{
				return c2 == '/';
			}
			return true;
		}
		case ')':
			if (base.CurrentState == State.Constructor || base.CurrentState == State.ConstructorStart)
			{
				return true;
			}
			break;
		case '\t':
		case '\n':
		case '\r':
		case ' ':
			return true;
		default:
			if (char.IsWhiteSpace(c))
			{
				return true;
			}
			break;
		}
		return false;
	}

	private void ParseTrue()
	{
		if (MatchValueWithTrailingSeparator(JsonConvert.True))
		{
			SetToken(JsonToken.Boolean, true);
			return;
		}
		throw JsonReaderException.Create(this, "Error parsing boolean value.");
	}

	private void ParseNull()
	{
		if (MatchValueWithTrailingSeparator(JsonConvert.Null))
		{
			SetToken(JsonToken.Null);
			return;
		}
		throw JsonReaderException.Create(this, "Error parsing null value.");
	}

	private void ParseUndefined()
	{
		if (MatchValueWithTrailingSeparator(JsonConvert.Undefined))
		{
			SetToken(JsonToken.Undefined);
			return;
		}
		throw JsonReaderException.Create(this, "Error parsing undefined value.");
	}

	private void ParseFalse()
	{
		if (MatchValueWithTrailingSeparator(JsonConvert.False))
		{
			SetToken(JsonToken.Boolean, false);
			return;
		}
		throw JsonReaderException.Create(this, "Error parsing boolean value.");
	}

	private object ParseNumberNegativeInfinity(ReadType readType)
	{
		if (MatchValueWithTrailingSeparator(JsonConvert.NegativeInfinity))
		{
			switch (readType)
			{
			case ReadType.Read:
			case ReadType.ReadAsDouble:
				if (_floatParseHandling == FloatParseHandling.Double)
				{
					SetToken(JsonToken.Float, double.NegativeInfinity);
					return double.NegativeInfinity;
				}
				break;
			case ReadType.ReadAsString:
				SetToken(JsonToken.String, JsonConvert.NegativeInfinity);
				return JsonConvert.NegativeInfinity;
			}
			throw JsonReaderException.Create(this, "Cannot read -Infinity value.");
		}
		throw JsonReaderException.Create(this, "Error parsing -Infinity value.");
	}

	private object ParseNumberPositiveInfinity(ReadType readType)
	{
		if (MatchValueWithTrailingSeparator(JsonConvert.PositiveInfinity))
		{
			switch (readType)
			{
			case ReadType.Read:
			case ReadType.ReadAsDouble:
				if (_floatParseHandling == FloatParseHandling.Double)
				{
					SetToken(JsonToken.Float, double.PositiveInfinity);
					return double.PositiveInfinity;
				}
				break;
			case ReadType.ReadAsString:
				SetToken(JsonToken.String, JsonConvert.PositiveInfinity);
				return JsonConvert.PositiveInfinity;
			}
			throw JsonReaderException.Create(this, "Cannot read Infinity value.");
		}
		throw JsonReaderException.Create(this, "Error parsing Infinity value.");
	}

	private object ParseNumberNaN(ReadType readType)
	{
		if (MatchValueWithTrailingSeparator(JsonConvert.NaN))
		{
			switch (readType)
			{
			case ReadType.Read:
			case ReadType.ReadAsDouble:
				if (_floatParseHandling == FloatParseHandling.Double)
				{
					SetToken(JsonToken.Float, double.NaN);
					return double.NaN;
				}
				break;
			case ReadType.ReadAsString:
				SetToken(JsonToken.String, JsonConvert.NaN);
				return JsonConvert.NaN;
			}
			throw JsonReaderException.Create(this, "Cannot read NaN value.");
		}
		throw JsonReaderException.Create(this, "Error parsing NaN value.");
	}

	public override void Close()
	{
		base.Close();
		if (_chars != null)
		{
			BufferUtils.ReturnBuffer(_arrayPool, _chars);
			_chars = null;
		}
		if (base.CloseInput && _reader != null)
		{
			_reader.Close();
		}
		_stringBuffer.Clear(_arrayPool);
	}

	public bool HasLineInfo()
	{
		return true;
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Preserve]
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
public sealed class JsonPropertyAttribute : Attribute
{
	internal NullValueHandling? _nullValueHandling;

	internal DefaultValueHandling? _defaultValueHandling;

	internal ReferenceLoopHandling? _referenceLoopHandling;

	internal ObjectCreationHandling? _objectCreationHandling;

	internal TypeNameHandling? _typeNameHandling;

	internal bool? _isReference;

	internal int? _order;

	internal Required? _required;

	internal bool? _itemIsReference;

	internal ReferenceLoopHandling? _itemReferenceLoopHandling;

	internal TypeNameHandling? _itemTypeNameHandling;

	public Type ItemConverterType { get; set; }

	public object[] ItemConverterParameters { get; set; }

	public NullValueHandling NullValueHandling
	{
		get
		{
			return _nullValueHandling ?? NullValueHandling.Include;
		}
		set
		{
			_nullValueHandling = value;
		}
	}

	public DefaultValueHandling DefaultValueHandling
	{
		get
		{
			return _defaultValueHandling ?? DefaultValueHandling.Include;
		}
		set
		{
			_defaultValueHandling = value;
		}
	}

	public ReferenceLoopHandling ReferenceLoopHandling
	{
		get
		{
			return _referenceLoopHandling ?? ReferenceLoopHandling.Error;
		}
		set
		{
			_referenceLoopHandling = value;
		}
	}

	public ObjectCreationHandling ObjectCreationHandling
	{
		get
		{
			return _objectCreationHandling ?? ObjectCreationHandling.Auto;
		}
		set
		{
			_objectCreationHandling = value;
		}
	}

	public TypeNameHandling TypeNameHandling
	{
		get
		{
			return _typeNameHandling ?? TypeNameHandling.None;
		}
		set
		{
			_typeNameHandling = value;
		}
	}

	public bool IsReference
	{
		get
		{
			return _isReference ?? false;
		}
		set
		{
			_isReference = value;
		}
	}

	public int Order
	{
		get
		{
			return _order ?? 0;
		}
		set
		{
			_order = value;
		}
	}

	public Required Required
	{
		get
		{
			return _required ?? Required.Default;
		}
		set
		{
			_required = value;
		}
	}

	public string PropertyName { get; set; }

	public ReferenceLoopHandling ItemReferenceLoopHandling
	{
		get
		{
			return _itemReferenceLoopHandling ?? ReferenceLoopHandling.Error;
		}
		set
		{
			_itemReferenceLoopHandling = value;
		}
	}

	public TypeNameHandling ItemTypeNameHandling
	{
		get
		{
			return _itemTypeNameHandling ?? TypeNameHandling.None;
		}
		set
		{
			_itemTypeNameHandling = value;
		}
	}

	public bool ItemIsReference
	{
		get
		{
			return _itemIsReference ?? false;
		}
		set
		{
			_itemIsReference = value;
		}
	}

	public JsonPropertyAttribute()
	{
	}

	public JsonPropertyAttribute(string propertyName)
	{
		PropertyName = propertyName;
	}
}


using System;
using Newtonsoft.Json.Shims;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
[Preserve]
public sealed class JsonIgnoreAttribute : Attribute
{
}


using System;
using System.Globalization;
using System.IO;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JsonTextWriter : JsonWriter
{
	private readonly TextWriter _writer;

	private Base64Encoder _base64Encoder;

	private char _indentChar;

	private int _indentation;

	private char _quoteChar;

	private bool _quoteName;

	private bool[] _charEscapeFlags;

	private char[] _writeBuffer;

	private IArrayPool<char> _arrayPool;

	private char[] _indentChars;

	private Base64Encoder Base64Encoder
	{
		get
		{
			if (_base64Encoder == null)
			{
				_base64Encoder = new Base64Encoder(_writer);
			}
			return _base64Encoder;
		}
	}

	public IArrayPool<char> ArrayPool
	{
		get
		{
			return _arrayPool;
		}
		set
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			_arrayPool = value;
		}
	}

	public int Indentation
	{
		get
		{
			return _indentation;
		}
		set
		{
			if (value < 0)
			{
				throw new ArgumentException("Indentation value must be greater than 0.");
			}
			_indentation = value;
		}
	}

	public char QuoteChar
	{
		get
		{
			return _quoteChar;
		}
		set
		{
			if (value != '"' && value != '\'')
			{
				throw new ArgumentException("Invalid JavaScript string quote character. Valid quote characters are ' and \".");
			}
			_quoteChar = value;
			UpdateCharEscapeFlags();
		}
	}

	public char IndentChar
	{
		get
		{
			return _indentChar;
		}
		set
		{
			if (value != _indentChar)
			{
				_indentChar = value;
				_indentChars = null;
			}
		}
	}

	public bool QuoteName
	{
		get
		{
			return _quoteName;
		}
		set
		{
			_quoteName = value;
		}
	}

	public JsonTextWriter(TextWriter textWriter)
	{
		if (textWriter == null)
		{
			throw new ArgumentNullException("textWriter");
		}
		_writer = textWriter;
		_quoteChar = '"';
		_quoteName = true;
		_indentChar = ' ';
		_indentation = 2;
		UpdateCharEscapeFlags();
	}

	public override void Flush()
	{
		_writer.Flush();
	}

	public override void Close()
	{
		base.Close();
		if (_writeBuffer != null)
		{
			BufferUtils.ReturnBuffer(_arrayPool, _writeBuffer);
			_writeBuffer = null;
		}
		if (base.CloseOutput && _writer != null)
		{
			_writer.Close();
		}
	}

	public override void WriteStartObject()
	{
		InternalWriteStart(JsonToken.StartObject, JsonContainerType.Object);
		_writer.Write('{');
	}

	public override void WriteStartArray()
	{
		InternalWriteStart(JsonToken.StartArray, JsonContainerType.Array);
		_writer.Write('[');
	}

	public override void WriteStartConstructor(string name)
	{
		InternalWriteStart(JsonToken.StartConstructor, JsonContainerType.Constructor);
		_writer.Write("new ");
		_writer.Write(name);
		_writer.Write('(');
	}

	protected override void WriteEnd(JsonToken token)
	{
		switch (token)
		{
		case JsonToken.EndObject:
			_writer.Write('}');
			break;
		case JsonToken.EndArray:
			_writer.Write(']');
			break;
		case JsonToken.EndConstructor:
			_writer.Write(')');
			break;
		default:
			throw JsonWriterException.Create(this, "Invalid JsonToken: " + token, null);
		}
	}

	public override void WritePropertyName(string name)
	{
		InternalWritePropertyName(name);
		WriteEscapedString(name, _quoteName);
		_writer.Write(':');
	}

	public override void WritePropertyName(string name, bool escape)
	{
		InternalWritePropertyName(name);
		if (escape)
		{
			WriteEscapedString(name, _quoteName);
		}
		else
		{
			if (_quoteName)
			{
				_writer.Write(_quoteChar);
			}
			_writer.Write(name);
			if (_quoteName)
			{
				_writer.Write(_quoteChar);
			}
		}
		_writer.Write(':');
	}

	internal override void OnStringEscapeHandlingChanged()
	{
		UpdateCharEscapeFlags();
	}

	private void UpdateCharEscapeFlags()
	{
		_charEscapeFlags = JavaScriptUtils.GetCharEscapeFlags(base.StringEscapeHandling, _quoteChar);
	}

	protected override void WriteIndent()
	{
		_writer.WriteLine();
		int num = base.Top * _indentation;
		if (num > 0)
		{
			if (_indentChars == null)
			{
				_indentChars = new string(_indentChar, 10).ToCharArray();
			}
			while (num > 0)
			{
				int num2 = Math.Min(num, 10);
				_writer.Write(_indentChars, 0, num2);
				num -= num2;
			}
		}
	}

	protected override void WriteValueDelimiter()
	{
		_writer.Write(',');
	}

	protected override void WriteIndentSpace()
	{
		_writer.Write(' ');
	}

	private void WriteValueInternal(string value, JsonToken token)
	{
		_writer.Write(value);
	}

	public override void WriteValue(object value)
	{
		base.WriteValue(value);
	}

	public override void WriteNull()
	{
		InternalWriteValue(JsonToken.Null);
		WriteValueInternal(JsonConvert.Null, JsonToken.Null);
	}

	public override void WriteUndefined()
	{
		InternalWriteValue(JsonToken.Undefined);
		WriteValueInternal(JsonConvert.Undefined, JsonToken.Undefined);
	}

	public override void WriteRaw(string json)
	{
		InternalWriteRaw();
		_writer.Write(json);
	}

	public override void WriteValue(string value)
	{
		InternalWriteValue(JsonToken.String);
		if (value == null)
		{
			WriteValueInternal(JsonConvert.Null, JsonToken.Null);
		}
		else
		{
			WriteEscapedString(value, quote: true);
		}
	}

	private void WriteEscapedString(string value, bool quote)
	{
		EnsureWriteBuffer();
		JavaScriptUtils.WriteEscapedJavaScriptString(_writer, value, _quoteChar, quote, _charEscapeFlags, base.StringEscapeHandling, _arrayPool, ref _writeBuffer);
	}

	public override void WriteValue(int value)
	{
		InternalWriteValue(JsonToken.Integer);
		WriteIntegerValue(value);
	}

	[CLSCompliant(false)]
	public override void WriteValue(uint value)
	{
		InternalWriteValue(JsonToken.Integer);
		WriteIntegerValue(value);
	}

	public override void WriteValue(long value)
	{
		InternalWriteValue(JsonToken.Integer);
		WriteIntegerValue(value);
	}

	[CLSCompliant(false)]
	public override void WriteValue(ulong value)
	{
		InternalWriteValue(JsonToken.Integer);
		WriteIntegerValue(value);
	}

	public override void WriteValue(float value)
	{
		InternalWriteValue(JsonToken.Float);
		WriteValueInternal(JsonConvert.ToString(value, base.FloatFormatHandling, QuoteChar, nullable: false), JsonToken.Float);
	}

	public override void WriteValue(float? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
			return;
		}
		InternalWriteValue(JsonToken.Float);
		WriteValueInternal(JsonConvert.ToString(value.GetValueOrDefault(), base.FloatFormatHandling, QuoteChar, nullable: true), JsonToken.Float);
	}

	public override void WriteValue(double value)
	{
		InternalWriteValue(JsonToken.Float);
		WriteValueInternal(JsonConvert.ToString(value, base.FloatFormatHandling, QuoteChar, nullable: false), JsonToken.Float);
	}

	public override void WriteValue(double? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
			return;
		}
		InternalWriteValue(JsonToken.Float);
		WriteValueInternal(JsonConvert.ToString(value.GetValueOrDefault(), base.FloatFormatHandling, QuoteChar, nullable: true), JsonToken.Float);
	}

	public override void WriteValue(bool value)
	{
		InternalWriteValue(JsonToken.Boolean);
		WriteValueInternal(JsonConvert.ToString(value), JsonToken.Boolean);
	}

	public override void WriteValue(short value)
	{
		InternalWriteValue(JsonToken.Integer);
		WriteIntegerValue(value);
	}

	[CLSCompliant(false)]
	public override void WriteValue(ushort value)
	{
		InternalWriteValue(JsonToken.Integer);
		WriteIntegerValue(value);
	}

	public override void WriteValue(char value)
	{
		InternalWriteValue(JsonToken.String);
		WriteValueInternal(JsonConvert.ToString(value), JsonToken.String);
	}

	public override void WriteValue(byte value)
	{
		InternalWriteValue(JsonToken.Integer);
		WriteIntegerValue(value);
	}

	[CLSCompliant(false)]
	public override void WriteValue(sbyte value)
	{
		InternalWriteValue(JsonToken.Integer);
		WriteIntegerValue(value);
	}

	public override void WriteValue(decimal value)
	{
		InternalWriteValue(JsonToken.Float);
		WriteValueInternal(JsonConvert.ToString(value), JsonToken.Float);
	}

	public override void WriteValue(DateTime value)
	{
		InternalWriteValue(JsonToken.Date);
		value = DateTimeUtils.EnsureDateTime(value, base.DateTimeZoneHandling);
		if (string.IsNullOrEmpty(base.DateFormatString))
		{
			EnsureWriteBuffer();
			int start = 0;
			_writeBuffer[start++] = _quoteChar;
			start = DateTimeUtils.WriteDateTimeString(_writeBuffer, start, value, null, value.Kind, base.DateFormatHandling);
			_writeBuffer[start++] = _quoteChar;
			_writer.Write(_writeBuffer, 0, start);
		}
		else
		{
			_writer.Write(_quoteChar);
			_writer.Write(value.ToString(base.DateFormatString, base.Culture));
			_writer.Write(_quoteChar);
		}
	}

	public override void WriteValue(byte[] value)
	{
		if (value == null)
		{
			WriteNull();
			return;
		}
		InternalWriteValue(JsonToken.Bytes);
		_writer.Write(_quoteChar);
		Base64Encoder.Encode(value, 0, value.Length);
		Base64Encoder.Flush();
		_writer.Write(_quoteChar);
	}

	public override void WriteValue(DateTimeOffset value)
	{
		InternalWriteValue(JsonToken.Date);
		if (string.IsNullOrEmpty(base.DateFormatString))
		{
			EnsureWriteBuffer();
			int start = 0;
			_writeBuffer[start++] = _quoteChar;
			start = DateTimeUtils.WriteDateTimeString(_writeBuffer, start, (base.DateFormatHandling == DateFormatHandling.IsoDateFormat) ? value.DateTime : value.UtcDateTime, value.Offset, DateTimeKind.Local, base.DateFormatHandling);
			_writeBuffer[start++] = _quoteChar;
			_writer.Write(_writeBuffer, 0, start);
		}
		else
		{
			_writer.Write(_quoteChar);
			_writer.Write(value.ToString(base.DateFormatString, base.Culture));
			_writer.Write(_quoteChar);
		}
	}

	public override void WriteValue(Guid value)
	{
		InternalWriteValue(JsonToken.String);
		string text = null;
		text = value.ToString("D", CultureInfo.InvariantCulture);
		_writer.Write(_quoteChar);
		_writer.Write(text);
		_writer.Write(_quoteChar);
	}

	public override void WriteValue(TimeSpan value)
	{
		InternalWriteValue(JsonToken.String);
		string value2 = value.ToString();
		_writer.Write(_quoteChar);
		_writer.Write(value2);
		_writer.Write(_quoteChar);
	}

	public override void WriteValue(Uri value)
	{
		if (value == null)
		{
			WriteNull();
			return;
		}
		InternalWriteValue(JsonToken.String);
		WriteEscapedString(value.OriginalString, quote: true);
	}

	public override void WriteComment(string text)
	{
		InternalWriteComment();
		_writer.Write("/*");
		_writer.Write(text);
		_writer.Write("*/");
	}

	public override void WriteWhitespace(string ws)
	{
		InternalWriteWhitespace(ws);
		_writer.Write(ws);
	}

	private void EnsureWriteBuffer()
	{
		if (_writeBuffer == null)
		{
			_writeBuffer = BufferUtils.RentBuffer(_arrayPool, 35);
		}
	}

	private void WriteIntegerValue(long value)
	{
		if (value >= 0 && value <= 9)
		{
			_writer.Write((char)(48 + value));
			return;
		}
		ulong uvalue = (ulong)((value < 0) ? (-value) : value);
		if (value < 0)
		{
			_writer.Write('-');
		}
		WriteIntegerValue(uvalue);
	}

	private void WriteIntegerValue(ulong uvalue)
	{
		if (uvalue <= 9)
		{
			_writer.Write((char)(48 + uvalue));
			return;
		}
		EnsureWriteBuffer();
		int num = MathUtils.IntLength(uvalue);
		int num2 = 0;
		do
		{
			_writeBuffer[num - ++num2] = (char)(48 + uvalue % 10);
			uvalue /= 10;
		}
		while (uvalue != 0L);
		_writer.Write(_writeBuffer, 0, num2);
	}
}


using System;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Serializable]
[Preserve]
public class JsonWriterException : JsonException
{
	public string Path { get; private set; }

	public JsonWriterException()
	{
	}

	public JsonWriterException(string message)
		: base(message)
	{
	}

	public JsonWriterException(string message, Exception innerException)
		: base(message, innerException)
	{
	}

	public JsonWriterException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}

	internal JsonWriterException(string message, Exception innerException, string path)
		: base(message, innerException)
	{
		Path = path;
	}

	internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex)
	{
		return Create(writer.ContainerPath, message, ex);
	}

	internal static JsonWriterException Create(string path, string message, Exception ex)
	{
		message = JsonPosition.FormatMessage(null, path, message);
		return new JsonWriterException(message, ex, path);
	}
}


using System;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Serializable]
[Preserve]
public class JsonReaderException : JsonException
{
	public int LineNumber { get; private set; }

	public int LinePosition { get; private set; }

	public string Path { get; private set; }

	public JsonReaderException()
	{
	}

	public JsonReaderException(string message)
		: base(message)
	{
	}

	public JsonReaderException(string message, Exception innerException)
		: base(message, innerException)
	{
	}

	public JsonReaderException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}

	internal JsonReaderException(string message, Exception innerException, string path, int lineNumber, int linePosition)
		: base(message, innerException)
	{
		Path = path;
		LineNumber = lineNumber;
		LinePosition = linePosition;
	}

	internal static JsonReaderException Create(JsonReader reader, string message)
	{
		return Create(reader, message, null);
	}

	internal static JsonReaderException Create(JsonReader reader, string message, Exception ex)
	{
		return Create(reader as IJsonLineInfo, reader.Path, message, ex);
	}

	internal static JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex)
	{
		message = JsonPosition.FormatMessage(lineInfo, path, message);
		int lineNumber;
		int linePosition;
		if (lineInfo != null && lineInfo.HasLineInfo())
		{
			lineNumber = lineInfo.LineNumber;
			linePosition = lineInfo.LinePosition;
		}
		else
		{
			lineNumber = 0;
			linePosition = 0;
		}
		return new JsonReaderException(message, ex, path, lineNumber, linePosition);
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Preserve]
public abstract class JsonConverter
{
	public virtual bool CanRead => true;

	public virtual bool CanWrite => true;

	public abstract void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);

	public abstract object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);

	public abstract bool CanConvert(Type objectType);
}


using System.Collections.ObjectModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Preserve]
public class JsonConverterCollection : Collection<JsonConverter>
{
}


using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public abstract class JsonReader : IDisposable
{
	protected internal enum State
	{
		Start,
		Complete,
		Property,
		ObjectStart,
		Object,
		ArrayStart,
		Array,
		Closed,
		PostValue,
		ConstructorStart,
		Constructor,
		Error,
		Finished
	}

	private JsonToken _tokenType;

	private object _value;

	internal char _quoteChar;

	internal State _currentState;

	private JsonPosition _currentPosition;

	private CultureInfo _culture;

	private DateTimeZoneHandling _dateTimeZoneHandling;

	private int? _maxDepth;

	private bool _hasExceededMaxDepth;

	internal DateParseHandling _dateParseHandling;

	internal FloatParseHandling _floatParseHandling;

	private string _dateFormatString;

	private List<JsonPosition> _stack;

	protected State CurrentState => _currentState;

	public bool CloseInput { get; set; }

	public bool SupportMultipleContent { get; set; }

	public virtual char QuoteChar
	{
		get
		{
			return _quoteChar;
		}
		protected internal set
		{
			_quoteChar = value;
		}
	}

	public DateTimeZoneHandling DateTimeZoneHandling
	{
		get
		{
			return _dateTimeZoneHandling;
		}
		set
		{
			if (value < DateTimeZoneHandling.Local || value > DateTimeZoneHandling.RoundtripKind)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_dateTimeZoneHandling = value;
		}
	}

	public DateParseHandling DateParseHandling
	{
		get
		{
			return _dateParseHandling;
		}
		set
		{
			if (value < DateParseHandling.None || value > DateParseHandling.DateTimeOffset)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_dateParseHandling = value;
		}
	}

	public FloatParseHandling FloatParseHandling
	{
		get
		{
			return _floatParseHandling;
		}
		set
		{
			if (value < FloatParseHandling.Double || value > FloatParseHandling.Decimal)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_floatParseHandling = value;
		}
	}

	public string DateFormatString
	{
		get
		{
			return _dateFormatString;
		}
		set
		{
			_dateFormatString = value;
		}
	}

	public int? MaxDepth
	{
		get
		{
			return _maxDepth;
		}
		set
		{
			if (value <= 0)
			{
				throw new ArgumentException("Value must be positive.", "value");
			}
			_maxDepth = value;
		}
	}

	public virtual JsonToken TokenType => _tokenType;

	public virtual object Value => _value;

	public virtual Type ValueType
	{
		get
		{
			if (_value == null)
			{
				return null;
			}
			return _value.GetType();
		}
	}

	public virtual int Depth
	{
		get
		{
			int num = ((_stack != null) ? _stack.Count : 0);
			if (JsonTokenUtils.IsStartToken(TokenType) || _currentPosition.Type == JsonContainerType.None)
			{
				return num;
			}
			return num + 1;
		}
	}

	public virtual string Path
	{
		get
		{
			if (_currentPosition.Type == JsonContainerType.None)
			{
				return string.Empty;
			}
			JsonPosition? currentPosition = ((_currentState != State.ArrayStart && _currentState != State.ConstructorStart && _currentState != State.ObjectStart) ? new JsonPosition?(_currentPosition) : ((JsonPosition?)null));
			return JsonPosition.BuildPath(_stack, currentPosition);
		}
	}

	public CultureInfo Culture
	{
		get
		{
			return _culture ?? CultureInfo.InvariantCulture;
		}
		set
		{
			_culture = value;
		}
	}

	internal JsonPosition GetPosition(int depth)
	{
		if (_stack != null && depth < _stack.Count)
		{
			return _stack[depth];
		}
		return _currentPosition;
	}

	protected JsonReader()
	{
		_currentState = State.Start;
		_dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
		_dateParseHandling = DateParseHandling.DateTime;
		_floatParseHandling = FloatParseHandling.Double;
		CloseInput = true;
	}

	private void Push(JsonContainerType value)
	{
		UpdateScopeWithFinishedValue();
		if (_currentPosition.Type == JsonContainerType.None)
		{
			_currentPosition = new JsonPosition(value);
			return;
		}
		if (_stack == null)
		{
			_stack = new List<JsonPosition>();
		}
		_stack.Add(_currentPosition);
		_currentPosition = new JsonPosition(value);
		if (_maxDepth.HasValue)
		{
			int num = Depth + 1;
			int? maxDepth = _maxDepth;
			if (num > maxDepth.GetValueOrDefault() && maxDepth.HasValue && !_hasExceededMaxDepth)
			{
				_hasExceededMaxDepth = true;
				throw JsonReaderException.Create(this, "The reader's MaxDepth of {0} has been exceeded.".FormatWith(CultureInfo.InvariantCulture, _maxDepth));
			}
		}
	}

	private JsonContainerType Pop()
	{
		JsonPosition currentPosition;
		if (_stack != null && _stack.Count > 0)
		{
			currentPosition = _currentPosition;
			_currentPosition = _stack[_stack.Count - 1];
			_stack.RemoveAt(_stack.Count - 1);
		}
		else
		{
			currentPosition = _currentPosition;
			_currentPosition = default(JsonPosition);
		}
		if (_maxDepth.HasValue && Depth <= _maxDepth)
		{
			_hasExceededMaxDepth = false;
		}
		return currentPosition.Type;
	}

	private JsonContainerType Peek()
	{
		return _currentPosition.Type;
	}

	public abstract bool Read();

	public virtual int? ReadAsInt32()
	{
		JsonToken contentToken = GetContentToken();
		switch (contentToken)
		{
		case JsonToken.None:
		case JsonToken.Null:
		case JsonToken.EndArray:
			return null;
		case JsonToken.Integer:
		case JsonToken.Float:
			if (!(Value is int))
			{
				SetToken(JsonToken.Integer, Convert.ToInt32(Value, CultureInfo.InvariantCulture), updateIndex: false);
			}
			return (int)Value;
		case JsonToken.String:
		{
			string s = (string)Value;
			return ReadInt32String(s);
		}
		default:
			throw JsonReaderException.Create(this, "Error reading integer. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
		}
	}

	internal int? ReadInt32String(string s)
	{
		if (string.IsNullOrEmpty(s))
		{
			SetToken(JsonToken.Null, null, updateIndex: false);
			return null;
		}
		if (int.TryParse(s, NumberStyles.Integer, Culture, out var result))
		{
			SetToken(JsonToken.Integer, result, updateIndex: false);
			return result;
		}
		SetToken(JsonToken.String, s, updateIndex: false);
		throw JsonReaderException.Create(this, "Could not convert string to integer: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
	}

	public virtual string ReadAsString()
	{
		JsonToken contentToken = GetContentToken();
		switch (contentToken)
		{
		case JsonToken.None:
		case JsonToken.Null:
		case JsonToken.EndArray:
			return null;
		case JsonToken.String:
			return (string)Value;
		default:
			if (JsonTokenUtils.IsPrimitiveToken(contentToken) && Value != null)
			{
				string text = ((Value is IFormattable) ? ((IFormattable)Value).ToString(null, Culture) : ((!(Value is Uri)) ? Value.ToString() : ((Uri)Value).OriginalString));
				SetToken(JsonToken.String, text, updateIndex: false);
				return text;
			}
			throw JsonReaderException.Create(this, "Error reading string. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
		}
	}

	public virtual byte[] ReadAsBytes()
	{
		JsonToken contentToken = GetContentToken();
		if (contentToken == JsonToken.None)
		{
			return null;
		}
		if (TokenType == JsonToken.StartObject)
		{
			ReadIntoWrappedTypeObject();
			byte[] array = ReadAsBytes();
			ReaderReadAndAssert();
			if (TokenType != JsonToken.EndObject)
			{
				throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
			}
			SetToken(JsonToken.Bytes, array, updateIndex: false);
			return array;
		}
		switch (contentToken)
		{
		case JsonToken.String:
		{
			string text = (string)Value;
			Guid g;
			byte[] array3 = ((text.Length == 0) ? new byte[0] : ((!ConvertUtils.TryConvertGuid(text, out g)) ? Convert.FromBase64String(text) : g.ToByteArray()));
			SetToken(JsonToken.Bytes, array3, updateIndex: false);
			return array3;
		}
		case JsonToken.Null:
		case JsonToken.EndArray:
			return null;
		case JsonToken.Bytes:
			if ((object)ValueType == typeof(Guid))
			{
				byte[] array2 = ((Guid)Value).ToByteArray();
				SetToken(JsonToken.Bytes, array2, updateIndex: false);
				return array2;
			}
			return (byte[])Value;
		case JsonToken.StartArray:
			return ReadArrayIntoByteArray();
		default:
			throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
		}
	}

	internal byte[] ReadArrayIntoByteArray()
	{
		List<byte> list = new List<byte>();
		while (true)
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
				throw JsonReaderException.Create(this, "Unexpected end when reading bytes.");
			case JsonToken.Integer:
				break;
			case JsonToken.EndArray:
			{
				byte[] array = list.ToArray();
				SetToken(JsonToken.Bytes, array, updateIndex: false);
				return array;
			}
			default:
				throw JsonReaderException.Create(this, "Unexpected token when reading bytes: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
			list.Add(Convert.ToByte(Value, CultureInfo.InvariantCulture));
		}
	}

	public virtual double? ReadAsDouble()
	{
		JsonToken contentToken = GetContentToken();
		switch (contentToken)
		{
		case JsonToken.None:
		case JsonToken.Null:
		case JsonToken.EndArray:
			return null;
		case JsonToken.Integer:
		case JsonToken.Float:
			if (!(Value is double))
			{
				double num = Convert.ToDouble(Value, CultureInfo.InvariantCulture);
				SetToken(JsonToken.Float, num, updateIndex: false);
			}
			return (double)Value;
		case JsonToken.String:
			return ReadDoubleString((string)Value);
		default:
			throw JsonReaderException.Create(this, "Error reading double. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
		}
	}

	internal double? ReadDoubleString(string s)
	{
		if (string.IsNullOrEmpty(s))
		{
			SetToken(JsonToken.Null, null, updateIndex: false);
			return null;
		}
		if (double.TryParse(s, NumberStyles.Float | NumberStyles.AllowThousands, Culture, out var result))
		{
			SetToken(JsonToken.Float, result, updateIndex: false);
			return result;
		}
		SetToken(JsonToken.String, s, updateIndex: false);
		throw JsonReaderException.Create(this, "Could not convert string to double: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
	}

	public virtual bool? ReadAsBoolean()
	{
		JsonToken contentToken = GetContentToken();
		switch (contentToken)
		{
		case JsonToken.None:
		case JsonToken.Null:
		case JsonToken.EndArray:
			return null;
		case JsonToken.Integer:
		case JsonToken.Float:
		{
			bool flag = Convert.ToBoolean(Value, CultureInfo.InvariantCulture);
			SetToken(JsonToken.Boolean, flag, updateIndex: false);
			return flag;
		}
		case JsonToken.String:
			return ReadBooleanString((string)Value);
		case JsonToken.Boolean:
			return (bool)Value;
		default:
			throw JsonReaderException.Create(this, "Error reading boolean. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
		}
	}

	internal bool? ReadBooleanString(string s)
	{
		if (string.IsNullOrEmpty(s))
		{
			SetToken(JsonToken.Null, null, updateIndex: false);
			return null;
		}
		if (bool.TryParse(s, out var result))
		{
			SetToken(JsonToken.Boolean, result, updateIndex: false);
			return result;
		}
		SetToken(JsonToken.String, s, updateIndex: false);
		throw JsonReaderException.Create(this, "Could not convert string to boolean: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
	}

	public virtual decimal? ReadAsDecimal()
	{
		JsonToken contentToken = GetContentToken();
		switch (contentToken)
		{
		case JsonToken.None:
		case JsonToken.Null:
		case JsonToken.EndArray:
			return null;
		case JsonToken.Integer:
		case JsonToken.Float:
			if (!(Value is decimal))
			{
				SetToken(JsonToken.Float, Convert.ToDecimal(Value, CultureInfo.InvariantCulture), updateIndex: false);
			}
			return (decimal)Value;
		case JsonToken.String:
			return ReadDecimalString((string)Value);
		default:
			throw JsonReaderException.Create(this, "Error reading decimal. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
		}
	}

	internal decimal? ReadDecimalString(string s)
	{
		if (string.IsNullOrEmpty(s))
		{
			SetToken(JsonToken.Null, null, updateIndex: false);
			return null;
		}
		if (decimal.TryParse(s, NumberStyles.Number, Culture, out var result))
		{
			SetToken(JsonToken.Float, result, updateIndex: false);
			return result;
		}
		SetToken(JsonToken.String, s, updateIndex: false);
		throw JsonReaderException.Create(this, "Could not convert string to decimal: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
	}

	public virtual DateTime? ReadAsDateTime()
	{
		switch (GetContentToken())
		{
		case JsonToken.None:
		case JsonToken.Null:
		case JsonToken.EndArray:
			return null;
		case JsonToken.Date:
			if (Value is DateTimeOffset)
			{
				SetToken(JsonToken.Date, ((DateTimeOffset)Value).DateTime, updateIndex: false);
			}
			return (DateTime)Value;
		case JsonToken.String:
		{
			string s = (string)Value;
			return ReadDateTimeString(s);
		}
		default:
			throw JsonReaderException.Create(this, "Error reading date. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
		}
	}

	internal DateTime? ReadDateTimeString(string s)
	{
		if (string.IsNullOrEmpty(s))
		{
			SetToken(JsonToken.Null, null, updateIndex: false);
			return null;
		}
		if (DateTimeUtils.TryParseDateTime(s, DateTimeZoneHandling, _dateFormatString, Culture, out var dt))
		{
			dt = DateTimeUtils.EnsureDateTime(dt, DateTimeZoneHandling);
			SetToken(JsonToken.Date, dt, updateIndex: false);
			return dt;
		}
		if (DateTime.TryParse(s, Culture, DateTimeStyles.RoundtripKind, out dt))
		{
			dt = DateTimeUtils.EnsureDateTime(dt, DateTimeZoneHandling);
			SetToken(JsonToken.Date, dt, updateIndex: false);
			return dt;
		}
		throw JsonReaderException.Create(this, "Could not convert string to DateTime: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
	}

	public virtual DateTimeOffset? ReadAsDateTimeOffset()
	{
		JsonToken contentToken = GetContentToken();
		switch (contentToken)
		{
		case JsonToken.None:
		case JsonToken.Null:
		case JsonToken.EndArray:
			return null;
		case JsonToken.Date:
			if (Value is DateTime)
			{
				SetToken(JsonToken.Date, new DateTimeOffset((DateTime)Value), updateIndex: false);
			}
			return (DateTimeOffset)Value;
		case JsonToken.String:
		{
			string s = (string)Value;
			return ReadDateTimeOffsetString(s);
		}
		default:
			throw JsonReaderException.Create(this, "Error reading date. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
		}
	}

	internal DateTimeOffset? ReadDateTimeOffsetString(string s)
	{
		if (string.IsNullOrEmpty(s))
		{
			SetToken(JsonToken.Null, null, updateIndex: false);
			return null;
		}
		if (DateTimeUtils.TryParseDateTimeOffset(s, _dateFormatString, Culture, out var dt))
		{
			SetToken(JsonToken.Date, dt, updateIndex: false);
			return dt;
		}
		if (DateTimeOffset.TryParse(s, Culture, DateTimeStyles.RoundtripKind, out dt))
		{
			SetToken(JsonToken.Date, dt, updateIndex: false);
			return dt;
		}
		SetToken(JsonToken.String, s, updateIndex: false);
		throw JsonReaderException.Create(this, "Could not convert string to DateTimeOffset: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
	}

	internal void ReaderReadAndAssert()
	{
		if (!Read())
		{
			throw CreateUnexpectedEndException();
		}
	}

	internal JsonReaderException CreateUnexpectedEndException()
	{
		return JsonReaderException.Create(this, "Unexpected end when reading JSON.");
	}

	internal void ReadIntoWrappedTypeObject()
	{
		ReaderReadAndAssert();
		if (Value.ToString() == "$type")
		{
			ReaderReadAndAssert();
			if (Value != null && Value.ToString().StartsWith("System.Byte[]", StringComparison.Ordinal))
			{
				ReaderReadAndAssert();
				if (Value.ToString() == "$value")
				{
					return;
				}
			}
		}
		throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, JsonToken.StartObject));
	}

	public void Skip()
	{
		if (TokenType == JsonToken.PropertyName)
		{
			Read();
		}
		if (JsonTokenUtils.IsStartToken(TokenType))
		{
			int depth = Depth;
			while (Read() && depth < Depth)
			{
			}
		}
	}

	protected void SetToken(JsonToken newToken)
	{
		SetToken(newToken, null, updateIndex: true);
	}

	protected void SetToken(JsonToken newToken, object value)
	{
		SetToken(newToken, value, updateIndex: true);
	}

	internal void SetToken(JsonToken newToken, object value, bool updateIndex)
	{
		_tokenType = newToken;
		_value = value;
		switch (newToken)
		{
		case JsonToken.StartObject:
			_currentState = State.ObjectStart;
			Push(JsonContainerType.Object);
			break;
		case JsonToken.StartArray:
			_currentState = State.ArrayStart;
			Push(JsonContainerType.Array);
			break;
		case JsonToken.StartConstructor:
			_currentState = State.ConstructorStart;
			Push(JsonContainerType.Constructor);
			break;
		case JsonToken.EndObject:
			ValidateEnd(JsonToken.EndObject);
			break;
		case JsonToken.EndArray:
			ValidateEnd(JsonToken.EndArray);
			break;
		case JsonToken.EndConstructor:
			ValidateEnd(JsonToken.EndConstructor);
			break;
		case JsonToken.PropertyName:
			_currentState = State.Property;
			_currentPosition.PropertyName = (string)value;
			break;
		case JsonToken.Raw:
		case JsonToken.Integer:
		case JsonToken.Float:
		case JsonToken.String:
		case JsonToken.Boolean:
		case JsonToken.Null:
		case JsonToken.Undefined:
		case JsonToken.Date:
		case JsonToken.Bytes:
			SetPostValueState(updateIndex);
			break;
		case JsonToken.Comment:
			break;
		}
	}

	internal void SetPostValueState(bool updateIndex)
	{
		if (Peek() != 0)
		{
			_currentState = State.PostValue;
		}
		else
		{
			SetFinished();
		}
		if (updateIndex)
		{
			UpdateScopeWithFinishedValue();
		}
	}

	private void UpdateScopeWithFinishedValue()
	{
		if (_currentPosition.HasIndex)
		{
			_currentPosition.Position++;
		}
	}

	private void ValidateEnd(JsonToken endToken)
	{
		JsonContainerType jsonContainerType = Pop();
		if (GetTypeForCloseToken(endToken) != jsonContainerType)
		{
			throw JsonReaderException.Create(this, "JsonToken {0} is not valid for closing JsonType {1}.".FormatWith(CultureInfo.InvariantCulture, endToken, jsonContainerType));
		}
		if (Peek() != 0)
		{
			_currentState = State.PostValue;
		}
		else
		{
			SetFinished();
		}
	}

	protected void SetStateBasedOnCurrent()
	{
		JsonContainerType jsonContainerType = Peek();
		switch (jsonContainerType)
		{
		case JsonContainerType.Object:
			_currentState = State.Object;
			break;
		case JsonContainerType.Array:
			_currentState = State.Array;
			break;
		case JsonContainerType.Constructor:
			_currentState = State.Constructor;
			break;
		case JsonContainerType.None:
			SetFinished();
			break;
		default:
			throw JsonReaderException.Create(this, "While setting the reader state back to current object an unexpected JsonType was encountered: {0}".FormatWith(CultureInfo.InvariantCulture, jsonContainerType));
		}
	}

	private void SetFinished()
	{
		if (SupportMultipleContent)
		{
			_currentState = State.Start;
		}
		else
		{
			_currentState = State.Finished;
		}
	}

	private JsonContainerType GetTypeForCloseToken(JsonToken token)
	{
		return token switch
		{
			JsonToken.EndObject => JsonContainerType.Object, 
			JsonToken.EndArray => JsonContainerType.Array, 
			JsonToken.EndConstructor => JsonContainerType.Constructor, 
			_ => throw JsonReaderException.Create(this, "Not a valid close JsonToken: {0}".FormatWith(CultureInfo.InvariantCulture, token)), 
		};
	}

	void IDisposable.Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	protected virtual void Dispose(bool disposing)
	{
		if (_currentState != State.Closed && disposing)
		{
			Close();
		}
	}

	public virtual void Close()
	{
		_currentState = State.Closed;
		_tokenType = JsonToken.None;
		_value = null;
	}

	internal void ReadAndAssert()
	{
		if (!Read())
		{
			throw JsonSerializationException.Create(this, "Unexpected end when reading JSON.");
		}
	}

	internal bool ReadAndMoveToContent()
	{
		if (Read())
		{
			return MoveToContent();
		}
		return false;
	}

	internal bool MoveToContent()
	{
		JsonToken tokenType = TokenType;
		while (tokenType == JsonToken.None || tokenType == JsonToken.Comment)
		{
			if (!Read())
			{
				return false;
			}
			tokenType = TokenType;
		}
		return true;
	}

	private JsonToken GetContentToken()
	{
		JsonToken tokenType;
		do
		{
			if (!Read())
			{
				SetToken(JsonToken.None);
				return JsonToken.None;
			}
			tokenType = TokenType;
		}
		while (tokenType == JsonToken.Comment);
		return tokenType;
	}
}


protected internal enum State
{
	Start,
	Complete,
	Property,
	ObjectStart,
	Object,
	ArrayStart,
	Array,
	Closed,
	PostValue,
	ConstructorStart,
	Constructor,
	Error,
	Finished
}


using System;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public static class JsonConvert
{
	public static readonly string True;

	public static readonly string False;

	public static readonly string Null;

	public static readonly string Undefined;

	public static readonly string PositiveInfinity;

	public static readonly string NegativeInfinity;

	public static readonly string NaN;

	private static readonly JsonSerializerSettings InitialSerializerSettings;

	public static Func<JsonSerializerSettings> DefaultSettings { get; set; }

	static JsonConvert()
	{
		True = "true";
		False = "false";
		Null = "null";
		Undefined = "undefined";
		PositiveInfinity = "Infinity";
		NegativeInfinity = "-Infinity";
		NaN = "NaN";
		InitialSerializerSettings = new JsonSerializerSettings();
		DefaultSettings = GetDefaultSettings;
	}

	internal static JsonSerializerSettings GetDefaultSettings()
	{
		return InitialSerializerSettings;
	}

	public static string ToString(DateTime value)
	{
		return ToString(value, DateFormatHandling.IsoDateFormat, DateTimeZoneHandling.RoundtripKind);
	}

	public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling)
	{
		DateTime value2 = DateTimeUtils.EnsureDateTime(value, timeZoneHandling);
		using StringWriter stringWriter = StringUtils.CreateStringWriter(64);
		stringWriter.Write('"');
		DateTimeUtils.WriteDateTimeString(stringWriter, value2, format, null, CultureInfo.InvariantCulture);
		stringWriter.Write('"');
		return stringWriter.ToString();
	}

	public static string ToString(DateTimeOffset value)
	{
		return ToString(value, DateFormatHandling.IsoDateFormat);
	}

	public static string ToString(DateTimeOffset value, DateFormatHandling format)
	{
		using StringWriter stringWriter = StringUtils.CreateStringWriter(64);
		stringWriter.Write('"');
		DateTimeUtils.WriteDateTimeOffsetString(stringWriter, value, format, null, CultureInfo.InvariantCulture);
		stringWriter.Write('"');
		return stringWriter.ToString();
	}

	public static string ToString(bool value)
	{
		if (!value)
		{
			return False;
		}
		return True;
	}

	public static string ToString(char value)
	{
		return ToString(char.ToString(value));
	}

	public static string ToString(Enum value)
	{
		return value.ToString("D");
	}

	public static string ToString(int value)
	{
		return value.ToString(null, CultureInfo.InvariantCulture);
	}

	public static string ToString(short value)
	{
		return value.ToString(null, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static string ToString(ushort value)
	{
		return value.ToString(null, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static string ToString(uint value)
	{
		return value.ToString(null, CultureInfo.InvariantCulture);
	}

	public static string ToString(long value)
	{
		return value.ToString(null, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static string ToString(ulong value)
	{
		return value.ToString(null, CultureInfo.InvariantCulture);
	}

	public static string ToString(float value)
	{
		return EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture));
	}

	internal static string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
	{
		return EnsureFloatFormat(value, EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture)), floatFormatHandling, quoteChar, nullable);
	}

	private static string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
	{
		if (floatFormatHandling == FloatFormatHandling.Symbol || (!double.IsInfinity(value) && !double.IsNaN(value)))
		{
			return text;
		}
		if (floatFormatHandling == FloatFormatHandling.DefaultValue)
		{
			if (nullable)
			{
				return Null;
			}
			return "0.0";
		}
		return quoteChar + text + quoteChar;
	}

	public static string ToString(double value)
	{
		return EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture));
	}

	internal static string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
	{
		return EnsureFloatFormat(value, EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture)), floatFormatHandling, quoteChar, nullable);
	}

	private static string EnsureDecimalPlace(double value, string text)
	{
		if (double.IsNaN(value) || double.IsInfinity(value) || text.IndexOf('.') != -1 || text.IndexOf('E') != -1 || text.IndexOf('e') != -1)
		{
			return text;
		}
		return text + ".0";
	}

	private static string EnsureDecimalPlace(string text)
	{
		if (text.IndexOf('.') != -1)
		{
			return text;
		}
		return text + ".0";
	}

	public static string ToString(byte value)
	{
		return value.ToString(null, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static string ToString(sbyte value)
	{
		return value.ToString(null, CultureInfo.InvariantCulture);
	}

	public static string ToString(decimal value)
	{
		return EnsureDecimalPlace(value.ToString(null, CultureInfo.InvariantCulture));
	}

	public static string ToString(Guid value)
	{
		return ToString(value, '"');
	}

	internal static string ToString(Guid value, char quoteChar)
	{
		string text = value.ToString("D", CultureInfo.InvariantCulture);
		string text2 = quoteChar.ToString(CultureInfo.InvariantCulture);
		return text2 + text + text2;
	}

	public static string ToString(TimeSpan value)
	{
		return ToString(value, '"');
	}

	internal static string ToString(TimeSpan value, char quoteChar)
	{
		return ToString(value.ToString(), quoteChar);
	}

	public static string ToString(Uri value)
	{
		if (value == null)
		{
			return Null;
		}
		return ToString(value, '"');
	}

	internal static string ToString(Uri value, char quoteChar)
	{
		return ToString(value.OriginalString, quoteChar);
	}

	public static string ToString(string value)
	{
		return ToString(value, '"');
	}

	public static string ToString(string value, char delimiter)
	{
		return ToString(value, delimiter, StringEscapeHandling.Default);
	}

	public static string ToString(string value, char delimiter, StringEscapeHandling stringEscapeHandling)
	{
		if (delimiter != '"' && delimiter != '\'')
		{
			throw new ArgumentException("Delimiter must be a single or double quote.", "delimiter");
		}
		return JavaScriptUtils.ToEscapedJavaScriptString(value, delimiter, appendDelimiters: true, stringEscapeHandling);
	}

	public static string ToString(object value)
	{
		if (value == null)
		{
			return Null;
		}
		return ConvertUtils.GetTypeCode(value.GetType()) switch
		{
			PrimitiveTypeCode.String => ToString((string)value), 
			PrimitiveTypeCode.Char => ToString((char)value), 
			PrimitiveTypeCode.Boolean => ToString((bool)value), 
			PrimitiveTypeCode.SByte => ToString((sbyte)value), 
			PrimitiveTypeCode.Int16 => ToString((short)value), 
			PrimitiveTypeCode.UInt16 => ToString((ushort)value), 
			PrimitiveTypeCode.Int32 => ToString((int)value), 
			PrimitiveTypeCode.Byte => ToString((byte)value), 
			PrimitiveTypeCode.UInt32 => ToString((uint)value), 
			PrimitiveTypeCode.Int64 => ToString((long)value), 
			PrimitiveTypeCode.UInt64 => ToString((ulong)value), 
			PrimitiveTypeCode.Single => ToString((float)value), 
			PrimitiveTypeCode.Double => ToString((double)value), 
			PrimitiveTypeCode.DateTime => ToString((DateTime)value), 
			PrimitiveTypeCode.Decimal => ToString((decimal)value), 
			PrimitiveTypeCode.DBNull => Null, 
			PrimitiveTypeCode.DateTimeOffset => ToString((DateTimeOffset)value), 
			PrimitiveTypeCode.Guid => ToString((Guid)value), 
			PrimitiveTypeCode.Uri => ToString((Uri)value), 
			PrimitiveTypeCode.TimeSpan => ToString((TimeSpan)value), 
			_ => throw new ArgumentException("Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith(CultureInfo.InvariantCulture, value.GetType())), 
		};
	}

	public static string SerializeObject(object value)
	{
		return SerializeObject(value, (Type)null, (JsonSerializerSettings)null);
	}

	public static string SerializeObject(object value, Formatting formatting)
	{
		return SerializeObject(value, formatting, (JsonSerializerSettings)null);
	}

	public static string SerializeObject(object value, params JsonConverter[] converters)
	{
		JsonSerializerSettings settings = ((converters != null && converters.Length != 0) ? new JsonSerializerSettings
		{
			Converters = converters
		} : null);
		return SerializeObject(value, null, settings);
	}

	public static string SerializeObject(object value, Formatting formatting, params JsonConverter[] converters)
	{
		JsonSerializerSettings settings = ((converters != null && converters.Length != 0) ? new JsonSerializerSettings
		{
			Converters = converters
		} : null);
		return SerializeObject(value, null, formatting, settings);
	}

	public static string SerializeObject(object value, JsonSerializerSettings settings)
	{
		return SerializeObject(value, null, settings);
	}

	public static string SerializeObject(object value, Type type, JsonSerializerSettings settings)
	{
		JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
		return SerializeObjectInternal(value, type, jsonSerializer);
	}

	public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings)
	{
		return SerializeObject(value, null, formatting, settings);
	}

	public static string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings)
	{
		JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
		jsonSerializer.Formatting = formatting;
		return SerializeObjectInternal(value, type, jsonSerializer);
	}

	private static string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer)
	{
		StringWriter stringWriter = new StringWriter(new StringBuilder(256), CultureInfo.InvariantCulture);
		using (JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter))
		{
			jsonTextWriter.Formatting = jsonSerializer.Formatting;
			jsonSerializer.Serialize(jsonTextWriter, value, type);
		}
		return stringWriter.ToString();
	}

	public static object DeserializeObject(string value)
	{
		return DeserializeObject(value, (Type)null, (JsonSerializerSettings)null);
	}

	public static object DeserializeObject(string value, JsonSerializerSettings settings)
	{
		return DeserializeObject(value, null, settings);
	}

	public static object DeserializeObject(string value, Type type)
	{
		return DeserializeObject(value, type, (JsonSerializerSettings)null);
	}

	public static T DeserializeObject<T>(string value)
	{
		return JsonConvert.DeserializeObject<T>(value, (JsonSerializerSettings)null);
	}

	public static T DeserializeAnonymousType<T>(string value, T anonymousTypeObject)
	{
		return DeserializeObject<T>(value);
	}

	public static T DeserializeAnonymousType<T>(string value, T anonymousTypeObject, JsonSerializerSettings settings)
	{
		return DeserializeObject<T>(value, settings);
	}

	public static T DeserializeObject<T>(string value, params JsonConverter[] converters)
	{
		return (T)DeserializeObject(value, typeof(T), converters);
	}

	public static T DeserializeObject<T>(string value, JsonSerializerSettings settings)
	{
		return (T)DeserializeObject(value, typeof(T), settings);
	}

	public static object DeserializeObject(string value, Type type, params JsonConverter[] converters)
	{
		JsonSerializerSettings settings = ((converters != null && converters.Length != 0) ? new JsonSerializerSettings
		{
			Converters = converters
		} : null);
		return DeserializeObject(value, type, settings);
	}

	public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings)
	{
		ValidationUtils.ArgumentNotNull(value, "value");
		JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
		if (!jsonSerializer.IsCheckAdditionalContentSet())
		{
			jsonSerializer.CheckAdditionalContent = true;
		}
		using JsonTextReader reader = new JsonTextReader(new StringReader(value));
		return jsonSerializer.Deserialize(reader, type);
	}

	public static void PopulateObject(string value, object target)
	{
		PopulateObject(value, target, null);
	}

	public static void PopulateObject(string value, object target, JsonSerializerSettings settings)
	{
		JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
		using JsonReader jsonReader = new JsonTextReader(new StringReader(value));
		jsonSerializer.Populate(jsonReader, target);
		if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
		{
			throw new JsonSerializationException("Additional text found in JSON string after finishing deserializing object.");
		}
	}

	public static string SerializeXmlNode(XmlNode node)
	{
		return SerializeXmlNode(node, Formatting.None);
	}

	public static string SerializeXmlNode(XmlNode node, Formatting formatting)
	{
		XmlNodeConverter xmlNodeConverter = new XmlNodeConverter();
		return SerializeObject(node, formatting, xmlNodeConverter);
	}

	public static string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject)
	{
		XmlNodeConverter xmlNodeConverter = new XmlNodeConverter
		{
			OmitRootObject = omitRootObject
		};
		return SerializeObject(node, formatting, xmlNodeConverter);
	}

	public static XmlDocument DeserializeXmlNode(string value)
	{
		return DeserializeXmlNode(value, null);
	}

	public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName)
	{
		return DeserializeXmlNode(value, deserializeRootElementName, writeArrayAttribute: false);
	}

	public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Expected O, but got Unknown
		XmlNodeConverter xmlNodeConverter = new XmlNodeConverter();
		xmlNodeConverter.DeserializeRootElementName = deserializeRootElementName;
		xmlNodeConverter.WriteArrayAttribute = writeArrayAttribute;
		return (XmlDocument)DeserializeObject(value, typeof(XmlDocument), xmlNodeConverter);
	}

	public static string SerializeXNode(XObject node)
	{
		return SerializeXNode(node, Formatting.None);
	}

	public static string SerializeXNode(XObject node, Formatting formatting)
	{
		return SerializeXNode(node, formatting, omitRootObject: false);
	}

	public static string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject)
	{
		XmlNodeConverter xmlNodeConverter = new XmlNodeConverter
		{
			OmitRootObject = omitRootObject
		};
		return SerializeObject(node, formatting, xmlNodeConverter);
	}

	public static XDocument DeserializeXNode(string value)
	{
		return DeserializeXNode(value, null);
	}

	public static XDocument DeserializeXNode(string value, string deserializeRootElementName)
	{
		return DeserializeXNode(value, deserializeRootElementName, writeArrayAttribute: false);
	}

	public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Expected O, but got Unknown
		XmlNodeConverter xmlNodeConverter = new XmlNodeConverter();
		xmlNodeConverter.DeserializeRootElementName = deserializeRootElementName;
		xmlNodeConverter.WriteArrayAttribute = writeArrayAttribute;
		return (XDocument)DeserializeObject(value, typeof(XDocument), xmlNodeConverter);
	}
}


using System;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Serializable]
[Preserve]
public class JsonSerializationException : JsonException
{
	public JsonSerializationException()
	{
	}

	public JsonSerializationException(string message)
		: base(message)
	{
	}

	public JsonSerializationException(string message, Exception innerException)
		: base(message, innerException)
	{
	}

	public JsonSerializationException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}

	internal static JsonSerializationException Create(JsonReader reader, string message)
	{
		return Create(reader, message, null);
	}

	internal static JsonSerializationException Create(JsonReader reader, string message, Exception ex)
	{
		return Create(reader as IJsonLineInfo, reader.Path, message, ex);
	}

	internal static JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex)
	{
		message = JsonPosition.FormatMessage(lineInfo, path, message);
		return new JsonSerializationException(message, ex);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JsonSerializer
{
	internal TypeNameHandling _typeNameHandling;

	internal FormatterAssemblyStyle _typeNameAssemblyFormat;

	internal PreserveReferencesHandling _preserveReferencesHandling;

	internal ReferenceLoopHandling _referenceLoopHandling;

	internal MissingMemberHandling _missingMemberHandling;

	internal ObjectCreationHandling _objectCreationHandling;

	internal NullValueHandling _nullValueHandling;

	internal DefaultValueHandling _defaultValueHandling;

	internal ConstructorHandling _constructorHandling;

	internal MetadataPropertyHandling _metadataPropertyHandling;

	internal JsonConverterCollection _converters;

	internal IContractResolver _contractResolver;

	internal ITraceWriter _traceWriter;

	internal IEqualityComparer _equalityComparer;

	internal SerializationBinder _binder;

	internal StreamingContext _context;

	private IReferenceResolver _referenceResolver;

	private Formatting? _formatting;

	private DateFormatHandling? _dateFormatHandling;

	private DateTimeZoneHandling? _dateTimeZoneHandling;

	private DateParseHandling? _dateParseHandling;

	private FloatFormatHandling? _floatFormatHandling;

	private FloatParseHandling? _floatParseHandling;

	private StringEscapeHandling? _stringEscapeHandling;

	private CultureInfo _culture;

	private int? _maxDepth;

	private bool _maxDepthSet;

	private bool? _checkAdditionalContent;

	private string _dateFormatString;

	private bool _dateFormatStringSet;

	public virtual IReferenceResolver ReferenceResolver
	{
		get
		{
			return GetReferenceResolver();
		}
		set
		{
			if (value == null)
			{
				throw new ArgumentNullException("value", "Reference resolver cannot be null.");
			}
			_referenceResolver = value;
		}
	}

	public virtual SerializationBinder Binder
	{
		get
		{
			return _binder;
		}
		set
		{
			if (value == null)
			{
				throw new ArgumentNullException("value", "Serialization binder cannot be null.");
			}
			_binder = value;
		}
	}

	public virtual ITraceWriter TraceWriter
	{
		get
		{
			return _traceWriter;
		}
		set
		{
			_traceWriter = value;
		}
	}

	public virtual IEqualityComparer EqualityComparer
	{
		get
		{
			return _equalityComparer;
		}
		set
		{
			_equalityComparer = value;
		}
	}

	public virtual TypeNameHandling TypeNameHandling
	{
		get
		{
			return _typeNameHandling;
		}
		set
		{
			if (value < TypeNameHandling.None || value > TypeNameHandling.Auto)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_typeNameHandling = value;
		}
	}

	public virtual FormatterAssemblyStyle TypeNameAssemblyFormat
	{
		get
		{
			return _typeNameAssemblyFormat;
		}
		set
		{
			if (value < FormatterAssemblyStyle.Simple || value > FormatterAssemblyStyle.Full)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_typeNameAssemblyFormat = value;
		}
	}

	public virtual PreserveReferencesHandling PreserveReferencesHandling
	{
		get
		{
			return _preserveReferencesHandling;
		}
		set
		{
			if (value < PreserveReferencesHandling.None || value > PreserveReferencesHandling.All)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_preserveReferencesHandling = value;
		}
	}

	public virtual ReferenceLoopHandling ReferenceLoopHandling
	{
		get
		{
			return _referenceLoopHandling;
		}
		set
		{
			if (value < ReferenceLoopHandling.Error || value > ReferenceLoopHandling.Serialize)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_referenceLoopHandling = value;
		}
	}

	public virtual MissingMemberHandling MissingMemberHandling
	{
		get
		{
			return _missingMemberHandling;
		}
		set
		{
			if (value < MissingMemberHandling.Ignore || value > MissingMemberHandling.Error)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_missingMemberHandling = value;
		}
	}

	public virtual NullValueHandling NullValueHandling
	{
		get
		{
			return _nullValueHandling;
		}
		set
		{
			if (value < NullValueHandling.Include || value > NullValueHandling.Ignore)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_nullValueHandling = value;
		}
	}

	public virtual DefaultValueHandling DefaultValueHandling
	{
		get
		{
			return _defaultValueHandling;
		}
		set
		{
			if (value < DefaultValueHandling.Include || value > DefaultValueHandling.IgnoreAndPopulate)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_defaultValueHandling = value;
		}
	}

	public virtual ObjectCreationHandling ObjectCreationHandling
	{
		get
		{
			return _objectCreationHandling;
		}
		set
		{
			if (value < ObjectCreationHandling.Auto || value > ObjectCreationHandling.Replace)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_objectCreationHandling = value;
		}
	}

	public virtual ConstructorHandling ConstructorHandling
	{
		get
		{
			return _constructorHandling;
		}
		set
		{
			if (value < ConstructorHandling.Default || value > ConstructorHandling.AllowNonPublicDefaultConstructor)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_constructorHandling = value;
		}
	}

	public virtual MetadataPropertyHandling MetadataPropertyHandling
	{
		get
		{
			return _metadataPropertyHandling;
		}
		set
		{
			if (value < MetadataPropertyHandling.Default || value > MetadataPropertyHandling.Ignore)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_metadataPropertyHandling = value;
		}
	}

	public virtual JsonConverterCollection Converters
	{
		get
		{
			if (_converters == null)
			{
				_converters = new JsonConverterCollection();
			}
			return _converters;
		}
	}

	public virtual IContractResolver ContractResolver
	{
		get
		{
			return _contractResolver;
		}
		set
		{
			_contractResolver = value ?? DefaultContractResolver.Instance;
		}
	}

	public virtual StreamingContext Context
	{
		get
		{
			return _context;
		}
		set
		{
			_context = value;
		}
	}

	public virtual Formatting Formatting
	{
		get
		{
			return _formatting ?? Formatting.None;
		}
		set
		{
			_formatting = value;
		}
	}

	public virtual DateFormatHandling DateFormatHandling
	{
		get
		{
			return _dateFormatHandling ?? DateFormatHandling.IsoDateFormat;
		}
		set
		{
			_dateFormatHandling = value;
		}
	}

	public virtual DateTimeZoneHandling DateTimeZoneHandling
	{
		get
		{
			return _dateTimeZoneHandling ?? DateTimeZoneHandling.RoundtripKind;
		}
		set
		{
			_dateTimeZoneHandling = value;
		}
	}

	public virtual DateParseHandling DateParseHandling
	{
		get
		{
			return _dateParseHandling ?? DateParseHandling.DateTime;
		}
		set
		{
			_dateParseHandling = value;
		}
	}

	public virtual FloatParseHandling FloatParseHandling
	{
		get
		{
			return _floatParseHandling ?? FloatParseHandling.Double;
		}
		set
		{
			_floatParseHandling = value;
		}
	}

	public virtual FloatFormatHandling FloatFormatHandling
	{
		get
		{
			return _floatFormatHandling ?? FloatFormatHandling.String;
		}
		set
		{
			_floatFormatHandling = value;
		}
	}

	public virtual StringEscapeHandling StringEscapeHandling
	{
		get
		{
			return _stringEscapeHandling ?? StringEscapeHandling.Default;
		}
		set
		{
			_stringEscapeHandling = value;
		}
	}

	public virtual string DateFormatString
	{
		get
		{
			return _dateFormatString ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";
		}
		set
		{
			_dateFormatString = value;
			_dateFormatStringSet = true;
		}
	}

	public virtual CultureInfo Culture
	{
		get
		{
			return _culture ?? JsonSerializerSettings.DefaultCulture;
		}
		set
		{
			_culture = value;
		}
	}

	public virtual int? MaxDepth
	{
		get
		{
			return _maxDepth;
		}
		set
		{
			if (value <= 0)
			{
				throw new ArgumentException("Value must be positive.", "value");
			}
			_maxDepth = value;
			_maxDepthSet = true;
		}
	}

	public virtual bool CheckAdditionalContent
	{
		get
		{
			return _checkAdditionalContent ?? false;
		}
		set
		{
			_checkAdditionalContent = value;
		}
	}

	public virtual event EventHandler<Newtonsoft.Json.Serialization.ErrorEventArgs> Error;

	internal bool IsCheckAdditionalContentSet()
	{
		return _checkAdditionalContent.HasValue;
	}

	public JsonSerializer()
	{
		_referenceLoopHandling = ReferenceLoopHandling.Error;
		_missingMemberHandling = MissingMemberHandling.Ignore;
		_nullValueHandling = NullValueHandling.Include;
		_defaultValueHandling = DefaultValueHandling.Include;
		_objectCreationHandling = ObjectCreationHandling.Auto;
		_preserveReferencesHandling = PreserveReferencesHandling.None;
		_constructorHandling = ConstructorHandling.Default;
		_typeNameHandling = TypeNameHandling.None;
		_metadataPropertyHandling = MetadataPropertyHandling.Default;
		_context = JsonSerializerSettings.DefaultContext;
		_binder = DefaultSerializationBinder.Instance;
		_culture = JsonSerializerSettings.DefaultCulture;
		_contractResolver = DefaultContractResolver.Instance;
	}

	public static JsonSerializer Create()
	{
		return new JsonSerializer();
	}

	public static JsonSerializer Create(JsonSerializerSettings settings)
	{
		JsonSerializer jsonSerializer = Create();
		if (settings != null)
		{
			ApplySerializerSettings(jsonSerializer, settings);
		}
		return jsonSerializer;
	}

	public static JsonSerializer CreateDefault()
	{
		return Create(JsonConvert.DefaultSettings?.Invoke());
	}

	public static JsonSerializer CreateDefault(JsonSerializerSettings settings)
	{
		JsonSerializer jsonSerializer = CreateDefault();
		if (settings != null)
		{
			ApplySerializerSettings(jsonSerializer, settings);
		}
		return jsonSerializer;
	}

	private static void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings)
	{
		if (!CollectionUtils.IsNullOrEmpty(settings.Converters))
		{
			for (int i = 0; i < settings.Converters.Count; i++)
			{
				serializer.Converters.Insert(i, settings.Converters[i]);
			}
		}
		if (settings._typeNameHandling.HasValue)
		{
			serializer.TypeNameHandling = settings.TypeNameHandling;
		}
		if (settings._metadataPropertyHandling.HasValue)
		{
			serializer.MetadataPropertyHandling = settings.MetadataPropertyHandling;
		}
		if (settings._typeNameAssemblyFormat.HasValue)
		{
			serializer.TypeNameAssemblyFormat = settings.TypeNameAssemblyFormat;
		}
		if (settings._preserveReferencesHandling.HasValue)
		{
			serializer.PreserveReferencesHandling = settings.PreserveReferencesHandling;
		}
		if (settings._referenceLoopHandling.HasValue)
		{
			serializer.ReferenceLoopHandling = settings.ReferenceLoopHandling;
		}
		if (settings._missingMemberHandling.HasValue)
		{
			serializer.MissingMemberHandling = settings.MissingMemberHandling;
		}
		if (settings._objectCreationHandling.HasValue)
		{
			serializer.ObjectCreationHandling = settings.ObjectCreationHandling;
		}
		if (settings._nullValueHandling.HasValue)
		{
			serializer.NullValueHandling = settings.NullValueHandling;
		}
		if (settings._defaultValueHandling.HasValue)
		{
			serializer.DefaultValueHandling = settings.DefaultValueHandling;
		}
		if (settings._constructorHandling.HasValue)
		{
			serializer.ConstructorHandling = settings.ConstructorHandling;
		}
		if (settings._context.HasValue)
		{
			serializer.Context = settings.Context;
		}
		if (settings._checkAdditionalContent.HasValue)
		{
			serializer._checkAdditionalContent = settings._checkAdditionalContent;
		}
		if (settings.Error != null)
		{
			serializer.Error += settings.Error;
		}
		if (settings.ContractResolver != null)
		{
			serializer.ContractResolver = settings.ContractResolver;
		}
		if (settings.ReferenceResolverProvider != null)
		{
			serializer.ReferenceResolver = settings.ReferenceResolverProvider();
		}
		if (settings.TraceWriter != null)
		{
			serializer.TraceWriter = settings.TraceWriter;
		}
		if (settings.EqualityComparer != null)
		{
			serializer.EqualityComparer = settings.EqualityComparer;
		}
		if (settings.Binder != null)
		{
			serializer.Binder = settings.Binder;
		}
		if (settings._formatting.HasValue)
		{
			serializer._formatting = settings._formatting;
		}
		if (settings._dateFormatHandling.HasValue)
		{
			serializer._dateFormatHandling = settings._dateFormatHandling;
		}
		if (settings._dateTimeZoneHandling.HasValue)
		{
			serializer._dateTimeZoneHandling = settings._dateTimeZoneHandling;
		}
		if (settings._dateParseHandling.HasValue)
		{
			serializer._dateParseHandling = settings._dateParseHandling;
		}
		if (settings._dateFormatStringSet)
		{
			serializer._dateFormatString = settings._dateFormatString;
			serializer._dateFormatStringSet = settings._dateFormatStringSet;
		}
		if (settings._floatFormatHandling.HasValue)
		{
			serializer._floatFormatHandling = settings._floatFormatHandling;
		}
		if (settings._floatParseHandling.HasValue)
		{
			serializer._floatParseHandling = settings._floatParseHandling;
		}
		if (settings._stringEscapeHandling.HasValue)
		{
			serializer._stringEscapeHandling = settings._stringEscapeHandling;
		}
		if (settings._culture != null)
		{
			serializer._culture = settings._culture;
		}
		if (settings._maxDepthSet)
		{
			serializer._maxDepth = settings._maxDepth;
			serializer._maxDepthSet = settings._maxDepthSet;
		}
	}

	public void Populate(TextReader reader, object target)
	{
		Populate(new JsonTextReader(reader), target);
	}

	public void Populate(JsonReader reader, object target)
	{
		PopulateInternal(reader, target);
	}

	internal virtual void PopulateInternal(JsonReader reader, object target)
	{
		ValidationUtils.ArgumentNotNull(reader, "reader");
		ValidationUtils.ArgumentNotNull(target, "target");
		SetupReader(reader, out var previousCulture, out var previousDateTimeZoneHandling, out var previousDateParseHandling, out var previousFloatParseHandling, out var previousMaxDepth, out var previousDateFormatString);
		TraceJsonReader traceJsonReader = ((TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose) ? new TraceJsonReader(reader) : null);
		new JsonSerializerInternalReader(this).Populate(traceJsonReader ?? reader, target);
		if (traceJsonReader != null)
		{
			TraceWriter.Trace(TraceLevel.Verbose, traceJsonReader.GetDeserializedJsonMessage(), null);
		}
		ResetReader(reader, previousCulture, previousDateTimeZoneHandling, previousDateParseHandling, previousFloatParseHandling, previousMaxDepth, previousDateFormatString);
	}

	public object Deserialize(JsonReader reader)
	{
		return Deserialize(reader, null);
	}

	public object Deserialize(TextReader reader, Type objectType)
	{
		return Deserialize(new JsonTextReader(reader), objectType);
	}

	public T Deserialize<T>(JsonReader reader)
	{
		return (T)Deserialize(reader, typeof(T));
	}

	public object Deserialize(JsonReader reader, Type objectType)
	{
		return DeserializeInternal(reader, objectType);
	}

	internal virtual object DeserializeInternal(JsonReader reader, Type objectType)
	{
		ValidationUtils.ArgumentNotNull(reader, "reader");
		SetupReader(reader, out var previousCulture, out var previousDateTimeZoneHandling, out var previousDateParseHandling, out var previousFloatParseHandling, out var previousMaxDepth, out var previousDateFormatString);
		TraceJsonReader traceJsonReader = ((TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose) ? new TraceJsonReader(reader) : null);
		object result = new JsonSerializerInternalReader(this).Deserialize(traceJsonReader ?? reader, objectType, CheckAdditionalContent);
		if (traceJsonReader != null)
		{
			TraceWriter.Trace(TraceLevel.Verbose, traceJsonReader.GetDeserializedJsonMessage(), null);
		}
		ResetReader(reader, previousCulture, previousDateTimeZoneHandling, previousDateParseHandling, previousFloatParseHandling, previousMaxDepth, previousDateFormatString);
		return result;
	}

	private void SetupReader(JsonReader reader, out CultureInfo previousCulture, out DateTimeZoneHandling? previousDateTimeZoneHandling, out DateParseHandling? previousDateParseHandling, out FloatParseHandling? previousFloatParseHandling, out int? previousMaxDepth, out string previousDateFormatString)
	{
		if (_culture != null && !_culture.Equals(reader.Culture))
		{
			previousCulture = reader.Culture;
			reader.Culture = _culture;
		}
		else
		{
			previousCulture = null;
		}
		if (_dateTimeZoneHandling.HasValue && reader.DateTimeZoneHandling != _dateTimeZoneHandling)
		{
			previousDateTimeZoneHandling = reader.DateTimeZoneHandling;
			reader.DateTimeZoneHandling = _dateTimeZoneHandling.GetValueOrDefault();
		}
		else
		{
			previousDateTimeZoneHandling = null;
		}
		if (_dateParseHandling.HasValue && reader.DateParseHandling != _dateParseHandling)
		{
			previousDateParseHandling = reader.DateParseHandling;
			reader.DateParseHandling = _dateParseHandling.GetValueOrDefault();
		}
		else
		{
			previousDateParseHandling = null;
		}
		if (_floatParseHandling.HasValue && reader.FloatParseHandling != _floatParseHandling)
		{
			previousFloatParseHandling = reader.FloatParseHandling;
			reader.FloatParseHandling = _floatParseHandling.GetValueOrDefault();
		}
		else
		{
			previousFloatParseHandling = null;
		}
		if (_maxDepthSet && reader.MaxDepth != _maxDepth)
		{
			previousMaxDepth = reader.MaxDepth;
			reader.MaxDepth = _maxDepth;
		}
		else
		{
			previousMaxDepth = null;
		}
		if (_dateFormatStringSet && reader.DateFormatString != _dateFormatString)
		{
			previousDateFormatString = reader.DateFormatString;
			reader.DateFormatString = _dateFormatString;
		}
		else
		{
			previousDateFormatString = null;
		}
		if (reader is JsonTextReader jsonTextReader && _contractResolver is DefaultContractResolver defaultContractResolver)
		{
			jsonTextReader.NameTable = defaultContractResolver.GetState().NameTable;
		}
	}

	private void ResetReader(JsonReader reader, CultureInfo previousCulture, DateTimeZoneHandling? previousDateTimeZoneHandling, DateParseHandling? previousDateParseHandling, FloatParseHandling? previousFloatParseHandling, int? previousMaxDepth, string previousDateFormatString)
	{
		if (previousCulture != null)
		{
			reader.Culture = previousCulture;
		}
		if (previousDateTimeZoneHandling.HasValue)
		{
			reader.DateTimeZoneHandling = previousDateTimeZoneHandling.GetValueOrDefault();
		}
		if (previousDateParseHandling.HasValue)
		{
			reader.DateParseHandling = previousDateParseHandling.GetValueOrDefault();
		}
		if (previousFloatParseHandling.HasValue)
		{
			reader.FloatParseHandling = previousFloatParseHandling.GetValueOrDefault();
		}
		if (_maxDepthSet)
		{
			reader.MaxDepth = previousMaxDepth;
		}
		if (_dateFormatStringSet)
		{
			reader.DateFormatString = previousDateFormatString;
		}
		if (reader is JsonTextReader jsonTextReader)
		{
			jsonTextReader.NameTable = null;
		}
	}

	public void Serialize(TextWriter textWriter, object value)
	{
		Serialize(new JsonTextWriter(textWriter), value);
	}

	public void Serialize(JsonWriter jsonWriter, object value, Type objectType)
	{
		SerializeInternal(jsonWriter, value, objectType);
	}

	public void Serialize(TextWriter textWriter, object value, Type objectType)
	{
		Serialize(new JsonTextWriter(textWriter), value, objectType);
	}

	public void Serialize(JsonWriter jsonWriter, object value)
	{
		SerializeInternal(jsonWriter, value, null);
	}

	internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType)
	{
		ValidationUtils.ArgumentNotNull(jsonWriter, "jsonWriter");
		Formatting? formatting = null;
		if (_formatting.HasValue && jsonWriter.Formatting != _formatting)
		{
			formatting = jsonWriter.Formatting;
			jsonWriter.Formatting = _formatting.GetValueOrDefault();
		}
		DateFormatHandling? dateFormatHandling = null;
		if (_dateFormatHandling.HasValue && jsonWriter.DateFormatHandling != _dateFormatHandling)
		{
			dateFormatHandling = jsonWriter.DateFormatHandling;
			jsonWriter.DateFormatHandling = _dateFormatHandling.GetValueOrDefault();
		}
		DateTimeZoneHandling? dateTimeZoneHandling = null;
		if (_dateTimeZoneHandling.HasValue && jsonWriter.DateTimeZoneHandling != _dateTimeZoneHandling)
		{
			dateTimeZoneHandling = jsonWriter.DateTimeZoneHandling;
			jsonWriter.DateTimeZoneHandling = _dateTimeZoneHandling.GetValueOrDefault();
		}
		FloatFormatHandling? floatFormatHandling = null;
		if (_floatFormatHandling.HasValue && jsonWriter.FloatFormatHandling != _floatFormatHandling)
		{
			floatFormatHandling = jsonWriter.FloatFormatHandling;
			jsonWriter.FloatFormatHandling = _floatFormatHandling.GetValueOrDefault();
		}
		StringEscapeHandling? stringEscapeHandling = null;
		if (_stringEscapeHandling.HasValue && jsonWriter.StringEscapeHandling != _stringEscapeHandling)
		{
			stringEscapeHandling = jsonWriter.StringEscapeHandling;
			jsonWriter.StringEscapeHandling = _stringEscapeHandling.GetValueOrDefault();
		}
		CultureInfo cultureInfo = null;
		if (_culture != null && !_culture.Equals(jsonWriter.Culture))
		{
			cultureInfo = jsonWriter.Culture;
			jsonWriter.Culture = _culture;
		}
		string dateFormatString = null;
		if (_dateFormatStringSet && jsonWriter.DateFormatString != _dateFormatString)
		{
			dateFormatString = jsonWriter.DateFormatString;
			jsonWriter.DateFormatString = _dateFormatString;
		}
		TraceJsonWriter traceJsonWriter = ((TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose) ? new TraceJsonWriter(jsonWriter) : null);
		new JsonSerializerInternalWriter(this).Serialize(traceJsonWriter ?? jsonWriter, value, objectType);
		if (traceJsonWriter != null)
		{
			TraceWriter.Trace(TraceLevel.Verbose, traceJsonWriter.GetSerializedJsonMessage(), null);
		}
		if (formatting.HasValue)
		{
			jsonWriter.Formatting = formatting.GetValueOrDefault();
		}
		if (dateFormatHandling.HasValue)
		{
			jsonWriter.DateFormatHandling = dateFormatHandling.GetValueOrDefault();
		}
		if (dateTimeZoneHandling.HasValue)
		{
			jsonWriter.DateTimeZoneHandling = dateTimeZoneHandling.GetValueOrDefault();
		}
		if (floatFormatHandling.HasValue)
		{
			jsonWriter.FloatFormatHandling = floatFormatHandling.GetValueOrDefault();
		}
		if (stringEscapeHandling.HasValue)
		{
			jsonWriter.StringEscapeHandling = stringEscapeHandling.GetValueOrDefault();
		}
		if (_dateFormatStringSet)
		{
			jsonWriter.DateFormatString = dateFormatString;
		}
		if (cultureInfo != null)
		{
			jsonWriter.Culture = cultureInfo;
		}
	}

	internal IReferenceResolver GetReferenceResolver()
	{
		if (_referenceResolver == null)
		{
			_referenceResolver = new DefaultReferenceResolver();
		}
		return _referenceResolver;
	}

	internal JsonConverter GetMatchingConverter(Type type)
	{
		return GetMatchingConverter(_converters, type);
	}

	internal static JsonConverter GetMatchingConverter(IList<JsonConverter> converters, Type objectType)
	{
		if (converters != null)
		{
			for (int i = 0; i < converters.Count; i++)
			{
				JsonConverter jsonConverter = converters[i];
				if (jsonConverter.CanConvert(objectType))
				{
					return jsonConverter;
				}
			}
		}
		return null;
	}

	internal void OnError(Newtonsoft.Json.Serialization.ErrorEventArgs e)
	{
		this.Error?.Invoke(this, e);
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum MissingMemberHandling
{
	Ignore,
	Error
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum NullValueHandling
{
	Include,
	Ignore
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum ReferenceLoopHandling
{
	Error,
	Ignore,
	Serialize
}


using System;
using Newtonsoft.Json.Shims;

[Flags]
[Preserve]
public enum TypeNameHandling
{
	None = 0,
	Objects = 1,
	Arrays = 2,
	All = 3,
	Auto = 4
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum JsonToken
{
	None,
	StartObject,
	StartArray,
	StartConstructor,
	PropertyName,
	Comment,
	Raw,
	Integer,
	Float,
	String,
	Boolean,
	Null,
	Undefined,
	EndObject,
	EndArray,
	EndConstructor,
	Date,
	Bytes
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public abstract class JsonWriter : IDisposable
{
	internal enum State
	{
		Start,
		Property,
		ObjectStart,
		Object,
		ArrayStart,
		Array,
		ConstructorStart,
		Constructor,
		Closed,
		Error
	}

	private static readonly State[][] StateArray;

	internal static readonly State[][] StateArrayTempate;

	private List<JsonPosition> _stack;

	private JsonPosition _currentPosition;

	private State _currentState;

	private Formatting _formatting;

	private DateFormatHandling _dateFormatHandling;

	private DateTimeZoneHandling _dateTimeZoneHandling;

	private StringEscapeHandling _stringEscapeHandling;

	private FloatFormatHandling _floatFormatHandling;

	private string _dateFormatString;

	private CultureInfo _culture;

	public bool CloseOutput { get; set; }

	protected internal int Top
	{
		get
		{
			int num = ((_stack != null) ? _stack.Count : 0);
			if (Peek() != 0)
			{
				num++;
			}
			return num;
		}
	}

	public WriteState WriteState
	{
		get
		{
			switch (_currentState)
			{
			case State.Error:
				return WriteState.Error;
			case State.Closed:
				return WriteState.Closed;
			case State.ObjectStart:
			case State.Object:
				return WriteState.Object;
			case State.ArrayStart:
			case State.Array:
				return WriteState.Array;
			case State.ConstructorStart:
			case State.Constructor:
				return WriteState.Constructor;
			case State.Property:
				return WriteState.Property;
			case State.Start:
				return WriteState.Start;
			default:
				throw JsonWriterException.Create(this, "Invalid state: " + _currentState, null);
			}
		}
	}

	internal string ContainerPath
	{
		get
		{
			if (_currentPosition.Type == JsonContainerType.None || _stack == null)
			{
				return string.Empty;
			}
			return JsonPosition.BuildPath(_stack, null);
		}
	}

	public string Path
	{
		get
		{
			if (_currentPosition.Type == JsonContainerType.None)
			{
				return string.Empty;
			}
			JsonPosition? currentPosition = ((_currentState != State.ArrayStart && _currentState != State.ConstructorStart && _currentState != State.ObjectStart) ? new JsonPosition?(_currentPosition) : ((JsonPosition?)null));
			return JsonPosition.BuildPath(_stack, currentPosition);
		}
	}

	public Formatting Formatting
	{
		get
		{
			return _formatting;
		}
		set
		{
			if (value < Formatting.None || value > Formatting.Indented)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_formatting = value;
		}
	}

	public DateFormatHandling DateFormatHandling
	{
		get
		{
			return _dateFormatHandling;
		}
		set
		{
			if (value < DateFormatHandling.IsoDateFormat || value > DateFormatHandling.MicrosoftDateFormat)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_dateFormatHandling = value;
		}
	}

	public DateTimeZoneHandling DateTimeZoneHandling
	{
		get
		{
			return _dateTimeZoneHandling;
		}
		set
		{
			if (value < DateTimeZoneHandling.Local || value > DateTimeZoneHandling.RoundtripKind)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_dateTimeZoneHandling = value;
		}
	}

	public StringEscapeHandling StringEscapeHandling
	{
		get
		{
			return _stringEscapeHandling;
		}
		set
		{
			if (value < StringEscapeHandling.Default || value > StringEscapeHandling.EscapeHtml)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_stringEscapeHandling = value;
			OnStringEscapeHandlingChanged();
		}
	}

	public FloatFormatHandling FloatFormatHandling
	{
		get
		{
			return _floatFormatHandling;
		}
		set
		{
			if (value < FloatFormatHandling.String || value > FloatFormatHandling.DefaultValue)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_floatFormatHandling = value;
		}
	}

	public string DateFormatString
	{
		get
		{
			return _dateFormatString;
		}
		set
		{
			_dateFormatString = value;
		}
	}

	public CultureInfo Culture
	{
		get
		{
			return _culture ?? CultureInfo.InvariantCulture;
		}
		set
		{
			_culture = value;
		}
	}

	internal static State[][] BuildStateArray()
	{
		List<State[]> list = StateArrayTempate.ToList();
		State[] item = StateArrayTempate[0];
		State[] item2 = StateArrayTempate[7];
		foreach (JsonToken value in EnumUtils.GetValues(typeof(JsonToken)))
		{
			if (list.Count <= (int)value)
			{
				switch (value)
				{
				case JsonToken.Integer:
				case JsonToken.Float:
				case JsonToken.String:
				case JsonToken.Boolean:
				case JsonToken.Null:
				case JsonToken.Undefined:
				case JsonToken.Date:
				case JsonToken.Bytes:
					list.Add(item2);
					break;
				default:
					list.Add(item);
					break;
				}
			}
		}
		return list.ToArray();
	}

	static JsonWriter()
	{
		StateArrayTempate = new State[8][]
		{
			new State[10]
			{
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.ObjectStart,
				State.ObjectStart,
				State.Error,
				State.Error,
				State.ObjectStart,
				State.ObjectStart,
				State.ObjectStart,
				State.ObjectStart,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.ArrayStart,
				State.ArrayStart,
				State.Error,
				State.Error,
				State.ArrayStart,
				State.ArrayStart,
				State.ArrayStart,
				State.ArrayStart,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.ConstructorStart,
				State.ConstructorStart,
				State.Error,
				State.Error,
				State.ConstructorStart,
				State.ConstructorStart,
				State.ConstructorStart,
				State.ConstructorStart,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.Property,
				State.Error,
				State.Property,
				State.Property,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.Start,
				State.Property,
				State.ObjectStart,
				State.Object,
				State.ArrayStart,
				State.Array,
				State.Constructor,
				State.Constructor,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.Start,
				State.Property,
				State.ObjectStart,
				State.Object,
				State.ArrayStart,
				State.Array,
				State.Constructor,
				State.Constructor,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.Start,
				State.Object,
				State.Error,
				State.Error,
				State.Array,
				State.Array,
				State.Constructor,
				State.Constructor,
				State.Error,
				State.Error
			}
		};
		StateArray = BuildStateArray();
	}

	internal virtual void OnStringEscapeHandlingChanged()
	{
	}

	protected JsonWriter()
	{
		_currentState = State.Start;
		_formatting = Formatting.None;
		_dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
		CloseOutput = true;
	}

	internal void UpdateScopeWithFinishedValue()
	{
		if (_currentPosition.HasIndex)
		{
			_currentPosition.Position++;
		}
	}

	private void Push(JsonContainerType value)
	{
		if (_currentPosition.Type != 0)
		{
			if (_stack == null)
			{
				_stack = new List<JsonPosition>();
			}
			_stack.Add(_currentPosition);
		}
		_currentPosition = new JsonPosition(value);
	}

	private JsonContainerType Pop()
	{
		JsonPosition currentPosition = _currentPosition;
		if (_stack != null && _stack.Count > 0)
		{
			_currentPosition = _stack[_stack.Count - 1];
			_stack.RemoveAt(_stack.Count - 1);
		}
		else
		{
			_currentPosition = default(JsonPosition);
		}
		return currentPosition.Type;
	}

	private JsonContainerType Peek()
	{
		return _currentPosition.Type;
	}

	public abstract void Flush();

	public virtual void Close()
	{
		AutoCompleteAll();
	}

	public virtual void WriteStartObject()
	{
		InternalWriteStart(JsonToken.StartObject, JsonContainerType.Object);
	}

	public virtual void WriteEndObject()
	{
		InternalWriteEnd(JsonContainerType.Object);
	}

	public virtual void WriteStartArray()
	{
		InternalWriteStart(JsonToken.StartArray, JsonContainerType.Array);
	}

	public virtual void WriteEndArray()
	{
		InternalWriteEnd(JsonContainerType.Array);
	}

	public virtual void WriteStartConstructor(string name)
	{
		InternalWriteStart(JsonToken.StartConstructor, JsonContainerType.Constructor);
	}

	public virtual void WriteEndConstructor()
	{
		InternalWriteEnd(JsonContainerType.Constructor);
	}

	public virtual void WritePropertyName(string name)
	{
		InternalWritePropertyName(name);
	}

	public virtual void WritePropertyName(string name, bool escape)
	{
		WritePropertyName(name);
	}

	public virtual void WriteEnd()
	{
		WriteEnd(Peek());
	}

	public void WriteToken(JsonReader reader)
	{
		WriteToken(reader, writeChildren: true);
	}

	public void WriteToken(JsonReader reader, bool writeChildren)
	{
		ValidationUtils.ArgumentNotNull(reader, "reader");
		WriteToken(reader, writeChildren, writeDateConstructorAsDate: true, writeComments: true);
	}

	public void WriteToken(JsonToken token, object value)
	{
		switch (token)
		{
		case JsonToken.StartObject:
			WriteStartObject();
			break;
		case JsonToken.StartArray:
			WriteStartArray();
			break;
		case JsonToken.StartConstructor:
			ValidationUtils.ArgumentNotNull(value, "value");
			WriteStartConstructor(value.ToString());
			break;
		case JsonToken.PropertyName:
			ValidationUtils.ArgumentNotNull(value, "value");
			WritePropertyName(value.ToString());
			break;
		case JsonToken.Comment:
			WriteComment(value?.ToString());
			break;
		case JsonToken.Integer:
			ValidationUtils.ArgumentNotNull(value, "value");
			WriteValue(Convert.ToInt64(value, CultureInfo.InvariantCulture));
			break;
		case JsonToken.Float:
			ValidationUtils.ArgumentNotNull(value, "value");
			if (value is decimal)
			{
				WriteValue((decimal)value);
			}
			else if (value is double)
			{
				WriteValue((double)value);
			}
			else if (value is float)
			{
				WriteValue((float)value);
			}
			else
			{
				WriteValue(Convert.ToDouble(value, CultureInfo.InvariantCulture));
			}
			break;
		case JsonToken.String:
			ValidationUtils.ArgumentNotNull(value, "value");
			WriteValue(value.ToString());
			break;
		case JsonToken.Boolean:
			ValidationUtils.ArgumentNotNull(value, "value");
			WriteValue(Convert.ToBoolean(value, CultureInfo.InvariantCulture));
			break;
		case JsonToken.Null:
			WriteNull();
			break;
		case JsonToken.Undefined:
			WriteUndefined();
			break;
		case JsonToken.EndObject:
			WriteEndObject();
			break;
		case JsonToken.EndArray:
			WriteEndArray();
			break;
		case JsonToken.EndConstructor:
			WriteEndConstructor();
			break;
		case JsonToken.Date:
			ValidationUtils.ArgumentNotNull(value, "value");
			if (value is DateTimeOffset)
			{
				WriteValue((DateTimeOffset)value);
			}
			else
			{
				WriteValue(Convert.ToDateTime(value, CultureInfo.InvariantCulture));
			}
			break;
		case JsonToken.Raw:
			WriteRawValue(value?.ToString());
			break;
		case JsonToken.Bytes:
			ValidationUtils.ArgumentNotNull(value, "value");
			if (value is Guid)
			{
				WriteValue((Guid)value);
			}
			else
			{
				WriteValue((byte[])value);
			}
			break;
		default:
			throw MiscellaneousUtils.CreateArgumentOutOfRangeException("token", token, "Unexpected token type.");
		case JsonToken.None:
			break;
		}
	}

	public void WriteToken(JsonToken token)
	{
		WriteToken(token, null);
	}

	internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments)
	{
		int num = ((reader.TokenType == JsonToken.None) ? (-1) : (JsonTokenUtils.IsStartToken(reader.TokenType) ? reader.Depth : (reader.Depth + 1)));
		do
		{
			if (writeDateConstructorAsDate && reader.TokenType == JsonToken.StartConstructor && string.Equals(reader.Value.ToString(), "Date", StringComparison.Ordinal))
			{
				WriteConstructorDate(reader);
			}
			else if (writeComments || reader.TokenType != JsonToken.Comment)
			{
				WriteToken(reader.TokenType, reader.Value);
			}
		}
		while (num - 1 < reader.Depth - (JsonTokenUtils.IsEndToken(reader.TokenType) ? 1 : 0) && writeChildren && reader.Read());
	}

	private void WriteConstructorDate(JsonReader reader)
	{
		if (!reader.Read())
		{
			throw JsonWriterException.Create(this, "Unexpected end when reading date constructor.", null);
		}
		if (reader.TokenType != JsonToken.Integer)
		{
			throw JsonWriterException.Create(this, "Unexpected token when reading date constructor. Expected Integer, got " + reader.TokenType, null);
		}
		DateTime value = DateTimeUtils.ConvertJavaScriptTicksToDateTime((long)reader.Value);
		if (!reader.Read())
		{
			throw JsonWriterException.Create(this, "Unexpected end when reading date constructor.", null);
		}
		if (reader.TokenType != JsonToken.EndConstructor)
		{
			throw JsonWriterException.Create(this, "Unexpected token when reading date constructor. Expected EndConstructor, got " + reader.TokenType, null);
		}
		WriteValue(value);
	}

	private void WriteEnd(JsonContainerType type)
	{
		switch (type)
		{
		case JsonContainerType.Object:
			WriteEndObject();
			break;
		case JsonContainerType.Array:
			WriteEndArray();
			break;
		case JsonContainerType.Constructor:
			WriteEndConstructor();
			break;
		default:
			throw JsonWriterException.Create(this, "Unexpected type when writing end: " + type, null);
		}
	}

	private void AutoCompleteAll()
	{
		while (Top > 0)
		{
			WriteEnd();
		}
	}

	private JsonToken GetCloseTokenForType(JsonContainerType type)
	{
		return type switch
		{
			JsonContainerType.Object => JsonToken.EndObject, 
			JsonContainerType.Array => JsonToken.EndArray, 
			JsonContainerType.Constructor => JsonToken.EndConstructor, 
			_ => throw JsonWriterException.Create(this, "No close token for type: " + type, null), 
		};
	}

	private void AutoCompleteClose(JsonContainerType type)
	{
		int num = 0;
		if (_currentPosition.Type == type)
		{
			num = 1;
		}
		else
		{
			int num2 = Top - 2;
			for (int num3 = num2; num3 >= 0; num3--)
			{
				int index = num2 - num3;
				if (_stack[index].Type == type)
				{
					num = num3 + 2;
					break;
				}
			}
		}
		if (num == 0)
		{
			throw JsonWriterException.Create(this, "No token to close.", null);
		}
		for (int i = 0; i < num; i++)
		{
			JsonToken closeTokenForType = GetCloseTokenForType(Pop());
			if (_currentState == State.Property)
			{
				WriteNull();
			}
			if (_formatting == Formatting.Indented && _currentState != State.ObjectStart && _currentState != State.ArrayStart)
			{
				WriteIndent();
			}
			WriteEnd(closeTokenForType);
			JsonContainerType jsonContainerType = Peek();
			switch (jsonContainerType)
			{
			case JsonContainerType.Object:
				_currentState = State.Object;
				break;
			case JsonContainerType.Array:
				_currentState = State.Array;
				break;
			case JsonContainerType.Constructor:
				_currentState = State.Array;
				break;
			case JsonContainerType.None:
				_currentState = State.Start;
				break;
			default:
				throw JsonWriterException.Create(this, "Unknown JsonType: " + jsonContainerType, null);
			}
		}
	}

	protected virtual void WriteEnd(JsonToken token)
	{
	}

	protected virtual void WriteIndent()
	{
	}

	protected virtual void WriteValueDelimiter()
	{
	}

	protected virtual void WriteIndentSpace()
	{
	}

	internal void AutoComplete(JsonToken tokenBeingWritten)
	{
		State state = StateArray[(int)tokenBeingWritten][(int)_currentState];
		if (state == State.Error)
		{
			throw JsonWriterException.Create(this, "Token {0} in state {1} would result in an invalid JSON object.".FormatWith(CultureInfo.InvariantCulture, tokenBeingWritten.ToString(), _currentState.ToString()), null);
		}
		if ((_currentState == State.Object || _currentState == State.Array || _currentState == State.Constructor) && tokenBeingWritten != JsonToken.Comment)
		{
			WriteValueDelimiter();
		}
		if (_formatting == Formatting.Indented)
		{
			if (_currentState == State.Property)
			{
				WriteIndentSpace();
			}
			if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.Constructor || _currentState == State.ConstructorStart || (tokenBeingWritten == JsonToken.PropertyName && _currentState != 0))
			{
				WriteIndent();
			}
		}
		_currentState = state;
	}

	public virtual void WriteNull()
	{
		InternalWriteValue(JsonToken.Null);
	}

	public virtual void WriteUndefined()
	{
		InternalWriteValue(JsonToken.Undefined);
	}

	public virtual void WriteRaw(string json)
	{
		InternalWriteRaw();
	}

	public virtual void WriteRawValue(string json)
	{
		UpdateScopeWithFinishedValue();
		AutoComplete(JsonToken.Undefined);
		WriteRaw(json);
	}

	public virtual void WriteValue(string value)
	{
		InternalWriteValue(JsonToken.String);
	}

	public virtual void WriteValue(int value)
	{
		InternalWriteValue(JsonToken.Integer);
	}

	[CLSCompliant(false)]
	public virtual void WriteValue(uint value)
	{
		InternalWriteValue(JsonToken.Integer);
	}

	public virtual void WriteValue(long value)
	{
		InternalWriteValue(JsonToken.Integer);
	}

	[CLSCompliant(false)]
	public virtual void WriteValue(ulong value)
	{
		InternalWriteValue(JsonToken.Integer);
	}

	public virtual void WriteValue(float value)
	{
		InternalWriteValue(JsonToken.Float);
	}

	public virtual void WriteValue(double value)
	{
		InternalWriteValue(JsonToken.Float);
	}

	public virtual void WriteValue(bool value)
	{
		InternalWriteValue(JsonToken.Boolean);
	}

	public virtual void WriteValue(short value)
	{
		InternalWriteValue(JsonToken.Integer);
	}

	[CLSCompliant(false)]
	public virtual void WriteValue(ushort value)
	{
		InternalWriteValue(JsonToken.Integer);
	}

	public virtual void WriteValue(char value)
	{
		InternalWriteValue(JsonToken.String);
	}

	public virtual void WriteValue(byte value)
	{
		InternalWriteValue(JsonToken.Integer);
	}

	[CLSCompliant(false)]
	public virtual void WriteValue(sbyte value)
	{
		InternalWriteValue(JsonToken.Integer);
	}

	public virtual void WriteValue(decimal value)
	{
		InternalWriteValue(JsonToken.Float);
	}

	public virtual void WriteValue(DateTime value)
	{
		InternalWriteValue(JsonToken.Date);
	}

	public virtual void WriteValue(DateTimeOffset value)
	{
		InternalWriteValue(JsonToken.Date);
	}

	public virtual void WriteValue(Guid value)
	{
		InternalWriteValue(JsonToken.String);
	}

	public virtual void WriteValue(TimeSpan value)
	{
		InternalWriteValue(JsonToken.String);
	}

	public virtual void WriteValue(int? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	[CLSCompliant(false)]
	public virtual void WriteValue(uint? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	public virtual void WriteValue(long? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	[CLSCompliant(false)]
	public virtual void WriteValue(ulong? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	public virtual void WriteValue(float? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	public virtual void WriteValue(double? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	public virtual void WriteValue(bool? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value == true);
		}
	}

	public virtual void WriteValue(short? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	[CLSCompliant(false)]
	public virtual void WriteValue(ushort? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	public virtual void WriteValue(char? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	public virtual void WriteValue(byte? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	[CLSCompliant(false)]
	public virtual void WriteValue(sbyte? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	public virtual void WriteValue(decimal? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	public virtual void WriteValue(DateTime? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	public virtual void WriteValue(DateTimeOffset? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	public virtual void WriteValue(Guid? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	public virtual void WriteValue(TimeSpan? value)
	{
		if (!value.HasValue)
		{
			WriteNull();
		}
		else
		{
			WriteValue(value.GetValueOrDefault());
		}
	}

	public virtual void WriteValue(byte[] value)
	{
		if (value == null)
		{
			WriteNull();
		}
		else
		{
			InternalWriteValue(JsonToken.Bytes);
		}
	}

	public virtual void WriteValue(Uri value)
	{
		if (value == null)
		{
			WriteNull();
		}
		else
		{
			InternalWriteValue(JsonToken.String);
		}
	}

	public virtual void WriteValue(object value)
	{
		if (value == null)
		{
			WriteNull();
		}
		else
		{
			WriteValue(this, ConvertUtils.GetTypeCode(value.GetType()), value);
		}
	}

	public virtual void WriteComment(string text)
	{
		InternalWriteComment();
	}

	public virtual void WriteWhitespace(string ws)
	{
		InternalWriteWhitespace(ws);
	}

	void IDisposable.Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	protected virtual void Dispose(bool disposing)
	{
		if (_currentState != State.Closed && disposing)
		{
			Close();
		}
	}

	internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value)
	{
		switch (typeCode)
		{
		case PrimitiveTypeCode.Char:
			writer.WriteValue((char)value);
			return;
		case PrimitiveTypeCode.CharNullable:
			writer.WriteValue((value == null) ? ((char?)null) : new char?((char)value));
			return;
		case PrimitiveTypeCode.Boolean:
			writer.WriteValue((bool)value);
			return;
		case PrimitiveTypeCode.BooleanNullable:
			writer.WriteValue((value == null) ? ((bool?)null) : new bool?((bool)value));
			return;
		case PrimitiveTypeCode.SByte:
			writer.WriteValue((sbyte)value);
			return;
		case PrimitiveTypeCode.SByteNullable:
			writer.WriteValue((value == null) ? ((sbyte?)null) : new sbyte?((sbyte)value));
			return;
		case PrimitiveTypeCode.Int16:
			writer.WriteValue((short)value);
			return;
		case PrimitiveTypeCode.Int16Nullable:
			writer.WriteValue((value == null) ? ((short?)null) : new short?((short)value));
			return;
		case PrimitiveTypeCode.UInt16:
			writer.WriteValue((ushort)value);
			return;
		case PrimitiveTypeCode.UInt16Nullable:
			writer.WriteValue((value == null) ? ((ushort?)null) : new ushort?((ushort)value));
			return;
		case PrimitiveTypeCode.Int32:
			writer.WriteValue((int)value);
			return;
		case PrimitiveTypeCode.Int32Nullable:
			writer.WriteValue((value == null) ? ((int?)null) : new int?((int)value));
			return;
		case PrimitiveTypeCode.Byte:
			writer.WriteValue((byte)value);
			return;
		case PrimitiveTypeCode.ByteNullable:
			writer.WriteValue((value == null) ? ((byte?)null) : new byte?((byte)value));
			return;
		case PrimitiveTypeCode.UInt32:
			writer.WriteValue((uint)value);
			return;
		case PrimitiveTypeCode.UInt32Nullable:
			writer.WriteValue((value == null) ? ((uint?)null) : new uint?((uint)value));
			return;
		case PrimitiveTypeCode.Int64:
			writer.WriteValue((long)value);
			return;
		case PrimitiveTypeCode.Int64Nullable:
			writer.WriteValue((value == null) ? ((long?)null) : new long?((long)value));
			return;
		case PrimitiveTypeCode.UInt64:
			writer.WriteValue((ulong)value);
			return;
		case PrimitiveTypeCode.UInt64Nullable:
			writer.WriteValue((value == null) ? ((ulong?)null) : new ulong?((ulong)value));
			return;
		case PrimitiveTypeCode.Single:
			writer.WriteValue((float)value);
			return;
		case PrimitiveTypeCode.SingleNullable:
			writer.WriteValue((value == null) ? ((float?)null) : new float?((float)value));
			return;
		case PrimitiveTypeCode.Double:
			writer.WriteValue((double)value);
			return;
		case PrimitiveTypeCode.DoubleNullable:
			writer.WriteValue((value == null) ? ((double?)null) : new double?((double)value));
			return;
		case PrimitiveTypeCode.DateTime:
			writer.WriteValue((DateTime)value);
			return;
		case PrimitiveTypeCode.DateTimeNullable:
			writer.WriteValue((value == null) ? ((DateTime?)null) : new DateTime?((DateTime)value));
			return;
		case PrimitiveTypeCode.DateTimeOffset:
			writer.WriteValue((DateTimeOffset)value);
			return;
		case PrimitiveTypeCode.DateTimeOffsetNullable:
			writer.WriteValue((value == null) ? ((DateTimeOffset?)null) : new DateTimeOffset?((DateTimeOffset)value));
			return;
		case PrimitiveTypeCode.Decimal:
			writer.WriteValue((decimal)value);
			return;
		case PrimitiveTypeCode.DecimalNullable:
			writer.WriteValue((value == null) ? ((decimal?)null) : new decimal?((decimal)value));
			return;
		case PrimitiveTypeCode.Guid:
			writer.WriteValue((Guid)value);
			return;
		case PrimitiveTypeCode.GuidNullable:
			writer.WriteValue((value == null) ? ((Guid?)null) : new Guid?((Guid)value));
			return;
		case PrimitiveTypeCode.TimeSpan:
			writer.WriteValue((TimeSpan)value);
			return;
		case PrimitiveTypeCode.TimeSpanNullable:
			writer.WriteValue((value == null) ? ((TimeSpan?)null) : new TimeSpan?((TimeSpan)value));
			return;
		case PrimitiveTypeCode.Uri:
			writer.WriteValue((Uri)value);
			return;
		case PrimitiveTypeCode.String:
			writer.WriteValue((string)value);
			return;
		case PrimitiveTypeCode.Bytes:
			writer.WriteValue((byte[])value);
			return;
		case PrimitiveTypeCode.DBNull:
			writer.WriteNull();
			return;
		}
		if (value is IConvertible)
		{
			IConvertible obj = (IConvertible)value;
			TypeInformation typeInformation = ConvertUtils.GetTypeInformation(obj);
			PrimitiveTypeCode typeCode2 = ((typeInformation.TypeCode == PrimitiveTypeCode.Object) ? PrimitiveTypeCode.String : typeInformation.TypeCode);
			Type conversionType = ((typeInformation.TypeCode == PrimitiveTypeCode.Object) ? typeof(string) : typeInformation.Type);
			object value2 = obj.ToType(conversionType, CultureInfo.InvariantCulture);
			WriteValue(writer, typeCode2, value2);
			return;
		}
		throw CreateUnsupportedTypeException(writer, value);
	}

	private static JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value)
	{
		return JsonWriterException.Create(writer, "Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith(CultureInfo.InvariantCulture, value.GetType()), null);
	}

	protected void SetWriteState(JsonToken token, object value)
	{
		switch (token)
		{
		case JsonToken.StartObject:
			InternalWriteStart(token, JsonContainerType.Object);
			break;
		case JsonToken.StartArray:
			InternalWriteStart(token, JsonContainerType.Array);
			break;
		case JsonToken.StartConstructor:
			InternalWriteStart(token, JsonContainerType.Constructor);
			break;
		case JsonToken.PropertyName:
			if (!(value is string))
			{
				throw new ArgumentException("A name is required when setting property name state.", "value");
			}
			InternalWritePropertyName((string)value);
			break;
		case JsonToken.Comment:
			InternalWriteComment();
			break;
		case JsonToken.Raw:
			InternalWriteRaw();
			break;
		case JsonToken.Integer:
		case JsonToken.Float:
		case JsonToken.String:
		case JsonToken.Boolean:
		case JsonToken.Null:
		case JsonToken.Undefined:
		case JsonToken.Date:
		case JsonToken.Bytes:
			InternalWriteValue(token);
			break;
		case JsonToken.EndObject:
			InternalWriteEnd(JsonContainerType.Object);
			break;
		case JsonToken.EndArray:
			InternalWriteEnd(JsonContainerType.Array);
			break;
		case JsonToken.EndConstructor:
			InternalWriteEnd(JsonContainerType.Constructor);
			break;
		default:
			throw new ArgumentOutOfRangeException("token");
		}
	}

	internal void InternalWriteEnd(JsonContainerType container)
	{
		AutoCompleteClose(container);
	}

	internal void InternalWritePropertyName(string name)
	{
		_currentPosition.PropertyName = name;
		AutoComplete(JsonToken.PropertyName);
	}

	internal void InternalWriteRaw()
	{
	}

	internal void InternalWriteStart(JsonToken token, JsonContainerType container)
	{
		UpdateScopeWithFinishedValue();
		AutoComplete(token);
		Push(container);
	}

	internal void InternalWriteValue(JsonToken token)
	{
		UpdateScopeWithFinishedValue();
		AutoComplete(token);
	}

	internal void InternalWriteWhitespace(string ws)
	{
		if (ws != null && !StringUtils.IsWhiteSpace(ws))
		{
			throw JsonWriterException.Create(this, "Only white space characters should be used.", null);
		}
	}

	internal void InternalWriteComment()
	{
		AutoComplete(JsonToken.Comment);
	}
}


internal enum State
{
	Start,
	Property,
	ObjectStart,
	Object,
	ArrayStart,
	Array,
	ConstructorStart,
	Constructor,
	Closed,
	Error
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum WriteState
{
	Error,
	Closed,
	Object,
	Array,
	Constructor,
	Property,
	Start
}


using Newtonsoft.Json.Shims;

[Preserve]
internal enum ParserTimeZone
{
	Unspecified,
	Utc,
	LocalWestOfUtc,
	LocalEastOfUtc
}


using System;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal struct DateTimeParser
{
	public int Year;

	public int Month;

	public int Day;

	public int Hour;

	public int Minute;

	public int Second;

	public int Fraction;

	public int ZoneHour;

	public int ZoneMinute;

	public ParserTimeZone Zone;

	private char[] _text;

	private int _end;

	private static readonly int[] Power10;

	private static readonly int Lzyyyy;

	private static readonly int Lzyyyy_;

	private static readonly int Lzyyyy_MM;

	private static readonly int Lzyyyy_MM_;

	private static readonly int Lzyyyy_MM_dd;

	private static readonly int Lzyyyy_MM_ddT;

	private static readonly int LzHH;

	private static readonly int LzHH_;

	private static readonly int LzHH_mm;

	private static readonly int LzHH_mm_;

	private static readonly int LzHH_mm_ss;

	private static readonly int Lz_;

	private static readonly int Lz_zz;

	private const short MaxFractionDigits = 7;

	static DateTimeParser()
	{
		Power10 = new int[7] { -1, 10, 100, 1000, 10000, 100000, 1000000 };
		Lzyyyy = "yyyy".Length;
		Lzyyyy_ = "yyyy-".Length;
		Lzyyyy_MM = "yyyy-MM".Length;
		Lzyyyy_MM_ = "yyyy-MM-".Length;
		Lzyyyy_MM_dd = "yyyy-MM-dd".Length;
		Lzyyyy_MM_ddT = "yyyy-MM-ddT".Length;
		LzHH = "HH".Length;
		LzHH_ = "HH:".Length;
		LzHH_mm = "HH:mm".Length;
		LzHH_mm_ = "HH:mm:".Length;
		LzHH_mm_ss = "HH:mm:ss".Length;
		Lz_ = "-".Length;
		Lz_zz = "-zz".Length;
	}

	public bool Parse(char[] text, int startIndex, int length)
	{
		_text = text;
		_end = startIndex + length;
		if (ParseDate(startIndex) && ParseChar(Lzyyyy_MM_dd + startIndex, 'T') && ParseTimeAndZoneAndWhitespace(Lzyyyy_MM_ddT + startIndex))
		{
			return true;
		}
		return false;
	}

	private bool ParseDate(int start)
	{
		if (Parse4Digit(start, out Year) && 1 <= Year && ParseChar(start + Lzyyyy, '-') && Parse2Digit(start + Lzyyyy_, out Month) && 1 <= Month && Month <= 12 && ParseChar(start + Lzyyyy_MM, '-') && Parse2Digit(start + Lzyyyy_MM_, out Day) && 1 <= Day)
		{
			return Day <= DateTime.DaysInMonth(Year, Month);
		}
		return false;
	}

	private bool ParseTimeAndZoneAndWhitespace(int start)
	{
		if (ParseTime(ref start))
		{
			return ParseZone(start);
		}
		return false;
	}

	private bool ParseTime(ref int start)
	{
		if (!Parse2Digit(start, out Hour) || Hour > 24 || !ParseChar(start + LzHH, ':') || !Parse2Digit(start + LzHH_, out Minute) || Minute >= 60 || !ParseChar(start + LzHH_mm, ':') || !Parse2Digit(start + LzHH_mm_, out Second) || Second >= 60 || (Hour == 24 && (Minute != 0 || Second != 0)))
		{
			return false;
		}
		start += LzHH_mm_ss;
		if (ParseChar(start, '.'))
		{
			Fraction = 0;
			int num = 0;
			while (++start < _end && num < 7)
			{
				int num2 = _text[start] - 48;
				if (num2 < 0 || num2 > 9)
				{
					break;
				}
				Fraction = Fraction * 10 + num2;
				num++;
			}
			if (num < 7)
			{
				if (num == 0)
				{
					return false;
				}
				Fraction *= Power10[7 - num];
			}
			if (Hour == 24 && Fraction != 0)
			{
				return false;
			}
		}
		return true;
	}

	private bool ParseZone(int start)
	{
		if (start < _end)
		{
			char c = _text[start];
			if (c == 'Z' || c == 'z')
			{
				Zone = ParserTimeZone.Utc;
				start++;
			}
			else
			{
				if (start + 2 < _end && Parse2Digit(start + Lz_, out ZoneHour) && ZoneHour <= 99)
				{
					switch (c)
					{
					case '-':
						Zone = ParserTimeZone.LocalWestOfUtc;
						start += Lz_zz;
						break;
					case '+':
						Zone = ParserTimeZone.LocalEastOfUtc;
						start += Lz_zz;
						break;
					}
				}
				if (start < _end)
				{
					if (ParseChar(start, ':'))
					{
						start++;
						if (start + 1 < _end && Parse2Digit(start, out ZoneMinute) && ZoneMinute <= 99)
						{
							start += 2;
						}
					}
					else if (start + 1 < _end && Parse2Digit(start, out ZoneMinute) && ZoneMinute <= 99)
					{
						start += 2;
					}
				}
			}
		}
		return start == _end;
	}

	private bool Parse4Digit(int start, out int num)
	{
		if (start + 3 < _end)
		{
			int num2 = _text[start] - 48;
			int num3 = _text[start + 1] - 48;
			int num4 = _text[start + 2] - 48;
			int num5 = _text[start + 3] - 48;
			if (0 <= num2 && num2 < 10 && 0 <= num3 && num3 < 10 && 0 <= num4 && num4 < 10 && 0 <= num5 && num5 < 10)
			{
				num = ((num2 * 10 + num3) * 10 + num4) * 10 + num5;
				return true;
			}
		}
		num = 0;
		return false;
	}

	private bool Parse2Digit(int start, out int num)
	{
		if (start + 1 < _end)
		{
			int num2 = _text[start] - 48;
			int num3 = _text[start + 1] - 48;
			if (0 <= num2 && num2 < 10 && 0 <= num3 && num3 < 10)
			{
				num = num2 * 10 + num3;
				return true;
			}
		}
		num = 0;
		return false;
	}

	private bool ParseChar(int start, char ch)
	{
		if (start < _end)
		{
			return _text[start] == ch;
		}
		return false;
	}
}


using System;
using System.IO;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class Base64Encoder
{
	private const int Base64LineSize = 76;

	private const int LineSizeInBytes = 57;

	private readonly char[] _charsLine = new char[76];

	private readonly TextWriter _writer;

	private byte[] _leftOverBytes;

	private int _leftOverBytesCount;

	public Base64Encoder(TextWriter writer)
	{
		ValidationUtils.ArgumentNotNull(writer, "writer");
		_writer = writer;
	}

	public void Encode(byte[] buffer, int index, int count)
	{
		if (buffer == null)
		{
			throw new ArgumentNullException("buffer");
		}
		if (index < 0)
		{
			throw new ArgumentOutOfRangeException("index");
		}
		if (count < 0)
		{
			throw new ArgumentOutOfRangeException("count");
		}
		if (count > buffer.Length - index)
		{
			throw new ArgumentOutOfRangeException("count");
		}
		if (_leftOverBytesCount > 0)
		{
			int leftOverBytesCount = _leftOverBytesCount;
			while (leftOverBytesCount < 3 && count > 0)
			{
				_leftOverBytes[leftOverBytesCount++] = buffer[index++];
				count--;
			}
			if (count == 0 && leftOverBytesCount < 3)
			{
				_leftOverBytesCount = leftOverBytesCount;
				return;
			}
			int count2 = Convert.ToBase64CharArray(_leftOverBytes, 0, 3, _charsLine, 0);
			WriteChars(_charsLine, 0, count2);
		}
		_leftOverBytesCount = count % 3;
		if (_leftOverBytesCount > 0)
		{
			count -= _leftOverBytesCount;
			if (_leftOverBytes == null)
			{
				_leftOverBytes = new byte[3];
			}
			for (int i = 0; i < _leftOverBytesCount; i++)
			{
				_leftOverBytes[i] = buffer[index + count + i];
			}
		}
		int num = index + count;
		int num2 = 57;
		while (index < num)
		{
			if (index + num2 > num)
			{
				num2 = num - index;
			}
			int count3 = Convert.ToBase64CharArray(buffer, index, num2, _charsLine, 0);
			WriteChars(_charsLine, 0, count3);
			index += num2;
		}
	}

	public void Flush()
	{
		if (_leftOverBytesCount > 0)
		{
			int count = Convert.ToBase64CharArray(_leftOverBytes, 0, _leftOverBytesCount, _charsLine, 0);
			WriteChars(_charsLine, 0, count);
			_leftOverBytesCount = 0;
		}
	}

	private void WriteChars(char[] chars, int index, int count)
	{
		_writer.Write(chars, index, count);
	}
}


using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Preserve]
internal static class JsonTokenUtils
{
	internal static bool IsEndToken(JsonToken token)
	{
		switch (token)
		{
		case JsonToken.EndObject:
		case JsonToken.EndArray:
		case JsonToken.EndConstructor:
			return true;
		default:
			return false;
		}
	}

	internal static bool IsStartToken(JsonToken token)
	{
		switch (token)
		{
		case JsonToken.StartObject:
		case JsonToken.StartArray:
		case JsonToken.StartConstructor:
			return true;
		default:
			return false;
		}
	}

	internal static bool IsPrimitiveToken(JsonToken token)
	{
		switch (token)
		{
		case JsonToken.Integer:
		case JsonToken.Float:
		case JsonToken.String:
		case JsonToken.Boolean:
		case JsonToken.Null:
		case JsonToken.Undefined:
		case JsonToken.Date:
		case JsonToken.Bytes:
			return true;
		default:
			return false;
		}
	}
}


using System;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class PropertyNameTable
{
	private class Entry
	{
		internal readonly string Value;

		internal readonly int HashCode;

		internal Entry Next;

		internal Entry(string value, int hashCode, Entry next)
		{
			Value = value;
			HashCode = hashCode;
			Next = next;
		}
	}

	private static readonly int HashCodeRandomizer;

	private int _count;

	private Entry[] _entries;

	private int _mask = 31;

	static PropertyNameTable()
	{
		HashCodeRandomizer = Environment.TickCount;
	}

	public PropertyNameTable()
	{
		_entries = new Entry[_mask + 1];
	}

	public string Get(char[] key, int start, int length)
	{
		if (length == 0)
		{
			return string.Empty;
		}
		int num = length + HashCodeRandomizer;
		num += (num << 7) ^ key[start];
		int num2 = start + length;
		for (int i = start + 1; i < num2; i++)
		{
			num += (num << 7) ^ key[i];
		}
		num -= num >> 17;
		num -= num >> 11;
		num -= num >> 5;
		for (Entry entry = _entries[num & _mask]; entry != null; entry = entry.Next)
		{
			if (entry.HashCode == num && TextEquals(entry.Value, key, start, length))
			{
				return entry.Value;
			}
		}
		return null;
	}

	public string Add(string key)
	{
		if (key == null)
		{
			throw new ArgumentNullException("key");
		}
		int length = key.Length;
		if (length == 0)
		{
			return string.Empty;
		}
		int num = length + HashCodeRandomizer;
		for (int i = 0; i < key.Length; i++)
		{
			num += (num << 7) ^ key[i];
		}
		num -= num >> 17;
		num -= num >> 11;
		num -= num >> 5;
		for (Entry entry = _entries[num & _mask]; entry != null; entry = entry.Next)
		{
			if (entry.HashCode == num && entry.Value.Equals(key))
			{
				return entry.Value;
			}
		}
		return AddEntry(key, num);
	}

	private string AddEntry(string str, int hashCode)
	{
		int num = hashCode & _mask;
		Entry entry = new Entry(str, hashCode, _entries[num]);
		_entries[num] = entry;
		if (_count++ == _mask)
		{
			Grow();
		}
		return entry.Value;
	}

	private void Grow()
	{
		Entry[] entries = _entries;
		int num = _mask * 2 + 1;
		Entry[] array = new Entry[num + 1];
		for (int i = 0; i < entries.Length; i++)
		{
			Entry entry = entries[i];
			while (entry != null)
			{
				int num2 = entry.HashCode & num;
				Entry next = entry.Next;
				entry.Next = array[num2];
				array[num2] = entry;
				entry = next;
			}
		}
		_entries = array;
		_mask = num;
	}

	private static bool TextEquals(string str1, char[] str2, int str2Start, int str2Length)
	{
		if (str1.Length != str2Length)
		{
			return false;
		}
		for (int i = 0; i < str1.Length; i++)
		{
			if (str1[i] != str2[str2Start + i])
			{
				return false;
			}
		}
		return true;
	}
}


private class Entry
{
	internal readonly string Value;

	internal readonly int HashCode;

	internal Entry Next;

	internal Entry(string value, int hashCode, Entry next)
	{
		Value = value;
		HashCode = hashCode;
		Next = next;
	}
}


using System;
using System.Globalization;
using System.Reflection;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal abstract class ReflectionDelegateFactory
{
	public Func<T, object> CreateGet<T>(MemberInfo memberInfo)
	{
		if (memberInfo is PropertyInfo propertyInfo)
		{
			return CreateGet<T>(propertyInfo);
		}
		if (memberInfo is FieldInfo fieldInfo)
		{
			return CreateGet<T>(fieldInfo);
		}
		throw new Exception("Could not create getter for {0}.".FormatWith(CultureInfo.InvariantCulture, memberInfo));
	}

	public Action<T, object> CreateSet<T>(MemberInfo memberInfo)
	{
		if (memberInfo is PropertyInfo propertyInfo)
		{
			return CreateSet<T>(propertyInfo);
		}
		if (memberInfo is FieldInfo fieldInfo)
		{
			return CreateSet<T>(fieldInfo);
		}
		throw new Exception("Could not create setter for {0}.".FormatWith(CultureInfo.InvariantCulture, memberInfo));
	}

	public abstract MethodCall<T, object> CreateMethodCall<T>(MethodBase method);

	public abstract ObjectConstructor<object> CreateParameterizedConstructor(MethodBase method);

	public abstract Func<T> CreateDefaultConstructor<T>(Type type);

	public abstract Func<T, object> CreateGet<T>(PropertyInfo propertyInfo);

	public abstract Func<T, object> CreateGet<T>(FieldInfo fieldInfo);

	public abstract Action<T, object> CreateSet<T>(FieldInfo fieldInfo);

	public abstract Action<T, object> CreateSet<T>(PropertyInfo propertyInfo);
}


using System;
using System.Reflection;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class LateBoundReflectionDelegateFactory : ReflectionDelegateFactory
{
	private static readonly LateBoundReflectionDelegateFactory _instance = new LateBoundReflectionDelegateFactory();

	internal static ReflectionDelegateFactory Instance => _instance;

	public override ObjectConstructor<object> CreateParameterizedConstructor(MethodBase method)
	{
		ValidationUtils.ArgumentNotNull(method, "method");
		ConstructorInfo c = method as ConstructorInfo;
		if ((object)c != null)
		{
			return (object[] a) => c.Invoke(a);
		}
		return (object[] a) => method.Invoke(null, a);
	}

	public override MethodCall<T, object> CreateMethodCall<T>(MethodBase method)
	{
		ValidationUtils.ArgumentNotNull(method, "method");
		ConstructorInfo c = method as ConstructorInfo;
		if ((object)c != null)
		{
			return (T o, object[] a) => c.Invoke(a);
		}
		return (T o, object[] a) => method.Invoke(o, a);
	}

	public override Func<T> CreateDefaultConstructor<T>(Type type)
	{
		ValidationUtils.ArgumentNotNull(type, "type");
		if (type.IsValueType())
		{
			return () => (T)Activator.CreateInstance(type);
		}
		ConstructorInfo constructorInfo = ReflectionUtils.GetDefaultConstructor(type, nonPublic: true);
		return () => (T)constructorInfo.Invoke(null);
	}

	public override Func<T, object> CreateGet<T>(PropertyInfo propertyInfo)
	{
		ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
		return (T o) => propertyInfo.GetValue(o, null);
	}

	public override Func<T, object> CreateGet<T>(FieldInfo fieldInfo)
	{
		ValidationUtils.ArgumentNotNull(fieldInfo, "fieldInfo");
		return (T o) => fieldInfo.GetValue(o);
	}

	public override Action<T, object> CreateSet<T>(FieldInfo fieldInfo)
	{
		ValidationUtils.ArgumentNotNull(fieldInfo, "fieldInfo");
		return delegate(T o, object v)
		{
			fieldInfo.SetValue(o, v);
		};
	}

	public override Action<T, object> CreateSet<T>(PropertyInfo propertyInfo)
	{
		ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
		return delegate(T o, object v)
		{
			propertyInfo.SetValue(o, v, null);
		};
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
internal delegate TResult MethodCall<T, TResult>(T target, params object[] args);


using System;
using Newtonsoft.Json.Shims;

[Preserve]
internal class ReflectionMember
{
	public Type MemberType { get; set; }

	public Func<object, object> Getter { get; set; }

	public Action<object, object> Setter { get; set; }
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class ReflectionObject
{
	public ObjectConstructor<object> Creator { get; private set; }

	public IDictionary<string, ReflectionMember> Members { get; private set; }

	public ReflectionObject()
	{
		Members = new Dictionary<string, ReflectionMember>();
	}

	public object GetValue(object target, string member)
	{
		return Members[member].Getter(target);
	}

	public void SetValue(object target, string member, object value)
	{
		Members[member].Setter(target, value);
	}

	public Type GetType(string member)
	{
		return Members[member].MemberType;
	}

	public static ReflectionObject Create(Type t, params string[] memberNames)
	{
		return Create(t, null, memberNames);
	}

	public static ReflectionObject Create(Type t, MethodBase creator, params string[] memberNames)
	{
		ReflectionObject reflectionObject = new ReflectionObject();
		ReflectionDelegateFactory reflectionDelegateFactory = JsonTypeReflector.ReflectionDelegateFactory;
		if ((object)creator != null)
		{
			reflectionObject.Creator = reflectionDelegateFactory.CreateParameterizedConstructor(creator);
		}
		else if (ReflectionUtils.HasDefaultConstructor(t, nonPublic: false))
		{
			Func<object> ctor = reflectionDelegateFactory.CreateDefaultConstructor<object>(t);
			reflectionObject.Creator = (object[] args) => ctor();
		}
		foreach (string text in memberNames)
		{
			MemberInfo[] member = t.GetMember(text, BindingFlags.Instance | BindingFlags.Public);
			if (member.Length != 1)
			{
				throw new ArgumentException("Expected a single member with the name '{0}'.".FormatWith(CultureInfo.InvariantCulture, text));
			}
			MemberInfo memberInfo = member.Single();
			ReflectionMember reflectionMember = new ReflectionMember();
			switch (memberInfo.MemberType())
			{
			case MemberTypes.Field:
			case MemberTypes.Property:
				if (ReflectionUtils.CanReadMemberValue(memberInfo, nonPublic: false))
				{
					reflectionMember.Getter = reflectionDelegateFactory.CreateGet<object>(memberInfo);
				}
				if (ReflectionUtils.CanSetMemberValue(memberInfo, nonPublic: false, canSetReadOnly: false))
				{
					reflectionMember.Setter = reflectionDelegateFactory.CreateSet<object>(memberInfo);
				}
				break;
			case MemberTypes.Method:
			{
				MethodInfo methodInfo = (MethodInfo)memberInfo;
				if (!methodInfo.IsPublic)
				{
					break;
				}
				ParameterInfo[] parameters = methodInfo.GetParameters();
				if (parameters.Length == 0 && (object)methodInfo.ReturnType != typeof(void))
				{
					MethodCall<object, object> call = reflectionDelegateFactory.CreateMethodCall<object>(methodInfo);
					reflectionMember.Getter = (object target) => call(target);
				}
				else if (parameters.Length == 1 && (object)methodInfo.ReturnType == typeof(void))
				{
					MethodCall<object, object> call2 = reflectionDelegateFactory.CreateMethodCall<object>(methodInfo);
					reflectionMember.Setter = delegate(object target, object arg)
					{
						call2(target, arg);
					};
				}
				break;
			}
			default:
				throw new ArgumentException("Unexpected member type '{0}' for member '{1}'.".FormatWith(CultureInfo.InvariantCulture, memberInfo.MemberType(), memberInfo.Name));
			}
			if (ReflectionUtils.CanReadMemberValue(memberInfo, nonPublic: false))
			{
				reflectionMember.Getter = reflectionDelegateFactory.CreateGet<object>(memberInfo);
			}
			if (ReflectionUtils.CanSetMemberValue(memberInfo, nonPublic: false, canSetReadOnly: false))
			{
				reflectionMember.Setter = reflectionDelegateFactory.CreateSet<object>(memberInfo);
			}
			reflectionMember.MemberType = ReflectionUtils.GetMemberUnderlyingType(memberInfo);
			reflectionObject.Members[text] = reflectionMember;
		}
		return reflectionObject;
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
internal struct StringReference
{
	private readonly char[] _chars;

	private readonly int _startIndex;

	private readonly int _length;

	public char this[int i] => _chars[i];

	public char[] Chars => _chars;

	public int StartIndex => _startIndex;

	public int Length => _length;

	public StringReference(char[] chars, int startIndex, int length)
	{
		_chars = chars;
		_startIndex = startIndex;
		_length = length;
	}

	public override string ToString()
	{
		return new string(_chars, _startIndex, _length);
	}
}


using System;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal static class StringReferenceExtensions
{
	public static int IndexOf(this StringReference s, char c, int startIndex, int length)
	{
		int num = Array.IndexOf(s.Chars, c, s.StartIndex + startIndex, length);
		if (num == -1)
		{
			return -1;
		}
		return num - s.StartIndex;
	}

	public static bool StartsWith(this StringReference s, string text)
	{
		if (text.Length > s.Length)
		{
			return false;
		}
		char[] chars = s.Chars;
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i] != chars[i + s.StartIndex])
			{
				return false;
			}
		}
		return true;
	}

	public static bool EndsWith(this StringReference s, string text)
	{
		if (text.Length > s.Length)
		{
			return false;
		}
		char[] chars = s.Chars;
		int num = s.StartIndex + s.Length - text.Length;
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i] != chars[i + num])
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using System.Collections.Generic;
using Newtonsoft.Json.Shims;

[Preserve]
internal class ThreadSafeStore<TKey, TValue>
{
	private readonly object _lock = new object();

	private Dictionary<TKey, TValue> _store;

	private readonly Func<TKey, TValue> _creator;

	[Preserve]
	public ThreadSafeStore(Func<TKey, TValue> creator)
	{
		if (creator == null)
		{
			throw new ArgumentNullException("creator");
		}
		_creator = creator;
		_store = new Dictionary<TKey, TValue>();
	}

	[Preserve]
	public TValue Get(TKey key)
	{
		if (!_store.TryGetValue(key, out var value))
		{
			return AddValue(key);
		}
		return value;
	}

	[Preserve]
	private TValue AddValue(TKey key)
	{
		TValue val = _creator(key);
		lock (_lock)
		{
			if (_store == null)
			{
				_store = new Dictionary<TKey, TValue>();
				_store[key] = val;
			}
			else
			{
				if (_store.TryGetValue(key, out var value))
				{
					return value;
				}
				Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>(_store);
				dictionary[key] = val;
				_store = dictionary;
			}
			return val;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class BidirectionalDictionary<TFirst, TSecond>
{
	private readonly IDictionary<TFirst, TSecond> _firstToSecond;

	private readonly IDictionary<TSecond, TFirst> _secondToFirst;

	private readonly string _duplicateFirstErrorMessage;

	private readonly string _duplicateSecondErrorMessage;

	public BidirectionalDictionary()
		: this((IEqualityComparer<TFirst>)EqualityComparer<TFirst>.Default, (IEqualityComparer<TSecond>)EqualityComparer<TSecond>.Default)
	{
	}

	public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer)
		: this(firstEqualityComparer, secondEqualityComparer, "Duplicate item already exists for '{0}'.", "Duplicate item already exists for '{0}'.")
	{
	}

	public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage)
	{
		_firstToSecond = new Dictionary<TFirst, TSecond>(firstEqualityComparer);
		_secondToFirst = new Dictionary<TSecond, TFirst>(secondEqualityComparer);
		_duplicateFirstErrorMessage = duplicateFirstErrorMessage;
		_duplicateSecondErrorMessage = duplicateSecondErrorMessage;
	}

	public void Set(TFirst first, TSecond second)
	{
		if (_firstToSecond.TryGetValue(first, out var value) && !value.Equals(second))
		{
			throw new ArgumentException(_duplicateFirstErrorMessage.FormatWith(CultureInfo.InvariantCulture, first));
		}
		if (_secondToFirst.TryGetValue(second, out var value2) && !value2.Equals(first))
		{
			throw new ArgumentException(_duplicateSecondErrorMessage.FormatWith(CultureInfo.InvariantCulture, second));
		}
		_firstToSecond.Add(first, second);
		_secondToFirst.Add(second, first);
	}

	public bool TryGetByFirst(TFirst first, out TSecond second)
	{
		return _firstToSecond.TryGetValue(first, out second);
	}

	public bool TryGetBySecond(TSecond second, out TFirst first)
	{
		return _secondToFirst.TryGetValue(second, out first);
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
internal enum PrimitiveTypeCode
{
	Empty,
	Object,
	Char,
	CharNullable,
	Boolean,
	BooleanNullable,
	SByte,
	SByteNullable,
	Int16,
	Int16Nullable,
	UInt16,
	UInt16Nullable,
	Int32,
	Int32Nullable,
	Byte,
	ByteNullable,
	UInt32,
	UInt32Nullable,
	Int64,
	Int64Nullable,
	UInt64,
	UInt64Nullable,
	Single,
	SingleNullable,
	Double,
	DoubleNullable,
	DateTime,
	DateTimeNullable,
	DateTimeOffset,
	DateTimeOffsetNullable,
	Decimal,
	DecimalNullable,
	Guid,
	GuidNullable,
	TimeSpan,
	TimeSpanNullable,
	BigInteger,
	BigIntegerNullable,
	Uri,
	String,
	Bytes,
	DBNull
}


using System;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class TypeInformation
{
	public Type Type { get; set; }

	public PrimitiveTypeCode TypeCode { get; set; }
}


using Newtonsoft.Json.Shims;

[Preserve]
internal enum ParseResult
{
	None,
	Success,
	Overflow,
	Invalid
}


using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Reflection;
using System.Text.RegularExpressions;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal static class ConvertUtils
{
	internal struct TypeConvertKey
	{
		private readonly Type _initialType;

		private readonly Type _targetType;

		public Type InitialType => _initialType;

		public Type TargetType => _targetType;

		public TypeConvertKey(Type initialType, Type targetType)
		{
			_initialType = initialType;
			_targetType = targetType;
		}

		public override int GetHashCode()
		{
			return _initialType.GetHashCode() ^ _targetType.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (!(obj is TypeConvertKey))
			{
				return false;
			}
			return Equals((TypeConvertKey)obj);
		}

		public bool Equals(TypeConvertKey other)
		{
			if ((object)_initialType == other._initialType)
			{
				return (object)_targetType == other._targetType;
			}
			return false;
		}
	}

	internal enum ConvertResult
	{
		Success,
		CannotConvertNull,
		NotInstantiableType,
		NoValidConversion
	}

	private static readonly Dictionary<Type, PrimitiveTypeCode> TypeCodeMap = new Dictionary<Type, PrimitiveTypeCode>
	{
		{
			typeof(char),
			PrimitiveTypeCode.Char
		},
		{
			typeof(char?),
			PrimitiveTypeCode.CharNullable
		},
		{
			typeof(bool),
			PrimitiveTypeCode.Boolean
		},
		{
			typeof(bool?),
			PrimitiveTypeCode.BooleanNullable
		},
		{
			typeof(sbyte),
			PrimitiveTypeCode.SByte
		},
		{
			typeof(sbyte?),
			PrimitiveTypeCode.SByteNullable
		},
		{
			typeof(short),
			PrimitiveTypeCode.Int16
		},
		{
			typeof(short?),
			PrimitiveTypeCode.Int16Nullable
		},
		{
			typeof(ushort),
			PrimitiveTypeCode.UInt16
		},
		{
			typeof(ushort?),
			PrimitiveTypeCode.UInt16Nullable
		},
		{
			typeof(int),
			PrimitiveTypeCode.Int32
		},
		{
			typeof(int?),
			PrimitiveTypeCode.Int32Nullable
		},
		{
			typeof(byte),
			PrimitiveTypeCode.Byte
		},
		{
			typeof(byte?),
			PrimitiveTypeCode.ByteNullable
		},
		{
			typeof(uint),
			PrimitiveTypeCode.UInt32
		},
		{
			typeof(uint?),
			PrimitiveTypeCode.UInt32Nullable
		},
		{
			typeof(long),
			PrimitiveTypeCode.Int64
		},
		{
			typeof(long?),
			PrimitiveTypeCode.Int64Nullable
		},
		{
			typeof(ulong),
			PrimitiveTypeCode.UInt64
		},
		{
			typeof(ulong?),
			PrimitiveTypeCode.UInt64Nullable
		},
		{
			typeof(float),
			PrimitiveTypeCode.Single
		},
		{
			typeof(float?),
			PrimitiveTypeCode.SingleNullable
		},
		{
			typeof(double),
			PrimitiveTypeCode.Double
		},
		{
			typeof(double?),
			PrimitiveTypeCode.DoubleNullable
		},
		{
			typeof(DateTime),
			PrimitiveTypeCode.DateTime
		},
		{
			typeof(DateTime?),
			PrimitiveTypeCode.DateTimeNullable
		},
		{
			typeof(DateTimeOffset),
			PrimitiveTypeCode.DateTimeOffset
		},
		{
			typeof(DateTimeOffset?),
			PrimitiveTypeCode.DateTimeOffsetNullable
		},
		{
			typeof(decimal),
			PrimitiveTypeCode.Decimal
		},
		{
			typeof(decimal?),
			PrimitiveTypeCode.DecimalNullable
		},
		{
			typeof(Guid),
			PrimitiveTypeCode.Guid
		},
		{
			typeof(Guid?),
			PrimitiveTypeCode.GuidNullable
		},
		{
			typeof(TimeSpan),
			PrimitiveTypeCode.TimeSpan
		},
		{
			typeof(TimeSpan?),
			PrimitiveTypeCode.TimeSpanNullable
		},
		{
			typeof(Uri),
			PrimitiveTypeCode.Uri
		},
		{
			typeof(string),
			PrimitiveTypeCode.String
		},
		{
			typeof(byte[]),
			PrimitiveTypeCode.Bytes
		},
		{
			typeof(DBNull),
			PrimitiveTypeCode.DBNull
		}
	};

	private static readonly TypeInformation[] PrimitiveTypeCodes = new TypeInformation[19]
	{
		new TypeInformation
		{
			Type = typeof(object),
			TypeCode = PrimitiveTypeCode.Empty
		},
		new TypeInformation
		{
			Type = typeof(object),
			TypeCode = PrimitiveTypeCode.Object
		},
		new TypeInformation
		{
			Type = typeof(object),
			TypeCode = PrimitiveTypeCode.DBNull
		},
		new TypeInformation
		{
			Type = typeof(bool),
			TypeCode = PrimitiveTypeCode.Boolean
		},
		new TypeInformation
		{
			Type = typeof(char),
			TypeCode = PrimitiveTypeCode.Char
		},
		new TypeInformation
		{
			Type = typeof(sbyte),
			TypeCode = PrimitiveTypeCode.SByte
		},
		new TypeInformation
		{
			Type = typeof(byte),
			TypeCode = PrimitiveTypeCode.Byte
		},
		new TypeInformation
		{
			Type = typeof(short),
			TypeCode = PrimitiveTypeCode.Int16
		},
		new TypeInformation
		{
			Type = typeof(ushort),
			TypeCode = PrimitiveTypeCode.UInt16
		},
		new TypeInformation
		{
			Type = typeof(int),
			TypeCode = PrimitiveTypeCode.Int32
		},
		new TypeInformation
		{
			Type = typeof(uint),
			TypeCode = PrimitiveTypeCode.UInt32
		},
		new TypeInformation
		{
			Type = typeof(long),
			TypeCode = PrimitiveTypeCode.Int64
		},
		new TypeInformation
		{
			Type = typeof(ulong),
			TypeCode = PrimitiveTypeCode.UInt64
		},
		new TypeInformation
		{
			Type = typeof(float),
			TypeCode = PrimitiveTypeCode.Single
		},
		new TypeInformation
		{
			Type = typeof(double),
			TypeCode = PrimitiveTypeCode.Double
		},
		new TypeInformation
		{
			Type = typeof(decimal),
			TypeCode = PrimitiveTypeCode.Decimal
		},
		new TypeInformation
		{
			Type = typeof(DateTime),
			TypeCode = PrimitiveTypeCode.DateTime
		},
		new TypeInformation
		{
			Type = typeof(object),
			TypeCode = PrimitiveTypeCode.Empty
		},
		new TypeInformation
		{
			Type = typeof(string),
			TypeCode = PrimitiveTypeCode.String
		}
	};

	private static readonly ThreadSafeStore<TypeConvertKey, Func<object, object>> CastConverters = new ThreadSafeStore<TypeConvertKey, Func<object, object>>(CreateCastConverter);

	public static PrimitiveTypeCode GetTypeCode(Type t)
	{
		bool isEnum;
		return GetTypeCode(t, out isEnum);
	}

	public static PrimitiveTypeCode GetTypeCode(Type t, out bool isEnum)
	{
		if (TypeCodeMap.TryGetValue(t, out var value))
		{
			isEnum = false;
			return value;
		}
		if (t.IsEnum())
		{
			isEnum = true;
			return GetTypeCode(Enum.GetUnderlyingType(t));
		}
		if (ReflectionUtils.IsNullableType(t))
		{
			Type underlyingType = Nullable.GetUnderlyingType(t);
			if (underlyingType.IsEnum())
			{
				Type t2 = typeof(Nullable<>).MakeGenericType(Enum.GetUnderlyingType(underlyingType));
				isEnum = true;
				return GetTypeCode(t2);
			}
		}
		isEnum = false;
		return PrimitiveTypeCode.Object;
	}

	public static TypeInformation GetTypeInformation(IConvertible convertable)
	{
		return PrimitiveTypeCodes[(int)convertable.GetTypeCode()];
	}

	public static bool IsConvertible(Type t)
	{
		return typeof(IConvertible).IsAssignableFrom(t);
	}

	public static TimeSpan ParseTimeSpan(string input)
	{
		return TimeSpan.Parse(input);
	}

	private static Func<object, object> CreateCastConverter(TypeConvertKey t)
	{
		MethodInfo method = t.TargetType.GetMethod("op_Implicit", new Type[1] { t.InitialType });
		if ((object)method == null)
		{
			method = t.TargetType.GetMethod("op_Explicit", new Type[1] { t.InitialType });
		}
		if ((object)method == null)
		{
			return null;
		}
		MethodCall<object, object> call = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
		return (object o) => call(null, o);
	}

	public static object Convert(object initialValue, CultureInfo culture, Type targetType)
	{
		object value;
		return TryConvertInternal(initialValue, culture, targetType, out value) switch
		{
			ConvertResult.Success => value, 
			ConvertResult.CannotConvertNull => throw new Exception("Can not convert null {0} into non-nullable {1}.".FormatWith(CultureInfo.InvariantCulture, initialValue.GetType(), targetType)), 
			ConvertResult.NotInstantiableType => throw new ArgumentException("Target type {0} is not a value type or a non-abstract class.".FormatWith(CultureInfo.InvariantCulture, targetType), "targetType"), 
			ConvertResult.NoValidConversion => throw new InvalidOperationException("Can not convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, initialValue.GetType(), targetType)), 
			_ => throw new InvalidOperationException("Unexpected conversion result."), 
		};
	}

	private static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, out object value)
	{
		try
		{
			if (TryConvertInternal(initialValue, culture, targetType, out value) == ConvertResult.Success)
			{
				return true;
			}
			value = null;
			return false;
		}
		catch
		{
			value = null;
			return false;
		}
	}

	private static ConvertResult TryConvertInternal(object initialValue, CultureInfo culture, Type targetType, out object value)
	{
		if (initialValue == null)
		{
			throw new ArgumentNullException("initialValue");
		}
		if (ReflectionUtils.IsNullableType(targetType))
		{
			targetType = Nullable.GetUnderlyingType(targetType);
		}
		Type type = initialValue.GetType();
		if ((object)targetType == type)
		{
			value = initialValue;
			return ConvertResult.Success;
		}
		if (IsConvertible(initialValue.GetType()) && IsConvertible(targetType))
		{
			if (targetType.IsEnum())
			{
				if (initialValue is string)
				{
					value = Enum.Parse(targetType, initialValue.ToString(), ignoreCase: true);
					return ConvertResult.Success;
				}
				if (IsInteger(initialValue))
				{
					value = Enum.ToObject(targetType, initialValue);
					return ConvertResult.Success;
				}
			}
			value = System.Convert.ChangeType(initialValue, targetType, culture);
			return ConvertResult.Success;
		}
		if (initialValue is DateTime && (object)targetType == typeof(DateTimeOffset))
		{
			value = new DateTimeOffset((DateTime)initialValue);
			return ConvertResult.Success;
		}
		if (initialValue is byte[] && (object)targetType == typeof(Guid))
		{
			value = new Guid((byte[])initialValue);
			return ConvertResult.Success;
		}
		if (initialValue is Guid && (object)targetType == typeof(byte[]))
		{
			value = ((Guid)initialValue).ToByteArray();
			return ConvertResult.Success;
		}
		if (initialValue is string text)
		{
			if ((object)targetType == typeof(Guid))
			{
				value = new Guid(text);
				return ConvertResult.Success;
			}
			if ((object)targetType == typeof(Uri))
			{
				value = new Uri(text, UriKind.RelativeOrAbsolute);
				return ConvertResult.Success;
			}
			if ((object)targetType == typeof(TimeSpan))
			{
				value = ParseTimeSpan(text);
				return ConvertResult.Success;
			}
			if ((object)targetType == typeof(byte[]))
			{
				value = System.Convert.FromBase64String(text);
				return ConvertResult.Success;
			}
			if ((object)targetType == typeof(Version))
			{
				if (VersionTryParse(text, out var result))
				{
					value = result;
					return ConvertResult.Success;
				}
				value = null;
				return ConvertResult.NoValidConversion;
			}
			if (typeof(Type).IsAssignableFrom(targetType))
			{
				value = Type.GetType(text, throwOnError: true);
				return ConvertResult.Success;
			}
		}
		TypeConverter converter = GetConverter(type);
		if (converter != null && converter.CanConvertTo(targetType))
		{
			value = converter.ConvertTo(null, culture, initialValue, targetType);
			return ConvertResult.Success;
		}
		TypeConverter converter2 = GetConverter(targetType);
		if (converter2 != null && converter2.CanConvertFrom(type))
		{
			value = converter2.ConvertFrom(null, culture, initialValue);
			return ConvertResult.Success;
		}
		if (initialValue == DBNull.Value)
		{
			if (ReflectionUtils.IsNullable(targetType))
			{
				value = EnsureTypeAssignable(null, type, targetType);
				return ConvertResult.Success;
			}
			value = null;
			return ConvertResult.CannotConvertNull;
		}
		if (targetType.IsInterface() || targetType.IsGenericTypeDefinition() || targetType.IsAbstract())
		{
			value = null;
			return ConvertResult.NotInstantiableType;
		}
		value = null;
		return ConvertResult.NoValidConversion;
	}

	public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType)
	{
		if ((object)targetType == typeof(object))
		{
			return initialValue;
		}
		if (initialValue == null && ReflectionUtils.IsNullable(targetType))
		{
			return null;
		}
		if (TryConvert(initialValue, culture, targetType, out var value))
		{
			return value;
		}
		return EnsureTypeAssignable(initialValue, ReflectionUtils.GetObjectType(initialValue), targetType);
	}

	private static object EnsureTypeAssignable(object value, Type initialType, Type targetType)
	{
		Type type = value?.GetType();
		if (value != null)
		{
			if (targetType.IsAssignableFrom(type))
			{
				return value;
			}
			Func<object, object> func = CastConverters.Get(new TypeConvertKey(type, targetType));
			if (func != null)
			{
				return func(value);
			}
		}
		else if (ReflectionUtils.IsNullable(targetType))
		{
			return null;
		}
		throw new ArgumentException("Could not cast or convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, ((object)initialType != null) ? initialType.ToString() : "{null}", targetType));
	}

	internal static TypeConverter GetConverter(Type t)
	{
		return JsonTypeReflector.GetTypeConverter(t);
	}

	public static bool VersionTryParse(string input, out Version result)
	{
		try
		{
			result = new Version(input);
			return true;
		}
		catch
		{
			result = null;
			return false;
		}
	}

	public static bool IsInteger(object value)
	{
		switch (GetTypeCode(value.GetType()))
		{
		case PrimitiveTypeCode.SByte:
		case PrimitiveTypeCode.Int16:
		case PrimitiveTypeCode.UInt16:
		case PrimitiveTypeCode.Int32:
		case PrimitiveTypeCode.Byte:
		case PrimitiveTypeCode.UInt32:
		case PrimitiveTypeCode.Int64:
		case PrimitiveTypeCode.UInt64:
			return true;
		default:
			return false;
		}
	}

	public static ParseResult Int32TryParse(char[] chars, int start, int length, out int value)
	{
		value = 0;
		if (length == 0)
		{
			return ParseResult.Invalid;
		}
		bool flag = chars[start] == '-';
		if (flag)
		{
			if (length == 1)
			{
				return ParseResult.Invalid;
			}
			start++;
			length--;
		}
		int num = start + length;
		if (length > 10 || (length == 10 && chars[start] - 48 > 2))
		{
			for (int i = start; i < num; i++)
			{
				int num2 = chars[i] - 48;
				if (num2 < 0 || num2 > 9)
				{
					return ParseResult.Invalid;
				}
			}
			return ParseResult.Overflow;
		}
		for (int j = start; j < num; j++)
		{
			int num3 = chars[j] - 48;
			if (num3 < 0 || num3 > 9)
			{
				return ParseResult.Invalid;
			}
			int num4 = 10 * value - num3;
			if (num4 > value)
			{
				for (j++; j < num; j++)
				{
					num3 = chars[j] - 48;
					if (num3 < 0 || num3 > 9)
					{
						return ParseResult.Invalid;
					}
				}
				return ParseResult.Overflow;
			}
			value = num4;
		}
		if (!flag)
		{
			if (value == int.MinValue)
			{
				return ParseResult.Overflow;
			}
			value = -value;
		}
		return ParseResult.Success;
	}

	public static ParseResult Int64TryParse(char[] chars, int start, int length, out long value)
	{
		value = 0L;
		if (length == 0)
		{
			return ParseResult.Invalid;
		}
		bool flag = chars[start] == '-';
		if (flag)
		{
			if (length == 1)
			{
				return ParseResult.Invalid;
			}
			start++;
			length--;
		}
		int num = start + length;
		if (length > 19)
		{
			for (int i = start; i < num; i++)
			{
				int num2 = chars[i] - 48;
				if (num2 < 0 || num2 > 9)
				{
					return ParseResult.Invalid;
				}
			}
			return ParseResult.Overflow;
		}
		for (int j = start; j < num; j++)
		{
			int num3 = chars[j] - 48;
			if (num3 < 0 || num3 > 9)
			{
				return ParseResult.Invalid;
			}
			long num4 = 10 * value - num3;
			if (num4 > value)
			{
				for (j++; j < num; j++)
				{
					num3 = chars[j] - 48;
					if (num3 < 0 || num3 > 9)
					{
						return ParseResult.Invalid;
					}
				}
				return ParseResult.Overflow;
			}
			value = num4;
		}
		if (!flag)
		{
			if (value == long.MinValue)
			{
				return ParseResult.Overflow;
			}
			value = -value;
		}
		return ParseResult.Success;
	}

	public static bool TryConvertGuid(string s, out Guid g)
	{
		if (s == null)
		{
			throw new ArgumentNullException("s");
		}
		if (new Regex("^[A-Fa-f0-9]{8}-([A-Fa-f0-9]{4}-){3}[A-Fa-f0-9]{12}$").Match(s).Success)
		{
			g = new Guid(s);
			return true;
		}
		g = Guid.Empty;
		return false;
	}

	public static int HexTextToInt(char[] text, int start, int end)
	{
		int num = 0;
		for (int i = start; i < end; i++)
		{
			num += HexCharToInt(text[i]) << (end - 1 - i) * 4;
		}
		return num;
	}

	private static int HexCharToInt(char ch)
	{
		if (ch <= '9' && ch >= '0')
		{
			return ch - 48;
		}
		if (ch <= 'F' && ch >= 'A')
		{
			return ch - 55;
		}
		if (ch <= 'f' && ch >= 'a')
		{
			return ch - 87;
		}
		throw new FormatException("Invalid hex character: " + ch);
	}
}


using System;

internal struct TypeConvertKey
{
	private readonly Type _initialType;

	private readonly Type _targetType;

	public Type InitialType => _initialType;

	public Type TargetType => _targetType;

	public TypeConvertKey(Type initialType, Type targetType)
	{
		_initialType = initialType;
		_targetType = targetType;
	}

	public override int GetHashCode()
	{
		return _initialType.GetHashCode() ^ _targetType.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (!(obj is TypeConvertKey))
		{
			return false;
		}
		return Equals((TypeConvertKey)obj);
	}

	public bool Equals(TypeConvertKey other)
	{
		if ((object)_initialType == other._initialType)
		{
			return (object)_targetType == other._targetType;
		}
		return false;
	}
}


internal enum ConvertResult
{
	Success,
	CannotConvertNull,
	NotInstantiableType,
	NoValidConversion
}


using System.Collections;
using Newtonsoft.Json.Shims;

[Preserve]
internal interface IWrappedCollection : IList, ICollection, IEnumerable
{
	object UnderlyingCollection { get; }
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class CollectionWrapper<T> : ICollection<T>, IEnumerable<T>, IEnumerable, IWrappedCollection, IList, ICollection
{
	private readonly IList _list;

	private readonly ICollection<T> _genericCollection;

	private object _syncRoot;

	public virtual int Count
	{
		get
		{
			if (_genericCollection != null)
			{
				return _genericCollection.Count;
			}
			return _list.Count;
		}
	}

	public virtual bool IsReadOnly
	{
		get
		{
			if (_genericCollection != null)
			{
				return _genericCollection.IsReadOnly;
			}
			return _list.IsReadOnly;
		}
	}

	bool IList.IsFixedSize
	{
		get
		{
			if (_genericCollection != null)
			{
				return _genericCollection.IsReadOnly;
			}
			return _list.IsFixedSize;
		}
	}

	object IList.this[int index]
	{
		get
		{
			if (_genericCollection != null)
			{
				throw new InvalidOperationException("Wrapped ICollection<T> does not support indexer.");
			}
			return _list[index];
		}
		set
		{
			if (_genericCollection != null)
			{
				throw new InvalidOperationException("Wrapped ICollection<T> does not support indexer.");
			}
			VerifyValueType(value);
			_list[index] = (T)value;
		}
	}

	bool ICollection.IsSynchronized => false;

	object ICollection.SyncRoot
	{
		get
		{
			if (_syncRoot == null)
			{
				Interlocked.CompareExchange(ref _syncRoot, new object(), null);
			}
			return _syncRoot;
		}
	}

	public object UnderlyingCollection
	{
		get
		{
			if (_genericCollection != null)
			{
				return _genericCollection;
			}
			return _list;
		}
	}

	public CollectionWrapper(IList list)
	{
		ValidationUtils.ArgumentNotNull(list, "list");
		if (list is ICollection<T>)
		{
			_genericCollection = (ICollection<T>)list;
		}
		else
		{
			_list = list;
		}
	}

	public CollectionWrapper(ICollection<T> list)
	{
		ValidationUtils.ArgumentNotNull(list, "list");
		_genericCollection = list;
	}

	public virtual void Add(T item)
	{
		if (_genericCollection != null)
		{
			_genericCollection.Add(item);
		}
		else
		{
			_list.Add(item);
		}
	}

	public virtual void Clear()
	{
		if (_genericCollection != null)
		{
			_genericCollection.Clear();
		}
		else
		{
			_list.Clear();
		}
	}

	public virtual bool Contains(T item)
	{
		if (_genericCollection != null)
		{
			return _genericCollection.Contains(item);
		}
		return _list.Contains(item);
	}

	public virtual void CopyTo(T[] array, int arrayIndex)
	{
		if (_genericCollection != null)
		{
			_genericCollection.CopyTo(array, arrayIndex);
		}
		else
		{
			_list.CopyTo(array, arrayIndex);
		}
	}

	public virtual bool Remove(T item)
	{
		if (_genericCollection != null)
		{
			return _genericCollection.Remove(item);
		}
		bool num = _list.Contains(item);
		if (num)
		{
			_list.Remove(item);
		}
		return num;
	}

	public virtual IEnumerator<T> GetEnumerator()
	{
		if (_genericCollection != null)
		{
			return _genericCollection.GetEnumerator();
		}
		return _list.Cast<T>().GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		if (_genericCollection != null)
		{
			return _genericCollection.GetEnumerator();
		}
		return _list.GetEnumerator();
	}

	int IList.Add(object value)
	{
		VerifyValueType(value);
		Add((T)value);
		return Count - 1;
	}

	bool IList.Contains(object value)
	{
		if (IsCompatibleObject(value))
		{
			return Contains((T)value);
		}
		return false;
	}

	int IList.IndexOf(object value)
	{
		if (_genericCollection != null)
		{
			throw new InvalidOperationException("Wrapped ICollection<T> does not support IndexOf.");
		}
		if (IsCompatibleObject(value))
		{
			return _list.IndexOf((T)value);
		}
		return -1;
	}

	void IList.RemoveAt(int index)
	{
		if (_genericCollection != null)
		{
			throw new InvalidOperationException("Wrapped ICollection<T> does not support RemoveAt.");
		}
		_list.RemoveAt(index);
	}

	void IList.Insert(int index, object value)
	{
		if (_genericCollection != null)
		{
			throw new InvalidOperationException("Wrapped ICollection<T> does not support Insert.");
		}
		VerifyValueType(value);
		_list.Insert(index, (T)value);
	}

	void IList.Remove(object value)
	{
		if (IsCompatibleObject(value))
		{
			Remove((T)value);
		}
	}

	void ICollection.CopyTo(Array array, int arrayIndex)
	{
		CopyTo((T[])array, arrayIndex);
	}

	private static void VerifyValueType(object value)
	{
		if (!IsCompatibleObject(value))
		{
			throw new ArgumentException("The value '{0}' is not of type '{1}' and cannot be used in this generic collection.".FormatWith(CultureInfo.InvariantCulture, value, typeof(T)), "value");
		}
	}

	private static bool IsCompatibleObject(object value)
	{
		if (!(value is T) && (value != null || (typeof(T).IsValueType() && !ReflectionUtils.IsNullableType(typeof(T)))))
		{
			return false;
		}
		return true;
	}
}


using System;
using System.Globalization;
using System.IO;
using System.Xml;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal static class DateTimeUtils
{
	internal static readonly long InitialJavaScriptDateTicks;

	private const string IsoDateFormat = "yyyy-MM-ddTHH:mm:ss.FFFFFFFK";

	private const int DaysPer100Years = 36524;

	private const int DaysPer400Years = 146097;

	private const int DaysPer4Years = 1461;

	private const int DaysPerYear = 365;

	private const long TicksPerDay = 864000000000L;

	private static readonly int[] DaysToMonth365;

	private static readonly int[] DaysToMonth366;

	static DateTimeUtils()
	{
		InitialJavaScriptDateTicks = 621355968000000000L;
		DaysToMonth365 = new int[13]
		{
			0, 31, 59, 90, 120, 151, 181, 212, 243, 273,
			304, 334, 365
		};
		DaysToMonth366 = new int[13]
		{
			0, 31, 60, 91, 121, 152, 182, 213, 244, 274,
			305, 335, 366
		};
	}

	public static TimeSpan GetUtcOffset(this DateTime d)
	{
		return TimeZone.CurrentTimeZone.GetUtcOffset(d);
	}

	public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind)
	{
		return (XmlDateTimeSerializationMode)(kind switch
		{
			DateTimeKind.Local => 0, 
			DateTimeKind.Unspecified => 2, 
			DateTimeKind.Utc => 1, 
			_ => throw MiscellaneousUtils.CreateArgumentOutOfRangeException("kind", kind, "Unexpected DateTimeKind value."), 
		});
	}

	internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone)
	{
		switch (timeZone)
		{
		case DateTimeZoneHandling.Local:
			value = SwitchToLocalTime(value);
			break;
		case DateTimeZoneHandling.Utc:
			value = SwitchToUtcTime(value);
			break;
		case DateTimeZoneHandling.Unspecified:
			value = new DateTime(value.Ticks, DateTimeKind.Unspecified);
			break;
		default:
			throw new ArgumentException("Invalid date time handling value.");
		case DateTimeZoneHandling.RoundtripKind:
			break;
		}
		return value;
	}

	private static DateTime SwitchToLocalTime(DateTime value)
	{
		return value.Kind switch
		{
			DateTimeKind.Unspecified => new DateTime(value.Ticks, DateTimeKind.Local), 
			DateTimeKind.Utc => value.ToLocalTime(), 
			DateTimeKind.Local => value, 
			_ => value, 
		};
	}

	private static DateTime SwitchToUtcTime(DateTime value)
	{
		return value.Kind switch
		{
			DateTimeKind.Unspecified => new DateTime(value.Ticks, DateTimeKind.Utc), 
			DateTimeKind.Utc => value, 
			DateTimeKind.Local => value.ToUniversalTime(), 
			_ => value, 
		};
	}

	private static long ToUniversalTicks(DateTime dateTime)
	{
		if (dateTime.Kind == DateTimeKind.Utc)
		{
			return dateTime.Ticks;
		}
		return ToUniversalTicks(dateTime, dateTime.GetUtcOffset());
	}

	private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset)
	{
		if (dateTime.Kind == DateTimeKind.Utc || dateTime == DateTime.MaxValue || dateTime == DateTime.MinValue)
		{
			return dateTime.Ticks;
		}
		long num = dateTime.Ticks - offset.Ticks;
		if (num > 3155378975999999999L)
		{
			return 3155378975999999999L;
		}
		if (num < 0)
		{
			return 0L;
		}
		return num;
	}

	internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset)
	{
		return UniversialTicksToJavaScriptTicks(ToUniversalTicks(dateTime, offset));
	}

	internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime)
	{
		return ConvertDateTimeToJavaScriptTicks(dateTime, convertToUtc: true);
	}

	internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc)
	{
		return UniversialTicksToJavaScriptTicks(convertToUtc ? ToUniversalTicks(dateTime) : dateTime.Ticks);
	}

	private static long UniversialTicksToJavaScriptTicks(long universialTicks)
	{
		return (universialTicks - InitialJavaScriptDateTicks) / 10000;
	}

	internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks)
	{
		return new DateTime(javaScriptTicks * 10000 + InitialJavaScriptDateTicks, DateTimeKind.Utc);
	}

	internal static bool TryParseDateTimeIso(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, out DateTime dt)
	{
		DateTimeParser dateTimeParser = default(DateTimeParser);
		if (!dateTimeParser.Parse(text.Chars, text.StartIndex, text.Length))
		{
			dt = default(DateTime);
			return false;
		}
		DateTime dateTime = CreateDateTime(dateTimeParser);
		switch (dateTimeParser.Zone)
		{
		case ParserTimeZone.Utc:
			dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Utc);
			break;
		case ParserTimeZone.LocalWestOfUtc:
		{
			TimeSpan timeSpan2 = new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0);
			long num = dateTime.Ticks + timeSpan2.Ticks;
			long num4 = num;
			DateTime minValue = DateTime.MaxValue;
			if (num4 <= minValue.Ticks)
			{
				dateTime = new DateTime(num, DateTimeKind.Utc).ToLocalTime();
				break;
			}
			num += dateTime.GetUtcOffset().Ticks;
			long num5 = num;
			minValue = DateTime.MaxValue;
			if (num5 > minValue.Ticks)
			{
				minValue = DateTime.MaxValue;
				num = minValue.Ticks;
			}
			dateTime = new DateTime(num, DateTimeKind.Local);
			break;
		}
		case ParserTimeZone.LocalEastOfUtc:
		{
			TimeSpan timeSpan = new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0);
			long num = dateTime.Ticks - timeSpan.Ticks;
			long num2 = num;
			DateTime minValue = DateTime.MinValue;
			if (num2 >= minValue.Ticks)
			{
				dateTime = new DateTime(num, DateTimeKind.Utc).ToLocalTime();
				break;
			}
			num += dateTime.GetUtcOffset().Ticks;
			long num3 = num;
			minValue = DateTime.MinValue;
			if (num3 < minValue.Ticks)
			{
				minValue = DateTime.MinValue;
				num = minValue.Ticks;
			}
			dateTime = new DateTime(num, DateTimeKind.Local);
			break;
		}
		}
		dt = EnsureDateTime(dateTime, dateTimeZoneHandling);
		return true;
	}

	internal static bool TryParseDateTimeOffsetIso(StringReference text, out DateTimeOffset dt)
	{
		DateTimeParser dateTimeParser = default(DateTimeParser);
		if (!dateTimeParser.Parse(text.Chars, text.StartIndex, text.Length))
		{
			dt = default(DateTimeOffset);
			return false;
		}
		DateTime dateTime = CreateDateTime(dateTimeParser);
		TimeSpan offset = dateTimeParser.Zone switch
		{
			ParserTimeZone.Utc => new TimeSpan(0L), 
			ParserTimeZone.LocalWestOfUtc => new TimeSpan(-dateTimeParser.ZoneHour, -dateTimeParser.ZoneMinute, 0), 
			ParserTimeZone.LocalEastOfUtc => new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0), 
			_ => TimeZoneInfo.Local.GetUtcOffset(dateTime), 
		};
		long num = dateTime.Ticks - offset.Ticks;
		if (num < 0 || num > 3155378975999999999L)
		{
			dt = default(DateTimeOffset);
			return false;
		}
		dt = new DateTimeOffset(dateTime, offset);
		return true;
	}

	private static DateTime CreateDateTime(DateTimeParser dateTimeParser)
	{
		bool flag;
		if (dateTimeParser.Hour == 24)
		{
			flag = true;
			dateTimeParser.Hour = 0;
		}
		else
		{
			flag = false;
		}
		DateTime result = new DateTime(dateTimeParser.Year, dateTimeParser.Month, dateTimeParser.Day, dateTimeParser.Hour, dateTimeParser.Minute, dateTimeParser.Second).AddTicks(dateTimeParser.Fraction);
		if (flag)
		{
			result = result.AddDays(1.0);
		}
		return result;
	}

	internal static bool TryParseDateTime(StringReference s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, out DateTime dt)
	{
		if (s.Length > 0)
		{
			int startIndex = s.StartIndex;
			if (s[startIndex] == '/')
			{
				if (s.Length >= 9 && s.StartsWith("/Date(") && s.EndsWith(")/") && TryParseDateTimeMicrosoft(s, dateTimeZoneHandling, out dt))
				{
					return true;
				}
			}
			else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[startIndex]) && s[startIndex + 10] == 'T' && TryParseDateTimeIso(s, dateTimeZoneHandling, out dt))
			{
				return true;
			}
			if (!string.IsNullOrEmpty(dateFormatString) && TryParseDateTimeExact(s.ToString(), dateTimeZoneHandling, dateFormatString, culture, out dt))
			{
				return true;
			}
		}
		dt = default(DateTime);
		return false;
	}

	internal static bool TryParseDateTime(string s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, out DateTime dt)
	{
		if (s.Length > 0)
		{
			if (s[0] == '/')
			{
				if (s.Length >= 9 && s.StartsWith("/Date(", StringComparison.Ordinal) && s.EndsWith(")/", StringComparison.Ordinal) && TryParseDateTimeMicrosoft(new StringReference(s.ToCharArray(), 0, s.Length), dateTimeZoneHandling, out dt))
				{
					return true;
				}
			}
			else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[0]) && s[10] == 'T' && DateTime.TryParseExact(s, "yyyy-MM-ddTHH:mm:ss.FFFFFFFK", CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out dt))
			{
				dt = EnsureDateTime(dt, dateTimeZoneHandling);
				return true;
			}
			if (!string.IsNullOrEmpty(dateFormatString) && TryParseDateTimeExact(s, dateTimeZoneHandling, dateFormatString, culture, out dt))
			{
				return true;
			}
		}
		dt = default(DateTime);
		return false;
	}

	internal static bool TryParseDateTimeOffset(StringReference s, string dateFormatString, CultureInfo culture, out DateTimeOffset dt)
	{
		if (s.Length > 0)
		{
			int startIndex = s.StartIndex;
			if (s[startIndex] == '/')
			{
				if (s.Length >= 9 && s.StartsWith("/Date(") && s.EndsWith(")/") && TryParseDateTimeOffsetMicrosoft(s, out dt))
				{
					return true;
				}
			}
			else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[startIndex]) && s[startIndex + 10] == 'T' && TryParseDateTimeOffsetIso(s, out dt))
			{
				return true;
			}
			if (!string.IsNullOrEmpty(dateFormatString) && TryParseDateTimeOffsetExact(s.ToString(), dateFormatString, culture, out dt))
			{
				return true;
			}
		}
		dt = default(DateTimeOffset);
		return false;
	}

	internal static bool TryParseDateTimeOffset(string s, string dateFormatString, CultureInfo culture, out DateTimeOffset dt)
	{
		if (s.Length > 0)
		{
			if (s[0] == '/')
			{
				if (s.Length >= 9 && s.StartsWith("/Date(", StringComparison.Ordinal) && s.EndsWith(")/", StringComparison.Ordinal) && TryParseDateTimeOffsetMicrosoft(new StringReference(s.ToCharArray(), 0, s.Length), out dt))
				{
					return true;
				}
			}
			else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[0]) && s[10] == 'T' && DateTimeOffset.TryParseExact(s, "yyyy-MM-ddTHH:mm:ss.FFFFFFFK", CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out dt) && TryParseDateTimeOffsetIso(new StringReference(s.ToCharArray(), 0, s.Length), out dt))
			{
				return true;
			}
			if (!string.IsNullOrEmpty(dateFormatString) && TryParseDateTimeOffsetExact(s, dateFormatString, culture, out dt))
			{
				return true;
			}
		}
		dt = default(DateTimeOffset);
		return false;
	}

	private static bool TryParseMicrosoftDate(StringReference text, out long ticks, out TimeSpan offset, out DateTimeKind kind)
	{
		kind = DateTimeKind.Utc;
		int num = text.IndexOf('+', 7, text.Length - 8);
		if (num == -1)
		{
			num = text.IndexOf('-', 7, text.Length - 8);
		}
		if (num != -1)
		{
			kind = DateTimeKind.Local;
			if (!TryReadOffset(text, num + text.StartIndex, out offset))
			{
				ticks = 0L;
				return false;
			}
		}
		else
		{
			offset = TimeSpan.Zero;
			num = text.Length - 2;
		}
		return ConvertUtils.Int64TryParse(text.Chars, 6 + text.StartIndex, num - 6, out ticks) == ParseResult.Success;
	}

	private static bool TryParseDateTimeMicrosoft(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, out DateTime dt)
	{
		if (!TryParseMicrosoftDate(text, out var ticks, out var _, out var kind))
		{
			dt = default(DateTime);
			return false;
		}
		DateTime dateTime = ConvertJavaScriptTicksToDateTime(ticks);
		switch (kind)
		{
		case DateTimeKind.Unspecified:
			dt = DateTime.SpecifyKind(dateTime.ToLocalTime(), DateTimeKind.Unspecified);
			break;
		case DateTimeKind.Local:
			dt = dateTime.ToLocalTime();
			break;
		default:
			dt = dateTime;
			break;
		}
		dt = EnsureDateTime(dt, dateTimeZoneHandling);
		return true;
	}

	private static bool TryParseDateTimeExact(string text, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, out DateTime dt)
	{
		if (DateTime.TryParseExact(text, dateFormatString, culture, DateTimeStyles.RoundtripKind, out var result))
		{
			result = EnsureDateTime(result, dateTimeZoneHandling);
			dt = result;
			return true;
		}
		dt = default(DateTime);
		return false;
	}

	private static bool TryParseDateTimeOffsetMicrosoft(StringReference text, out DateTimeOffset dt)
	{
		if (!TryParseMicrosoftDate(text, out var ticks, out var offset, out var _))
		{
			dt = default(DateTime);
			return false;
		}
		dt = new DateTimeOffset(ConvertJavaScriptTicksToDateTime(ticks).Add(offset).Ticks, offset);
		return true;
	}

	private static bool TryParseDateTimeOffsetExact(string text, string dateFormatString, CultureInfo culture, out DateTimeOffset dt)
	{
		if (DateTimeOffset.TryParseExact(text, dateFormatString, culture, DateTimeStyles.RoundtripKind, out var result))
		{
			dt = result;
			return true;
		}
		dt = default(DateTimeOffset);
		return false;
	}

	private static bool TryReadOffset(StringReference offsetText, int startIndex, out TimeSpan offset)
	{
		bool flag = offsetText[startIndex] == '-';
		if (ConvertUtils.Int32TryParse(offsetText.Chars, startIndex + 1, 2, out var value) != ParseResult.Success)
		{
			offset = default(TimeSpan);
			return false;
		}
		int value2 = 0;
		if (offsetText.Length - startIndex > 5 && ConvertUtils.Int32TryParse(offsetText.Chars, startIndex + 3, 2, out value2) != ParseResult.Success)
		{
			offset = default(TimeSpan);
			return false;
		}
		offset = TimeSpan.FromHours(value) + TimeSpan.FromMinutes(value2);
		if (flag)
		{
			offset = offset.Negate();
		}
		return true;
	}

	internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture)
	{
		if (string.IsNullOrEmpty(formatString))
		{
			char[] array = new char[64];
			int count = WriteDateTimeString(array, 0, value, null, value.Kind, format);
			writer.Write(array, 0, count);
		}
		else
		{
			writer.Write(value.ToString(formatString, culture));
		}
	}

	internal static int WriteDateTimeString(char[] chars, int start, DateTime value, TimeSpan? offset, DateTimeKind kind, DateFormatHandling format)
	{
		int num = start;
		if (format == DateFormatHandling.MicrosoftDateFormat)
		{
			TimeSpan offset2 = offset ?? value.GetUtcOffset();
			long num2 = ConvertDateTimeToJavaScriptTicks(value, offset2);
			"\\/Date(".CopyTo(0, chars, num, 7);
			num += 7;
			string text = num2.ToString(CultureInfo.InvariantCulture);
			text.CopyTo(0, chars, num, text.Length);
			num += text.Length;
			switch (kind)
			{
			case DateTimeKind.Unspecified:
				if (value != DateTime.MaxValue && value != DateTime.MinValue)
				{
					num = WriteDateTimeOffset(chars, num, offset2, format);
				}
				break;
			case DateTimeKind.Local:
				num = WriteDateTimeOffset(chars, num, offset2, format);
				break;
			}
			")\\/".CopyTo(0, chars, num, 3);
			num += 3;
		}
		else
		{
			num = WriteDefaultIsoDate(chars, num, value);
			switch (kind)
			{
			case DateTimeKind.Local:
				num = WriteDateTimeOffset(chars, num, offset ?? value.GetUtcOffset(), format);
				break;
			case DateTimeKind.Utc:
				chars[num++] = 'Z';
				break;
			}
		}
		return num;
	}

	internal static int WriteDefaultIsoDate(char[] chars, int start, DateTime dt)
	{
		int num = 19;
		GetDateValues(dt, out var year, out var month, out var day);
		CopyIntToCharArray(chars, start, year, 4);
		chars[start + 4] = '-';
		CopyIntToCharArray(chars, start + 5, month, 2);
		chars[start + 7] = '-';
		CopyIntToCharArray(chars, start + 8, day, 2);
		chars[start + 10] = 'T';
		CopyIntToCharArray(chars, start + 11, dt.Hour, 2);
		chars[start + 13] = ':';
		CopyIntToCharArray(chars, start + 14, dt.Minute, 2);
		chars[start + 16] = ':';
		CopyIntToCharArray(chars, start + 17, dt.Second, 2);
		int num2 = (int)(dt.Ticks % 10000000);
		if (num2 != 0)
		{
			int num3 = 7;
			while (num2 % 10 == 0)
			{
				num3--;
				num2 /= 10;
			}
			chars[start + 19] = '.';
			CopyIntToCharArray(chars, start + 20, num2, num3);
			num += num3 + 1;
		}
		return start + num;
	}

	private static void CopyIntToCharArray(char[] chars, int start, int value, int digits)
	{
		while (digits-- != 0)
		{
			chars[start + digits] = (char)(value % 10 + 48);
			value /= 10;
		}
	}

	internal static int WriteDateTimeOffset(char[] chars, int start, TimeSpan offset, DateFormatHandling format)
	{
		chars[start++] = ((offset.Ticks >= 0) ? '+' : '-');
		int value = Math.Abs(offset.Hours);
		CopyIntToCharArray(chars, start, value, 2);
		start += 2;
		if (format == DateFormatHandling.IsoDateFormat)
		{
			chars[start++] = ':';
		}
		int value2 = Math.Abs(offset.Minutes);
		CopyIntToCharArray(chars, start, value2, 2);
		start += 2;
		return start;
	}

	internal static void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture)
	{
		if (string.IsNullOrEmpty(formatString))
		{
			char[] array = new char[64];
			int count = WriteDateTimeString(array, 0, (format == DateFormatHandling.IsoDateFormat) ? value.DateTime : value.UtcDateTime, value.Offset, DateTimeKind.Local, format);
			writer.Write(array, 0, count);
		}
		else
		{
			writer.Write(value.ToString(formatString, culture));
		}
	}

	private static void GetDateValues(DateTime td, out int year, out int month, out int day)
	{
		int num = (int)(td.Ticks / 864000000000L);
		int num2 = num / 146097;
		num -= num2 * 146097;
		int num3 = num / 36524;
		if (num3 == 4)
		{
			num3 = 3;
		}
		num -= num3 * 36524;
		int num4 = num / 1461;
		num -= num4 * 1461;
		int num5 = num / 365;
		if (num5 == 4)
		{
			num5 = 3;
		}
		year = num2 * 400 + num3 * 100 + num4 * 4 + num5 + 1;
		num -= num5 * 365;
		int[] array = ((num5 == 3 && (num4 != 24 || num3 == 3)) ? DaysToMonth366 : DaysToMonth365);
		int i;
		for (i = num >> 6; num >= array[i]; i++)
		{
		}
		month = i;
		day = num - array[i - 1] + 1;
	}
}


using System.Collections;
using Newtonsoft.Json.Shims;

[Preserve]
internal interface IWrappedDictionary : IDictionary, ICollection, IEnumerable
{
	object UnderlyingDictionary { get; }
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class DictionaryWrapper<TKey, TValue> : IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IWrappedDictionary, IDictionary, ICollection
{
	private struct DictionaryEnumerator<TEnumeratorKey, TEnumeratorValue> : IDictionaryEnumerator, IEnumerator
	{
		private readonly IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;

		public DictionaryEntry Entry => (DictionaryEntry)Current;

		public object Key => Entry.Key;

		public object Value => Entry.Value;

		public object Current => new DictionaryEntry(_e.Current.Key, _e.Current.Value);

		public DictionaryEnumerator(IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
		{
			ValidationUtils.ArgumentNotNull(e, "e");
			_e = e;
		}

		public bool MoveNext()
		{
			return _e.MoveNext();
		}

		public void Reset()
		{
			_e.Reset();
		}
	}

	private readonly IDictionary _dictionary;

	private readonly IDictionary<TKey, TValue> _genericDictionary;

	private object _syncRoot;

	public ICollection<TKey> Keys
	{
		get
		{
			if (_dictionary != null)
			{
				return _dictionary.Keys.Cast<TKey>().ToList();
			}
			return _genericDictionary.Keys;
		}
	}

	public ICollection<TValue> Values
	{
		get
		{
			if (_dictionary != null)
			{
				return _dictionary.Values.Cast<TValue>().ToList();
			}
			return _genericDictionary.Values;
		}
	}

	public TValue this[TKey key]
	{
		get
		{
			if (_dictionary != null)
			{
				return (TValue)_dictionary[key];
			}
			return _genericDictionary[key];
		}
		set
		{
			if (_dictionary != null)
			{
				_dictionary[key] = value;
			}
			else
			{
				_genericDictionary[key] = value;
			}
		}
	}

	public int Count
	{
		get
		{
			if (_dictionary != null)
			{
				return _dictionary.Count;
			}
			return _genericDictionary.Count;
		}
	}

	public bool IsReadOnly
	{
		get
		{
			if (_dictionary != null)
			{
				return _dictionary.IsReadOnly;
			}
			return _genericDictionary.IsReadOnly;
		}
	}

	object IDictionary.this[object key]
	{
		get
		{
			if (_dictionary != null)
			{
				return _dictionary[key];
			}
			return _genericDictionary[(TKey)key];
		}
		set
		{
			if (_dictionary != null)
			{
				_dictionary[key] = value;
			}
			else
			{
				_genericDictionary[(TKey)key] = (TValue)value;
			}
		}
	}

	bool IDictionary.IsFixedSize
	{
		get
		{
			if (_genericDictionary != null)
			{
				return false;
			}
			return _dictionary.IsFixedSize;
		}
	}

	ICollection IDictionary.Keys
	{
		get
		{
			if (_genericDictionary != null)
			{
				return _genericDictionary.Keys.ToList();
			}
			return _dictionary.Keys;
		}
	}

	ICollection IDictionary.Values
	{
		get
		{
			if (_genericDictionary != null)
			{
				return _genericDictionary.Values.ToList();
			}
			return _dictionary.Values;
		}
	}

	bool ICollection.IsSynchronized
	{
		get
		{
			if (_dictionary != null)
			{
				return _dictionary.IsSynchronized;
			}
			return false;
		}
	}

	object ICollection.SyncRoot
	{
		get
		{
			if (_syncRoot == null)
			{
				Interlocked.CompareExchange(ref _syncRoot, new object(), null);
			}
			return _syncRoot;
		}
	}

	public object UnderlyingDictionary
	{
		get
		{
			if (_dictionary != null)
			{
				return _dictionary;
			}
			return _genericDictionary;
		}
	}

	public DictionaryWrapper(IDictionary dictionary)
	{
		ValidationUtils.ArgumentNotNull(dictionary, "dictionary");
		_dictionary = dictionary;
	}

	public DictionaryWrapper(IDictionary<TKey, TValue> dictionary)
	{
		ValidationUtils.ArgumentNotNull(dictionary, "dictionary");
		_genericDictionary = dictionary;
	}

	public void Add(TKey key, TValue value)
	{
		if (_dictionary != null)
		{
			_dictionary.Add(key, value);
			return;
		}
		if (_genericDictionary != null)
		{
			_genericDictionary.Add(key, value);
			return;
		}
		throw new NotSupportedException();
	}

	public bool ContainsKey(TKey key)
	{
		if (_dictionary != null)
		{
			return _dictionary.Contains(key);
		}
		return _genericDictionary.ContainsKey(key);
	}

	public bool Remove(TKey key)
	{
		if (_dictionary != null)
		{
			if (_dictionary.Contains(key))
			{
				_dictionary.Remove(key);
				return true;
			}
			return false;
		}
		return _genericDictionary.Remove(key);
	}

	public bool TryGetValue(TKey key, out TValue value)
	{
		if (_dictionary != null)
		{
			if (!_dictionary.Contains(key))
			{
				value = default(TValue);
				return false;
			}
			value = (TValue)_dictionary[key];
			return true;
		}
		return _genericDictionary.TryGetValue(key, out value);
	}

	public void Add(KeyValuePair<TKey, TValue> item)
	{
		if (_dictionary != null)
		{
			((IList)_dictionary).Add(item);
		}
		else if (_genericDictionary != null)
		{
			_genericDictionary.Add(item);
		}
	}

	public void Clear()
	{
		if (_dictionary != null)
		{
			_dictionary.Clear();
		}
		else
		{
			_genericDictionary.Clear();
		}
	}

	public bool Contains(KeyValuePair<TKey, TValue> item)
	{
		if (_dictionary != null)
		{
			return ((IList)_dictionary).Contains(item);
		}
		return _genericDictionary.Contains(item);
	}

	public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
	{
		if (_dictionary != null)
		{
			foreach (DictionaryEntry item in _dictionary)
			{
				array[arrayIndex++] = new KeyValuePair<TKey, TValue>((TKey)item.Key, (TValue)item.Value);
			}
			return;
		}
		_genericDictionary.CopyTo(array, arrayIndex);
	}

	public bool Remove(KeyValuePair<TKey, TValue> item)
	{
		if (_dictionary != null)
		{
			if (_dictionary.Contains(item.Key))
			{
				if (object.Equals(_dictionary[item.Key], item.Value))
				{
					_dictionary.Remove(item.Key);
					return true;
				}
				return false;
			}
			return true;
		}
		return _genericDictionary.Remove(item);
	}

	public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
	{
		if (_dictionary != null)
		{
			return (from DictionaryEntry de in _dictionary
				select new KeyValuePair<TKey, TValue>((TKey)de.Key, (TValue)de.Value)).GetEnumerator();
		}
		return _genericDictionary.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	void IDictionary.Add(object key, object value)
	{
		if (_dictionary != null)
		{
			_dictionary.Add(key, value);
		}
		else
		{
			_genericDictionary.Add((TKey)key, (TValue)value);
		}
	}

	IDictionaryEnumerator IDictionary.GetEnumerator()
	{
		if (_dictionary != null)
		{
			return _dictionary.GetEnumerator();
		}
		return new DictionaryEnumerator<TKey, TValue>(_genericDictionary.GetEnumerator());
	}

	bool IDictionary.Contains(object key)
	{
		if (_genericDictionary != null)
		{
			return _genericDictionary.ContainsKey((TKey)key);
		}
		return _dictionary.Contains(key);
	}

	public void Remove(object key)
	{
		if (_dictionary != null)
		{
			_dictionary.Remove(key);
		}
		else
		{
			_genericDictionary.Remove((TKey)key);
		}
	}

	void ICollection.CopyTo(Array array, int index)
	{
		if (_dictionary != null)
		{
			_dictionary.CopyTo(array, index);
		}
		else
		{
			_genericDictionary.CopyTo((KeyValuePair<TKey, TValue>[])array, index);
		}
	}
}


using System.Collections;
using System.Collections.Generic;

private struct DictionaryEnumerator<TEnumeratorKey, TEnumeratorValue> : IDictionaryEnumerator, IEnumerator
{
	private readonly IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;

	public DictionaryEntry Entry => (DictionaryEntry)Current;

	public object Key => Entry.Key;

	public object Value => Entry.Value;

	public object Current => new DictionaryEntry(_e.Current.Key, _e.Current.Value);

	public DictionaryEnumerator(IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
	{
		ValidationUtils.ArgumentNotNull(e, "e");
		_e = e;
	}

	public bool MoveNext()
	{
		return _e.MoveNext();
	}

	public void Reset()
	{
		_e.Reset();
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal static class EnumUtils
{
	private static readonly ThreadSafeStore<Type, BidirectionalDictionary<string, string>> EnumMemberNamesPerType = new ThreadSafeStore<Type, BidirectionalDictionary<string, string>>(InitializeEnumType);

	private static BidirectionalDictionary<string, string> InitializeEnumType(Type type)
	{
		BidirectionalDictionary<string, string> bidirectionalDictionary = new BidirectionalDictionary<string, string>(StringComparer.OrdinalIgnoreCase, StringComparer.OrdinalIgnoreCase);
		FieldInfo[] fields = type.GetFields();
		foreach (FieldInfo fieldInfo in fields)
		{
			string name = fieldInfo.Name;
			string text = (from EnumMemberAttribute a in fieldInfo.GetCustomAttributes(typeof(EnumMemberAttribute), inherit: true)
				select a.Value).SingleOrDefault() ?? fieldInfo.Name;
			if (bidirectionalDictionary.TryGetBySecond(text, out var _))
			{
				throw new InvalidOperationException("Enum name '{0}' already exists on enum '{1}'.".FormatWith(CultureInfo.InvariantCulture, text, type.Name));
			}
			bidirectionalDictionary.Set(name, text);
		}
		return bidirectionalDictionary;
	}

	public static IList<T> GetFlagsValues<T>(T value) where T : struct
	{
		Type typeFromHandle = typeof(T);
		if (!typeFromHandle.IsDefined(typeof(FlagsAttribute), inherit: false))
		{
			throw new ArgumentException("Enum type {0} is not a set of flags.".FormatWith(CultureInfo.InvariantCulture, typeFromHandle));
		}
		Type underlyingType = Enum.GetUnderlyingType(value.GetType());
		ulong num = Convert.ToUInt64(value, CultureInfo.InvariantCulture);
		IList<EnumValue<ulong>> namesAndValues = GetNamesAndValues<T>();
		IList<T> list = new List<T>();
		foreach (EnumValue<ulong> item in namesAndValues)
		{
			if ((num & item.Value) == item.Value && item.Value != 0L)
			{
				list.Add((T)Convert.ChangeType(item.Value, underlyingType, CultureInfo.CurrentCulture));
			}
		}
		if (list.Count == 0 && namesAndValues.SingleOrDefault((EnumValue<ulong> v) => v.Value == 0) != null)
		{
			list.Add(default(T));
		}
		return list;
	}

	public static IList<EnumValue<ulong>> GetNamesAndValues<T>() where T : struct
	{
		return GetNamesAndValues<ulong>(typeof(T));
	}

	public static IList<EnumValue<TUnderlyingType>> GetNamesAndValues<TUnderlyingType>(Type enumType) where TUnderlyingType : struct
	{
		if ((object)enumType == null)
		{
			throw new ArgumentNullException("enumType");
		}
		if (!enumType.IsEnum())
		{
			throw new ArgumentException("Type {0} is not an Enum.".FormatWith(CultureInfo.InvariantCulture, enumType), "enumType");
		}
		IList<object> values = GetValues(enumType);
		IList<string> names = GetNames(enumType);
		IList<EnumValue<TUnderlyingType>> list = new List<EnumValue<TUnderlyingType>>();
		for (int i = 0; i < values.Count; i++)
		{
			try
			{
				list.Add(new EnumValue<TUnderlyingType>(names[i], (TUnderlyingType)Convert.ChangeType(values[i], typeof(TUnderlyingType), CultureInfo.CurrentCulture)));
			}
			catch (OverflowException innerException)
			{
				throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "Value from enum with the underlying type of {0} cannot be added to dictionary with a value type of {1}. Value was too large: {2}", new object[3]
				{
					Enum.GetUnderlyingType(enumType),
					typeof(TUnderlyingType),
					Convert.ToUInt64(values[i], CultureInfo.InvariantCulture)
				}), innerException);
			}
		}
		return list;
	}

	public static IList<object> GetValues(Type enumType)
	{
		if (!enumType.IsEnum())
		{
			throw new ArgumentException("Type '" + enumType.Name + "' is not an enum.");
		}
		List<object> list = new List<object>();
		foreach (FieldInfo item in from f in enumType.GetFields()
			where f.IsLiteral
			select f)
		{
			object value = item.GetValue(enumType);
			list.Add(value);
		}
		return list;
	}

	public static IList<string> GetNames(Type enumType)
	{
		if (!enumType.IsEnum())
		{
			throw new ArgumentException("Type '" + enumType.Name + "' is not an enum.");
		}
		List<string> list = new List<string>();
		foreach (FieldInfo item in from f in enumType.GetFields()
			where f.IsLiteral
			select f)
		{
			list.Add(item.Name);
		}
		return list;
	}

	public static object ParseEnumName(string enumText, bool isNullable, Type t)
	{
		if (enumText == string.Empty && isNullable)
		{
			return null;
		}
		BidirectionalDictionary<string, string> map = EnumMemberNamesPerType.Get(t);
		string value;
		if (enumText.IndexOf(',') != -1)
		{
			string[] array = enumText.Split(new char[1] { ',' });
			for (int i = 0; i < array.Length; i++)
			{
				string enumText2 = array[i].Trim();
				array[i] = ResolvedEnumName(map, enumText2);
			}
			value = string.Join(", ", array);
		}
		else
		{
			value = ResolvedEnumName(map, enumText);
		}
		return Enum.Parse(t, value, ignoreCase: true);
	}

	public static string ToEnumName(Type enumType, string enumText, bool camelCaseText)
	{
		BidirectionalDictionary<string, string> bidirectionalDictionary = EnumMemberNamesPerType.Get(enumType);
		string[] array = enumText.Split(new char[1] { ',' });
		for (int i = 0; i < array.Length; i++)
		{
			string text = array[i].Trim();
			bidirectionalDictionary.TryGetByFirst(text, out var second);
			second = second ?? text;
			if (camelCaseText)
			{
				second = StringUtils.ToCamelCase(second);
			}
			array[i] = second;
		}
		return string.Join(", ", array);
	}

	private static string ResolvedEnumName(BidirectionalDictionary<string, string> map, string enumText)
	{
		map.TryGetBySecond(enumText, out var first);
		return first ?? enumText;
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
internal class EnumValue<T> where T : struct
{
	private readonly string _name;

	private readonly T _value;

	public string Name => _name;

	public T Value => _value;

	public EnumValue(string name, T value)
	{
		_name = name;
		_value = value;
	}
}


using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Preserve]
internal static class BufferUtils
{
	public static char[] RentBuffer(IArrayPool<char> bufferPool, int minSize)
	{
		if (bufferPool == null)
		{
			return new char[minSize];
		}
		return bufferPool.Rent(minSize);
	}

	public static void ReturnBuffer(IArrayPool<char> bufferPool, char[] buffer)
	{
		bufferPool?.Return(buffer);
	}

	public static char[] EnsureBufferSize(IArrayPool<char> bufferPool, int size, char[] buffer)
	{
		if (bufferPool == null)
		{
			return new char[size];
		}
		if (buffer != null)
		{
			bufferPool.Return(buffer);
		}
		return bufferPool.Rent(size);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal static class JavaScriptUtils
{
	internal static readonly bool[] SingleQuoteCharEscapeFlags;

	internal static readonly bool[] DoubleQuoteCharEscapeFlags;

	internal static readonly bool[] HtmlCharEscapeFlags;

	private const int UnicodeTextLength = 6;

	private const string EscapedUnicodeText = "!";

	static JavaScriptUtils()
	{
		SingleQuoteCharEscapeFlags = new bool[128];
		DoubleQuoteCharEscapeFlags = new bool[128];
		HtmlCharEscapeFlags = new bool[128];
		IList<char> list = new List<char> { '\n', '\r', '\t', '\\', '\f', '\b' };
		for (int i = 0; i < 32; i++)
		{
			list.Add((char)i);
		}
		foreach (char item in list.Union(new char[1] { '\'' }))
		{
			SingleQuoteCharEscapeFlags[(uint)item] = true;
		}
		foreach (char item2 in list.Union(new char[1] { '"' }))
		{
			DoubleQuoteCharEscapeFlags[(uint)item2] = true;
		}
		foreach (char item3 in list.Union(new char[5] { '"', '\'', '<', '>', '&' }))
		{
			HtmlCharEscapeFlags[(uint)item3] = true;
		}
	}

	public static bool[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar)
	{
		if (stringEscapeHandling == StringEscapeHandling.EscapeHtml)
		{
			return HtmlCharEscapeFlags;
		}
		if (quoteChar == '"')
		{
			return DoubleQuoteCharEscapeFlags;
		}
		return SingleQuoteCharEscapeFlags;
	}

	public static bool ShouldEscapeJavaScriptString(string s, bool[] charEscapeFlags)
	{
		if (s == null)
		{
			return false;
		}
		foreach (char c in s)
		{
			if (c >= charEscapeFlags.Length || charEscapeFlags[(uint)c])
			{
				return true;
			}
		}
		return false;
	}

	public static void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, bool[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, IArrayPool<char> bufferPool, ref char[] writeBuffer)
	{
		if (appendDelimiters)
		{
			writer.Write(delimiter);
		}
		if (s != null)
		{
			int num = 0;
			for (int i = 0; i < s.Length; i++)
			{
				char c = s[i];
				if (c < charEscapeFlags.Length && !charEscapeFlags[(uint)c])
				{
					continue;
				}
				string text;
				switch (c)
				{
				case '\t':
					text = "\\t";
					break;
				case '\n':
					text = "\\n";
					break;
				case '\r':
					text = "\\r";
					break;
				case '\f':
					text = "\\f";
					break;
				case '\b':
					text = "\\b";
					break;
				case '\\':
					text = "\\\\";
					break;
				case '\u0085':
					text = "\\u0085";
					break;
				case '\u2028':
					text = "\\u2028";
					break;
				case '\u2029':
					text = "\\u2029";
					break;
				default:
					if (c < charEscapeFlags.Length || stringEscapeHandling == StringEscapeHandling.EscapeNonAscii)
					{
						if (c == '\'' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
						{
							text = "\\'";
							break;
						}
						if (c == '"' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
						{
							text = "\\\"";
							break;
						}
						if (writeBuffer == null || writeBuffer.Length < 6)
						{
							writeBuffer = BufferUtils.EnsureBufferSize(bufferPool, 6, writeBuffer);
						}
						StringUtils.ToCharAsUnicode(c, writeBuffer);
						text = "!";
					}
					else
					{
						text = null;
					}
					break;
				}
				if (text == null)
				{
					continue;
				}
				bool flag = string.Equals(text, "!");
				if (i > num)
				{
					int num2 = i - num + (flag ? 6 : 0);
					int num3 = (flag ? 6 : 0);
					if (writeBuffer == null || writeBuffer.Length < num2)
					{
						char[] array = BufferUtils.RentBuffer(bufferPool, num2);
						if (flag)
						{
							Array.Copy(writeBuffer, array, 6);
						}
						BufferUtils.ReturnBuffer(bufferPool, writeBuffer);
						writeBuffer = array;
					}
					s.CopyTo(num, writeBuffer, num3, num2 - num3);
					writer.Write(writeBuffer, num3, num2 - num3);
				}
				num = i + 1;
				if (!flag)
				{
					writer.Write(text);
				}
				else
				{
					writer.Write(writeBuffer, 0, 6);
				}
			}
			if (num == 0)
			{
				writer.Write(s);
			}
			else
			{
				int num4 = s.Length - num;
				if (writeBuffer == null || writeBuffer.Length < num4)
				{
					writeBuffer = BufferUtils.EnsureBufferSize(bufferPool, num4, writeBuffer);
				}
				s.CopyTo(num, writeBuffer, 0, num4);
				writer.Write(writeBuffer, 0, num4);
			}
		}
		if (appendDelimiters)
		{
			writer.Write(delimiter);
		}
	}

	public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling)
	{
		bool[] charEscapeFlags = GetCharEscapeFlags(stringEscapeHandling, delimiter);
		using StringWriter stringWriter = StringUtils.CreateStringWriter(StringUtils.GetLength(value) ?? 16);
		char[] writeBuffer = null;
		WriteEscapedJavaScriptString(stringWriter, value, delimiter, appendDelimiters, charEscapeFlags, stringEscapeHandling, null, ref writeBuffer);
		return stringWriter.ToString();
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal struct StringBuffer
{
	private char[] _buffer;

	private int _position;

	public int Position
	{
		get
		{
			return _position;
		}
		set
		{
			_position = value;
		}
	}

	public bool IsEmpty => _buffer == null;

	public char[] InternalBuffer => _buffer;

	public StringBuffer(IArrayPool<char> bufferPool, int initalSize)
		: this(BufferUtils.RentBuffer(bufferPool, initalSize))
	{
	}

	private StringBuffer(char[] buffer)
	{
		_buffer = buffer;
		_position = 0;
	}

	public void Append(IArrayPool<char> bufferPool, char value)
	{
		if (_position == _buffer.Length)
		{
			EnsureSize(bufferPool, 1);
		}
		_buffer[_position++] = value;
	}

	public void Append(IArrayPool<char> bufferPool, char[] buffer, int startIndex, int count)
	{
		if (_position + count >= _buffer.Length)
		{
			EnsureSize(bufferPool, count);
		}
		Array.Copy(buffer, startIndex, _buffer, _position, count);
		_position += count;
	}

	public void Clear(IArrayPool<char> bufferPool)
	{
		if (_buffer != null)
		{
			BufferUtils.ReturnBuffer(bufferPool, _buffer);
			_buffer = null;
		}
		_position = 0;
	}

	private void EnsureSize(IArrayPool<char> bufferPool, int appendLength)
	{
		char[] array = BufferUtils.RentBuffer(bufferPool, (_position + appendLength) * 2);
		if (_buffer != null)
		{
			Array.Copy(_buffer, array, _position);
			BufferUtils.ReturnBuffer(bufferPool, _buffer);
		}
		_buffer = array;
	}

	public override string ToString()
	{
		return ToString(0, _position);
	}

	public string ToString(int start, int length)
	{
		return new string(_buffer, start, length);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal static class CollectionUtils
{
	public static bool IsNullOrEmpty<T>(ICollection<T> collection)
	{
		if (collection != null)
		{
			return collection.Count == 0;
		}
		return true;
	}

	public static void AddRange<T>(this IList<T> initial, IEnumerable<T> collection)
	{
		if (initial == null)
		{
			throw new ArgumentNullException("initial");
		}
		if (collection == null)
		{
			return;
		}
		foreach (T item in collection)
		{
			initial.Add(item);
		}
	}

	public static void AddRange<T>(this IList<T> initial, IEnumerable collection)
	{
		ValidationUtils.ArgumentNotNull(initial, "initial");
		initial.AddRange(collection.Cast<T>());
	}

	public static bool IsDictionaryType(Type type)
	{
		ValidationUtils.ArgumentNotNull(type, "type");
		if (typeof(IDictionary).IsAssignableFrom(type))
		{
			return true;
		}
		if (ReflectionUtils.ImplementsGenericDefinition(type, typeof(IDictionary<, >)))
		{
			return true;
		}
		return false;
	}

	public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType)
	{
		Type constructorArgumentType = typeof(IList<>).MakeGenericType(collectionItemType);
		return ResolveEnumerableCollectionConstructor(collectionType, collectionItemType, constructorArgumentType);
	}

	public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType)
	{
		Type type = typeof(IEnumerable<>).MakeGenericType(collectionItemType);
		ConstructorInfo constructorInfo = null;
		ConstructorInfo[] constructors = collectionType.GetConstructors(BindingFlags.Instance | BindingFlags.Public);
		foreach (ConstructorInfo constructorInfo2 in constructors)
		{
			IList<ParameterInfo> parameters = constructorInfo2.GetParameters();
			if (parameters.Count == 1)
			{
				Type parameterType = parameters[0].ParameterType;
				if ((object)type == parameterType)
				{
					constructorInfo = constructorInfo2;
					break;
				}
				if ((object)constructorInfo == null && parameterType.IsAssignableFrom(constructorArgumentType))
				{
					constructorInfo = constructorInfo2;
				}
			}
		}
		return constructorInfo;
	}

	public static bool AddDistinct<T>(this IList<T> list, T value)
	{
		return list.AddDistinct(value, EqualityComparer<T>.Default);
	}

	public static bool AddDistinct<T>(this IList<T> list, T value, IEqualityComparer<T> comparer)
	{
		if (list.ContainsValue(value, comparer))
		{
			return false;
		}
		list.Add(value);
		return true;
	}

	public static bool ContainsValue<TSource>(this IEnumerable<TSource> source, TSource value, IEqualityComparer<TSource> comparer)
	{
		if (comparer == null)
		{
			comparer = EqualityComparer<TSource>.Default;
		}
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		foreach (TSource item in source)
		{
			if (comparer.Equals(item, value))
			{
				return true;
			}
		}
		return false;
	}

	public static bool AddRangeDistinct<T>(this IList<T> list, IEnumerable<T> values, IEqualityComparer<T> comparer)
	{
		bool result = true;
		foreach (T value in values)
		{
			if (!list.AddDistinct(value, comparer))
			{
				result = false;
			}
		}
		return result;
	}

	public static int IndexOf<T>(this IEnumerable<T> collection, Func<T, bool> predicate)
	{
		int num = 0;
		foreach (T item in collection)
		{
			if (predicate(item))
			{
				return num;
			}
			num++;
		}
		return -1;
	}

	public static bool Contains<T>(this List<T> list, T value, IEqualityComparer comparer)
	{
		for (int i = 0; i < list.Count; i++)
		{
			if (comparer.Equals(value, list[i]))
			{
				return true;
			}
		}
		return false;
	}

	public static int IndexOfReference<T>(this List<T> list, T item)
	{
		for (int i = 0; i < list.Count; i++)
		{
			if ((object)item == (object)list[i])
			{
				return i;
			}
		}
		return -1;
	}

	private static IList<int> GetDimensions(IList values, int dimensionsCount)
	{
		IList<int> list = new List<int>();
		IList list2 = values;
		while (true)
		{
			list.Add(list2.Count);
			if (list.Count == dimensionsCount || list2.Count == 0)
			{
				break;
			}
			object obj = list2[0];
			if (!(obj is IList))
			{
				break;
			}
			list2 = (IList)obj;
		}
		return list;
	}

	private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, int[] indices)
	{
		int num = indices.Length;
		if (num == multidimensionalArray.Rank)
		{
			multidimensionalArray.SetValue(JaggedArrayGetValue(values, indices), indices);
			return;
		}
		int length = multidimensionalArray.GetLength(num);
		if (((IList)JaggedArrayGetValue(values, indices)).Count != length)
		{
			throw new Exception("Cannot deserialize non-cubical array as multidimensional array.");
		}
		int[] array = new int[num + 1];
		for (int i = 0; i < num; i++)
		{
			array[i] = indices[i];
		}
		for (int j = 0; j < multidimensionalArray.GetLength(num); j++)
		{
			array[num] = j;
			CopyFromJaggedToMultidimensionalArray(values, multidimensionalArray, array);
		}
	}

	private static object JaggedArrayGetValue(IList values, int[] indices)
	{
		IList list = values;
		for (int i = 0; i < indices.Length; i++)
		{
			int index = indices[i];
			if (i == indices.Length - 1)
			{
				return list[index];
			}
			list = (IList)list[index];
		}
		return list;
	}

	public static Array ToMultidimensionalArray(IList values, Type type, int rank)
	{
		IList<int> dimensions = GetDimensions(values, rank);
		while (dimensions.Count < rank)
		{
			dimensions.Add(0);
		}
		Array array = Array.CreateInstance(type, dimensions.ToArray());
		CopyFromJaggedToMultidimensionalArray(values, array, new int[0]);
		return array;
	}
}


using System;
using Newtonsoft.Json.Shims;

[Preserve]
internal static class MathUtils
{
	public static int IntLength(ulong i)
	{
		if (i < 10000000000L)
		{
			if (i < 10)
			{
				return 1;
			}
			if (i < 100)
			{
				return 2;
			}
			if (i < 1000)
			{
				return 3;
			}
			if (i < 10000)
			{
				return 4;
			}
			if (i < 100000)
			{
				return 5;
			}
			if (i < 1000000)
			{
				return 6;
			}
			if (i < 10000000)
			{
				return 7;
			}
			if (i < 100000000)
			{
				return 8;
			}
			if (i < 1000000000)
			{
				return 9;
			}
			return 10;
		}
		if (i < 100000000000L)
		{
			return 11;
		}
		if (i < 1000000000000L)
		{
			return 12;
		}
		if (i < 10000000000000L)
		{
			return 13;
		}
		if (i < 100000000000000L)
		{
			return 14;
		}
		if (i < 1000000000000000L)
		{
			return 15;
		}
		if (i < 10000000000000000L)
		{
			return 16;
		}
		if (i < 100000000000000000L)
		{
			return 17;
		}
		if (i < 1000000000000000000L)
		{
			return 18;
		}
		if (i < 10000000000000000000uL)
		{
			return 19;
		}
		return 20;
	}

	public static char IntToHex(int n)
	{
		if (n <= 9)
		{
			return (char)(n + 48);
		}
		return (char)(n - 10 + 97);
	}

	public static int? Min(int? val1, int? val2)
	{
		if (!val1.HasValue)
		{
			return val2;
		}
		if (!val2.HasValue)
		{
			return val1;
		}
		return Math.Min(val1.GetValueOrDefault(), val2.GetValueOrDefault());
	}

	public static int? Max(int? val1, int? val2)
	{
		if (!val1.HasValue)
		{
			return val2;
		}
		if (!val2.HasValue)
		{
			return val1;
		}
		return Math.Max(val1.GetValueOrDefault(), val2.GetValueOrDefault());
	}

	public static double? Max(double? val1, double? val2)
	{
		if (!val1.HasValue)
		{
			return val2;
		}
		if (!val2.HasValue)
		{
			return val1;
		}
		return Math.Max(val1.GetValueOrDefault(), val2.GetValueOrDefault());
	}

	public static bool ApproxEquals(double d1, double d2)
	{
		if (d1 == d2)
		{
			return true;
		}
		double num = (Math.Abs(d1) + Math.Abs(d2) + 10.0) * 2.220446049250313E-16;
		double num2 = d1 - d2;
		if (0.0 - num < num2)
		{
			return num > num2;
		}
		return false;
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
internal delegate T Creator<T>();


using System;
using System.Globalization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal static class MiscellaneousUtils
{
	public static bool ValueEquals(object objA, object objB)
	{
		if (objA == null && objB == null)
		{
			return true;
		}
		if (objA != null && objB == null)
		{
			return false;
		}
		if (objA == null && objB != null)
		{
			return false;
		}
		if ((object)objA.GetType() != objB.GetType())
		{
			if (ConvertUtils.IsInteger(objA) && ConvertUtils.IsInteger(objB))
			{
				return Convert.ToDecimal(objA, CultureInfo.CurrentCulture).Equals(Convert.ToDecimal(objB, CultureInfo.CurrentCulture));
			}
			if ((objA is double || objA is float || objA is decimal) && (objB is double || objB is float || objB is decimal))
			{
				return MathUtils.ApproxEquals(Convert.ToDouble(objA, CultureInfo.CurrentCulture), Convert.ToDouble(objB, CultureInfo.CurrentCulture));
			}
			return false;
		}
		return objA.Equals(objB);
	}

	public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message)
	{
		string message2 = message + Environment.NewLine + "Actual value was {0}.".FormatWith(CultureInfo.InvariantCulture, actualValue);
		return new ArgumentOutOfRangeException(paramName, message2);
	}

	public static string ToString(object value)
	{
		if (value == null)
		{
			return "{null}";
		}
		if (!(value is string))
		{
			return value.ToString();
		}
		return "\"" + value.ToString() + "\"";
	}

	public static int ByteArrayCompare(byte[] a1, byte[] a2)
	{
		int num = a1.Length.CompareTo(a2.Length);
		if (num != 0)
		{
			return num;
		}
		for (int i = 0; i < a1.Length; i++)
		{
			int num2 = a1[i].CompareTo(a2[i]);
			if (num2 != 0)
			{
				return num2;
			}
		}
		return 0;
	}

	public static string GetPrefix(string qualifiedName)
	{
		GetQualifiedNameParts(qualifiedName, out var prefix, out var _);
		return prefix;
	}

	public static string GetLocalName(string qualifiedName)
	{
		GetQualifiedNameParts(qualifiedName, out var _, out var localName);
		return localName;
	}

	public static void GetQualifiedNameParts(string qualifiedName, out string prefix, out string localName)
	{
		int num = qualifiedName.IndexOf(':');
		if (num == -1 || num == 0 || qualifiedName.Length - 1 == num)
		{
			prefix = null;
			localName = qualifiedName;
		}
		else
		{
			prefix = qualifiedName.Substring(0, num);
			localName = qualifiedName.Substring(num + 1);
		}
	}

	internal static string FormatValueForPrint(object value)
	{
		if (value == null)
		{
			return "{null}";
		}
		if (value is string)
		{
			return string.Concat("\"", value, "\"");
		}
		return value.ToString();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Text;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal static class ReflectionUtils
{
	public static readonly Type[] EmptyTypes;

	static ReflectionUtils()
	{
		EmptyTypes = Type.EmptyTypes;
	}

	public static bool IsVirtual(this PropertyInfo propertyInfo)
	{
		ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
		MethodInfo getMethod = propertyInfo.GetGetMethod();
		if ((object)getMethod != null && getMethod.IsVirtual)
		{
			return true;
		}
		getMethod = propertyInfo.GetSetMethod();
		if ((object)getMethod != null && getMethod.IsVirtual)
		{
			return true;
		}
		return false;
	}

	public static MethodInfo GetBaseDefinition(this PropertyInfo propertyInfo)
	{
		ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
		MethodInfo getMethod = propertyInfo.GetGetMethod();
		if ((object)getMethod != null)
		{
			return getMethod.GetBaseDefinition();
		}
		return propertyInfo.GetSetMethod()?.GetBaseDefinition();
	}

	public static bool IsPublic(PropertyInfo property)
	{
		if ((object)property.GetGetMethod() != null && property.GetGetMethod().IsPublic)
		{
			return true;
		}
		if ((object)property.GetSetMethod() != null && property.GetSetMethod().IsPublic)
		{
			return true;
		}
		return false;
	}

	public static Type GetObjectType(object v)
	{
		return v?.GetType();
	}

	public static string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat, SerializationBinder binder)
	{
		string assemblyQualifiedName = t.AssemblyQualifiedName;
		return assemblyFormat switch
		{
			FormatterAssemblyStyle.Simple => RemoveAssemblyDetails(assemblyQualifiedName), 
			FormatterAssemblyStyle.Full => assemblyQualifiedName, 
			_ => throw new ArgumentOutOfRangeException(), 
		};
	}

	private static string RemoveAssemblyDetails(string fullyQualifiedTypeName)
	{
		StringBuilder stringBuilder = new StringBuilder();
		bool flag = false;
		bool flag2 = false;
		foreach (char c in fullyQualifiedTypeName)
		{
			switch (c)
			{
			case '[':
				flag = false;
				flag2 = false;
				stringBuilder.Append(c);
				break;
			case ']':
				flag = false;
				flag2 = false;
				stringBuilder.Append(c);
				break;
			case ',':
				if (!flag)
				{
					flag = true;
					stringBuilder.Append(c);
				}
				else
				{
					flag2 = true;
				}
				break;
			default:
				if (!flag2)
				{
					stringBuilder.Append(c);
				}
				break;
			}
		}
		return stringBuilder.ToString();
	}

	public static bool HasDefaultConstructor(Type t, bool nonPublic)
	{
		ValidationUtils.ArgumentNotNull(t, "t");
		if (t.IsValueType())
		{
			return true;
		}
		return (object)GetDefaultConstructor(t, nonPublic) != null;
	}

	public static ConstructorInfo GetDefaultConstructor(Type t)
	{
		return GetDefaultConstructor(t, nonPublic: false);
	}

	public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic)
	{
		BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public;
		if (nonPublic)
		{
			bindingFlags |= BindingFlags.NonPublic;
		}
		return t.GetConstructors(bindingFlags).SingleOrDefault((ConstructorInfo c) => !c.GetParameters().Any());
	}

	public static bool IsNullable(Type t)
	{
		ValidationUtils.ArgumentNotNull(t, "t");
		if (t.IsValueType())
		{
			return IsNullableType(t);
		}
		return true;
	}

	public static bool IsNullableType(Type t)
	{
		ValidationUtils.ArgumentNotNull(t, "t");
		if (t.IsGenericType())
		{
			return (object)t.GetGenericTypeDefinition() == typeof(Nullable<>);
		}
		return false;
	}

	public static Type EnsureNotNullableType(Type t)
	{
		if (!IsNullableType(t))
		{
			return t;
		}
		return Nullable.GetUnderlyingType(t);
	}

	public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition)
	{
		if (!type.IsGenericType())
		{
			return false;
		}
		return (object)type.GetGenericTypeDefinition() == genericInterfaceDefinition;
	}

	public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition)
	{
		Type implementingType;
		return ImplementsGenericDefinition(type, genericInterfaceDefinition, out implementingType);
	}

	public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, out Type implementingType)
	{
		ValidationUtils.ArgumentNotNull(type, "type");
		ValidationUtils.ArgumentNotNull(genericInterfaceDefinition, "genericInterfaceDefinition");
		if (!genericInterfaceDefinition.IsInterface() || !genericInterfaceDefinition.IsGenericTypeDefinition())
		{
			throw new ArgumentNullException("'{0}' is not a generic interface definition.".FormatWith(CultureInfo.InvariantCulture, genericInterfaceDefinition));
		}
		if (type.IsInterface() && type.IsGenericType())
		{
			Type genericTypeDefinition = type.GetGenericTypeDefinition();
			if ((object)genericInterfaceDefinition == genericTypeDefinition)
			{
				implementingType = type;
				return true;
			}
		}
		Type[] interfaces = type.GetInterfaces();
		foreach (Type type2 in interfaces)
		{
			if (type2.IsGenericType())
			{
				Type genericTypeDefinition2 = type2.GetGenericTypeDefinition();
				if ((object)genericInterfaceDefinition == genericTypeDefinition2)
				{
					implementingType = type2;
					return true;
				}
			}
		}
		implementingType = null;
		return false;
	}

	public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition)
	{
		Type implementingType;
		return InheritsGenericDefinition(type, genericClassDefinition, out implementingType);
	}

	public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, out Type implementingType)
	{
		ValidationUtils.ArgumentNotNull(type, "type");
		ValidationUtils.ArgumentNotNull(genericClassDefinition, "genericClassDefinition");
		if (!genericClassDefinition.IsClass() || !genericClassDefinition.IsGenericTypeDefinition())
		{
			throw new ArgumentNullException("'{0}' is not a generic class definition.".FormatWith(CultureInfo.InvariantCulture, genericClassDefinition));
		}
		return InheritsGenericDefinitionInternal(type, genericClassDefinition, out implementingType);
	}

	private static bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, out Type implementingType)
	{
		if (currentType.IsGenericType())
		{
			Type genericTypeDefinition = currentType.GetGenericTypeDefinition();
			if ((object)genericClassDefinition == genericTypeDefinition)
			{
				implementingType = currentType;
				return true;
			}
		}
		if ((object)currentType.BaseType() == null)
		{
			implementingType = null;
			return false;
		}
		return InheritsGenericDefinitionInternal(currentType.BaseType(), genericClassDefinition, out implementingType);
	}

	public static Type GetCollectionItemType(Type type)
	{
		ValidationUtils.ArgumentNotNull(type, "type");
		if (type.IsArray)
		{
			return type.GetElementType();
		}
		if (ImplementsGenericDefinition(type, typeof(IEnumerable<>), out var implementingType))
		{
			if (implementingType.IsGenericTypeDefinition())
			{
				throw new Exception("Type {0} is not a collection.".FormatWith(CultureInfo.InvariantCulture, type));
			}
			return implementingType.GetGenericArguments()[0];
		}
		if (typeof(IEnumerable).IsAssignableFrom(type))
		{
			return null;
		}
		throw new Exception("Type {0} is not a collection.".FormatWith(CultureInfo.InvariantCulture, type));
	}

	public static void GetDictionaryKeyValueTypes(Type dictionaryType, out Type keyType, out Type valueType)
	{
		ValidationUtils.ArgumentNotNull(dictionaryType, "dictionaryType");
		if (ImplementsGenericDefinition(dictionaryType, typeof(IDictionary<, >), out var implementingType))
		{
			if (implementingType.IsGenericTypeDefinition())
			{
				throw new Exception("Type {0} is not a dictionary.".FormatWith(CultureInfo.InvariantCulture, dictionaryType));
			}
			Type[] genericArguments = implementingType.GetGenericArguments();
			keyType = genericArguments[0];
			valueType = genericArguments[1];
		}
		else
		{
			if (!typeof(IDictionary).IsAssignableFrom(dictionaryType))
			{
				throw new Exception("Type {0} is not a dictionary.".FormatWith(CultureInfo.InvariantCulture, dictionaryType));
			}
			keyType = null;
			valueType = null;
		}
	}

	public static Type GetMemberUnderlyingType(MemberInfo member)
	{
		ValidationUtils.ArgumentNotNull(member, "member");
		return member.MemberType() switch
		{
			MemberTypes.Field => ((FieldInfo)member).FieldType, 
			MemberTypes.Property => ((PropertyInfo)member).PropertyType, 
			MemberTypes.Event => ((EventInfo)member).EventHandlerType, 
			MemberTypes.Method => ((MethodInfo)member).ReturnType, 
			_ => throw new ArgumentException("MemberInfo must be of type FieldInfo, PropertyInfo, EventInfo or MethodInfo", "member"), 
		};
	}

	public static bool IsIndexedProperty(MemberInfo member)
	{
		ValidationUtils.ArgumentNotNull(member, "member");
		if (member is PropertyInfo property)
		{
			return IsIndexedProperty(property);
		}
		return false;
	}

	public static bool IsIndexedProperty(PropertyInfo property)
	{
		ValidationUtils.ArgumentNotNull(property, "property");
		return property.GetIndexParameters().Length != 0;
	}

	public static object GetMemberValue(MemberInfo member, object target)
	{
		ValidationUtils.ArgumentNotNull(member, "member");
		ValidationUtils.ArgumentNotNull(target, "target");
		switch (member.MemberType())
		{
		case MemberTypes.Field:
			return ((FieldInfo)member).GetValue(target);
		case MemberTypes.Property:
			try
			{
				return ((PropertyInfo)member).GetValue(target, null);
			}
			catch (TargetParameterCountException innerException)
			{
				throw new ArgumentException("MemberInfo '{0}' has index parameters".FormatWith(CultureInfo.InvariantCulture, member.Name), innerException);
			}
		default:
			throw new ArgumentException("MemberInfo '{0}' is not of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture, CultureInfo.InvariantCulture, member.Name), "member");
		}
	}

	public static void SetMemberValue(MemberInfo member, object target, object value)
	{
		ValidationUtils.ArgumentNotNull(member, "member");
		ValidationUtils.ArgumentNotNull(target, "target");
		switch (member.MemberType())
		{
		case MemberTypes.Field:
			((FieldInfo)member).SetValue(target, value);
			break;
		case MemberTypes.Property:
			((PropertyInfo)member).SetValue(target, value, null);
			break;
		default:
			throw new ArgumentException("MemberInfo '{0}' must be of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture, member.Name), "member");
		}
	}

	public static bool CanReadMemberValue(MemberInfo member, bool nonPublic)
	{
		switch (member.MemberType())
		{
		case MemberTypes.Field:
		{
			FieldInfo fieldInfo = (FieldInfo)member;
			if (nonPublic)
			{
				return true;
			}
			if (fieldInfo.IsPublic)
			{
				return true;
			}
			return false;
		}
		case MemberTypes.Property:
		{
			PropertyInfo propertyInfo = (PropertyInfo)member;
			if (!propertyInfo.CanRead)
			{
				return false;
			}
			if (nonPublic)
			{
				return true;
			}
			return (object)propertyInfo.GetGetMethod(nonPublic) != null;
		}
		default:
			return false;
		}
	}

	public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly)
	{
		switch (member.MemberType())
		{
		case MemberTypes.Field:
		{
			FieldInfo fieldInfo = (FieldInfo)member;
			if (fieldInfo.IsLiteral)
			{
				return false;
			}
			if (fieldInfo.IsInitOnly && !canSetReadOnly)
			{
				return false;
			}
			if (nonPublic)
			{
				return true;
			}
			if (fieldInfo.IsPublic)
			{
				return true;
			}
			return false;
		}
		case MemberTypes.Property:
		{
			PropertyInfo propertyInfo = (PropertyInfo)member;
			if (!propertyInfo.CanWrite)
			{
				return false;
			}
			if (nonPublic)
			{
				return true;
			}
			return (object)propertyInfo.GetSetMethod(nonPublic) != null;
		}
		default:
			return false;
		}
	}

	public static List<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr)
	{
		List<MemberInfo> list = new List<MemberInfo>();
		((IList<MemberInfo>)list).AddRange((IEnumerable)GetFields(type, bindingAttr));
		((IList<MemberInfo>)list).AddRange((IEnumerable)GetProperties(type, bindingAttr));
		List<MemberInfo> list2 = new List<MemberInfo>(list.Count);
		foreach (IGrouping<string, MemberInfo> item in from m in list
			group m by m.Name)
		{
			int num = item.Count();
			IList<MemberInfo> list3 = item.ToList();
			if (num == 1)
			{
				list2.Add(list3.First());
				continue;
			}
			IList<MemberInfo> list4 = new List<MemberInfo>();
			foreach (MemberInfo item2 in list3)
			{
				if (list4.Count == 0)
				{
					list4.Add(item2);
				}
				else if (!IsOverridenGenericMember(item2, bindingAttr) || item2.Name == "Item")
				{
					list4.Add(item2);
				}
			}
			list2.AddRange(list4);
		}
		return list2;
	}

	private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr)
	{
		if (memberInfo.MemberType() != MemberTypes.Property)
		{
			return false;
		}
		PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
		if (!propertyInfo.IsVirtual())
		{
			return false;
		}
		Type declaringType = propertyInfo.DeclaringType;
		if (!declaringType.IsGenericType())
		{
			return false;
		}
		Type genericTypeDefinition = declaringType.GetGenericTypeDefinition();
		if ((object)genericTypeDefinition == null)
		{
			return false;
		}
		MemberInfo[] member = genericTypeDefinition.GetMember(propertyInfo.Name, bindingAttr);
		if (member.Length == 0)
		{
			return false;
		}
		if (!GetMemberUnderlyingType(member[0]).IsGenericParameter)
		{
			return false;
		}
		return true;
	}

	public static T GetAttribute<T>(object attributeProvider) where T : Attribute
	{
		return GetAttribute<T>(attributeProvider, inherit: true);
	}

	public static T GetAttribute<T>(object attributeProvider, bool inherit) where T : Attribute
	{
		T[] attributes = GetAttributes<T>(attributeProvider, inherit);
		if (attributes == null)
		{
			return null;
		}
		return attributes.FirstOrDefault();
	}

	public static T[] GetAttributes<T>(object attributeProvider, bool inherit) where T : Attribute
	{
		Attribute[] attributes = GetAttributes(attributeProvider, typeof(T), inherit);
		if (attributes is T[] result)
		{
			return result;
		}
		return attributes.Cast<T>().ToArray();
	}

	public static Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit)
	{
		ValidationUtils.ArgumentNotNull(attributeProvider, "attributeProvider");
		if (attributeProvider is Type)
		{
			Type type = (Type)attributeProvider;
			Attribute[] array = (((object)attributeType != null) ? type.GetCustomAttributes(attributeType, inherit) : type.GetCustomAttributes(inherit)).Cast<Attribute>().ToArray();
			if (inherit && (object)type.BaseType != null)
			{
				array = array.Union(GetAttributes(type.BaseType, attributeType, inherit)).ToArray();
			}
			return array;
		}
		if (attributeProvider is Assembly)
		{
			Assembly element = (Assembly)attributeProvider;
			if ((object)attributeType == null)
			{
				return Attribute.GetCustomAttributes(element);
			}
			return Attribute.GetCustomAttributes(element, attributeType);
		}
		if (attributeProvider is MemberInfo)
		{
			MemberInfo element2 = (MemberInfo)attributeProvider;
			if ((object)attributeType == null)
			{
				return Attribute.GetCustomAttributes(element2, inherit);
			}
			return Attribute.GetCustomAttributes(element2, attributeType, inherit);
		}
		if (attributeProvider is Module)
		{
			Module element3 = (Module)attributeProvider;
			if ((object)attributeType == null)
			{
				return Attribute.GetCustomAttributes(element3, inherit);
			}
			return Attribute.GetCustomAttributes(element3, attributeType, inherit);
		}
		if (attributeProvider is ParameterInfo)
		{
			ParameterInfo element4 = (ParameterInfo)attributeProvider;
			if ((object)attributeType == null)
			{
				return Attribute.GetCustomAttributes(element4, inherit);
			}
			return Attribute.GetCustomAttributes(element4, attributeType, inherit);
		}
		ICustomAttributeProvider customAttributeProvider = (ICustomAttributeProvider)attributeProvider;
		return (Attribute[])(((object)attributeType != null) ? customAttributeProvider.GetCustomAttributes(attributeType, inherit) : customAttributeProvider.GetCustomAttributes(inherit));
	}

	public static void SplitFullyQualifiedTypeName(string fullyQualifiedTypeName, out string typeName, out string assemblyName)
	{
		int? assemblyDelimiterIndex = GetAssemblyDelimiterIndex(fullyQualifiedTypeName);
		if (assemblyDelimiterIndex.HasValue)
		{
			typeName = fullyQualifiedTypeName.Substring(0, assemblyDelimiterIndex.GetValueOrDefault()).Trim();
			assemblyName = fullyQualifiedTypeName.Substring(assemblyDelimiterIndex.GetValueOrDefault() + 1, fullyQualifiedTypeName.Length - assemblyDelimiterIndex.GetValueOrDefault() - 1).Trim();
		}
		else
		{
			typeName = fullyQualifiedTypeName;
			assemblyName = null;
		}
	}

	private static int? GetAssemblyDelimiterIndex(string fullyQualifiedTypeName)
	{
		int num = 0;
		for (int i = 0; i < fullyQualifiedTypeName.Length; i++)
		{
			switch (fullyQualifiedTypeName[i])
			{
			case '[':
				num++;
				break;
			case ']':
				num--;
				break;
			case ',':
				if (num == 0)
				{
					return i;
				}
				break;
			}
		}
		return null;
	}

	public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo)
	{
		MemberTypes memberTypes = memberInfo.MemberType();
		if (memberTypes == MemberTypes.Property)
		{
			PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
			Type[] types = (from p in propertyInfo.GetIndexParameters()
				select p.ParameterType).ToArray();
			return targetType.GetProperty(propertyInfo.Name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, propertyInfo.PropertyType, types, null);
		}
		return targetType.GetMember(memberInfo.Name, memberInfo.MemberType(), BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic).SingleOrDefault();
	}

	public static IEnumerable<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr)
	{
		ValidationUtils.ArgumentNotNull(targetType, "targetType");
		List<MemberInfo> list = new List<MemberInfo>(targetType.GetFields(bindingAttr));
		GetChildPrivateFields(list, targetType, bindingAttr);
		return list.Cast<FieldInfo>();
	}

	private static void GetChildPrivateFields(IList<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr)
	{
		if ((bindingAttr & BindingFlags.NonPublic) == 0)
		{
			return;
		}
		BindingFlags bindingAttr2 = bindingAttr.RemoveFlag(BindingFlags.Public);
		while ((object)(targetType = targetType.BaseType()) != null)
		{
			IEnumerable<MemberInfo> collection = (from f in targetType.GetFields(bindingAttr2)
				where f.IsPrivate
				select f).Cast<MemberInfo>();
			initialFields.AddRange(collection);
		}
	}

	public static IEnumerable<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr)
	{
		ValidationUtils.ArgumentNotNull(targetType, "targetType");
		List<PropertyInfo> list = new List<PropertyInfo>(targetType.GetProperties(bindingAttr));
		if (targetType.IsInterface())
		{
			Type[] interfaces = targetType.GetInterfaces();
			foreach (Type type in interfaces)
			{
				list.AddRange(type.GetProperties(bindingAttr));
			}
		}
		GetChildPrivateProperties(list, targetType, bindingAttr);
		for (int j = 0; j < list.Count; j++)
		{
			PropertyInfo propertyInfo = list[j];
			if ((object)propertyInfo.DeclaringType != targetType)
			{
				PropertyInfo value = (PropertyInfo)GetMemberInfoFromType(propertyInfo.DeclaringType, propertyInfo);
				list[j] = value;
			}
		}
		return list;
	}

	public static BindingFlags RemoveFlag(this BindingFlags bindingAttr, BindingFlags flag)
	{
		if ((bindingAttr & flag) != flag)
		{
			return bindingAttr;
		}
		return bindingAttr ^ flag;
	}

	private static void GetChildPrivateProperties(IList<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr)
	{
		while ((object)(targetType = targetType.BaseType()) != null)
		{
			PropertyInfo[] properties = targetType.GetProperties(bindingAttr);
			foreach (PropertyInfo propertyInfo in properties)
			{
				PropertyInfo subTypeProperty = propertyInfo;
				if (!IsPublic(subTypeProperty))
				{
					int num = initialProperties.IndexOf((PropertyInfo p) => p.Name == subTypeProperty.Name);
					if (num == -1)
					{
						initialProperties.Add(subTypeProperty);
					}
					else if (!IsPublic(initialProperties[num]))
					{
						initialProperties[num] = subTypeProperty;
					}
				}
				else if (!subTypeProperty.IsVirtual())
				{
					if (initialProperties.IndexOf((PropertyInfo p) => p.Name == subTypeProperty.Name && (object)p.DeclaringType == subTypeProperty.DeclaringType) == -1)
					{
						initialProperties.Add(subTypeProperty);
					}
				}
				else if (initialProperties.IndexOf((PropertyInfo p) => p.Name == subTypeProperty.Name && p.IsVirtual() && (object)p.GetBaseDefinition() != null && p.GetBaseDefinition().DeclaringType.IsAssignableFrom(subTypeProperty.GetBaseDefinition().DeclaringType)) == -1)
				{
					initialProperties.Add(subTypeProperty);
				}
			}
		}
	}

	public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method)
	{
		return currentType.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Any((MethodInfo info) => info.Name == method && (object)info.DeclaringType != methodDeclaringType && (object)info.GetBaseDefinition().DeclaringType == methodDeclaringType);
	}

	public static object GetDefaultValue(Type type)
	{
		if (!type.IsValueType())
		{
			return null;
		}
		switch (ConvertUtils.GetTypeCode(type))
		{
		case PrimitiveTypeCode.Boolean:
			return false;
		case PrimitiveTypeCode.Char:
		case PrimitiveTypeCode.SByte:
		case PrimitiveTypeCode.Int16:
		case PrimitiveTypeCode.UInt16:
		case PrimitiveTypeCode.Int32:
		case PrimitiveTypeCode.Byte:
		case PrimitiveTypeCode.UInt32:
			return 0;
		case PrimitiveTypeCode.Int64:
		case PrimitiveTypeCode.UInt64:
			return 0L;
		case PrimitiveTypeCode.Single:
			return 0f;
		case PrimitiveTypeCode.Double:
			return 0.0;
		case PrimitiveTypeCode.Decimal:
			return 0m;
		case PrimitiveTypeCode.DateTime:
			return default(DateTime);
		case PrimitiveTypeCode.Guid:
			return default(Guid);
		case PrimitiveTypeCode.DateTimeOffset:
			return default(DateTimeOffset);
		default:
			if (IsNullable(type))
			{
				return null;
			}
			return Activator.CreateInstance(type);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal static class StringUtils
{
	public const string CarriageReturnLineFeed = "\r\n";

	public const string Empty = "";

	public const char CarriageReturn = '\r';

	public const char LineFeed = '\n';

	public const char Tab = '\t';

	public static string FormatWith(this string format, IFormatProvider provider, object arg0)
	{
		return format.FormatWith(provider, new object[1] { arg0 });
	}

	public static string FormatWith(this string format, IFormatProvider provider, object arg0, object arg1)
	{
		return format.FormatWith(provider, new object[2] { arg0, arg1 });
	}

	public static string FormatWith(this string format, IFormatProvider provider, object arg0, object arg1, object arg2)
	{
		return format.FormatWith(provider, new object[3] { arg0, arg1, arg2 });
	}

	public static string FormatWith(this string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3)
	{
		return format.FormatWith(provider, new object[4] { arg0, arg1, arg2, arg3 });
	}

	private static string FormatWith(this string format, IFormatProvider provider, params object[] args)
	{
		ValidationUtils.ArgumentNotNull(format, "format");
		return string.Format(provider, format, args);
	}

	public static bool IsWhiteSpace(string s)
	{
		if (s == null)
		{
			throw new ArgumentNullException("s");
		}
		if (s.Length == 0)
		{
			return false;
		}
		for (int i = 0; i < s.Length; i++)
		{
			if (!char.IsWhiteSpace(s[i]))
			{
				return false;
			}
		}
		return true;
	}

	public static string NullEmptyString(string s)
	{
		if (!string.IsNullOrEmpty(s))
		{
			return s;
		}
		return null;
	}

	public static StringWriter CreateStringWriter(int capacity)
	{
		return new StringWriter(new StringBuilder(capacity), CultureInfo.InvariantCulture);
	}

	public static int? GetLength(string value)
	{
		return value?.Length;
	}

	public static void ToCharAsUnicode(char c, char[] buffer)
	{
		buffer[0] = '\\';
		buffer[1] = 'u';
		buffer[2] = MathUtils.IntToHex(((int)c >> 12) & 0xF);
		buffer[3] = MathUtils.IntToHex(((int)c >> 8) & 0xF);
		buffer[4] = MathUtils.IntToHex(((int)c >> 4) & 0xF);
		buffer[5] = MathUtils.IntToHex(c & 0xF);
	}

	public static TSource ForgivingCaseSensitiveFind<TSource>(this IEnumerable<TSource> source, Func<TSource, string> valueSelector, string testValue)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		if (valueSelector == null)
		{
			throw new ArgumentNullException("valueSelector");
		}
		IEnumerable<TSource> source2 = source.Where((TSource s) => string.Equals(valueSelector(s), testValue, StringComparison.OrdinalIgnoreCase));
		if (source2.Count() <= 1)
		{
			return source2.SingleOrDefault();
		}
		return source.Where((TSource s) => string.Equals(valueSelector(s), testValue, StringComparison.Ordinal)).SingleOrDefault();
	}

	public static string ToCamelCase(string s)
	{
		if (string.IsNullOrEmpty(s) || !char.IsUpper(s[0]))
		{
			return s;
		}
		char[] array = s.ToCharArray();
		for (int i = 0; i < array.Length && (i != 1 || char.IsUpper(array[i])); i++)
		{
			bool flag = i + 1 < array.Length;
			if (i > 0 && flag && !char.IsUpper(array[i + 1]))
			{
				break;
			}
			array[i] = char.ToLower(array[i], CultureInfo.InvariantCulture);
		}
		return new string(array);
	}

	public static bool IsHighSurrogate(char c)
	{
		return char.IsHighSurrogate(c);
	}

	public static bool IsLowSurrogate(char c)
	{
		return char.IsLowSurrogate(c);
	}

	public static bool StartsWith(this string source, char value)
	{
		if (source.Length > 0)
		{
			return source[0] == value;
		}
		return false;
	}

	public static bool EndsWith(this string source, char value)
	{
		if (source.Length > 0)
		{
			return source[source.Length - 1] == value;
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using System.Reflection;
using Newtonsoft.Json.Shims;

[Preserve]
internal static class TypeExtensions
{
	public static MethodInfo Method(this Delegate d)
	{
		return d.Method;
	}

	public static MemberTypes MemberType(this MemberInfo memberInfo)
	{
		return memberInfo.MemberType;
	}

	public static bool ContainsGenericParameters(this Type type)
	{
		return type.ContainsGenericParameters;
	}

	public static bool IsInterface(this Type type)
	{
		return type.IsInterface;
	}

	public static bool IsGenericType(this Type type)
	{
		return type.IsGenericType;
	}

	public static bool IsGenericTypeDefinition(this Type type)
	{
		return type.IsGenericTypeDefinition;
	}

	public static Type BaseType(this Type type)
	{
		return type.BaseType;
	}

	public static Assembly Assembly(this Type type)
	{
		return type.Assembly;
	}

	public static bool IsEnum(this Type type)
	{
		return type.IsEnum;
	}

	public static bool IsClass(this Type type)
	{
		return type.IsClass;
	}

	public static bool IsSealed(this Type type)
	{
		return type.IsSealed;
	}

	public static bool IsAbstract(this Type type)
	{
		return type.IsAbstract;
	}

	public static bool IsVisible(this Type type)
	{
		return type.IsVisible;
	}

	public static bool IsValueType(this Type type)
	{
		return type.IsValueType;
	}

	public static bool AssignableToTypeName(this Type type, string fullTypeName, out Type match)
	{
		Type type2 = type;
		while ((object)type2 != null)
		{
			if (string.Equals(type2.FullName, fullTypeName, StringComparison.Ordinal))
			{
				match = type2;
				return true;
			}
			type2 = BaseType(type2);
		}
		Type[] interfaces = type.GetInterfaces();
		for (int i = 0; i < interfaces.Length; i++)
		{
			if (string.Equals(interfaces[i].Name, fullTypeName, StringComparison.Ordinal))
			{
				match = type;
				return true;
			}
		}
		match = null;
		return false;
	}

	public static bool AssignableToTypeName(this Type type, string fullTypeName)
	{
		Type match;
		return AssignableToTypeName(type, fullTypeName, out match);
	}

	public static bool ImplementInterface(this Type type, Type interfaceType)
	{
		Type type2 = type;
		while ((object)type2 != null)
		{
			foreach (Type item in (IEnumerable<Type>)type2.GetInterfaces())
			{
				if ((object)item == interfaceType || ((object)item != null && ImplementInterface(item, interfaceType)))
				{
					return true;
				}
			}
			type2 = BaseType(type2);
		}
		return false;
	}
}


using System;
using Newtonsoft.Json.Shims;

[Preserve]
internal static class ValidationUtils
{
	public static void ArgumentNotNull(object value, string parameterName)
	{
		if (value == null)
		{
			throw new ArgumentNullException(parameterName);
		}
	}
}


using System;
using Newtonsoft.Json.Shims;

[Preserve]
public class PreserveAttribute : Attribute
{
}


using System;
using System.Diagnostics;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;

[Preserve]
public class DiagnosticsTraceWriter : ITraceWriter
{
	public TraceLevel LevelFilter { get; set; }

	private TraceEventType GetTraceEventType(TraceLevel level)
	{
		return level switch
		{
			TraceLevel.Error => TraceEventType.Error, 
			TraceLevel.Warning => TraceEventType.Warning, 
			TraceLevel.Info => TraceEventType.Information, 
			TraceLevel.Verbose => TraceEventType.Verbose, 
			_ => throw new ArgumentOutOfRangeException("level"), 
		};
	}

	public void Trace(TraceLevel level, string message, Exception ex)
	{
		if (level == TraceLevel.Off)
		{
			return;
		}
		TraceEventCache eventCache = new TraceEventCache();
		TraceEventType traceEventType = GetTraceEventType(level);
		foreach (TraceListener listener in System.Diagnostics.Trace.Listeners)
		{
			if (!listener.IsThreadSafe)
			{
				lock (listener)
				{
					listener.TraceEvent(eventCache, "Newtonsoft.Json", traceEventType, 0, message);
				}
			}
			else
			{
				listener.TraceEvent(eventCache, "Newtonsoft.Json", traceEventType, 0, message);
			}
			if (System.Diagnostics.Trace.AutoFlush)
			{
				listener.Flush();
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Newtonsoft.Json.Shims;

[Preserve]
public interface IAttributeProvider
{
	IList<Attribute> GetAttributes(bool inherit);

	IList<Attribute> GetAttributes(Type attributeType, bool inherit);
}


using System;
using System.Diagnostics;
using Newtonsoft.Json.Shims;

[Preserve]
public interface ITraceWriter
{
	TraceLevel LevelFilter { get; }

	void Trace(TraceLevel level, string message, Exception ex);
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JsonContainerContract : JsonContract
{
	private JsonContract _itemContract;

	private JsonContract _finalItemContract;

	internal JsonContract ItemContract
	{
		get
		{
			return _itemContract;
		}
		set
		{
			_itemContract = value;
			if (_itemContract != null)
			{
				_finalItemContract = (_itemContract.UnderlyingType.IsSealed() ? _itemContract : null);
			}
			else
			{
				_finalItemContract = null;
			}
		}
	}

	internal JsonContract FinalItemContract => _finalItemContract;

	public JsonConverter ItemConverter { get; set; }

	public bool? ItemIsReference { get; set; }

	public ReferenceLoopHandling? ItemReferenceLoopHandling { get; set; }

	public TypeNameHandling? ItemTypeNameHandling { get; set; }

	internal JsonContainerContract(Type underlyingType)
		: base(underlyingType)
	{
		JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(underlyingType);
		if (cachedAttribute != null)
		{
			if ((object)cachedAttribute.ItemConverterType != null)
			{
				ItemConverter = JsonTypeReflector.CreateJsonConverterInstance(cachedAttribute.ItemConverterType, cachedAttribute.ItemConverterParameters);
			}
			ItemIsReference = cachedAttribute._itemIsReference;
			ItemReferenceLoopHandling = cachedAttribute._itemReferenceLoopHandling;
			ItemTypeNameHandling = cachedAttribute._itemTypeNameHandling;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Text;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;

[Preserve]
public class MemoryTraceWriter : ITraceWriter
{
	private readonly Queue<string> _traceMessages;

	public TraceLevel LevelFilter { get; set; }

	public MemoryTraceWriter()
	{
		LevelFilter = TraceLevel.Verbose;
		_traceMessages = new Queue<string>();
	}

	public void Trace(TraceLevel level, string message, Exception ex)
	{
		if (_traceMessages.Count >= 1000)
		{
			_traceMessages.Dequeue();
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append(DateTime.Now.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fff", CultureInfo.InvariantCulture));
		stringBuilder.Append(" ");
		stringBuilder.Append(level.ToString("g"));
		stringBuilder.Append(" ");
		stringBuilder.Append(message);
		_traceMessages.Enqueue(stringBuilder.ToString());
	}

	public IEnumerable<string> GetTraceMessages()
	{
		return _traceMessages;
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (string traceMessage in _traceMessages)
		{
			if (stringBuilder.Length > 0)
			{
				stringBuilder.AppendLine();
			}
			stringBuilder.Append(traceMessage);
		}
		return stringBuilder.ToString();
	}
}


using System;
using System.Collections.Generic;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class ReflectionAttributeProvider : IAttributeProvider
{
	private readonly object _attributeProvider;

	public ReflectionAttributeProvider(object attributeProvider)
	{
		ValidationUtils.ArgumentNotNull(attributeProvider, "attributeProvider");
		_attributeProvider = attributeProvider;
	}

	public IList<Attribute> GetAttributes(bool inherit)
	{
		return ReflectionUtils.GetAttributes(_attributeProvider, null, inherit);
	}

	public IList<Attribute> GetAttributes(Type attributeType, bool inherit)
	{
		return ReflectionUtils.GetAttributes(_attributeProvider, attributeType, inherit);
	}
}


using System;
using System.Globalization;
using System.IO;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Preserve]
internal class TraceJsonReader : JsonReader, IJsonLineInfo
{
	private readonly JsonReader _innerReader;

	private readonly JsonTextWriter _textWriter;

	private readonly StringWriter _sw;

	public override int Depth => _innerReader.Depth;

	public override string Path => _innerReader.Path;

	public override char QuoteChar
	{
		get
		{
			return _innerReader.QuoteChar;
		}
		protected internal set
		{
			_innerReader.QuoteChar = value;
		}
	}

	public override JsonToken TokenType => _innerReader.TokenType;

	public override object Value => _innerReader.Value;

	public override Type ValueType => _innerReader.ValueType;

	int IJsonLineInfo.LineNumber
	{
		get
		{
			if (!(_innerReader is IJsonLineInfo jsonLineInfo))
			{
				return 0;
			}
			return jsonLineInfo.LineNumber;
		}
	}

	int IJsonLineInfo.LinePosition
	{
		get
		{
			if (!(_innerReader is IJsonLineInfo jsonLineInfo))
			{
				return 0;
			}
			return jsonLineInfo.LinePosition;
		}
	}

	public TraceJsonReader(JsonReader innerReader)
	{
		_innerReader = innerReader;
		_sw = new StringWriter(CultureInfo.InvariantCulture);
		_sw.Write("Deserialized JSON: " + Environment.NewLine);
		_textWriter = new JsonTextWriter(_sw);
		_textWriter.Formatting = Formatting.Indented;
	}

	public string GetDeserializedJsonMessage()
	{
		return _sw.ToString();
	}

	public override bool Read()
	{
		bool result = _innerReader.Read();
		_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
		return result;
	}

	public override int? ReadAsInt32()
	{
		int? result = _innerReader.ReadAsInt32();
		_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
		return result;
	}

	public override string ReadAsString()
	{
		string result = _innerReader.ReadAsString();
		_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
		return result;
	}

	public override byte[] ReadAsBytes()
	{
		byte[] result = _innerReader.ReadAsBytes();
		_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
		return result;
	}

	public override decimal? ReadAsDecimal()
	{
		decimal? result = _innerReader.ReadAsDecimal();
		_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
		return result;
	}

	public override double? ReadAsDouble()
	{
		double? result = _innerReader.ReadAsDouble();
		_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
		return result;
	}

	public override bool? ReadAsBoolean()
	{
		bool? result = _innerReader.ReadAsBoolean();
		_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
		return result;
	}

	public override DateTime? ReadAsDateTime()
	{
		DateTime? result = _innerReader.ReadAsDateTime();
		_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
		return result;
	}

	public override DateTimeOffset? ReadAsDateTimeOffset()
	{
		DateTimeOffset? result = _innerReader.ReadAsDateTimeOffset();
		_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
		return result;
	}

	public override void Close()
	{
		_innerReader.Close();
	}

	bool IJsonLineInfo.HasLineInfo()
	{
		if (_innerReader is IJsonLineInfo jsonLineInfo)
		{
			return jsonLineInfo.HasLineInfo();
		}
		return false;
	}
}


using System;
using System.Globalization;
using System.IO;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Preserve]
internal class TraceJsonWriter : JsonWriter
{
	private readonly JsonWriter _innerWriter;

	private readonly JsonTextWriter _textWriter;

	private readonly StringWriter _sw;

	public TraceJsonWriter(JsonWriter innerWriter)
	{
		_innerWriter = innerWriter;
		_sw = new StringWriter(CultureInfo.InvariantCulture);
		_sw.Write("Serialized JSON: " + Environment.NewLine);
		_textWriter = new JsonTextWriter(_sw);
		_textWriter.Formatting = Formatting.Indented;
		_textWriter.Culture = innerWriter.Culture;
		_textWriter.DateFormatHandling = innerWriter.DateFormatHandling;
		_textWriter.DateFormatString = innerWriter.DateFormatString;
		_textWriter.DateTimeZoneHandling = innerWriter.DateTimeZoneHandling;
		_textWriter.FloatFormatHandling = innerWriter.FloatFormatHandling;
	}

	public string GetSerializedJsonMessage()
	{
		return _sw.ToString();
	}

	public override void WriteValue(decimal value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(bool value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(byte value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(byte? value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(char value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(byte[] value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(DateTime value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(DateTimeOffset value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(double value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteUndefined()
	{
		_textWriter.WriteUndefined();
		_innerWriter.WriteUndefined();
		base.WriteUndefined();
	}

	public override void WriteNull()
	{
		_textWriter.WriteNull();
		_innerWriter.WriteNull();
		base.WriteUndefined();
	}

	public override void WriteValue(float value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(Guid value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(int value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(long value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(object value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(sbyte value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(short value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(string value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(TimeSpan value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(uint value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(ulong value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(Uri value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteValue(ushort value)
	{
		_textWriter.WriteValue(value);
		_innerWriter.WriteValue(value);
		base.WriteValue(value);
	}

	public override void WriteWhitespace(string ws)
	{
		_textWriter.WriteWhitespace(ws);
		_innerWriter.WriteWhitespace(ws);
		base.WriteWhitespace(ws);
	}

	public override void WriteComment(string text)
	{
		_textWriter.WriteComment(text);
		_innerWriter.WriteComment(text);
		base.WriteComment(text);
	}

	public override void WriteStartArray()
	{
		_textWriter.WriteStartArray();
		_innerWriter.WriteStartArray();
		base.WriteStartArray();
	}

	public override void WriteEndArray()
	{
		_textWriter.WriteEndArray();
		_innerWriter.WriteEndArray();
		base.WriteEndArray();
	}

	public override void WriteStartConstructor(string name)
	{
		_textWriter.WriteStartConstructor(name);
		_innerWriter.WriteStartConstructor(name);
		base.WriteStartConstructor(name);
	}

	public override void WriteEndConstructor()
	{
		_textWriter.WriteEndConstructor();
		_innerWriter.WriteEndConstructor();
		base.WriteEndConstructor();
	}

	public override void WritePropertyName(string name)
	{
		_textWriter.WritePropertyName(name);
		_innerWriter.WritePropertyName(name);
		base.WritePropertyName(name);
	}

	public override void WritePropertyName(string name, bool escape)
	{
		_textWriter.WritePropertyName(name, escape);
		_innerWriter.WritePropertyName(name, escape);
		base.WritePropertyName(name);
	}

	public override void WriteStartObject()
	{
		_textWriter.WriteStartObject();
		_innerWriter.WriteStartObject();
		base.WriteStartObject();
	}

	public override void WriteEndObject()
	{
		_textWriter.WriteEndObject();
		_innerWriter.WriteEndObject();
		base.WriteEndObject();
	}

	public override void WriteRawValue(string json)
	{
		_textWriter.WriteRawValue(json);
		_innerWriter.WriteRawValue(json);
		InternalWriteValue(JsonToken.Undefined);
	}

	public override void WriteRaw(string json)
	{
		_textWriter.WriteRaw(json);
		_innerWriter.WriteRaw(json);
		base.WriteRaw(json);
	}

	public override void Close()
	{
		_textWriter.Close();
		_innerWriter.Close();
		base.Close();
	}

	public override void Flush()
	{
		_textWriter.Flush();
		_innerWriter.Flush();
	}
}


using System;
using System.Globalization;
using System.Runtime.Serialization;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class JsonFormatterConverter : IFormatterConverter
{
	private readonly JsonSerializerInternalReader _reader;

	private readonly JsonISerializableContract _contract;

	private readonly JsonProperty _member;

	public JsonFormatterConverter(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty member)
	{
		ValidationUtils.ArgumentNotNull(reader, "reader");
		ValidationUtils.ArgumentNotNull(contract, "contract");
		_reader = reader;
		_contract = contract;
		_member = member;
	}

	private T GetTokenValue<T>(object value)
	{
		ValidationUtils.ArgumentNotNull(value, "value");
		return (T)System.Convert.ChangeType(((JValue)value).Value, typeof(T), CultureInfo.InvariantCulture);
	}

	public object Convert(object value, Type type)
	{
		ValidationUtils.ArgumentNotNull(value, "value");
		if (!(value is JToken token))
		{
			throw new ArgumentException("Value is not a JToken.", "value");
		}
		return _reader.CreateISerializableItem(token, type, _contract, _member);
	}

	public object Convert(object value, TypeCode typeCode)
	{
		ValidationUtils.ArgumentNotNull(value, "value");
		if (value is JValue)
		{
			value = ((JValue)value).Value;
		}
		return System.Convert.ChangeType(value, typeCode, CultureInfo.InvariantCulture);
	}

	public bool ToBoolean(object value)
	{
		return GetTokenValue<bool>(value);
	}

	public byte ToByte(object value)
	{
		return GetTokenValue<byte>(value);
	}

	public char ToChar(object value)
	{
		return GetTokenValue<char>(value);
	}

	public DateTime ToDateTime(object value)
	{
		return GetTokenValue<DateTime>(value);
	}

	public decimal ToDecimal(object value)
	{
		return GetTokenValue<decimal>(value);
	}

	public double ToDouble(object value)
	{
		return GetTokenValue<double>(value);
	}

	public short ToInt16(object value)
	{
		return GetTokenValue<short>(value);
	}

	public int ToInt32(object value)
	{
		return GetTokenValue<int>(value);
	}

	public long ToInt64(object value)
	{
		return GetTokenValue<long>(value);
	}

	public sbyte ToSByte(object value)
	{
		return GetTokenValue<sbyte>(value);
	}

	public float ToSingle(object value)
	{
		return GetTokenValue<float>(value);
	}

	public string ToString(object value)
	{
		return GetTokenValue<string>(value);
	}

	public ushort ToUInt16(object value)
	{
		return GetTokenValue<ushort>(value);
	}

	public uint ToUInt32(object value)
	{
		return GetTokenValue<uint>(value);
	}

	public ulong ToUInt64(object value)
	{
		return GetTokenValue<ulong>(value);
	}
}


using System;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;

[Preserve]
public class JsonISerializableContract : JsonContainerContract
{
	public ObjectConstructor<object> ISerializableCreator { get; set; }

	public JsonISerializableContract(Type underlyingType)
		: base(underlyingType)
	{
		ContractType = JsonContractType.Serializable;
	}
}


using System;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;

[Preserve]
public class JsonLinqContract : JsonContract
{
	public JsonLinqContract(Type underlyingType)
		: base(underlyingType)
	{
		ContractType = JsonContractType.Linq;
	}
}


using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JsonPrimitiveContract : JsonContract
{
	private static readonly Dictionary<Type, ReadType> ReadTypeMap = new Dictionary<Type, ReadType>
	{
		[typeof(byte[])] = ReadType.ReadAsBytes,
		[typeof(byte)] = ReadType.ReadAsInt32,
		[typeof(short)] = ReadType.ReadAsInt32,
		[typeof(int)] = ReadType.ReadAsInt32,
		[typeof(decimal)] = ReadType.ReadAsDecimal,
		[typeof(bool)] = ReadType.ReadAsBoolean,
		[typeof(string)] = ReadType.ReadAsString,
		[typeof(DateTime)] = ReadType.ReadAsDateTime,
		[typeof(DateTimeOffset)] = ReadType.ReadAsDateTimeOffset,
		[typeof(float)] = ReadType.ReadAsDouble,
		[typeof(double)] = ReadType.ReadAsDouble
	};

	internal PrimitiveTypeCode TypeCode { get; set; }

	public JsonPrimitiveContract(Type underlyingType)
		: base(underlyingType)
	{
		ContractType = JsonContractType.Primitive;
		TypeCode = ConvertUtils.GetTypeCode(underlyingType);
		IsReadOnlyOrFixedSize = true;
		if (ReadTypeMap.TryGetValue(NonNullableUnderlyingType, out var value))
		{
			InternalReadType = value;
		}
	}
}


using System;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;

[Preserve]
public class ErrorEventArgs : EventArgs
{
	public object CurrentObject { get; private set; }

	public ErrorContext ErrorContext { get; private set; }

	public ErrorEventArgs(object currentObject, ErrorContext errorContext)
	{
		CurrentObject = currentObject;
		ErrorContext = errorContext;
	}
}


using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class DefaultReferenceResolver : IReferenceResolver
{
	private int _referenceCount;

	private BidirectionalDictionary<string, object> GetMappings(object context)
	{
		JsonSerializerInternalBase jsonSerializerInternalBase;
		if (context is JsonSerializerInternalBase)
		{
			jsonSerializerInternalBase = (JsonSerializerInternalBase)context;
		}
		else
		{
			if (!(context is JsonSerializerProxy))
			{
				throw new JsonException("The DefaultReferenceResolver can only be used internally.");
			}
			jsonSerializerInternalBase = ((JsonSerializerProxy)context).GetInternalSerializer();
		}
		return jsonSerializerInternalBase.DefaultReferenceMappings;
	}

	public object ResolveReference(object context, string reference)
	{
		GetMappings(context).TryGetByFirst(reference, out var second);
		return second;
	}

	public string GetReference(object context, object value)
	{
		BidirectionalDictionary<string, object> mappings = GetMappings(context);
		if (!mappings.TryGetBySecond(value, out var first))
		{
			_referenceCount++;
			first = _referenceCount.ToString(CultureInfo.InvariantCulture);
			mappings.Set(first, value);
		}
		return first;
	}

	public void AddReference(object context, string reference, object value)
	{
		GetMappings(context).Set(reference, value);
	}

	public bool IsReferenced(object context, object value)
	{
		string first;
		return GetMappings(context).TryGetBySecond(value, out first);
	}
}


using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class CamelCasePropertyNamesContractResolver : DefaultContractResolver
{
	public CamelCasePropertyNamesContractResolver()
		: base(shareCache: true)
	{
	}

	protected override string ResolvePropertyName(string propertyName)
	{
		return StringUtils.ToCamelCase(propertyName);
	}
}


using System;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;

[Preserve]
internal struct ResolverContractKey
{
	private readonly Type _resolverType;

	private readonly Type _contractType;

	public ResolverContractKey(Type resolverType, Type contractType)
	{
		_resolverType = resolverType;
		_contractType = contractType;
	}

	public override int GetHashCode()
	{
		return _resolverType.GetHashCode() ^ _contractType.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ResolverContractKey))
		{
			return false;
		}
		return Equals((ResolverContractKey)obj);
	}

	public bool Equals(ResolverContractKey other)
	{
		if ((object)_resolverType == other._resolverType)
		{
			return (object)_contractType == other._contractType;
		}
		return false;
	}
}


using System.Collections.Generic;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class DefaultContractResolverState
{
	public Dictionary<ResolverContractKey, JsonContract> ContractCache;

	public PropertyNameTable NameTable = new PropertyNameTable();
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class DefaultContractResolver : IContractResolver
{
	internal class EnumerableDictionaryWrapper<TEnumeratorKey, TEnumeratorValue> : IEnumerable<KeyValuePair<object, object>>, IEnumerable
	{
		private readonly IEnumerable<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;

		public EnumerableDictionaryWrapper(IEnumerable<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
		{
			ValidationUtils.ArgumentNotNull(e, "e");
			_e = e;
		}

		public IEnumerator<KeyValuePair<object, object>> GetEnumerator()
		{
			foreach (KeyValuePair<TEnumeratorKey, TEnumeratorValue> item in _e)
			{
				yield return new KeyValuePair<object, object>(item.Key, item.Value);
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	private static readonly IContractResolver _instance = new DefaultContractResolver(shareCache: true);

	private static readonly JsonConverter[] BuiltInConverters = new JsonConverter[4]
	{
		new XmlNodeConverter(),
		new KeyValuePairConverter(),
		new BsonObjectIdConverter(),
		new RegexConverter()
	};

	private static readonly object TypeContractCacheLock = new object();

	private static readonly DefaultContractResolverState _sharedState = new DefaultContractResolverState();

	private readonly DefaultContractResolverState _instanceState = new DefaultContractResolverState();

	private readonly bool _sharedCache;

	internal static IContractResolver Instance => _instance;

	public bool DynamicCodeGeneration => JsonTypeReflector.DynamicCodeGeneration;

	[Obsolete("DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.")]
	public BindingFlags DefaultMembersSearchFlags { get; set; }

	public bool SerializeCompilerGeneratedMembers { get; set; }

	public bool IgnoreSerializableInterface { get; set; }

	public bool IgnoreSerializableAttribute { get; set; }

	public DefaultContractResolver()
	{
		IgnoreSerializableAttribute = true;
		DefaultMembersSearchFlags = BindingFlags.Instance | BindingFlags.Public;
	}

	[Obsolete("DefaultContractResolver(bool) is obsolete. Use the parameterless constructor and cache instances of the contract resolver within your application for optimal performance.")]
	public DefaultContractResolver(bool shareCache)
		: this()
	{
		_sharedCache = shareCache;
	}

	internal DefaultContractResolverState GetState()
	{
		if (_sharedCache)
		{
			return _sharedState;
		}
		return _instanceState;
	}

	public virtual JsonContract ResolveContract(Type type)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		DefaultContractResolverState state = GetState();
		ResolverContractKey key = new ResolverContractKey(GetType(), type);
		Dictionary<ResolverContractKey, JsonContract> contractCache = state.ContractCache;
		if (contractCache == null || !contractCache.TryGetValue(key, out var value))
		{
			value = CreateContract(type);
			lock (TypeContractCacheLock)
			{
				contractCache = state.ContractCache;
				Dictionary<ResolverContractKey, JsonContract> dictionary = ((contractCache != null) ? new Dictionary<ResolverContractKey, JsonContract>(contractCache) : new Dictionary<ResolverContractKey, JsonContract>());
				dictionary[key] = value;
				state.ContractCache = dictionary;
			}
		}
		return value;
	}

	protected virtual List<MemberInfo> GetSerializableMembers(Type objectType)
	{
		bool ignoreSerializableAttribute = IgnoreSerializableAttribute;
		MemberSerialization objectMemberSerialization = JsonTypeReflector.GetObjectMemberSerialization(objectType, ignoreSerializableAttribute);
		List<MemberInfo> list = (from m in ReflectionUtils.GetFieldsAndProperties(objectType, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)
			where !ReflectionUtils.IsIndexedProperty(m)
			select m).ToList();
		List<MemberInfo> list2 = new List<MemberInfo>();
		if (objectMemberSerialization != MemberSerialization.Fields)
		{
			DataContractAttribute dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(objectType);
			List<MemberInfo> list3 = (from m in ReflectionUtils.GetFieldsAndProperties(objectType, DefaultMembersSearchFlags)
				where !ReflectionUtils.IsIndexedProperty(m)
				select m).ToList();
			foreach (MemberInfo item in list)
			{
				if (SerializeCompilerGeneratedMembers || !item.IsDefined(typeof(CompilerGeneratedAttribute), inherit: true))
				{
					if (list3.Contains(item))
					{
						list2.Add(item);
					}
					else if (JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(item) != null)
					{
						list2.Add(item);
					}
					else if (JsonTypeReflector.GetAttribute<JsonRequiredAttribute>(item) != null)
					{
						list2.Add(item);
					}
					else if (dataContractAttribute != null && JsonTypeReflector.GetAttribute<DataMemberAttribute>(item) != null)
					{
						list2.Add(item);
					}
					else if (objectMemberSerialization == MemberSerialization.Fields && item.MemberType() == MemberTypes.Field)
					{
						list2.Add(item);
					}
				}
			}
			if (objectType.AssignableToTypeName("System.Data.Objects.DataClasses.EntityObject", out var _))
			{
				list2 = list2.Where(ShouldSerializeEntityMember).ToList();
			}
		}
		else
		{
			foreach (MemberInfo item2 in list)
			{
				if (item2 is FieldInfo { IsStatic: false })
				{
					list2.Add(item2);
				}
			}
		}
		return list2;
	}

	private bool ShouldSerializeEntityMember(MemberInfo memberInfo)
	{
		if (memberInfo is PropertyInfo propertyInfo && propertyInfo.PropertyType.IsGenericType() && propertyInfo.PropertyType.GetGenericTypeDefinition().FullName == "System.Data.Objects.DataClasses.EntityReference`1")
		{
			return false;
		}
		return true;
	}

	protected virtual JsonObjectContract CreateObjectContract(Type objectType)
	{
		JsonObjectContract jsonObjectContract = new JsonObjectContract(objectType);
		InitializeContract(jsonObjectContract);
		bool ignoreSerializableAttribute = IgnoreSerializableAttribute;
		jsonObjectContract.MemberSerialization = JsonTypeReflector.GetObjectMemberSerialization(jsonObjectContract.NonNullableUnderlyingType, ignoreSerializableAttribute);
		jsonObjectContract.Properties.AddRange(CreateProperties(jsonObjectContract.NonNullableUnderlyingType, jsonObjectContract.MemberSerialization));
		JsonObjectAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonObjectAttribute>(jsonObjectContract.NonNullableUnderlyingType);
		if (cachedAttribute != null)
		{
			jsonObjectContract.ItemRequired = cachedAttribute._itemRequired;
		}
		if (jsonObjectContract.IsInstantiable)
		{
			ConstructorInfo attributeConstructor = GetAttributeConstructor(jsonObjectContract.NonNullableUnderlyingType);
			if ((object)attributeConstructor != null)
			{
				jsonObjectContract.OverrideConstructor = attributeConstructor;
				jsonObjectContract.CreatorParameters.AddRange(CreateConstructorParameters(attributeConstructor, jsonObjectContract.Properties));
			}
			else if (jsonObjectContract.MemberSerialization == MemberSerialization.Fields)
			{
				if (JsonTypeReflector.FullyTrusted)
				{
					jsonObjectContract.DefaultCreator = jsonObjectContract.GetUninitializedObject;
				}
			}
			else if (jsonObjectContract.DefaultCreator == null || jsonObjectContract.DefaultCreatorNonPublic)
			{
				ConstructorInfo parameterizedConstructor = GetParameterizedConstructor(jsonObjectContract.NonNullableUnderlyingType);
				if ((object)parameterizedConstructor != null)
				{
					jsonObjectContract.ParametrizedConstructor = parameterizedConstructor;
					jsonObjectContract.CreatorParameters.AddRange(CreateConstructorParameters(parameterizedConstructor, jsonObjectContract.Properties));
				}
			}
		}
		MemberInfo extensionDataMemberForType = GetExtensionDataMemberForType(jsonObjectContract.NonNullableUnderlyingType);
		if ((object)extensionDataMemberForType != null)
		{
			SetExtensionDataDelegates(jsonObjectContract, extensionDataMemberForType);
		}
		return jsonObjectContract;
	}

	private MemberInfo GetExtensionDataMemberForType(Type type)
	{
		return GetClassHierarchyForType(type).SelectMany(delegate(Type baseType)
		{
			List<MemberInfo> list = new List<MemberInfo>();
			CollectionUtils.AddRange(list, baseType.GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
			CollectionUtils.AddRange(list, baseType.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
			return list;
		}).LastOrDefault(delegate(MemberInfo m)
		{
			MemberTypes memberTypes = m.MemberType();
			if (memberTypes != MemberTypes.Property && memberTypes != MemberTypes.Field)
			{
				return false;
			}
			if (!m.IsDefined(typeof(JsonExtensionDataAttribute), inherit: false))
			{
				return false;
			}
			if (!ReflectionUtils.CanReadMemberValue(m, nonPublic: true))
			{
				throw new JsonException("Invalid extension data attribute on '{0}'. Member '{1}' must have a getter.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(m.DeclaringType), m.Name));
			}
			if (ReflectionUtils.ImplementsGenericDefinition(ReflectionUtils.GetMemberUnderlyingType(m), typeof(IDictionary<, >), out var implementingType))
			{
				Type obj = implementingType.GetGenericArguments()[0];
				Type type2 = implementingType.GetGenericArguments()[1];
				if (obj.IsAssignableFrom(typeof(string)) && type2.IsAssignableFrom(typeof(JToken)))
				{
					return true;
				}
			}
			throw new JsonException("Invalid extension data attribute on '{0}'. Member '{1}' type must implement IDictionary<string, JToken>.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(m.DeclaringType), m.Name));
		});
	}

	private static void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member)
	{
		JsonExtensionDataAttribute attribute = ReflectionUtils.GetAttribute<JsonExtensionDataAttribute>(member);
		if (attribute == null)
		{
			return;
		}
		Type memberUnderlyingType = ReflectionUtils.GetMemberUnderlyingType(member);
		ReflectionUtils.ImplementsGenericDefinition(memberUnderlyingType, typeof(IDictionary<, >), out var implementingType);
		Type type = implementingType.GetGenericArguments()[0];
		Type type2 = implementingType.GetGenericArguments()[1];
		Type type3 = ((!ReflectionUtils.IsGenericDefinition(memberUnderlyingType, typeof(IDictionary<, >))) ? memberUnderlyingType : typeof(Dictionary<, >).MakeGenericType(type, type2));
		Func<object, object> getExtensionDataDictionary = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(member);
		if (attribute.ReadData)
		{
			Action<object, object> setExtensionDataDictionary = (ReflectionUtils.CanSetMemberValue(member, nonPublic: true, canSetReadOnly: false) ? JsonTypeReflector.ReflectionDelegateFactory.CreateSet<object>(member) : null);
			Func<object> createExtensionDataDictionary = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type3);
			MethodInfo method = memberUnderlyingType.GetMethod("Add", new Type[2] { type, type2 });
			MethodCall<object, object> setExtensionDataDictionaryValue = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
			ExtensionDataSetter extensionDataSetter = delegate(object o, string key, object value)
			{
				object obj = getExtensionDataDictionary(o);
				if (obj == null)
				{
					if (setExtensionDataDictionary == null)
					{
						throw new JsonSerializationException("Cannot set value onto extension data member '{0}'. The extension data collection is null and it cannot be set.".FormatWith(CultureInfo.InvariantCulture, member.Name));
					}
					obj = createExtensionDataDictionary();
					setExtensionDataDictionary(o, obj);
				}
				setExtensionDataDictionaryValue(obj, key, value);
			};
			contract.ExtensionDataSetter = extensionDataSetter;
		}
		if (attribute.WriteData)
		{
			ConstructorInfo method2 = typeof(EnumerableDictionaryWrapper<, >).MakeGenericType(type, type2).GetConstructors().First();
			ObjectConstructor<object> createEnumerableWrapper = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(method2);
			ExtensionDataGetter extensionDataGetter = delegate(object o)
			{
				object obj2 = getExtensionDataDictionary(o);
				return (obj2 == null) ? null : ((IEnumerable<KeyValuePair<object, object>>)createEnumerableWrapper(obj2));
			};
			contract.ExtensionDataGetter = extensionDataGetter;
		}
		contract.ExtensionDataValueType = type2;
	}

	private ConstructorInfo GetAttributeConstructor(Type objectType)
	{
		IList<ConstructorInfo> list = (from c in objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
			where c.IsDefined(typeof(JsonConstructorAttribute), inherit: true)
			select c).ToList();
		if (list.Count > 1)
		{
			throw new JsonException("Multiple constructors with the JsonConstructorAttribute.");
		}
		if (list.Count == 1)
		{
			return list[0];
		}
		if ((object)objectType == typeof(Version))
		{
			return objectType.GetConstructor(new Type[4]
			{
				typeof(int),
				typeof(int),
				typeof(int),
				typeof(int)
			});
		}
		return null;
	}

	private ConstructorInfo GetParameterizedConstructor(Type objectType)
	{
		IList<ConstructorInfo> list = objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public).ToList();
		if (list.Count == 1)
		{
			return list[0];
		}
		return null;
	}

	protected virtual IList<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties)
	{
		ParameterInfo[] parameters = constructor.GetParameters();
		JsonPropertyCollection jsonPropertyCollection = new JsonPropertyCollection(constructor.DeclaringType);
		ParameterInfo[] array = parameters;
		foreach (ParameterInfo parameterInfo in array)
		{
			JsonProperty jsonProperty = ((parameterInfo.Name != null) ? memberProperties.GetClosestMatchProperty(parameterInfo.Name) : null);
			if (jsonProperty != null && (object)jsonProperty.PropertyType != parameterInfo.ParameterType)
			{
				jsonProperty = null;
			}
			if (jsonProperty != null || parameterInfo.Name != null)
			{
				JsonProperty jsonProperty2 = CreatePropertyFromConstructorParameter(jsonProperty, parameterInfo);
				if (jsonProperty2 != null)
				{
					jsonPropertyCollection.AddProperty(jsonProperty2);
				}
			}
		}
		return jsonPropertyCollection;
	}

	protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo)
	{
		JsonProperty jsonProperty = new JsonProperty();
		jsonProperty.PropertyType = parameterInfo.ParameterType;
		jsonProperty.AttributeProvider = new ReflectionAttributeProvider(parameterInfo);
		SetPropertySettingsFromAttributes(jsonProperty, parameterInfo, parameterInfo.Name, parameterInfo.Member.DeclaringType, MemberSerialization.OptOut, out var _);
		jsonProperty.Readable = false;
		jsonProperty.Writable = true;
		if (matchingMemberProperty != null)
		{
			jsonProperty.PropertyName = ((jsonProperty.PropertyName != parameterInfo.Name) ? jsonProperty.PropertyName : matchingMemberProperty.PropertyName);
			jsonProperty.Converter = jsonProperty.Converter ?? matchingMemberProperty.Converter;
			jsonProperty.MemberConverter = jsonProperty.MemberConverter ?? matchingMemberProperty.MemberConverter;
			if (!jsonProperty._hasExplicitDefaultValue && matchingMemberProperty._hasExplicitDefaultValue)
			{
				jsonProperty.DefaultValue = matchingMemberProperty.DefaultValue;
			}
			jsonProperty._required = jsonProperty._required ?? matchingMemberProperty._required;
			jsonProperty.IsReference = jsonProperty.IsReference ?? matchingMemberProperty.IsReference;
			jsonProperty.NullValueHandling = jsonProperty.NullValueHandling ?? matchingMemberProperty.NullValueHandling;
			jsonProperty.DefaultValueHandling = jsonProperty.DefaultValueHandling ?? matchingMemberProperty.DefaultValueHandling;
			jsonProperty.ReferenceLoopHandling = jsonProperty.ReferenceLoopHandling ?? matchingMemberProperty.ReferenceLoopHandling;
			jsonProperty.ObjectCreationHandling = jsonProperty.ObjectCreationHandling ?? matchingMemberProperty.ObjectCreationHandling;
			jsonProperty.TypeNameHandling = jsonProperty.TypeNameHandling ?? matchingMemberProperty.TypeNameHandling;
		}
		return jsonProperty;
	}

	protected virtual JsonConverter ResolveContractConverter(Type objectType)
	{
		return JsonTypeReflector.GetJsonConverter(objectType);
	}

	private Func<object> GetDefaultCreator(Type createdType)
	{
		return JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(createdType);
	}

	private void InitializeContract(JsonContract contract)
	{
		JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(contract.NonNullableUnderlyingType);
		if (cachedAttribute != null)
		{
			contract.IsReference = cachedAttribute._isReference;
		}
		else
		{
			DataContractAttribute dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(contract.NonNullableUnderlyingType);
			if (dataContractAttribute != null && dataContractAttribute.IsReference)
			{
				contract.IsReference = true;
			}
		}
		contract.Converter = ResolveContractConverter(contract.NonNullableUnderlyingType);
		contract.InternalConverter = JsonSerializer.GetMatchingConverter(BuiltInConverters, contract.NonNullableUnderlyingType);
		if (contract.IsInstantiable && (ReflectionUtils.HasDefaultConstructor(contract.CreatedType, nonPublic: true) || contract.CreatedType.IsValueType()))
		{
			contract.DefaultCreator = GetDefaultCreator(contract.CreatedType);
			contract.DefaultCreatorNonPublic = !contract.CreatedType.IsValueType() && (object)ReflectionUtils.GetDefaultConstructor(contract.CreatedType) == null;
		}
		ResolveCallbackMethods(contract, contract.NonNullableUnderlyingType);
	}

	private void ResolveCallbackMethods(JsonContract contract, Type t)
	{
		GetCallbackMethodsForType(t, out var onSerializing, out var onSerialized, out var onDeserializing, out var onDeserialized, out var onError);
		if (onSerializing != null)
		{
			contract.OnSerializingCallbacks.AddRange(onSerializing);
		}
		if (onSerialized != null)
		{
			contract.OnSerializedCallbacks.AddRange(onSerialized);
		}
		if (onDeserializing != null)
		{
			contract.OnDeserializingCallbacks.AddRange(onDeserializing);
		}
		if (onDeserialized != null)
		{
			contract.OnDeserializedCallbacks.AddRange(onDeserialized);
		}
		if (onError != null)
		{
			contract.OnErrorCallbacks.AddRange(onError);
		}
	}

	private void GetCallbackMethodsForType(Type type, out List<SerializationCallback> onSerializing, out List<SerializationCallback> onSerialized, out List<SerializationCallback> onDeserializing, out List<SerializationCallback> onDeserialized, out List<SerializationErrorCallback> onError)
	{
		onSerializing = null;
		onSerialized = null;
		onDeserializing = null;
		onDeserialized = null;
		onError = null;
		foreach (Type item in GetClassHierarchyForType(type))
		{
			MethodInfo currentCallback = null;
			MethodInfo currentCallback2 = null;
			MethodInfo currentCallback3 = null;
			MethodInfo currentCallback4 = null;
			MethodInfo currentCallback5 = null;
			bool flag = ShouldSkipSerializing(item);
			bool flag2 = ShouldSkipDeserialized(item);
			MethodInfo[] methods = item.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (MethodInfo methodInfo in methods)
			{
				if (!methodInfo.ContainsGenericParameters)
				{
					Type prevAttributeType = null;
					ParameterInfo[] parameters = methodInfo.GetParameters();
					if (!flag && IsValidCallback(methodInfo, parameters, typeof(OnSerializingAttribute), currentCallback, ref prevAttributeType))
					{
						onSerializing = onSerializing ?? new List<SerializationCallback>();
						onSerializing.Add(JsonContract.CreateSerializationCallback(methodInfo));
						currentCallback = methodInfo;
					}
					if (IsValidCallback(methodInfo, parameters, typeof(OnSerializedAttribute), currentCallback2, ref prevAttributeType))
					{
						onSerialized = onSerialized ?? new List<SerializationCallback>();
						onSerialized.Add(JsonContract.CreateSerializationCallback(methodInfo));
						currentCallback2 = methodInfo;
					}
					if (IsValidCallback(methodInfo, parameters, typeof(OnDeserializingAttribute), currentCallback3, ref prevAttributeType))
					{
						onDeserializing = onDeserializing ?? new List<SerializationCallback>();
						onDeserializing.Add(JsonContract.CreateSerializationCallback(methodInfo));
						currentCallback3 = methodInfo;
					}
					if (!flag2 && IsValidCallback(methodInfo, parameters, typeof(OnDeserializedAttribute), currentCallback4, ref prevAttributeType))
					{
						onDeserialized = onDeserialized ?? new List<SerializationCallback>();
						onDeserialized.Add(JsonContract.CreateSerializationCallback(methodInfo));
						currentCallback4 = methodInfo;
					}
					if (IsValidCallback(methodInfo, parameters, typeof(OnErrorAttribute), currentCallback5, ref prevAttributeType))
					{
						onError = onError ?? new List<SerializationErrorCallback>();
						onError.Add(JsonContract.CreateSerializationErrorCallback(methodInfo));
						currentCallback5 = methodInfo;
					}
				}
			}
		}
	}

	private static bool ShouldSkipDeserialized(Type t)
	{
		return false;
	}

	private static bool ShouldSkipSerializing(Type t)
	{
		return false;
	}

	private List<Type> GetClassHierarchyForType(Type type)
	{
		List<Type> list = new List<Type>();
		Type type2 = type;
		while ((object)type2 != null && (object)type2 != typeof(object))
		{
			list.Add(type2);
			type2 = type2.BaseType();
		}
		list.Reverse();
		return list;
	}

	protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType)
	{
		JsonDictionaryContract jsonDictionaryContract = new JsonDictionaryContract(objectType);
		InitializeContract(jsonDictionaryContract);
		jsonDictionaryContract.DictionaryKeyResolver = ResolveDictionaryKey;
		ConstructorInfo attributeConstructor = GetAttributeConstructor(jsonDictionaryContract.NonNullableUnderlyingType);
		if ((object)attributeConstructor != null)
		{
			ParameterInfo[] parameters = attributeConstructor.GetParameters();
			Type type = (((object)jsonDictionaryContract.DictionaryKeyType != null && (object)jsonDictionaryContract.DictionaryValueType != null) ? typeof(IEnumerable<>).MakeGenericType(typeof(KeyValuePair<, >).MakeGenericType(jsonDictionaryContract.DictionaryKeyType, jsonDictionaryContract.DictionaryValueType)) : typeof(IDictionary));
			if (parameters.Length == 0)
			{
				jsonDictionaryContract.HasParameterizedCreator = false;
			}
			else
			{
				if (parameters.Length != 1 || !type.IsAssignableFrom(parameters[0].ParameterType))
				{
					throw new JsonException("Constructor for '{0}' must have no parameters or a single parameter that implements '{1}'.".FormatWith(CultureInfo.InvariantCulture, jsonDictionaryContract.UnderlyingType, type));
				}
				jsonDictionaryContract.HasParameterizedCreator = true;
			}
			jsonDictionaryContract.OverrideCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(attributeConstructor);
		}
		return jsonDictionaryContract;
	}

	protected virtual JsonArrayContract CreateArrayContract(Type objectType)
	{
		JsonArrayContract jsonArrayContract = new JsonArrayContract(objectType);
		InitializeContract(jsonArrayContract);
		ConstructorInfo attributeConstructor = GetAttributeConstructor(jsonArrayContract.NonNullableUnderlyingType);
		if ((object)attributeConstructor != null)
		{
			ParameterInfo[] parameters = attributeConstructor.GetParameters();
			Type type = (((object)jsonArrayContract.CollectionItemType != null) ? typeof(IEnumerable<>).MakeGenericType(jsonArrayContract.CollectionItemType) : typeof(IEnumerable));
			if (parameters.Length == 0)
			{
				jsonArrayContract.HasParameterizedCreator = false;
			}
			else
			{
				if (parameters.Length != 1 || !type.IsAssignableFrom(parameters[0].ParameterType))
				{
					throw new JsonException("Constructor for '{0}' must have no parameters or a single parameter that implements '{1}'.".FormatWith(CultureInfo.InvariantCulture, jsonArrayContract.UnderlyingType, type));
				}
				jsonArrayContract.HasParameterizedCreator = true;
			}
			jsonArrayContract.OverrideCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(attributeConstructor);
		}
		return jsonArrayContract;
	}

	protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType)
	{
		JsonPrimitiveContract jsonPrimitiveContract = new JsonPrimitiveContract(objectType);
		InitializeContract(jsonPrimitiveContract);
		return jsonPrimitiveContract;
	}

	protected virtual JsonLinqContract CreateLinqContract(Type objectType)
	{
		JsonLinqContract jsonLinqContract = new JsonLinqContract(objectType);
		InitializeContract(jsonLinqContract);
		return jsonLinqContract;
	}

	protected virtual JsonISerializableContract CreateISerializableContract(Type objectType)
	{
		JsonISerializableContract jsonISerializableContract = new JsonISerializableContract(objectType);
		InitializeContract(jsonISerializableContract);
		ConstructorInfo constructor = jsonISerializableContract.NonNullableUnderlyingType.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(SerializationInfo),
			typeof(StreamingContext)
		}, null);
		if ((object)constructor != null)
		{
			ObjectConstructor<object> iSerializableCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(constructor);
			jsonISerializableContract.ISerializableCreator = iSerializableCreator;
		}
		return jsonISerializableContract;
	}

	protected virtual JsonStringContract CreateStringContract(Type objectType)
	{
		JsonStringContract jsonStringContract = new JsonStringContract(objectType);
		InitializeContract(jsonStringContract);
		return jsonStringContract;
	}

	protected virtual JsonContract CreateContract(Type objectType)
	{
		if (IsJsonPrimitiveType(objectType))
		{
			return CreatePrimitiveContract(objectType);
		}
		Type type = ReflectionUtils.EnsureNotNullableType(objectType);
		JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(type);
		if (cachedAttribute is JsonObjectAttribute)
		{
			return CreateObjectContract(objectType);
		}
		if (cachedAttribute is JsonArrayAttribute)
		{
			return CreateArrayContract(objectType);
		}
		if (cachedAttribute is JsonDictionaryAttribute)
		{
			return CreateDictionaryContract(objectType);
		}
		if ((object)type == typeof(JToken) || type.IsSubclassOf(typeof(JToken)))
		{
			return CreateLinqContract(objectType);
		}
		if (CollectionUtils.IsDictionaryType(type))
		{
			return CreateDictionaryContract(objectType);
		}
		if (typeof(IEnumerable).IsAssignableFrom(type))
		{
			return CreateArrayContract(objectType);
		}
		if (CanConvertToString(type))
		{
			return CreateStringContract(objectType);
		}
		if (!IgnoreSerializableInterface && typeof(ISerializable).IsAssignableFrom(type))
		{
			return CreateISerializableContract(objectType);
		}
		if (IsIConvertible(type))
		{
			return CreatePrimitiveContract(type);
		}
		return CreateObjectContract(objectType);
	}

	internal static bool IsJsonPrimitiveType(Type t)
	{
		PrimitiveTypeCode typeCode = ConvertUtils.GetTypeCode(t);
		if (typeCode != 0)
		{
			return typeCode != PrimitiveTypeCode.Object;
		}
		return false;
	}

	internal static bool IsIConvertible(Type t)
	{
		if (typeof(IConvertible).IsAssignableFrom(t) || (ReflectionUtils.IsNullableType(t) && typeof(IConvertible).IsAssignableFrom(Nullable.GetUnderlyingType(t))))
		{
			return !typeof(JToken).IsAssignableFrom(t);
		}
		return false;
	}

	internal static bool CanConvertToString(Type type)
	{
		TypeConverter converter = ConvertUtils.GetConverter(type);
		if (converter != null && !(converter is ComponentConverter) && !(converter is ReferenceConverter) && (object)converter.GetType() != typeof(TypeConverter) && converter.CanConvertTo(typeof(string)))
		{
			return true;
		}
		if ((object)type == typeof(Type) || type.IsSubclassOf(typeof(Type)))
		{
			return true;
		}
		return false;
	}

	private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, ref Type prevAttributeType)
	{
		if (!method.IsDefined(attributeType, inherit: false))
		{
			return false;
		}
		if ((object)currentCallback != null)
		{
			throw new JsonException("Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.".FormatWith(CultureInfo.InvariantCulture, method, currentCallback, GetClrTypeFullName(method.DeclaringType), attributeType));
		}
		if ((object)prevAttributeType != null)
		{
			throw new JsonException("Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.".FormatWith(CultureInfo.InvariantCulture, prevAttributeType, attributeType, GetClrTypeFullName(method.DeclaringType), method));
		}
		if (method.IsVirtual)
		{
			throw new JsonException("Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.".FormatWith(CultureInfo.InvariantCulture, method, GetClrTypeFullName(method.DeclaringType), attributeType));
		}
		if ((object)method.ReturnType != typeof(void))
		{
			throw new JsonException("Serialization Callback '{1}' in type '{0}' must return void.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method));
		}
		if ((object)attributeType == typeof(OnErrorAttribute))
		{
			if (parameters == null || parameters.Length != 2 || (object)parameters[0].ParameterType != typeof(StreamingContext) || (object)parameters[1].ParameterType != typeof(ErrorContext))
			{
				throw new JsonException("Serialization Error Callback '{1}' in type '{0}' must have two parameters of type '{2}' and '{3}'.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method, typeof(StreamingContext), typeof(ErrorContext)));
			}
		}
		else if (parameters == null || parameters.Length != 1 || (object)parameters[0].ParameterType != typeof(StreamingContext))
		{
			throw new JsonException("Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method, typeof(StreamingContext)));
		}
		prevAttributeType = attributeType;
		return true;
	}

	internal static string GetClrTypeFullName(Type type)
	{
		if (type.IsGenericTypeDefinition() || !type.ContainsGenericParameters())
		{
			return type.FullName;
		}
		return string.Format(CultureInfo.InvariantCulture, "{0}.{1}", new object[2] { type.Namespace, type.Name });
	}

	protected virtual IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)
	{
		List<MemberInfo> obj = GetSerializableMembers(type) ?? throw new JsonSerializationException("Null collection of seralizable members returned.");
		JsonPropertyCollection jsonPropertyCollection = new JsonPropertyCollection(type);
		foreach (MemberInfo item in obj)
		{
			JsonProperty jsonProperty = CreateProperty(item, memberSerialization);
			if (jsonProperty != null)
			{
				DefaultContractResolverState state = GetState();
				lock (state.NameTable)
				{
					jsonProperty.PropertyName = state.NameTable.Add(jsonProperty.PropertyName);
				}
				jsonPropertyCollection.AddProperty(jsonProperty);
			}
		}
		return jsonPropertyCollection.OrderBy((JsonProperty p) => p.Order ?? (-1)).ToList();
	}

	protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member)
	{
		return new ReflectionValueProvider(member);
	}

	protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)
	{
		JsonProperty jsonProperty = new JsonProperty();
		jsonProperty.PropertyType = ReflectionUtils.GetMemberUnderlyingType(member);
		jsonProperty.DeclaringType = member.DeclaringType;
		jsonProperty.ValueProvider = CreateMemberValueProvider(member);
		jsonProperty.AttributeProvider = new ReflectionAttributeProvider(member);
		SetPropertySettingsFromAttributes(jsonProperty, member, member.Name, member.DeclaringType, memberSerialization, out var allowNonPublicAccess);
		if (memberSerialization != MemberSerialization.Fields)
		{
			jsonProperty.Readable = ReflectionUtils.CanReadMemberValue(member, allowNonPublicAccess);
			jsonProperty.Writable = ReflectionUtils.CanSetMemberValue(member, allowNonPublicAccess, jsonProperty.HasMemberAttribute);
		}
		else
		{
			jsonProperty.Readable = true;
			jsonProperty.Writable = true;
		}
		jsonProperty.ShouldSerialize = CreateShouldSerializeTest(member);
		SetIsSpecifiedActions(jsonProperty, member, allowNonPublicAccess);
		return jsonProperty;
	}

	private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, out bool allowNonPublicAccess)
	{
		DataContractAttribute dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(declaringType);
		MemberInfo memberInfo = attributeProvider as MemberInfo;
		DataMemberAttribute dataMemberAttribute = ((dataContractAttribute == null || (object)memberInfo == null) ? null : JsonTypeReflector.GetDataMemberAttribute(memberInfo));
		JsonPropertyAttribute attribute = JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(attributeProvider);
		JsonRequiredAttribute attribute2 = JsonTypeReflector.GetAttribute<JsonRequiredAttribute>(attributeProvider);
		string propertyName = ((attribute != null && attribute.PropertyName != null) ? attribute.PropertyName : ((dataMemberAttribute == null || dataMemberAttribute.Name == null) ? name : dataMemberAttribute.Name));
		property.PropertyName = ResolvePropertyName(propertyName);
		property.UnderlyingName = name;
		bool flag = false;
		if (attribute != null)
		{
			property._required = attribute._required;
			property.Order = attribute._order;
			property.DefaultValueHandling = attribute._defaultValueHandling;
			flag = true;
		}
		else if (dataMemberAttribute != null)
		{
			property._required = (dataMemberAttribute.IsRequired ? Required.AllowNull : Required.Default);
			property.Order = ((dataMemberAttribute.Order != -1) ? new int?(dataMemberAttribute.Order) : ((int?)null));
			property.DefaultValueHandling = ((!dataMemberAttribute.EmitDefaultValue) ? new DefaultValueHandling?(DefaultValueHandling.Ignore) : ((DefaultValueHandling?)null));
			flag = true;
		}
		if (attribute2 != null)
		{
			property._required = Required.Always;
			flag = true;
		}
		property.HasMemberAttribute = flag;
		bool flag2 = JsonTypeReflector.GetAttribute<JsonIgnoreAttribute>(attributeProvider) != null || JsonTypeReflector.GetAttribute<JsonExtensionDataAttribute>(attributeProvider) != null || JsonTypeReflector.GetAttribute<NonSerializedAttribute>(attributeProvider) != null;
		if (memberSerialization != MemberSerialization.OptIn)
		{
			bool flag3 = false;
			property.Ignored = flag2 || flag3;
		}
		else
		{
			property.Ignored = flag2 || !flag;
		}
		property.Converter = JsonTypeReflector.GetJsonConverter(attributeProvider);
		property.MemberConverter = JsonTypeReflector.GetJsonConverter(attributeProvider);
		DefaultValueAttribute attribute3 = JsonTypeReflector.GetAttribute<DefaultValueAttribute>(attributeProvider);
		if (attribute3 != null)
		{
			property.DefaultValue = attribute3.Value;
		}
		property.NullValueHandling = attribute?._nullValueHandling;
		property.ReferenceLoopHandling = attribute?._referenceLoopHandling;
		property.ObjectCreationHandling = attribute?._objectCreationHandling;
		property.TypeNameHandling = attribute?._typeNameHandling;
		property.IsReference = attribute?._isReference;
		property.ItemIsReference = attribute?._itemIsReference;
		property.ItemConverter = ((attribute != null && (object)attribute.ItemConverterType != null) ? JsonTypeReflector.CreateJsonConverterInstance(attribute.ItemConverterType, attribute.ItemConverterParameters) : null);
		property.ItemReferenceLoopHandling = attribute?._itemReferenceLoopHandling;
		property.ItemTypeNameHandling = attribute?._itemTypeNameHandling;
		allowNonPublicAccess = false;
		if ((DefaultMembersSearchFlags & BindingFlags.NonPublic) == BindingFlags.NonPublic)
		{
			allowNonPublicAccess = true;
		}
		if (flag)
		{
			allowNonPublicAccess = true;
		}
		if (memberSerialization == MemberSerialization.Fields)
		{
			allowNonPublicAccess = true;
		}
	}

	private Predicate<object> CreateShouldSerializeTest(MemberInfo member)
	{
		MethodInfo method = member.DeclaringType.GetMethod("ShouldSerialize" + member.Name, ReflectionUtils.EmptyTypes);
		if ((object)method == null || (object)method.ReturnType != typeof(bool))
		{
			return null;
		}
		MethodCall<object, object> shouldSerializeCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
		return (object o) => (bool)shouldSerializeCall(o);
	}

	private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess)
	{
		MemberInfo memberInfo = member.DeclaringType.GetProperty(member.Name + "Specified");
		if ((object)memberInfo == null)
		{
			memberInfo = member.DeclaringType.GetField(member.Name + "Specified");
		}
		if ((object)memberInfo != null && (object)ReflectionUtils.GetMemberUnderlyingType(memberInfo) == typeof(bool))
		{
			Func<object, object> specifiedPropertyGet = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(memberInfo);
			property.GetIsSpecified = (object o) => (bool)specifiedPropertyGet(o);
			if (ReflectionUtils.CanSetMemberValue(memberInfo, allowNonPublicAccess, canSetReadOnly: false))
			{
				property.SetIsSpecified = JsonTypeReflector.ReflectionDelegateFactory.CreateSet<object>(memberInfo);
			}
		}
	}

	protected virtual string ResolvePropertyName(string propertyName)
	{
		return propertyName;
	}

	protected virtual string ResolveDictionaryKey(string dictionaryKey)
	{
		return ResolvePropertyName(dictionaryKey);
	}

	public string GetResolvedPropertyName(string propertyName)
	{
		return ResolvePropertyName(propertyName);
	}
}


using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json.Utilities;

internal class EnumerableDictionaryWrapper<TEnumeratorKey, TEnumeratorValue> : IEnumerable<KeyValuePair<object, object>>, IEnumerable
{
	private readonly IEnumerable<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;

	public EnumerableDictionaryWrapper(IEnumerable<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
	{
		ValidationUtils.ArgumentNotNull(e, "e");
		_e = e;
	}

	public IEnumerator<KeyValuePair<object, object>> GetEnumerator()
	{
		foreach (KeyValuePair<TEnumeratorKey, TEnumeratorValue> item in _e)
		{
			yield return new KeyValuePair<object, object>(item.Key, item.Value);
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Globalization;
using System.Reflection;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class DefaultSerializationBinder : SerializationBinder
{
	internal struct TypeNameKey
	{
		internal readonly string AssemblyName;

		internal readonly string TypeName;

		public TypeNameKey(string assemblyName, string typeName)
		{
			AssemblyName = assemblyName;
			TypeName = typeName;
		}

		public override int GetHashCode()
		{
			return ((AssemblyName != null) ? AssemblyName.GetHashCode() : 0) ^ ((TypeName != null) ? TypeName.GetHashCode() : 0);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is TypeNameKey))
			{
				return false;
			}
			return Equals((TypeNameKey)obj);
		}

		public bool Equals(TypeNameKey other)
		{
			if (AssemblyName == other.AssemblyName)
			{
				return TypeName == other.TypeName;
			}
			return false;
		}
	}

	internal static readonly DefaultSerializationBinder Instance = new DefaultSerializationBinder();

	private readonly ThreadSafeStore<TypeNameKey, Type> _typeCache = new ThreadSafeStore<TypeNameKey, Type>(GetTypeFromTypeNameKey);

	private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
	{
		string assemblyName = typeNameKey.AssemblyName;
		string typeName = typeNameKey.TypeName;
		if (assemblyName != null)
		{
			Assembly assembly = Assembly.Load(assemblyName);
			if ((object)assembly == null)
			{
				Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
				foreach (Assembly assembly2 in assemblies)
				{
					if (assembly2.FullName == assemblyName)
					{
						assembly = assembly2;
						break;
					}
				}
			}
			if ((object)assembly == null)
			{
				throw new JsonSerializationException("Could not load assembly '{0}'.".FormatWith(CultureInfo.InvariantCulture, assemblyName));
			}
			return assembly.GetType(typeName) ?? throw new JsonSerializationException("Could not find type '{0}' in assembly '{1}'.".FormatWith(CultureInfo.InvariantCulture, typeName, assembly.FullName));
		}
		return Type.GetType(typeName);
	}

	public override Type BindToType(string assemblyName, string typeName)
	{
		return _typeCache.Get(new TypeNameKey(assemblyName, typeName));
	}
}


internal struct TypeNameKey
{
	internal readonly string AssemblyName;

	internal readonly string TypeName;

	public TypeNameKey(string assemblyName, string typeName)
	{
		AssemblyName = assemblyName;
		TypeName = typeName;
	}

	public override int GetHashCode()
	{
		return ((AssemblyName != null) ? AssemblyName.GetHashCode() : 0) ^ ((TypeName != null) ? TypeName.GetHashCode() : 0);
	}

	public override bool Equals(object obj)
	{
		if (!(obj is TypeNameKey))
		{
			return false;
		}
		return Equals((TypeNameKey)obj);
	}

	public bool Equals(TypeNameKey other)
	{
		if (AssemblyName == other.AssemblyName)
		{
			return TypeName == other.TypeName;
		}
		return false;
	}
}


using System;
using Newtonsoft.Json.Shims;

[Preserve]
public class ErrorContext
{
	internal bool Traced { get; set; }

	public Exception Error { get; private set; }

	public object OriginalObject { get; private set; }

	public object Member { get; private set; }

	public string Path { get; private set; }

	public bool Handled { get; set; }

	internal ErrorContext(object originalObject, object member, string path, Exception error)
	{
		OriginalObject = originalObject;
		Member = member;
		Error = error;
		Path = path;
	}
}


using System;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;

[Preserve]
public interface IContractResolver
{
	JsonContract ResolveContract(Type type);
}


using Newtonsoft.Json.Shims;

[Preserve]
public interface IValueProvider
{
	void SetValue(object target, object value);

	object GetValue(object target);
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Reflection;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JsonArrayContract : JsonContainerContract
{
	private readonly Type _genericCollectionDefinitionType;

	private Type _genericWrapperType;

	private ObjectConstructor<object> _genericWrapperCreator;

	private Func<object> _genericTemporaryCollectionCreator;

	private readonly ConstructorInfo _parameterizedConstructor;

	private ObjectConstructor<object> _parameterizedCreator;

	private ObjectConstructor<object> _overrideCreator;

	public Type CollectionItemType { get; private set; }

	public bool IsMultidimensionalArray { get; private set; }

	internal bool IsArray { get; private set; }

	internal bool ShouldCreateWrapper { get; private set; }

	internal bool CanDeserialize { get; private set; }

	internal ObjectConstructor<object> ParameterizedCreator
	{
		get
		{
			if (_parameterizedCreator == null)
			{
				_parameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(_parameterizedConstructor);
			}
			return _parameterizedCreator;
		}
	}

	public ObjectConstructor<object> OverrideCreator
	{
		get
		{
			return _overrideCreator;
		}
		set
		{
			_overrideCreator = value;
			CanDeserialize = true;
		}
	}

	public bool HasParameterizedCreator { get; set; }

	internal bool HasParameterizedCreatorInternal
	{
		get
		{
			if (!HasParameterizedCreator && _parameterizedCreator == null)
			{
				return (object)_parameterizedConstructor != null;
			}
			return true;
		}
	}

	public JsonArrayContract(Type underlyingType)
		: base(underlyingType)
	{
		ContractType = JsonContractType.Array;
		IsArray = base.CreatedType.IsArray;
		bool canDeserialize;
		Type implementingType;
		if (IsArray)
		{
			CollectionItemType = ReflectionUtils.GetCollectionItemType(base.UnderlyingType);
			IsReadOnlyOrFixedSize = true;
			_genericCollectionDefinitionType = typeof(List<>).MakeGenericType(CollectionItemType);
			canDeserialize = true;
			IsMultidimensionalArray = IsArray && base.UnderlyingType.GetArrayRank() > 1;
		}
		else if (typeof(IList).IsAssignableFrom(underlyingType))
		{
			if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(ICollection<>), out _genericCollectionDefinitionType))
			{
				CollectionItemType = _genericCollectionDefinitionType.GetGenericArguments()[0];
			}
			else
			{
				CollectionItemType = ReflectionUtils.GetCollectionItemType(underlyingType);
			}
			if ((object)underlyingType == typeof(IList))
			{
				base.CreatedType = typeof(List<object>);
			}
			if ((object)CollectionItemType != null)
			{
				_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(underlyingType, CollectionItemType);
			}
			IsReadOnlyOrFixedSize = ReflectionUtils.InheritsGenericDefinition(underlyingType, typeof(ReadOnlyCollection<>));
			canDeserialize = true;
		}
		else if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(ICollection<>), out _genericCollectionDefinitionType))
		{
			CollectionItemType = _genericCollectionDefinitionType.GetGenericArguments()[0];
			if (ReflectionUtils.IsGenericDefinition(underlyingType, typeof(ICollection<>)) || ReflectionUtils.IsGenericDefinition(underlyingType, typeof(IList<>)))
			{
				base.CreatedType = typeof(List<>).MakeGenericType(CollectionItemType);
			}
			_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(underlyingType, CollectionItemType);
			canDeserialize = true;
			ShouldCreateWrapper = true;
		}
		else if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(IEnumerable<>), out implementingType))
		{
			CollectionItemType = implementingType.GetGenericArguments()[0];
			if (ReflectionUtils.IsGenericDefinition(base.UnderlyingType, typeof(IEnumerable<>)))
			{
				base.CreatedType = typeof(List<>).MakeGenericType(CollectionItemType);
			}
			_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(underlyingType, CollectionItemType);
			if (underlyingType.IsGenericType() && (object)underlyingType.GetGenericTypeDefinition() == typeof(IEnumerable<>))
			{
				_genericCollectionDefinitionType = implementingType;
				IsReadOnlyOrFixedSize = false;
				ShouldCreateWrapper = false;
				canDeserialize = true;
			}
			else
			{
				_genericCollectionDefinitionType = typeof(List<>).MakeGenericType(CollectionItemType);
				IsReadOnlyOrFixedSize = true;
				ShouldCreateWrapper = true;
				canDeserialize = HasParameterizedCreatorInternal;
			}
		}
		else
		{
			canDeserialize = false;
			ShouldCreateWrapper = true;
		}
		CanDeserialize = canDeserialize;
		if ((object)CollectionItemType != null && ReflectionUtils.IsNullableType(CollectionItemType) && (ReflectionUtils.InheritsGenericDefinition(base.CreatedType, typeof(List<>), out implementingType) || (IsArray && !IsMultidimensionalArray)))
		{
			ShouldCreateWrapper = true;
		}
	}

	internal IWrappedCollection CreateWrapper(object list)
	{
		if (_genericWrapperCreator == null)
		{
			_genericWrapperType = typeof(CollectionWrapper<>).MakeGenericType(CollectionItemType);
			Type type = ((!ReflectionUtils.InheritsGenericDefinition(_genericCollectionDefinitionType, typeof(List<>)) && (object)_genericCollectionDefinitionType.GetGenericTypeDefinition() != typeof(IEnumerable<>)) ? _genericCollectionDefinitionType : typeof(ICollection<>).MakeGenericType(CollectionItemType));
			ConstructorInfo constructor = _genericWrapperType.GetConstructor(new Type[1] { type });
			_genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(constructor);
		}
		return (IWrappedCollection)_genericWrapperCreator(list);
	}

	internal IList CreateTemporaryCollection()
	{
		if (_genericTemporaryCollectionCreator == null)
		{
			Type type = ((IsMultidimensionalArray || (object)CollectionItemType == null) ? typeof(object) : CollectionItemType);
			Type type2 = typeof(List<>).MakeGenericType(type);
			_genericTemporaryCollectionCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type2);
		}
		return (IList)_genericTemporaryCollectionCreator();
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
internal enum JsonContractType
{
	None,
	Object,
	Array,
	Primitive,
	String,
	Dictionary,
	Dynamic,
	Serializable,
	Linq
}


using System.Runtime.Serialization;
using Newtonsoft.Json.Shims;

[Preserve]
public delegate void SerializationCallback(object o, StreamingContext context);


using System.Runtime.Serialization;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;

[Preserve]
public delegate void SerializationErrorCallback(object o, StreamingContext context, ErrorContext errorContext);


using Newtonsoft.Json.Shims;

[Preserve]
public delegate void ExtensionDataSetter(object o, string key, object value);


using System.Collections.Generic;
using Newtonsoft.Json.Shims;

[Preserve]
public delegate IEnumerable<KeyValuePair<object, object>> ExtensionDataGetter(object o);


using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public abstract class JsonContract
{
	internal bool IsNullable;

	internal bool IsConvertable;

	internal bool IsEnum;

	internal Type NonNullableUnderlyingType;

	internal ReadType InternalReadType;

	internal JsonContractType ContractType;

	internal bool IsReadOnlyOrFixedSize;

	internal bool IsSealed;

	internal bool IsInstantiable;

	private List<SerializationCallback> _onDeserializedCallbacks;

	private IList<SerializationCallback> _onDeserializingCallbacks;

	private IList<SerializationCallback> _onSerializedCallbacks;

	private IList<SerializationCallback> _onSerializingCallbacks;

	private IList<SerializationErrorCallback> _onErrorCallbacks;

	private Type _createdType;

	public Type UnderlyingType { get; private set; }

	public Type CreatedType
	{
		get
		{
			return _createdType;
		}
		set
		{
			_createdType = value;
			IsSealed = _createdType.IsSealed();
			IsInstantiable = !_createdType.IsInterface() && !_createdType.IsAbstract();
		}
	}

	public bool? IsReference { get; set; }

	public JsonConverter Converter { get; set; }

	internal JsonConverter InternalConverter { get; set; }

	public IList<SerializationCallback> OnDeserializedCallbacks
	{
		get
		{
			if (_onDeserializedCallbacks == null)
			{
				_onDeserializedCallbacks = new List<SerializationCallback>();
			}
			return _onDeserializedCallbacks;
		}
	}

	public IList<SerializationCallback> OnDeserializingCallbacks
	{
		get
		{
			if (_onDeserializingCallbacks == null)
			{
				_onDeserializingCallbacks = new List<SerializationCallback>();
			}
			return _onDeserializingCallbacks;
		}
	}

	public IList<SerializationCallback> OnSerializedCallbacks
	{
		get
		{
			if (_onSerializedCallbacks == null)
			{
				_onSerializedCallbacks = new List<SerializationCallback>();
			}
			return _onSerializedCallbacks;
		}
	}

	public IList<SerializationCallback> OnSerializingCallbacks
	{
		get
		{
			if (_onSerializingCallbacks == null)
			{
				_onSerializingCallbacks = new List<SerializationCallback>();
			}
			return _onSerializingCallbacks;
		}
	}

	public IList<SerializationErrorCallback> OnErrorCallbacks
	{
		get
		{
			if (_onErrorCallbacks == null)
			{
				_onErrorCallbacks = new List<SerializationErrorCallback>();
			}
			return _onErrorCallbacks;
		}
	}

	[Obsolete("This property is obsolete and has been replaced by the OnDeserializedCallbacks collection.")]
	public MethodInfo OnDeserialized
	{
		get
		{
			if (OnDeserializedCallbacks.Count <= 0)
			{
				return null;
			}
			return OnDeserializedCallbacks[0].Method();
		}
		set
		{
			OnDeserializedCallbacks.Clear();
			OnDeserializedCallbacks.Add(CreateSerializationCallback(value));
		}
	}

	[Obsolete("This property is obsolete and has been replaced by the OnDeserializingCallbacks collection.")]
	public MethodInfo OnDeserializing
	{
		get
		{
			if (OnDeserializingCallbacks.Count <= 0)
			{
				return null;
			}
			return OnDeserializingCallbacks[0].Method();
		}
		set
		{
			OnDeserializingCallbacks.Clear();
			OnDeserializingCallbacks.Add(CreateSerializationCallback(value));
		}
	}

	[Obsolete("This property is obsolete and has been replaced by the OnSerializedCallbacks collection.")]
	public MethodInfo OnSerialized
	{
		get
		{
			if (OnSerializedCallbacks.Count <= 0)
			{
				return null;
			}
			return OnSerializedCallbacks[0].Method();
		}
		set
		{
			OnSerializedCallbacks.Clear();
			OnSerializedCallbacks.Add(CreateSerializationCallback(value));
		}
	}

	[Obsolete("This property is obsolete and has been replaced by the OnSerializingCallbacks collection.")]
	public MethodInfo OnSerializing
	{
		get
		{
			if (OnSerializingCallbacks.Count <= 0)
			{
				return null;
			}
			return OnSerializingCallbacks[0].Method();
		}
		set
		{
			OnSerializingCallbacks.Clear();
			OnSerializingCallbacks.Add(CreateSerializationCallback(value));
		}
	}

	[Obsolete("This property is obsolete and has been replaced by the OnErrorCallbacks collection.")]
	public MethodInfo OnError
	{
		get
		{
			if (OnErrorCallbacks.Count <= 0)
			{
				return null;
			}
			return OnErrorCallbacks[0].Method();
		}
		set
		{
			OnErrorCallbacks.Clear();
			OnErrorCallbacks.Add(CreateSerializationErrorCallback(value));
		}
	}

	public Func<object> DefaultCreator { get; set; }

	public bool DefaultCreatorNonPublic { get; set; }

	internal JsonContract(Type underlyingType)
	{
		ValidationUtils.ArgumentNotNull(underlyingType, "underlyingType");
		UnderlyingType = underlyingType;
		IsNullable = ReflectionUtils.IsNullable(underlyingType);
		NonNullableUnderlyingType = ((IsNullable && ReflectionUtils.IsNullableType(underlyingType)) ? Nullable.GetUnderlyingType(underlyingType) : underlyingType);
		CreatedType = NonNullableUnderlyingType;
		IsConvertable = ConvertUtils.IsConvertible(NonNullableUnderlyingType);
		IsEnum = NonNullableUnderlyingType.IsEnum();
		InternalReadType = ReadType.Read;
	}

	internal void InvokeOnSerializing(object o, StreamingContext context)
	{
		if (_onSerializingCallbacks == null)
		{
			return;
		}
		foreach (SerializationCallback onSerializingCallback in _onSerializingCallbacks)
		{
			onSerializingCallback(o, context);
		}
	}

	internal void InvokeOnSerialized(object o, StreamingContext context)
	{
		if (_onSerializedCallbacks == null)
		{
			return;
		}
		foreach (SerializationCallback onSerializedCallback in _onSerializedCallbacks)
		{
			onSerializedCallback(o, context);
		}
	}

	internal void InvokeOnDeserializing(object o, StreamingContext context)
	{
		if (_onDeserializingCallbacks == null)
		{
			return;
		}
		foreach (SerializationCallback onDeserializingCallback in _onDeserializingCallbacks)
		{
			onDeserializingCallback(o, context);
		}
	}

	internal void InvokeOnDeserialized(object o, StreamingContext context)
	{
		if (_onDeserializedCallbacks == null)
		{
			return;
		}
		foreach (SerializationCallback onDeserializedCallback in _onDeserializedCallbacks)
		{
			onDeserializedCallback(o, context);
		}
	}

	internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext)
	{
		if (_onErrorCallbacks == null)
		{
			return;
		}
		foreach (SerializationErrorCallback onErrorCallback in _onErrorCallbacks)
		{
			onErrorCallback(o, context, errorContext);
		}
	}

	internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo)
	{
		return delegate(object o, StreamingContext context)
		{
			callbackMethodInfo.Invoke(o, new object[1] { context });
		};
	}

	internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo)
	{
		return delegate(object o, StreamingContext context, ErrorContext econtext)
		{
			callbackMethodInfo.Invoke(o, new object[2] { context, econtext });
		};
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JsonDictionaryContract : JsonContainerContract
{
	private readonly Type _genericCollectionDefinitionType;

	private Type _genericWrapperType;

	private ObjectConstructor<object> _genericWrapperCreator;

	private Func<object> _genericTemporaryDictionaryCreator;

	private readonly ConstructorInfo _parameterizedConstructor;

	private ObjectConstructor<object> _overrideCreator;

	private ObjectConstructor<object> _parameterizedCreator;

	[Obsolete("PropertyNameResolver is obsolete. Use DictionaryKeyResolver instead.")]
	public Func<string, string> PropertyNameResolver
	{
		get
		{
			return DictionaryKeyResolver;
		}
		set
		{
			DictionaryKeyResolver = value;
		}
	}

	public Func<string, string> DictionaryKeyResolver { get; set; }

	public Type DictionaryKeyType { get; private set; }

	public Type DictionaryValueType { get; private set; }

	internal JsonContract KeyContract { get; set; }

	internal bool ShouldCreateWrapper { get; private set; }

	internal ObjectConstructor<object> ParameterizedCreator
	{
		get
		{
			if (_parameterizedCreator == null)
			{
				_parameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(_parameterizedConstructor);
			}
			return _parameterizedCreator;
		}
	}

	public ObjectConstructor<object> OverrideCreator
	{
		get
		{
			return _overrideCreator;
		}
		set
		{
			_overrideCreator = value;
		}
	}

	public bool HasParameterizedCreator { get; set; }

	internal bool HasParameterizedCreatorInternal
	{
		get
		{
			if (!HasParameterizedCreator && _parameterizedCreator == null)
			{
				return (object)_parameterizedConstructor != null;
			}
			return true;
		}
	}

	public JsonDictionaryContract(Type underlyingType)
		: base(underlyingType)
	{
		ContractType = JsonContractType.Dictionary;
		Type keyType;
		Type valueType;
		if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(IDictionary<, >), out _genericCollectionDefinitionType))
		{
			keyType = _genericCollectionDefinitionType.GetGenericArguments()[0];
			valueType = _genericCollectionDefinitionType.GetGenericArguments()[1];
			if (ReflectionUtils.IsGenericDefinition(base.UnderlyingType, typeof(IDictionary<, >)))
			{
				base.CreatedType = typeof(Dictionary<, >).MakeGenericType(keyType, valueType);
			}
		}
		else
		{
			ReflectionUtils.GetDictionaryKeyValueTypes(base.UnderlyingType, out keyType, out valueType);
			if ((object)base.UnderlyingType == typeof(IDictionary))
			{
				base.CreatedType = typeof(Dictionary<object, object>);
			}
		}
		if ((object)keyType != null && (object)valueType != null)
		{
			_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(base.CreatedType, typeof(KeyValuePair<, >).MakeGenericType(keyType, valueType), typeof(IDictionary<, >).MakeGenericType(keyType, valueType));
		}
		ShouldCreateWrapper = !typeof(IDictionary).IsAssignableFrom(base.CreatedType);
		DictionaryKeyType = keyType;
		DictionaryValueType = valueType;
		if ((object)DictionaryValueType != null && ReflectionUtils.IsNullableType(DictionaryValueType) && ReflectionUtils.InheritsGenericDefinition(base.CreatedType, typeof(Dictionary<, >), out var _))
		{
			ShouldCreateWrapper = true;
		}
	}

	internal IWrappedDictionary CreateWrapper(object dictionary)
	{
		if (_genericWrapperCreator == null)
		{
			_genericWrapperType = typeof(DictionaryWrapper<, >).MakeGenericType(DictionaryKeyType, DictionaryValueType);
			ConstructorInfo constructor = _genericWrapperType.GetConstructor(new Type[1] { _genericCollectionDefinitionType });
			_genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(constructor);
		}
		return (IWrappedDictionary)_genericWrapperCreator(dictionary);
	}

	internal IDictionary CreateTemporaryDictionary()
	{
		if (_genericTemporaryDictionaryCreator == null)
		{
			Type type = typeof(Dictionary<, >).MakeGenericType(DictionaryKeyType ?? typeof(object), DictionaryValueType ?? typeof(object));
			_genericTemporaryDictionaryCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type);
		}
		return (IDictionary)_genericTemporaryDictionaryCreator();
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JsonProperty
{
	internal Required? _required;

	internal bool _hasExplicitDefaultValue;

	private object _defaultValue;

	private bool _hasGeneratedDefaultValue;

	private string _propertyName;

	internal bool _skipPropertyNameEscape;

	private Type _propertyType;

	internal JsonContract PropertyContract { get; set; }

	public string PropertyName
	{
		get
		{
			return _propertyName;
		}
		set
		{
			_propertyName = value;
			_skipPropertyNameEscape = !JavaScriptUtils.ShouldEscapeJavaScriptString(_propertyName, JavaScriptUtils.HtmlCharEscapeFlags);
		}
	}

	public Type DeclaringType { get; set; }

	public int? Order { get; set; }

	public string UnderlyingName { get; set; }

	public IValueProvider ValueProvider { get; set; }

	public IAttributeProvider AttributeProvider { get; set; }

	public Type PropertyType
	{
		get
		{
			return _propertyType;
		}
		set
		{
			if ((object)_propertyType != value)
			{
				_propertyType = value;
				_hasGeneratedDefaultValue = false;
			}
		}
	}

	public JsonConverter Converter { get; set; }

	public JsonConverter MemberConverter { get; set; }

	public bool Ignored { get; set; }

	public bool Readable { get; set; }

	public bool Writable { get; set; }

	public bool HasMemberAttribute { get; set; }

	public object DefaultValue
	{
		get
		{
			if (!_hasExplicitDefaultValue)
			{
				return null;
			}
			return _defaultValue;
		}
		set
		{
			_hasExplicitDefaultValue = true;
			_defaultValue = value;
		}
	}

	public Required Required
	{
		get
		{
			return _required ?? Required.Default;
		}
		set
		{
			_required = value;
		}
	}

	public bool? IsReference { get; set; }

	public NullValueHandling? NullValueHandling { get; set; }

	public DefaultValueHandling? DefaultValueHandling { get; set; }

	public ReferenceLoopHandling? ReferenceLoopHandling { get; set; }

	public ObjectCreationHandling? ObjectCreationHandling { get; set; }

	public TypeNameHandling? TypeNameHandling { get; set; }

	public Predicate<object> ShouldSerialize { get; set; }

	public Predicate<object> ShouldDeserialize { get; set; }

	public Predicate<object> GetIsSpecified { get; set; }

	public Action<object, object> SetIsSpecified { get; set; }

	public JsonConverter ItemConverter { get; set; }

	public bool? ItemIsReference { get; set; }

	public TypeNameHandling? ItemTypeNameHandling { get; set; }

	public ReferenceLoopHandling? ItemReferenceLoopHandling { get; set; }

	internal object GetResolvedDefaultValue()
	{
		if ((object)_propertyType == null)
		{
			return null;
		}
		if (!_hasExplicitDefaultValue && !_hasGeneratedDefaultValue)
		{
			_defaultValue = ReflectionUtils.GetDefaultValue(PropertyType);
			_hasGeneratedDefaultValue = true;
		}
		return _defaultValue;
	}

	public override string ToString()
	{
		return PropertyName;
	}

	internal void WritePropertyName(JsonWriter writer)
	{
		if (_skipPropertyNameEscape)
		{
			writer.WritePropertyName(PropertyName, escape: false);
		}
		else
		{
			writer.WritePropertyName(PropertyName);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JsonPropertyCollection : KeyedCollection<string, JsonProperty>
{
	private readonly Type _type;

	private readonly List<JsonProperty> _list;

	public JsonPropertyCollection(Type type)
		: base((IEqualityComparer<string>?)StringComparer.Ordinal)
	{
		ValidationUtils.ArgumentNotNull(type, "type");
		_type = type;
		_list = (List<JsonProperty>)base.Items;
	}

	protected override string GetKeyForItem(JsonProperty item)
	{
		return item.PropertyName;
	}

	public void AddProperty(JsonProperty property)
	{
		if (Contains(property.PropertyName))
		{
			if (property.Ignored)
			{
				return;
			}
			JsonProperty jsonProperty = base[property.PropertyName];
			bool flag = true;
			if (jsonProperty.Ignored)
			{
				Remove(jsonProperty);
				flag = false;
			}
			else if ((object)property.DeclaringType != null && (object)jsonProperty.DeclaringType != null)
			{
				if (property.DeclaringType.IsSubclassOf(jsonProperty.DeclaringType) || (jsonProperty.DeclaringType.IsInterface() && property.DeclaringType.ImplementInterface(jsonProperty.DeclaringType)))
				{
					Remove(jsonProperty);
					flag = false;
				}
				if (jsonProperty.DeclaringType.IsSubclassOf(property.DeclaringType) || (property.DeclaringType.IsInterface() && jsonProperty.DeclaringType.ImplementInterface(property.DeclaringType)))
				{
					return;
				}
			}
			if (flag)
			{
				throw new JsonSerializationException("A member with the name '{0}' already exists on '{1}'. Use the JsonPropertyAttribute to specify another name.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, _type));
			}
		}
		Add(property);
	}

	public JsonProperty GetClosestMatchProperty(string propertyName)
	{
		JsonProperty property = GetProperty(propertyName, StringComparison.Ordinal);
		if (property == null)
		{
			property = GetProperty(propertyName, StringComparison.OrdinalIgnoreCase);
		}
		return property;
	}

	private new bool TryGetValue(string key, out JsonProperty item)
	{
		if (base.Dictionary == null)
		{
			item = null;
			return false;
		}
		return base.Dictionary.TryGetValue(key, out item);
	}

	public JsonProperty GetProperty(string propertyName, StringComparison comparisonType)
	{
		if (comparisonType == StringComparison.Ordinal)
		{
			if (TryGetValue(propertyName, out var item))
			{
				return item;
			}
			return null;
		}
		for (int i = 0; i < _list.Count; i++)
		{
			JsonProperty jsonProperty = _list[i];
			if (string.Equals(propertyName, jsonProperty.PropertyName, comparisonType))
			{
				return jsonProperty;
			}
		}
		return null;
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
public interface IReferenceResolver
{
	object ResolveReference(object context, string reference);

	string GetReference(object context, object value);

	bool IsReferenced(object context, object value);

	void AddReference(object context, string reference, object value);
}


using System;
using System.Globalization;
using System.Reflection;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JsonObjectContract : JsonContainerContract
{
	internal bool ExtensionDataIsJToken;

	private bool? _hasRequiredOrDefaultValueProperties;

	private ConstructorInfo _parametrizedConstructor;

	private ConstructorInfo _overrideConstructor;

	private ObjectConstructor<object> _overrideCreator;

	private ObjectConstructor<object> _parameterizedCreator;

	private JsonPropertyCollection _creatorParameters;

	private Type _extensionDataValueType;

	public MemberSerialization MemberSerialization { get; set; }

	public Required? ItemRequired { get; set; }

	public JsonPropertyCollection Properties { get; private set; }

	[Obsolete("ConstructorParameters is obsolete. Use CreatorParameters instead.")]
	public JsonPropertyCollection ConstructorParameters => CreatorParameters;

	public JsonPropertyCollection CreatorParameters
	{
		get
		{
			if (_creatorParameters == null)
			{
				_creatorParameters = new JsonPropertyCollection(base.UnderlyingType);
			}
			return _creatorParameters;
		}
	}

	[Obsolete("OverrideConstructor is obsolete. Use OverrideCreator instead.")]
	public ConstructorInfo OverrideConstructor
	{
		get
		{
			return _overrideConstructor;
		}
		set
		{
			_overrideConstructor = value;
			_overrideCreator = (((object)value != null) ? JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(value) : null);
		}
	}

	[Obsolete("ParametrizedConstructor is obsolete. Use OverrideCreator instead.")]
	public ConstructorInfo ParametrizedConstructor
	{
		get
		{
			return _parametrizedConstructor;
		}
		set
		{
			_parametrizedConstructor = value;
			_parameterizedCreator = (((object)value != null) ? JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(value) : null);
		}
	}

	public ObjectConstructor<object> OverrideCreator
	{
		get
		{
			return _overrideCreator;
		}
		set
		{
			_overrideCreator = value;
			_overrideConstructor = null;
		}
	}

	internal ObjectConstructor<object> ParameterizedCreator => _parameterizedCreator;

	public ExtensionDataSetter ExtensionDataSetter { get; set; }

	public ExtensionDataGetter ExtensionDataGetter { get; set; }

	public Type ExtensionDataValueType
	{
		get
		{
			return _extensionDataValueType;
		}
		set
		{
			_extensionDataValueType = value;
			ExtensionDataIsJToken = (object)value != null && typeof(JToken).IsAssignableFrom(value);
		}
	}

	internal bool HasRequiredOrDefaultValueProperties
	{
		get
		{
			if (!_hasRequiredOrDefaultValueProperties.HasValue)
			{
				_hasRequiredOrDefaultValueProperties = false;
				if ((ItemRequired ?? Required.Default) != 0)
				{
					_hasRequiredOrDefaultValueProperties = true;
				}
				else
				{
					foreach (JsonProperty property in Properties)
					{
						if (property.Required != 0 || ((uint?)property.DefaultValueHandling & 2u) == 2)
						{
							_hasRequiredOrDefaultValueProperties = true;
							break;
						}
					}
				}
			}
			return _hasRequiredOrDefaultValueProperties == true;
		}
	}

	public JsonObjectContract(Type underlyingType)
		: base(underlyingType)
	{
		ContractType = JsonContractType.Object;
		Properties = new JsonPropertyCollection(base.UnderlyingType);
	}

	internal object GetUninitializedObject()
	{
		if (!JsonTypeReflector.FullyTrusted)
		{
			throw new JsonException("Insufficient permissions. Creating an uninitialized '{0}' type requires full trust.".FormatWith(CultureInfo.InvariantCulture, NonNullableUnderlyingType));
		}
		return FormatterServices.GetUninitializedObject(NonNullableUnderlyingType);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal abstract class JsonSerializerInternalBase
{
	private class ReferenceEqualsEqualityComparer : IEqualityComparer<object>
	{
		bool IEqualityComparer<object>.Equals(object x, object y)
		{
			return x == y;
		}

		int IEqualityComparer<object>.GetHashCode(object obj)
		{
			return RuntimeHelpers.GetHashCode(obj);
		}
	}

	private ErrorContext _currentErrorContext;

	private BidirectionalDictionary<string, object> _mappings;

	internal readonly JsonSerializer Serializer;

	internal readonly ITraceWriter TraceWriter;

	protected JsonSerializerProxy InternalSerializer;

	internal BidirectionalDictionary<string, object> DefaultReferenceMappings
	{
		get
		{
			if (_mappings == null)
			{
				_mappings = new BidirectionalDictionary<string, object>(EqualityComparer<string>.Default, new ReferenceEqualsEqualityComparer(), "A different value already has the Id '{0}'.", "A different Id has already been assigned for value '{0}'.");
			}
			return _mappings;
		}
	}

	protected JsonSerializerInternalBase(JsonSerializer serializer)
	{
		ValidationUtils.ArgumentNotNull(serializer, "serializer");
		Serializer = serializer;
		TraceWriter = serializer.TraceWriter;
	}

	private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error)
	{
		if (_currentErrorContext == null)
		{
			_currentErrorContext = new ErrorContext(currentObject, member, path, error);
		}
		if (_currentErrorContext.Error != error)
		{
			throw new InvalidOperationException("Current error context error is different to requested error.");
		}
		return _currentErrorContext;
	}

	protected void ClearErrorContext()
	{
		if (_currentErrorContext == null)
		{
			throw new InvalidOperationException("Could not clear error context. Error context is already null.");
		}
		_currentErrorContext = null;
	}

	protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex)
	{
		ErrorContext errorContext = GetErrorContext(currentObject, keyValue, path, ex);
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Error && !errorContext.Traced)
		{
			errorContext.Traced = true;
			string text = (((object)GetType() == typeof(JsonSerializerInternalWriter)) ? "Error serializing" : "Error deserializing");
			if (contract != null)
			{
				text = text + " " + contract.UnderlyingType;
			}
			text = text + ". " + ex.Message;
			if (!(ex is JsonException))
			{
				text = JsonPosition.FormatMessage(lineInfo, path, text);
			}
			TraceWriter.Trace(TraceLevel.Error, text, ex);
		}
		if (contract != null && currentObject != null)
		{
			contract.InvokeOnError(currentObject, Serializer.Context, errorContext);
		}
		if (!errorContext.Handled)
		{
			Serializer.OnError(new ErrorEventArgs(currentObject, errorContext));
		}
		return errorContext.Handled;
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;

private class ReferenceEqualsEqualityComparer : IEqualityComparer<object>
{
	bool IEqualityComparer<object>.Equals(object x, object y)
	{
		return x == y;
	}

	int IEqualityComparer<object>.GetHashCode(object obj)
	{
		return RuntimeHelpers.GetHashCode(obj);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class JsonSerializerInternalReader : JsonSerializerInternalBase
{
	internal enum PropertyPresence
	{
		None,
		Null,
		Value
	}

	internal class CreatorPropertyContext
	{
		public string Name;

		public JsonProperty Property;

		public JsonProperty ConstructorProperty;

		public PropertyPresence? Presence;

		public object Value;

		public bool Used;
	}

	public JsonSerializerInternalReader(JsonSerializer serializer)
		: base(serializer)
	{
	}

	public void Populate(JsonReader reader, object target)
	{
		ValidationUtils.ArgumentNotNull(target, "target");
		Type type = target.GetType();
		JsonContract jsonContract = Serializer._contractResolver.ResolveContract(type);
		if (!reader.MoveToContent())
		{
			throw JsonSerializationException.Create(reader, "No JSON content found.");
		}
		if (reader.TokenType == JsonToken.StartArray)
		{
			if (jsonContract.ContractType == JsonContractType.Array)
			{
				JsonArrayContract jsonArrayContract = (JsonArrayContract)jsonContract;
				object list;
				if (!jsonArrayContract.ShouldCreateWrapper)
				{
					list = (IList)target;
				}
				else
				{
					IList list2 = jsonArrayContract.CreateWrapper(target);
					list = list2;
				}
				PopulateList((IList)list, reader, jsonArrayContract, null, null);
				return;
			}
			throw JsonSerializationException.Create(reader, "Cannot populate JSON array onto type '{0}'.".FormatWith(CultureInfo.InvariantCulture, type));
		}
		if (reader.TokenType == JsonToken.StartObject)
		{
			reader.ReadAndAssert();
			string id = null;
			if (Serializer.MetadataPropertyHandling != MetadataPropertyHandling.Ignore && reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), "$id", StringComparison.Ordinal))
			{
				reader.ReadAndAssert();
				id = ((reader.Value != null) ? reader.Value.ToString() : null);
				reader.ReadAndAssert();
			}
			if (jsonContract.ContractType == JsonContractType.Dictionary)
			{
				JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)jsonContract;
				object dictionary;
				if (!jsonDictionaryContract.ShouldCreateWrapper)
				{
					dictionary = (IDictionary)target;
				}
				else
				{
					IDictionary dictionary2 = jsonDictionaryContract.CreateWrapper(target);
					dictionary = dictionary2;
				}
				PopulateDictionary((IDictionary)dictionary, reader, jsonDictionaryContract, null, id);
			}
			else
			{
				if (jsonContract.ContractType != JsonContractType.Object)
				{
					throw JsonSerializationException.Create(reader, "Cannot populate JSON object onto type '{0}'.".FormatWith(CultureInfo.InvariantCulture, type));
				}
				PopulateObject(target, reader, (JsonObjectContract)jsonContract, null, id);
			}
			return;
		}
		throw JsonSerializationException.Create(reader, "Unexpected initial token '{0}' when populating object. Expected JSON object or array.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
	}

	private JsonContract GetContractSafe(Type type)
	{
		if ((object)type == null)
		{
			return null;
		}
		return Serializer._contractResolver.ResolveContract(type);
	}

	public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		JsonContract contractSafe = GetContractSafe(objectType);
		try
		{
			JsonConverter converter = GetConverter(contractSafe, null, null, null);
			if (reader.TokenType == JsonToken.None && !ReadForType(reader, contractSafe, converter != null))
			{
				if (contractSafe != null && !contractSafe.IsNullable)
				{
					throw JsonSerializationException.Create(reader, "No JSON content found and type '{0}' is not nullable.".FormatWith(CultureInfo.InvariantCulture, contractSafe.UnderlyingType));
				}
				return null;
			}
			object result = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, objectType, contractSafe, null, null, null, null) : DeserializeConvertable(converter, reader, objectType, null));
			if (checkAdditionalContent && reader.Read() && reader.TokenType != JsonToken.Comment)
			{
				throw new JsonSerializationException("Additional text found in JSON string after finishing deserializing object.");
			}
			return result;
		}
		catch (Exception ex)
		{
			if (IsErrorHandled(null, contractSafe, null, reader as IJsonLineInfo, reader.Path, ex))
			{
				HandleError(reader, readPastError: false, 0);
				return null;
			}
			ClearErrorContext();
			throw;
		}
	}

	private JsonSerializerProxy GetInternalSerializer()
	{
		if (InternalSerializer == null)
		{
			InternalSerializer = new JsonSerializerProxy(this);
		}
		return InternalSerializer;
	}

	private JToken CreateJToken(JsonReader reader, JsonContract contract)
	{
		ValidationUtils.ArgumentNotNull(reader, "reader");
		if (contract != null)
		{
			if ((object)contract.UnderlyingType == typeof(JRaw))
			{
				return JRaw.Create(reader);
			}
			if (reader.TokenType == JsonToken.Null && (object)contract.UnderlyingType != typeof(JValue) && (object)contract.UnderlyingType != typeof(JToken))
			{
				return null;
			}
		}
		using JTokenWriter jTokenWriter = new JTokenWriter();
		jTokenWriter.WriteToken(reader);
		return jTokenWriter.Token;
	}

	private JToken CreateJObject(JsonReader reader)
	{
		ValidationUtils.ArgumentNotNull(reader, "reader");
		using JTokenWriter jTokenWriter = new JTokenWriter();
		jTokenWriter.WriteStartObject();
		do
		{
			if (reader.TokenType == JsonToken.PropertyName)
			{
				string text = (string)reader.Value;
				if (!reader.ReadAndMoveToContent())
				{
					break;
				}
				if (!CheckPropertyName(reader, text))
				{
					jTokenWriter.WritePropertyName(text);
					jTokenWriter.WriteToken(reader, writeChildren: true, writeDateConstructorAsDate: true, writeComments: false);
				}
			}
			else if (reader.TokenType != JsonToken.Comment)
			{
				jTokenWriter.WriteEndObject();
				return jTokenWriter.Token;
			}
		}
		while (reader.Read());
		throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
	}

	private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue)
	{
		if (contract != null && contract.ContractType == JsonContractType.Linq)
		{
			return CreateJToken(reader, contract);
		}
		do
		{
			switch (reader.TokenType)
			{
			case JsonToken.StartObject:
				return CreateObject(reader, objectType, contract, member, containerContract, containerMember, existingValue);
			case JsonToken.StartArray:
				return CreateList(reader, objectType, contract, member, existingValue, null);
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.Boolean:
			case JsonToken.Date:
			case JsonToken.Bytes:
				return EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
			case JsonToken.String:
			{
				string text = (string)reader.Value;
				if (CoerceEmptyStringToNull(objectType, contract, text))
				{
					return null;
				}
				if ((object)objectType == typeof(byte[]))
				{
					return Convert.FromBase64String(text);
				}
				return EnsureType(reader, text, CultureInfo.InvariantCulture, contract, objectType);
			}
			case JsonToken.StartConstructor:
			{
				string value = reader.Value.ToString();
				return EnsureType(reader, value, CultureInfo.InvariantCulture, contract, objectType);
			}
			case JsonToken.Null:
			case JsonToken.Undefined:
				if ((object)objectType == typeof(DBNull))
				{
					return DBNull.Value;
				}
				return EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
			case JsonToken.Raw:
				return new JRaw((string)reader.Value);
			default:
				throw JsonSerializationException.Create(reader, "Unexpected token while deserializing object: " + reader.TokenType);
			case JsonToken.Comment:
				break;
			}
		}
		while (reader.Read());
		throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
	}

	private static bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s)
	{
		if (string.IsNullOrEmpty(s) && (object)objectType != null && (object)objectType != typeof(string) && (object)objectType != typeof(object) && contract != null)
		{
			return contract.IsNullable;
		}
		return false;
	}

	internal string GetExpectedDescription(JsonContract contract)
	{
		switch (contract.ContractType)
		{
		case JsonContractType.Object:
		case JsonContractType.Dictionary:
		case JsonContractType.Serializable:
			return "JSON object (e.g. {\"name\":\"value\"})";
		case JsonContractType.Array:
			return "JSON array (e.g. [1,2,3])";
		case JsonContractType.Primitive:
			return "JSON primitive value (e.g. string, number, boolean, null)";
		case JsonContractType.String:
			return "JSON string value";
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty)
	{
		JsonConverter result = null;
		if (memberConverter != null)
		{
			result = memberConverter;
		}
		else if (containerProperty != null && containerProperty.ItemConverter != null)
		{
			result = containerProperty.ItemConverter;
		}
		else if (containerContract != null && containerContract.ItemConverter != null)
		{
			result = containerContract.ItemConverter;
		}
		else if (contract != null)
		{
			JsonConverter matchingConverter;
			if (contract.Converter != null)
			{
				result = contract.Converter;
			}
			else if ((matchingConverter = Serializer.GetMatchingConverter(contract.UnderlyingType)) != null)
			{
				result = matchingConverter;
			}
			else if (contract.InternalConverter != null)
			{
				result = contract.InternalConverter;
			}
		}
		return result;
	}

	private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue)
	{
		Type objectType2 = objectType;
		string id;
		if (Serializer.MetadataPropertyHandling == MetadataPropertyHandling.Ignore)
		{
			reader.ReadAndAssert();
			id = null;
		}
		else if (Serializer.MetadataPropertyHandling == MetadataPropertyHandling.ReadAhead)
		{
			JTokenReader jTokenReader = reader as JTokenReader;
			if (jTokenReader == null)
			{
				jTokenReader = (JTokenReader)JToken.ReadFrom(reader).CreateReader();
				jTokenReader.Culture = reader.Culture;
				jTokenReader.DateFormatString = reader.DateFormatString;
				jTokenReader.DateParseHandling = reader.DateParseHandling;
				jTokenReader.DateTimeZoneHandling = reader.DateTimeZoneHandling;
				jTokenReader.FloatParseHandling = reader.FloatParseHandling;
				jTokenReader.SupportMultipleContent = reader.SupportMultipleContent;
				jTokenReader.ReadAndAssert();
				reader = jTokenReader;
			}
			if (ReadMetadataPropertiesToken(jTokenReader, ref objectType2, ref contract, member, containerContract, containerMember, existingValue, out var newValue, out id))
			{
				return newValue;
			}
		}
		else
		{
			reader.ReadAndAssert();
			if (ReadMetadataProperties(reader, ref objectType2, ref contract, member, containerContract, containerMember, existingValue, out var newValue2, out id))
			{
				return newValue2;
			}
		}
		if (HasNoDefinedType(contract))
		{
			return CreateJObject(reader);
		}
		switch (contract.ContractType)
		{
		case JsonContractType.Object:
		{
			bool createdFromNonDefaultCreator2 = false;
			JsonObjectContract jsonObjectContract = (JsonObjectContract)contract;
			object obj = ((existingValue == null || ((object)objectType2 != objectType && !objectType2.IsAssignableFrom(existingValue.GetType()))) ? CreateNewObject(reader, jsonObjectContract, member, containerMember, id, out createdFromNonDefaultCreator2) : existingValue);
			if (createdFromNonDefaultCreator2)
			{
				return obj;
			}
			return PopulateObject(obj, reader, jsonObjectContract, member, id);
		}
		case JsonContractType.Primitive:
		{
			JsonPrimitiveContract contract3 = (JsonPrimitiveContract)contract;
			if (Serializer.MetadataPropertyHandling != MetadataPropertyHandling.Ignore && reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), "$value", StringComparison.Ordinal))
			{
				reader.ReadAndAssert();
				if (reader.TokenType == JsonToken.StartObject)
				{
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing primitive value: " + reader.TokenType);
				}
				object result = CreateValueInternal(reader, objectType2, contract3, member, null, null, existingValue);
				reader.ReadAndAssert();
				return result;
			}
			break;
		}
		case JsonContractType.Dictionary:
		{
			JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)contract;
			if (existingValue == null)
			{
				bool createdFromNonDefaultCreator;
				IDictionary dictionary = CreateNewDictionary(reader, jsonDictionaryContract, out createdFromNonDefaultCreator);
				if (createdFromNonDefaultCreator)
				{
					if (id != null)
					{
						throw JsonSerializationException.Create(reader, "Cannot preserve reference to readonly dictionary, or dictionary created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
					if (contract.OnSerializingCallbacks.Count > 0)
					{
						throw JsonSerializationException.Create(reader, "Cannot call OnSerializing on readonly dictionary, or dictionary created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
					if (contract.OnErrorCallbacks.Count > 0)
					{
						throw JsonSerializationException.Create(reader, "Cannot call OnError on readonly list, or dictionary created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
					if (!jsonDictionaryContract.HasParameterizedCreatorInternal)
					{
						throw JsonSerializationException.Create(reader, "Cannot deserialize readonly or fixed size dictionary: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
				}
				PopulateDictionary(dictionary, reader, jsonDictionaryContract, member, id);
				if (createdFromNonDefaultCreator)
				{
					return (jsonDictionaryContract.OverrideCreator ?? jsonDictionaryContract.ParameterizedCreator)(dictionary);
				}
				if (dictionary is IWrappedDictionary)
				{
					return ((IWrappedDictionary)dictionary).UnderlyingDictionary;
				}
				return dictionary;
			}
			object dictionary2;
			if (!jsonDictionaryContract.ShouldCreateWrapper)
			{
				dictionary2 = (IDictionary)existingValue;
			}
			else
			{
				IDictionary dictionary3 = jsonDictionaryContract.CreateWrapper(existingValue);
				dictionary2 = dictionary3;
			}
			return PopulateDictionary((IDictionary)dictionary2, reader, jsonDictionaryContract, member, id);
		}
		case JsonContractType.Serializable:
		{
			JsonISerializableContract contract2 = (JsonISerializableContract)contract;
			return CreateISerializable(reader, contract2, member, id);
		}
		}
		string format = "Cannot deserialize the current JSON object (e.g. {{\"name\":\"value\"}}) into type '{0}' because the type requires a {1} to deserialize correctly." + Environment.NewLine + "To fix this error either change the JSON to a {1} or change the deserialized type so that it is a normal .NET type (e.g. not a primitive type like integer, not a collection type like an array or List<T>) that can be deserialized from a JSON object. JsonObjectAttribute can also be added to the type to force it to deserialize from a JSON object." + Environment.NewLine;
		format = format.FormatWith(CultureInfo.InvariantCulture, objectType2, GetExpectedDescription(contract));
		throw JsonSerializationException.Create(reader, format);
	}

	private bool ReadMetadataPropertiesToken(JTokenReader reader, ref Type objectType, ref JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, out object newValue, out string id)
	{
		id = null;
		newValue = null;
		if (reader.TokenType == JsonToken.StartObject)
		{
			JObject jObject = (JObject)reader.CurrentToken;
			JToken jToken = jObject["$ref"];
			if (jToken != null)
			{
				if (jToken.Type != JTokenType.String && jToken.Type != JTokenType.Null)
				{
					throw JsonSerializationException.Create(jToken, jToken.Path, "JSON reference {0} property must have a string or null value.".FormatWith(CultureInfo.InvariantCulture, "$ref"), null);
				}
				JToken parent = jToken.Parent;
				JToken jToken2 = null;
				if (parent.Next != null)
				{
					jToken2 = parent.Next;
				}
				else if (parent.Previous != null)
				{
					jToken2 = parent.Previous;
				}
				string text = (string)jToken;
				if (text != null)
				{
					if (jToken2 != null)
					{
						throw JsonSerializationException.Create(jToken2, jToken2.Path, "Additional content found in JSON reference object. A JSON reference object should only have a {0} property.".FormatWith(CultureInfo.InvariantCulture, "$ref"), null);
					}
					newValue = Serializer.GetReferenceResolver().ResolveReference(this, text);
					if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
					{
						TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader, reader.Path, "Resolved object reference '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, text, newValue.GetType())), null);
					}
					reader.Skip();
					return true;
				}
			}
			JToken jToken3 = jObject["$type"];
			if (jToken3 != null)
			{
				string qualifiedTypeName = (string)jToken3;
				JsonReader jsonReader = jToken3.CreateReader();
				jsonReader.ReadAndAssert();
				ResolveTypeName(jsonReader, ref objectType, ref contract, member, containerContract, containerMember, qualifiedTypeName);
				if (jObject["$value"] != null)
				{
					while (true)
					{
						reader.ReadAndAssert();
						if (reader.TokenType == JsonToken.PropertyName && (string)reader.Value == "$value")
						{
							break;
						}
						reader.ReadAndAssert();
						reader.Skip();
					}
					return false;
				}
			}
			JToken jToken4 = jObject["$id"];
			if (jToken4 != null)
			{
				id = (string)jToken4;
			}
			JToken jToken5 = jObject["$values"];
			if (jToken5 != null)
			{
				JsonReader jsonReader2 = jToken5.CreateReader();
				jsonReader2.ReadAndAssert();
				newValue = CreateList(jsonReader2, objectType, contract, member, existingValue, id);
				reader.Skip();
				return true;
			}
		}
		reader.ReadAndAssert();
		return false;
	}

	private bool ReadMetadataProperties(JsonReader reader, ref Type objectType, ref JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, out object newValue, out string id)
	{
		id = null;
		newValue = null;
		if (reader.TokenType == JsonToken.PropertyName)
		{
			string text = reader.Value.ToString();
			if (text.Length > 0 && text[0] == '$')
			{
				bool flag;
				do
				{
					text = reader.Value.ToString();
					if (string.Equals(text, "$ref", StringComparison.Ordinal))
					{
						reader.ReadAndAssert();
						if (reader.TokenType != JsonToken.String && reader.TokenType != JsonToken.Null)
						{
							throw JsonSerializationException.Create(reader, "JSON reference {0} property must have a string or null value.".FormatWith(CultureInfo.InvariantCulture, "$ref"));
						}
						string text2 = ((reader.Value != null) ? reader.Value.ToString() : null);
						reader.ReadAndAssert();
						if (text2 != null)
						{
							if (reader.TokenType == JsonToken.PropertyName)
							{
								throw JsonSerializationException.Create(reader, "Additional content found in JSON reference object. A JSON reference object should only have a {0} property.".FormatWith(CultureInfo.InvariantCulture, "$ref"));
							}
							newValue = Serializer.GetReferenceResolver().ResolveReference(this, text2);
							if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
							{
								TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Resolved object reference '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, text2, newValue.GetType())), null);
							}
							return true;
						}
						flag = true;
					}
					else if (string.Equals(text, "$type", StringComparison.Ordinal))
					{
						reader.ReadAndAssert();
						string qualifiedTypeName = reader.Value.ToString();
						ResolveTypeName(reader, ref objectType, ref contract, member, containerContract, containerMember, qualifiedTypeName);
						reader.ReadAndAssert();
						flag = true;
					}
					else if (string.Equals(text, "$id", StringComparison.Ordinal))
					{
						reader.ReadAndAssert();
						id = ((reader.Value != null) ? reader.Value.ToString() : null);
						reader.ReadAndAssert();
						flag = true;
					}
					else
					{
						if (string.Equals(text, "$values", StringComparison.Ordinal))
						{
							reader.ReadAndAssert();
							object obj = CreateList(reader, objectType, contract, member, existingValue, id);
							reader.ReadAndAssert();
							newValue = obj;
							return true;
						}
						flag = false;
					}
				}
				while (flag && reader.TokenType == JsonToken.PropertyName);
			}
		}
		return false;
	}

	private void ResolveTypeName(JsonReader reader, ref Type objectType, ref JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, string qualifiedTypeName)
	{
		if ((member?.TypeNameHandling ?? containerContract?.ItemTypeNameHandling ?? containerMember?.ItemTypeNameHandling ?? Serializer._typeNameHandling) != 0)
		{
			ReflectionUtils.SplitFullyQualifiedTypeName(qualifiedTypeName, out var typeName, out var assemblyName);
			Type type;
			try
			{
				type = Serializer._binder.BindToType(assemblyName, typeName);
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(reader, "Error resolving type specified in JSON '{0}'.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName), ex);
			}
			if ((object)type == null)
			{
				throw JsonSerializationException.Create(reader, "Type specified in JSON '{0}' was not resolved.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName));
			}
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Resolved type '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName, type)), null);
			}
			if ((object)objectType != null && !objectType.IsAssignableFrom(type))
			{
				throw JsonSerializationException.Create(reader, "Type specified in JSON '{0}' is not compatible with '{1}'.".FormatWith(CultureInfo.InvariantCulture, type.AssemblyQualifiedName, objectType.AssemblyQualifiedName));
			}
			objectType = type;
			contract = GetContractSafe(type);
		}
	}

	private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract)
	{
		if (contract == null)
		{
			throw JsonSerializationException.Create(reader, "Could not resolve type '{0}' to a JsonContract.".FormatWith(CultureInfo.InvariantCulture, objectType));
		}
		JsonArrayContract obj = contract as JsonArrayContract;
		if (obj == null)
		{
			string format = "Cannot deserialize the current JSON array (e.g. [1,2,3]) into type '{0}' because the type requires a {1} to deserialize correctly." + Environment.NewLine + "To fix this error either change the JSON to a {1} or change the deserialized type to an array or a type that implements a collection interface (e.g. ICollection, IList) like List<T> that can be deserialized from a JSON array. JsonArrayAttribute can also be added to the type to force it to deserialize from a JSON array." + Environment.NewLine;
			format = format.FormatWith(CultureInfo.InvariantCulture, objectType, GetExpectedDescription(contract));
			throw JsonSerializationException.Create(reader, format);
		}
		return obj;
	}

	private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id)
	{
		if (HasNoDefinedType(contract))
		{
			return CreateJToken(reader, contract);
		}
		JsonArrayContract jsonArrayContract = EnsureArrayContract(reader, objectType, contract);
		if (existingValue == null)
		{
			bool createdFromNonDefaultCreator;
			IList list = CreateNewList(reader, jsonArrayContract, out createdFromNonDefaultCreator);
			if (createdFromNonDefaultCreator)
			{
				if (id != null)
				{
					throw JsonSerializationException.Create(reader, "Cannot preserve reference to array or readonly list, or list created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
				}
				if (contract.OnSerializingCallbacks.Count > 0)
				{
					throw JsonSerializationException.Create(reader, "Cannot call OnSerializing on an array or readonly list, or list created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
				}
				if (contract.OnErrorCallbacks.Count > 0)
				{
					throw JsonSerializationException.Create(reader, "Cannot call OnError on an array or readonly list, or list created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
				}
				if (!jsonArrayContract.HasParameterizedCreatorInternal && !jsonArrayContract.IsArray)
				{
					throw JsonSerializationException.Create(reader, "Cannot deserialize readonly or fixed size list: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
				}
			}
			if (!jsonArrayContract.IsMultidimensionalArray)
			{
				PopulateList(list, reader, jsonArrayContract, member, id);
			}
			else
			{
				PopulateMultidimensionalArray(list, reader, jsonArrayContract, member, id);
			}
			if (createdFromNonDefaultCreator)
			{
				if (jsonArrayContract.IsMultidimensionalArray)
				{
					list = CollectionUtils.ToMultidimensionalArray(list, jsonArrayContract.CollectionItemType, contract.CreatedType.GetArrayRank());
				}
				else
				{
					if (!jsonArrayContract.IsArray)
					{
						return (jsonArrayContract.OverrideCreator ?? jsonArrayContract.ParameterizedCreator)(list);
					}
					Array array = Array.CreateInstance(jsonArrayContract.CollectionItemType, list.Count);
					list.CopyTo(array, 0);
					list = array;
				}
			}
			else if (list is IWrappedCollection)
			{
				return ((IWrappedCollection)list).UnderlyingCollection;
			}
			return list;
		}
		if (!jsonArrayContract.CanDeserialize)
		{
			throw JsonSerializationException.Create(reader, "Cannot populate list type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.CreatedType));
		}
		object list2;
		if (!jsonArrayContract.ShouldCreateWrapper)
		{
			list2 = (IList)existingValue;
		}
		else
		{
			IList list3 = jsonArrayContract.CreateWrapper(existingValue);
			list2 = list3;
		}
		return PopulateList((IList)list2, reader, jsonArrayContract, member, id);
	}

	private bool HasNoDefinedType(JsonContract contract)
	{
		if (contract != null && (object)contract.UnderlyingType != typeof(object))
		{
			return contract.ContractType == JsonContractType.Linq;
		}
		return true;
	}

	private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType)
	{
		if ((object)targetType == null)
		{
			return value;
		}
		if ((object)ReflectionUtils.GetObjectType(value) != targetType)
		{
			if (value == null && contract.IsNullable)
			{
				return null;
			}
			try
			{
				if (contract.IsConvertable)
				{
					JsonPrimitiveContract jsonPrimitiveContract = (JsonPrimitiveContract)contract;
					if (contract.IsEnum)
					{
						if (value is string)
						{
							return Enum.Parse(contract.NonNullableUnderlyingType, value.ToString(), ignoreCase: true);
						}
						if (ConvertUtils.IsInteger(jsonPrimitiveContract.TypeCode))
						{
							return Enum.ToObject(contract.NonNullableUnderlyingType, value);
						}
					}
					return Convert.ChangeType(value, contract.NonNullableUnderlyingType, culture);
				}
				return ConvertUtils.ConvertOrCast(value, culture, contract.NonNullableUnderlyingType);
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(reader, "Error converting value {0} to type '{1}'.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.FormatValueForPrint(value), targetType), ex);
			}
		}
		return value;
	}

	private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target)
	{
		if (CalculatePropertyDetails(property, ref propertyConverter, containerContract, containerProperty, reader, target, out var useExistingValue, out var currentValue, out var propertyContract, out var gottenCurrentValue))
		{
			return false;
		}
		object obj;
		if (propertyConverter != null && propertyConverter.CanRead)
		{
			if (!gottenCurrentValue && target != null && property.Readable)
			{
				currentValue = property.ValueProvider.GetValue(target);
			}
			obj = DeserializeConvertable(propertyConverter, reader, property.PropertyType, currentValue);
		}
		else
		{
			obj = CreateValueInternal(reader, property.PropertyType, propertyContract, property, containerContract, containerProperty, useExistingValue ? currentValue : null);
		}
		if ((!useExistingValue || obj != currentValue) && ShouldSetPropertyValue(property, obj))
		{
			property.ValueProvider.SetValue(target, obj);
			if (property.SetIsSpecified != null)
			{
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
				{
					TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "IsSpecified for property '{0}' on {1} set to true.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType)), null);
				}
				property.SetIsSpecified(target, true);
			}
			return true;
		}
		return useExistingValue;
	}

	private bool CalculatePropertyDetails(JsonProperty property, ref JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, out bool useExistingValue, out object currentValue, out JsonContract propertyContract, out bool gottenCurrentValue)
	{
		currentValue = null;
		useExistingValue = false;
		propertyContract = null;
		gottenCurrentValue = false;
		if (property.Ignored)
		{
			return true;
		}
		JsonToken tokenType = reader.TokenType;
		if (property.PropertyContract == null)
		{
			property.PropertyContract = GetContractSafe(property.PropertyType);
		}
		if (property.ObjectCreationHandling.GetValueOrDefault(Serializer._objectCreationHandling) != ObjectCreationHandling.Replace && (tokenType == JsonToken.StartArray || tokenType == JsonToken.StartObject) && property.Readable)
		{
			currentValue = property.ValueProvider.GetValue(target);
			gottenCurrentValue = true;
			if (currentValue != null)
			{
				propertyContract = GetContractSafe(currentValue.GetType());
				useExistingValue = !propertyContract.IsReadOnlyOrFixedSize && !propertyContract.UnderlyingType.IsValueType();
			}
		}
		if (!property.Writable && !useExistingValue)
		{
			return true;
		}
		if (property.NullValueHandling.GetValueOrDefault(Serializer._nullValueHandling) == NullValueHandling.Ignore && tokenType == JsonToken.Null)
		{
			return true;
		}
		if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && !HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate) && JsonTokenUtils.IsPrimitiveToken(tokenType) && MiscellaneousUtils.ValueEquals(reader.Value, property.GetResolvedDefaultValue()))
		{
			return true;
		}
		if (currentValue == null)
		{
			propertyContract = property.PropertyContract;
		}
		else
		{
			propertyContract = GetContractSafe(currentValue.GetType());
			if (propertyContract != property.PropertyContract)
			{
				propertyConverter = GetConverter(propertyContract, property.MemberConverter, containerContract, containerProperty);
			}
		}
		return false;
	}

	private void AddReference(JsonReader reader, string id, object value)
	{
		try
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Read object reference Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, id, value.GetType())), null);
			}
			Serializer.GetReferenceResolver().AddReference(this, id, value);
		}
		catch (Exception ex)
		{
			throw JsonSerializationException.Create(reader, "Error reading object reference '{0}'.".FormatWith(CultureInfo.InvariantCulture, id), ex);
		}
	}

	private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
	{
		return (value & flag) == flag;
	}

	private bool ShouldSetPropertyValue(JsonProperty property, object value)
	{
		if (property.NullValueHandling.GetValueOrDefault(Serializer._nullValueHandling) == NullValueHandling.Ignore && value == null)
		{
			return false;
		}
		if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && !HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate) && MiscellaneousUtils.ValueEquals(value, property.GetResolvedDefaultValue()))
		{
			return false;
		}
		if (!property.Writable)
		{
			return false;
		}
		return true;
	}

	private IList CreateNewList(JsonReader reader, JsonArrayContract contract, out bool createdFromNonDefaultCreator)
	{
		if (!contract.CanDeserialize)
		{
			throw JsonSerializationException.Create(reader, "Cannot create and populate list type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.CreatedType));
		}
		if (contract.OverrideCreator != null)
		{
			if (contract.HasParameterizedCreator)
			{
				createdFromNonDefaultCreator = true;
				return contract.CreateTemporaryCollection();
			}
			createdFromNonDefaultCreator = false;
			return (IList)contract.OverrideCreator();
		}
		if (contract.IsReadOnlyOrFixedSize)
		{
			createdFromNonDefaultCreator = true;
			IList list = contract.CreateTemporaryCollection();
			if (contract.ShouldCreateWrapper)
			{
				list = contract.CreateWrapper(list);
			}
			return list;
		}
		if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
		{
			object obj = contract.DefaultCreator();
			if (contract.ShouldCreateWrapper)
			{
				obj = contract.CreateWrapper(obj);
			}
			createdFromNonDefaultCreator = false;
			return (IList)obj;
		}
		if (contract.HasParameterizedCreatorInternal)
		{
			createdFromNonDefaultCreator = true;
			return contract.CreateTemporaryCollection();
		}
		if (!contract.IsInstantiable)
		{
			throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
		}
		throw JsonSerializationException.Create(reader, "Unable to find a constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
	}

	private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, out bool createdFromNonDefaultCreator)
	{
		if (contract.OverrideCreator != null)
		{
			if (contract.HasParameterizedCreator)
			{
				createdFromNonDefaultCreator = true;
				return contract.CreateTemporaryDictionary();
			}
			createdFromNonDefaultCreator = false;
			return (IDictionary)contract.OverrideCreator();
		}
		if (contract.IsReadOnlyOrFixedSize)
		{
			createdFromNonDefaultCreator = true;
			return contract.CreateTemporaryDictionary();
		}
		if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
		{
			object obj = contract.DefaultCreator();
			if (contract.ShouldCreateWrapper)
			{
				obj = contract.CreateWrapper(obj);
			}
			createdFromNonDefaultCreator = false;
			return (IDictionary)obj;
		}
		if (contract.HasParameterizedCreatorInternal)
		{
			createdFromNonDefaultCreator = true;
			return contract.CreateTemporaryDictionary();
		}
		if (!contract.IsInstantiable)
		{
			throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
		}
		throw JsonSerializationException.Create(reader, "Unable to find a default constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
	}

	private void OnDeserializing(JsonReader reader, JsonContract contract, object value)
	{
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
		{
			TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Started deserializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
		}
		contract.InvokeOnDeserializing(value, Serializer._context);
	}

	private void OnDeserialized(JsonReader reader, JsonContract contract, object value)
	{
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
		{
			TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Finished deserializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
		}
		contract.InvokeOnDeserialized(value, Serializer._context);
	}

	private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id)
	{
		object obj = ((dictionary is IWrappedDictionary wrappedDictionary) ? wrappedDictionary.UnderlyingDictionary : dictionary);
		if (id != null)
		{
			AddReference(reader, id, obj);
		}
		OnDeserializing(reader, contract, obj);
		int depth = reader.Depth;
		if (contract.KeyContract == null)
		{
			contract.KeyContract = GetContractSafe(contract.DictionaryKeyType);
		}
		if (contract.ItemContract == null)
		{
			contract.ItemContract = GetContractSafe(contract.DictionaryValueType);
		}
		JsonConverter jsonConverter = contract.ItemConverter ?? GetConverter(contract.ItemContract, null, contract, containerProperty);
		PrimitiveTypeCode primitiveTypeCode = ((contract.KeyContract is JsonPrimitiveContract) ? ((JsonPrimitiveContract)contract.KeyContract).TypeCode : PrimitiveTypeCode.Empty);
		bool flag = false;
		do
		{
			switch (reader.TokenType)
			{
			case JsonToken.PropertyName:
			{
				object obj2 = reader.Value;
				if (CheckPropertyName(reader, obj2.ToString()))
				{
					break;
				}
				try
				{
					try
					{
						switch (primitiveTypeCode)
						{
						case PrimitiveTypeCode.DateTime:
						case PrimitiveTypeCode.DateTimeNullable:
						{
							obj2 = ((!DateTimeUtils.TryParseDateTime(obj2.ToString(), reader.DateTimeZoneHandling, reader.DateFormatString, reader.Culture, out var dt2)) ? EnsureType(reader, obj2, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType) : ((object)dt2));
							break;
						}
						case PrimitiveTypeCode.DateTimeOffset:
						case PrimitiveTypeCode.DateTimeOffsetNullable:
						{
							obj2 = ((!DateTimeUtils.TryParseDateTimeOffset(obj2.ToString(), reader.DateFormatString, reader.Culture, out var dt)) ? EnsureType(reader, obj2, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType) : ((object)dt));
							break;
						}
						default:
							obj2 = EnsureType(reader, obj2, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType);
							break;
						}
					}
					catch (Exception ex)
					{
						throw JsonSerializationException.Create(reader, "Could not convert string '{0}' to dictionary key type '{1}'. Create a TypeConverter to convert from the string to the key type object.".FormatWith(CultureInfo.InvariantCulture, reader.Value, contract.DictionaryKeyType), ex);
					}
					if (!ReadForType(reader, contract.ItemContract, jsonConverter != null))
					{
						throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
					}
					object value = ((jsonConverter == null || !jsonConverter.CanRead) ? CreateValueInternal(reader, contract.DictionaryValueType, contract.ItemContract, null, contract, containerProperty, null) : DeserializeConvertable(jsonConverter, reader, contract.DictionaryValueType, null));
					dictionary[obj2] = value;
				}
				catch (Exception ex2)
				{
					if (IsErrorHandled(obj, contract, obj2, reader as IJsonLineInfo, reader.Path, ex2))
					{
						HandleError(reader, readPastError: true, depth);
						break;
					}
					throw;
				}
				break;
			}
			case JsonToken.EndObject:
				flag = true;
				break;
			default:
				throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
			case JsonToken.Comment:
				break;
			}
		}
		while (!flag && reader.Read());
		if (!flag)
		{
			ThrowUnexpectedEndException(reader, contract, obj, "Unexpected end when deserializing object.");
		}
		OnDeserialized(reader, contract, obj);
		return obj;
	}

	private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id)
	{
		int arrayRank = contract.UnderlyingType.GetArrayRank();
		if (id != null)
		{
			AddReference(reader, id, list);
		}
		OnDeserializing(reader, contract, list);
		JsonContract contractSafe = GetContractSafe(contract.CollectionItemType);
		JsonConverter converter = GetConverter(contractSafe, null, contract, containerProperty);
		int? num = null;
		Stack<IList> stack = new Stack<IList>();
		stack.Push(list);
		IList list2 = list;
		bool flag = false;
		do
		{
			int depth = reader.Depth;
			if (stack.Count == arrayRank)
			{
				try
				{
					if (ReadForType(reader, contractSafe, converter != null))
					{
						JsonToken tokenType = reader.TokenType;
						if (tokenType == JsonToken.EndArray)
						{
							stack.Pop();
							list2 = stack.Peek();
							num = null;
						}
						else
						{
							object value = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, contract.CollectionItemType, contractSafe, null, contract, containerProperty, null) : DeserializeConvertable(converter, reader, contract.CollectionItemType, null));
							list2.Add(value);
						}
						continue;
					}
				}
				catch (Exception ex)
				{
					JsonPosition position = reader.GetPosition(depth);
					if (IsErrorHandled(list, contract, position.Position, reader as IJsonLineInfo, reader.Path, ex))
					{
						HandleError(reader, readPastError: true, depth);
						if (num.HasValue && num == position.Position)
						{
							throw JsonSerializationException.Create(reader, "Infinite loop detected from error handling.", ex);
						}
						num = position.Position;
						continue;
					}
					throw;
				}
				break;
			}
			if (!reader.Read())
			{
				break;
			}
			switch (reader.TokenType)
			{
			case JsonToken.StartArray:
			{
				IList list3 = new List<object>();
				list2.Add(list3);
				stack.Push(list3);
				list2 = list3;
				break;
			}
			case JsonToken.EndArray:
				stack.Pop();
				if (stack.Count > 0)
				{
					list2 = stack.Peek();
				}
				else
				{
					flag = true;
				}
				break;
			default:
				throw JsonSerializationException.Create(reader, "Unexpected token when deserializing multidimensional array: " + reader.TokenType);
			case JsonToken.Comment:
				break;
			}
		}
		while (!flag);
		if (!flag)
		{
			ThrowUnexpectedEndException(reader, contract, list, "Unexpected end when deserializing array.");
		}
		OnDeserialized(reader, contract, list);
		return list;
	}

	private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message)
	{
		try
		{
			throw JsonSerializationException.Create(reader, message);
		}
		catch (Exception ex)
		{
			if (IsErrorHandled(currentObject, contract, null, reader as IJsonLineInfo, reader.Path, ex))
			{
				HandleError(reader, readPastError: false, 0);
				return;
			}
			throw;
		}
	}

	private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id)
	{
		object obj = ((list is IWrappedCollection wrappedCollection) ? wrappedCollection.UnderlyingCollection : list);
		if (id != null)
		{
			AddReference(reader, id, obj);
		}
		if (list.IsFixedSize)
		{
			reader.Skip();
			return obj;
		}
		OnDeserializing(reader, contract, obj);
		int depth = reader.Depth;
		if (contract.ItemContract == null)
		{
			contract.ItemContract = GetContractSafe(contract.CollectionItemType);
		}
		JsonConverter converter = GetConverter(contract.ItemContract, null, contract, containerProperty);
		int? num = null;
		bool flag = false;
		do
		{
			try
			{
				if (ReadForType(reader, contract.ItemContract, converter != null))
				{
					JsonToken tokenType = reader.TokenType;
					if (tokenType == JsonToken.EndArray)
					{
						flag = true;
						continue;
					}
					object value = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, contract.CollectionItemType, contract.ItemContract, null, contract, containerProperty, null) : DeserializeConvertable(converter, reader, contract.CollectionItemType, null));
					list.Add(value);
					continue;
				}
			}
			catch (Exception ex)
			{
				JsonPosition position = reader.GetPosition(depth);
				if (IsErrorHandled(obj, contract, position.Position, reader as IJsonLineInfo, reader.Path, ex))
				{
					HandleError(reader, readPastError: true, depth);
					if (num.HasValue && num == position.Position)
					{
						throw JsonSerializationException.Create(reader, "Infinite loop detected from error handling.", ex);
					}
					num = position.Position;
					continue;
				}
				throw;
			}
			break;
		}
		while (!flag);
		if (!flag)
		{
			ThrowUnexpectedEndException(reader, contract, obj, "Unexpected end when deserializing array.");
		}
		OnDeserialized(reader, contract, obj);
		return obj;
	}

	private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id)
	{
		Type underlyingType = contract.UnderlyingType;
		if (!JsonTypeReflector.FullyTrusted)
		{
			string format = "Type '{0}' implements ISerializable but cannot be deserialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data." + Environment.NewLine + "To fix this error either change the environment to be fully trusted, change the application to not deserialize the type, add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true." + Environment.NewLine;
			format = format.FormatWith(CultureInfo.InvariantCulture, underlyingType);
			throw JsonSerializationException.Create(reader, format);
		}
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
		{
			TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Deserializing {0} using ISerializable constructor.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
		}
		SerializationInfo serializationInfo = new SerializationInfo(contract.UnderlyingType, new JsonFormatterConverter(this, contract, member));
		bool flag = false;
		do
		{
			switch (reader.TokenType)
			{
			case JsonToken.PropertyName:
			{
				string text = reader.Value.ToString();
				if (!reader.Read())
				{
					throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
				}
				serializationInfo.AddValue(text, JToken.ReadFrom(reader));
				break;
			}
			case JsonToken.EndObject:
				flag = true;
				break;
			default:
				throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
			case JsonToken.Comment:
				break;
			}
		}
		while (!flag && reader.Read());
		if (!flag)
		{
			ThrowUnexpectedEndException(reader, contract, serializationInfo, "Unexpected end when deserializing object.");
		}
		if (contract.ISerializableCreator == null)
		{
			throw JsonSerializationException.Create(reader, "ISerializable type '{0}' does not have a valid constructor. To correctly implement ISerializable a constructor that takes SerializationInfo and StreamingContext parameters should be present.".FormatWith(CultureInfo.InvariantCulture, underlyingType));
		}
		object obj = contract.ISerializableCreator(serializationInfo, Serializer._context);
		if (id != null)
		{
			AddReference(reader, id, obj);
		}
		OnDeserializing(reader, contract, obj);
		OnDeserialized(reader, contract, obj);
		return obj;
	}

	internal object CreateISerializableItem(JToken token, Type type, JsonISerializableContract contract, JsonProperty member)
	{
		JsonContract contractSafe = GetContractSafe(type);
		JsonConverter converter = GetConverter(contractSafe, null, contract, member);
		JsonReader jsonReader = token.CreateReader();
		jsonReader.ReadAndAssert();
		if (converter != null && converter.CanRead)
		{
			return DeserializeConvertable(converter, jsonReader, type, null);
		}
		return CreateValueInternal(jsonReader, type, contractSafe, null, contract, member, null);
	}

	private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor<object> creator, string id)
	{
		ValidationUtils.ArgumentNotNull(creator, "creator");
		bool flag = contract.HasRequiredOrDefaultValueProperties || HasFlag(Serializer._defaultValueHandling, DefaultValueHandling.Populate);
		Type underlyingType = contract.UnderlyingType;
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
		{
			string arg = string.Join(", ", contract.CreatorParameters.Select((JsonProperty p) => p.PropertyName).ToArray());
			TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Deserializing {0} using creator with parameters: {1}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType, arg)), null);
		}
		List<CreatorPropertyContext> list = ResolvePropertyAndCreatorValues(contract, containerProperty, reader, underlyingType);
		if (flag)
		{
			foreach (JsonProperty property in contract.Properties)
			{
				if (list.All((CreatorPropertyContext p) => p.Property != property))
				{
					list.Add(new CreatorPropertyContext
					{
						Property = property,
						Name = property.PropertyName,
						Presence = PropertyPresence.None
					});
				}
			}
		}
		object[] array = new object[contract.CreatorParameters.Count];
		foreach (CreatorPropertyContext item in list)
		{
			if (flag && item.Property != null && !item.Presence.HasValue)
			{
				object value = item.Value;
				PropertyPresence value2 = ((value == null) ? PropertyPresence.Null : ((!(value is string)) ? PropertyPresence.Value : (CoerceEmptyStringToNull(item.Property.PropertyType, item.Property.PropertyContract, (string)value) ? PropertyPresence.Null : PropertyPresence.Value)));
				item.Presence = value2;
			}
			JsonProperty jsonProperty = item.ConstructorProperty;
			if (jsonProperty == null && item.Property != null)
			{
				jsonProperty = contract.CreatorParameters.ForgivingCaseSensitiveFind((JsonProperty p) => p.PropertyName, item.Property.UnderlyingName);
			}
			if (jsonProperty == null || jsonProperty.Ignored)
			{
				continue;
			}
			if (flag && (item.Presence == PropertyPresence.None || item.Presence == PropertyPresence.Null))
			{
				if (jsonProperty.PropertyContract == null)
				{
					jsonProperty.PropertyContract = GetContractSafe(jsonProperty.PropertyType);
				}
				if (HasFlag(jsonProperty.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate))
				{
					item.Value = EnsureType(reader, jsonProperty.GetResolvedDefaultValue(), CultureInfo.InvariantCulture, jsonProperty.PropertyContract, jsonProperty.PropertyType);
				}
			}
			int num = contract.CreatorParameters.IndexOf(jsonProperty);
			array[num] = item.Value;
			item.Used = true;
		}
		object obj = creator(array);
		if (id != null)
		{
			AddReference(reader, id, obj);
		}
		OnDeserializing(reader, contract, obj);
		foreach (CreatorPropertyContext item2 in list)
		{
			if (item2.Used || item2.Property == null || item2.Property.Ignored || item2.Presence == PropertyPresence.None)
			{
				continue;
			}
			JsonProperty property2 = item2.Property;
			object value3 = item2.Value;
			if (ShouldSetPropertyValue(property2, value3))
			{
				property2.ValueProvider.SetValue(obj, value3);
				item2.Used = true;
			}
			else
			{
				if (property2.Writable || value3 == null)
				{
					continue;
				}
				JsonContract jsonContract = Serializer._contractResolver.ResolveContract(property2.PropertyType);
				if (jsonContract.ContractType == JsonContractType.Array)
				{
					JsonArrayContract jsonArrayContract = (JsonArrayContract)jsonContract;
					object value4 = property2.ValueProvider.GetValue(obj);
					if (value4 != null)
					{
						IWrappedCollection wrappedCollection = jsonArrayContract.CreateWrapper(value4);
						foreach (object item3 in jsonArrayContract.CreateWrapper(value3))
						{
							wrappedCollection.Add(item3);
						}
					}
				}
				else if (jsonContract.ContractType == JsonContractType.Dictionary)
				{
					JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)jsonContract;
					object value5 = property2.ValueProvider.GetValue(obj);
					if (value5 != null)
					{
						object obj2;
						if (!jsonDictionaryContract.ShouldCreateWrapper)
						{
							obj2 = (IDictionary)value5;
						}
						else
						{
							IDictionary dictionary = jsonDictionaryContract.CreateWrapper(value5);
							obj2 = dictionary;
						}
						IDictionary dictionary2 = (IDictionary)obj2;
						object obj3;
						if (!jsonDictionaryContract.ShouldCreateWrapper)
						{
							obj3 = (IDictionary)value3;
						}
						else
						{
							IDictionary dictionary = jsonDictionaryContract.CreateWrapper(value3);
							obj3 = dictionary;
						}
						foreach (DictionaryEntry item4 in (IDictionary)obj3)
						{
							dictionary2.Add(item4.Key, item4.Value);
						}
					}
				}
				item2.Used = true;
			}
		}
		if (contract.ExtensionDataSetter != null)
		{
			foreach (CreatorPropertyContext item5 in list)
			{
				if (!item5.Used)
				{
					contract.ExtensionDataSetter(obj, item5.Name, item5.Value);
				}
			}
		}
		if (flag)
		{
			foreach (CreatorPropertyContext item6 in list)
			{
				if (item6.Property != null)
				{
					EndProcessProperty(obj, reader, contract, reader.Depth, item6.Property, item6.Presence.GetValueOrDefault(), !item6.Used);
				}
			}
		}
		OnDeserialized(reader, contract, obj);
		return obj;
	}

	private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue)
	{
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
		{
			TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Started deserializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, objectType, converter.GetType())), null);
		}
		object result = converter.ReadJson(reader, objectType, existingValue, GetInternalSerializer());
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
		{
			TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Finished deserializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, objectType, converter.GetType())), null);
		}
		return result;
	}

	private List<CreatorPropertyContext> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType)
	{
		List<CreatorPropertyContext> list = new List<CreatorPropertyContext>();
		bool flag = false;
		do
		{
			switch (reader.TokenType)
			{
			case JsonToken.PropertyName:
			{
				string text = reader.Value.ToString();
				CreatorPropertyContext creatorPropertyContext = new CreatorPropertyContext
				{
					Name = reader.Value.ToString(),
					ConstructorProperty = contract.CreatorParameters.GetClosestMatchProperty(text),
					Property = contract.Properties.GetClosestMatchProperty(text)
				};
				list.Add(creatorPropertyContext);
				JsonProperty jsonProperty = creatorPropertyContext.ConstructorProperty ?? creatorPropertyContext.Property;
				if (jsonProperty != null && !jsonProperty.Ignored)
				{
					if (jsonProperty.PropertyContract == null)
					{
						jsonProperty.PropertyContract = GetContractSafe(jsonProperty.PropertyType);
					}
					JsonConverter converter = GetConverter(jsonProperty.PropertyContract, jsonProperty.MemberConverter, contract, containerProperty);
					if (!ReadForType(reader, jsonProperty.PropertyContract, converter != null))
					{
						throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
					}
					if (converter != null && converter.CanRead)
					{
						creatorPropertyContext.Value = DeserializeConvertable(converter, reader, jsonProperty.PropertyType, null);
					}
					else
					{
						creatorPropertyContext.Value = CreateValueInternal(reader, jsonProperty.PropertyType, jsonProperty.PropertyContract, jsonProperty, contract, containerProperty, null);
					}
					break;
				}
				if (!reader.Read())
				{
					throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
				}
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
				{
					TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Could not find member '{0}' on {1}.".FormatWith(CultureInfo.InvariantCulture, text, contract.UnderlyingType)), null);
				}
				if (Serializer._missingMemberHandling == MissingMemberHandling.Error)
				{
					throw JsonSerializationException.Create(reader, "Could not find member '{0}' on object of type '{1}'".FormatWith(CultureInfo.InvariantCulture, text, objectType.Name));
				}
				if (contract.ExtensionDataSetter != null)
				{
					creatorPropertyContext.Value = ReadExtensionDataValue(contract, containerProperty, reader);
				}
				else
				{
					reader.Skip();
				}
				break;
			}
			case JsonToken.EndObject:
				flag = true;
				break;
			default:
				throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
			case JsonToken.Comment:
				break;
			}
		}
		while (!flag && reader.Read());
		return list;
	}

	private bool ReadForType(JsonReader reader, JsonContract contract, bool hasConverter)
	{
		if (hasConverter)
		{
			return reader.Read();
		}
		switch (contract?.InternalReadType ?? ReadType.Read)
		{
		case ReadType.Read:
			return reader.ReadAndMoveToContent();
		case ReadType.ReadAsInt32:
			reader.ReadAsInt32();
			break;
		case ReadType.ReadAsDecimal:
			reader.ReadAsDecimal();
			break;
		case ReadType.ReadAsDouble:
			reader.ReadAsDouble();
			break;
		case ReadType.ReadAsBytes:
			reader.ReadAsBytes();
			break;
		case ReadType.ReadAsBoolean:
			reader.ReadAsBoolean();
			break;
		case ReadType.ReadAsString:
			reader.ReadAsString();
			break;
		case ReadType.ReadAsDateTime:
			reader.ReadAsDateTime();
			break;
		case ReadType.ReadAsDateTimeOffset:
			reader.ReadAsDateTimeOffset();
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
		return reader.TokenType != JsonToken.None;
	}

	public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, out bool createdFromNonDefaultCreator)
	{
		object obj = null;
		if (objectContract.OverrideCreator != null)
		{
			if (objectContract.CreatorParameters.Count > 0)
			{
				createdFromNonDefaultCreator = true;
				return CreateObjectUsingCreatorWithParameters(reader, objectContract, containerMember, objectContract.OverrideCreator, id);
			}
			obj = objectContract.OverrideCreator();
		}
		else if (objectContract.DefaultCreator != null && (!objectContract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor || objectContract.ParameterizedCreator == null))
		{
			obj = objectContract.DefaultCreator();
		}
		else if (objectContract.ParameterizedCreator != null)
		{
			createdFromNonDefaultCreator = true;
			return CreateObjectUsingCreatorWithParameters(reader, objectContract, containerMember, objectContract.ParameterizedCreator, id);
		}
		if (obj == null)
		{
			if (!objectContract.IsInstantiable)
			{
				throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, objectContract.UnderlyingType));
			}
			throw JsonSerializationException.Create(reader, "Unable to find a constructor to use for type {0}. A class should either have a default constructor, one constructor with arguments or a constructor marked with the JsonConstructor attribute.".FormatWith(CultureInfo.InvariantCulture, objectContract.UnderlyingType));
		}
		createdFromNonDefaultCreator = false;
		return obj;
	}

	private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id)
	{
		OnDeserializing(reader, contract, newObject);
		Dictionary<JsonProperty, PropertyPresence> dictionary = ((contract.HasRequiredOrDefaultValueProperties || HasFlag(Serializer._defaultValueHandling, DefaultValueHandling.Populate)) ? contract.Properties.ToDictionary((JsonProperty m) => m, (JsonProperty m) => PropertyPresence.None) : null);
		if (id != null)
		{
			AddReference(reader, id, newObject);
		}
		int depth = reader.Depth;
		bool flag = false;
		do
		{
			switch (reader.TokenType)
			{
			case JsonToken.PropertyName:
			{
				string text = reader.Value.ToString();
				if (CheckPropertyName(reader, text))
				{
					break;
				}
				try
				{
					JsonProperty closestMatchProperty = contract.Properties.GetClosestMatchProperty(text);
					if (closestMatchProperty == null)
					{
						if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
						{
							TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Could not find member '{0}' on {1}".FormatWith(CultureInfo.InvariantCulture, text, contract.UnderlyingType)), null);
						}
						if (Serializer._missingMemberHandling == MissingMemberHandling.Error)
						{
							throw JsonSerializationException.Create(reader, "Could not find member '{0}' on object of type '{1}'".FormatWith(CultureInfo.InvariantCulture, text, contract.UnderlyingType.Name));
						}
						if (reader.Read())
						{
							SetExtensionData(contract, member, reader, text, newObject);
						}
						break;
					}
					if (closestMatchProperty.Ignored || !ShouldDeserialize(reader, closestMatchProperty, newObject))
					{
						if (reader.Read())
						{
							SetPropertyPresence(reader, closestMatchProperty, dictionary);
							SetExtensionData(contract, member, reader, text, newObject);
						}
						break;
					}
					if (closestMatchProperty.PropertyContract == null)
					{
						closestMatchProperty.PropertyContract = GetContractSafe(closestMatchProperty.PropertyType);
					}
					JsonConverter converter = GetConverter(closestMatchProperty.PropertyContract, closestMatchProperty.MemberConverter, contract, member);
					if (!ReadForType(reader, closestMatchProperty.PropertyContract, converter != null))
					{
						throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
					}
					SetPropertyPresence(reader, closestMatchProperty, dictionary);
					if (!SetPropertyValue(closestMatchProperty, converter, contract, member, reader, newObject))
					{
						SetExtensionData(contract, member, reader, text, newObject);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(newObject, contract, text, reader as IJsonLineInfo, reader.Path, ex))
					{
						HandleError(reader, readPastError: true, depth);
						break;
					}
					throw;
				}
				break;
			}
			case JsonToken.EndObject:
				flag = true;
				break;
			default:
				throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
			case JsonToken.Comment:
				break;
			}
		}
		while (!flag && reader.Read());
		if (!flag)
		{
			ThrowUnexpectedEndException(reader, contract, newObject, "Unexpected end when deserializing object.");
		}
		if (dictionary != null)
		{
			foreach (KeyValuePair<JsonProperty, PropertyPresence> item in dictionary)
			{
				JsonProperty key = item.Key;
				PropertyPresence value = item.Value;
				EndProcessProperty(newObject, reader, contract, depth, key, value, setDefaultValue: true);
			}
		}
		OnDeserialized(reader, contract, newObject);
		return newObject;
	}

	private bool ShouldDeserialize(JsonReader reader, JsonProperty property, object target)
	{
		if (property.ShouldDeserialize == null)
		{
			return true;
		}
		bool flag = property.ShouldDeserialize(target);
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
		{
			TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, reader.Path, "ShouldDeserialize result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, flag)), null);
		}
		return flag;
	}

	private bool CheckPropertyName(JsonReader reader, string memberName)
	{
		if (Serializer.MetadataPropertyHandling == MetadataPropertyHandling.ReadAhead)
		{
			switch (memberName)
			{
			case "$id":
			case "$ref":
			case "$type":
			case "$values":
				reader.Skip();
				return true;
			}
		}
		return false;
	}

	private void SetExtensionData(JsonObjectContract contract, JsonProperty member, JsonReader reader, string memberName, object o)
	{
		if (contract.ExtensionDataSetter != null)
		{
			try
			{
				object value = ReadExtensionDataValue(contract, member, reader);
				contract.ExtensionDataSetter(o, memberName, value);
				return;
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(reader, "Error setting value in extension data for type '{0}'.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType), ex);
			}
		}
		reader.Skip();
	}

	private object ReadExtensionDataValue(JsonObjectContract contract, JsonProperty member, JsonReader reader)
	{
		if (contract.ExtensionDataIsJToken)
		{
			return JToken.ReadFrom(reader);
		}
		return CreateValueInternal(reader, null, null, null, contract, member, null);
	}

	private void EndProcessProperty(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, JsonProperty property, PropertyPresence presence, bool setDefaultValue)
	{
		if (presence != 0 && presence != PropertyPresence.Null)
		{
			return;
		}
		try
		{
			Required required = property._required ?? contract.ItemRequired ?? Required.Default;
			switch (presence)
			{
			case PropertyPresence.None:
				if (required == Required.AllowNull || required == Required.Always)
				{
					throw JsonSerializationException.Create(reader, "Required property '{0}' not found in JSON.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName));
				}
				if (setDefaultValue && !property.Ignored)
				{
					if (property.PropertyContract == null)
					{
						property.PropertyContract = GetContractSafe(property.PropertyType);
					}
					if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate) && property.Writable)
					{
						property.ValueProvider.SetValue(newObject, EnsureType(reader, property.GetResolvedDefaultValue(), CultureInfo.InvariantCulture, property.PropertyContract, property.PropertyType));
					}
				}
				break;
			case PropertyPresence.Null:
				switch (required)
				{
				case Required.Always:
					throw JsonSerializationException.Create(reader, "Required property '{0}' expects a value but got null.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName));
				case Required.DisallowNull:
					throw JsonSerializationException.Create(reader, "Required property '{0}' expects a non-null value.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName));
				}
				break;
			}
		}
		catch (Exception ex)
		{
			if (IsErrorHandled(newObject, contract, property.PropertyName, reader as IJsonLineInfo, reader.Path, ex))
			{
				HandleError(reader, readPastError: true, initialDepth);
				return;
			}
			throw;
		}
	}

	private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary<JsonProperty, PropertyPresence> requiredProperties)
	{
		if (property != null && requiredProperties != null)
		{
			PropertyPresence value;
			switch (reader.TokenType)
			{
			case JsonToken.String:
				value = (CoerceEmptyStringToNull(property.PropertyType, property.PropertyContract, (string)reader.Value) ? PropertyPresence.Null : PropertyPresence.Value);
				break;
			case JsonToken.Null:
			case JsonToken.Undefined:
				value = PropertyPresence.Null;
				break;
			default:
				value = PropertyPresence.Value;
				break;
			}
			requiredProperties[property] = value;
		}
	}

	private void HandleError(JsonReader reader, bool readPastError, int initialDepth)
	{
		ClearErrorContext();
		if (readPastError)
		{
			reader.Skip();
			while (reader.Depth > initialDepth + 1 && reader.Read())
			{
			}
		}
	}
}


internal enum PropertyPresence
{
	None,
	Null,
	Value
}


internal class CreatorPropertyContext
{
	public string Name;

	public JsonProperty Property;

	public JsonProperty ConstructorProperty;

	public PropertyPresence? Presence;

	public object Value;

	public bool Used;
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class JsonSerializerInternalWriter : JsonSerializerInternalBase
{
	private Type _rootType;

	private int _rootLevel;

	private readonly List<object> _serializeStack = new List<object>();

	public JsonSerializerInternalWriter(JsonSerializer serializer)
		: base(serializer)
	{
	}

	public void Serialize(JsonWriter jsonWriter, object value, Type objectType)
	{
		if (jsonWriter == null)
		{
			throw new ArgumentNullException("jsonWriter");
		}
		_rootType = objectType;
		_rootLevel = _serializeStack.Count + 1;
		JsonContract contractSafe = GetContractSafe(value);
		try
		{
			if (ShouldWriteReference(value, null, contractSafe, null, null))
			{
				WriteReference(jsonWriter, value);
			}
			else
			{
				SerializeValue(jsonWriter, value, contractSafe, null, null, null);
			}
		}
		catch (Exception ex)
		{
			if (IsErrorHandled(null, contractSafe, null, null, jsonWriter.Path, ex))
			{
				HandleError(jsonWriter, 0);
				return;
			}
			ClearErrorContext();
			throw;
		}
		finally
		{
			_rootType = null;
		}
	}

	private JsonSerializerProxy GetInternalSerializer()
	{
		if (InternalSerializer == null)
		{
			InternalSerializer = new JsonSerializerProxy(this);
		}
		return InternalSerializer;
	}

	private JsonContract GetContractSafe(object value)
	{
		if (value == null)
		{
			return null;
		}
		return Serializer._contractResolver.ResolveContract(value.GetType());
	}

	private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
	{
		if (contract.TypeCode == PrimitiveTypeCode.Bytes && ShouldWriteType(TypeNameHandling.Objects, contract, member, containerContract, containerProperty))
		{
			writer.WriteStartObject();
			WriteTypeProperty(writer, contract.CreatedType);
			writer.WritePropertyName("$value", escape: false);
			JsonWriter.WriteValue(writer, contract.TypeCode, value);
			writer.WriteEndObject();
		}
		else
		{
			JsonWriter.WriteValue(writer, contract.TypeCode, value);
		}
	}

	private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
	{
		if (value == null)
		{
			writer.WriteNull();
			return;
		}
		JsonConverter jsonConverter = member?.Converter ?? containerProperty?.ItemConverter ?? containerContract?.ItemConverter ?? valueContract.Converter ?? Serializer.GetMatchingConverter(valueContract.UnderlyingType) ?? valueContract.InternalConverter;
		if (jsonConverter != null && jsonConverter.CanWrite)
		{
			SerializeConvertable(writer, jsonConverter, value, valueContract, containerContract, containerProperty);
			return;
		}
		switch (valueContract.ContractType)
		{
		case JsonContractType.Object:
			SerializeObject(writer, value, (JsonObjectContract)valueContract, member, containerContract, containerProperty);
			break;
		case JsonContractType.Array:
		{
			JsonArrayContract jsonArrayContract = (JsonArrayContract)valueContract;
			if (!jsonArrayContract.IsMultidimensionalArray)
			{
				SerializeList(writer, (IEnumerable)value, jsonArrayContract, member, containerContract, containerProperty);
			}
			else
			{
				SerializeMultidimensionalArray(writer, (Array)value, jsonArrayContract, member, containerContract, containerProperty);
			}
			break;
		}
		case JsonContractType.Primitive:
			SerializePrimitive(writer, value, (JsonPrimitiveContract)valueContract, member, containerContract, containerProperty);
			break;
		case JsonContractType.String:
			SerializeString(writer, value, (JsonStringContract)valueContract);
			break;
		case JsonContractType.Dictionary:
		{
			JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)valueContract;
			object values;
			if (!(value is IDictionary))
			{
				IDictionary dictionary = jsonDictionaryContract.CreateWrapper(value);
				values = dictionary;
			}
			else
			{
				values = (IDictionary)value;
			}
			SerializeDictionary(writer, (IDictionary)values, jsonDictionaryContract, member, containerContract, containerProperty);
			break;
		}
		case JsonContractType.Serializable:
			SerializeISerializable(writer, (ISerializable)value, (JsonISerializableContract)valueContract, member, containerContract, containerProperty);
			break;
		case JsonContractType.Linq:
			((JToken)value).WriteTo(writer, Serializer.Converters.ToArray());
			break;
		case JsonContractType.Dynamic:
			break;
		}
	}

	private bool? ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty)
	{
		bool? result = null;
		if (property != null)
		{
			result = property.IsReference;
		}
		if (!result.HasValue && containerProperty != null)
		{
			result = containerProperty.ItemIsReference;
		}
		if (!result.HasValue && collectionContract != null)
		{
			result = collectionContract.ItemIsReference;
		}
		if (!result.HasValue)
		{
			result = contract.IsReference;
		}
		return result;
	}

	private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty)
	{
		if (value == null)
		{
			return false;
		}
		if (valueContract.ContractType == JsonContractType.Primitive || valueContract.ContractType == JsonContractType.String)
		{
			return false;
		}
		bool? flag = ResolveIsReference(valueContract, property, collectionContract, containerProperty);
		if (!flag.HasValue)
		{
			flag = ((valueContract.ContractType != JsonContractType.Array) ? new bool?(HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Objects)) : new bool?(HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Arrays)));
		}
		if (flag != true)
		{
			return false;
		}
		return Serializer.GetReferenceResolver().IsReferenced(this, value);
	}

	private bool ShouldWriteProperty(object memberValue, JsonProperty property)
	{
		if (property.NullValueHandling.GetValueOrDefault(Serializer._nullValueHandling) == NullValueHandling.Ignore && memberValue == null)
		{
			return false;
		}
		if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && MiscellaneousUtils.ValueEquals(memberValue, property.GetResolvedDefaultValue()))
		{
			return false;
		}
		return true;
	}

	private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty)
	{
		if (value == null || contract.ContractType == JsonContractType.Primitive || contract.ContractType == JsonContractType.String)
		{
			return true;
		}
		ReferenceLoopHandling? referenceLoopHandling = null;
		if (property != null)
		{
			referenceLoopHandling = property.ReferenceLoopHandling;
		}
		if (!referenceLoopHandling.HasValue && containerProperty != null)
		{
			referenceLoopHandling = containerProperty.ItemReferenceLoopHandling;
		}
		if (!referenceLoopHandling.HasValue && containerContract != null)
		{
			referenceLoopHandling = containerContract.ItemReferenceLoopHandling;
		}
		if ((Serializer._equalityComparer != null) ? _serializeStack.Contains(value, Serializer._equalityComparer) : _serializeStack.Contains(value))
		{
			string text = "Self referencing loop detected";
			if (property != null)
			{
				text += " for property '{0}'".FormatWith(CultureInfo.InvariantCulture, property.PropertyName);
			}
			text += " with type '{0}'.".FormatWith(CultureInfo.InvariantCulture, value.GetType());
			switch (referenceLoopHandling.GetValueOrDefault(Serializer._referenceLoopHandling))
			{
			case ReferenceLoopHandling.Error:
				throw JsonSerializationException.Create(null, writer.ContainerPath, text, null);
			case ReferenceLoopHandling.Ignore:
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
				{
					TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, text + ". Skipping serializing self referenced value."), null);
				}
				return false;
			case ReferenceLoopHandling.Serialize:
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
				{
					TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, text + ". Serializing self referenced value."), null);
				}
				return true;
			}
		}
		return true;
	}

	private void WriteReference(JsonWriter writer, object value)
	{
		string reference = GetReference(writer, value);
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
		{
			TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Writing object reference to Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, reference, value.GetType())), null);
		}
		writer.WriteStartObject();
		writer.WritePropertyName("$ref", escape: false);
		writer.WriteValue(reference);
		writer.WriteEndObject();
	}

	private string GetReference(JsonWriter writer, object value)
	{
		try
		{
			return Serializer.GetReferenceResolver().GetReference(this, value);
		}
		catch (Exception ex)
		{
			throw JsonSerializationException.Create(null, writer.ContainerPath, "Error writing object reference for '{0}'.".FormatWith(CultureInfo.InvariantCulture, value.GetType()), ex);
		}
	}

	internal static bool TryConvertToString(object value, Type type, out string s)
	{
		TypeConverter converter = ConvertUtils.GetConverter(type);
		if (converter != null && !(converter is ComponentConverter) && (object)converter.GetType() != typeof(TypeConverter) && converter.CanConvertTo(typeof(string)))
		{
			s = converter.ConvertToInvariantString(value);
			return true;
		}
		if (value is Type)
		{
			s = ((Type)value).AssemblyQualifiedName;
			return true;
		}
		s = null;
		return false;
	}

	private void SerializeString(JsonWriter writer, object value, JsonStringContract contract)
	{
		OnSerializing(writer, contract, value);
		TryConvertToString(value, contract.UnderlyingType, out var s);
		writer.WriteValue(s);
		OnSerialized(writer, contract, value);
	}

	private void OnSerializing(JsonWriter writer, JsonContract contract, object value)
	{
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
		{
			TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Started serializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
		}
		contract.InvokeOnSerializing(value, Serializer._context);
	}

	private void OnSerialized(JsonWriter writer, JsonContract contract, object value)
	{
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
		{
			TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Finished serializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
		}
		contract.InvokeOnSerialized(value, Serializer._context);
	}

	private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
	{
		OnSerializing(writer, contract, value);
		_serializeStack.Add(value);
		WriteObjectStart(writer, value, contract, member, collectionContract, containerProperty);
		int top = writer.Top;
		for (int i = 0; i < contract.Properties.Count; i++)
		{
			JsonProperty jsonProperty = contract.Properties[i];
			try
			{
				if (CalculatePropertyValues(writer, value, contract, member, jsonProperty, out var memberContract, out var memberValue))
				{
					jsonProperty.WritePropertyName(writer);
					SerializeValue(writer, memberValue, memberContract, jsonProperty, contract, member);
				}
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(value, contract, jsonProperty.PropertyName, null, writer.ContainerPath, ex))
				{
					HandleError(writer, top);
					continue;
				}
				throw;
			}
		}
		if (contract.ExtensionDataGetter != null)
		{
			IEnumerable<KeyValuePair<object, object>> enumerable = contract.ExtensionDataGetter(value);
			if (enumerable != null)
			{
				foreach (KeyValuePair<object, object> item in enumerable)
				{
					JsonContract contractSafe = GetContractSafe(item.Key);
					JsonContract contractSafe2 = GetContractSafe(item.Value);
					bool escape;
					string propertyName = GetPropertyName(writer, item.Key, contractSafe, out escape);
					if (ShouldWriteReference(item.Value, null, contractSafe2, contract, member))
					{
						writer.WritePropertyName(propertyName);
						WriteReference(writer, item.Value);
					}
					else if (CheckForCircularReference(writer, item.Value, null, contractSafe2, contract, member))
					{
						writer.WritePropertyName(propertyName);
						SerializeValue(writer, item.Value, contractSafe2, null, contract, member);
					}
				}
			}
		}
		writer.WriteEndObject();
		_serializeStack.RemoveAt(_serializeStack.Count - 1);
		OnSerialized(writer, contract, value);
	}

	private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, out JsonContract memberContract, out object memberValue)
	{
		if (!property.Ignored && property.Readable && ShouldSerialize(writer, property, value) && IsSpecified(writer, property, value))
		{
			if (property.PropertyContract == null)
			{
				property.PropertyContract = Serializer._contractResolver.ResolveContract(property.PropertyType);
			}
			memberValue = property.ValueProvider.GetValue(value);
			memberContract = (property.PropertyContract.IsSealed ? property.PropertyContract : GetContractSafe(memberValue));
			if (ShouldWriteProperty(memberValue, property))
			{
				if (ShouldWriteReference(memberValue, property, memberContract, contract, member))
				{
					property.WritePropertyName(writer);
					WriteReference(writer, memberValue);
					return false;
				}
				if (!CheckForCircularReference(writer, memberValue, property, memberContract, contract, member))
				{
					return false;
				}
				if (memberValue == null)
				{
					JsonObjectContract jsonObjectContract = contract as JsonObjectContract;
					switch (property._required ?? jsonObjectContract?.ItemRequired ?? Required.Default)
					{
					case Required.Always:
						throw JsonSerializationException.Create(null, writer.ContainerPath, "Cannot write a null value for property '{0}'. Property requires a value.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName), null);
					case Required.DisallowNull:
						throw JsonSerializationException.Create(null, writer.ContainerPath, "Cannot write a null value for property '{0}'. Property requires a non-null value.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName), null);
					}
				}
				return true;
			}
		}
		memberContract = null;
		memberValue = null;
		return false;
	}

	private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
	{
		writer.WriteStartObject();
		if ((ResolveIsReference(contract, member, collectionContract, containerProperty) ?? HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Objects)) && (member == null || member.Writable))
		{
			WriteReferenceIdProperty(writer, contract.UnderlyingType, value);
		}
		if (ShouldWriteType(TypeNameHandling.Objects, contract, member, collectionContract, containerProperty))
		{
			WriteTypeProperty(writer, contract.UnderlyingType);
		}
	}

	private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value)
	{
		string reference = GetReference(writer, value);
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
		{
			TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "Writing object reference Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, reference, type)), null);
		}
		writer.WritePropertyName("$id", escape: false);
		writer.WriteValue(reference);
	}

	private void WriteTypeProperty(JsonWriter writer, Type type)
	{
		string typeName = ReflectionUtils.GetTypeName(type, Serializer._typeNameAssemblyFormat, Serializer._binder);
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
		{
			TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "Writing type name '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, typeName, type)), null);
		}
		writer.WritePropertyName("$type", escape: false);
		writer.WriteValue(typeName);
	}

	private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
	{
		return (value & flag) == flag;
	}

	private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag)
	{
		return (value & flag) == flag;
	}

	private bool HasFlag(TypeNameHandling value, TypeNameHandling flag)
	{
		return (value & flag) == flag;
	}

	private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty)
	{
		if (ShouldWriteReference(value, null, contract, collectionContract, containerProperty))
		{
			WriteReference(writer, value);
		}
		else if (CheckForCircularReference(writer, value, null, contract, collectionContract, containerProperty))
		{
			_serializeStack.Add(value);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Started serializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, value.GetType(), converter.GetType())), null);
			}
			converter.WriteJson(writer, value, GetInternalSerializer());
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Finished serializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, value.GetType(), converter.GetType())), null);
			}
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
		}
	}

	private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
	{
		object obj = ((values is IWrappedCollection wrappedCollection) ? wrappedCollection.UnderlyingCollection : values);
		OnSerializing(writer, contract, obj);
		_serializeStack.Add(obj);
		bool flag = WriteStartArray(writer, obj, contract, member, collectionContract, containerProperty);
		writer.WriteStartArray();
		int top = writer.Top;
		int num = 0;
		foreach (object value in values)
		{
			try
			{
				JsonContract jsonContract = contract.FinalItemContract ?? GetContractSafe(value);
				if (ShouldWriteReference(value, null, jsonContract, contract, member))
				{
					WriteReference(writer, value);
				}
				else if (CheckForCircularReference(writer, value, null, jsonContract, contract, member))
				{
					SerializeValue(writer, value, jsonContract, null, contract, member);
				}
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(obj, contract, num, null, writer.ContainerPath, ex))
				{
					HandleError(writer, top);
					continue;
				}
				throw;
			}
			finally
			{
				num++;
			}
		}
		writer.WriteEndArray();
		if (flag)
		{
			writer.WriteEndObject();
		}
		_serializeStack.RemoveAt(_serializeStack.Count - 1);
		OnSerialized(writer, contract, obj);
	}

	private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
	{
		OnSerializing(writer, contract, values);
		_serializeStack.Add(values);
		bool num = WriteStartArray(writer, values, contract, member, collectionContract, containerProperty);
		SerializeMultidimensionalArray(writer, values, contract, member, writer.Top, new int[0]);
		if (num)
		{
			writer.WriteEndObject();
		}
		_serializeStack.RemoveAt(_serializeStack.Count - 1);
		OnSerialized(writer, contract, values);
	}

	private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, int[] indices)
	{
		int num = indices.Length;
		int[] array = new int[num + 1];
		for (int i = 0; i < num; i++)
		{
			array[i] = indices[i];
		}
		writer.WriteStartArray();
		for (int j = values.GetLowerBound(num); j <= values.GetUpperBound(num); j++)
		{
			array[num] = j;
			if (array.Length == values.Rank)
			{
				object value = values.GetValue(array);
				try
				{
					JsonContract jsonContract = contract.FinalItemContract ?? GetContractSafe(value);
					if (ShouldWriteReference(value, null, jsonContract, contract, member))
					{
						WriteReference(writer, value);
					}
					else if (CheckForCircularReference(writer, value, null, jsonContract, contract, member))
					{
						SerializeValue(writer, value, jsonContract, null, contract, member);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(values, contract, j, null, writer.ContainerPath, ex))
					{
						HandleError(writer, initialDepth + 1);
						continue;
					}
					throw;
				}
			}
			else
			{
				SerializeMultidimensionalArray(writer, values, contract, member, initialDepth + 1, array);
			}
		}
		writer.WriteEndArray();
	}

	private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
	{
		bool flag = (ResolveIsReference(contract, member, containerContract, containerProperty) ?? HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Arrays)) && (member?.Writable ?? true);
		bool flag2 = ShouldWriteType(TypeNameHandling.Arrays, contract, member, containerContract, containerProperty);
		bool num = flag || flag2;
		if (num)
		{
			writer.WriteStartObject();
			if (flag)
			{
				WriteReferenceIdProperty(writer, contract.UnderlyingType, values);
			}
			if (flag2)
			{
				WriteTypeProperty(writer, values.GetType());
			}
			writer.WritePropertyName("$values", escape: false);
		}
		if (contract.ItemContract == null)
		{
			contract.ItemContract = Serializer._contractResolver.ResolveContract(contract.CollectionItemType ?? typeof(object));
		}
		return num;
	}

	private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
	{
		if (!JsonTypeReflector.FullyTrusted)
		{
			string format = "Type '{0}' implements ISerializable but cannot be serialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data." + Environment.NewLine + "To fix this error either change the environment to be fully trusted, change the application to not deserialize the type, add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true." + Environment.NewLine;
			format = format.FormatWith(CultureInfo.InvariantCulture, value.GetType());
			throw JsonSerializationException.Create(null, writer.ContainerPath, format, null);
		}
		OnSerializing(writer, contract, value);
		_serializeStack.Add(value);
		WriteObjectStart(writer, value, contract, member, collectionContract, containerProperty);
		SerializationInfo serializationInfo = new SerializationInfo(contract.UnderlyingType, new FormatterConverter());
		value.GetObjectData(serializationInfo, Serializer._context);
		SerializationInfoEnumerator enumerator = serializationInfo.GetEnumerator();
		while (enumerator.MoveNext())
		{
			SerializationEntry current = enumerator.Current;
			JsonContract contractSafe = GetContractSafe(current.Value);
			if (ShouldWriteReference(current.Value, null, contractSafe, contract, member))
			{
				writer.WritePropertyName(current.Name);
				WriteReference(writer, current.Value);
			}
			else if (CheckForCircularReference(writer, current.Value, null, contractSafe, contract, member))
			{
				writer.WritePropertyName(current.Name);
				SerializeValue(writer, current.Value, contractSafe, null, contract, member);
			}
		}
		writer.WriteEndObject();
		_serializeStack.RemoveAt(_serializeStack.Count - 1);
		OnSerialized(writer, contract, value);
	}

	private bool ShouldWriteDynamicProperty(object memberValue)
	{
		if (Serializer._nullValueHandling == NullValueHandling.Ignore && memberValue == null)
		{
			return false;
		}
		if (HasFlag(Serializer._defaultValueHandling, DefaultValueHandling.Ignore) && (memberValue == null || MiscellaneousUtils.ValueEquals(memberValue, ReflectionUtils.GetDefaultValue(memberValue.GetType()))))
		{
			return false;
		}
		return true;
	}

	private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
	{
		TypeNameHandling value = member?.TypeNameHandling ?? containerProperty?.ItemTypeNameHandling ?? containerContract?.ItemTypeNameHandling ?? Serializer._typeNameHandling;
		if (HasFlag(value, typeNameHandlingFlag))
		{
			return true;
		}
		if (HasFlag(value, TypeNameHandling.Auto))
		{
			if (member != null)
			{
				if ((object)contract.UnderlyingType != member.PropertyContract.CreatedType)
				{
					return true;
				}
			}
			else if (containerContract != null)
			{
				if (containerContract.ItemContract == null || (object)contract.UnderlyingType != containerContract.ItemContract.CreatedType)
				{
					return true;
				}
			}
			else if ((object)_rootType != null && _serializeStack.Count == _rootLevel)
			{
				JsonContract jsonContract = Serializer._contractResolver.ResolveContract(_rootType);
				if ((object)contract.UnderlyingType != jsonContract.CreatedType)
				{
					return true;
				}
			}
		}
		return false;
	}

	private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
	{
		object obj = ((values is IWrappedDictionary wrappedDictionary) ? wrappedDictionary.UnderlyingDictionary : values);
		OnSerializing(writer, contract, obj);
		_serializeStack.Add(obj);
		WriteObjectStart(writer, obj, contract, member, collectionContract, containerProperty);
		if (contract.ItemContract == null)
		{
			contract.ItemContract = Serializer._contractResolver.ResolveContract(contract.DictionaryValueType ?? typeof(object));
		}
		if (contract.KeyContract == null)
		{
			contract.KeyContract = Serializer._contractResolver.ResolveContract(contract.DictionaryKeyType ?? typeof(object));
		}
		int top = writer.Top;
		foreach (DictionaryEntry value2 in values)
		{
			string propertyName = GetPropertyName(writer, value2.Key, contract.KeyContract, out var escape);
			propertyName = ((contract.DictionaryKeyResolver != null) ? contract.DictionaryKeyResolver(propertyName) : propertyName);
			try
			{
				object value = value2.Value;
				JsonContract jsonContract = contract.FinalItemContract ?? GetContractSafe(value);
				if (ShouldWriteReference(value, null, jsonContract, contract, member))
				{
					writer.WritePropertyName(propertyName, escape);
					WriteReference(writer, value);
				}
				else if (CheckForCircularReference(writer, value, null, jsonContract, contract, member))
				{
					writer.WritePropertyName(propertyName, escape);
					SerializeValue(writer, value, jsonContract, null, contract, member);
				}
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(obj, contract, propertyName, null, writer.ContainerPath, ex))
				{
					HandleError(writer, top);
					continue;
				}
				throw;
			}
		}
		writer.WriteEndObject();
		_serializeStack.RemoveAt(_serializeStack.Count - 1);
		OnSerialized(writer, contract, obj);
	}

	private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, out bool escape)
	{
		if (contract.ContractType == JsonContractType.Primitive)
		{
			JsonPrimitiveContract jsonPrimitiveContract = (JsonPrimitiveContract)contract;
			if (jsonPrimitiveContract.TypeCode == PrimitiveTypeCode.DateTime || jsonPrimitiveContract.TypeCode == PrimitiveTypeCode.DateTimeNullable)
			{
				DateTime value = DateTimeUtils.EnsureDateTime((DateTime)name, writer.DateTimeZoneHandling);
				escape = false;
				StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
				DateTimeUtils.WriteDateTimeString(stringWriter, value, writer.DateFormatHandling, writer.DateFormatString, writer.Culture);
				return stringWriter.ToString();
			}
			if (jsonPrimitiveContract.TypeCode == PrimitiveTypeCode.DateTimeOffset || jsonPrimitiveContract.TypeCode == PrimitiveTypeCode.DateTimeOffsetNullable)
			{
				escape = false;
				StringWriter stringWriter2 = new StringWriter(CultureInfo.InvariantCulture);
				DateTimeUtils.WriteDateTimeOffsetString(stringWriter2, (DateTimeOffset)name, writer.DateFormatHandling, writer.DateFormatString, writer.Culture);
				return stringWriter2.ToString();
			}
			escape = true;
			return Convert.ToString(name, CultureInfo.InvariantCulture);
		}
		if (TryConvertToString(name, name.GetType(), out var s))
		{
			escape = true;
			return s;
		}
		escape = true;
		return name.ToString();
	}

	private void HandleError(JsonWriter writer, int initialDepth)
	{
		ClearErrorContext();
		if (writer.WriteState == WriteState.Property)
		{
			writer.WriteNull();
		}
		while (writer.Top > initialDepth)
		{
			writer.WriteEnd();
		}
	}

	private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target)
	{
		if (property.ShouldSerialize == null)
		{
			return true;
		}
		bool flag = property.ShouldSerialize(target);
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
		{
			TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "ShouldSerialize result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, flag)), null);
		}
		return flag;
	}

	private bool IsSpecified(JsonWriter writer, JsonProperty property, object target)
	{
		if (property.GetIsSpecified == null)
		{
			return true;
		}
		bool flag = property.GetIsSpecified(target);
		if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
		{
			TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "IsSpecified result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, flag)), null);
		}
		return flag;
	}
}


using System;
using System.Collections;
using System.Globalization;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class JsonSerializerProxy : JsonSerializer
{
	private readonly JsonSerializerInternalReader _serializerReader;

	private readonly JsonSerializerInternalWriter _serializerWriter;

	private readonly JsonSerializer _serializer;

	public override IReferenceResolver ReferenceResolver
	{
		get
		{
			return _serializer.ReferenceResolver;
		}
		set
		{
			_serializer.ReferenceResolver = value;
		}
	}

	public override ITraceWriter TraceWriter
	{
		get
		{
			return _serializer.TraceWriter;
		}
		set
		{
			_serializer.TraceWriter = value;
		}
	}

	public override IEqualityComparer EqualityComparer
	{
		get
		{
			return _serializer.EqualityComparer;
		}
		set
		{
			_serializer.EqualityComparer = value;
		}
	}

	public override JsonConverterCollection Converters => _serializer.Converters;

	public override DefaultValueHandling DefaultValueHandling
	{
		get
		{
			return _serializer.DefaultValueHandling;
		}
		set
		{
			_serializer.DefaultValueHandling = value;
		}
	}

	public override IContractResolver ContractResolver
	{
		get
		{
			return _serializer.ContractResolver;
		}
		set
		{
			_serializer.ContractResolver = value;
		}
	}

	public override MissingMemberHandling MissingMemberHandling
	{
		get
		{
			return _serializer.MissingMemberHandling;
		}
		set
		{
			_serializer.MissingMemberHandling = value;
		}
	}

	public override NullValueHandling NullValueHandling
	{
		get
		{
			return _serializer.NullValueHandling;
		}
		set
		{
			_serializer.NullValueHandling = value;
		}
	}

	public override ObjectCreationHandling ObjectCreationHandling
	{
		get
		{
			return _serializer.ObjectCreationHandling;
		}
		set
		{
			_serializer.ObjectCreationHandling = value;
		}
	}

	public override ReferenceLoopHandling ReferenceLoopHandling
	{
		get
		{
			return _serializer.ReferenceLoopHandling;
		}
		set
		{
			_serializer.ReferenceLoopHandling = value;
		}
	}

	public override PreserveReferencesHandling PreserveReferencesHandling
	{
		get
		{
			return _serializer.PreserveReferencesHandling;
		}
		set
		{
			_serializer.PreserveReferencesHandling = value;
		}
	}

	public override TypeNameHandling TypeNameHandling
	{
		get
		{
			return _serializer.TypeNameHandling;
		}
		set
		{
			_serializer.TypeNameHandling = value;
		}
	}

	public override MetadataPropertyHandling MetadataPropertyHandling
	{
		get
		{
			return _serializer.MetadataPropertyHandling;
		}
		set
		{
			_serializer.MetadataPropertyHandling = value;
		}
	}

	public override FormatterAssemblyStyle TypeNameAssemblyFormat
	{
		get
		{
			return _serializer.TypeNameAssemblyFormat;
		}
		set
		{
			_serializer.TypeNameAssemblyFormat = value;
		}
	}

	public override ConstructorHandling ConstructorHandling
	{
		get
		{
			return _serializer.ConstructorHandling;
		}
		set
		{
			_serializer.ConstructorHandling = value;
		}
	}

	public override SerializationBinder Binder
	{
		get
		{
			return _serializer.Binder;
		}
		set
		{
			_serializer.Binder = value;
		}
	}

	public override StreamingContext Context
	{
		get
		{
			return _serializer.Context;
		}
		set
		{
			_serializer.Context = value;
		}
	}

	public override Formatting Formatting
	{
		get
		{
			return _serializer.Formatting;
		}
		set
		{
			_serializer.Formatting = value;
		}
	}

	public override DateFormatHandling DateFormatHandling
	{
		get
		{
			return _serializer.DateFormatHandling;
		}
		set
		{
			_serializer.DateFormatHandling = value;
		}
	}

	public override DateTimeZoneHandling DateTimeZoneHandling
	{
		get
		{
			return _serializer.DateTimeZoneHandling;
		}
		set
		{
			_serializer.DateTimeZoneHandling = value;
		}
	}

	public override DateParseHandling DateParseHandling
	{
		get
		{
			return _serializer.DateParseHandling;
		}
		set
		{
			_serializer.DateParseHandling = value;
		}
	}

	public override FloatFormatHandling FloatFormatHandling
	{
		get
		{
			return _serializer.FloatFormatHandling;
		}
		set
		{
			_serializer.FloatFormatHandling = value;
		}
	}

	public override FloatParseHandling FloatParseHandling
	{
		get
		{
			return _serializer.FloatParseHandling;
		}
		set
		{
			_serializer.FloatParseHandling = value;
		}
	}

	public override StringEscapeHandling StringEscapeHandling
	{
		get
		{
			return _serializer.StringEscapeHandling;
		}
		set
		{
			_serializer.StringEscapeHandling = value;
		}
	}

	public override string DateFormatString
	{
		get
		{
			return _serializer.DateFormatString;
		}
		set
		{
			_serializer.DateFormatString = value;
		}
	}

	public override CultureInfo Culture
	{
		get
		{
			return _serializer.Culture;
		}
		set
		{
			_serializer.Culture = value;
		}
	}

	public override int? MaxDepth
	{
		get
		{
			return _serializer.MaxDepth;
		}
		set
		{
			_serializer.MaxDepth = value;
		}
	}

	public override bool CheckAdditionalContent
	{
		get
		{
			return _serializer.CheckAdditionalContent;
		}
		set
		{
			_serializer.CheckAdditionalContent = value;
		}
	}

	public override event EventHandler<ErrorEventArgs> Error
	{
		add
		{
			_serializer.Error += value;
		}
		remove
		{
			_serializer.Error -= value;
		}
	}

	internal JsonSerializerInternalBase GetInternalSerializer()
	{
		if (_serializerReader != null)
		{
			return _serializerReader;
		}
		return _serializerWriter;
	}

	public JsonSerializerProxy(JsonSerializerInternalReader serializerReader)
	{
		ValidationUtils.ArgumentNotNull(serializerReader, "serializerReader");
		_serializerReader = serializerReader;
		_serializer = serializerReader.Serializer;
	}

	public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter)
	{
		ValidationUtils.ArgumentNotNull(serializerWriter, "serializerWriter");
		_serializerWriter = serializerWriter;
		_serializer = serializerWriter.Serializer;
	}

	internal override object DeserializeInternal(JsonReader reader, Type objectType)
	{
		if (_serializerReader != null)
		{
			return _serializerReader.Deserialize(reader, objectType, checkAdditionalContent: false);
		}
		return _serializer.Deserialize(reader, objectType);
	}

	internal override void PopulateInternal(JsonReader reader, object target)
	{
		if (_serializerReader != null)
		{
			_serializerReader.Populate(reader, target);
		}
		else
		{
			_serializer.Populate(reader, target);
		}
	}

	internal override void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType)
	{
		if (_serializerWriter != null)
		{
			_serializerWriter.Serialize(jsonWriter, value, rootType);
		}
		else
		{
			_serializer.Serialize(jsonWriter, value);
		}
	}
}


using System;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;

[Preserve]
public class JsonStringContract : JsonPrimitiveContract
{
	public JsonStringContract(Type underlyingType)
		: base(underlyingType)
	{
		ContractType = JsonContractType.String;
	}
}


using System;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Security;
using System.Security.Permissions;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal static class JsonTypeReflector
{
	private static bool? _dynamicCodeGeneration;

	private static bool? _fullyTrusted;

	public const string IdPropertyName = "$id";

	public const string RefPropertyName = "$ref";

	public const string TypePropertyName = "$type";

	public const string ValuePropertyName = "$value";

	public const string ArrayValuesPropertyName = "$values";

	public const string ShouldSerializePrefix = "ShouldSerialize";

	public const string SpecifiedPostfix = "Specified";

	private static readonly ThreadSafeStore<Type, Func<object[], JsonConverter>> JsonConverterCreatorCache = new ThreadSafeStore<Type, Func<object[], JsonConverter>>(GetJsonConverterCreator);

	private static readonly ThreadSafeStore<Type, Type> AssociatedMetadataTypesCache = new ThreadSafeStore<Type, Type>(GetAssociateMetadataTypeFromAttribute);

	private static ReflectionObject _metadataTypeAttributeReflectionObject;

	public static bool DynamicCodeGeneration
	{
		get
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			if (!_dynamicCodeGeneration.HasValue)
			{
				try
				{
					((CodeAccessPermission)new ReflectionPermission((ReflectionPermissionFlag)2)).Demand();
					((CodeAccessPermission)new ReflectionPermission((ReflectionPermissionFlag)8)).Demand();
					((CodeAccessPermission)new SecurityPermission(SecurityPermissionFlag.SkipVerification)).Demand();
					((CodeAccessPermission)new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Demand();
					((CodeAccessPermission)new SecurityPermission(PermissionState.Unrestricted)).Demand();
					_dynamicCodeGeneration = true;
				}
				catch (Exception)
				{
					_dynamicCodeGeneration = false;
				}
			}
			return _dynamicCodeGeneration == true;
		}
	}

	public static bool FullyTrusted
	{
		get
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			if (!_fullyTrusted.HasValue)
			{
				try
				{
					((CodeAccessPermission)new SecurityPermission(PermissionState.Unrestricted)).Demand();
					_fullyTrusted = true;
				}
				catch (Exception)
				{
					_fullyTrusted = false;
				}
			}
			return _fullyTrusted == true;
		}
	}

	public static ReflectionDelegateFactory ReflectionDelegateFactory => LateBoundReflectionDelegateFactory.Instance;

	public static T GetCachedAttribute<T>(object attributeProvider) where T : Attribute
	{
		return CachedAttributeGetter<T>.GetAttribute(attributeProvider);
	}

	public static DataContractAttribute GetDataContractAttribute(Type type)
	{
		Type type2 = type;
		while ((object)type2 != null)
		{
			DataContractAttribute attribute = CachedAttributeGetter<DataContractAttribute>.GetAttribute(type2);
			if (attribute != null)
			{
				return attribute;
			}
			type2 = type2.BaseType();
		}
		return null;
	}

	public static DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo)
	{
		if (memberInfo.MemberType() == MemberTypes.Field)
		{
			return CachedAttributeGetter<DataMemberAttribute>.GetAttribute(memberInfo);
		}
		PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
		DataMemberAttribute attribute = CachedAttributeGetter<DataMemberAttribute>.GetAttribute(propertyInfo);
		if (attribute == null && propertyInfo.IsVirtual())
		{
			Type type = propertyInfo.DeclaringType;
			while (attribute == null && (object)type != null)
			{
				PropertyInfo propertyInfo2 = (PropertyInfo)ReflectionUtils.GetMemberInfoFromType(type, propertyInfo);
				if ((object)propertyInfo2 != null && propertyInfo2.IsVirtual())
				{
					attribute = CachedAttributeGetter<DataMemberAttribute>.GetAttribute(propertyInfo2);
				}
				type = type.BaseType();
			}
		}
		return attribute;
	}

	public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute)
	{
		JsonObjectAttribute cachedAttribute = GetCachedAttribute<JsonObjectAttribute>(objectType);
		if (cachedAttribute != null)
		{
			return cachedAttribute.MemberSerialization;
		}
		if (GetDataContractAttribute(objectType) != null)
		{
			return MemberSerialization.OptIn;
		}
		if (!ignoreSerializableAttribute && GetCachedAttribute<SerializableAttribute>(objectType) != null)
		{
			return MemberSerialization.Fields;
		}
		return MemberSerialization.OptOut;
	}

	public static JsonConverter GetJsonConverter(object attributeProvider)
	{
		JsonConverterAttribute cachedAttribute = GetCachedAttribute<JsonConverterAttribute>(attributeProvider);
		if (cachedAttribute != null)
		{
			Func<object[], JsonConverter> func = JsonConverterCreatorCache.Get(cachedAttribute.ConverterType);
			if (func != null)
			{
				return func(cachedAttribute.ConverterParameters);
			}
		}
		return null;
	}

	public static JsonConverter CreateJsonConverterInstance(Type converterType, object[] converterArgs)
	{
		return JsonConverterCreatorCache.Get(converterType)(converterArgs);
	}

	private static Func<object[], JsonConverter> GetJsonConverterCreator(Type converterType)
	{
		Func<object> defaultConstructor = (ReflectionUtils.HasDefaultConstructor(converterType, nonPublic: false) ? ReflectionDelegateFactory.CreateDefaultConstructor<object>(converterType) : null);
		return delegate(object[] parameters)
		{
			try
			{
				if (parameters != null)
				{
					Type[] types = parameters.Select((object param) => param.GetType()).ToArray();
					ConstructorInfo constructor = converterType.GetConstructor(types);
					if ((object)constructor == null)
					{
						throw new JsonException("No matching parameterized constructor found for '{0}'.".FormatWith(CultureInfo.InvariantCulture, converterType));
					}
					return (JsonConverter)ReflectionDelegateFactory.CreateParameterizedConstructor(constructor)(parameters);
				}
				if (defaultConstructor == null)
				{
					throw new JsonException("No parameterless constructor defined for '{0}'.".FormatWith(CultureInfo.InvariantCulture, converterType));
				}
				return (JsonConverter)defaultConstructor();
			}
			catch (Exception innerException)
			{
				throw new JsonException("Error creating '{0}'.".FormatWith(CultureInfo.InvariantCulture, converterType), innerException);
			}
		};
	}

	public static TypeConverter GetTypeConverter(Type type)
	{
		return TypeDescriptor.GetConverter(type);
	}

	private static Type GetAssociatedMetadataType(Type type)
	{
		return AssociatedMetadataTypesCache.Get(type);
	}

	private static Type GetAssociateMetadataTypeFromAttribute(Type type)
	{
		Attribute[] attributes = ReflectionUtils.GetAttributes(type, null, inherit: true);
		foreach (Attribute attribute in attributes)
		{
			Type type2 = attribute.GetType();
			if (string.Equals(type2.FullName, "System.ComponentModel.DataAnnotations.MetadataTypeAttribute", StringComparison.Ordinal))
			{
				if (_metadataTypeAttributeReflectionObject == null)
				{
					_metadataTypeAttributeReflectionObject = ReflectionObject.Create(type2, "MetadataClassType");
				}
				return (Type)_metadataTypeAttributeReflectionObject.GetValue(attribute, "MetadataClassType");
			}
		}
		return null;
	}

	private static T GetAttribute<T>(Type type) where T : Attribute
	{
		Type associatedMetadataType = GetAssociatedMetadataType(type);
		T attribute;
		if ((object)associatedMetadataType != null)
		{
			attribute = ReflectionUtils.GetAttribute<T>(associatedMetadataType, inherit: true);
			if (attribute != null)
			{
				return attribute;
			}
		}
		attribute = ReflectionUtils.GetAttribute<T>(type, inherit: true);
		if (attribute != null)
		{
			return attribute;
		}
		Type[] interfaces = type.GetInterfaces();
		for (int i = 0; i < interfaces.Length; i++)
		{
			attribute = ReflectionUtils.GetAttribute<T>(interfaces[i], inherit: true);
			if (attribute != null)
			{
				return attribute;
			}
		}
		return null;
	}

	private static T GetAttribute<T>(MemberInfo memberInfo) where T : Attribute
	{
		Type associatedMetadataType = GetAssociatedMetadataType(memberInfo.DeclaringType);
		T attribute;
		if ((object)associatedMetadataType != null)
		{
			MemberInfo memberInfoFromType = ReflectionUtils.GetMemberInfoFromType(associatedMetadataType, memberInfo);
			if ((object)memberInfoFromType != null)
			{
				attribute = ReflectionUtils.GetAttribute<T>(memberInfoFromType, inherit: true);
				if (attribute != null)
				{
					return attribute;
				}
			}
		}
		attribute = ReflectionUtils.GetAttribute<T>(memberInfo, inherit: true);
		if (attribute != null)
		{
			return attribute;
		}
		if ((object)memberInfo.DeclaringType != null)
		{
			Type[] interfaces = memberInfo.DeclaringType.GetInterfaces();
			for (int i = 0; i < interfaces.Length; i++)
			{
				MemberInfo memberInfoFromType2 = ReflectionUtils.GetMemberInfoFromType(interfaces[i], memberInfo);
				if ((object)memberInfoFromType2 != null)
				{
					attribute = ReflectionUtils.GetAttribute<T>(memberInfoFromType2, inherit: true);
					if (attribute != null)
					{
						return attribute;
					}
				}
			}
		}
		return null;
	}

	public static T GetAttribute<T>(object provider) where T : Attribute
	{
		if (provider is Type type)
		{
			return GetAttribute<T>(type);
		}
		if (provider is MemberInfo memberInfo)
		{
			return GetAttribute<T>(memberInfo);
		}
		return ReflectionUtils.GetAttribute<T>(provider, inherit: true);
	}
}


using System;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal static class CachedAttributeGetter<T> where T : Attribute
{
	private static readonly ThreadSafeStore<object, T> TypeAttributeCache = new ThreadSafeStore<object, T>(JsonTypeReflector.GetAttribute<T>);

	public static T GetAttribute(object type)
	{
		return TypeAttributeCache.Get(type);
	}
}


using System;
using System.Globalization;
using System.Reflection;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class ReflectionValueProvider : IValueProvider
{
	private readonly MemberInfo _memberInfo;

	public ReflectionValueProvider(MemberInfo memberInfo)
	{
		ValidationUtils.ArgumentNotNull(memberInfo, "memberInfo");
		_memberInfo = memberInfo;
	}

	public void SetValue(object target, object value)
	{
		try
		{
			ReflectionUtils.SetMemberValue(_memberInfo, target, value);
		}
		catch (Exception innerException)
		{
			throw new JsonSerializationException("Error setting value to '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), innerException);
		}
	}

	public object GetValue(object target)
	{
		try
		{
			return ReflectionUtils.GetMemberValue(_memberInfo, target);
		}
		catch (Exception innerException)
		{
			throw new JsonSerializationException("Error getting value from '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), innerException);
		}
	}
}


using System;
using Newtonsoft.Json.Shims;

[Preserve]
[AttributeUsage(AttributeTargets.Method, Inherited = false)]
public sealed class OnErrorAttribute : Attribute
{
}


using Newtonsoft.Json.Shims;

[Preserve]
public delegate object ObjectConstructor<T>(params object[] args);


using Newtonsoft.Json.Shims;

[Preserve]
public enum CommentHandling
{
	Ignore,
	Load
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum LineInfoHandling
{
	Ignore,
	Load
}


using System;
using System.ComponentModel;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;

[Preserve]
public class JPropertyDescriptor : PropertyDescriptor
{
	public override Type ComponentType => typeof(JObject);

	public override bool IsReadOnly => false;

	public override Type PropertyType => typeof(object);

	protected override int NameHashCode => base.NameHashCode;

	public JPropertyDescriptor(string name)
		: base(name, null)
	{
	}

	private static JObject CastInstance(object instance)
	{
		return (JObject)instance;
	}

	public override bool CanResetValue(object component)
	{
		return false;
	}

	public override object GetValue(object component)
	{
		return CastInstance(component)[Name];
	}

	public override void ResetValue(object component)
	{
	}

	public override void SetValue(object component, object value)
	{
		JToken value2 = ((value is JToken) ? ((JToken)value) : new JValue(value));
		CastInstance(component)[Name] = value2;
	}

	public override bool ShouldSerializeValue(object component)
	{
		return false;
	}
}


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class JPropertyKeyedCollection : Collection<JToken>
{
	private static readonly IEqualityComparer<string> Comparer = StringComparer.Ordinal;

	private Dictionary<string, JToken> _dictionary;

	public JToken this[string key]
	{
		get
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (_dictionary != null)
			{
				return _dictionary[key];
			}
			throw new KeyNotFoundException();
		}
	}

	public ICollection<string> Keys
	{
		get
		{
			EnsureDictionary();
			return _dictionary.Keys;
		}
	}

	public ICollection<JToken> Values
	{
		get
		{
			EnsureDictionary();
			return _dictionary.Values;
		}
	}

	public JPropertyKeyedCollection()
		: base((IList<JToken>)new List<JToken>())
	{
	}

	private void AddKey(string key, JToken item)
	{
		EnsureDictionary();
		_dictionary[key] = item;
	}

	protected void ChangeItemKey(JToken item, string newKey)
	{
		if (!ContainsItem(item))
		{
			throw new ArgumentException("The specified item does not exist in this KeyedCollection.");
		}
		string keyForItem = GetKeyForItem(item);
		if (!Comparer.Equals(keyForItem, newKey))
		{
			if (newKey != null)
			{
				AddKey(newKey, item);
			}
			if (keyForItem != null)
			{
				RemoveKey(keyForItem);
			}
		}
	}

	protected override void ClearItems()
	{
		base.ClearItems();
		if (_dictionary != null)
		{
			_dictionary.Clear();
		}
	}

	public bool Contains(string key)
	{
		if (key == null)
		{
			throw new ArgumentNullException("key");
		}
		if (_dictionary != null)
		{
			return _dictionary.ContainsKey(key);
		}
		return false;
	}

	private bool ContainsItem(JToken item)
	{
		if (_dictionary == null)
		{
			return false;
		}
		string keyForItem = GetKeyForItem(item);
		JToken value;
		return _dictionary.TryGetValue(keyForItem, out value);
	}

	private void EnsureDictionary()
	{
		if (_dictionary == null)
		{
			_dictionary = new Dictionary<string, JToken>(Comparer);
		}
	}

	private string GetKeyForItem(JToken item)
	{
		return ((JProperty)item).Name;
	}

	protected override void InsertItem(int index, JToken item)
	{
		AddKey(GetKeyForItem(item), item);
		base.InsertItem(index, item);
	}

	public bool Remove(string key)
	{
		if (key == null)
		{
			throw new ArgumentNullException("key");
		}
		if (_dictionary != null)
		{
			if (_dictionary.ContainsKey(key))
			{
				return Remove(_dictionary[key]);
			}
			return false;
		}
		return false;
	}

	protected override void RemoveItem(int index)
	{
		string keyForItem = GetKeyForItem(base.Items[index]);
		RemoveKey(keyForItem);
		base.RemoveItem(index);
	}

	private void RemoveKey(string key)
	{
		if (_dictionary != null)
		{
			_dictionary.Remove(key);
		}
	}

	protected override void SetItem(int index, JToken item)
	{
		string keyForItem = GetKeyForItem(item);
		string keyForItem2 = GetKeyForItem(base.Items[index]);
		if (Comparer.Equals(keyForItem2, keyForItem))
		{
			if (_dictionary != null)
			{
				_dictionary[keyForItem] = item;
			}
		}
		else
		{
			AddKey(keyForItem, item);
			if (keyForItem2 != null)
			{
				RemoveKey(keyForItem2);
			}
		}
		base.SetItem(index, item);
	}

	public bool TryGetValue(string key, out JToken value)
	{
		if (_dictionary == null)
		{
			value = null;
			return false;
		}
		return _dictionary.TryGetValue(key, out value);
	}

	public int IndexOfReference(JToken t)
	{
		return ((List<JToken>)base.Items).IndexOfReference(t);
	}

	public bool Compare(JPropertyKeyedCollection other)
	{
		if (this == other)
		{
			return true;
		}
		Dictionary<string, JToken> dictionary = _dictionary;
		Dictionary<string, JToken> dictionary2 = other._dictionary;
		if (dictionary == null && dictionary2 == null)
		{
			return true;
		}
		if (dictionary == null)
		{
			return dictionary2.Count == 0;
		}
		if (dictionary2 == null)
		{
			return dictionary.Count == 0;
		}
		if (dictionary.Count != dictionary2.Count)
		{
			return false;
		}
		foreach (KeyValuePair<string, JToken> item in dictionary)
		{
			if (!dictionary2.TryGetValue(item.Key, out var value))
			{
				return false;
			}
			JProperty jProperty = (JProperty)item.Value;
			JProperty jProperty2 = (JProperty)value;
			if (jProperty.Value == null)
			{
				return jProperty2.Value == null;
			}
			if (!jProperty.Value.DeepEquals(jProperty2.Value))
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;

[Preserve]
public class JsonLoadSettings
{
	private CommentHandling _commentHandling;

	private LineInfoHandling _lineInfoHandling;

	public CommentHandling CommentHandling
	{
		get
		{
			return _commentHandling;
		}
		set
		{
			if (value < CommentHandling.Ignore || value > CommentHandling.Load)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_commentHandling = value;
		}
	}

	public LineInfoHandling LineInfoHandling
	{
		get
		{
			return _lineInfoHandling;
		}
		set
		{
			if (value < LineInfoHandling.Ignore || value > LineInfoHandling.Load)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_lineInfoHandling = value;
		}
	}
}


using System;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;

[Preserve]
public class JsonMergeSettings
{
	private MergeArrayHandling _mergeArrayHandling;

	private MergeNullValueHandling _mergeNullValueHandling;

	public MergeArrayHandling MergeArrayHandling
	{
		get
		{
			return _mergeArrayHandling;
		}
		set
		{
			if (value < MergeArrayHandling.Concat || value > MergeArrayHandling.Merge)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_mergeArrayHandling = value;
		}
	}

	public MergeNullValueHandling MergeNullValueHandling
	{
		get
		{
			return _mergeNullValueHandling;
		}
		set
		{
			if (value < MergeNullValueHandling.Ignore || value > MergeNullValueHandling.Merge)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_mergeNullValueHandling = value;
		}
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum MergeArrayHandling
{
	Concat,
	Union,
	Replace,
	Merge
}


using System;
using Newtonsoft.Json.Shims;

[Flags]
[Preserve]
public enum MergeNullValueHandling
{
	Ignore = 0,
	Merge = 1
}


using System.Globalization;
using System.IO;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;

[Preserve]
public class JRaw : JValue
{
	public JRaw(JRaw other)
		: base(other)
	{
	}

	public JRaw(object rawJson)
		: base(rawJson, JTokenType.Raw)
	{
	}

	public static JRaw Create(JsonReader reader)
	{
		using StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
		using JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter);
		jsonTextWriter.WriteToken(reader);
		return new JRaw(stringWriter.ToString());
	}

	internal override JToken CloneToken()
	{
		return new JRaw(this);
	}
}


using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;

[Preserve]
public interface IJEnumerable<T> : IEnumerable<T>, IEnumerable where T : JToken
{
	IJEnumerable<JToken> this[object key] { get; }
}


using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;

[Preserve]
public class JTokenEqualityComparer : IEqualityComparer<JToken>
{
	public bool Equals(JToken x, JToken y)
	{
		return JToken.DeepEquals(x, y);
	}

	public int GetHashCode(JToken obj)
	{
		return obj?.GetDeepHashCode() ?? 0;
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public static class Extensions
{
	public static IJEnumerable<JToken> Ancestors<T>(this IEnumerable<T> source) where T : JToken
	{
		ValidationUtils.ArgumentNotNull(source, "source");
		return source.SelectMany((T j) => j.Ancestors()).AsJEnumerable();
	}

	public static IJEnumerable<JToken> AncestorsAndSelf<T>(this IEnumerable<T> source) where T : JToken
	{
		ValidationUtils.ArgumentNotNull(source, "source");
		return source.SelectMany((T j) => j.AncestorsAndSelf()).AsJEnumerable();
	}

	public static IJEnumerable<JToken> Descendants<T>(this IEnumerable<T> source) where T : JContainer
	{
		ValidationUtils.ArgumentNotNull(source, "source");
		return source.SelectMany((T j) => j.Descendants()).AsJEnumerable();
	}

	public static IJEnumerable<JToken> DescendantsAndSelf<T>(this IEnumerable<T> source) where T : JContainer
	{
		ValidationUtils.ArgumentNotNull(source, "source");
		return source.SelectMany((T j) => j.DescendantsAndSelf()).AsJEnumerable();
	}

	public static IJEnumerable<JProperty> Properties(this IEnumerable<JObject> source)
	{
		ValidationUtils.ArgumentNotNull(source, "source");
		return source.SelectMany((JObject d) => d.Properties()).AsJEnumerable();
	}

	public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source, object key)
	{
		return source.Values<JToken, JToken>(key).AsJEnumerable();
	}

	public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source)
	{
		return source.Values(null);
	}

	public static IEnumerable<U> Values<U>(this IEnumerable<JToken> source, object key)
	{
		return source.Values<JToken, U>(key);
	}

	public static IEnumerable<U> Values<U>(this IEnumerable<JToken> source)
	{
		return source.Values<JToken, U>(null);
	}

	public static U Value<U>(this IEnumerable<JToken> value)
	{
		return value.Value<JToken, U>();
	}

	public static U Value<T, U>(this IEnumerable<T> value) where T : JToken
	{
		ValidationUtils.ArgumentNotNull(value, "value");
		return ((value as JToken) ?? throw new ArgumentException("Source value must be a JToken.")).Convert<JToken, U>();
	}

	internal static IEnumerable<U> Values<T, U>(this IEnumerable<T> source, object key) where T : JToken
	{
		ValidationUtils.ArgumentNotNull(source, "source");
		foreach (T token in source)
		{
			if (key == null)
			{
				if (token is JValue)
				{
					yield return ((JValue)(object)token).Convert<JValue, U>();
					continue;
				}
				foreach (JToken item in token.Children())
				{
					yield return item.Convert<JToken, U>();
				}
			}
			else
			{
				JToken jToken = token[key];
				if (jToken != null)
				{
					yield return jToken.Convert<JToken, U>();
				}
			}
		}
	}

	public static IJEnumerable<JToken> Children<T>(this IEnumerable<T> source) where T : JToken
	{
		return source.Children<T, JToken>().AsJEnumerable();
	}

	public static IEnumerable<U> Children<T, U>(this IEnumerable<T> source) where T : JToken
	{
		ValidationUtils.ArgumentNotNull(source, "source");
		return source.SelectMany((T c) => c.Children()).Convert<JToken, U>();
	}

	internal static IEnumerable<U> Convert<T, U>(this IEnumerable<T> source) where T : JToken
	{
		ValidationUtils.ArgumentNotNull(source, "source");
		foreach (T item in source)
		{
			yield return item.Convert<JToken, U>();
		}
	}

	internal static U Convert<T, U>(this T token) where T : JToken
	{
		if (token == null)
		{
			return default(U);
		}
		if (token is U && (object)typeof(U) != typeof(IComparable) && (object)typeof(U) != typeof(IFormattable))
		{
			return (U)(object)token;
		}
		if (!(token is JValue jValue))
		{
			throw new InvalidCastException("Cannot cast {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, token.GetType(), typeof(T)));
		}
		if (jValue.Value is U)
		{
			return (U)jValue.Value;
		}
		Type type = typeof(U);
		if (ReflectionUtils.IsNullableType(type))
		{
			if (jValue.Value == null)
			{
				return default(U);
			}
			type = Nullable.GetUnderlyingType(type);
		}
		return (U)System.Convert.ChangeType(jValue.Value, type, CultureInfo.InvariantCulture);
	}

	public static IJEnumerable<JToken> AsJEnumerable(this IEnumerable<JToken> source)
	{
		return source.AsJEnumerable<JToken>();
	}

	public static IJEnumerable<T> AsJEnumerable<T>(this IEnumerable<T> source) where T : JToken
	{
		if (source == null)
		{
			return null;
		}
		if (source is IJEnumerable<T>)
		{
			return (IJEnumerable<T>)source;
		}
		return new JEnumerable<T>(source);
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JConstructor : JContainer
{
	private string _name;

	private readonly List<JToken> _values = new List<JToken>();

	protected override IList<JToken> ChildrenTokens => _values;

	public string Name
	{
		get
		{
			return _name;
		}
		set
		{
			_name = value;
		}
	}

	public override JTokenType Type => JTokenType.Constructor;

	public override JToken this[object key]
	{
		get
		{
			ValidationUtils.ArgumentNotNull(key, "key");
			if (!(key is int))
			{
				throw new ArgumentException("Accessed JConstructor values with invalid key value: {0}. Argument position index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
			}
			return GetItem((int)key);
		}
		set
		{
			ValidationUtils.ArgumentNotNull(key, "key");
			if (!(key is int))
			{
				throw new ArgumentException("Set JConstructor values with invalid key value: {0}. Argument position index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
			}
			SetItem((int)key, value);
		}
	}

	internal override int IndexOfItem(JToken item)
	{
		return _values.IndexOfReference(item);
	}

	internal override void MergeItem(object content, JsonMergeSettings settings)
	{
		if (content is JConstructor jConstructor)
		{
			if (jConstructor.Name != null)
			{
				Name = jConstructor.Name;
			}
			JContainer.MergeEnumerableContent(this, jConstructor, settings);
		}
	}

	public JConstructor()
	{
	}

	public JConstructor(JConstructor other)
		: base(other)
	{
		_name = other.Name;
	}

	public JConstructor(string name, params object[] content)
		: this(name, (object)content)
	{
	}

	public JConstructor(string name, object content)
		: this(name)
	{
		Add(content);
	}

	public JConstructor(string name)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		if (name.Length == 0)
		{
			throw new ArgumentException("Constructor name cannot be empty.", "name");
		}
		_name = name;
	}

	internal override bool DeepEquals(JToken node)
	{
		if (node is JConstructor jConstructor && _name == jConstructor.Name)
		{
			return ContentsEqual(jConstructor);
		}
		return false;
	}

	internal override JToken CloneToken()
	{
		return new JConstructor(this);
	}

	public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
	{
		writer.WriteStartConstructor(_name);
		foreach (JToken item in Children())
		{
			item.WriteTo(writer, converters);
		}
		writer.WriteEndConstructor();
	}

	internal override int GetDeepHashCode()
	{
		return _name.GetHashCode() ^ ContentsHashCode();
	}

	public new static JConstructor Load(JsonReader reader)
	{
		return Load(reader, null);
	}

	public new static JConstructor Load(JsonReader reader, JsonLoadSettings settings)
	{
		if (reader.TokenType == JsonToken.None && !reader.Read())
		{
			throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader.");
		}
		reader.MoveToContent();
		if (reader.TokenType != JsonToken.StartConstructor)
		{
			throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader. Current JsonReader item is not a constructor: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}
		JConstructor jConstructor = new JConstructor((string)reader.Value);
		jConstructor.SetLineInfo(reader as IJsonLineInfo, settings);
		jConstructor.ReadTokenFrom(reader, settings);
		return jConstructor;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Threading;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public abstract class JContainer : JToken, IList<JToken>, ICollection<JToken>, IEnumerable<JToken>, IEnumerable, ITypedList, IBindingList, IList, ICollection
{
	internal ListChangedEventHandler _listChanged;

	internal AddingNewEventHandler _addingNew;

	private object _syncRoot;

	private bool _busy;

	protected abstract IList<JToken> ChildrenTokens { get; }

	public override bool HasValues => ChildrenTokens.Count > 0;

	public override JToken First
	{
		get
		{
			IList<JToken> childrenTokens = ChildrenTokens;
			if (childrenTokens.Count <= 0)
			{
				return null;
			}
			return childrenTokens[0];
		}
	}

	public override JToken Last
	{
		get
		{
			IList<JToken> childrenTokens = ChildrenTokens;
			int count = childrenTokens.Count;
			if (count <= 0)
			{
				return null;
			}
			return childrenTokens[count - 1];
		}
	}

	JToken IList<JToken>.this[int index]
	{
		get
		{
			return GetItem(index);
		}
		set
		{
			SetItem(index, value);
		}
	}

	bool ICollection<JToken>.IsReadOnly => false;

	bool IList.IsFixedSize => false;

	bool IList.IsReadOnly => false;

	object IList.this[int index]
	{
		get
		{
			return GetItem(index);
		}
		set
		{
			SetItem(index, EnsureValue(value));
		}
	}

	public int Count => ChildrenTokens.Count;

	bool ICollection.IsSynchronized => false;

	object ICollection.SyncRoot
	{
		get
		{
			if (_syncRoot == null)
			{
				Interlocked.CompareExchange(ref _syncRoot, new object(), null);
			}
			return _syncRoot;
		}
	}

	bool IBindingList.AllowEdit => true;

	bool IBindingList.AllowNew => true;

	bool IBindingList.AllowRemove => true;

	bool IBindingList.IsSorted => false;

	ListSortDirection IBindingList.SortDirection => ListSortDirection.Ascending;

	PropertyDescriptor IBindingList.SortProperty => null;

	bool IBindingList.SupportsChangeNotification => true;

	bool IBindingList.SupportsSearching => false;

	bool IBindingList.SupportsSorting => false;

	public event ListChangedEventHandler ListChanged
	{
		add
		{
			_listChanged = (ListChangedEventHandler)Delegate.Combine(_listChanged, value);
		}
		remove
		{
			_listChanged = (ListChangedEventHandler)Delegate.Remove(_listChanged, value);
		}
	}

	public event AddingNewEventHandler AddingNew
	{
		add
		{
			_addingNew = (AddingNewEventHandler)Delegate.Combine(_addingNew, value);
		}
		remove
		{
			_addingNew = (AddingNewEventHandler)Delegate.Remove(_addingNew, value);
		}
	}

	internal JContainer()
	{
	}

	internal JContainer(JContainer other)
		: this()
	{
		ValidationUtils.ArgumentNotNull(other, "other");
		int num = 0;
		foreach (JToken item in (IEnumerable<JToken>)other)
		{
			AddInternal(num, item, skipParentCheck: false);
			num++;
		}
	}

	internal void CheckReentrancy()
	{
		if (_busy)
		{
			throw new InvalidOperationException("Cannot change {0} during a collection change event.".FormatWith(CultureInfo.InvariantCulture, GetType()));
		}
	}

	internal virtual IList<JToken> CreateChildrenCollection()
	{
		return new List<JToken>();
	}

	protected virtual void OnAddingNew(AddingNewEventArgs e)
	{
		_addingNew?.Invoke(this, e);
	}

	protected virtual void OnListChanged(ListChangedEventArgs e)
	{
		ListChangedEventHandler listChanged = _listChanged;
		if (listChanged != null)
		{
			_busy = true;
			try
			{
				listChanged(this, e);
			}
			finally
			{
				_busy = false;
			}
		}
	}

	internal bool ContentsEqual(JContainer container)
	{
		if (container == this)
		{
			return true;
		}
		IList<JToken> childrenTokens = ChildrenTokens;
		IList<JToken> childrenTokens2 = container.ChildrenTokens;
		if (childrenTokens.Count != childrenTokens2.Count)
		{
			return false;
		}
		for (int i = 0; i < childrenTokens.Count; i++)
		{
			if (!childrenTokens[i].DeepEquals(childrenTokens2[i]))
			{
				return false;
			}
		}
		return true;
	}

	public override JEnumerable<JToken> Children()
	{
		return new JEnumerable<JToken>(ChildrenTokens);
	}

	public override IEnumerable<T> Values<T>()
	{
		return ChildrenTokens.Convert<JToken, T>();
	}

	public IEnumerable<JToken> Descendants()
	{
		return GetDescendants(self: false);
	}

	public IEnumerable<JToken> DescendantsAndSelf()
	{
		return GetDescendants(self: true);
	}

	internal IEnumerable<JToken> GetDescendants(bool self)
	{
		if (self)
		{
			yield return this;
		}
		foreach (JToken o in ChildrenTokens)
		{
			yield return o;
			if (!(o is JContainer jContainer))
			{
				continue;
			}
			foreach (JToken item in jContainer.Descendants())
			{
				yield return item;
			}
		}
	}

	internal bool IsMultiContent(object content)
	{
		if (content is IEnumerable && !(content is string) && !(content is JToken))
		{
			return !(content is byte[]);
		}
		return false;
	}

	internal JToken EnsureParentToken(JToken item, bool skipParentCheck)
	{
		if (item == null)
		{
			return JValue.CreateNull();
		}
		if (skipParentCheck)
		{
			return item;
		}
		if (item.Parent != null || item == this || (item.HasValues && base.Root == item))
		{
			item = item.CloneToken();
		}
		return item;
	}

	internal abstract int IndexOfItem(JToken item);

	internal virtual void InsertItem(int index, JToken item, bool skipParentCheck)
	{
		IList<JToken> childrenTokens = ChildrenTokens;
		if (index > childrenTokens.Count)
		{
			throw new ArgumentOutOfRangeException("index", "Index must be within the bounds of the List.");
		}
		CheckReentrancy();
		item = EnsureParentToken(item, skipParentCheck);
		JToken jToken = ((index == 0) ? null : childrenTokens[index - 1]);
		JToken jToken2 = ((index == childrenTokens.Count) ? null : childrenTokens[index]);
		ValidateToken(item, null);
		item.Parent = this;
		item.Previous = jToken;
		if (jToken != null)
		{
			jToken.Next = item;
		}
		item.Next = jToken2;
		if (jToken2 != null)
		{
			jToken2.Previous = item;
		}
		childrenTokens.Insert(index, item);
		if (_listChanged != null)
		{
			OnListChanged(new ListChangedEventArgs(ListChangedType.ItemAdded, index));
		}
	}

	internal virtual void RemoveItemAt(int index)
	{
		IList<JToken> childrenTokens = ChildrenTokens;
		if (index < 0)
		{
			throw new ArgumentOutOfRangeException("index", "Index is less than 0.");
		}
		if (index >= childrenTokens.Count)
		{
			throw new ArgumentOutOfRangeException("index", "Index is equal to or greater than Count.");
		}
		CheckReentrancy();
		JToken jToken = childrenTokens[index];
		JToken jToken2 = ((index == 0) ? null : childrenTokens[index - 1]);
		JToken jToken3 = ((index == childrenTokens.Count - 1) ? null : childrenTokens[index + 1]);
		if (jToken2 != null)
		{
			jToken2.Next = jToken3;
		}
		if (jToken3 != null)
		{
			jToken3.Previous = jToken2;
		}
		jToken.Parent = null;
		jToken.Previous = null;
		jToken.Next = null;
		childrenTokens.RemoveAt(index);
		if (_listChanged != null)
		{
			OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, index));
		}
	}

	internal virtual bool RemoveItem(JToken item)
	{
		int num = IndexOfItem(item);
		if (num >= 0)
		{
			RemoveItemAt(num);
			return true;
		}
		return false;
	}

	internal virtual JToken GetItem(int index)
	{
		return ChildrenTokens[index];
	}

	internal virtual void SetItem(int index, JToken item)
	{
		IList<JToken> childrenTokens = ChildrenTokens;
		if (index < 0)
		{
			throw new ArgumentOutOfRangeException("index", "Index is less than 0.");
		}
		if (index >= childrenTokens.Count)
		{
			throw new ArgumentOutOfRangeException("index", "Index is equal to or greater than Count.");
		}
		JToken jToken = childrenTokens[index];
		if (!IsTokenUnchanged(jToken, item))
		{
			CheckReentrancy();
			item = EnsureParentToken(item, skipParentCheck: false);
			ValidateToken(item, jToken);
			JToken jToken2 = ((index == 0) ? null : childrenTokens[index - 1]);
			JToken jToken3 = ((index == childrenTokens.Count - 1) ? null : childrenTokens[index + 1]);
			item.Parent = this;
			item.Previous = jToken2;
			if (jToken2 != null)
			{
				jToken2.Next = item;
			}
			item.Next = jToken3;
			if (jToken3 != null)
			{
				jToken3.Previous = item;
			}
			childrenTokens[index] = item;
			jToken.Parent = null;
			jToken.Previous = null;
			jToken.Next = null;
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, index));
			}
		}
	}

	internal virtual void ClearItems()
	{
		CheckReentrancy();
		IList<JToken> childrenTokens = ChildrenTokens;
		foreach (JToken item in childrenTokens)
		{
			item.Parent = null;
			item.Previous = null;
			item.Next = null;
		}
		childrenTokens.Clear();
		if (_listChanged != null)
		{
			OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));
		}
	}

	internal virtual void ReplaceItem(JToken existing, JToken replacement)
	{
		if (existing != null && existing.Parent == this)
		{
			int index = IndexOfItem(existing);
			SetItem(index, replacement);
		}
	}

	internal virtual bool ContainsItem(JToken item)
	{
		return IndexOfItem(item) != -1;
	}

	internal virtual void CopyItemsTo(Array array, int arrayIndex)
	{
		if (array == null)
		{
			throw new ArgumentNullException("array");
		}
		if (arrayIndex < 0)
		{
			throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex is less than 0.");
		}
		if (arrayIndex >= array.Length && arrayIndex != 0)
		{
			throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
		}
		if (Count > array.Length - arrayIndex)
		{
			throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");
		}
		int num = 0;
		foreach (JToken childrenToken in ChildrenTokens)
		{
			array.SetValue(childrenToken, arrayIndex + num);
			num++;
		}
	}

	internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue)
	{
		if (currentValue is JValue jValue)
		{
			if (jValue.Type == JTokenType.Null && newValue == null)
			{
				return true;
			}
			return jValue.Equals(newValue);
		}
		return false;
	}

	internal virtual void ValidateToken(JToken o, JToken existing)
	{
		ValidationUtils.ArgumentNotNull(o, "o");
		if (o.Type == JTokenType.Property)
		{
			throw new ArgumentException("Can not add {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, o.GetType(), GetType()));
		}
	}

	public virtual void Add(object content)
	{
		AddInternal(ChildrenTokens.Count, content, skipParentCheck: false);
	}

	internal void AddAndSkipParentCheck(JToken token)
	{
		AddInternal(ChildrenTokens.Count, token, skipParentCheck: true);
	}

	public void AddFirst(object content)
	{
		AddInternal(0, content, skipParentCheck: false);
	}

	internal void AddInternal(int index, object content, bool skipParentCheck)
	{
		if (IsMultiContent(content))
		{
			IEnumerable obj = (IEnumerable)content;
			int num = index;
			{
				foreach (object item2 in obj)
				{
					AddInternal(num, item2, skipParentCheck);
					num++;
				}
				return;
			}
		}
		JToken item = CreateFromContent(content);
		InsertItem(index, item, skipParentCheck);
	}

	internal static JToken CreateFromContent(object content)
	{
		if (content is JToken result)
		{
			return result;
		}
		return new JValue(content);
	}

	public JsonWriter CreateWriter()
	{
		return new JTokenWriter(this);
	}

	public void ReplaceAll(object content)
	{
		ClearItems();
		Add(content);
	}

	public void RemoveAll()
	{
		ClearItems();
	}

	internal abstract void MergeItem(object content, JsonMergeSettings settings);

	public void Merge(object content)
	{
		MergeItem(content, new JsonMergeSettings());
	}

	public void Merge(object content, JsonMergeSettings settings)
	{
		MergeItem(content, settings);
	}

	internal void ReadTokenFrom(JsonReader reader, JsonLoadSettings options)
	{
		int depth = reader.Depth;
		if (!reader.Read())
		{
			throw JsonReaderException.Create(reader, "Error reading {0} from JsonReader.".FormatWith(CultureInfo.InvariantCulture, GetType().Name));
		}
		ReadContentFrom(reader, options);
		if (reader.Depth > depth)
		{
			throw JsonReaderException.Create(reader, "Unexpected end of content while loading {0}.".FormatWith(CultureInfo.InvariantCulture, GetType().Name));
		}
	}

	internal void ReadContentFrom(JsonReader r, JsonLoadSettings settings)
	{
		ValidationUtils.ArgumentNotNull(r, "r");
		IJsonLineInfo lineInfo = r as IJsonLineInfo;
		JContainer jContainer = this;
		do
		{
			if ((jContainer as JProperty)?.Value != null)
			{
				if (jContainer == this)
				{
					break;
				}
				jContainer = jContainer.Parent;
			}
			switch (r.TokenType)
			{
			case JsonToken.StartArray:
			{
				JArray jArray = new JArray();
				jArray.SetLineInfo(lineInfo, settings);
				jContainer.Add(jArray);
				jContainer = jArray;
				break;
			}
			case JsonToken.EndArray:
				if (jContainer == this)
				{
					return;
				}
				jContainer = jContainer.Parent;
				break;
			case JsonToken.StartObject:
			{
				JObject jObject = new JObject();
				jObject.SetLineInfo(lineInfo, settings);
				jContainer.Add(jObject);
				jContainer = jObject;
				break;
			}
			case JsonToken.EndObject:
				if (jContainer == this)
				{
					return;
				}
				jContainer = jContainer.Parent;
				break;
			case JsonToken.StartConstructor:
			{
				JConstructor jConstructor = new JConstructor(r.Value.ToString());
				jConstructor.SetLineInfo(lineInfo, settings);
				jContainer.Add(jConstructor);
				jContainer = jConstructor;
				break;
			}
			case JsonToken.EndConstructor:
				if (jContainer == this)
				{
					return;
				}
				jContainer = jContainer.Parent;
				break;
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Date:
			case JsonToken.Bytes:
			{
				JValue jValue = new JValue(r.Value);
				jValue.SetLineInfo(lineInfo, settings);
				jContainer.Add(jValue);
				break;
			}
			case JsonToken.Comment:
				if (settings != null && settings.CommentHandling == CommentHandling.Load)
				{
					JValue jValue = JValue.CreateComment(r.Value.ToString());
					jValue.SetLineInfo(lineInfo, settings);
					jContainer.Add(jValue);
				}
				break;
			case JsonToken.Null:
			{
				JValue jValue = JValue.CreateNull();
				jValue.SetLineInfo(lineInfo, settings);
				jContainer.Add(jValue);
				break;
			}
			case JsonToken.Undefined:
			{
				JValue jValue = JValue.CreateUndefined();
				jValue.SetLineInfo(lineInfo, settings);
				jContainer.Add(jValue);
				break;
			}
			case JsonToken.PropertyName:
			{
				string name = r.Value.ToString();
				JProperty jProperty = new JProperty(name);
				jProperty.SetLineInfo(lineInfo, settings);
				JProperty jProperty2 = ((JObject)jContainer).Property(name);
				if (jProperty2 == null)
				{
					jContainer.Add(jProperty);
				}
				else
				{
					jProperty2.Replace(jProperty);
				}
				jContainer = jProperty;
				break;
			}
			default:
				throw new InvalidOperationException("The JsonReader should not be on a token of type {0}.".FormatWith(CultureInfo.InvariantCulture, r.TokenType));
			case JsonToken.None:
				break;
			}
		}
		while (r.Read());
	}

	internal int ContentsHashCode()
	{
		int num = 0;
		foreach (JToken childrenToken in ChildrenTokens)
		{
			num ^= childrenToken.GetDeepHashCode();
		}
		return num;
	}

	string ITypedList.GetListName(PropertyDescriptor[] listAccessors)
	{
		return string.Empty;
	}

	PropertyDescriptorCollection ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors)
	{
		return (First as ICustomTypeDescriptor)?.GetProperties();
	}

	int IList<JToken>.IndexOf(JToken item)
	{
		return IndexOfItem(item);
	}

	void IList<JToken>.Insert(int index, JToken item)
	{
		InsertItem(index, item, skipParentCheck: false);
	}

	void IList<JToken>.RemoveAt(int index)
	{
		RemoveItemAt(index);
	}

	void ICollection<JToken>.Add(JToken item)
	{
		Add(item);
	}

	void ICollection<JToken>.Clear()
	{
		ClearItems();
	}

	bool ICollection<JToken>.Contains(JToken item)
	{
		return ContainsItem(item);
	}

	void ICollection<JToken>.CopyTo(JToken[] array, int arrayIndex)
	{
		CopyItemsTo(array, arrayIndex);
	}

	bool ICollection<JToken>.Remove(JToken item)
	{
		return RemoveItem(item);
	}

	private JToken EnsureValue(object value)
	{
		if (value == null)
		{
			return null;
		}
		if (value is JToken result)
		{
			return result;
		}
		throw new ArgumentException("Argument is not a JToken.");
	}

	int IList.Add(object value)
	{
		Add(EnsureValue(value));
		return Count - 1;
	}

	void IList.Clear()
	{
		ClearItems();
	}

	bool IList.Contains(object value)
	{
		return ContainsItem(EnsureValue(value));
	}

	int IList.IndexOf(object value)
	{
		return IndexOfItem(EnsureValue(value));
	}

	void IList.Insert(int index, object value)
	{
		InsertItem(index, EnsureValue(value), skipParentCheck: false);
	}

	void IList.Remove(object value)
	{
		RemoveItem(EnsureValue(value));
	}

	void IList.RemoveAt(int index)
	{
		RemoveItemAt(index);
	}

	void ICollection.CopyTo(Array array, int index)
	{
		CopyItemsTo(array, index);
	}

	void IBindingList.AddIndex(PropertyDescriptor property)
	{
	}

	object IBindingList.AddNew()
	{
		AddingNewEventArgs addingNewEventArgs = new AddingNewEventArgs();
		OnAddingNew(addingNewEventArgs);
		if (addingNewEventArgs.NewObject == null)
		{
			throw new JsonException("Could not determine new value to add to '{0}'.".FormatWith(CultureInfo.InvariantCulture, GetType()));
		}
		if (!(addingNewEventArgs.NewObject is JToken))
		{
			throw new JsonException("New item to be added to collection must be compatible with {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JToken)));
		}
		JToken jToken = (JToken)addingNewEventArgs.NewObject;
		Add(jToken);
		return jToken;
	}

	void IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction)
	{
		throw new NotSupportedException();
	}

	int IBindingList.Find(PropertyDescriptor property, object key)
	{
		throw new NotSupportedException();
	}

	void IBindingList.RemoveIndex(PropertyDescriptor property)
	{
	}

	void IBindingList.RemoveSort()
	{
		throw new NotSupportedException();
	}

	internal static void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings settings)
	{
		switch (settings.MergeArrayHandling)
		{
		case MergeArrayHandling.Concat:
		{
			foreach (JToken item in content)
			{
				target.Add(item);
			}
			break;
		}
		case MergeArrayHandling.Union:
		{
			HashSet<JToken> hashSet = new HashSet<JToken>(target, JToken.EqualityComparer);
			{
				foreach (JToken item2 in content)
				{
					if (hashSet.Add(item2))
					{
						target.Add(item2);
					}
				}
				break;
			}
		}
		case MergeArrayHandling.Replace:
			target.ClearItems();
			{
				foreach (JToken item3 in content)
				{
					target.Add(item3);
				}
				break;
			}
		case MergeArrayHandling.Merge:
		{
			int num = 0;
			{
				foreach (object item4 in content)
				{
					if (num < target.Count)
					{
						if (target[num] is JContainer jContainer)
						{
							jContainer.Merge(item4, settings);
						}
						else if (item4 != null)
						{
							JToken jToken = CreateFromContent(item4);
							if (jToken.Type != JTokenType.Null)
							{
								target[num] = jToken;
							}
						}
					}
					else
					{
						target.Add(item4);
					}
					num++;
				}
				break;
			}
		}
		default:
			throw new ArgumentOutOfRangeException("settings", "Unexpected merge array handling when merging JSON.");
		}
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public struct JEnumerable<T> : IJEnumerable<T>, IEnumerable<T>, IEnumerable where T : JToken
{
	public static readonly JEnumerable<T> Empty = new JEnumerable<T>(Enumerable.Empty<T>());

	private readonly IEnumerable<T> _enumerable;

	public IJEnumerable<JToken> this[object key]
	{
		get
		{
			if (_enumerable == null)
			{
				return JEnumerable<JToken>.Empty;
			}
			return new JEnumerable<JToken>(_enumerable.Values<T, JToken>(key));
		}
	}

	public JEnumerable(IEnumerable<T> enumerable)
	{
		ValidationUtils.ArgumentNotNull(enumerable, "enumerable");
		_enumerable = enumerable;
	}

	public IEnumerator<T> GetEnumerator()
	{
		if (_enumerable == null)
		{
			return Empty.GetEnumerator();
		}
		return _enumerable.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public bool Equals(JEnumerable<T> other)
	{
		return object.Equals(_enumerable, other._enumerable);
	}

	public override bool Equals(object obj)
	{
		if (obj is JEnumerable<T>)
		{
			return Equals((JEnumerable<T>)obj);
		}
		return false;
	}

	public override int GetHashCode()
	{
		if (_enumerable == null)
		{
			return 0;
		}
		return _enumerable.GetHashCode();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JObject : JContainer, IDictionary<string, JToken>, ICollection<KeyValuePair<string, JToken>>, IEnumerable<KeyValuePair<string, JToken>>, IEnumerable, INotifyPropertyChanged, ICustomTypeDescriptor, INotifyPropertyChanging
{
	private readonly JPropertyKeyedCollection _properties = new JPropertyKeyedCollection();

	protected override IList<JToken> ChildrenTokens => _properties;

	public override JTokenType Type => JTokenType.Object;

	public override JToken this[object key]
	{
		get
		{
			ValidationUtils.ArgumentNotNull(key, "key");
			if (!(key is string propertyName))
			{
				throw new ArgumentException("Accessed JObject values with invalid key value: {0}. Object property name expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
			}
			return this[propertyName];
		}
		set
		{
			ValidationUtils.ArgumentNotNull(key, "key");
			if (!(key is string propertyName))
			{
				throw new ArgumentException("Set JObject values with invalid key value: {0}. Object property name expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
			}
			this[propertyName] = value;
		}
	}

	public JToken this[string propertyName]
	{
		get
		{
			ValidationUtils.ArgumentNotNull(propertyName, "propertyName");
			return Property(propertyName)?.Value;
		}
		set
		{
			JProperty jProperty = Property(propertyName);
			if (jProperty != null)
			{
				jProperty.Value = value;
				return;
			}
			OnPropertyChanging(propertyName);
			Add(new JProperty(propertyName, value));
			OnPropertyChanged(propertyName);
		}
	}

	ICollection<string> IDictionary<string, JToken>.Keys => _properties.Keys;

	ICollection<JToken> IDictionary<string, JToken>.Values
	{
		get
		{
			throw new NotImplementedException();
		}
	}

	bool ICollection<KeyValuePair<string, JToken>>.IsReadOnly => false;

	public event PropertyChangedEventHandler PropertyChanged;

	public event PropertyChangingEventHandler PropertyChanging;

	public JObject()
	{
	}

	public JObject(JObject other)
		: base(other)
	{
	}

	public JObject(params object[] content)
		: this((object)content)
	{
	}

	public JObject(object content)
	{
		Add(content);
	}

	internal override bool DeepEquals(JToken node)
	{
		if (!(node is JObject jObject))
		{
			return false;
		}
		return _properties.Compare(jObject._properties);
	}

	internal override int IndexOfItem(JToken item)
	{
		return _properties.IndexOfReference(item);
	}

	internal override void InsertItem(int index, JToken item, bool skipParentCheck)
	{
		if (item == null || item.Type != JTokenType.Comment)
		{
			base.InsertItem(index, item, skipParentCheck);
		}
	}

	internal override void ValidateToken(JToken o, JToken existing)
	{
		ValidationUtils.ArgumentNotNull(o, "o");
		if (o.Type != JTokenType.Property)
		{
			throw new ArgumentException("Can not add {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, o.GetType(), GetType()));
		}
		JProperty jProperty = (JProperty)o;
		if (existing != null)
		{
			JProperty jProperty2 = (JProperty)existing;
			if (jProperty.Name == jProperty2.Name)
			{
				return;
			}
		}
		if (_properties.TryGetValue(jProperty.Name, out existing))
		{
			throw new ArgumentException("Can not add property {0} to {1}. Property with the same name already exists on object.".FormatWith(CultureInfo.InvariantCulture, jProperty.Name, GetType()));
		}
	}

	internal override void MergeItem(object content, JsonMergeSettings settings)
	{
		if (!(content is JObject jObject))
		{
			return;
		}
		foreach (KeyValuePair<string, JToken> item in jObject)
		{
			JProperty jProperty = Property(item.Key);
			if (jProperty == null)
			{
				Add(item.Key, item.Value);
			}
			else
			{
				if (item.Value == null)
				{
					continue;
				}
				if (!(jProperty.Value is JContainer jContainer))
				{
					if (item.Value.Type != JTokenType.Null || (settings != null && settings.MergeNullValueHandling == MergeNullValueHandling.Merge))
					{
						jProperty.Value = item.Value;
					}
				}
				else if (jContainer.Type != item.Value.Type)
				{
					jProperty.Value = item.Value;
				}
				else
				{
					jContainer.Merge(item.Value, settings);
				}
			}
		}
	}

	internal void InternalPropertyChanged(JProperty childProperty)
	{
		OnPropertyChanged(childProperty.Name);
		if (_listChanged != null)
		{
			OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, IndexOfItem(childProperty)));
		}
	}

	internal void InternalPropertyChanging(JProperty childProperty)
	{
		OnPropertyChanging(childProperty.Name);
	}

	internal override JToken CloneToken()
	{
		return new JObject(this);
	}

	public IEnumerable<JProperty> Properties()
	{
		return _properties.Cast<JProperty>();
	}

	public JProperty Property(string name)
	{
		if (name == null)
		{
			return null;
		}
		_properties.TryGetValue(name, out var value);
		return (JProperty)value;
	}

	public JEnumerable<JToken> PropertyValues()
	{
		return new JEnumerable<JToken>(from p in Properties()
			select p.Value);
	}

	public new static JObject Load(JsonReader reader)
	{
		return Load(reader, null);
	}

	public new static JObject Load(JsonReader reader, JsonLoadSettings settings)
	{
		ValidationUtils.ArgumentNotNull(reader, "reader");
		if (reader.TokenType == JsonToken.None && !reader.Read())
		{
			throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader.");
		}
		reader.MoveToContent();
		if (reader.TokenType != JsonToken.StartObject)
		{
			throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader. Current JsonReader item is not an object: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}
		JObject jObject = new JObject();
		jObject.SetLineInfo(reader as IJsonLineInfo, settings);
		jObject.ReadTokenFrom(reader, settings);
		return jObject;
	}

	public new static JObject Parse(string json)
	{
		return Parse(json, null);
	}

	public new static JObject Parse(string json, JsonLoadSettings settings)
	{
		using JsonReader jsonReader = new JsonTextReader(new StringReader(json));
		JObject result = Load(jsonReader, settings);
		if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
		{
			throw JsonReaderException.Create(jsonReader, "Additional text found in JSON string after parsing content.");
		}
		return result;
	}

	public new static JObject FromObject(object o)
	{
		return FromObject(o, JsonSerializer.CreateDefault());
	}

	public new static JObject FromObject(object o, JsonSerializer jsonSerializer)
	{
		JToken jToken = JToken.FromObjectInternal(o, jsonSerializer);
		if (jToken != null && jToken.Type != JTokenType.Object)
		{
			throw new ArgumentException("Object serialized to {0}. JObject instance expected.".FormatWith(CultureInfo.InvariantCulture, jToken.Type));
		}
		return (JObject)jToken;
	}

	public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
	{
		writer.WriteStartObject();
		for (int i = 0; i < _properties.Count; i++)
		{
			_properties[i].WriteTo(writer, converters);
		}
		writer.WriteEndObject();
	}

	public JToken GetValue(string propertyName)
	{
		return GetValue(propertyName, StringComparison.Ordinal);
	}

	public JToken GetValue(string propertyName, StringComparison comparison)
	{
		if (propertyName == null)
		{
			return null;
		}
		JProperty jProperty = Property(propertyName);
		if (jProperty != null)
		{
			return jProperty.Value;
		}
		if (comparison != StringComparison.Ordinal)
		{
			foreach (JProperty property in _properties)
			{
				if (string.Equals(property.Name, propertyName, comparison))
				{
					return property.Value;
				}
			}
		}
		return null;
	}

	public bool TryGetValue(string propertyName, StringComparison comparison, out JToken value)
	{
		value = GetValue(propertyName, comparison);
		return value != null;
	}

	public void Add(string propertyName, JToken value)
	{
		Add(new JProperty(propertyName, value));
	}

	bool IDictionary<string, JToken>.ContainsKey(string key)
	{
		return _properties.Contains(key);
	}

	public bool Remove(string propertyName)
	{
		JProperty jProperty = Property(propertyName);
		if (jProperty == null)
		{
			return false;
		}
		jProperty.Remove();
		return true;
	}

	public bool TryGetValue(string propertyName, out JToken value)
	{
		JProperty jProperty = Property(propertyName);
		if (jProperty == null)
		{
			value = null;
			return false;
		}
		value = jProperty.Value;
		return true;
	}

	void ICollection<KeyValuePair<string, JToken>>.Add(KeyValuePair<string, JToken> item)
	{
		Add(new JProperty(item.Key, item.Value));
	}

	void ICollection<KeyValuePair<string, JToken>>.Clear()
	{
		RemoveAll();
	}

	bool ICollection<KeyValuePair<string, JToken>>.Contains(KeyValuePair<string, JToken> item)
	{
		JProperty jProperty = Property(item.Key);
		if (jProperty == null)
		{
			return false;
		}
		return jProperty.Value == item.Value;
	}

	void ICollection<KeyValuePair<string, JToken>>.CopyTo(KeyValuePair<string, JToken>[] array, int arrayIndex)
	{
		if (array == null)
		{
			throw new ArgumentNullException("array");
		}
		if (arrayIndex < 0)
		{
			throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex is less than 0.");
		}
		if (arrayIndex >= array.Length && arrayIndex != 0)
		{
			throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
		}
		if (base.Count > array.Length - arrayIndex)
		{
			throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");
		}
		int num = 0;
		foreach (JProperty property in _properties)
		{
			array[arrayIndex + num] = new KeyValuePair<string, JToken>(property.Name, property.Value);
			num++;
		}
	}

	bool ICollection<KeyValuePair<string, JToken>>.Remove(KeyValuePair<string, JToken> item)
	{
		if (!((ICollection<KeyValuePair<string, JToken>>)this).Contains(item))
		{
			return false;
		}
		((IDictionary<string, JToken>)this).Remove(item.Key);
		return true;
	}

	internal override int GetDeepHashCode()
	{
		return ContentsHashCode();
	}

	public IEnumerator<KeyValuePair<string, JToken>> GetEnumerator()
	{
		foreach (JProperty property in _properties)
		{
			yield return new KeyValuePair<string, JToken>(property.Name, property.Value);
		}
	}

	protected virtual void OnPropertyChanged(string propertyName)
	{
		if (this.PropertyChanged != null)
		{
			this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
		}
	}

	protected virtual void OnPropertyChanging(string propertyName)
	{
		if (this.PropertyChanging != null)
		{
			this.PropertyChanging(this, new PropertyChangingEventArgs(propertyName));
		}
	}

	PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties()
	{
		return ((ICustomTypeDescriptor)this).GetProperties((Attribute[]?)null);
	}

	PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes)
	{
		PropertyDescriptorCollection propertyDescriptorCollection = new PropertyDescriptorCollection(null);
		using IEnumerator<KeyValuePair<string, JToken>> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			propertyDescriptorCollection.Add(new JPropertyDescriptor(enumerator.Current.Key));
		}
		return propertyDescriptorCollection;
	}

	AttributeCollection ICustomTypeDescriptor.GetAttributes()
	{
		return AttributeCollection.Empty;
	}

	string ICustomTypeDescriptor.GetClassName()
	{
		return null;
	}

	string ICustomTypeDescriptor.GetComponentName()
	{
		return null;
	}

	TypeConverter ICustomTypeDescriptor.GetConverter()
	{
		return new TypeConverter();
	}

	EventDescriptor ICustomTypeDescriptor.GetDefaultEvent()
	{
		return null;
	}

	PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty()
	{
		return null;
	}

	object ICustomTypeDescriptor.GetEditor(Type editorBaseType)
	{
		return null;
	}

	EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes)
	{
		return EventDescriptorCollection.Empty;
	}

	EventDescriptorCollection ICustomTypeDescriptor.GetEvents()
	{
		return EventDescriptorCollection.Empty;
	}

	object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd)
	{
		return null;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JArray : JContainer, IList<JToken>, ICollection<JToken>, IEnumerable<JToken>, IEnumerable
{
	private readonly List<JToken> _values = new List<JToken>();

	protected override IList<JToken> ChildrenTokens => _values;

	public override JTokenType Type => JTokenType.Array;

	public override JToken this[object key]
	{
		get
		{
			ValidationUtils.ArgumentNotNull(key, "key");
			if (!(key is int))
			{
				throw new ArgumentException("Accessed JArray values with invalid key value: {0}. Int32 array index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
			}
			return GetItem((int)key);
		}
		set
		{
			ValidationUtils.ArgumentNotNull(key, "key");
			if (!(key is int))
			{
				throw new ArgumentException("Set JArray values with invalid key value: {0}. Int32 array index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
			}
			SetItem((int)key, value);
		}
	}

	public JToken this[int index]
	{
		get
		{
			return GetItem(index);
		}
		set
		{
			SetItem(index, value);
		}
	}

	public bool IsReadOnly => false;

	public JArray()
	{
	}

	public JArray(JArray other)
		: base(other)
	{
	}

	public JArray(params object[] content)
		: this((object)content)
	{
	}

	public JArray(object content)
	{
		Add(content);
	}

	internal override bool DeepEquals(JToken node)
	{
		if (node is JArray container)
		{
			return ContentsEqual(container);
		}
		return false;
	}

	internal override JToken CloneToken()
	{
		return new JArray(this);
	}

	public new static JArray Load(JsonReader reader)
	{
		return Load(reader, null);
	}

	public new static JArray Load(JsonReader reader, JsonLoadSettings settings)
	{
		if (reader.TokenType == JsonToken.None && !reader.Read())
		{
			throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader.");
		}
		reader.MoveToContent();
		if (reader.TokenType != JsonToken.StartArray)
		{
			throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader. Current JsonReader item is not an array: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}
		JArray jArray = new JArray();
		jArray.SetLineInfo(reader as IJsonLineInfo, settings);
		jArray.ReadTokenFrom(reader, settings);
		return jArray;
	}

	public new static JArray Parse(string json)
	{
		return Parse(json, null);
	}

	public new static JArray Parse(string json, JsonLoadSettings settings)
	{
		using JsonReader jsonReader = new JsonTextReader(new StringReader(json));
		JArray result = Load(jsonReader, settings);
		if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
		{
			throw JsonReaderException.Create(jsonReader, "Additional text found in JSON string after parsing content.");
		}
		return result;
	}

	public new static JArray FromObject(object o)
	{
		return FromObject(o, JsonSerializer.CreateDefault());
	}

	public new static JArray FromObject(object o, JsonSerializer jsonSerializer)
	{
		JToken jToken = JToken.FromObjectInternal(o, jsonSerializer);
		if (jToken.Type != JTokenType.Array)
		{
			throw new ArgumentException("Object serialized to {0}. JArray instance expected.".FormatWith(CultureInfo.InvariantCulture, jToken.Type));
		}
		return (JArray)jToken;
	}

	public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
	{
		writer.WriteStartArray();
		for (int i = 0; i < _values.Count; i++)
		{
			_values[i].WriteTo(writer, converters);
		}
		writer.WriteEndArray();
	}

	internal override int IndexOfItem(JToken item)
	{
		return _values.IndexOfReference(item);
	}

	internal override void MergeItem(object content, JsonMergeSettings settings)
	{
		IEnumerable enumerable = ((IsMultiContent(content) || content is JArray) ? ((IEnumerable)content) : null);
		if (enumerable != null)
		{
			JContainer.MergeEnumerableContent(this, enumerable, settings);
		}
	}

	public int IndexOf(JToken item)
	{
		return IndexOfItem(item);
	}

	public void Insert(int index, JToken item)
	{
		InsertItem(index, item, skipParentCheck: false);
	}

	public void RemoveAt(int index)
	{
		RemoveItemAt(index);
	}

	public IEnumerator<JToken> GetEnumerator()
	{
		return Children().GetEnumerator();
	}

	public void Add(JToken item)
	{
		Add((object)item);
	}

	public void Clear()
	{
		ClearItems();
	}

	public bool Contains(JToken item)
	{
		return ContainsItem(item);
	}

	public void CopyTo(JToken[] array, int arrayIndex)
	{
		CopyItemsTo(array, arrayIndex);
	}

	public bool Remove(JToken item)
	{
		return RemoveItem(item);
	}

	internal override int GetDeepHashCode()
	{
		return ContentsHashCode();
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JTokenReader : JsonReader, IJsonLineInfo
{
	private readonly JToken _root;

	private string _initialPath;

	private JToken _parent;

	private JToken _current;

	public JToken CurrentToken => _current;

	int IJsonLineInfo.LineNumber
	{
		get
		{
			if (base.CurrentState == State.Start)
			{
				return 0;
			}
			return ((IJsonLineInfo)_current)?.LineNumber ?? 0;
		}
	}

	int IJsonLineInfo.LinePosition
	{
		get
		{
			if (base.CurrentState == State.Start)
			{
				return 0;
			}
			return ((IJsonLineInfo)_current)?.LinePosition ?? 0;
		}
	}

	public override string Path
	{
		get
		{
			string text = base.Path;
			if (_initialPath == null)
			{
				_initialPath = _root.Path;
			}
			if (!string.IsNullOrEmpty(_initialPath))
			{
				if (string.IsNullOrEmpty(text))
				{
					return _initialPath;
				}
				text = ((!StringUtils.StartsWith(text, '[')) ? (_initialPath + "." + text) : (_initialPath + text));
			}
			return text;
		}
	}

	public JTokenReader(JToken token)
	{
		ValidationUtils.ArgumentNotNull(token, "token");
		_root = token;
	}

	internal JTokenReader(JToken token, string initialPath)
		: this(token)
	{
		_initialPath = initialPath;
	}

	public override bool Read()
	{
		if (base.CurrentState != 0)
		{
			if (_current == null)
			{
				return false;
			}
			if (_current is JContainer jContainer && _parent != jContainer)
			{
				return ReadInto(jContainer);
			}
			return ReadOver(_current);
		}
		_current = _root;
		SetToken(_current);
		return true;
	}

	private bool ReadOver(JToken t)
	{
		if (t == _root)
		{
			return ReadToEnd();
		}
		JToken next = t.Next;
		if (next == null || next == t || t == t.Parent.Last)
		{
			if (t.Parent == null)
			{
				return ReadToEnd();
			}
			return SetEnd(t.Parent);
		}
		_current = next;
		SetToken(_current);
		return true;
	}

	private bool ReadToEnd()
	{
		_current = null;
		SetToken(JsonToken.None);
		return false;
	}

	private JsonToken? GetEndToken(JContainer c)
	{
		return c.Type switch
		{
			JTokenType.Object => JsonToken.EndObject, 
			JTokenType.Array => JsonToken.EndArray, 
			JTokenType.Constructor => JsonToken.EndConstructor, 
			JTokenType.Property => null, 
			_ => throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", c.Type, "Unexpected JContainer type."), 
		};
	}

	private bool ReadInto(JContainer c)
	{
		JToken first = c.First;
		if (first == null)
		{
			return SetEnd(c);
		}
		SetToken(first);
		_current = first;
		_parent = c;
		return true;
	}

	private bool SetEnd(JContainer c)
	{
		JsonToken? endToken = GetEndToken(c);
		if (endToken.HasValue)
		{
			SetToken(endToken.GetValueOrDefault());
			_current = c;
			_parent = c;
			return true;
		}
		return ReadOver(c);
	}

	private void SetToken(JToken token)
	{
		switch (token.Type)
		{
		case JTokenType.Object:
			SetToken(JsonToken.StartObject);
			break;
		case JTokenType.Array:
			SetToken(JsonToken.StartArray);
			break;
		case JTokenType.Constructor:
			SetToken(JsonToken.StartConstructor, ((JConstructor)token).Name);
			break;
		case JTokenType.Property:
			SetToken(JsonToken.PropertyName, ((JProperty)token).Name);
			break;
		case JTokenType.Comment:
			SetToken(JsonToken.Comment, ((JValue)token).Value);
			break;
		case JTokenType.Integer:
			SetToken(JsonToken.Integer, ((JValue)token).Value);
			break;
		case JTokenType.Float:
			SetToken(JsonToken.Float, ((JValue)token).Value);
			break;
		case JTokenType.String:
			SetToken(JsonToken.String, ((JValue)token).Value);
			break;
		case JTokenType.Boolean:
			SetToken(JsonToken.Boolean, ((JValue)token).Value);
			break;
		case JTokenType.Null:
			SetToken(JsonToken.Null, ((JValue)token).Value);
			break;
		case JTokenType.Undefined:
			SetToken(JsonToken.Undefined, ((JValue)token).Value);
			break;
		case JTokenType.Date:
			SetToken(JsonToken.Date, ((JValue)token).Value);
			break;
		case JTokenType.Raw:
			SetToken(JsonToken.Raw, ((JValue)token).Value);
			break;
		case JTokenType.Bytes:
			SetToken(JsonToken.Bytes, ((JValue)token).Value);
			break;
		case JTokenType.Guid:
			SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
			break;
		case JTokenType.Uri:
		{
			object value = ((JValue)token).Value;
			if (value is Uri)
			{
				SetToken(JsonToken.String, ((Uri)value).OriginalString);
			}
			else
			{
				SetToken(JsonToken.String, SafeToString(value));
			}
			break;
		}
		case JTokenType.TimeSpan:
			SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
			break;
		default:
			throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", token.Type, "Unexpected JTokenType.");
		}
	}

	private string SafeToString(object value)
	{
		return value?.ToString();
	}

	bool IJsonLineInfo.HasLineInfo()
	{
		if (base.CurrentState == State.Start)
		{
			return false;
		}
		return ((IJsonLineInfo)_current)?.HasLineInfo() ?? false;
	}
}


using System;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JTokenWriter : JsonWriter
{
	private JContainer _token;

	private JContainer _parent;

	private JValue _value;

	private JToken _current;

	public JToken CurrentToken => _current;

	public JToken Token
	{
		get
		{
			if (_token != null)
			{
				return _token;
			}
			return _value;
		}
	}

	public JTokenWriter(JContainer container)
	{
		ValidationUtils.ArgumentNotNull(container, "container");
		_token = container;
		_parent = container;
	}

	public JTokenWriter()
	{
	}

	public override void Flush()
	{
	}

	public override void Close()
	{
		base.Close();
	}

	public override void WriteStartObject()
	{
		base.WriteStartObject();
		AddParent(new JObject());
	}

	private void AddParent(JContainer container)
	{
		if (_parent == null)
		{
			_token = container;
		}
		else
		{
			_parent.AddAndSkipParentCheck(container);
		}
		_parent = container;
		_current = container;
	}

	private void RemoveParent()
	{
		_current = _parent;
		_parent = _parent.Parent;
		if (_parent != null && _parent.Type == JTokenType.Property)
		{
			_parent = _parent.Parent;
		}
	}

	public override void WriteStartArray()
	{
		base.WriteStartArray();
		AddParent(new JArray());
	}

	public override void WriteStartConstructor(string name)
	{
		base.WriteStartConstructor(name);
		AddParent(new JConstructor(name));
	}

	protected override void WriteEnd(JsonToken token)
	{
		RemoveParent();
	}

	public override void WritePropertyName(string name)
	{
		if (_parent is JObject jObject)
		{
			jObject.Remove(name);
		}
		AddParent(new JProperty(name));
		base.WritePropertyName(name);
	}

	private void AddValue(object value, JsonToken token)
	{
		AddValue(new JValue(value), token);
	}

	internal void AddValue(JValue value, JsonToken token)
	{
		if (_parent != null)
		{
			_parent.Add(value);
			_current = _parent.Last;
			if (_parent.Type == JTokenType.Property)
			{
				_parent = _parent.Parent;
			}
		}
		else
		{
			_value = value ?? JValue.CreateNull();
			_current = _value;
		}
	}

	public override void WriteValue(object value)
	{
		base.WriteValue(value);
	}

	public override void WriteNull()
	{
		base.WriteNull();
		AddValue(null, JsonToken.Null);
	}

	public override void WriteUndefined()
	{
		base.WriteUndefined();
		AddValue(null, JsonToken.Undefined);
	}

	public override void WriteRaw(string json)
	{
		base.WriteRaw(json);
		AddValue(new JRaw(json), JsonToken.Raw);
	}

	public override void WriteComment(string text)
	{
		base.WriteComment(text);
		AddValue(JValue.CreateComment(text), JsonToken.Comment);
	}

	public override void WriteValue(string value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.String);
	}

	public override void WriteValue(int value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Integer);
	}

	[CLSCompliant(false)]
	public override void WriteValue(uint value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Integer);
	}

	public override void WriteValue(long value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Integer);
	}

	[CLSCompliant(false)]
	public override void WriteValue(ulong value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Integer);
	}

	public override void WriteValue(float value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Float);
	}

	public override void WriteValue(double value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Float);
	}

	public override void WriteValue(bool value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Boolean);
	}

	public override void WriteValue(short value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Integer);
	}

	[CLSCompliant(false)]
	public override void WriteValue(ushort value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Integer);
	}

	public override void WriteValue(char value)
	{
		base.WriteValue(value);
		string text = null;
		text = value.ToString(CultureInfo.InvariantCulture);
		AddValue(text, JsonToken.String);
	}

	public override void WriteValue(byte value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Integer);
	}

	[CLSCompliant(false)]
	public override void WriteValue(sbyte value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Integer);
	}

	public override void WriteValue(decimal value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Float);
	}

	public override void WriteValue(DateTime value)
	{
		base.WriteValue(value);
		value = DateTimeUtils.EnsureDateTime(value, base.DateTimeZoneHandling);
		AddValue(value, JsonToken.Date);
	}

	public override void WriteValue(DateTimeOffset value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Date);
	}

	public override void WriteValue(byte[] value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.Bytes);
	}

	public override void WriteValue(TimeSpan value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.String);
	}

	public override void WriteValue(Guid value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.String);
	}

	public override void WriteValue(Uri value)
	{
		base.WriteValue(value);
		AddValue(value, JsonToken.String);
	}

	internal override void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments)
	{
		JTokenReader jTokenReader = reader as JTokenReader;
		if (jTokenReader != null && writeChildren && writeDateConstructorAsDate && writeComments)
		{
			if (jTokenReader.TokenType == JsonToken.None && !jTokenReader.Read())
			{
				return;
			}
			JToken jToken = jTokenReader.CurrentToken.CloneToken();
			if (_parent != null)
			{
				_parent.Add(jToken);
				_current = _parent.Last;
				if (_parent.Type == JTokenType.Property)
				{
					_parent = _parent.Parent;
					InternalWriteValue(JsonToken.Null);
				}
			}
			else
			{
				_current = jToken;
				if (_token == null && _value == null)
				{
					_token = jToken as JContainer;
					_value = jToken as JValue;
				}
			}
			jTokenReader.Skip();
		}
		else
		{
			base.WriteToken(reader, writeChildren, writeDateConstructorAsDate, writeComments);
		}
	}
}


