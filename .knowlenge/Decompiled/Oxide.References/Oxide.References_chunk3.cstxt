using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public abstract class JToken : IJEnumerable<JToken>, IEnumerable<JToken>, IEnumerable, IJsonLineInfo, ICloneable
{
	private class LineInfoAnnotation
	{
		internal readonly int LineNumber;

		internal readonly int LinePosition;

		public LineInfoAnnotation(int lineNumber, int linePosition)
		{
			LineNumber = lineNumber;
			LinePosition = linePosition;
		}
	}

	private static JTokenEqualityComparer _equalityComparer;

	private JContainer _parent;

	private JToken _previous;

	private JToken _next;

	private object _annotations;

	private static readonly JTokenType[] BooleanTypes = new JTokenType[6]
	{
		JTokenType.Integer,
		JTokenType.Float,
		JTokenType.String,
		JTokenType.Comment,
		JTokenType.Raw,
		JTokenType.Boolean
	};

	private static readonly JTokenType[] NumberTypes = new JTokenType[6]
	{
		JTokenType.Integer,
		JTokenType.Float,
		JTokenType.String,
		JTokenType.Comment,
		JTokenType.Raw,
		JTokenType.Boolean
	};

	private static readonly JTokenType[] StringTypes = new JTokenType[11]
	{
		JTokenType.Date,
		JTokenType.Integer,
		JTokenType.Float,
		JTokenType.String,
		JTokenType.Comment,
		JTokenType.Raw,
		JTokenType.Boolean,
		JTokenType.Bytes,
		JTokenType.Guid,
		JTokenType.TimeSpan,
		JTokenType.Uri
	};

	private static readonly JTokenType[] GuidTypes = new JTokenType[5]
	{
		JTokenType.String,
		JTokenType.Comment,
		JTokenType.Raw,
		JTokenType.Guid,
		JTokenType.Bytes
	};

	private static readonly JTokenType[] TimeSpanTypes = new JTokenType[4]
	{
		JTokenType.String,
		JTokenType.Comment,
		JTokenType.Raw,
		JTokenType.TimeSpan
	};

	private static readonly JTokenType[] UriTypes = new JTokenType[4]
	{
		JTokenType.String,
		JTokenType.Comment,
		JTokenType.Raw,
		JTokenType.Uri
	};

	private static readonly JTokenType[] CharTypes = new JTokenType[5]
	{
		JTokenType.Integer,
		JTokenType.Float,
		JTokenType.String,
		JTokenType.Comment,
		JTokenType.Raw
	};

	private static readonly JTokenType[] DateTimeTypes = new JTokenType[4]
	{
		JTokenType.Date,
		JTokenType.String,
		JTokenType.Comment,
		JTokenType.Raw
	};

	private static readonly JTokenType[] BytesTypes = new JTokenType[5]
	{
		JTokenType.Bytes,
		JTokenType.String,
		JTokenType.Comment,
		JTokenType.Raw,
		JTokenType.Integer
	};

	public static JTokenEqualityComparer EqualityComparer
	{
		get
		{
			if (_equalityComparer == null)
			{
				_equalityComparer = new JTokenEqualityComparer();
			}
			return _equalityComparer;
		}
	}

	public JContainer Parent
	{
		[DebuggerStepThrough]
		get
		{
			return _parent;
		}
		internal set
		{
			_parent = value;
		}
	}

	public JToken Root
	{
		get
		{
			JContainer parent = Parent;
			if (parent == null)
			{
				return this;
			}
			while (parent.Parent != null)
			{
				parent = parent.Parent;
			}
			return parent;
		}
	}

	public abstract JTokenType Type { get; }

	public abstract bool HasValues { get; }

	public JToken Next
	{
		get
		{
			return _next;
		}
		internal set
		{
			_next = value;
		}
	}

	public JToken Previous
	{
		get
		{
			return _previous;
		}
		internal set
		{
			_previous = value;
		}
	}

	public string Path
	{
		get
		{
			if (Parent == null)
			{
				return string.Empty;
			}
			List<JsonPosition> list = new List<JsonPosition>();
			JToken jToken = null;
			for (JToken jToken2 = this; jToken2 != null; jToken2 = jToken2.Parent)
			{
				switch (jToken2.Type)
				{
				case JTokenType.Property:
				{
					JProperty jProperty = (JProperty)jToken2;
					list.Add(new JsonPosition(JsonContainerType.Object)
					{
						PropertyName = jProperty.Name
					});
					break;
				}
				case JTokenType.Array:
				case JTokenType.Constructor:
					if (jToken != null)
					{
						int position = ((IList<JToken>)jToken2).IndexOf(jToken);
						list.Add(new JsonPosition(JsonContainerType.Array)
						{
							Position = position
						});
					}
					break;
				}
				jToken = jToken2;
			}
			list.Reverse();
			return JsonPosition.BuildPath(list, null);
		}
	}

	public virtual JToken this[object key]
	{
		get
		{
			throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
		}
		set
		{
			throw new InvalidOperationException("Cannot set child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
		}
	}

	public virtual JToken First
	{
		get
		{
			throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
		}
	}

	public virtual JToken Last
	{
		get
		{
			throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
		}
	}

	IJEnumerable<JToken> IJEnumerable<JToken>.this[object key] => this[key];

	int IJsonLineInfo.LineNumber => Annotation<LineInfoAnnotation>()?.LineNumber ?? 0;

	int IJsonLineInfo.LinePosition => Annotation<LineInfoAnnotation>()?.LinePosition ?? 0;

	internal abstract JToken CloneToken();

	internal abstract bool DeepEquals(JToken node);

	public static bool DeepEquals(JToken t1, JToken t2)
	{
		if (t1 != t2)
		{
			if (t1 != null && t2 != null)
			{
				return t1.DeepEquals(t2);
			}
			return false;
		}
		return true;
	}

	internal JToken()
	{
	}

	public void AddAfterSelf(object content)
	{
		if (_parent == null)
		{
			throw new InvalidOperationException("The parent is missing.");
		}
		int num = _parent.IndexOfItem(this);
		_parent.AddInternal(num + 1, content, skipParentCheck: false);
	}

	public void AddBeforeSelf(object content)
	{
		if (_parent == null)
		{
			throw new InvalidOperationException("The parent is missing.");
		}
		int index = _parent.IndexOfItem(this);
		_parent.AddInternal(index, content, skipParentCheck: false);
	}

	public IEnumerable<JToken> Ancestors()
	{
		return GetAncestors(self: false);
	}

	public IEnumerable<JToken> AncestorsAndSelf()
	{
		return GetAncestors(self: true);
	}

	internal IEnumerable<JToken> GetAncestors(bool self)
	{
		for (JToken current = (self ? this : Parent); current != null; current = current.Parent)
		{
			yield return current;
		}
	}

	public IEnumerable<JToken> AfterSelf()
	{
		if (Parent != null)
		{
			for (JToken o = Next; o != null; o = o.Next)
			{
				yield return o;
			}
		}
	}

	public IEnumerable<JToken> BeforeSelf()
	{
		for (JToken o = Parent.First; o != this; o = o.Next)
		{
			yield return o;
		}
	}

	public virtual T Value<T>(object key)
	{
		JToken jToken = this[key];
		if (jToken != null)
		{
			return jToken.Convert<JToken, T>();
		}
		return default(T);
	}

	public virtual JEnumerable<JToken> Children()
	{
		return JEnumerable<JToken>.Empty;
	}

	public JEnumerable<T> Children<T>() where T : JToken
	{
		return new JEnumerable<T>(Children().OfType<T>());
	}

	public virtual IEnumerable<T> Values<T>()
	{
		throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
	}

	public void Remove()
	{
		if (_parent == null)
		{
			throw new InvalidOperationException("The parent is missing.");
		}
		_parent.RemoveItem(this);
	}

	public void Replace(JToken value)
	{
		if (_parent == null)
		{
			throw new InvalidOperationException("The parent is missing.");
		}
		_parent.ReplaceItem(this, value);
	}

	public abstract void WriteTo(JsonWriter writer, params JsonConverter[] converters);

	public override string ToString()
	{
		return ToString(Formatting.Indented);
	}

	public string ToString(Formatting formatting, params JsonConverter[] converters)
	{
		using StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
		JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter);
		jsonTextWriter.Formatting = formatting;
		WriteTo(jsonTextWriter, converters);
		return stringWriter.ToString();
	}

	private static JValue EnsureValue(JToken value)
	{
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		if (value is JProperty)
		{
			value = ((JProperty)value).Value;
		}
		return value as JValue;
	}

	private static string GetType(JToken token)
	{
		ValidationUtils.ArgumentNotNull(token, "token");
		if (token is JProperty)
		{
			token = ((JProperty)token).Value;
		}
		return token.Type.ToString();
	}

	private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable)
	{
		if (Array.IndexOf(validTypes, o.Type) == -1)
		{
			if (nullable)
			{
				if (o.Type != JTokenType.Null)
				{
					return o.Type == JTokenType.Undefined;
				}
				return true;
			}
			return false;
		}
		return true;
	}

	public static explicit operator bool(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, BooleanTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to Boolean.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToBoolean(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator DateTimeOffset(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to DateTimeOffset.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value is DateTimeOffset)
		{
			return (DateTimeOffset)jValue.Value;
		}
		if (jValue.Value is string)
		{
			return DateTimeOffset.Parse((string)jValue.Value, CultureInfo.InvariantCulture);
		}
		return new DateTimeOffset(Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture));
	}

	public static explicit operator bool?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, BooleanTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to Boolean.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToBoolean(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator long(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to Int64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToInt64(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator DateTime?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to DateTime.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value is DateTimeOffset)
		{
			return ((DateTimeOffset)jValue.Value).DateTime;
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator DateTimeOffset?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to DateTimeOffset.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		if (jValue.Value is DateTimeOffset)
		{
			return (DateTimeOffset?)jValue.Value;
		}
		if (jValue.Value is string)
		{
			return DateTimeOffset.Parse((string)jValue.Value, CultureInfo.InvariantCulture);
		}
		return new DateTimeOffset(Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture));
	}

	public static explicit operator decimal?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to Decimal.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToDecimal(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator double?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to Double.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToDouble(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator char?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, CharTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to Char.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToChar(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator int(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to Int32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToInt32(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator short(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to Int16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToInt16(jValue.Value, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static explicit operator ushort(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to UInt16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToUInt16(jValue.Value, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static explicit operator char(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, CharTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to Char.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToChar(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator byte(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to Byte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToByte(jValue.Value, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static explicit operator sbyte(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to SByte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToSByte(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator int?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to Int32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToInt32(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator short?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to Int16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToInt16(jValue.Value, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static explicit operator ushort?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to UInt16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToUInt16(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator byte?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to Byte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToByte(jValue.Value, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static explicit operator sbyte?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to SByte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToSByte(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator DateTime(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to DateTime.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value is DateTimeOffset)
		{
			return ((DateTimeOffset)jValue.Value).DateTime;
		}
		return Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator long?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to Int64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToInt64(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator float?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to Single.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToSingle(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator decimal(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to Decimal.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToDecimal(jValue.Value, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static explicit operator uint?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to UInt32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToUInt32(jValue.Value, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static explicit operator ulong?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to UInt64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return Convert.ToUInt64(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator double(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to Double.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToDouble(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator float(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to Single.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToSingle(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator string(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, StringTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to String.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		if (jValue.Value is byte[])
		{
			return Convert.ToBase64String((byte[])jValue.Value);
		}
		return Convert.ToString(jValue.Value, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static explicit operator uint(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to UInt32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToUInt32(jValue.Value, CultureInfo.InvariantCulture);
	}

	[CLSCompliant(false)]
	public static explicit operator ulong(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to UInt64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		return Convert.ToUInt64(jValue.Value, CultureInfo.InvariantCulture);
	}

	public static explicit operator byte[](JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, BytesTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to byte array.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value is string)
		{
			return Convert.FromBase64String(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
		}
		if (jValue.Value is byte[])
		{
			return (byte[])jValue.Value;
		}
		throw new ArgumentException("Can not convert {0} to byte array.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
	}

	public static explicit operator Guid(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, GuidTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to Guid.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value is byte[])
		{
			return new Guid((byte[])jValue.Value);
		}
		if (!(jValue.Value is Guid))
		{
			return new Guid(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
		}
		return (Guid)jValue.Value;
	}

	public static explicit operator Guid?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, GuidTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to Guid.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		if (jValue.Value is byte[])
		{
			return new Guid((byte[])jValue.Value);
		}
		return (jValue.Value is Guid) ? ((Guid)jValue.Value) : new Guid(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
	}

	public static explicit operator TimeSpan(JToken value)
	{
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, TimeSpanTypes, nullable: false))
		{
			throw new ArgumentException("Can not convert {0} to TimeSpan.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (!(jValue.Value is TimeSpan))
		{
			return ConvertUtils.ParseTimeSpan(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
		}
		return (TimeSpan)jValue.Value;
	}

	public static explicit operator TimeSpan?(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, TimeSpanTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to TimeSpan.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		return (jValue.Value is TimeSpan) ? ((TimeSpan)jValue.Value) : ConvertUtils.ParseTimeSpan(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
	}

	public static explicit operator Uri(JToken value)
	{
		if (value == null)
		{
			return null;
		}
		JValue jValue = EnsureValue(value);
		if (jValue == null || !ValidateToken(jValue, UriTypes, nullable: true))
		{
			throw new ArgumentException("Can not convert {0} to Uri.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}
		if (jValue.Value == null)
		{
			return null;
		}
		if (!(jValue.Value is Uri))
		{
			return new Uri(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
		}
		return (Uri)jValue.Value;
	}

	public static implicit operator JToken(bool value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(DateTimeOffset value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(byte value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(byte? value)
	{
		return new JValue(value);
	}

	[CLSCompliant(false)]
	public static implicit operator JToken(sbyte value)
	{
		return new JValue(value);
	}

	[CLSCompliant(false)]
	public static implicit operator JToken(sbyte? value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(bool? value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(long value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(DateTime? value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(DateTimeOffset? value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(decimal? value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(double? value)
	{
		return new JValue(value);
	}

	[CLSCompliant(false)]
	public static implicit operator JToken(short value)
	{
		return new JValue(value);
	}

	[CLSCompliant(false)]
	public static implicit operator JToken(ushort value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(int value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(int? value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(DateTime value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(long? value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(float? value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(decimal value)
	{
		return new JValue(value);
	}

	[CLSCompliant(false)]
	public static implicit operator JToken(short? value)
	{
		return new JValue(value);
	}

	[CLSCompliant(false)]
	public static implicit operator JToken(ushort? value)
	{
		return new JValue(value);
	}

	[CLSCompliant(false)]
	public static implicit operator JToken(uint? value)
	{
		return new JValue(value);
	}

	[CLSCompliant(false)]
	public static implicit operator JToken(ulong? value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(double value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(float value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(string value)
	{
		return new JValue(value);
	}

	[CLSCompliant(false)]
	public static implicit operator JToken(uint value)
	{
		return new JValue(value);
	}

	[CLSCompliant(false)]
	public static implicit operator JToken(ulong value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(byte[] value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(Uri value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(TimeSpan value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(TimeSpan? value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(Guid value)
	{
		return new JValue(value);
	}

	public static implicit operator JToken(Guid? value)
	{
		return new JValue(value);
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return ((IEnumerable<JToken>)this).GetEnumerator();
	}

	IEnumerator<JToken> IEnumerable<JToken>.GetEnumerator()
	{
		return Children().GetEnumerator();
	}

	internal abstract int GetDeepHashCode();

	public JsonReader CreateReader()
	{
		return new JTokenReader(this);
	}

	internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer)
	{
		ValidationUtils.ArgumentNotNull(o, "o");
		ValidationUtils.ArgumentNotNull(jsonSerializer, "jsonSerializer");
		using JTokenWriter jTokenWriter = new JTokenWriter();
		jsonSerializer.Serialize(jTokenWriter, o);
		return jTokenWriter.Token;
	}

	public static JToken FromObject(object o)
	{
		return FromObjectInternal(o, JsonSerializer.CreateDefault());
	}

	public static JToken FromObject(object o, JsonSerializer jsonSerializer)
	{
		return FromObjectInternal(o, jsonSerializer);
	}

	public T ToObject<T>()
	{
		return (T)ToObject(typeof(T));
	}

	public object ToObject(Type objectType)
	{
		if (JsonConvert.DefaultSettings == null)
		{
			bool isEnum;
			PrimitiveTypeCode typeCode = ConvertUtils.GetTypeCode(objectType, out isEnum);
			if (isEnum)
			{
				if (Type == JTokenType.String)
				{
					try
					{
						return ToObject(objectType, JsonSerializer.CreateDefault());
					}
					catch (Exception innerException)
					{
						Type type = (objectType.IsEnum() ? objectType : Nullable.GetUnderlyingType(objectType));
						throw new ArgumentException("Could not convert '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, (string)this, type.Name), innerException);
					}
				}
				if (Type == JTokenType.Integer)
				{
					return Enum.ToObject(objectType.IsEnum() ? objectType : Nullable.GetUnderlyingType(objectType), ((JValue)this).Value);
				}
			}
			switch (typeCode)
			{
			case PrimitiveTypeCode.BooleanNullable:
				return (bool?)this;
			case PrimitiveTypeCode.Boolean:
				return (bool)this;
			case PrimitiveTypeCode.CharNullable:
				return (char?)this;
			case PrimitiveTypeCode.Char:
				return (char)this;
			case PrimitiveTypeCode.SByte:
				return (sbyte?)this;
			case PrimitiveTypeCode.SByteNullable:
				return (sbyte)this;
			case PrimitiveTypeCode.ByteNullable:
				return (byte?)this;
			case PrimitiveTypeCode.Byte:
				return (byte)this;
			case PrimitiveTypeCode.Int16Nullable:
				return (short?)this;
			case PrimitiveTypeCode.Int16:
				return (short)this;
			case PrimitiveTypeCode.UInt16Nullable:
				return (ushort?)this;
			case PrimitiveTypeCode.UInt16:
				return (ushort)this;
			case PrimitiveTypeCode.Int32Nullable:
				return (int?)this;
			case PrimitiveTypeCode.Int32:
				return (int)this;
			case PrimitiveTypeCode.UInt32Nullable:
				return (uint?)this;
			case PrimitiveTypeCode.UInt32:
				return (uint)this;
			case PrimitiveTypeCode.Int64Nullable:
				return (long?)this;
			case PrimitiveTypeCode.Int64:
				return (long)this;
			case PrimitiveTypeCode.UInt64Nullable:
				return (ulong?)this;
			case PrimitiveTypeCode.UInt64:
				return (ulong)this;
			case PrimitiveTypeCode.SingleNullable:
				return (float?)this;
			case PrimitiveTypeCode.Single:
				return (float)this;
			case PrimitiveTypeCode.DoubleNullable:
				return (double?)this;
			case PrimitiveTypeCode.Double:
				return (double)this;
			case PrimitiveTypeCode.DecimalNullable:
				return (decimal?)this;
			case PrimitiveTypeCode.Decimal:
				return (decimal)this;
			case PrimitiveTypeCode.DateTimeNullable:
				return (DateTime?)this;
			case PrimitiveTypeCode.DateTime:
				return (DateTime)this;
			case PrimitiveTypeCode.DateTimeOffsetNullable:
				return (DateTimeOffset?)this;
			case PrimitiveTypeCode.DateTimeOffset:
				return (DateTimeOffset)this;
			case PrimitiveTypeCode.String:
				return (string)this;
			case PrimitiveTypeCode.GuidNullable:
				return (Guid?)this;
			case PrimitiveTypeCode.Guid:
				return (Guid)this;
			case PrimitiveTypeCode.Uri:
				return (Uri)this;
			case PrimitiveTypeCode.TimeSpanNullable:
				return (TimeSpan?)this;
			case PrimitiveTypeCode.TimeSpan:
				return (TimeSpan)this;
			}
		}
		return ToObject(objectType, JsonSerializer.CreateDefault());
	}

	public T ToObject<T>(JsonSerializer jsonSerializer)
	{
		return (T)ToObject(typeof(T), jsonSerializer);
	}

	public object ToObject(Type objectType, JsonSerializer jsonSerializer)
	{
		ValidationUtils.ArgumentNotNull(jsonSerializer, "jsonSerializer");
		using JTokenReader reader = new JTokenReader(this);
		return jsonSerializer.Deserialize(reader, objectType);
	}

	public static JToken ReadFrom(JsonReader reader)
	{
		return ReadFrom(reader, null);
	}

	public static JToken ReadFrom(JsonReader reader, JsonLoadSettings settings)
	{
		ValidationUtils.ArgumentNotNull(reader, "reader");
		if (reader.TokenType == JsonToken.None && !((settings != null && settings.CommentHandling == CommentHandling.Ignore) ? reader.ReadAndMoveToContent() : reader.Read()))
		{
			throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader.");
		}
		IJsonLineInfo lineInfo = reader as IJsonLineInfo;
		switch (reader.TokenType)
		{
		case JsonToken.StartObject:
			return JObject.Load(reader, settings);
		case JsonToken.StartArray:
			return JArray.Load(reader, settings);
		case JsonToken.StartConstructor:
			return JConstructor.Load(reader, settings);
		case JsonToken.PropertyName:
			return JProperty.Load(reader, settings);
		case JsonToken.Integer:
		case JsonToken.Float:
		case JsonToken.String:
		case JsonToken.Boolean:
		case JsonToken.Date:
		case JsonToken.Bytes:
		{
			JValue jValue4 = new JValue(reader.Value);
			jValue4.SetLineInfo(lineInfo, settings);
			return jValue4;
		}
		case JsonToken.Comment:
		{
			JValue jValue3 = JValue.CreateComment(reader.Value.ToString());
			jValue3.SetLineInfo(lineInfo, settings);
			return jValue3;
		}
		case JsonToken.Null:
		{
			JValue jValue2 = JValue.CreateNull();
			jValue2.SetLineInfo(lineInfo, settings);
			return jValue2;
		}
		case JsonToken.Undefined:
		{
			JValue jValue = JValue.CreateUndefined();
			jValue.SetLineInfo(lineInfo, settings);
			return jValue;
		}
		default:
			throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader. Unexpected token: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}
	}

	public static JToken Parse(string json)
	{
		return Parse(json, null);
	}

	public static JToken Parse(string json, JsonLoadSettings settings)
	{
		using JsonReader jsonReader = new JsonTextReader(new StringReader(json));
		JToken result = Load(jsonReader, settings);
		if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
		{
			throw JsonReaderException.Create(jsonReader, "Additional text found in JSON string after parsing content.");
		}
		return result;
	}

	public static JToken Load(JsonReader reader, JsonLoadSettings settings)
	{
		return ReadFrom(reader, settings);
	}

	public static JToken Load(JsonReader reader)
	{
		return Load(reader, null);
	}

	internal void SetLineInfo(IJsonLineInfo lineInfo, JsonLoadSettings settings)
	{
		if ((settings == null || settings.LineInfoHandling != LineInfoHandling.Load) && lineInfo != null && lineInfo.HasLineInfo())
		{
			SetLineInfo(lineInfo.LineNumber, lineInfo.LinePosition);
		}
	}

	internal void SetLineInfo(int lineNumber, int linePosition)
	{
		AddAnnotation(new LineInfoAnnotation(lineNumber, linePosition));
	}

	bool IJsonLineInfo.HasLineInfo()
	{
		return Annotation<LineInfoAnnotation>() != null;
	}

	public JToken SelectToken(string path)
	{
		return SelectToken(path, errorWhenNoMatch: false);
	}

	public JToken SelectToken(string path, bool errorWhenNoMatch)
	{
		JPath jPath = new JPath(path);
		JToken jToken = null;
		foreach (JToken item in jPath.Evaluate(this, errorWhenNoMatch))
		{
			if (jToken != null)
			{
				throw new JsonException("Path returned multiple tokens.");
			}
			jToken = item;
		}
		return jToken;
	}

	public IEnumerable<JToken> SelectTokens(string path)
	{
		return SelectTokens(path, errorWhenNoMatch: false);
	}

	public IEnumerable<JToken> SelectTokens(string path, bool errorWhenNoMatch)
	{
		return new JPath(path).Evaluate(this, errorWhenNoMatch);
	}

	object ICloneable.Clone()
	{
		return DeepClone();
	}

	public JToken DeepClone()
	{
		return CloneToken();
	}

	public void AddAnnotation(object annotation)
	{
		if (annotation == null)
		{
			throw new ArgumentNullException("annotation");
		}
		if (_annotations == null)
		{
			_annotations = ((!(annotation is object[])) ? annotation : new object[1] { annotation });
			return;
		}
		object[] array = _annotations as object[];
		if (array == null)
		{
			_annotations = new object[2] { _annotations, annotation };
			return;
		}
		int i;
		for (i = 0; i < array.Length && array[i] != null; i++)
		{
		}
		if (i == array.Length)
		{
			Array.Resize(ref array, i * 2);
			_annotations = array;
		}
		array[i] = annotation;
	}

	public T Annotation<T>() where T : class
	{
		if (_annotations != null)
		{
			if (!(_annotations is object[] array))
			{
				return _annotations as T;
			}
			foreach (object obj in array)
			{
				if (obj == null)
				{
					break;
				}
				if (obj is T result)
				{
					return result;
				}
			}
		}
		return null;
	}

	public object Annotation(Type type)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		if (_annotations != null)
		{
			if (!(_annotations is object[] array))
			{
				if (type.IsInstanceOfType(_annotations))
				{
					return _annotations;
				}
			}
			else
			{
				foreach (object obj in array)
				{
					if (obj == null)
					{
						break;
					}
					if (type.IsInstanceOfType(obj))
					{
						return obj;
					}
				}
			}
		}
		return null;
	}

	public IEnumerable<T> Annotations<T>() where T : class
	{
		if (_annotations == null)
		{
			yield break;
		}
		if (_annotations is object[] annotations)
		{
			foreach (object obj in annotations)
			{
				if (obj != null)
				{
					if (obj is T val)
					{
						yield return val;
					}
					continue;
				}
				break;
			}
		}
		else if (_annotations is T val2)
		{
			yield return val2;
		}
	}

	public IEnumerable<object> Annotations(Type type)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		if (_annotations == null)
		{
			yield break;
		}
		if (_annotations is object[] annotations)
		{
			foreach (object obj in annotations)
			{
				if (obj != null)
				{
					if (type.IsInstanceOfType(obj))
					{
						yield return obj;
					}
					continue;
				}
				break;
			}
		}
		else if (type.IsInstanceOfType(_annotations))
		{
			yield return _annotations;
		}
	}

	public void RemoveAnnotations<T>() where T : class
	{
		if (_annotations == null)
		{
			return;
		}
		if (!(_annotations is object[] array))
		{
			if (_annotations is T)
			{
				_annotations = null;
			}
			return;
		}
		int i = 0;
		int num = 0;
		for (; i < array.Length; i++)
		{
			object obj = array[i];
			if (obj == null)
			{
				break;
			}
			if (!(obj is T))
			{
				array[num++] = obj;
			}
		}
		if (num != 0)
		{
			while (num < i)
			{
				array[num++] = null;
			}
		}
		else
		{
			_annotations = null;
		}
	}

	public void RemoveAnnotations(Type type)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		if (_annotations == null)
		{
			return;
		}
		if (!(_annotations is object[] array))
		{
			if (type.IsInstanceOfType(_annotations))
			{
				_annotations = null;
			}
			return;
		}
		int i = 0;
		int num = 0;
		for (; i < array.Length; i++)
		{
			object obj = array[i];
			if (obj == null)
			{
				break;
			}
			if (!type.IsInstanceOfType(obj))
			{
				array[num++] = obj;
			}
		}
		if (num != 0)
		{
			while (num < i)
			{
				array[num++] = null;
			}
		}
		else
		{
			_annotations = null;
		}
	}
}


private class LineInfoAnnotation
{
	internal readonly int LineNumber;

	internal readonly int LinePosition;

	public LineInfoAnnotation(int lineNumber, int linePosition)
	{
		LineNumber = lineNumber;
		LinePosition = linePosition;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JProperty : JContainer
{
	private class JPropertyList : IList<JToken>, ICollection<JToken>, IEnumerable<JToken>, IEnumerable
	{
		internal JToken _token;

		public int Count
		{
			get
			{
				if (_token == null)
				{
					return 0;
				}
				return 1;
			}
		}

		public bool IsReadOnly => false;

		public JToken this[int index]
		{
			get
			{
				if (index != 0)
				{
					return null;
				}
				return _token;
			}
			set
			{
				if (index == 0)
				{
					_token = value;
				}
			}
		}

		public IEnumerator<JToken> GetEnumerator()
		{
			if (_token != null)
			{
				yield return _token;
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Add(JToken item)
		{
			_token = item;
		}

		public void Clear()
		{
			_token = null;
		}

		public bool Contains(JToken item)
		{
			return _token == item;
		}

		public void CopyTo(JToken[] array, int arrayIndex)
		{
			if (_token != null)
			{
				array[arrayIndex] = _token;
			}
		}

		public bool Remove(JToken item)
		{
			if (_token == item)
			{
				_token = null;
				return true;
			}
			return false;
		}

		public int IndexOf(JToken item)
		{
			if (_token != item)
			{
				return -1;
			}
			return 0;
		}

		public void Insert(int index, JToken item)
		{
			if (index == 0)
			{
				_token = item;
			}
		}

		public void RemoveAt(int index)
		{
			if (index == 0)
			{
				_token = null;
			}
		}
	}

	private readonly JPropertyList _content = new JPropertyList();

	private readonly string _name;

	protected override IList<JToken> ChildrenTokens => _content;

	public string Name
	{
		[DebuggerStepThrough]
		get
		{
			return _name;
		}
	}

	public new JToken Value
	{
		[DebuggerStepThrough]
		get
		{
			return _content._token;
		}
		set
		{
			CheckReentrancy();
			JToken item = value ?? JValue.CreateNull();
			if (_content._token == null)
			{
				InsertItem(0, item, skipParentCheck: false);
			}
			else
			{
				SetItem(0, item);
			}
		}
	}

	public override JTokenType Type
	{
		[DebuggerStepThrough]
		get
		{
			return JTokenType.Property;
		}
	}

	public JProperty(JProperty other)
		: base(other)
	{
		_name = other.Name;
	}

	internal override JToken GetItem(int index)
	{
		if (index != 0)
		{
			throw new ArgumentOutOfRangeException();
		}
		return Value;
	}

	internal override void SetItem(int index, JToken item)
	{
		if (index != 0)
		{
			throw new ArgumentOutOfRangeException();
		}
		if (!JContainer.IsTokenUnchanged(Value, item))
		{
			if (base.Parent != null)
			{
				((JObject)base.Parent).InternalPropertyChanging(this);
			}
			base.SetItem(0, item);
			if (base.Parent != null)
			{
				((JObject)base.Parent).InternalPropertyChanged(this);
			}
		}
	}

	internal override bool RemoveItem(JToken item)
	{
		throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
	}

	internal override void RemoveItemAt(int index)
	{
		throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
	}

	internal override int IndexOfItem(JToken item)
	{
		return _content.IndexOf(item);
	}

	internal override void InsertItem(int index, JToken item, bool skipParentCheck)
	{
		if (item == null || item.Type != JTokenType.Comment)
		{
			if (Value != null)
			{
				throw new JsonException("{0} cannot have multiple values.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
			}
			base.InsertItem(0, item, skipParentCheck: false);
		}
	}

	internal override bool ContainsItem(JToken item)
	{
		return Value == item;
	}

	internal override void MergeItem(object content, JsonMergeSettings settings)
	{
		if (content is JProperty { Value: not null } jProperty && jProperty.Value.Type != JTokenType.Null)
		{
			Value = jProperty.Value;
		}
	}

	internal override void ClearItems()
	{
		throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
	}

	internal override bool DeepEquals(JToken node)
	{
		if (node is JProperty jProperty && _name == jProperty.Name)
		{
			return ContentsEqual(jProperty);
		}
		return false;
	}

	internal override JToken CloneToken()
	{
		return new JProperty(this);
	}

	internal JProperty(string name)
	{
		ValidationUtils.ArgumentNotNull(name, "name");
		_name = name;
	}

	public JProperty(string name, params object[] content)
		: this(name, (object)content)
	{
	}

	public JProperty(string name, object content)
	{
		ValidationUtils.ArgumentNotNull(name, "name");
		_name = name;
		Value = (IsMultiContent(content) ? new JArray(content) : JContainer.CreateFromContent(content));
	}

	public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
	{
		writer.WritePropertyName(_name);
		JToken value = Value;
		if (value != null)
		{
			value.WriteTo(writer, converters);
		}
		else
		{
			writer.WriteNull();
		}
	}

	internal override int GetDeepHashCode()
	{
		return _name.GetHashCode() ^ ((Value != null) ? Value.GetDeepHashCode() : 0);
	}

	public new static JProperty Load(JsonReader reader)
	{
		return Load(reader, null);
	}

	public new static JProperty Load(JsonReader reader, JsonLoadSettings settings)
	{
		if (reader.TokenType == JsonToken.None && !reader.Read())
		{
			throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader.");
		}
		reader.MoveToContent();
		if (reader.TokenType != JsonToken.PropertyName)
		{
			throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader. Current JsonReader item is not a property: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}
		JProperty jProperty = new JProperty((string)reader.Value);
		jProperty.SetLineInfo(reader as IJsonLineInfo, settings);
		jProperty.ReadTokenFrom(reader, settings);
		return jProperty;
	}
}


using System.Collections;
using System.Collections.Generic;

private class JPropertyList : IList<JToken>, ICollection<JToken>, IEnumerable<JToken>, IEnumerable
{
	internal JToken _token;

	public int Count
	{
		get
		{
			if (_token == null)
			{
				return 0;
			}
			return 1;
		}
	}

	public bool IsReadOnly => false;

	public JToken this[int index]
	{
		get
		{
			if (index != 0)
			{
				return null;
			}
			return _token;
		}
		set
		{
			if (index == 0)
			{
				_token = value;
			}
		}
	}

	public IEnumerator<JToken> GetEnumerator()
	{
		if (_token != null)
		{
			yield return _token;
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public void Add(JToken item)
	{
		_token = item;
	}

	public void Clear()
	{
		_token = null;
	}

	public bool Contains(JToken item)
	{
		return _token == item;
	}

	public void CopyTo(JToken[] array, int arrayIndex)
	{
		if (_token != null)
		{
			array[arrayIndex] = _token;
		}
	}

	public bool Remove(JToken item)
	{
		if (_token == item)
		{
			_token = null;
			return true;
		}
		return false;
	}

	public int IndexOf(JToken item)
	{
		if (_token != item)
		{
			return -1;
		}
		return 0;
	}

	public void Insert(int index, JToken item)
	{
		if (index == 0)
		{
			_token = item;
		}
	}

	public void RemoveAt(int index)
	{
		if (index == 0)
		{
			_token = null;
		}
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
public enum JTokenType
{
	None,
	Object,
	Array,
	Constructor,
	Property,
	Comment,
	Integer,
	Float,
	String,
	Boolean,
	Null,
	Undefined,
	Date,
	Raw,
	Bytes,
	Guid,
	Uri,
	TimeSpan
}


using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JValue : JToken, IFormattable, IComparable, IConvertible
{
	private JTokenType _valueType;

	private object _value;

	public override bool HasValues => false;

	public override JTokenType Type => _valueType;

	public new object Value
	{
		get
		{
			return _value;
		}
		set
		{
			Type obj = ((_value != null) ? _value.GetType() : null);
			Type type = value?.GetType();
			if ((object)obj != type)
			{
				_valueType = GetValueType(_valueType, value);
			}
			_value = value;
		}
	}

	internal JValue(object value, JTokenType type)
	{
		_value = value;
		_valueType = type;
	}

	public JValue(JValue other)
		: this(other.Value, other.Type)
	{
	}

	public JValue(long value)
		: this(value, JTokenType.Integer)
	{
	}

	public JValue(decimal value)
		: this(value, JTokenType.Float)
	{
	}

	public JValue(char value)
		: this(value, JTokenType.String)
	{
	}

	[CLSCompliant(false)]
	public JValue(ulong value)
		: this(value, JTokenType.Integer)
	{
	}

	public JValue(double value)
		: this(value, JTokenType.Float)
	{
	}

	public JValue(float value)
		: this(value, JTokenType.Float)
	{
	}

	public JValue(DateTime value)
		: this(value, JTokenType.Date)
	{
	}

	public JValue(DateTimeOffset value)
		: this(value, JTokenType.Date)
	{
	}

	public JValue(bool value)
		: this(value, JTokenType.Boolean)
	{
	}

	public JValue(string value)
		: this(value, JTokenType.String)
	{
	}

	public JValue(Guid value)
		: this(value, JTokenType.Guid)
	{
	}

	public JValue(Uri value)
		: this(value, (value != null) ? JTokenType.Uri : JTokenType.Null)
	{
	}

	public JValue(TimeSpan value)
		: this(value, JTokenType.TimeSpan)
	{
	}

	public JValue(object value)
		: this(value, GetValueType(null, value))
	{
	}

	internal override bool DeepEquals(JToken node)
	{
		if (!(node is JValue jValue))
		{
			return false;
		}
		if (jValue == this)
		{
			return true;
		}
		return ValuesEquals(this, jValue);
	}

	internal static int Compare(JTokenType valueType, object objA, object objB)
	{
		if (objA == null && objB == null)
		{
			return 0;
		}
		if (objA != null && objB == null)
		{
			return 1;
		}
		if (objA == null && objB != null)
		{
			return -1;
		}
		switch (valueType)
		{
		case JTokenType.Integer:
			if (objA is ulong || objB is ulong || objA is decimal || objB is decimal)
			{
				return Convert.ToDecimal(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToDecimal(objB, CultureInfo.InvariantCulture));
			}
			if (objA is float || objB is float || objA is double || objB is double)
			{
				return CompareFloat(objA, objB);
			}
			return Convert.ToInt64(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToInt64(objB, CultureInfo.InvariantCulture));
		case JTokenType.Float:
			return CompareFloat(objA, objB);
		case JTokenType.Comment:
		case JTokenType.String:
		case JTokenType.Raw:
		{
			string? strA = Convert.ToString(objA, CultureInfo.InvariantCulture);
			string strB = Convert.ToString(objB, CultureInfo.InvariantCulture);
			return string.CompareOrdinal(strA, strB);
		}
		case JTokenType.Boolean:
		{
			bool flag = Convert.ToBoolean(objA, CultureInfo.InvariantCulture);
			bool value3 = Convert.ToBoolean(objB, CultureInfo.InvariantCulture);
			return flag.CompareTo(value3);
		}
		case JTokenType.Date:
		{
			if (objA is DateTime dateTime)
			{
				DateTime value2 = ((!(objB is DateTimeOffset dateTimeOffset)) ? Convert.ToDateTime(objB, CultureInfo.InvariantCulture) : dateTimeOffset.DateTime);
				return dateTime.CompareTo(value2);
			}
			DateTimeOffset dateTimeOffset2 = (DateTimeOffset)objA;
			DateTimeOffset other = ((!(objB is DateTimeOffset)) ? new DateTimeOffset(Convert.ToDateTime(objB, CultureInfo.InvariantCulture)) : ((DateTimeOffset)objB));
			return dateTimeOffset2.CompareTo(other);
		}
		case JTokenType.Bytes:
		{
			if (!(objB is byte[]))
			{
				throw new ArgumentException("Object must be of type byte[].");
			}
			byte[] array = objA as byte[];
			byte[] array2 = objB as byte[];
			if (array == null)
			{
				return -1;
			}
			if (array2 == null)
			{
				return 1;
			}
			return MiscellaneousUtils.ByteArrayCompare(array, array2);
		}
		case JTokenType.Guid:
		{
			if (!(objB is Guid))
			{
				throw new ArgumentException("Object must be of type Guid.");
			}
			Guid guid = (Guid)objA;
			Guid value4 = (Guid)objB;
			return guid.CompareTo(value4);
		}
		case JTokenType.Uri:
		{
			if (!(objB is Uri))
			{
				throw new ArgumentException("Object must be of type Uri.");
			}
			Uri uri = (Uri)objA;
			Uri uri2 = (Uri)objB;
			return Comparer<string>.Default.Compare(uri.ToString(), uri2.ToString());
		}
		case JTokenType.TimeSpan:
		{
			if (!(objB is TimeSpan))
			{
				throw new ArgumentException("Object must be of type TimeSpan.");
			}
			TimeSpan timeSpan = (TimeSpan)objA;
			TimeSpan value = (TimeSpan)objB;
			return timeSpan.CompareTo(value);
		}
		default:
			throw MiscellaneousUtils.CreateArgumentOutOfRangeException("valueType", valueType, "Unexpected value type: {0}".FormatWith(CultureInfo.InvariantCulture, valueType));
		}
	}

	private static int CompareFloat(object objA, object objB)
	{
		double d = Convert.ToDouble(objA, CultureInfo.InvariantCulture);
		double num = Convert.ToDouble(objB, CultureInfo.InvariantCulture);
		if (MathUtils.ApproxEquals(d, num))
		{
			return 0;
		}
		return d.CompareTo(num);
	}

	internal override JToken CloneToken()
	{
		return new JValue(this);
	}

	public static JValue CreateComment(string value)
	{
		return new JValue(value, JTokenType.Comment);
	}

	public static JValue CreateString(string value)
	{
		return new JValue(value, JTokenType.String);
	}

	public static JValue CreateNull()
	{
		return new JValue(null, JTokenType.Null);
	}

	public static JValue CreateUndefined()
	{
		return new JValue(null, JTokenType.Undefined);
	}

	private static JTokenType GetValueType(JTokenType? current, object value)
	{
		if (value == null)
		{
			return JTokenType.Null;
		}
		if (value == DBNull.Value)
		{
			return JTokenType.Null;
		}
		if (value is string)
		{
			return GetStringValueType(current);
		}
		if (value is long || value is int || value is short || value is sbyte || value is ulong || value is uint || value is ushort || value is byte)
		{
			return JTokenType.Integer;
		}
		if (value is Enum)
		{
			return JTokenType.Integer;
		}
		if (value is double || value is float || value is decimal)
		{
			return JTokenType.Float;
		}
		if (value is DateTime)
		{
			return JTokenType.Date;
		}
		if (value is DateTimeOffset)
		{
			return JTokenType.Date;
		}
		if (value is byte[])
		{
			return JTokenType.Bytes;
		}
		if (value is bool)
		{
			return JTokenType.Boolean;
		}
		if (value is Guid)
		{
			return JTokenType.Guid;
		}
		if (value is Uri)
		{
			return JTokenType.Uri;
		}
		if (value is TimeSpan)
		{
			return JTokenType.TimeSpan;
		}
		throw new ArgumentException("Could not determine JSON object type for type {0}.".FormatWith(CultureInfo.InvariantCulture, value.GetType()));
	}

	private static JTokenType GetStringValueType(JTokenType? current)
	{
		if (!current.HasValue)
		{
			return JTokenType.String;
		}
		JTokenType valueOrDefault = current.GetValueOrDefault();
		if (valueOrDefault == JTokenType.Comment || valueOrDefault == JTokenType.String || valueOrDefault == JTokenType.Raw)
		{
			return current.GetValueOrDefault();
		}
		return JTokenType.String;
	}

	public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
	{
		if (converters != null && converters.Length != 0 && _value != null)
		{
			JsonConverter matchingConverter = JsonSerializer.GetMatchingConverter(converters, _value.GetType());
			if (matchingConverter != null && matchingConverter.CanWrite)
			{
				matchingConverter.WriteJson(writer, _value, JsonSerializer.CreateDefault());
				return;
			}
		}
		switch (_valueType)
		{
		case JTokenType.Comment:
			writer.WriteComment((_value != null) ? _value.ToString() : null);
			break;
		case JTokenType.Raw:
			writer.WriteRawValue((_value != null) ? _value.ToString() : null);
			break;
		case JTokenType.Null:
			writer.WriteNull();
			break;
		case JTokenType.Undefined:
			writer.WriteUndefined();
			break;
		case JTokenType.Integer:
			if (_value is int)
			{
				writer.WriteValue((int)_value);
			}
			else if (_value is long)
			{
				writer.WriteValue((long)_value);
			}
			else if (_value is ulong)
			{
				writer.WriteValue((ulong)_value);
			}
			else
			{
				writer.WriteValue(Convert.ToInt64(_value, CultureInfo.InvariantCulture));
			}
			break;
		case JTokenType.Float:
			if (_value is decimal)
			{
				writer.WriteValue((decimal)_value);
			}
			else if (_value is double)
			{
				writer.WriteValue((double)_value);
			}
			else if (_value is float)
			{
				writer.WriteValue((float)_value);
			}
			else
			{
				writer.WriteValue(Convert.ToDouble(_value, CultureInfo.InvariantCulture));
			}
			break;
		case JTokenType.String:
			writer.WriteValue((_value != null) ? _value.ToString() : null);
			break;
		case JTokenType.Boolean:
			writer.WriteValue(Convert.ToBoolean(_value, CultureInfo.InvariantCulture));
			break;
		case JTokenType.Date:
			if (_value is DateTimeOffset)
			{
				writer.WriteValue((DateTimeOffset)_value);
			}
			else
			{
				writer.WriteValue(Convert.ToDateTime(_value, CultureInfo.InvariantCulture));
			}
			break;
		case JTokenType.Bytes:
			writer.WriteValue((byte[])_value);
			break;
		case JTokenType.Guid:
			writer.WriteValue((_value != null) ? ((Guid?)_value) : ((Guid?)null));
			break;
		case JTokenType.TimeSpan:
			writer.WriteValue((_value != null) ? ((TimeSpan?)_value) : ((TimeSpan?)null));
			break;
		case JTokenType.Uri:
			writer.WriteValue((Uri)_value);
			break;
		default:
			throw MiscellaneousUtils.CreateArgumentOutOfRangeException("TokenType", _valueType, "Unexpected token type.");
		}
	}

	internal override int GetDeepHashCode()
	{
		int num = ((_value != null) ? _value.GetHashCode() : 0);
		int valueType = (int)_valueType;
		return valueType.GetHashCode() ^ num;
	}

	private static bool ValuesEquals(JValue v1, JValue v2)
	{
		if (v1 != v2)
		{
			if (v1._valueType == v2._valueType)
			{
				return Compare(v1._valueType, v1._value, v2._value) == 0;
			}
			return false;
		}
		return true;
	}

	public bool Equals(JValue other)
	{
		if (other == null)
		{
			return false;
		}
		return ValuesEquals(this, other);
	}

	public override bool Equals(object obj)
	{
		if (obj == null)
		{
			return false;
		}
		if (obj is JValue other)
		{
			return Equals(other);
		}
		return base.Equals(obj);
	}

	public override int GetHashCode()
	{
		if (_value == null)
		{
			return 0;
		}
		return _value.GetHashCode();
	}

	public override string ToString()
	{
		if (_value == null)
		{
			return string.Empty;
		}
		return _value.ToString();
	}

	public string ToString(string format)
	{
		return ToString(format, CultureInfo.CurrentCulture);
	}

	public string ToString(IFormatProvider formatProvider)
	{
		return ToString(null, formatProvider);
	}

	public string ToString(string format, IFormatProvider formatProvider)
	{
		if (_value == null)
		{
			return string.Empty;
		}
		if (_value is IFormattable formattable)
		{
			return formattable.ToString(format, formatProvider);
		}
		return _value.ToString();
	}

	int IComparable.CompareTo(object obj)
	{
		if (obj == null)
		{
			return 1;
		}
		object objB = ((obj is JValue) ? ((JValue)obj).Value : obj);
		return Compare(_valueType, _value, objB);
	}

	public int CompareTo(JValue obj)
	{
		if (obj == null)
		{
			return 1;
		}
		return Compare(_valueType, _value, obj._value);
	}

	TypeCode IConvertible.GetTypeCode()
	{
		if (_value == null)
		{
			return TypeCode.Empty;
		}
		if (!(_value is IConvertible convertible))
		{
			return TypeCode.Object;
		}
		return convertible.GetTypeCode();
	}

	bool IConvertible.ToBoolean(IFormatProvider provider)
	{
		return (bool)(JToken)this;
	}

	char IConvertible.ToChar(IFormatProvider provider)
	{
		return (char)(JToken)this;
	}

	sbyte IConvertible.ToSByte(IFormatProvider provider)
	{
		return (sbyte)(JToken)this;
	}

	byte IConvertible.ToByte(IFormatProvider provider)
	{
		return (byte)(JToken)this;
	}

	short IConvertible.ToInt16(IFormatProvider provider)
	{
		return (short)(JToken)this;
	}

	ushort IConvertible.ToUInt16(IFormatProvider provider)
	{
		return (ushort)(JToken)this;
	}

	int IConvertible.ToInt32(IFormatProvider provider)
	{
		return (int)(JToken)this;
	}

	uint IConvertible.ToUInt32(IFormatProvider provider)
	{
		return (uint)(JToken)this;
	}

	long IConvertible.ToInt64(IFormatProvider provider)
	{
		return (long)(JToken)this;
	}

	ulong IConvertible.ToUInt64(IFormatProvider provider)
	{
		return (ulong)(JToken)this;
	}

	float IConvertible.ToSingle(IFormatProvider provider)
	{
		return (float)(JToken)this;
	}

	double IConvertible.ToDouble(IFormatProvider provider)
	{
		return (double)(JToken)this;
	}

	decimal IConvertible.ToDecimal(IFormatProvider provider)
	{
		return (decimal)(JToken)this;
	}

	DateTime IConvertible.ToDateTime(IFormatProvider provider)
	{
		return (DateTime)(JToken)this;
	}

	object IConvertible.ToType(Type conversionType, IFormatProvider provider)
	{
		return ToObject(conversionType);
	}
}


using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class ArrayIndexFilter : PathFilter
{
	public int? Index { get; set; }

	public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
	{
		foreach (JToken t in current)
		{
			if (Index.HasValue)
			{
				JToken tokenIndex = PathFilter.GetTokenIndex(t, errorWhenNoMatch, Index.GetValueOrDefault());
				if (tokenIndex != null)
				{
					yield return tokenIndex;
				}
			}
			else if (t is JArray || t is JConstructor)
			{
				foreach (JToken item in (IEnumerable<JToken>)t)
				{
					yield return item;
				}
			}
			else if (errorWhenNoMatch)
			{
				throw new JsonException("Index * not valid on {0}.".FormatWith(CultureInfo.InvariantCulture, t.GetType().Name));
			}
		}
	}
}


using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Shims;

[Preserve]
internal class ArrayMultipleIndexFilter : PathFilter
{
	public List<int> Indexes { get; set; }

	public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
	{
		foreach (JToken t in current)
		{
			foreach (int index in Indexes)
			{
				JToken tokenIndex = PathFilter.GetTokenIndex(t, errorWhenNoMatch, index);
				if (tokenIndex != null)
				{
					yield return tokenIndex;
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class ArraySliceFilter : PathFilter
{
	public int? Start { get; set; }

	public int? End { get; set; }

	public int? Step { get; set; }

	public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
	{
		if (Step == 0)
		{
			throw new JsonException("Step cannot be zero.");
		}
		foreach (JToken t in current)
		{
			if (t is JArray a)
			{
				int stepCount = Step ?? 1;
				int num = Start ?? ((stepCount <= 0) ? (a.Count - 1) : 0);
				int stopIndex = End ?? ((stepCount > 0) ? a.Count : (-1));
				if (Start < 0)
				{
					num = a.Count + num;
				}
				if (End < 0)
				{
					stopIndex = a.Count + stopIndex;
				}
				num = Math.Max(num, (stepCount <= 0) ? int.MinValue : 0);
				num = Math.Min(num, (stepCount > 0) ? a.Count : (a.Count - 1));
				stopIndex = Math.Max(stopIndex, -1);
				stopIndex = Math.Min(stopIndex, a.Count);
				bool positiveStep = stepCount > 0;
				if (IsValid(num, stopIndex, positiveStep))
				{
					for (int i = num; IsValid(i, stopIndex, positiveStep); i += stepCount)
					{
						yield return a[i];
					}
				}
				else if (errorWhenNoMatch)
				{
					throw new JsonException("Array slice of {0} to {1} returned no results.".FormatWith(CultureInfo.InvariantCulture, Start.HasValue ? Start.GetValueOrDefault().ToString(CultureInfo.InvariantCulture) : "*", End.HasValue ? End.GetValueOrDefault().ToString(CultureInfo.InvariantCulture) : "*"));
				}
			}
			else if (errorWhenNoMatch)
			{
				throw new JsonException("Array slice is not valid on {0}.".FormatWith(CultureInfo.InvariantCulture, t.GetType().Name));
			}
		}
	}

	private bool IsValid(int index, int stopIndex, bool positiveStep)
	{
		if (positiveStep)
		{
			return index < stopIndex;
		}
		return index > stopIndex;
	}
}


using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class FieldFilter : PathFilter
{
	public string Name { get; set; }

	public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
	{
		foreach (JToken t in current)
		{
			if (t is JObject o)
			{
				if (Name != null)
				{
					JToken jToken = o[Name];
					if (jToken != null)
					{
						yield return jToken;
					}
					else if (errorWhenNoMatch)
					{
						throw new JsonException("Property '{0}' does not exist on JObject.".FormatWith(CultureInfo.InvariantCulture, Name));
					}
					continue;
				}
				foreach (KeyValuePair<string, JToken> item in o)
				{
					yield return item.Value;
				}
			}
			else if (errorWhenNoMatch)
			{
				throw new JsonException("Property '{0}' not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, Name ?? "*", t.GetType().Name));
			}
		}
	}
}


using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class FieldMultipleFilter : PathFilter
{
	public List<string> Names { get; set; }

	public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
	{
		foreach (JToken t in current)
		{
			if (t is JObject o)
			{
				foreach (string name in Names)
				{
					JToken jToken = o[name];
					if (jToken != null)
					{
						yield return jToken;
					}
					if (errorWhenNoMatch)
					{
						throw new JsonException("Property '{0}' does not exist on JObject.".FormatWith(CultureInfo.InvariantCulture, name));
					}
				}
			}
			else if (errorWhenNoMatch)
			{
				throw new JsonException("Properties {0} not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, string.Join(", ", Names.Select((string n) => "'" + n + "'").ToArray()), t.GetType().Name));
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class JPath
{
	private readonly string _expression;

	private int _currentIndex;

	public List<PathFilter> Filters { get; private set; }

	public JPath(string expression)
	{
		ValidationUtils.ArgumentNotNull(expression, "expression");
		_expression = expression;
		Filters = new List<PathFilter>();
		ParseMain();
	}

	private void ParseMain()
	{
		int currentIndex = _currentIndex;
		EatWhitespace();
		if (_expression.Length == _currentIndex)
		{
			return;
		}
		if (_expression[_currentIndex] == '$')
		{
			if (_expression.Length == 1)
			{
				return;
			}
			char c = _expression[_currentIndex + 1];
			if (c == '.' || c == '[')
			{
				_currentIndex++;
				currentIndex = _currentIndex;
			}
		}
		if (!ParsePath(Filters, currentIndex, query: false))
		{
			int currentIndex2 = _currentIndex;
			EatWhitespace();
			if (_currentIndex < _expression.Length)
			{
				throw new JsonException("Unexpected character while parsing path: " + _expression[currentIndex2]);
			}
		}
	}

	private bool ParsePath(List<PathFilter> filters, int currentPartStartIndex, bool query)
	{
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		while (_currentIndex < _expression.Length && !flag4)
		{
			char c = _expression[_currentIndex];
			switch (c)
			{
			case '(':
			case '[':
				if (_currentIndex > currentPartStartIndex)
				{
					string text2 = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex);
					if (text2 == "*")
					{
						text2 = null;
					}
					PathFilter item2 = (flag ? ((PathFilter)new ScanFilter
					{
						Name = text2
					}) : ((PathFilter)new FieldFilter
					{
						Name = text2
					}));
					filters.Add(item2);
					flag = false;
				}
				filters.Add(ParseIndexer(c));
				_currentIndex++;
				currentPartStartIndex = _currentIndex;
				flag2 = true;
				flag3 = false;
				break;
			case ')':
			case ']':
				flag4 = true;
				break;
			case ' ':
				if (_currentIndex < _expression.Length)
				{
					flag4 = true;
				}
				break;
			case '.':
				if (_currentIndex > currentPartStartIndex)
				{
					string text = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex);
					if (text == "*")
					{
						text = null;
					}
					PathFilter item = (flag ? ((PathFilter)new ScanFilter
					{
						Name = text
					}) : ((PathFilter)new FieldFilter
					{
						Name = text
					}));
					filters.Add(item);
					flag = false;
				}
				if (_currentIndex + 1 < _expression.Length && _expression[_currentIndex + 1] == '.')
				{
					flag = true;
					_currentIndex++;
				}
				_currentIndex++;
				currentPartStartIndex = _currentIndex;
				flag2 = false;
				flag3 = true;
				break;
			default:
				if (query && (c == '=' || c == '<' || c == '!' || c == '>' || c == '|' || c == '&'))
				{
					flag4 = true;
					break;
				}
				if (flag2)
				{
					throw new JsonException("Unexpected character following indexer: " + c);
				}
				_currentIndex++;
				break;
			}
		}
		bool flag5 = _currentIndex == _expression.Length;
		if (_currentIndex > currentPartStartIndex)
		{
			string text3 = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex).TrimEnd(new char[0]);
			if (text3 == "*")
			{
				text3 = null;
			}
			PathFilter item3 = (flag ? ((PathFilter)new ScanFilter
			{
				Name = text3
			}) : ((PathFilter)new FieldFilter
			{
				Name = text3
			}));
			filters.Add(item3);
		}
		else if (flag3 && (flag5 || query))
		{
			throw new JsonException("Unexpected end while parsing path.");
		}
		return flag5;
	}

	private PathFilter ParseIndexer(char indexerOpenChar)
	{
		_currentIndex++;
		char indexerCloseChar = ((indexerOpenChar == '[') ? ']' : ')');
		EnsureLength("Path ended with open indexer.");
		EatWhitespace();
		if (_expression[_currentIndex] == '\'')
		{
			return ParseQuotedField(indexerCloseChar);
		}
		if (_expression[_currentIndex] == '?')
		{
			return ParseQuery(indexerCloseChar);
		}
		return ParseArrayIndexer(indexerCloseChar);
	}

	private PathFilter ParseArrayIndexer(char indexerCloseChar)
	{
		int currentIndex = _currentIndex;
		int? num = null;
		List<int> list = null;
		int num2 = 0;
		int? start = null;
		int? end = null;
		int? step = null;
		while (_currentIndex < _expression.Length)
		{
			char c = _expression[_currentIndex];
			if (c == ' ')
			{
				num = _currentIndex;
				EatWhitespace();
				continue;
			}
			if (c == indexerCloseChar)
			{
				int num3 = (num ?? _currentIndex) - currentIndex;
				if (list != null)
				{
					if (num3 == 0)
					{
						throw new JsonException("Array index expected.");
					}
					int item = Convert.ToInt32(_expression.Substring(currentIndex, num3), CultureInfo.InvariantCulture);
					list.Add(item);
					return new ArrayMultipleIndexFilter
					{
						Indexes = list
					};
				}
				if (num2 > 0)
				{
					if (num3 > 0)
					{
						int value = Convert.ToInt32(_expression.Substring(currentIndex, num3), CultureInfo.InvariantCulture);
						if (num2 == 1)
						{
							end = value;
						}
						else
						{
							step = value;
						}
					}
					return new ArraySliceFilter
					{
						Start = start,
						End = end,
						Step = step
					};
				}
				if (num3 == 0)
				{
					throw new JsonException("Array index expected.");
				}
				int value2 = Convert.ToInt32(_expression.Substring(currentIndex, num3), CultureInfo.InvariantCulture);
				return new ArrayIndexFilter
				{
					Index = value2
				};
			}
			switch (c)
			{
			case ',':
			{
				int num5 = (num ?? _currentIndex) - currentIndex;
				if (num5 == 0)
				{
					throw new JsonException("Array index expected.");
				}
				if (list == null)
				{
					list = new List<int>();
				}
				string value4 = _expression.Substring(currentIndex, num5);
				list.Add(Convert.ToInt32(value4, CultureInfo.InvariantCulture));
				_currentIndex++;
				EatWhitespace();
				currentIndex = _currentIndex;
				num = null;
				break;
			}
			case '*':
				_currentIndex++;
				EnsureLength("Path ended with open indexer.");
				EatWhitespace();
				if (_expression[_currentIndex] != indexerCloseChar)
				{
					throw new JsonException("Unexpected character while parsing path indexer: " + c);
				}
				return new ArrayIndexFilter();
			case ':':
			{
				int num4 = (num ?? _currentIndex) - currentIndex;
				if (num4 > 0)
				{
					int value3 = Convert.ToInt32(_expression.Substring(currentIndex, num4), CultureInfo.InvariantCulture);
					switch (num2)
					{
					case 0:
						start = value3;
						break;
					case 1:
						end = value3;
						break;
					default:
						step = value3;
						break;
					}
				}
				num2++;
				_currentIndex++;
				EatWhitespace();
				currentIndex = _currentIndex;
				num = null;
				break;
			}
			default:
				if (!char.IsDigit(c) && c != '-')
				{
					throw new JsonException("Unexpected character while parsing path indexer: " + c);
				}
				if (num.HasValue)
				{
					throw new JsonException("Unexpected character while parsing path indexer: " + c);
				}
				_currentIndex++;
				break;
			}
		}
		throw new JsonException("Path ended with open indexer.");
	}

	private void EatWhitespace()
	{
		while (_currentIndex < _expression.Length && _expression[_currentIndex] == ' ')
		{
			_currentIndex++;
		}
	}

	private PathFilter ParseQuery(char indexerCloseChar)
	{
		_currentIndex++;
		EnsureLength("Path ended with open indexer.");
		if (_expression[_currentIndex] != '(')
		{
			throw new JsonException("Unexpected character while parsing path indexer: " + _expression[_currentIndex]);
		}
		_currentIndex++;
		QueryExpression expression = ParseExpression();
		_currentIndex++;
		EnsureLength("Path ended with open indexer.");
		EatWhitespace();
		if (_expression[_currentIndex] != indexerCloseChar)
		{
			throw new JsonException("Unexpected character while parsing path indexer: " + _expression[_currentIndex]);
		}
		return new QueryFilter
		{
			Expression = expression
		};
	}

	private QueryExpression ParseExpression()
	{
		QueryExpression queryExpression = null;
		CompositeExpression compositeExpression = null;
		while (_currentIndex < _expression.Length)
		{
			EatWhitespace();
			if (_expression[_currentIndex] != '@')
			{
				throw new JsonException("Unexpected character while parsing path query: " + _expression[_currentIndex]);
			}
			_currentIndex++;
			List<PathFilter> list = new List<PathFilter>();
			if (ParsePath(list, _currentIndex, query: true))
			{
				throw new JsonException("Path ended with open query.");
			}
			EatWhitespace();
			EnsureLength("Path ended with open query.");
			object value = null;
			QueryOperator queryOperator;
			if (_expression[_currentIndex] == ')' || _expression[_currentIndex] == '|' || _expression[_currentIndex] == '&')
			{
				queryOperator = QueryOperator.Exists;
			}
			else
			{
				queryOperator = ParseOperator();
				EatWhitespace();
				EnsureLength("Path ended with open query.");
				value = ParseValue();
				EatWhitespace();
				EnsureLength("Path ended with open query.");
			}
			BooleanQueryExpression booleanQueryExpression = new BooleanQueryExpression
			{
				Path = list,
				Operator = queryOperator,
				Value = ((queryOperator != QueryOperator.Exists) ? new JValue(value) : null)
			};
			if (_expression[_currentIndex] == ')')
			{
				if (compositeExpression != null)
				{
					compositeExpression.Expressions.Add(booleanQueryExpression);
					return queryExpression;
				}
				return booleanQueryExpression;
			}
			if (_expression[_currentIndex] == '&' && Match("&&"))
			{
				if (compositeExpression == null || compositeExpression.Operator != QueryOperator.And)
				{
					CompositeExpression compositeExpression2 = new CompositeExpression
					{
						Operator = QueryOperator.And
					};
					compositeExpression?.Expressions.Add(compositeExpression2);
					compositeExpression = compositeExpression2;
					if (queryExpression == null)
					{
						queryExpression = compositeExpression;
					}
				}
				compositeExpression.Expressions.Add(booleanQueryExpression);
			}
			if (_expression[_currentIndex] != '|' || !Match("||"))
			{
				continue;
			}
			if (compositeExpression == null || compositeExpression.Operator != QueryOperator.Or)
			{
				CompositeExpression compositeExpression3 = new CompositeExpression
				{
					Operator = QueryOperator.Or
				};
				compositeExpression?.Expressions.Add(compositeExpression3);
				compositeExpression = compositeExpression3;
				if (queryExpression == null)
				{
					queryExpression = compositeExpression;
				}
			}
			compositeExpression.Expressions.Add(booleanQueryExpression);
		}
		throw new JsonException("Path ended with open query.");
	}

	private object ParseValue()
	{
		char c = _expression[_currentIndex];
		if (c == '\'')
		{
			return ReadQuotedString();
		}
		if (char.IsDigit(c) || c == '-')
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(c);
			_currentIndex++;
			while (_currentIndex < _expression.Length)
			{
				c = _expression[_currentIndex];
				if (c == ' ' || c == ')')
				{
					string text = stringBuilder.ToString();
					if (text.IndexOfAny(new char[3] { '.', 'E', 'e' }) != -1)
					{
						if (double.TryParse(text, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out var result))
						{
							return result;
						}
						throw new JsonException("Could not read query value.");
					}
					if (long.TryParse(text, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result2))
					{
						return result2;
					}
					throw new JsonException("Could not read query value.");
				}
				stringBuilder.Append(c);
				_currentIndex++;
			}
		}
		else
		{
			switch (c)
			{
			case 't':
				if (Match("true"))
				{
					return true;
				}
				break;
			case 'f':
				if (Match("false"))
				{
					return false;
				}
				break;
			case 'n':
				if (Match("null"))
				{
					return null;
				}
				break;
			}
		}
		throw new JsonException("Could not read query value.");
	}

	private string ReadQuotedString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		_currentIndex++;
		while (_currentIndex < _expression.Length)
		{
			char c = _expression[_currentIndex];
			if (c == '\\' && _currentIndex + 1 < _expression.Length)
			{
				_currentIndex++;
				if (_expression[_currentIndex] == '\'')
				{
					stringBuilder.Append('\'');
				}
				else
				{
					if (_expression[_currentIndex] != '\\')
					{
						throw new JsonException("Unknown escape chracter: \\" + _expression[_currentIndex]);
					}
					stringBuilder.Append('\\');
				}
				_currentIndex++;
			}
			else
			{
				if (c == '\'')
				{
					_currentIndex++;
					return stringBuilder.ToString();
				}
				_currentIndex++;
				stringBuilder.Append(c);
			}
		}
		throw new JsonException("Path ended with an open string.");
	}

	private bool Match(string s)
	{
		int num = _currentIndex;
		foreach (char c in s)
		{
			if (num < _expression.Length && _expression[num] == c)
			{
				num++;
				continue;
			}
			return false;
		}
		_currentIndex = num;
		return true;
	}

	private QueryOperator ParseOperator()
	{
		if (_currentIndex + 1 >= _expression.Length)
		{
			throw new JsonException("Path ended with open query.");
		}
		if (Match("=="))
		{
			return QueryOperator.Equals;
		}
		if (Match("!=") || Match("<>"))
		{
			return QueryOperator.NotEquals;
		}
		if (Match("<="))
		{
			return QueryOperator.LessThanOrEquals;
		}
		if (Match("<"))
		{
			return QueryOperator.LessThan;
		}
		if (Match(">="))
		{
			return QueryOperator.GreaterThanOrEquals;
		}
		if (Match(">"))
		{
			return QueryOperator.GreaterThan;
		}
		throw new JsonException("Could not read query operator.");
	}

	private PathFilter ParseQuotedField(char indexerCloseChar)
	{
		List<string> list = null;
		while (_currentIndex < _expression.Length)
		{
			string text = ReadQuotedString();
			EatWhitespace();
			EnsureLength("Path ended with open indexer.");
			if (_expression[_currentIndex] == indexerCloseChar)
			{
				if (list != null)
				{
					list.Add(text);
					return new FieldMultipleFilter
					{
						Names = list
					};
				}
				return new FieldFilter
				{
					Name = text
				};
			}
			if (_expression[_currentIndex] == ',')
			{
				_currentIndex++;
				EatWhitespace();
				if (list == null)
				{
					list = new List<string>();
				}
				list.Add(text);
				continue;
			}
			throw new JsonException("Unexpected character while parsing path indexer: " + _expression[_currentIndex]);
		}
		throw new JsonException("Path ended with open indexer.");
	}

	private void EnsureLength(string message)
	{
		if (_currentIndex >= _expression.Length)
		{
			throw new JsonException(message);
		}
	}

	internal IEnumerable<JToken> Evaluate(JToken t, bool errorWhenNoMatch)
	{
		return Evaluate(Filters, t, errorWhenNoMatch);
	}

	internal static IEnumerable<JToken> Evaluate(List<PathFilter> filters, JToken t, bool errorWhenNoMatch)
	{
		IEnumerable<JToken> enumerable = new JToken[1] { t };
		foreach (PathFilter filter in filters)
		{
			enumerable = filter.ExecuteFilter(enumerable, errorWhenNoMatch);
		}
		return enumerable;
	}
}


using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal abstract class PathFilter
{
	public abstract IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch);

	protected static JToken GetTokenIndex(JToken t, bool errorWhenNoMatch, int index)
	{
		JArray jArray = t as JArray;
		JConstructor jConstructor = t as JConstructor;
		if (jArray != null)
		{
			if (jArray.Count <= index)
			{
				if (errorWhenNoMatch)
				{
					throw new JsonException("Index {0} outside the bounds of JArray.".FormatWith(CultureInfo.InvariantCulture, index));
				}
				return null;
			}
			return jArray[index];
		}
		if (jConstructor != null)
		{
			if (jConstructor.Count <= index)
			{
				if (errorWhenNoMatch)
				{
					throw new JsonException("Index {0} outside the bounds of JConstructor.".FormatWith(CultureInfo.InvariantCulture, index));
				}
				return null;
			}
			return jConstructor[index];
		}
		if (errorWhenNoMatch)
		{
			throw new JsonException("Index {0} not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, index, t.GetType().Name));
		}
		return null;
	}
}


using Newtonsoft.Json.Shims;

[Preserve]
internal enum QueryOperator
{
	None,
	Equals,
	NotEquals,
	Exists,
	LessThan,
	LessThanOrEquals,
	GreaterThan,
	GreaterThanOrEquals,
	And,
	Or
}


using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Shims;

[Preserve]
internal abstract class QueryExpression
{
	public QueryOperator Operator { get; set; }

	public abstract bool IsMatch(JToken t);
}


using System;
using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Shims;

[Preserve]
internal class CompositeExpression : QueryExpression
{
	public List<QueryExpression> Expressions { get; set; }

	public CompositeExpression()
	{
		Expressions = new List<QueryExpression>();
	}

	public override bool IsMatch(JToken t)
	{
		switch (base.Operator)
		{
		case QueryOperator.And:
			foreach (QueryExpression expression in Expressions)
			{
				if (!expression.IsMatch(t))
				{
					return false;
				}
			}
			return true;
		case QueryOperator.Or:
			foreach (QueryExpression expression2 in Expressions)
			{
				if (expression2.IsMatch(t))
				{
					return true;
				}
			}
			return false;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class BooleanQueryExpression : QueryExpression
{
	public List<PathFilter> Path { get; set; }

	public JValue Value { get; set; }

	public override bool IsMatch(JToken t)
	{
		foreach (JToken item in JPath.Evaluate(Path, t, errorWhenNoMatch: false))
		{
			if (item is JValue jValue)
			{
				switch (base.Operator)
				{
				case QueryOperator.Equals:
					if (EqualsWithStringCoercion(jValue, Value))
					{
						return true;
					}
					break;
				case QueryOperator.NotEquals:
					if (!EqualsWithStringCoercion(jValue, Value))
					{
						return true;
					}
					break;
				case QueryOperator.GreaterThan:
					if (jValue.CompareTo(Value) > 0)
					{
						return true;
					}
					break;
				case QueryOperator.GreaterThanOrEquals:
					if (jValue.CompareTo(Value) >= 0)
					{
						return true;
					}
					break;
				case QueryOperator.LessThan:
					if (jValue.CompareTo(Value) < 0)
					{
						return true;
					}
					break;
				case QueryOperator.LessThanOrEquals:
					if (jValue.CompareTo(Value) <= 0)
					{
						return true;
					}
					break;
				case QueryOperator.Exists:
					return true;
				}
			}
			else
			{
				QueryOperator @operator = base.Operator;
				if (@operator == QueryOperator.NotEquals || @operator == QueryOperator.Exists)
				{
					return true;
				}
			}
		}
		return false;
	}

	private bool EqualsWithStringCoercion(JValue value, JValue queryValue)
	{
		if (value.Equals(queryValue))
		{
			return true;
		}
		if (queryValue.Type != JTokenType.String)
		{
			return false;
		}
		string b = (string)queryValue.Value;
		string a;
		switch (value.Type)
		{
		case JTokenType.Date:
		{
			using (StringWriter stringWriter = StringUtils.CreateStringWriter(64))
			{
				if (value.Value is DateTimeOffset)
				{
					DateTimeUtils.WriteDateTimeOffsetString(stringWriter, (DateTimeOffset)value.Value, DateFormatHandling.IsoDateFormat, null, CultureInfo.InvariantCulture);
				}
				else
				{
					DateTimeUtils.WriteDateTimeString(stringWriter, (DateTime)value.Value, DateFormatHandling.IsoDateFormat, null, CultureInfo.InvariantCulture);
				}
				a = stringWriter.ToString();
			}
			break;
		}
		case JTokenType.Bytes:
			a = Convert.ToBase64String((byte[])value.Value);
			break;
		case JTokenType.Guid:
		case JTokenType.TimeSpan:
			a = value.Value.ToString();
			break;
		case JTokenType.Uri:
			a = ((Uri)value.Value).OriginalString;
			break;
		default:
			return false;
		}
		return string.Equals(a, b, StringComparison.Ordinal);
	}
}


using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Shims;

[Preserve]
internal class QueryFilter : PathFilter
{
	public QueryExpression Expression { get; set; }

	public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
	{
		foreach (JToken item in current)
		{
			foreach (JToken item2 in (IEnumerable<JToken>)item)
			{
				if (Expression.IsMatch(item2))
				{
					yield return item2;
				}
			}
		}
	}
}


using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Shims;

[Preserve]
internal class ScanFilter : PathFilter
{
	public string Name { get; set; }

	public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
	{
		foreach (JToken root in current)
		{
			if (Name == null)
			{
				yield return root;
			}
			JToken value = root;
			JToken jToken = root;
			while (true)
			{
				if (jToken != null && jToken.HasValues)
				{
					value = jToken.First;
				}
				else
				{
					while (value != null && value != root && value == value.Parent.Last)
					{
						value = value.Parent;
					}
					if (value == null || value == root)
					{
						break;
					}
					value = value.Next;
				}
				if (value is JProperty jProperty)
				{
					if (jProperty.Name == Name)
					{
						yield return jProperty.Value;
					}
				}
				else if (Name == null)
				{
					yield return value;
				}
				jToken = value as JContainer;
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class BinaryConverter : JsonConverter
{
	private const string BinaryTypeName = "System.Data.Linq.Binary";

	private const string BinaryToArrayName = "ToArray";

	private ReflectionObject _reflectionObject;

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		if (value == null)
		{
			writer.WriteNull();
			return;
		}
		byte[] byteArray = GetByteArray(value);
		writer.WriteValue(byteArray);
	}

	private byte[] GetByteArray(object value)
	{
		if (value.GetType().AssignableToTypeName("System.Data.Linq.Binary"))
		{
			EnsureReflectionObject(value.GetType());
			return (byte[])_reflectionObject.GetValue(value, "ToArray");
		}
		throw new JsonSerializationException("Unexpected value type when writing binary: {0}".FormatWith(CultureInfo.InvariantCulture, value.GetType()));
	}

	private void EnsureReflectionObject(Type t)
	{
		if (_reflectionObject == null)
		{
			_reflectionObject = ReflectionObject.Create(t, t.GetConstructor(new Type[1] { typeof(byte[]) }), "ToArray");
		}
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		if (reader.TokenType == JsonToken.Null)
		{
			if (!ReflectionUtils.IsNullable(objectType))
			{
				throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
			}
			return null;
		}
		byte[] array;
		if (reader.TokenType == JsonToken.StartArray)
		{
			array = ReadByteArray(reader);
		}
		else
		{
			if (reader.TokenType != JsonToken.String)
			{
				throw JsonSerializationException.Create(reader, "Unexpected token parsing binary. Expected String or StartArray, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			array = Convert.FromBase64String(reader.Value.ToString());
		}
		Type type = (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType);
		if (type.AssignableToTypeName("System.Data.Linq.Binary"))
		{
			EnsureReflectionObject(type);
			return _reflectionObject.Creator(array);
		}
		throw JsonSerializationException.Create(reader, "Unexpected object type when writing binary: {0}".FormatWith(CultureInfo.InvariantCulture, objectType));
	}

	private byte[] ReadByteArray(JsonReader reader)
	{
		List<byte> list = new List<byte>();
		while (reader.Read())
		{
			switch (reader.TokenType)
			{
			case JsonToken.Integer:
				list.Add(Convert.ToByte(reader.Value, CultureInfo.InvariantCulture));
				break;
			case JsonToken.EndArray:
				return list.ToArray();
			default:
				throw JsonSerializationException.Create(reader, "Unexpected token when reading bytes: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			case JsonToken.Comment:
				break;
			}
		}
		throw JsonSerializationException.Create(reader, "Unexpected end when reading bytes.");
	}

	public override bool CanConvert(Type objectType)
	{
		if (objectType.AssignableToTypeName("System.Data.Linq.Binary"))
		{
			return true;
		}
		return false;
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEngine;

public class ColorConverter : JsonConverter
{
	public override bool CanRead => true;

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (value == null)
		{
			writer.WriteNull();
			return;
		}
		Color val = (Color)value;
		writer.WriteStartObject();
		writer.WritePropertyName("a");
		writer.WriteValue(val.a);
		writer.WritePropertyName("r");
		writer.WriteValue(val.r);
		writer.WritePropertyName("g");
		writer.WriteValue(val.g);
		writer.WritePropertyName("b");
		writer.WriteValue(val.b);
		writer.WriteEndObject();
	}

	public override bool CanConvert(Type objectType)
	{
		if ((object)objectType != typeof(Color))
		{
			return (object)objectType == typeof(Color32);
		}
		return true;
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (reader.TokenType == JsonToken.Null)
		{
			return (object)default(Color);
		}
		JObject jObject = JObject.Load(reader);
		if ((object)objectType == typeof(Color32))
		{
			return (object)new Color32((byte)jObject["r"], (byte)jObject["g"], (byte)jObject["b"], (byte)jObject["a"]);
		}
		return (object)new Color((float)jObject["r"], (float)jObject["g"], (float)jObject["b"], (float)jObject["a"]);
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Preserve]
public abstract class CustomCreationConverter<T> : JsonConverter
{
	public override bool CanWrite => false;

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		throw new NotSupportedException("CustomCreationConverter should only be used while deserializing.");
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		if (reader.TokenType == JsonToken.Null)
		{
			return null;
		}
		T val = Create(objectType);
		if (val == null)
		{
			throw new JsonSerializationException("No object created.");
		}
		serializer.Populate(reader, val);
		return val;
	}

	public abstract T Create(Type objectType);

	public override bool CanConvert(Type objectType)
	{
		return typeof(T).IsAssignableFrom(objectType);
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;

[Preserve]
public abstract class DateTimeConverterBase : JsonConverter
{
	public override bool CanConvert(Type objectType)
	{
		if ((object)objectType == typeof(DateTime) || (object)objectType == typeof(DateTime?))
		{
			return true;
		}
		if ((object)objectType == typeof(DateTimeOffset) || (object)objectType == typeof(DateTimeOffset?))
		{
			return true;
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using UnityEngine;

public class EnumerableVectorConverter<T> : JsonConverter
{
	private static readonly VectorConverter VectorConverter = new VectorConverter();

	public override bool CanRead => true;

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		if (value == null)
		{
			writer.WriteNull();
		}
		T[] array = (value as IEnumerable<T>)?.ToArray();
		if (array == null)
		{
			writer.WriteNull();
			return;
		}
		writer.WriteStartArray();
		for (int i = 0; i < array.Length; i++)
		{
			VectorConverter.WriteJson(writer, array[i], serializer);
		}
		writer.WriteEndArray();
	}

	public override bool CanConvert(Type objectType)
	{
		if (!typeof(IEnumerable<Vector2>).IsAssignableFrom(objectType) && !typeof(IEnumerable<Vector3>).IsAssignableFrom(objectType))
		{
			return typeof(IEnumerable<Vector4>).IsAssignableFrom(objectType);
		}
		return true;
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		if (reader.TokenType == JsonToken.Null)
		{
			return null;
		}
		List<T> list = new List<T>();
		JObject jObject = JObject.Load(reader);
		for (int i = 0; i < jObject.Count; i++)
		{
			list.Add(JsonConvert.DeserializeObject<T>(jObject[i].ToString()));
		}
		return list;
	}
}


using System;
using System.Collections.Generic;
using System.Reflection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Utilities;

public class HashSetConverter : JsonConverter
{
	public override bool CanWrite => false;

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		bool flag = serializer.ObjectCreationHandling == ObjectCreationHandling.Replace;
		if (reader.TokenType == JsonToken.Null)
		{
			if (!flag)
			{
				return existingValue;
			}
			return null;
		}
		object obj = ((!flag && existingValue != null) ? existingValue : Activator.CreateInstance(objectType));
		Type objectType2 = objectType.GetGenericArguments()[0];
		MethodInfo method = objectType.GetMethod("Add");
		JArray jArray = JArray.Load(reader);
		for (int i = 0; i < jArray.Count; i++)
		{
			object obj2 = serializer.Deserialize(jArray[i].CreateReader(), objectType2);
			method.Invoke(obj, new object[1] { obj2 });
		}
		return obj;
	}

	public override bool CanConvert(Type objectType)
	{
		if (objectType.IsGenericType())
		{
			return (object)objectType.GetGenericTypeDefinition() == typeof(HashSet<>);
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class KeyValuePairConverter : JsonConverter
{
	private const string KeyName = "Key";

	private const string ValueName = "Value";

	private static readonly ThreadSafeStore<Type, ReflectionObject> ReflectionObjectPerType = new ThreadSafeStore<Type, ReflectionObject>(InitializeReflectionObject);

	private static ReflectionObject InitializeReflectionObject(Type t)
	{
		Type[] genericArguments = t.GetGenericArguments();
		Type type = ((IList<Type>)genericArguments)[0];
		Type type2 = ((IList<Type>)genericArguments)[1];
		return ReflectionObject.Create(t, t.GetConstructor(new Type[2] { type, type2 }), "Key", "Value");
	}

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		ReflectionObject reflectionObject = ReflectionObjectPerType.Get(value.GetType());
		DefaultContractResolver defaultContractResolver = serializer.ContractResolver as DefaultContractResolver;
		writer.WriteStartObject();
		writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Key") : "Key");
		serializer.Serialize(writer, reflectionObject.GetValue(value, "Key"), reflectionObject.GetType("Key"));
		writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Value") : "Value");
		serializer.Serialize(writer, reflectionObject.GetValue(value, "Value"), reflectionObject.GetType("Value"));
		writer.WriteEndObject();
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		if (reader.TokenType == JsonToken.Null)
		{
			if (!ReflectionUtils.IsNullableType(objectType))
			{
				throw JsonSerializationException.Create(reader, "Cannot convert null value to KeyValuePair.");
			}
			return null;
		}
		object obj = null;
		object obj2 = null;
		reader.ReadAndAssert();
		Type key = (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType);
		ReflectionObject reflectionObject = ReflectionObjectPerType.Get(key);
		while (reader.TokenType == JsonToken.PropertyName)
		{
			string a = reader.Value.ToString();
			if (string.Equals(a, "Key", StringComparison.OrdinalIgnoreCase))
			{
				reader.ReadAndAssert();
				obj = serializer.Deserialize(reader, reflectionObject.GetType("Key"));
			}
			else if (string.Equals(a, "Value", StringComparison.OrdinalIgnoreCase))
			{
				reader.ReadAndAssert();
				obj2 = serializer.Deserialize(reader, reflectionObject.GetType("Value"));
			}
			else
			{
				reader.Skip();
			}
			reader.ReadAndAssert();
		}
		return reflectionObject.Creator(obj, obj2);
	}

	public override bool CanConvert(Type objectType)
	{
		Type type = (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType);
		if (type.IsValueType() && type.IsGenericType())
		{
			return (object)type.GetGenericTypeDefinition() == typeof(KeyValuePair<, >);
		}
		return false;
	}
}


using System;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class BsonObjectIdConverter : JsonConverter
{
	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		BsonObjectId bsonObjectId = (BsonObjectId)value;
		if (writer is BsonWriter bsonWriter)
		{
			bsonWriter.WriteObjectId(bsonObjectId.Value);
		}
		else
		{
			writer.WriteValue(bsonObjectId.Value);
		}
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		if (reader.TokenType != JsonToken.Bytes)
		{
			throw new JsonSerializationException("Expected Bytes but got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}
		return new BsonObjectId((byte[])reader.Value);
	}

	public override bool CanConvert(Type objectType)
	{
		return (object)objectType == typeof(BsonObjectId);
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEngine;

public class Matrix4x4Converter : JsonConverter
{
	public override bool CanRead => true;

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		if (value == null)
		{
			writer.WriteNull();
			return;
		}
		Matrix4x4 val = (Matrix4x4)value;
		writer.WriteStartObject();
		writer.WritePropertyName("m00");
		writer.WriteValue(val.m00);
		writer.WritePropertyName("m01");
		writer.WriteValue(val.m01);
		writer.WritePropertyName("m02");
		writer.WriteValue(val.m02);
		writer.WritePropertyName("m03");
		writer.WriteValue(val.m03);
		writer.WritePropertyName("m10");
		writer.WriteValue(val.m10);
		writer.WritePropertyName("m11");
		writer.WriteValue(val.m11);
		writer.WritePropertyName("m12");
		writer.WriteValue(val.m12);
		writer.WritePropertyName("m13");
		writer.WriteValue(val.m13);
		writer.WritePropertyName("m20");
		writer.WriteValue(val.m20);
		writer.WritePropertyName("m21");
		writer.WriteValue(val.m21);
		writer.WritePropertyName("m22");
		writer.WriteValue(val.m22);
		writer.WritePropertyName("m23");
		writer.WriteValue(val.m23);
		writer.WritePropertyName("m30");
		writer.WriteValue(val.m30);
		writer.WritePropertyName("m31");
		writer.WriteValue(val.m31);
		writer.WritePropertyName("m32");
		writer.WriteValue(val.m32);
		writer.WritePropertyName("m33");
		writer.WriteValue(val.m33);
		writer.WriteEnd();
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (reader.TokenType == JsonToken.Null)
		{
			return (object)default(Matrix4x4);
		}
		JObject jObject = JObject.Load(reader);
		Matrix4x4 val = default(Matrix4x4);
		val.m00 = (float)jObject["m00"];
		val.m01 = (float)jObject["m01"];
		val.m02 = (float)jObject["m02"];
		val.m03 = (float)jObject["m03"];
		val.m20 = (float)jObject["m20"];
		val.m21 = (float)jObject["m21"];
		val.m22 = (float)jObject["m22"];
		val.m23 = (float)jObject["m23"];
		val.m30 = (float)jObject["m30"];
		val.m31 = (float)jObject["m31"];
		val.m32 = (float)jObject["m32"];
		val.m33 = (float)jObject["m33"];
		return val;
	}

	public override bool CanConvert(Type objectType)
	{
		return (object)objectType == typeof(Matrix4x4);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEngine;

public class QuaternionConverter : JsonConverter
{
	public override bool CanRead => true;

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = (Quaternion)value;
		writer.WriteStartObject();
		writer.WritePropertyName("w");
		writer.WriteValue(val.w);
		writer.WritePropertyName("x");
		writer.WriteValue(val.x);
		writer.WritePropertyName("y");
		writer.WriteValue(val.y);
		writer.WritePropertyName("z");
		writer.WriteValue(val.z);
		writer.WritePropertyName("eulerAngles");
		writer.WriteStartObject();
		writer.WritePropertyName("x");
		writer.WriteValue(((Quaternion)(ref val)).eulerAngles.x);
		writer.WritePropertyName("y");
		writer.WriteValue(((Quaternion)(ref val)).eulerAngles.y);
		writer.WritePropertyName("z");
		writer.WriteValue(((Quaternion)(ref val)).eulerAngles.z);
		writer.WriteEndObject();
		writer.WriteEndObject();
	}

	public override bool CanConvert(Type objectType)
	{
		return (object)objectType == typeof(Quaternion);
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		JObject jObject = JObject.Load(reader);
		List<JProperty> source = jObject.Properties().ToList();
		Quaternion val = default(Quaternion);
		if (source.Any((JProperty p) => p.Name == "w"))
		{
			val.w = (float)jObject["w"];
		}
		if (source.Any((JProperty p) => p.Name == "x"))
		{
			val.x = (float)jObject["x"];
		}
		if (source.Any((JProperty p) => p.Name == "y"))
		{
			val.y = (float)jObject["y"];
		}
		if (source.Any((JProperty p) => p.Name == "z"))
		{
			val.z = (float)jObject["z"];
		}
		if (source.Any((JProperty p) => p.Name == "eulerAngles"))
		{
			JToken jToken = jObject["eulerAngles"];
			Vector3 eulerAngles = default(Vector3);
			eulerAngles.x = (float)jToken["x"];
			eulerAngles.y = (float)jToken["y"];
			eulerAngles.z = (float)jToken["z"];
			((Quaternion)(ref val)).eulerAngles = eulerAngles;
		}
		return val;
	}
}


using System;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;

[Preserve]
public class RegexConverter : JsonConverter
{
	private const string PatternName = "Pattern";

	private const string OptionsName = "Options";

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		Regex regex = (Regex)value;
		if (writer is BsonWriter writer2)
		{
			WriteBson(writer2, regex);
		}
		else
		{
			WriteJson(writer, regex, serializer);
		}
	}

	private bool HasFlag(RegexOptions options, RegexOptions flag)
	{
		return (options & flag) == flag;
	}

	private void WriteBson(BsonWriter writer, Regex regex)
	{
		string text = null;
		if (HasFlag(regex.Options, RegexOptions.IgnoreCase))
		{
			text += "i";
		}
		if (HasFlag(regex.Options, RegexOptions.Multiline))
		{
			text += "m";
		}
		if (HasFlag(regex.Options, RegexOptions.Singleline))
		{
			text += "s";
		}
		text += "u";
		if (HasFlag(regex.Options, RegexOptions.ExplicitCapture))
		{
			text += "x";
		}
		writer.WriteRegex(regex.ToString(), text);
	}

	private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer)
	{
		DefaultContractResolver defaultContractResolver = serializer.ContractResolver as DefaultContractResolver;
		writer.WriteStartObject();
		writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Pattern") : "Pattern");
		writer.WriteValue(regex.ToString());
		writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Options") : "Options");
		serializer.Serialize(writer, regex.Options);
		writer.WriteEndObject();
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		if (reader.TokenType == JsonToken.StartObject)
		{
			return ReadRegexObject(reader, serializer);
		}
		if (reader.TokenType == JsonToken.String)
		{
			return ReadRegexString(reader);
		}
		throw JsonSerializationException.Create(reader, "Unexpected token when reading Regex.");
	}

	private object ReadRegexString(JsonReader reader)
	{
		string obj = (string)reader.Value;
		int num = obj.LastIndexOf('/');
		string pattern = obj.Substring(1, num - 1);
		string text = obj.Substring(num + 1);
		RegexOptions regexOptions = RegexOptions.None;
		string text2 = text;
		for (int i = 0; i < text2.Length; i++)
		{
			switch (text2[i])
			{
			case 'i':
				regexOptions |= RegexOptions.IgnoreCase;
				break;
			case 'm':
				regexOptions |= RegexOptions.Multiline;
				break;
			case 's':
				regexOptions |= RegexOptions.Singleline;
				break;
			case 'x':
				regexOptions |= RegexOptions.ExplicitCapture;
				break;
			}
		}
		return new Regex(pattern, regexOptions);
	}

	private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer)
	{
		string text = null;
		RegexOptions? regexOptions = null;
		while (reader.Read())
		{
			switch (reader.TokenType)
			{
			case JsonToken.PropertyName:
			{
				string a = reader.Value.ToString();
				if (!reader.Read())
				{
					throw JsonSerializationException.Create(reader, "Unexpected end when reading Regex.");
				}
				if (string.Equals(a, "Pattern", StringComparison.OrdinalIgnoreCase))
				{
					text = (string)reader.Value;
				}
				else if (string.Equals(a, "Options", StringComparison.OrdinalIgnoreCase))
				{
					regexOptions = serializer.Deserialize<RegexOptions>(reader);
				}
				else
				{
					reader.Skip();
				}
				break;
			}
			case JsonToken.EndObject:
				if (text == null)
				{
					throw JsonSerializationException.Create(reader, "Error deserializing Regex. No pattern found.");
				}
				return new Regex(text, regexOptions ?? RegexOptions.None);
			}
		}
		throw JsonSerializationException.Create(reader, "Unexpected end when reading Regex.");
	}

	public override bool CanConvert(Type objectType)
	{
		return (object)objectType == typeof(Regex);
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEngine;

public class ResolutionConverter : JsonConverter
{
	public override bool CanRead => true;

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Resolution val = (Resolution)value;
		writer.WriteStartObject();
		writer.WritePropertyName("height");
		writer.WriteValue(((Resolution)(ref val)).height);
		writer.WritePropertyName("width");
		writer.WriteValue(((Resolution)(ref val)).width);
		writer.WritePropertyName("refreshRate");
		writer.WriteValue(((Resolution)(ref val)).refreshRate);
		writer.WriteEndObject();
	}

	public override bool CanConvert(Type objectType)
	{
		return (object)objectType == typeof(Resolution);
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		JObject jObject = JObject.Load(reader);
		Resolution val = default(Resolution);
		((Resolution)(ref val)).height = (int)jObject["height"];
		((Resolution)(ref val)).width = (int)jObject["width"];
		((Resolution)(ref val)).refreshRate = (int)jObject["refreshRate"];
		return val;
	}
}


using System;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class StringEnumConverter : JsonConverter
{
	public bool CamelCaseText { get; set; }

	public bool AllowIntegerValues { get; set; }

	public StringEnumConverter()
	{
		AllowIntegerValues = true;
	}

	public StringEnumConverter(bool camelCaseText)
		: this()
	{
		CamelCaseText = camelCaseText;
	}

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		if (value == null)
		{
			writer.WriteNull();
			return;
		}
		Enum @enum = (Enum)value;
		string text = @enum.ToString("G");
		if (char.IsNumber(text[0]) || text[0] == '-')
		{
			writer.WriteValue(value);
			return;
		}
		string value2 = EnumUtils.ToEnumName(@enum.GetType(), text, CamelCaseText);
		writer.WriteValue(value2);
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		if (reader.TokenType == JsonToken.Null)
		{
			if (!ReflectionUtils.IsNullableType(objectType))
			{
				throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
			}
			return null;
		}
		bool flag = ReflectionUtils.IsNullableType(objectType);
		Type type = (flag ? Nullable.GetUnderlyingType(objectType) : objectType);
		try
		{
			if (reader.TokenType == JsonToken.String)
			{
				return EnumUtils.ParseEnumName(reader.Value.ToString(), flag, type);
			}
			if (reader.TokenType == JsonToken.Integer)
			{
				if (!AllowIntegerValues)
				{
					throw JsonSerializationException.Create(reader, "Integer value {0} is not allowed.".FormatWith(CultureInfo.InvariantCulture, reader.Value));
				}
				return ConvertUtils.ConvertOrCast(reader.Value, CultureInfo.InvariantCulture, type);
			}
		}
		catch (Exception ex)
		{
			throw JsonSerializationException.Create(reader, "Error converting value {0} to type '{1}'.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.FormatValueForPrint(reader.Value), objectType), ex);
		}
		throw JsonSerializationException.Create(reader, "Unexpected token {0} when parsing enum.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
	}

	public override bool CanConvert(Type objectType)
	{
		return (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType).IsEnum();
	}
}


using System;
using Newtonsoft.Json;

public class UriConverter : JsonConverter
{
	public override bool CanConvert(Type objectType)
	{
		return (object)objectType == typeof(Uri);
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		return reader.TokenType switch
		{
			JsonToken.String => new Uri((string)reader.Value), 
			JsonToken.Null => null, 
			_ => throw new InvalidOperationException("Unhandled case for UriConverter. Check to see if this converter has been applied to the wrong serialization type."), 
		};
	}

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		if (value == null)
		{
			writer.WriteNull();
			return;
		}
		Uri uri = value as Uri;
		if (uri == null)
		{
			throw new InvalidOperationException("Unhandled case for UriConverter. Check to see if this converter has been applied to the wrong serialization type.");
		}
		writer.WriteValue(uri.OriginalString);
	}
}


using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Shims;
using UnityEngine;

[Preserve]
public class VectorConverter : JsonConverter
{
	private static readonly Type V2 = typeof(Vector2);

	private static readonly Type V3 = typeof(Vector3);

	private static readonly Type V4 = typeof(Vector4);

	public bool EnableVector2 { get; set; }

	public bool EnableVector3 { get; set; }

	public bool EnableVector4 { get; set; }

	public VectorConverter()
	{
		EnableVector2 = true;
		EnableVector3 = true;
		EnableVector4 = true;
	}

	public VectorConverter(bool enableVector2, bool enableVector3, bool enableVector4)
		: this()
	{
		EnableVector2 = enableVector2;
		EnableVector3 = enableVector3;
		EnableVector4 = enableVector4;
	}

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (value == null)
		{
			writer.WriteNull();
			return;
		}
		Type type = value.GetType();
		if ((object)type == V2)
		{
			Vector2 val = (Vector2)value;
			WriteVector(writer, val.x, val.y, null, null);
		}
		else if ((object)type == V3)
		{
			Vector3 val2 = (Vector3)value;
			WriteVector(writer, val2.x, val2.y, val2.z, null);
		}
		else if ((object)type == V4)
		{
			Vector4 val3 = (Vector4)value;
			WriteVector(writer, val3.x, val3.y, val3.z, val3.w);
		}
		else
		{
			writer.WriteNull();
		}
	}

	private static void WriteVector(JsonWriter writer, float x, float y, float? z, float? w)
	{
		writer.WriteStartObject();
		writer.WritePropertyName("x");
		writer.WriteValue(x);
		writer.WritePropertyName("y");
		writer.WriteValue(y);
		if (z.HasValue)
		{
			writer.WritePropertyName("z");
			writer.WriteValue(z.Value);
			if (w.HasValue)
			{
				writer.WritePropertyName("w");
				writer.WriteValue(w.Value);
			}
		}
		writer.WriteEndObject();
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if ((object)objectType == V2)
		{
			return PopulateVector2(reader);
		}
		if ((object)objectType == V3)
		{
			return PopulateVector3(reader);
		}
		return PopulateVector4(reader);
	}

	public override bool CanConvert(Type objectType)
	{
		if ((!EnableVector2 || (object)objectType != V2) && (!EnableVector3 || (object)objectType != V3))
		{
			if (EnableVector4)
			{
				return (object)objectType == V4;
			}
			return false;
		}
		return true;
	}

	private static Vector2 PopulateVector2(JsonReader reader)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Vector2 result = default(Vector2);
		if (reader.TokenType != JsonToken.Null)
		{
			JObject jObject = JObject.Load(reader);
			result.x = jObject["x"].Value<float>();
			result.y = jObject["y"].Value<float>();
		}
		return result;
	}

	private static Vector3 PopulateVector3(JsonReader reader)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = default(Vector3);
		if (reader.TokenType != JsonToken.Null)
		{
			JObject jObject = JObject.Load(reader);
			result.x = jObject["x"].Value<float>();
			result.y = jObject["y"].Value<float>();
			result.z = jObject["z"].Value<float>();
		}
		return result;
	}

	private static Vector4 PopulateVector4(JsonReader reader)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		Vector4 result = default(Vector4);
		if (reader.TokenType != JsonToken.Null)
		{
			JObject jObject = JObject.Load(reader);
			result.x = jObject["x"].Value<float>();
			result.y = jObject["y"].Value<float>();
			result.z = jObject["z"].Value<float>();
			result.w = jObject["w"].Value<float>();
		}
		return result;
	}
}


using System;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class VersionConverter : JsonConverter
{
	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		if (value == null)
		{
			writer.WriteNull();
			return;
		}
		if (value is Version)
		{
			writer.WriteValue(value.ToString());
			return;
		}
		throw new JsonSerializationException("Expected Version object value");
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		if (reader.TokenType == JsonToken.Null)
		{
			return null;
		}
		if (reader.TokenType == JsonToken.String)
		{
			try
			{
				return new Version((string)reader.Value);
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(reader, "Error parsing version string: {0}".FormatWith(CultureInfo.InvariantCulture, reader.Value), ex);
			}
		}
		throw JsonSerializationException.Create(reader, "Unexpected token or value when parsing version. Token: {0}, Value: {1}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType, reader.Value));
	}

	public override bool CanConvert(Type objectType)
	{
		return (object)objectType == typeof(Version);
	}
}


using System;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class IsoDateTimeConverter : DateTimeConverterBase
{
	private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

	private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;

	private string _dateTimeFormat;

	private CultureInfo _culture;

	public DateTimeStyles DateTimeStyles
	{
		get
		{
			return _dateTimeStyles;
		}
		set
		{
			_dateTimeStyles = value;
		}
	}

	public string DateTimeFormat
	{
		get
		{
			return _dateTimeFormat ?? string.Empty;
		}
		set
		{
			_dateTimeFormat = StringUtils.NullEmptyString(value);
		}
	}

	public CultureInfo Culture
	{
		get
		{
			return _culture ?? CultureInfo.CurrentCulture;
		}
		set
		{
			_culture = value;
		}
	}

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		string value2;
		if (value is DateTime dateTime)
		{
			if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
			{
				dateTime = dateTime.ToUniversalTime();
			}
			value2 = dateTime.ToString(_dateTimeFormat ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK", Culture);
		}
		else
		{
			if (!(value is DateTimeOffset dateTimeOffset))
			{
				throw new JsonSerializationException("Unexpected value when converting date. Expected DateTime or DateTimeOffset, got {0}.".FormatWith(CultureInfo.InvariantCulture, ReflectionUtils.GetObjectType(value)));
			}
			if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
			{
				dateTimeOffset = dateTimeOffset.ToUniversalTime();
			}
			value2 = dateTimeOffset.ToString(_dateTimeFormat ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK", Culture);
		}
		writer.WriteValue(value2);
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		bool flag = ReflectionUtils.IsNullableType(objectType);
		Type type = (flag ? Nullable.GetUnderlyingType(objectType) : objectType);
		if (reader.TokenType == JsonToken.Null)
		{
			if (!ReflectionUtils.IsNullableType(objectType))
			{
				throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
			}
			return null;
		}
		if (reader.TokenType == JsonToken.Date)
		{
			if ((object)type == typeof(DateTimeOffset))
			{
				if (!(reader.Value is DateTimeOffset))
				{
					return new DateTimeOffset((DateTime)reader.Value);
				}
				return reader.Value;
			}
			if (reader.Value is DateTimeOffset)
			{
				return ((DateTimeOffset)reader.Value).DateTime;
			}
			return reader.Value;
		}
		if (reader.TokenType != JsonToken.String)
		{
			throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected String, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}
		string text = reader.Value.ToString();
		if (string.IsNullOrEmpty(text) && flag)
		{
			return null;
		}
		if ((object)type == typeof(DateTimeOffset))
		{
			if (!string.IsNullOrEmpty(_dateTimeFormat))
			{
				return DateTimeOffset.ParseExact(text, _dateTimeFormat, Culture, _dateTimeStyles);
			}
			return DateTimeOffset.Parse(text, Culture, _dateTimeStyles);
		}
		if (!string.IsNullOrEmpty(_dateTimeFormat))
		{
			return DateTime.ParseExact(text, _dateTimeFormat, Culture, _dateTimeStyles);
		}
		return DateTime.Parse(text, Culture, _dateTimeStyles);
	}
}


using System;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class JavaScriptDateTimeConverter : DateTimeConverterBase
{
	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		long value2;
		if (value is DateTime dateTime)
		{
			value2 = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTime.ToUniversalTime());
		}
		else
		{
			if (!(value is DateTimeOffset dateTimeOffset))
			{
				throw new JsonSerializationException("Expected date object value.");
			}
			value2 = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTimeOffset.ToUniversalTime().UtcDateTime);
		}
		writer.WriteStartConstructor("Date");
		writer.WriteValue(value2);
		writer.WriteEndConstructor();
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		if (reader.TokenType == JsonToken.Null)
		{
			if (!ReflectionUtils.IsNullable(objectType))
			{
				throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
			}
			return null;
		}
		if (reader.TokenType != JsonToken.StartConstructor || !string.Equals(reader.Value.ToString(), "Date", StringComparison.Ordinal))
		{
			throw JsonSerializationException.Create(reader, "Unexpected token or value when parsing date. Token: {0}, Value: {1}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType, reader.Value));
		}
		reader.Read();
		if (reader.TokenType != JsonToken.Integer)
		{
			throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected Integer, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}
		DateTime dateTime = DateTimeUtils.ConvertJavaScriptTicksToDateTime((long)reader.Value);
		reader.Read();
		if (reader.TokenType != JsonToken.EndConstructor)
		{
			throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected EndConstructor, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}
		if ((object)(ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType) == typeof(DateTimeOffset))
		{
			return new DateTimeOffset(dateTime);
		}
		return dateTime;
	}
}


using System.Xml;
using Newtonsoft.Json.Converters;

internal class XmlDocumentWrapper : XmlNodeWrapper, IXmlDocument, IXmlNode
{
	private readonly XmlDocument _document;

	public IXmlElement DocumentElement
	{
		get
		{
			if (_document.DocumentElement == null)
			{
				return null;
			}
			return new XmlElementWrapper(_document.DocumentElement);
		}
	}

	public XmlDocumentWrapper(XmlDocument document)
		: base((XmlNode)(object)document)
	{
		_document = document;
	}

	public IXmlNode CreateComment(string data)
	{
		return new XmlNodeWrapper((XmlNode)(object)_document.CreateComment(data));
	}

	public IXmlNode CreateTextNode(string text)
	{
		return new XmlNodeWrapper((XmlNode)(object)_document.CreateTextNode(text));
	}

	public IXmlNode CreateCDataSection(string data)
	{
		return new XmlNodeWrapper((XmlNode)(object)_document.CreateCDataSection(data));
	}

	public IXmlNode CreateWhitespace(string text)
	{
		return new XmlNodeWrapper((XmlNode)(object)_document.CreateWhitespace(text));
	}

	public IXmlNode CreateSignificantWhitespace(string text)
	{
		return new XmlNodeWrapper((XmlNode)(object)_document.CreateSignificantWhitespace(text));
	}

	public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
	{
		return new XmlDeclarationWrapper(_document.CreateXmlDeclaration(version, encoding, standalone));
	}

	public IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset)
	{
		return new XmlDocumentTypeWrapper(_document.CreateDocumentType(name, publicId, systemId, (string)null));
	}

	public IXmlNode CreateProcessingInstruction(string target, string data)
	{
		return new XmlNodeWrapper((XmlNode)(object)_document.CreateProcessingInstruction(target, data));
	}

	public IXmlElement CreateElement(string elementName)
	{
		return new XmlElementWrapper(_document.CreateElement(elementName));
	}

	public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
	{
		return new XmlElementWrapper(_document.CreateElement(qualifiedName, namespaceUri));
	}

	public IXmlNode CreateAttribute(string name, string value)
	{
		return new XmlNodeWrapper((XmlNode)(object)_document.CreateAttribute(name))
		{
			Value = value
		};
	}

	public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
	{
		return new XmlNodeWrapper((XmlNode)(object)_document.CreateAttribute(qualifiedName, namespaceUri))
		{
			Value = value
		};
	}
}


using System.Xml;
using Newtonsoft.Json.Converters;

internal class XmlElementWrapper : XmlNodeWrapper, IXmlElement, IXmlNode
{
	private readonly XmlElement _element;

	public bool IsEmpty => _element.IsEmpty;

	public XmlElementWrapper(XmlElement element)
		: base((XmlNode)(object)element)
	{
		_element = element;
	}

	public void SetAttributeNode(IXmlNode attribute)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		XmlNodeWrapper xmlNodeWrapper = (XmlNodeWrapper)attribute;
		_element.SetAttributeNode((XmlAttribute)xmlNodeWrapper.WrappedNode);
	}

	public string GetPrefixOfNamespace(string namespaceUri)
	{
		return ((XmlNode)_element).GetPrefixOfNamespace(namespaceUri);
	}
}


using System.Xml;
using Newtonsoft.Json.Converters;

internal class XmlDeclarationWrapper : XmlNodeWrapper, IXmlDeclaration, IXmlNode
{
	private readonly XmlDeclaration _declaration;

	public string Version => _declaration.Version;

	public string Encoding
	{
		get
		{
			return _declaration.Encoding;
		}
		set
		{
			_declaration.Encoding = value;
		}
	}

	public string Standalone
	{
		get
		{
			return _declaration.Standalone;
		}
		set
		{
			_declaration.Standalone = value;
		}
	}

	public XmlDeclarationWrapper(XmlDeclaration declaration)
		: base((XmlNode)(object)declaration)
	{
		_declaration = declaration;
	}
}


using System.Xml;
using Newtonsoft.Json.Converters;

internal class XmlDocumentTypeWrapper : XmlNodeWrapper, IXmlDocumentType, IXmlNode
{
	private readonly XmlDocumentType _documentType;

	public string Name => ((XmlNode)_documentType).Name;

	public string System => _documentType.SystemId;

	public string Public => _documentType.PublicId;

	public string InternalSubset => _documentType.InternalSubset;

	public override string LocalName => "DOCTYPE";

	public XmlDocumentTypeWrapper(XmlDocumentType documentType)
		: base((XmlNode)(object)documentType)
	{
		_documentType = documentType;
	}
}


using System.Collections.Generic;
using System.Xml;
using Newtonsoft.Json.Converters;

internal class XmlNodeWrapper : IXmlNode
{
	private readonly XmlNode _node;

	private List<IXmlNode> _childNodes;

	private List<IXmlNode> _attributes;

	public object WrappedNode => _node;

	public XmlNodeType NodeType => _node.NodeType;

	public virtual string LocalName => _node.LocalName;

	public List<IXmlNode> ChildNodes
	{
		get
		{
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Expected O, but got Unknown
			if (_childNodes == null)
			{
				_childNodes = new List<IXmlNode>(_node.ChildNodes.Count);
				foreach (XmlNode childNode in _node.ChildNodes)
				{
					XmlNode node = childNode;
					_childNodes.Add(WrapNode(node));
				}
			}
			return _childNodes;
		}
	}

	public List<IXmlNode> Attributes
	{
		get
		{
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Expected O, but got Unknown
			if (_node.Attributes == null)
			{
				return null;
			}
			if (_attributes == null)
			{
				_attributes = new List<IXmlNode>(((XmlNamedNodeMap)_node.Attributes).Count);
				foreach (XmlAttribute item in (XmlNamedNodeMap)_node.Attributes)
				{
					XmlAttribute node = item;
					_attributes.Add(WrapNode((XmlNode)(object)node));
				}
			}
			return _attributes;
		}
	}

	public IXmlNode ParentNode
	{
		get
		{
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			XmlNode val = (XmlNode)((_node is XmlAttribute) ? ((object)((XmlAttribute)_node).OwnerElement) : ((object)_node.ParentNode));
			if (val == null)
			{
				return null;
			}
			return WrapNode(val);
		}
	}

	public string Value
	{
		get
		{
			return _node.Value;
		}
		set
		{
			_node.Value = value;
		}
	}

	public string NamespaceUri => _node.NamespaceURI;

	public XmlNodeWrapper(XmlNode node)
	{
		_node = node;
	}

	internal static IXmlNode WrapNode(XmlNode node)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Invalid comparison between Unknown and I4
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Invalid comparison between Unknown and I4
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Expected O, but got Unknown
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Invalid comparison between Unknown and I4
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Expected O, but got Unknown
		XmlNodeType nodeType = node.NodeType;
		if ((int)nodeType != 1)
		{
			if ((int)nodeType != 10)
			{
				if ((int)nodeType == 17)
				{
					return new XmlDeclarationWrapper((XmlDeclaration)node);
				}
				return new XmlNodeWrapper(node);
			}
			return new XmlDocumentTypeWrapper((XmlDocumentType)node);
		}
		return new XmlElementWrapper((XmlElement)node);
	}

	public IXmlNode AppendChild(IXmlNode newChild)
	{
		XmlNodeWrapper xmlNodeWrapper = (XmlNodeWrapper)newChild;
		_node.AppendChild(xmlNodeWrapper._node);
		_childNodes = null;
		_attributes = null;
		return newChild;
	}
}


using Newtonsoft.Json.Converters;

internal interface IXmlDocument : IXmlNode
{
	IXmlElement DocumentElement { get; }

	IXmlNode CreateComment(string text);

	IXmlNode CreateTextNode(string text);

	IXmlNode CreateCDataSection(string data);

	IXmlNode CreateWhitespace(string text);

	IXmlNode CreateSignificantWhitespace(string text);

	IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);

	IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);

	IXmlNode CreateProcessingInstruction(string target, string data);

	IXmlElement CreateElement(string elementName);

	IXmlElement CreateElement(string qualifiedName, string namespaceUri);

	IXmlNode CreateAttribute(string name, string value);

	IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
}


using Newtonsoft.Json.Converters;

internal interface IXmlDeclaration : IXmlNode
{
	string Version { get; }

	string Encoding { get; set; }

	string Standalone { get; set; }
}


using Newtonsoft.Json.Converters;

internal interface IXmlDocumentType : IXmlNode
{
	string Name { get; }

	string System { get; }

	string Public { get; }

	string InternalSubset { get; }
}


using Newtonsoft.Json.Converters;

internal interface IXmlElement : IXmlNode
{
	bool IsEmpty { get; }

	void SetAttributeNode(IXmlNode attribute);

	string GetPrefixOfNamespace(string namespaceUri);
}


using System.Collections.Generic;
using System.Xml;
using Newtonsoft.Json.Converters;

internal interface IXmlNode
{
	XmlNodeType NodeType { get; }

	string LocalName { get; }

	List<IXmlNode> ChildNodes { get; }

	List<IXmlNode> Attributes { get; }

	IXmlNode ParentNode { get; }

	string Value { get; set; }

	string NamespaceUri { get; }

	object WrappedNode { get; }

	IXmlNode AppendChild(IXmlNode newChild);
}


using System.Xml;
using System.Xml.Linq;
using Newtonsoft.Json.Converters;

internal class XDeclarationWrapper : XObjectWrapper, IXmlDeclaration, IXmlNode
{
	internal XDeclaration Declaration { get; private set; }

	public override XmlNodeType NodeType => (XmlNodeType)17;

	public string Version => Declaration.Version;

	public string Encoding
	{
		get
		{
			return Declaration.Encoding;
		}
		set
		{
			Declaration.Encoding = value;
		}
	}

	public string Standalone
	{
		get
		{
			return Declaration.Standalone;
		}
		set
		{
			Declaration.Standalone = value;
		}
	}

	public XDeclarationWrapper(XDeclaration declaration)
		: base(null)
	{
		Declaration = declaration;
	}
}


using System.Xml.Linq;
using Newtonsoft.Json.Converters;

internal class XDocumentTypeWrapper : XObjectWrapper, IXmlDocumentType, IXmlNode
{
	private readonly XDocumentType _documentType;

	public string Name => _documentType.Name;

	public string System => _documentType.SystemId;

	public string Public => _documentType.PublicId;

	public string InternalSubset => _documentType.InternalSubset;

	public override string LocalName => "DOCTYPE";

	public XDocumentTypeWrapper(XDocumentType documentType)
		: base((XObject)(object)documentType)
	{
		_documentType = documentType;
	}
}


using System.Collections.Generic;
using System.Xml.Linq;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Utilities;

internal class XDocumentWrapper : XContainerWrapper, IXmlDocument, IXmlNode
{
	private XDocument Document => (XDocument)base.WrappedNode;

	public override List<IXmlNode> ChildNodes
	{
		get
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Invalid comparison between Unknown and I4
			List<IXmlNode> childNodes = base.ChildNodes;
			if (Document.Declaration != null && (int)childNodes[0].NodeType != 17)
			{
				childNodes.Insert(0, new XDeclarationWrapper(Document.Declaration));
			}
			return childNodes;
		}
	}

	public IXmlElement DocumentElement
	{
		get
		{
			if (Document.Root == null)
			{
				return null;
			}
			return new XElementWrapper(Document.Root);
		}
	}

	public XDocumentWrapper(XDocument document)
		: base((XContainer)(object)document)
	{
	}

	public IXmlNode CreateComment(string text)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		return new XObjectWrapper((XObject)new XComment(text));
	}

	public IXmlNode CreateTextNode(string text)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		return new XObjectWrapper((XObject)new XText(text));
	}

	public IXmlNode CreateCDataSection(string data)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		return new XObjectWrapper((XObject)new XCData(data));
	}

	public IXmlNode CreateWhitespace(string text)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		return new XObjectWrapper((XObject)new XText(text));
	}

	public IXmlNode CreateSignificantWhitespace(string text)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		return new XObjectWrapper((XObject)new XText(text));
	}

	public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Expected O, but got Unknown
		return new XDeclarationWrapper(new XDeclaration(version, encoding, standalone));
	}

	public IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Expected O, but got Unknown
		return new XDocumentTypeWrapper(new XDocumentType(name, publicId, systemId, internalSubset));
	}

	public IXmlNode CreateProcessingInstruction(string target, string data)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Expected O, but got Unknown
		return new XProcessingInstructionWrapper(new XProcessingInstruction(target, data));
	}

	public IXmlElement CreateElement(string elementName)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Expected O, but got Unknown
		return new XElementWrapper(new XElement(XName.op_Implicit(elementName)));
	}

	public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown
		return new XElementWrapper(new XElement(XName.Get(MiscellaneousUtils.GetLocalName(qualifiedName), namespaceUri)));
	}

	public IXmlNode CreateAttribute(string name, string value)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		return new XAttributeWrapper(new XAttribute(XName.op_Implicit(name), (object)value));
	}

	public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Expected O, but got Unknown
		return new XAttributeWrapper(new XAttribute(XName.Get(MiscellaneousUtils.GetLocalName(qualifiedName), namespaceUri), (object)value));
	}

	public override IXmlNode AppendChild(IXmlNode newChild)
	{
		if (newChild is XDeclarationWrapper xDeclarationWrapper)
		{
			Document.Declaration = xDeclarationWrapper.Declaration;
			return xDeclarationWrapper;
		}
		return base.AppendChild(newChild);
	}
}


using System.Xml.Linq;
using Newtonsoft.Json.Converters;

internal class XTextWrapper : XObjectWrapper
{
	private XText Text => (XText)base.WrappedNode;

	public override string Value
	{
		get
		{
			return Text.Value;
		}
		set
		{
			Text.Value = value;
		}
	}

	public override IXmlNode ParentNode
	{
		get
		{
			if (((XObject)Text).Parent == null)
			{
				return null;
			}
			return XContainerWrapper.WrapNode((XObject)(object)((XObject)Text).Parent);
		}
	}

	public XTextWrapper(XText text)
		: base((XObject)(object)text)
	{
	}
}


using System.Xml.Linq;
using Newtonsoft.Json.Converters;

internal class XCommentWrapper : XObjectWrapper
{
	private XComment Text => (XComment)base.WrappedNode;

	public override string Value
	{
		get
		{
			return Text.Value;
		}
		set
		{
			Text.Value = value;
		}
	}

	public override IXmlNode ParentNode
	{
		get
		{
			if (((XObject)Text).Parent == null)
			{
				return null;
			}
			return XContainerWrapper.WrapNode((XObject)(object)((XObject)Text).Parent);
		}
	}

	public XCommentWrapper(XComment text)
		: base((XObject)(object)text)
	{
	}
}


using System.Xml.Linq;
using Newtonsoft.Json.Converters;

internal class XProcessingInstructionWrapper : XObjectWrapper
{
	private XProcessingInstruction ProcessingInstruction => (XProcessingInstruction)base.WrappedNode;

	public override string LocalName => ProcessingInstruction.Target;

	public override string Value
	{
		get
		{
			return ProcessingInstruction.Data;
		}
		set
		{
			ProcessingInstruction.Data = value;
		}
	}

	public XProcessingInstructionWrapper(XProcessingInstruction processingInstruction)
		: base((XObject)(object)processingInstruction)
	{
	}
}


using System.Collections.Generic;
using System.Xml.Linq;
using Newtonsoft.Json.Converters;

internal class XContainerWrapper : XObjectWrapper
{
	private List<IXmlNode> _childNodes;

	private XContainer Container => (XContainer)base.WrappedNode;

	public override List<IXmlNode> ChildNodes
	{
		get
		{
			if (_childNodes == null)
			{
				_childNodes = new List<IXmlNode>();
				foreach (XNode item in Container.Nodes())
				{
					_childNodes.Add(WrapNode((XObject)(object)item));
				}
			}
			return _childNodes;
		}
	}

	public override IXmlNode ParentNode
	{
		get
		{
			if (((XObject)Container).Parent == null)
			{
				return null;
			}
			return WrapNode((XObject)(object)((XObject)Container).Parent);
		}
	}

	public XContainerWrapper(XContainer container)
		: base((XObject)(object)container)
	{
	}

	internal static IXmlNode WrapNode(XObject node)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Expected O, but got Unknown
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Expected O, but got Unknown
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Expected O, but got Unknown
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Expected O, but got Unknown
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Expected O, but got Unknown
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Expected O, but got Unknown
		if (node is XDocument)
		{
			return new XDocumentWrapper((XDocument)node);
		}
		if (node is XElement)
		{
			return new XElementWrapper((XElement)node);
		}
		if (node is XContainer)
		{
			return new XContainerWrapper((XContainer)node);
		}
		if (node is XProcessingInstruction)
		{
			return new XProcessingInstructionWrapper((XProcessingInstruction)node);
		}
		if (node is XText)
		{
			return new XTextWrapper((XText)node);
		}
		if (node is XComment)
		{
			return new XCommentWrapper((XComment)node);
		}
		if (node is XAttribute)
		{
			return new XAttributeWrapper((XAttribute)node);
		}
		if (node is XDocumentType)
		{
			return new XDocumentTypeWrapper((XDocumentType)node);
		}
		return new XObjectWrapper(node);
	}

	public override IXmlNode AppendChild(IXmlNode newChild)
	{
		Container.Add(newChild.WrappedNode);
		_childNodes = null;
		return newChild;
	}
}


using System;
using System.Collections.Generic;
using System.Xml;
using System.Xml.Linq;
using Newtonsoft.Json.Converters;

internal class XObjectWrapper : IXmlNode
{
	private static readonly List<IXmlNode> EmptyChildNodes = new List<IXmlNode>();

	private readonly XObject _xmlObject;

	public object WrappedNode => _xmlObject;

	public virtual XmlNodeType NodeType => _xmlObject.NodeType;

	public virtual string LocalName => null;

	public virtual List<IXmlNode> ChildNodes => EmptyChildNodes;

	public virtual List<IXmlNode> Attributes => null;

	public virtual IXmlNode ParentNode => null;

	public virtual string Value
	{
		get
		{
			return null;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public virtual string NamespaceUri => null;

	public XObjectWrapper(XObject xmlObject)
	{
		_xmlObject = xmlObject;
	}

	public virtual IXmlNode AppendChild(IXmlNode newChild)
	{
		throw new InvalidOperationException();
	}
}


using System.Xml.Linq;
using Newtonsoft.Json.Converters;

internal class XAttributeWrapper : XObjectWrapper
{
	private XAttribute Attribute => (XAttribute)base.WrappedNode;

	public override string Value
	{
		get
		{
			return Attribute.Value;
		}
		set
		{
			Attribute.Value = value;
		}
	}

	public override string LocalName => Attribute.Name.LocalName;

	public override string NamespaceUri => Attribute.Name.NamespaceName;

	public override IXmlNode ParentNode
	{
		get
		{
			if (((XObject)Attribute).Parent == null)
			{
				return null;
			}
			return XContainerWrapper.WrapNode((XObject)(object)((XObject)Attribute).Parent);
		}
	}

	public XAttributeWrapper(XAttribute attribute)
		: base((XObject)(object)attribute)
	{
	}
}


using System.Collections.Generic;
using System.Xml.Linq;
using Newtonsoft.Json.Converters;

internal class XElementWrapper : XContainerWrapper, IXmlElement, IXmlNode
{
	private List<IXmlNode> _attributes;

	private XElement Element => (XElement)base.WrappedNode;

	public override List<IXmlNode> Attributes
	{
		get
		{
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0119: Expected O, but got Unknown
			if (_attributes == null)
			{
				_attributes = new List<IXmlNode>();
				foreach (XAttribute item in Element.Attributes())
				{
					_attributes.Add(new XAttributeWrapper(item));
				}
				string namespaceUri = NamespaceUri;
				if (!string.IsNullOrEmpty(namespaceUri) && namespaceUri != ParentNode?.NamespaceUri && string.IsNullOrEmpty(GetPrefixOfNamespace(namespaceUri)))
				{
					bool flag = false;
					foreach (IXmlNode attribute in _attributes)
					{
						if (attribute.LocalName == "xmlns" && string.IsNullOrEmpty(attribute.NamespaceUri) && attribute.Value == namespaceUri)
						{
							flag = true;
						}
					}
					if (!flag)
					{
						_attributes.Insert(0, new XAttributeWrapper(new XAttribute(XName.op_Implicit("xmlns"), (object)namespaceUri)));
					}
				}
			}
			return _attributes;
		}
	}

	public override string Value
	{
		get
		{
			return Element.Value;
		}
		set
		{
			Element.Value = value;
		}
	}

	public override string LocalName => Element.Name.LocalName;

	public override string NamespaceUri => Element.Name.NamespaceName;

	public bool IsEmpty => Element.IsEmpty;

	public XElementWrapper(XElement element)
		: base((XContainer)(object)element)
	{
	}

	public void SetAttributeNode(IXmlNode attribute)
	{
		XObjectWrapper xObjectWrapper = (XObjectWrapper)attribute;
		((XContainer)Element).Add(xObjectWrapper.WrappedNode);
		_attributes = null;
	}

	public override IXmlNode AppendChild(IXmlNode newChild)
	{
		IXmlNode result = base.AppendChild(newChild);
		_attributes = null;
		return result;
	}

	public string GetPrefixOfNamespace(string namespaceUri)
	{
		return Element.GetPrefixOfNamespace(XNamespace.op_Implicit(namespaceUri));
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Xml;
using System.Xml.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class XmlNodeConverter : JsonConverter
{
	private const string TextName = "#text";

	private const string CommentName = "#comment";

	private const string CDataName = "#cdata-section";

	private const string WhitespaceName = "#whitespace";

	private const string SignificantWhitespaceName = "#significant-whitespace";

	private const string DeclarationName = "?xml";

	private const string JsonNamespaceUri = "http://james.newtonking.com/projects/json";

	public string DeserializeRootElementName { get; set; }

	public bool WriteArrayAttribute { get; set; }

	public bool OmitRootObject { get; set; }

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Expected O, but got Unknown
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		IXmlNode node = WrapXml(value);
		XmlNamespaceManager manager = new XmlNamespaceManager((XmlNameTable)new NameTable());
		PushParentNamespaces(node, manager);
		if (!OmitRootObject)
		{
			writer.WriteStartObject();
		}
		SerializeNode(writer, node, manager, !OmitRootObject);
		if (!OmitRootObject)
		{
			writer.WriteEndObject();
		}
	}

	private IXmlNode WrapXml(object value)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		if (value is XObject)
		{
			return XContainerWrapper.WrapNode((XObject)value);
		}
		if (value is XmlNode)
		{
			return XmlNodeWrapper.WrapNode((XmlNode)value);
		}
		throw new ArgumentException("Value must be an XML object.", "value");
	}

	private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Invalid comparison between Unknown and I4
		List<IXmlNode> list = null;
		IXmlNode xmlNode = node;
		while ((xmlNode = xmlNode.ParentNode) != null)
		{
			if ((int)xmlNode.NodeType == 1)
			{
				if (list == null)
				{
					list = new List<IXmlNode>();
				}
				list.Add(xmlNode);
			}
		}
		if (list == null)
		{
			return;
		}
		list.Reverse();
		foreach (IXmlNode item in list)
		{
			manager.PushScope();
			foreach (IXmlNode attribute in item.Attributes)
			{
				if (attribute.NamespaceUri == "http://www.w3.org/2000/xmlns/" && attribute.LocalName != "xmlns")
				{
					manager.AddNamespace(attribute.LocalName, attribute.Value);
				}
			}
		}
	}

	private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager)
	{
		string text = ((node.NamespaceUri == null || (node.LocalName == "xmlns" && node.NamespaceUri == "http://www.w3.org/2000/xmlns/")) ? null : manager.LookupPrefix(node.NamespaceUri));
		if (!string.IsNullOrEmpty(text))
		{
			return text + ":" + XmlConvert.DecodeName(node.LocalName);
		}
		return XmlConvert.DecodeName(node.LocalName);
	}

	private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Expected I4, but got Unknown
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		XmlNodeType nodeType = node.NodeType;
		switch (nodeType - 1)
		{
		case 1:
			if (node.NamespaceUri == "http://james.newtonking.com/projects/json")
			{
				return "$" + node.LocalName;
			}
			return "@" + ResolveFullName(node, manager);
		case 3:
			return "#cdata-section";
		case 7:
			return "#comment";
		case 0:
			if (node.NamespaceUri == "http://james.newtonking.com/projects/json")
			{
				return "$" + node.LocalName;
			}
			return ResolveFullName(node, manager);
		case 6:
			return "?" + ResolveFullName(node, manager);
		case 9:
			return "!" + ResolveFullName(node, manager);
		case 16:
			return "?xml";
		case 13:
			return "#significant-whitespace";
		case 2:
			return "#text";
		case 12:
			return "#whitespace";
		default:
			throw new JsonSerializationException("Unexpected XmlNodeType when getting node name: " + node.NodeType);
		}
	}

	private bool IsArray(IXmlNode node)
	{
		if (node.Attributes != null)
		{
			foreach (IXmlNode attribute in node.Attributes)
			{
				if (attribute.LocalName == "Array" && attribute.NamespaceUri == "http://james.newtonking.com/projects/json")
				{
					return XmlConvert.ToBoolean(attribute.Value);
				}
			}
		}
		return false;
	}

	private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName)
	{
		Dictionary<string, List<IXmlNode>> dictionary = new Dictionary<string, List<IXmlNode>>();
		for (int i = 0; i < node.ChildNodes.Count; i++)
		{
			IXmlNode xmlNode = node.ChildNodes[i];
			string propertyName = GetPropertyName(xmlNode, manager);
			if (!dictionary.TryGetValue(propertyName, out var value))
			{
				value = new List<IXmlNode>();
				dictionary.Add(propertyName, value);
			}
			value.Add(xmlNode);
		}
		foreach (KeyValuePair<string, List<IXmlNode>> item in dictionary)
		{
			List<IXmlNode> value2 = item.Value;
			if (value2.Count == 1 && !IsArray(value2[0]))
			{
				SerializeNode(writer, value2[0], manager, writePropertyName);
				continue;
			}
			string key = item.Key;
			if (writePropertyName)
			{
				writer.WritePropertyName(key);
			}
			writer.WriteStartArray();
			for (int j = 0; j < value2.Count; j++)
			{
				SerializeNode(writer, value2[j], manager, writePropertyName: false);
			}
			writer.WriteEndArray();
		}
	}

	private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Expected I4, but got Unknown
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Invalid comparison between Unknown and I4
		XmlNodeType nodeType = node.NodeType;
		switch (nodeType - 1)
		{
		case 8:
		case 10:
			SerializeGroupedNodes(writer, node, manager, writePropertyName);
			break;
		case 0:
			if (IsArray(node) && AllSameName(node) && node.ChildNodes.Count > 0)
			{
				SerializeGroupedNodes(writer, node, manager, writePropertyName: false);
				break;
			}
			manager.PushScope();
			foreach (IXmlNode attribute in node.Attributes)
			{
				if (attribute.NamespaceUri == "http://www.w3.org/2000/xmlns/")
				{
					string text = ((attribute.LocalName != "xmlns") ? XmlConvert.DecodeName(attribute.LocalName) : string.Empty);
					string value = attribute.Value;
					manager.AddNamespace(text, value);
				}
			}
			if (writePropertyName)
			{
				writer.WritePropertyName(GetPropertyName(node, manager));
			}
			if (!ValueAttributes(node.Attributes) && node.ChildNodes.Count == 1 && (int)node.ChildNodes[0].NodeType == 3)
			{
				writer.WriteValue(node.ChildNodes[0].Value);
			}
			else if (node.ChildNodes.Count == 0 && CollectionUtils.IsNullOrEmpty(node.Attributes))
			{
				if (((IXmlElement)node).IsEmpty)
				{
					writer.WriteNull();
				}
				else
				{
					writer.WriteValue(string.Empty);
				}
			}
			else
			{
				writer.WriteStartObject();
				for (int i = 0; i < node.Attributes.Count; i++)
				{
					SerializeNode(writer, node.Attributes[i], manager, writePropertyName: true);
				}
				SerializeGroupedNodes(writer, node, manager, writePropertyName: true);
				writer.WriteEndObject();
			}
			manager.PopScope();
			break;
		case 7:
			if (writePropertyName)
			{
				writer.WriteComment(node.Value);
			}
			break;
		case 1:
		case 2:
		case 3:
		case 6:
		case 12:
		case 13:
			if ((!(node.NamespaceUri == "http://www.w3.org/2000/xmlns/") || !(node.Value == "http://james.newtonking.com/projects/json")) && (!(node.NamespaceUri == "http://james.newtonking.com/projects/json") || !(node.LocalName == "Array")))
			{
				if (writePropertyName)
				{
					writer.WritePropertyName(GetPropertyName(node, manager));
				}
				writer.WriteValue(node.Value);
			}
			break;
		case 16:
		{
			IXmlDeclaration xmlDeclaration = (IXmlDeclaration)node;
			writer.WritePropertyName(GetPropertyName(node, manager));
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(xmlDeclaration.Version))
			{
				writer.WritePropertyName("@version");
				writer.WriteValue(xmlDeclaration.Version);
			}
			if (!string.IsNullOrEmpty(xmlDeclaration.Encoding))
			{
				writer.WritePropertyName("@encoding");
				writer.WriteValue(xmlDeclaration.Encoding);
			}
			if (!string.IsNullOrEmpty(xmlDeclaration.Standalone))
			{
				writer.WritePropertyName("@standalone");
				writer.WriteValue(xmlDeclaration.Standalone);
			}
			writer.WriteEndObject();
			break;
		}
		case 9:
		{
			IXmlDocumentType xmlDocumentType = (IXmlDocumentType)node;
			writer.WritePropertyName(GetPropertyName(node, manager));
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(xmlDocumentType.Name))
			{
				writer.WritePropertyName("@name");
				writer.WriteValue(xmlDocumentType.Name);
			}
			if (!string.IsNullOrEmpty(xmlDocumentType.Public))
			{
				writer.WritePropertyName("@public");
				writer.WriteValue(xmlDocumentType.Public);
			}
			if (!string.IsNullOrEmpty(xmlDocumentType.System))
			{
				writer.WritePropertyName("@system");
				writer.WriteValue(xmlDocumentType.System);
			}
			if (!string.IsNullOrEmpty(xmlDocumentType.InternalSubset))
			{
				writer.WritePropertyName("@internalSubset");
				writer.WriteValue(xmlDocumentType.InternalSubset);
			}
			writer.WriteEndObject();
			break;
		}
		default:
			throw new JsonSerializationException("Unexpected XmlNodeType when serializing nodes: " + node.NodeType);
		}
	}

	private static bool AllSameName(IXmlNode node)
	{
		foreach (IXmlNode childNode in node.ChildNodes)
		{
			if (childNode.LocalName != node.LocalName)
			{
				return false;
			}
		}
		return true;
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Expected O, but got Unknown
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Expected O, but got Unknown
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Expected O, but got Unknown
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Expected O, but got Unknown
		if (reader.TokenType == JsonToken.Null)
		{
			return null;
		}
		XmlNamespaceManager manager = new XmlNamespaceManager((XmlNameTable)new NameTable());
		IXmlDocument xmlDocument = null;
		IXmlNode xmlNode = null;
		if (typeof(XObject).IsAssignableFrom(objectType))
		{
			if ((object)objectType != typeof(XDocument) && (object)objectType != typeof(XElement))
			{
				throw new JsonSerializationException("XmlNodeConverter only supports deserializing XDocument or XElement.");
			}
			xmlDocument = new XDocumentWrapper(new XDocument());
			xmlNode = xmlDocument;
		}
		if (typeof(XmlNode).IsAssignableFrom(objectType))
		{
			if ((object)objectType != typeof(XmlDocument))
			{
				throw new JsonSerializationException("XmlNodeConverter only supports deserializing XmlDocuments");
			}
			xmlDocument = new XmlDocumentWrapper(new XmlDocument
			{
				XmlResolver = null
			});
			xmlNode = xmlDocument;
		}
		if (xmlDocument == null || xmlNode == null)
		{
			throw new JsonSerializationException("Unexpected type when converting XML: " + objectType);
		}
		if (reader.TokenType != JsonToken.StartObject)
		{
			throw new JsonSerializationException("XmlNodeConverter can only convert JSON that begins with an object.");
		}
		if (!string.IsNullOrEmpty(DeserializeRootElementName))
		{
			ReadElement(reader, xmlDocument, xmlNode, DeserializeRootElementName, manager);
		}
		else
		{
			reader.Read();
			DeserializeNode(reader, xmlDocument, manager, xmlNode);
		}
		if ((object)objectType == typeof(XElement))
		{
			XElement val = (XElement)xmlDocument.DocumentElement.WrappedNode;
			((XNode)val).Remove();
			return (object)val;
		}
		return xmlDocument.WrappedNode;
	}

	private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode)
	{
		switch (propertyName)
		{
		case "#text":
			currentNode.AppendChild(document.CreateTextNode(reader.Value.ToString()));
			return;
		case "#cdata-section":
			currentNode.AppendChild(document.CreateCDataSection(reader.Value.ToString()));
			return;
		case "#whitespace":
			currentNode.AppendChild(document.CreateWhitespace(reader.Value.ToString()));
			return;
		case "#significant-whitespace":
			currentNode.AppendChild(document.CreateSignificantWhitespace(reader.Value.ToString()));
			return;
		}
		if (!string.IsNullOrEmpty(propertyName) && propertyName[0] == '?')
		{
			CreateInstruction(reader, document, currentNode, propertyName);
		}
		else if (string.Equals(propertyName, "!DOCTYPE", StringComparison.OrdinalIgnoreCase))
		{
			CreateDocumentType(reader, document, currentNode);
		}
		else if (reader.TokenType == JsonToken.StartArray)
		{
			ReadArrayElements(reader, document, propertyName, currentNode, manager);
		}
		else
		{
			ReadElement(reader, document, currentNode, propertyName, manager);
		}
	}

	private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager)
	{
		if (string.IsNullOrEmpty(propertyName))
		{
			throw JsonSerializationException.Create(reader, "XmlNodeConverter cannot convert JSON with an empty property name to XML.");
		}
		Dictionary<string, string> attributeNameValues = ReadAttributeElements(reader, manager);
		string prefix = MiscellaneousUtils.GetPrefix(propertyName);
		if (StringUtils.StartsWith(propertyName, '@'))
		{
			string text = propertyName.Substring(1);
			string prefix2 = MiscellaneousUtils.GetPrefix(text);
			AddAttribute(reader, document, currentNode, text, manager, prefix2);
			return;
		}
		if (StringUtils.StartsWith(propertyName, '$'))
		{
			switch (propertyName)
			{
			case "$values":
				propertyName = propertyName.Substring(1);
				prefix = manager.LookupPrefix("http://james.newtonking.com/projects/json");
				CreateElement(reader, document, currentNode, propertyName, manager, prefix, attributeNameValues);
				return;
			case "$id":
			case "$ref":
			case "$type":
			case "$value":
			{
				string attributeName = propertyName.Substring(1);
				string attributePrefix = manager.LookupPrefix("http://james.newtonking.com/projects/json");
				AddAttribute(reader, document, currentNode, attributeName, manager, attributePrefix);
				return;
			}
			}
		}
		CreateElement(reader, document, currentNode, propertyName, manager, prefix, attributeNameValues);
	}

	private void CreateElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string elementName, XmlNamespaceManager manager, string elementPrefix, Dictionary<string, string> attributeNameValues)
	{
		IXmlElement xmlElement = CreateElement(elementName, document, elementPrefix, manager);
		currentNode.AppendChild(xmlElement);
		foreach (KeyValuePair<string, string> attributeNameValue in attributeNameValues)
		{
			string text = XmlConvert.EncodeName(attributeNameValue.Key);
			string prefix = MiscellaneousUtils.GetPrefix(attributeNameValue.Key);
			IXmlNode attributeNode = ((!string.IsNullOrEmpty(prefix)) ? document.CreateAttribute(text, manager.LookupNamespace(prefix) ?? string.Empty, attributeNameValue.Value) : document.CreateAttribute(text, attributeNameValue.Value));
			xmlElement.SetAttributeNode(attributeNode);
		}
		if (reader.TokenType == JsonToken.String || reader.TokenType == JsonToken.Integer || reader.TokenType == JsonToken.Float || reader.TokenType == JsonToken.Boolean || reader.TokenType == JsonToken.Date)
		{
			string text2 = ConvertTokenToXmlValue(reader);
			if (text2 != null)
			{
				xmlElement.AppendChild(document.CreateTextNode(text2));
			}
		}
		else if (reader.TokenType != JsonToken.Null)
		{
			if (reader.TokenType != JsonToken.EndObject)
			{
				manager.PushScope();
				DeserializeNode(reader, document, manager, xmlElement);
				manager.PopScope();
			}
			manager.RemoveNamespace(string.Empty, manager.DefaultNamespace);
		}
	}

	private static void AddAttribute(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string attributeName, XmlNamespaceManager manager, string attributePrefix)
	{
		string text = XmlConvert.EncodeName(attributeName);
		string value = reader.Value.ToString();
		IXmlNode attributeNode = ((!string.IsNullOrEmpty(attributePrefix)) ? document.CreateAttribute(text, manager.LookupNamespace(attributePrefix), value) : document.CreateAttribute(text, value));
		((IXmlElement)currentNode).SetAttributeNode(attributeNode);
	}

	private string ConvertTokenToXmlValue(JsonReader reader)
	{
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		if (reader.TokenType == JsonToken.String)
		{
			if (reader.Value == null)
			{
				return null;
			}
			return reader.Value.ToString();
		}
		if (reader.TokenType == JsonToken.Integer)
		{
			return XmlConvert.ToString(Convert.ToInt64(reader.Value, CultureInfo.InvariantCulture));
		}
		if (reader.TokenType == JsonToken.Float)
		{
			if (reader.Value is decimal)
			{
				return XmlConvert.ToString((decimal)reader.Value);
			}
			if (reader.Value is float)
			{
				return XmlConvert.ToString((float)reader.Value);
			}
			return XmlConvert.ToString(Convert.ToDouble(reader.Value, CultureInfo.InvariantCulture));
		}
		if (reader.TokenType == JsonToken.Boolean)
		{
			return XmlConvert.ToString(Convert.ToBoolean(reader.Value, CultureInfo.InvariantCulture));
		}
		if (reader.TokenType == JsonToken.Date)
		{
			if (reader.Value is DateTimeOffset)
			{
				return XmlConvert.ToString((DateTimeOffset)reader.Value);
			}
			DateTime dateTime = Convert.ToDateTime(reader.Value, CultureInfo.InvariantCulture);
			return XmlConvert.ToString(dateTime, DateTimeUtils.ToSerializationMode(dateTime.Kind));
		}
		if (reader.TokenType == JsonToken.Null)
		{
			return null;
		}
		throw JsonSerializationException.Create(reader, "Cannot get an XML string value from token type '{0}'.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
	}

	private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager)
	{
		string prefix = MiscellaneousUtils.GetPrefix(propertyName);
		IXmlElement xmlElement = CreateElement(propertyName, document, prefix, manager);
		currentNode.AppendChild(xmlElement);
		int num = 0;
		while (reader.Read() && reader.TokenType != JsonToken.EndArray)
		{
			DeserializeValue(reader, document, manager, propertyName, xmlElement);
			num++;
		}
		if (WriteArrayAttribute)
		{
			AddJsonArrayAttribute(xmlElement, document);
		}
		if (num != 1 || !WriteArrayAttribute)
		{
			return;
		}
		foreach (IXmlNode childNode in xmlElement.ChildNodes)
		{
			if (childNode is IXmlElement xmlElement2 && xmlElement2.LocalName == propertyName)
			{
				AddJsonArrayAttribute(xmlElement2, document);
				break;
			}
		}
	}

	private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document)
	{
		element.SetAttributeNode(document.CreateAttribute("json:Array", "http://james.newtonking.com/projects/json", "true"));
		if (element is XElementWrapper && element.GetPrefixOfNamespace("http://james.newtonking.com/projects/json") == null)
		{
			element.SetAttributeNode(document.CreateAttribute("xmlns:json", "http://www.w3.org/2000/xmlns/", "http://james.newtonking.com/projects/json"));
		}
	}

	private Dictionary<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		bool flag = false;
		bool flag2 = false;
		if (reader.TokenType != JsonToken.String && reader.TokenType != JsonToken.Null && reader.TokenType != JsonToken.Boolean && reader.TokenType != JsonToken.Integer && reader.TokenType != JsonToken.Float && reader.TokenType != JsonToken.Date && reader.TokenType != JsonToken.StartConstructor)
		{
			while (!flag && !flag2 && reader.Read())
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					if (!string.IsNullOrEmpty(text))
					{
						switch (text[0])
						{
						case '@':
						{
							text = text.Substring(1);
							reader.Read();
							string value = ConvertTokenToXmlValue(reader);
							dictionary.Add(text, value);
							if (IsNamespaceAttribute(text, out var prefix))
							{
								manager.AddNamespace(prefix, value);
							}
							break;
						}
						case '$':
							switch (text)
							{
							case "$values":
							case "$id":
							case "$ref":
							case "$type":
							case "$value":
							{
								string text2 = manager.LookupPrefix("http://james.newtonking.com/projects/json");
								if (text2 == null)
								{
									int? num = null;
									while (manager.LookupNamespace("json" + num) != null)
									{
										num = num.GetValueOrDefault() + 1;
									}
									text2 = "json" + num;
									dictionary.Add("xmlns:" + text2, "http://james.newtonking.com/projects/json");
									manager.AddNamespace(text2, "http://james.newtonking.com/projects/json");
								}
								if (text == "$values")
								{
									flag = true;
									break;
								}
								text = text.Substring(1);
								reader.Read();
								if (!JsonTokenUtils.IsPrimitiveToken(reader.TokenType))
								{
									throw JsonSerializationException.Create(reader, "Unexpected JsonToken: " + reader.TokenType);
								}
								string value = ((reader.Value != null) ? reader.Value.ToString() : null);
								dictionary.Add(text2 + ":" + text, value);
								break;
							}
							default:
								flag = true;
								break;
							}
							break;
						default:
							flag = true;
							break;
						}
					}
					else
					{
						flag = true;
					}
					break;
				}
				case JsonToken.EndObject:
					flag2 = true;
					break;
				case JsonToken.Comment:
					flag2 = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected JsonToken: " + reader.TokenType);
				}
			}
		}
		return dictionary;
	}

	private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName)
	{
		if (propertyName == "?xml")
		{
			string version = null;
			string encoding = null;
			string standalone = null;
			while (reader.Read() && reader.TokenType != JsonToken.EndObject)
			{
				switch (reader.Value.ToString())
				{
				case "@version":
					reader.Read();
					version = reader.Value.ToString();
					break;
				case "@encoding":
					reader.Read();
					encoding = reader.Value.ToString();
					break;
				case "@standalone":
					reader.Read();
					standalone = reader.Value.ToString();
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected property name encountered while deserializing XmlDeclaration: " + reader.Value);
				}
			}
			IXmlNode newChild = document.CreateXmlDeclaration(version, encoding, standalone);
			currentNode.AppendChild(newChild);
		}
		else
		{
			IXmlNode newChild2 = document.CreateProcessingInstruction(propertyName.Substring(1), reader.Value.ToString());
			currentNode.AppendChild(newChild2);
		}
	}

	private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode)
	{
		string name = null;
		string publicId = null;
		string systemId = null;
		string internalSubset = null;
		while (reader.Read() && reader.TokenType != JsonToken.EndObject)
		{
			switch (reader.Value.ToString())
			{
			case "@name":
				reader.Read();
				name = reader.Value.ToString();
				break;
			case "@public":
				reader.Read();
				publicId = reader.Value.ToString();
				break;
			case "@system":
				reader.Read();
				systemId = reader.Value.ToString();
				break;
			case "@internalSubset":
				reader.Read();
				internalSubset = reader.Value.ToString();
				break;
			default:
				throw JsonSerializationException.Create(reader, "Unexpected property name encountered while deserializing XmlDeclaration: " + reader.Value);
			}
		}
		IXmlNode newChild = document.CreateXmlDocumentType(name, publicId, systemId, internalSubset);
		currentNode.AppendChild(newChild);
	}

	private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager)
	{
		string text = XmlConvert.EncodeName(elementName);
		string text2 = (string.IsNullOrEmpty(elementPrefix) ? manager.DefaultNamespace : manager.LookupNamespace(elementPrefix));
		if (string.IsNullOrEmpty(text2))
		{
			return document.CreateElement(text);
		}
		return document.CreateElement(text, text2);
	}

	private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Invalid comparison between Unknown and I4
		do
		{
			switch (reader.TokenType)
			{
			case JsonToken.PropertyName:
			{
				if ((int)currentNode.NodeType == 9 && document.DocumentElement != null)
				{
					throw JsonSerializationException.Create(reader, "JSON root object has multiple properties. The root object must have a single property in order to create a valid XML document. Consider specifing a DeserializeRootElementName.");
				}
				string text = reader.Value.ToString();
				reader.Read();
				if (reader.TokenType == JsonToken.StartArray)
				{
					int num = 0;
					while (reader.Read() && reader.TokenType != JsonToken.EndArray)
					{
						DeserializeValue(reader, document, manager, text, currentNode);
						num++;
					}
					if (num != 1 || !WriteArrayAttribute)
					{
						break;
					}
					foreach (IXmlNode childNode in currentNode.ChildNodes)
					{
						if (childNode is IXmlElement xmlElement && xmlElement.LocalName == text)
						{
							AddJsonArrayAttribute(xmlElement, document);
							break;
						}
					}
				}
				else
				{
					DeserializeValue(reader, document, manager, text, currentNode);
				}
				break;
			}
			case JsonToken.StartConstructor:
			{
				string propertyName = reader.Value.ToString();
				while (reader.Read() && reader.TokenType != JsonToken.EndConstructor)
				{
					DeserializeValue(reader, document, manager, propertyName, currentNode);
				}
				break;
			}
			case JsonToken.Comment:
				currentNode.AppendChild(document.CreateComment((string)reader.Value));
				break;
			case JsonToken.EndObject:
			case JsonToken.EndArray:
				return;
			default:
				throw JsonSerializationException.Create(reader, "Unexpected JsonToken when deserializing node: " + reader.TokenType);
			}
		}
		while (reader.TokenType == JsonToken.PropertyName || reader.Read());
	}

	private bool IsNamespaceAttribute(string attributeName, out string prefix)
	{
		if (attributeName.StartsWith("xmlns", StringComparison.Ordinal))
		{
			if (attributeName.Length == 5)
			{
				prefix = string.Empty;
				return true;
			}
			if (attributeName[5] == ':')
			{
				prefix = attributeName.Substring(6, attributeName.Length - 6);
				return true;
			}
		}
		prefix = null;
		return false;
	}

	private bool ValueAttributes(List<IXmlNode> c)
	{
		foreach (IXmlNode item in c)
		{
			if (item.NamespaceUri != "http://james.newtonking.com/projects/json")
			{
				return true;
			}
		}
		return false;
	}

	public override bool CanConvert(Type valueType)
	{
		if (typeof(XObject).IsAssignableFrom(valueType))
		{
			return true;
		}
		if (typeof(XmlNode).IsAssignableFrom(valueType))
		{
			return true;
		}
		return false;
	}
}


using System;
using Newtonsoft.Json.Shims;

[Preserve]
internal enum BsonBinaryType : byte
{
	Binary = 0,
	Function = 1,
	[Obsolete("This type has been deprecated in the BSON specification. Use Binary instead.")]
	BinaryOld = 2,
	[Obsolete("This type has been deprecated in the BSON specification. Use Uuid instead.")]
	UuidOld = 3,
	Uuid = 4,
	Md5 = 5,
	UserDefined = 128
}


using System;
using System.Globalization;
using System.IO;
using System.Text;
using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
internal class BsonBinaryWriter
{
	private static readonly Encoding Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

	private readonly BinaryWriter _writer;

	private byte[] _largeByteBuffer;

	public DateTimeKind DateTimeKindHandling { get; set; }

	public BsonBinaryWriter(BinaryWriter writer)
	{
		DateTimeKindHandling = DateTimeKind.Utc;
		_writer = writer;
	}

	public void Flush()
	{
		_writer.Flush();
	}

	public void Close()
	{
		_writer.Close();
	}

	public void WriteToken(BsonToken t)
	{
		CalculateSize(t);
		WriteTokenInternal(t);
	}

	private void WriteTokenInternal(BsonToken t)
	{
		switch (t.Type)
		{
		case BsonType.Object:
		{
			BsonObject bsonObject = (BsonObject)t;
			_writer.Write(bsonObject.CalculatedSize);
			foreach (BsonProperty item in bsonObject)
			{
				_writer.Write((sbyte)item.Value.Type);
				WriteString((string)item.Name.Value, item.Name.ByteCount, null);
				WriteTokenInternal(item.Value);
			}
			_writer.Write((byte)0);
			break;
		}
		case BsonType.Array:
		{
			BsonArray bsonArray = (BsonArray)t;
			_writer.Write(bsonArray.CalculatedSize);
			ulong num2 = 0uL;
			foreach (BsonToken item2 in bsonArray)
			{
				_writer.Write((sbyte)item2.Type);
				WriteString(num2.ToString(CultureInfo.InvariantCulture), MathUtils.IntLength(num2), null);
				WriteTokenInternal(item2);
				num2++;
			}
			_writer.Write((byte)0);
			break;
		}
		case BsonType.Integer:
		{
			BsonValue bsonValue2 = (BsonValue)t;
			_writer.Write(Convert.ToInt32(bsonValue2.Value, CultureInfo.InvariantCulture));
			break;
		}
		case BsonType.Long:
		{
			BsonValue bsonValue3 = (BsonValue)t;
			_writer.Write(Convert.ToInt64(bsonValue3.Value, CultureInfo.InvariantCulture));
			break;
		}
		case BsonType.Number:
		{
			BsonValue bsonValue4 = (BsonValue)t;
			_writer.Write(Convert.ToDouble(bsonValue4.Value, CultureInfo.InvariantCulture));
			break;
		}
		case BsonType.String:
		{
			BsonString bsonString = (BsonString)t;
			WriteString((string)bsonString.Value, bsonString.ByteCount, bsonString.CalculatedSize - 4);
			break;
		}
		case BsonType.Boolean:
		{
			BsonValue bsonValue5 = (BsonValue)t;
			_writer.Write((bool)bsonValue5.Value);
			break;
		}
		case BsonType.Date:
		{
			BsonValue bsonValue = (BsonValue)t;
			long num = 0L;
			if (bsonValue.Value is DateTime)
			{
				DateTime dateTime = (DateTime)bsonValue.Value;
				if (DateTimeKindHandling == DateTimeKind.Utc)
				{
					dateTime = dateTime.ToUniversalTime();
				}
				else if (DateTimeKindHandling == DateTimeKind.Local)
				{
					dateTime = dateTime.ToLocalTime();
				}
				num = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTime, convertToUtc: false);
			}
			else
			{
				DateTimeOffset dateTimeOffset = (DateTimeOffset)bsonValue.Value;
				num = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTimeOffset.UtcDateTime, dateTimeOffset.Offset);
			}
			_writer.Write(num);
			break;
		}
		case BsonType.Binary:
		{
			BsonBinary bsonBinary = (BsonBinary)t;
			byte[] array = (byte[])bsonBinary.Value;
			_writer.Write(array.Length);
			_writer.Write((byte)bsonBinary.BinaryType);
			_writer.Write(array);
			break;
		}
		case BsonType.Oid:
		{
			byte[] buffer = (byte[])((BsonValue)t).Value;
			_writer.Write(buffer);
			break;
		}
		case BsonType.Regex:
		{
			BsonRegex bsonRegex = (BsonRegex)t;
			WriteString((string)bsonRegex.Pattern.Value, bsonRegex.Pattern.ByteCount, null);
			WriteString((string)bsonRegex.Options.Value, bsonRegex.Options.ByteCount, null);
			break;
		}
		default:
			throw new ArgumentOutOfRangeException("t", "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture, t.Type));
		case BsonType.Undefined:
		case BsonType.Null:
			break;
		}
	}

	private void WriteString(string s, int byteCount, int? calculatedlengthPrefix)
	{
		if (calculatedlengthPrefix.HasValue)
		{
			_writer.Write(calculatedlengthPrefix.GetValueOrDefault());
		}
		WriteUtf8Bytes(s, byteCount);
		_writer.Write((byte)0);
	}

	public void WriteUtf8Bytes(string s, int byteCount)
	{
		if (s != null)
		{
			if (_largeByteBuffer == null)
			{
				_largeByteBuffer = new byte[256];
			}
			if (byteCount <= 256)
			{
				Encoding.GetBytes(s, 0, s.Length, _largeByteBuffer, 0);
				_writer.Write(_largeByteBuffer, 0, byteCount);
			}
			else
			{
				byte[] bytes = Encoding.GetBytes(s);
				_writer.Write(bytes);
			}
		}
	}

	private int CalculateSize(int stringByteCount)
	{
		return stringByteCount + 1;
	}

	private int CalculateSizeWithLength(int stringByteCount, bool includeSize)
	{
		return ((!includeSize) ? 1 : 5) + stringByteCount;
	}

	private int CalculateSize(BsonToken t)
	{
		switch (t.Type)
		{
		case BsonType.Object:
		{
			BsonObject bsonObject = (BsonObject)t;
			int num4 = 4;
			foreach (BsonProperty item in bsonObject)
			{
				int num5 = 1;
				num5 += CalculateSize(item.Name);
				num5 += CalculateSize(item.Value);
				num4 += num5;
			}
			return bsonObject.CalculatedSize = num4 + 1;
		}
		case BsonType.Array:
		{
			BsonArray bsonArray = (BsonArray)t;
			int num2 = 4;
			ulong num3 = 0uL;
			foreach (BsonToken item2 in bsonArray)
			{
				num2++;
				num2 += CalculateSize(MathUtils.IntLength(num3));
				num2 += CalculateSize(item2);
				num3++;
			}
			num2++;
			bsonArray.CalculatedSize = num2;
			return bsonArray.CalculatedSize;
		}
		case BsonType.Integer:
			return 4;
		case BsonType.Long:
			return 8;
		case BsonType.Number:
			return 8;
		case BsonType.String:
		{
			BsonString bsonString = (BsonString)t;
			string text = (string)bsonString.Value;
			bsonString.ByteCount = ((text != null) ? Encoding.GetByteCount(text) : 0);
			bsonString.CalculatedSize = CalculateSizeWithLength(bsonString.ByteCount, bsonString.IncludeLength);
			return bsonString.CalculatedSize;
		}
		case BsonType.Boolean:
			return 1;
		case BsonType.Undefined:
		case BsonType.Null:
			return 0;
		case BsonType.Date:
			return 8;
		case BsonType.Binary:
		{
			BsonBinary obj = (BsonBinary)t;
			byte[] array = (byte[])obj.Value;
			obj.CalculatedSize = 5 + array.Length;
			return obj.CalculatedSize;
		}
		case BsonType.Oid:
			return 12;
		case BsonType.Regex:
		{
			BsonRegex bsonRegex = (BsonRegex)t;
			int num = 0;
			num += CalculateSize(bsonRegex.Pattern);
			num += CalculateSize(bsonRegex.Options);
			bsonRegex.CalculatedSize = num;
			return bsonRegex.CalculatedSize;
		}
		default:
			throw new ArgumentOutOfRangeException("t", "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture, t.Type));
		}
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class BsonReader : JsonReader
{
	private enum BsonReaderState
	{
		Normal,
		ReferenceStart,
		ReferenceRef,
		ReferenceId,
		CodeWScopeStart,
		CodeWScopeCode,
		CodeWScopeScope,
		CodeWScopeScopeObject,
		CodeWScopeScopeEnd
	}

	private class ContainerContext
	{
		public readonly BsonType Type;

		public int Length;

		public int Position;

		public ContainerContext(BsonType type)
		{
			Type = type;
		}
	}

	private const int MaxCharBytesSize = 128;

	private static readonly byte[] SeqRange1 = new byte[2] { 0, 127 };

	private static readonly byte[] SeqRange2 = new byte[2] { 194, 223 };

	private static readonly byte[] SeqRange3 = new byte[2] { 224, 239 };

	private static readonly byte[] SeqRange4 = new byte[2] { 240, 244 };

	private readonly BinaryReader _reader;

	private readonly List<ContainerContext> _stack;

	private byte[] _byteBuffer;

	private char[] _charBuffer;

	private BsonType _currentElementType;

	private BsonReaderState _bsonReaderState;

	private ContainerContext _currentContext;

	private bool _readRootValueAsArray;

	private bool _jsonNet35BinaryCompatibility;

	private DateTimeKind _dateTimeKindHandling;

	[Obsolete("JsonNet35BinaryCompatibility will be removed in a future version of Json.NET.")]
	public bool JsonNet35BinaryCompatibility
	{
		get
		{
			return _jsonNet35BinaryCompatibility;
		}
		set
		{
			_jsonNet35BinaryCompatibility = value;
		}
	}

	public bool ReadRootValueAsArray
	{
		get
		{
			return _readRootValueAsArray;
		}
		set
		{
			_readRootValueAsArray = value;
		}
	}

	public DateTimeKind DateTimeKindHandling
	{
		get
		{
			return _dateTimeKindHandling;
		}
		set
		{
			_dateTimeKindHandling = value;
		}
	}

	public BsonReader(Stream stream)
		: this(stream, readRootValueAsArray: false, DateTimeKind.Local)
	{
	}

	public BsonReader(BinaryReader reader)
		: this(reader, readRootValueAsArray: false, DateTimeKind.Local)
	{
	}

	public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
	{
		ValidationUtils.ArgumentNotNull(stream, "stream");
		_reader = new BinaryReader(stream);
		_stack = new List<ContainerContext>();
		_readRootValueAsArray = readRootValueAsArray;
		_dateTimeKindHandling = dateTimeKindHandling;
	}

	public BsonReader(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
	{
		ValidationUtils.ArgumentNotNull(reader, "reader");
		_reader = reader;
		_stack = new List<ContainerContext>();
		_readRootValueAsArray = readRootValueAsArray;
		_dateTimeKindHandling = dateTimeKindHandling;
	}

	private string ReadElement()
	{
		_currentElementType = ReadType();
		return ReadString();
	}

	public override bool Read()
	{
		try
		{
			bool flag;
			switch (_bsonReaderState)
			{
			case BsonReaderState.Normal:
				flag = ReadNormal();
				break;
			case BsonReaderState.ReferenceStart:
			case BsonReaderState.ReferenceRef:
			case BsonReaderState.ReferenceId:
				flag = ReadReference();
				break;
			case BsonReaderState.CodeWScopeStart:
			case BsonReaderState.CodeWScopeCode:
			case BsonReaderState.CodeWScopeScope:
			case BsonReaderState.CodeWScopeScopeObject:
			case BsonReaderState.CodeWScopeScopeEnd:
				flag = ReadCodeWScope();
				break;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}".FormatWith(CultureInfo.InvariantCulture, _bsonReaderState));
			}
			if (!flag)
			{
				SetToken(JsonToken.None);
				return false;
			}
			return true;
		}
		catch (EndOfStreamException)
		{
			SetToken(JsonToken.None);
			return false;
		}
	}

	public override void Close()
	{
		base.Close();
		if (base.CloseInput && _reader != null)
		{
			_reader.Close();
		}
	}

	private bool ReadCodeWScope()
	{
		switch (_bsonReaderState)
		{
		case BsonReaderState.CodeWScopeStart:
			SetToken(JsonToken.PropertyName, "$code");
			_bsonReaderState = BsonReaderState.CodeWScopeCode;
			return true;
		case BsonReaderState.CodeWScopeCode:
			ReadInt32();
			SetToken(JsonToken.String, ReadLengthString());
			_bsonReaderState = BsonReaderState.CodeWScopeScope;
			return true;
		case BsonReaderState.CodeWScopeScope:
		{
			if (base.CurrentState == State.PostValue)
			{
				SetToken(JsonToken.PropertyName, "$scope");
				return true;
			}
			SetToken(JsonToken.StartObject);
			_bsonReaderState = BsonReaderState.CodeWScopeScopeObject;
			ContainerContext containerContext = new ContainerContext(BsonType.Object);
			PushContext(containerContext);
			containerContext.Length = ReadInt32();
			return true;
		}
		case BsonReaderState.CodeWScopeScopeObject:
		{
			bool num = ReadNormal();
			if (num && TokenType == JsonToken.EndObject)
			{
				_bsonReaderState = BsonReaderState.CodeWScopeScopeEnd;
			}
			return num;
		}
		case BsonReaderState.CodeWScopeScopeEnd:
			SetToken(JsonToken.EndObject);
			_bsonReaderState = BsonReaderState.Normal;
			return true;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	private bool ReadReference()
	{
		switch (base.CurrentState)
		{
		case State.ObjectStart:
			SetToken(JsonToken.PropertyName, "$ref");
			_bsonReaderState = BsonReaderState.ReferenceRef;
			return true;
		case State.Property:
			if (_bsonReaderState == BsonReaderState.ReferenceRef)
			{
				SetToken(JsonToken.String, ReadLengthString());
				return true;
			}
			if (_bsonReaderState == BsonReaderState.ReferenceId)
			{
				SetToken(JsonToken.Bytes, ReadBytes(12));
				return true;
			}
			throw JsonReaderException.Create(this, "Unexpected state when reading BSON reference: " + _bsonReaderState);
		case State.PostValue:
			if (_bsonReaderState == BsonReaderState.ReferenceRef)
			{
				SetToken(JsonToken.PropertyName, "$id");
				_bsonReaderState = BsonReaderState.ReferenceId;
				return true;
			}
			if (_bsonReaderState == BsonReaderState.ReferenceId)
			{
				SetToken(JsonToken.EndObject);
				_bsonReaderState = BsonReaderState.Normal;
				return true;
			}
			throw JsonReaderException.Create(this, "Unexpected state when reading BSON reference: " + _bsonReaderState);
		default:
			throw JsonReaderException.Create(this, "Unexpected state when reading BSON reference: " + base.CurrentState);
		}
	}

	private bool ReadNormal()
	{
		switch (base.CurrentState)
		{
		case State.Start:
		{
			JsonToken token2 = ((!_readRootValueAsArray) ? JsonToken.StartObject : JsonToken.StartArray);
			int type = ((!_readRootValueAsArray) ? 3 : 4);
			SetToken(token2);
			ContainerContext containerContext = new ContainerContext((BsonType)type);
			PushContext(containerContext);
			containerContext.Length = ReadInt32();
			return true;
		}
		case State.Complete:
		case State.Closed:
			return false;
		case State.Property:
			ReadType(_currentElementType);
			return true;
		case State.ObjectStart:
		case State.ArrayStart:
		case State.PostValue:
		{
			ContainerContext currentContext = _currentContext;
			if (currentContext == null)
			{
				return false;
			}
			int num = currentContext.Length - 1;
			if (currentContext.Position < num)
			{
				if (currentContext.Type == BsonType.Array)
				{
					ReadElement();
					ReadType(_currentElementType);
					return true;
				}
				SetToken(JsonToken.PropertyName, ReadElement());
				return true;
			}
			if (currentContext.Position == num)
			{
				if (ReadByte() != 0)
				{
					throw JsonReaderException.Create(this, "Unexpected end of object byte value.");
				}
				PopContext();
				if (_currentContext != null)
				{
					MovePosition(currentContext.Length);
				}
				JsonToken token = ((currentContext.Type == BsonType.Object) ? JsonToken.EndObject : JsonToken.EndArray);
				SetToken(token);
				return true;
			}
			throw JsonReaderException.Create(this, "Read past end of current container context.");
		}
		default:
			throw new ArgumentOutOfRangeException();
		case State.ConstructorStart:
		case State.Constructor:
		case State.Error:
		case State.Finished:
			return false;
		}
	}

	private void PopContext()
	{
		_stack.RemoveAt(_stack.Count - 1);
		if (_stack.Count == 0)
		{
			_currentContext = null;
		}
		else
		{
			_currentContext = _stack[_stack.Count - 1];
		}
	}

	private void PushContext(ContainerContext newContext)
	{
		_stack.Add(newContext);
		_currentContext = newContext;
	}

	private byte ReadByte()
	{
		MovePosition(1);
		return _reader.ReadByte();
	}

	private void ReadType(BsonType type)
	{
		switch (type)
		{
		case BsonType.Number:
		{
			double num = ReadDouble();
			if (_floatParseHandling == FloatParseHandling.Decimal)
			{
				SetToken(JsonToken.Float, Convert.ToDecimal(num, CultureInfo.InvariantCulture));
			}
			else
			{
				SetToken(JsonToken.Float, num);
			}
			break;
		}
		case BsonType.String:
		case BsonType.Symbol:
			SetToken(JsonToken.String, ReadLengthString());
			break;
		case BsonType.Object:
		{
			SetToken(JsonToken.StartObject);
			ContainerContext containerContext2 = new ContainerContext(BsonType.Object);
			PushContext(containerContext2);
			containerContext2.Length = ReadInt32();
			break;
		}
		case BsonType.Array:
		{
			SetToken(JsonToken.StartArray);
			ContainerContext containerContext = new ContainerContext(BsonType.Array);
			PushContext(containerContext);
			containerContext.Length = ReadInt32();
			break;
		}
		case BsonType.Binary:
		{
			BsonBinaryType binaryType;
			byte[] array = ReadBinary(out binaryType);
			object value3 = ((binaryType != BsonBinaryType.Uuid) ? array : ((object)new Guid(array)));
			SetToken(JsonToken.Bytes, value3);
			break;
		}
		case BsonType.Undefined:
			SetToken(JsonToken.Undefined);
			break;
		case BsonType.Oid:
		{
			byte[] value2 = ReadBytes(12);
			SetToken(JsonToken.Bytes, value2);
			break;
		}
		case BsonType.Boolean:
		{
			bool flag = Convert.ToBoolean(ReadByte());
			SetToken(JsonToken.Boolean, flag);
			break;
		}
		case BsonType.Date:
		{
			DateTime dateTime = DateTimeUtils.ConvertJavaScriptTicksToDateTime(ReadInt64());
			SetToken(JsonToken.Date, DateTimeKindHandling switch
			{
				DateTimeKind.Unspecified => DateTime.SpecifyKind(dateTime, DateTimeKind.Unspecified), 
				DateTimeKind.Local => dateTime.ToLocalTime(), 
				_ => dateTime, 
			});
			break;
		}
		case BsonType.Null:
			SetToken(JsonToken.Null);
			break;
		case BsonType.Regex:
		{
			string text = ReadString();
			string text2 = ReadString();
			string value = "/" + text + "/" + text2;
			SetToken(JsonToken.String, value);
			break;
		}
		case BsonType.Reference:
			SetToken(JsonToken.StartObject);
			_bsonReaderState = BsonReaderState.ReferenceStart;
			break;
		case BsonType.Code:
			SetToken(JsonToken.String, ReadLengthString());
			break;
		case BsonType.CodeWScope:
			SetToken(JsonToken.StartObject);
			_bsonReaderState = BsonReaderState.CodeWScopeStart;
			break;
		case BsonType.Integer:
			SetToken(JsonToken.Integer, (long)ReadInt32());
			break;
		case BsonType.TimeStamp:
		case BsonType.Long:
			SetToken(JsonToken.Integer, ReadInt64());
			break;
		default:
			throw new ArgumentOutOfRangeException("type", "Unexpected BsonType value: " + type);
		}
	}

	private byte[] ReadBinary(out BsonBinaryType binaryType)
	{
		int count = ReadInt32();
		binaryType = (BsonBinaryType)ReadByte();
		if (binaryType == BsonBinaryType.BinaryOld && !_jsonNet35BinaryCompatibility)
		{
			count = ReadInt32();
		}
		return ReadBytes(count);
	}

	private string ReadString()
	{
		EnsureBuffers();
		StringBuilder stringBuilder = null;
		int num = 0;
		int num2 = 0;
		while (true)
		{
			int num3 = num2;
			byte b;
			while (num3 < 128 && (b = _reader.ReadByte()) > 0)
			{
				_byteBuffer[num3++] = b;
			}
			int num4 = num3 - num2;
			num += num4;
			if (num3 < 128 && stringBuilder == null)
			{
				int chars = Encoding.UTF8.GetChars(_byteBuffer, 0, num4, _charBuffer, 0);
				MovePosition(num + 1);
				return new string(_charBuffer, 0, chars);
			}
			int lastFullCharStop = GetLastFullCharStop(num3 - 1);
			int chars2 = Encoding.UTF8.GetChars(_byteBuffer, 0, lastFullCharStop + 1, _charBuffer, 0);
			if (stringBuilder == null)
			{
				stringBuilder = new StringBuilder(256);
			}
			stringBuilder.Append(_charBuffer, 0, chars2);
			if (lastFullCharStop < num4 - 1)
			{
				num2 = num4 - lastFullCharStop - 1;
				Array.Copy(_byteBuffer, lastFullCharStop + 1, _byteBuffer, 0, num2);
				continue;
			}
			if (num3 < 128)
			{
				break;
			}
			num2 = 0;
		}
		MovePosition(num + 1);
		return stringBuilder.ToString();
	}

	private string ReadLengthString()
	{
		int num = ReadInt32();
		MovePosition(num);
		string @string = GetString(num - 1);
		_reader.ReadByte();
		return @string;
	}

	private string GetString(int length)
	{
		if (length == 0)
		{
			return string.Empty;
		}
		EnsureBuffers();
		StringBuilder stringBuilder = null;
		int num = 0;
		int num2 = 0;
		do
		{
			int count = ((length - num > 128 - num2) ? (128 - num2) : (length - num));
			int num3 = _reader.Read(_byteBuffer, num2, count);
			if (num3 == 0)
			{
				throw new EndOfStreamException("Unable to read beyond the end of the stream.");
			}
			num += num3;
			num3 += num2;
			if (num3 == length)
			{
				int chars = Encoding.UTF8.GetChars(_byteBuffer, 0, num3, _charBuffer, 0);
				return new string(_charBuffer, 0, chars);
			}
			int lastFullCharStop = GetLastFullCharStop(num3 - 1);
			if (stringBuilder == null)
			{
				stringBuilder = new StringBuilder(length);
			}
			int chars2 = Encoding.UTF8.GetChars(_byteBuffer, 0, lastFullCharStop + 1, _charBuffer, 0);
			stringBuilder.Append(_charBuffer, 0, chars2);
			if (lastFullCharStop < num3 - 1)
			{
				num2 = num3 - lastFullCharStop - 1;
				Array.Copy(_byteBuffer, lastFullCharStop + 1, _byteBuffer, 0, num2);
			}
			else
			{
				num2 = 0;
			}
		}
		while (num < length);
		return stringBuilder.ToString();
	}

	private int GetLastFullCharStop(int start)
	{
		int num = start;
		int num2 = 0;
		for (; num >= 0; num--)
		{
			num2 = BytesInSequence(_byteBuffer[num]);
			switch (num2)
			{
			case 0:
				continue;
			default:
				num--;
				break;
			case 1:
				break;
			}
			break;
		}
		if (num2 == start - num)
		{
			return start;
		}
		return num;
	}

	private int BytesInSequence(byte b)
	{
		if (b <= SeqRange1[1])
		{
			return 1;
		}
		if (b >= SeqRange2[0] && b <= SeqRange2[1])
		{
			return 2;
		}
		if (b >= SeqRange3[0] && b <= SeqRange3[1])
		{
			return 3;
		}
		if (b >= SeqRange4[0] && b <= SeqRange4[1])
		{
			return 4;
		}
		return 0;
	}

	private void EnsureBuffers()
	{
		if (_byteBuffer == null)
		{
			_byteBuffer = new byte[128];
		}
		if (_charBuffer == null)
		{
			int maxCharCount = Encoding.UTF8.GetMaxCharCount(128);
			_charBuffer = new char[maxCharCount];
		}
	}

	private double ReadDouble()
	{
		MovePosition(8);
		return _reader.ReadDouble();
	}

	private int ReadInt32()
	{
		MovePosition(4);
		return _reader.ReadInt32();
	}

	private long ReadInt64()
	{
		MovePosition(8);
		return _reader.ReadInt64();
	}

	private BsonType ReadType()
	{
		MovePosition(1);
		return (BsonType)_reader.ReadSByte();
	}

	private void MovePosition(int count)
	{
		_currentContext.Position += count;
	}

	private byte[] ReadBytes(int count)
	{
		MovePosition(count);
		return _reader.ReadBytes(count);
	}
}


private enum BsonReaderState
{
	Normal,
	ReferenceStart,
	ReferenceRef,
	ReferenceId,
	CodeWScopeStart,
	CodeWScopeCode,
	CodeWScopeScope,
	CodeWScopeScopeObject,
	CodeWScopeScopeEnd
}


private class ContainerContext
{
	public readonly BsonType Type;

	public int Length;

	public int Position;

	public ContainerContext(BsonType type)
	{
		Type = type;
	}
}


using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Shims;

[Preserve]
internal abstract class BsonToken
{
	public abstract BsonType Type { get; }

	public BsonToken Parent { get; set; }

	public int CalculatedSize { get; set; }
}


using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Shims;

[Preserve]
internal class BsonObject : BsonToken, IEnumerable<BsonProperty>, IEnumerable
{
	private readonly List<BsonProperty> _children = new List<BsonProperty>();

	public override BsonType Type => BsonType.Object;

	public void Add(string name, BsonToken token)
	{
		_children.Add(new BsonProperty
		{
			Name = new BsonString(name, includeLength: false),
			Value = token
		});
		token.Parent = this;
	}

	public IEnumerator<BsonProperty> GetEnumerator()
	{
		return _children.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Shims;

[Preserve]
internal class BsonArray : BsonToken, IEnumerable<BsonToken>, IEnumerable
{
	private readonly List<BsonToken> _children = new List<BsonToken>();

	public override BsonType Type => BsonType.Array;

	public void Add(BsonToken token)
	{
		_children.Add(token);
		token.Parent = this;
	}

	public IEnumerator<BsonToken> GetEnumerator()
	{
		return _children.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Shims;

[Preserve]
internal class BsonValue : BsonToken
{
	private readonly object _value;

	private readonly BsonType _type;

	public object Value => _value;

	public override BsonType Type => _type;

	public BsonValue(object value, BsonType type)
	{
		_value = value;
		_type = type;
	}
}


using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Shims;

[Preserve]
internal class BsonString : BsonValue
{
	public int ByteCount { get; set; }

	public bool IncludeLength { get; set; }

	public BsonString(object value, bool includeLength)
		: base(value, BsonType.String)
	{
		IncludeLength = includeLength;
	}
}


using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Shims;

[Preserve]
internal class BsonBinary : BsonValue
{
	public BsonBinaryType BinaryType { get; set; }

	public BsonBinary(byte[] value, BsonBinaryType binaryType)
		: base(value, BsonType.Binary)
	{
		BinaryType = binaryType;
	}
}


using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Shims;

[Preserve]
internal class BsonRegex : BsonToken
{
	public BsonString Pattern { get; set; }

	public BsonString Options { get; set; }

	public override BsonType Type => BsonType.Regex;

	public BsonRegex(string pattern, string options)
	{
		Pattern = new BsonString(pattern, includeLength: false);
		Options = new BsonString(options, includeLength: false);
	}
}


using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Shims;

[Preserve]
internal class BsonProperty
{
	public BsonString Name { get; set; }

	public BsonToken Value { get; set; }
}


using Newtonsoft.Json.Shims;

[Preserve]
internal enum BsonType : sbyte
{
	Number = 1,
	String = 2,
	Object = 3,
	Array = 4,
	Binary = 5,
	Undefined = 6,
	Oid = 7,
	Boolean = 8,
	Date = 9,
	Null = 10,
	Regex = 11,
	Reference = 12,
	Code = 13,
	Symbol = 14,
	CodeWScope = 15,
	Integer = 16,
	TimeStamp = 17,
	Long = 18,
	MinKey = -1,
	MaxKey = sbyte.MaxValue
}


using System;
using System.Globalization;
using System.IO;
using Newtonsoft.Json;
using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class BsonWriter : JsonWriter
{
	private readonly BsonBinaryWriter _writer;

	private BsonToken _root;

	private BsonToken _parent;

	private string _propertyName;

	public DateTimeKind DateTimeKindHandling
	{
		get
		{
			return _writer.DateTimeKindHandling;
		}
		set
		{
			_writer.DateTimeKindHandling = value;
		}
	}

	public BsonWriter(Stream stream)
	{
		ValidationUtils.ArgumentNotNull(stream, "stream");
		_writer = new BsonBinaryWriter(new BinaryWriter(stream));
	}

	public BsonWriter(BinaryWriter writer)
	{
		ValidationUtils.ArgumentNotNull(writer, "writer");
		_writer = new BsonBinaryWriter(writer);
	}

	public override void Flush()
	{
		_writer.Flush();
	}

	protected override void WriteEnd(JsonToken token)
	{
		base.WriteEnd(token);
		RemoveParent();
		if (base.Top == 0)
		{
			_writer.WriteToken(_root);
		}
	}

	public override void WriteComment(string text)
	{
		throw JsonWriterException.Create(this, "Cannot write JSON comment as BSON.", null);
	}

	public override void WriteStartConstructor(string name)
	{
		throw JsonWriterException.Create(this, "Cannot write JSON constructor as BSON.", null);
	}

	public override void WriteRaw(string json)
	{
		throw JsonWriterException.Create(this, "Cannot write raw JSON as BSON.", null);
	}

	public override void WriteRawValue(string json)
	{
		throw JsonWriterException.Create(this, "Cannot write raw JSON as BSON.", null);
	}

	public override void WriteStartArray()
	{
		base.WriteStartArray();
		AddParent(new BsonArray());
	}

	public override void WriteStartObject()
	{
		base.WriteStartObject();
		AddParent(new BsonObject());
	}

	public override void WritePropertyName(string name)
	{
		base.WritePropertyName(name);
		_propertyName = name;
	}

	public override void Close()
	{
		base.Close();
		if (base.CloseOutput && _writer != null)
		{
			_writer.Close();
		}
	}

	private void AddParent(BsonToken container)
	{
		AddToken(container);
		_parent = container;
	}

	private void RemoveParent()
	{
		_parent = _parent.Parent;
	}

	private void AddValue(object value, BsonType type)
	{
		AddToken(new BsonValue(value, type));
	}

	internal void AddToken(BsonToken token)
	{
		if (_parent != null)
		{
			if (_parent is BsonObject)
			{
				((BsonObject)_parent).Add(_propertyName, token);
				_propertyName = null;
			}
			else
			{
				((BsonArray)_parent).Add(token);
			}
			return;
		}
		if (token.Type != BsonType.Object && token.Type != BsonType.Array)
		{
			throw JsonWriterException.Create(this, "Error writing {0} value. BSON must start with an Object or Array.".FormatWith(CultureInfo.InvariantCulture, token.Type), null);
		}
		_parent = token;
		_root = token;
	}

	public override void WriteValue(object value)
	{
		base.WriteValue(value);
	}

	public override void WriteNull()
	{
		base.WriteNull();
		AddValue(null, BsonType.Null);
	}

	public override void WriteUndefined()
	{
		base.WriteUndefined();
		AddValue(null, BsonType.Undefined);
	}

	public override void WriteValue(string value)
	{
		base.WriteValue(value);
		if (value == null)
		{
			AddValue(null, BsonType.Null);
		}
		else
		{
			AddToken(new BsonString(value, includeLength: true));
		}
	}

	public override void WriteValue(int value)
	{
		base.WriteValue(value);
		AddValue(value, BsonType.Integer);
	}

	[CLSCompliant(false)]
	public override void WriteValue(uint value)
	{
		if (value > int.MaxValue)
		{
			throw JsonWriterException.Create(this, "Value is too large to fit in a signed 32 bit integer. BSON does not support unsigned values.", null);
		}
		base.WriteValue(value);
		AddValue(value, BsonType.Integer);
	}

	public override void WriteValue(long value)
	{
		base.WriteValue(value);
		AddValue(value, BsonType.Long);
	}

	[CLSCompliant(false)]
	public override void WriteValue(ulong value)
	{
		if (value > long.MaxValue)
		{
			throw JsonWriterException.Create(this, "Value is too large to fit in a signed 64 bit integer. BSON does not support unsigned values.", null);
		}
		base.WriteValue(value);
		AddValue(value, BsonType.Long);
	}

	public override void WriteValue(float value)
	{
		base.WriteValue(value);
		AddValue(value, BsonType.Number);
	}

	public override void WriteValue(double value)
	{
		base.WriteValue(value);
		AddValue(value, BsonType.Number);
	}

	public override void WriteValue(bool value)
	{
		base.WriteValue(value);
		AddValue(value, BsonType.Boolean);
	}

	public override void WriteValue(short value)
	{
		base.WriteValue(value);
		AddValue(value, BsonType.Integer);
	}

	[CLSCompliant(false)]
	public override void WriteValue(ushort value)
	{
		base.WriteValue(value);
		AddValue(value, BsonType.Integer);
	}

	public override void WriteValue(char value)
	{
		base.WriteValue(value);
		string text = null;
		text = value.ToString(CultureInfo.InvariantCulture);
		AddToken(new BsonString(text, includeLength: true));
	}

	public override void WriteValue(byte value)
	{
		base.WriteValue(value);
		AddValue(value, BsonType.Integer);
	}

	[CLSCompliant(false)]
	public override void WriteValue(sbyte value)
	{
		base.WriteValue(value);
		AddValue(value, BsonType.Integer);
	}

	public override void WriteValue(decimal value)
	{
		base.WriteValue(value);
		AddValue(value, BsonType.Number);
	}

	public override void WriteValue(DateTime value)
	{
		base.WriteValue(value);
		value = DateTimeUtils.EnsureDateTime(value, base.DateTimeZoneHandling);
		AddValue(value, BsonType.Date);
	}

	public override void WriteValue(DateTimeOffset value)
	{
		base.WriteValue(value);
		AddValue(value, BsonType.Date);
	}

	public override void WriteValue(byte[] value)
	{
		base.WriteValue(value);
		AddToken(new BsonBinary(value, BsonBinaryType.Binary));
	}

	public override void WriteValue(Guid value)
	{
		base.WriteValue(value);
		AddToken(new BsonBinary(value.ToByteArray(), BsonBinaryType.Uuid));
	}

	public override void WriteValue(TimeSpan value)
	{
		base.WriteValue(value);
		AddToken(new BsonString(value.ToString(), includeLength: true));
	}

	public override void WriteValue(Uri value)
	{
		base.WriteValue(value);
		AddToken(new BsonString(value.ToString(), includeLength: true));
	}

	public void WriteObjectId(byte[] value)
	{
		ValidationUtils.ArgumentNotNull(value, "value");
		if (value.Length != 12)
		{
			throw JsonWriterException.Create(this, "An object id must be 12 bytes", null);
		}
		UpdateScopeWithFinishedValue();
		AutoComplete(JsonToken.Undefined);
		AddValue(value, BsonType.Oid);
	}

	public void WriteRegex(string pattern, string options)
	{
		ValidationUtils.ArgumentNotNull(pattern, "pattern");
		UpdateScopeWithFinishedValue();
		AutoComplete(JsonToken.Undefined);
		AddToken(new BsonRegex(pattern, options));
	}
}


using System;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;

[Preserve]
public class BsonObjectId
{
	public byte[] Value { get; private set; }

	public BsonObjectId(byte[] value)
	{
		ValidationUtils.ArgumentNotNull(value, "value");
		if (value.Length != 12)
		{
			throw new ArgumentException("An ObjectId must be 12 bytes", "value");
		}
		Value = value;
	}
}


internal enum TimeSpanScale
{
	Days = 0,
	Hours = 1,
	Minutes = 2,
	Seconds = 3,
	Milliseconds = 4,
	Ticks = 5,
	MinMax = 15
}


using System;
using System.Runtime.Serialization;
using ProtoBuf;

public static class BclHelpers
{
	[Flags]
	public enum NetObjectOptions : byte
	{
		None = 0,
		AsReference = 1,
		DynamicType = 2,
		UseConstructor = 4,
		LateSet = 8
	}

	private const int FieldTimeSpanValue = 1;

	private const int FieldTimeSpanScale = 2;

	private const int FieldDecimalLow = 1;

	private const int FieldDecimalHigh = 2;

	private const int FieldDecimalSignScale = 3;

	private const int FieldGuidLow = 1;

	private const int FieldGuidHigh = 2;

	private const int FieldExistingObjectKey = 1;

	private const int FieldNewObjectKey = 2;

	private const int FieldExistingTypeKey = 3;

	private const int FieldNewTypeKey = 4;

	private const int FieldTypeName = 8;

	private const int FieldObject = 10;

	internal static readonly DateTime EpochOrigin = new DateTime(1970, 1, 1, 0, 0, 0, 0);

	public static object GetUninitializedObject(Type type)
	{
		return FormatterServices.GetUninitializedObject(type);
	}

	public static void WriteTimeSpan(TimeSpan timeSpan, ProtoWriter dest)
	{
		if (dest == null)
		{
			throw new ArgumentNullException("dest");
		}
		switch (dest.WireType)
		{
		case WireType.String:
		case WireType.StartGroup:
		{
			long num = timeSpan.Ticks;
			TimeSpanScale timeSpanScale;
			if (timeSpan == TimeSpan.MaxValue)
			{
				num = 1L;
				timeSpanScale = TimeSpanScale.MinMax;
			}
			else if (timeSpan == TimeSpan.MinValue)
			{
				num = -1L;
				timeSpanScale = TimeSpanScale.MinMax;
			}
			else if (num % 864000000000L == 0)
			{
				timeSpanScale = TimeSpanScale.Days;
				num /= 864000000000L;
			}
			else if (num % 36000000000L == 0)
			{
				timeSpanScale = TimeSpanScale.Hours;
				num /= 36000000000L;
			}
			else if (num % 600000000 == 0)
			{
				timeSpanScale = TimeSpanScale.Minutes;
				num /= 600000000;
			}
			else if (num % 10000000 == 0)
			{
				timeSpanScale = TimeSpanScale.Seconds;
				num /= 10000000;
			}
			else if (num % 10000 == 0)
			{
				timeSpanScale = TimeSpanScale.Milliseconds;
				num /= 10000;
			}
			else
			{
				timeSpanScale = TimeSpanScale.Ticks;
			}
			SubItemToken token = ProtoWriter.StartSubItem(null, dest);
			if (num != 0)
			{
				ProtoWriter.WriteFieldHeader(1, WireType.SignedVariant, dest);
				ProtoWriter.WriteInt64(num, dest);
			}
			if (timeSpanScale != 0)
			{
				ProtoWriter.WriteFieldHeader(2, WireType.Variant, dest);
				ProtoWriter.WriteInt32((int)timeSpanScale, dest);
			}
			ProtoWriter.EndSubItem(token, dest);
			break;
		}
		case WireType.Fixed64:
			ProtoWriter.WriteInt64(timeSpan.Ticks, dest);
			break;
		default:
			throw new ProtoException("Unexpected wire-type: " + dest.WireType);
		}
	}

	public static TimeSpan ReadTimeSpan(ProtoReader source)
	{
		long num = ReadTimeSpanTicks(source);
		return num switch
		{
			long.MinValue => TimeSpan.MinValue, 
			long.MaxValue => TimeSpan.MaxValue, 
			_ => TimeSpan.FromTicks(num), 
		};
	}

	public static DateTime ReadDateTime(ProtoReader source)
	{
		long num = ReadTimeSpanTicks(source);
		switch (num)
		{
		case long.MinValue:
			return DateTime.MinValue;
		case long.MaxValue:
			return DateTime.MaxValue;
		default:
		{
			DateTime epochOrigin = EpochOrigin;
			return epochOrigin.AddTicks(num);
		}
		}
	}

	public static void WriteDateTime(DateTime value, ProtoWriter dest)
	{
		if (dest == null)
		{
			throw new ArgumentNullException("dest");
		}
		TimeSpan timeSpan;
		switch (dest.WireType)
		{
		case WireType.String:
		case WireType.StartGroup:
			timeSpan = ((!(value == DateTime.MaxValue)) ? ((!(value == DateTime.MinValue)) ? (value - EpochOrigin) : TimeSpan.MinValue) : TimeSpan.MaxValue);
			break;
		default:
			timeSpan = value - EpochOrigin;
			break;
		}
		WriteTimeSpan(timeSpan, dest);
	}

	private static long ReadTimeSpanTicks(ProtoReader source)
	{
		switch (source.WireType)
		{
		case WireType.String:
		case WireType.StartGroup:
		{
			SubItemToken token = ProtoReader.StartSubItem(source);
			TimeSpanScale timeSpanScale = TimeSpanScale.Days;
			long num = 0L;
			int num2;
			while ((num2 = source.ReadFieldHeader()) > 0)
			{
				switch (num2)
				{
				case 2:
					timeSpanScale = (TimeSpanScale)source.ReadInt32();
					break;
				case 1:
					source.Assert(WireType.SignedVariant);
					num = source.ReadInt64();
					break;
				default:
					source.SkipField();
					break;
				}
			}
			ProtoReader.EndSubItem(token, source);
			switch (timeSpanScale)
			{
			case TimeSpanScale.Days:
				return num * 864000000000L;
			case TimeSpanScale.Hours:
				return num * 36000000000L;
			case TimeSpanScale.Minutes:
				return num * 600000000;
			case TimeSpanScale.Seconds:
				return num * 10000000;
			case TimeSpanScale.Milliseconds:
				return num * 10000;
			case TimeSpanScale.Ticks:
				return num;
			case TimeSpanScale.MinMax:
			{
				long num3 = num;
				if (num3 <= 1 && num3 >= -1)
				{
					switch (num3 - -1)
					{
					case 2L:
						return long.MaxValue;
					case 0L:
						return long.MinValue;
					}
				}
				throw new ProtoException("Unknown min/max value: " + num);
			}
			default:
				throw new ProtoException("Unknown timescale: " + timeSpanScale);
			}
		}
		case WireType.Fixed64:
			return source.ReadInt64();
		default:
			throw new ProtoException("Unexpected wire-type: " + source.WireType);
		}
	}

	public static decimal ReadDecimal(ProtoReader reader)
	{
		ulong num = 0uL;
		uint num2 = 0u;
		uint num3 = 0u;
		SubItemToken token = ProtoReader.StartSubItem(reader);
		int num4;
		while ((num4 = reader.ReadFieldHeader()) > 0)
		{
			switch (num4)
			{
			case 1:
				num = reader.ReadUInt64();
				break;
			case 2:
				num2 = reader.ReadUInt32();
				break;
			case 3:
				num3 = reader.ReadUInt32();
				break;
			default:
				reader.SkipField();
				break;
			}
		}
		ProtoReader.EndSubItem(token, reader);
		if (num == 0 && num2 == 0)
		{
			return 0m;
		}
		int lo = (int)(num & 0xFFFFFFFFu);
		int mid = (int)((num >> 32) & 0xFFFFFFFFu);
		int hi = (int)num2;
		bool isNegative = (num3 & 1) == 1;
		byte scale = (byte)((num3 & 0x1FE) >> 1);
		return new decimal(lo, mid, hi, isNegative, scale);
	}

	public static void WriteDecimal(decimal value, ProtoWriter writer)
	{
		int[] bits = decimal.GetBits(value);
		ulong num = (ulong)((long)bits[1] << 32);
		ulong num2 = (ulong)(bits[0] & 0xFFFFFFFFu);
		ulong num3 = num | num2;
		uint num4 = (uint)bits[2];
		uint num5 = (uint)(((bits[3] >> 15) & 0x1FE) | ((bits[3] >> 31) & 1));
		SubItemToken token = ProtoWriter.StartSubItem(null, writer);
		if (num3 != 0)
		{
			ProtoWriter.WriteFieldHeader(1, WireType.Variant, writer);
			ProtoWriter.WriteUInt64(num3, writer);
		}
		if (num4 != 0)
		{
			ProtoWriter.WriteFieldHeader(2, WireType.Variant, writer);
			ProtoWriter.WriteUInt32(num4, writer);
		}
		if (num5 != 0)
		{
			ProtoWriter.WriteFieldHeader(3, WireType.Variant, writer);
			ProtoWriter.WriteUInt32(num5, writer);
		}
		ProtoWriter.EndSubItem(token, writer);
	}

	public static void WriteGuid(Guid value, ProtoWriter dest)
	{
		byte[] data = value.ToByteArray();
		SubItemToken token = ProtoWriter.StartSubItem(null, dest);
		if (value != Guid.Empty)
		{
			ProtoWriter.WriteFieldHeader(1, WireType.Fixed64, dest);
			ProtoWriter.WriteBytes(data, 0, 8, dest);
			ProtoWriter.WriteFieldHeader(2, WireType.Fixed64, dest);
			ProtoWriter.WriteBytes(data, 8, 8, dest);
		}
		ProtoWriter.EndSubItem(token, dest);
	}

	public static Guid ReadGuid(ProtoReader source)
	{
		ulong num = 0uL;
		ulong num2 = 0uL;
		SubItemToken token = ProtoReader.StartSubItem(source);
		int num3;
		while ((num3 = source.ReadFieldHeader()) > 0)
		{
			switch (num3)
			{
			case 1:
				num = source.ReadUInt64();
				break;
			case 2:
				num2 = source.ReadUInt64();
				break;
			default:
				source.SkipField();
				break;
			}
		}
		ProtoReader.EndSubItem(token, source);
		if (num == 0 && num2 == 0)
		{
			return Guid.Empty;
		}
		uint num4 = (uint)(num >> 32);
		uint a = (uint)num;
		uint num5 = (uint)(num2 >> 32);
		uint num6 = (uint)num2;
		return new Guid((int)a, (short)num4, (short)(num4 >> 16), (byte)num6, (byte)(num6 >> 8), (byte)(num6 >> 16), (byte)(num6 >> 24), (byte)num5, (byte)(num5 >> 8), (byte)(num5 >> 16), (byte)(num5 >> 24));
	}

	public static object ReadNetObject(object value, ProtoReader source, int key, Type type, NetObjectOptions options)
	{
		SubItemToken token = ProtoReader.StartSubItem(source);
		int num = -1;
		int num2 = -1;
		int num3;
		while ((num3 = source.ReadFieldHeader()) > 0)
		{
			switch (num3)
			{
			case 1:
			{
				int key2 = source.ReadInt32();
				value = source.NetCache.GetKeyedObject(key2);
				break;
			}
			case 2:
				num = source.ReadInt32();
				break;
			case 3:
			{
				int key2 = source.ReadInt32();
				type = (Type)source.NetCache.GetKeyedObject(key2);
				key = source.GetTypeKey(ref type);
				break;
			}
			case 4:
				num2 = source.ReadInt32();
				break;
			case 8:
			{
				string text = source.ReadString();
				type = source.DeserializeType(text);
				if ((object)type == null)
				{
					throw new ProtoException("Unable to resolve type: " + text + " (you can use the TypeModel.DynamicTypeFormatting event to provide a custom mapping)");
				}
				if ((object)type == typeof(string))
				{
					key = -1;
					break;
				}
				key = source.GetTypeKey(ref type);
				if (key >= 0)
				{
					break;
				}
				throw new InvalidOperationException("Dynamic type is not a contract-type: " + type.Name);
			}
			case 10:
			{
				bool flag = (object)type == typeof(string);
				bool flag2 = value == null;
				bool flag3 = flag2 && (flag || (options & NetObjectOptions.LateSet) != 0);
				if (num >= 0 && !flag3)
				{
					if (value == null)
					{
						source.TrapNextObject(num);
					}
					else
					{
						source.NetCache.SetKeyedObject(num, value);
					}
					if (num2 >= 0)
					{
						source.NetCache.SetKeyedObject(num2, type);
					}
				}
				object obj = value;
				value = ((!flag) ? ProtoReader.ReadTypedObject(obj, key, source, type) : source.ReadString());
				if (num >= 0)
				{
					if (flag2 && !flag3)
					{
						obj = source.NetCache.GetKeyedObject(num);
					}
					if (flag3)
					{
						source.NetCache.SetKeyedObject(num, value);
						if (num2 >= 0)
						{
							source.NetCache.SetKeyedObject(num2, type);
						}
					}
				}
				if (num >= 0 && !flag3 && !object.ReferenceEquals(obj, value))
				{
					throw new ProtoException("A reference-tracked object changed reference during deserialization");
				}
				if (num < 0 && num2 >= 0)
				{
					source.NetCache.SetKeyedObject(num2, type);
				}
				break;
			}
			default:
				source.SkipField();
				break;
			}
		}
		if (num >= 0 && (options & NetObjectOptions.AsReference) == 0)
		{
			throw new ProtoException("Object key in input stream, but reference-tracking was not expected");
		}
		ProtoReader.EndSubItem(token, source);
		return value;
	}

	public static void WriteNetObject(object value, ProtoWriter dest, int key, NetObjectOptions options)
	{
		if (dest == null)
		{
			throw new ArgumentNullException("dest");
		}
		bool flag = (options & NetObjectOptions.DynamicType) != 0;
		bool flag2 = (options & NetObjectOptions.AsReference) != 0;
		WireType wireType = dest.WireType;
		SubItemToken token = ProtoWriter.StartSubItem(null, dest);
		bool flag3 = true;
		if (flag2)
		{
			bool existing;
			int value2 = dest.NetCache.AddObjectKey(value, out existing);
			ProtoWriter.WriteFieldHeader(existing ? 1 : 2, WireType.Variant, dest);
			ProtoWriter.WriteInt32(value2, dest);
			if (existing)
			{
				flag3 = false;
			}
		}
		if (flag3)
		{
			if (flag)
			{
				Type type = value.GetType();
				if (!(value is string))
				{
					key = dest.GetTypeKey(ref type);
					if (key < 0)
					{
						throw new InvalidOperationException("Dynamic type is not a contract-type: " + type.Name);
					}
				}
				bool existing2;
				int value3 = dest.NetCache.AddObjectKey(type, out existing2);
				ProtoWriter.WriteFieldHeader(existing2 ? 3 : 4, WireType.Variant, dest);
				ProtoWriter.WriteInt32(value3, dest);
				if (!existing2)
				{
					ProtoWriter.WriteFieldHeader(8, WireType.String, dest);
					ProtoWriter.WriteString(dest.SerializeType(type), dest);
				}
			}
			ProtoWriter.WriteFieldHeader(10, wireType, dest);
			if (value is string)
			{
				ProtoWriter.WriteString((string)value, dest);
			}
			else
			{
				ProtoWriter.WriteObject(value, key, dest);
			}
		}
		ProtoWriter.EndSubItem(token, dest);
	}
}


using System;

[Flags]
public enum NetObjectOptions : byte
{
	None = 0,
	AsReference = 1,
	DynamicType = 2,
	UseConstructor = 4,
	LateSet = 8
}


using System.IO;

public interface IExtension
{
	Stream BeginAppend();

	void EndAppend(Stream stream, bool commit);

	Stream BeginQuery();

	void EndQuery(Stream stream);

	int GetLength();
}


using System.IO;
using ProtoBuf;

public sealed class BufferExtension : IExtension
{
	private byte[] buffer;

	int IExtension.GetLength()
	{
		if (buffer != null)
		{
			return buffer.Length;
		}
		return 0;
	}

	Stream IExtension.BeginAppend()
	{
		return new MemoryStream();
	}

	void IExtension.EndAppend(Stream stream, bool commit)
	{
		using (stream)
		{
			int num;
			if (commit && (num = (int)stream.Length) > 0)
			{
				MemoryStream memoryStream = (MemoryStream)stream;
				if (buffer == null)
				{
					buffer = memoryStream.ToArray();
					return;
				}
				int num2 = buffer.Length;
				byte[] to = new byte[num2 + num];
				Helpers.BlockCopy(buffer, 0, to, 0, num2);
				Helpers.BlockCopy(memoryStream.GetBuffer(), 0, to, num2, num);
				buffer = to;
			}
		}
	}

	Stream IExtension.BeginQuery()
	{
		if (buffer != null)
		{
			return new MemoryStream(buffer);
		}
		return Stream.Null;
	}

	void IExtension.EndQuery(Stream stream)
	{
		using (stream)
		{
		}
	}
}


using ProtoBuf;

internal sealed class BufferPool
{
	private const int PoolSize = 20;

	internal const int BufferLength = 1024;

	private static readonly object[] pool = new object[20];

	internal static void Flush()
	{
		lock (pool)
		{
			for (int i = 0; i < pool.Length; i++)
			{
				pool[i] = null;
			}
		}
	}

	private BufferPool()
	{
	}

	internal static byte[] GetBuffer()
	{
		lock (pool)
		{
			for (int i = 0; i < pool.Length; i++)
			{
				object obj;
				if ((obj = pool[i]) != null)
				{
					pool[i] = null;
					return (byte[])obj;
				}
			}
		}
		return new byte[1024];
	}

	internal static void ResizeAndFlushLeft(ref byte[] buffer, int toFitAtLeastBytes, int copyFromIndex, int copyBytes)
	{
		int num = buffer.Length * 2;
		if (num < toFitAtLeastBytes)
		{
			num = toFitAtLeastBytes;
		}
		byte[] array = new byte[num];
		if (copyBytes > 0)
		{
			Helpers.BlockCopy(buffer, copyFromIndex, array, 0, copyBytes);
		}
		if (buffer.Length == 1024)
		{
			ReleaseBufferToPool(ref buffer);
		}
		buffer = array;
	}

	internal static void ReleaseBufferToPool(ref byte[] buffer)
	{
		if (buffer == null)
		{
			return;
		}
		if (buffer.Length == 1024)
		{
			lock (pool)
			{
				for (int i = 0; i < pool.Length; i++)
				{
					if (pool[i] == null)
					{
						pool[i] = buffer;
						break;
					}
				}
			}
		}
		buffer = null;
	}
}


using System;
using System.ComponentModel;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
[ImmutableObject(true)]
public sealed class ProtoBeforeSerializationAttribute : Attribute
{
}


using System;
using System.ComponentModel;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
[ImmutableObject(true)]
public sealed class ProtoAfterSerializationAttribute : Attribute
{
}


using System;
using System.ComponentModel;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
[ImmutableObject(true)]
public sealed class ProtoBeforeDeserializationAttribute : Attribute
{
}


using System;
using System.ComponentModel;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
[ImmutableObject(true)]
public sealed class ProtoAfterDeserializationAttribute : Attribute
{
}


using ProtoBuf;

internal delegate void ProtoSerializer(object value, ProtoWriter dest);


using ProtoBuf;

internal delegate object ProtoDeserializer(object value, ProtoReader source);


using System.Reflection.Emit;

internal struct CodeLabel
{
	public readonly Label Value;

	public readonly int Index;

	public CodeLabel(Label value, int index)
	{
		Value = value;
		Index = index;
	}
}


using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class CompilerContext
{
	private sealed class UsingBlock : IDisposable
	{
		private Local local;

		private CompilerContext ctx;

		private CodeLabel label;

		public UsingBlock(CompilerContext ctx, Local local)
		{
			if (ctx == null)
			{
				throw new ArgumentNullException("ctx");
			}
			if (local == null)
			{
				throw new ArgumentNullException("local");
			}
			Type type = local.Type;
			if ((!type.IsValueType && !type.IsSealed) || ctx.MapType(typeof(IDisposable)).IsAssignableFrom(type))
			{
				this.local = local;
				this.ctx = ctx;
				label = ctx.BeginTry();
			}
		}

		public void Dispose()
		{
			if (this.local == null || ctx == null)
			{
				return;
			}
			ctx.EndTry(label, @short: false);
			ctx.BeginFinally();
			Type type = ctx.MapType(typeof(IDisposable));
			MethodInfo method = type.GetMethod("Dispose");
			Type type2 = this.local.Type;
			if (type2.IsValueType)
			{
				ctx.LoadAddress(this.local, type2);
				if (ctx.MetadataVersion == ILVersion.Net1)
				{
					ctx.LoadValue(this.local);
					ctx.CastToObject(type2);
				}
				else
				{
					ctx.Constrain(type2);
				}
				ctx.EmitCall(method);
			}
			else
			{
				CodeLabel codeLabel = ctx.DefineLabel();
				if (type.IsAssignableFrom(type2))
				{
					ctx.LoadValue(this.local);
					ctx.BranchIfFalse(codeLabel, @short: true);
					ctx.LoadAddress(this.local, type2);
				}
				else
				{
					using Local local = new Local(ctx, type);
					ctx.LoadValue(this.local);
					ctx.TryCast(type);
					ctx.CopyValue();
					ctx.StoreValue(local);
					ctx.BranchIfFalse(codeLabel, @short: true);
					ctx.LoadAddress(local, type);
				}
				ctx.EmitCall(method);
				ctx.MarkLabel(codeLabel);
			}
			ctx.EndFinally();
			this.local = null;
			ctx = null;
			label = default(CodeLabel);
		}
	}

	public enum ILVersion
	{
		Net1,
		Net2
	}

	private readonly DynamicMethod method;

	private static int next;

	private readonly bool isStatic;

	private readonly RuntimeTypeModel.SerializerPair[] methodPairs;

	private readonly bool isWriter;

	private readonly bool nonPublic;

	private readonly Local inputValue;

	private readonly string assemblyName;

	private readonly ILGenerator il;

	private MutableList locals = new MutableList();

	private int nextLabel;

	private BasicList knownTrustedAssemblies;

	private BasicList knownUntrustedAssemblies;

	private readonly TypeModel model;

	private readonly ILVersion metadataVersion;

	public TypeModel Model => model;

	internal bool NonPublic => nonPublic;

	public Local InputValue => inputValue;

	public ILVersion MetadataVersion => metadataVersion;

	internal CodeLabel DefineLabel()
	{
		CodeLabel result = new CodeLabel(il.DefineLabel(), nextLabel++);
		return result;
	}

	internal void MarkLabel(CodeLabel label)
	{
		il.MarkLabel(label.Value);
	}

	public static ProtoSerializer BuildSerializer(IProtoSerializer head, TypeModel model)
	{
		Type expectedType = head.ExpectedType;
		try
		{
			CompilerContext compilerContext = new CompilerContext(expectedType, isWriter: true, isStatic: true, model, typeof(object));
			compilerContext.LoadValue(compilerContext.InputValue);
			compilerContext.CastFromObject(expectedType);
			compilerContext.WriteNullCheckedTail(expectedType, head, null);
			compilerContext.Emit(OpCodes.Ret);
			return (ProtoSerializer)compilerContext.method.CreateDelegate(typeof(ProtoSerializer));
		}
		catch (Exception innerException)
		{
			string text = expectedType.FullName;
			if (string.IsNullOrEmpty(text))
			{
				text = expectedType.Name;
			}
			throw new InvalidOperationException("It was not possible to prepare a serializer for: " + text, innerException);
		}
	}

	public static ProtoDeserializer BuildDeserializer(IProtoSerializer head, TypeModel model)
	{
		Type expectedType = head.ExpectedType;
		CompilerContext compilerContext = new CompilerContext(expectedType, isWriter: false, isStatic: true, model, typeof(object));
		using (Local local = new Local(compilerContext, expectedType))
		{
			if (!expectedType.IsValueType)
			{
				compilerContext.LoadValue(compilerContext.InputValue);
				compilerContext.CastFromObject(expectedType);
				compilerContext.StoreValue(local);
			}
			else
			{
				compilerContext.LoadValue(compilerContext.InputValue);
				CodeLabel label = compilerContext.DefineLabel();
				CodeLabel label2 = compilerContext.DefineLabel();
				compilerContext.BranchIfTrue(label, @short: true);
				compilerContext.LoadAddress(local, expectedType);
				compilerContext.EmitCtor(expectedType);
				compilerContext.Branch(label2, @short: true);
				compilerContext.MarkLabel(label);
				compilerContext.LoadValue(compilerContext.InputValue);
				compilerContext.CastFromObject(expectedType);
				compilerContext.StoreValue(local);
				compilerContext.MarkLabel(label2);
			}
			head.EmitRead(compilerContext, local);
			if (head.ReturnsValue)
			{
				compilerContext.StoreValue(local);
			}
			compilerContext.LoadValue(local);
			compilerContext.CastToObject(expectedType);
		}
		compilerContext.Emit(OpCodes.Ret);
		return (ProtoDeserializer)compilerContext.method.CreateDelegate(typeof(ProtoDeserializer));
	}

	internal void Return()
	{
		Emit(OpCodes.Ret);
	}

	private static bool IsObject(Type type)
	{
		return (object)type == typeof(object);
	}

	internal void CastToObject(Type type)
	{
		if (!IsObject(type))
		{
			if (type.IsValueType)
			{
				il.Emit(OpCodes.Box, type);
			}
			else
			{
				il.Emit(OpCodes.Castclass, MapType(typeof(object)));
			}
		}
	}

	internal void CastFromObject(Type type)
	{
		if (IsObject(type))
		{
			return;
		}
		if (type.IsValueType)
		{
			if (MetadataVersion == ILVersion.Net1)
			{
				il.Emit(OpCodes.Unbox, type);
				il.Emit(OpCodes.Ldobj, type);
			}
			else
			{
				il.Emit(OpCodes.Unbox_Any, type);
			}
		}
		else
		{
			il.Emit(OpCodes.Castclass, type);
		}
	}

	internal MethodBuilder GetDedicatedMethod(int metaKey, bool read)
	{
		if (methodPairs == null)
		{
			return null;
		}
		for (int i = 0; i < methodPairs.Length; i++)
		{
			if (methodPairs[i].MetaKey == metaKey)
			{
				if (!read)
				{
					return methodPairs[i].Serialize;
				}
				return methodPairs[i].Deserialize;
			}
		}
		throw new ArgumentException("Meta-key not found", "metaKey");
	}

	internal int MapMetaKeyToCompiledKey(int metaKey)
	{
		if (metaKey < 0 || methodPairs == null)
		{
			return metaKey;
		}
		for (int i = 0; i < methodPairs.Length; i++)
		{
			if (methodPairs[i].MetaKey == metaKey)
			{
				return i;
			}
		}
		throw new ArgumentException("Key could not be mapped: " + metaKey, "metaKey");
	}

	internal CompilerContext(ILGenerator il, bool isStatic, bool isWriter, RuntimeTypeModel.SerializerPair[] methodPairs, TypeModel model, ILVersion metadataVersion, string assemblyName, Type inputType)
	{
		if (il == null)
		{
			throw new ArgumentNullException("il");
		}
		if (methodPairs == null)
		{
			throw new ArgumentNullException("methodPairs");
		}
		if (model == null)
		{
			throw new ArgumentNullException("model");
		}
		if (Helpers.IsNullOrEmpty(assemblyName))
		{
			throw new ArgumentNullException("assemblyName");
		}
		this.assemblyName = assemblyName;
		this.isStatic = isStatic;
		this.methodPairs = methodPairs;
		this.il = il;
		this.isWriter = isWriter;
		this.model = model;
		this.metadataVersion = metadataVersion;
		if ((object)inputType != null)
		{
			inputValue = new Local(null, inputType);
		}
	}

	private CompilerContext(Type associatedType, bool isWriter, bool isStatic, TypeModel model, Type inputType)
	{
		if (model == null)
		{
			throw new ArgumentNullException("model");
		}
		metadataVersion = ILVersion.Net2;
		this.isStatic = isStatic;
		this.isWriter = isWriter;
		this.model = model;
		nonPublic = true;
		Type typeFromHandle;
		Type[] parameterTypes;
		if (isWriter)
		{
			typeFromHandle = typeof(void);
			parameterTypes = new Type[2]
			{
				typeof(object),
				typeof(ProtoWriter)
			};
		}
		else
		{
			typeFromHandle = typeof(object);
			parameterTypes = new Type[2]
			{
				typeof(object),
				typeof(ProtoReader)
			};
		}
		method = new DynamicMethod("proto_" + ++next, typeFromHandle, parameterTypes, associatedType.IsInterface ? typeof(object) : associatedType, skipVisibility: true);
		il = method.GetILGenerator();
		if ((object)inputType != null)
		{
			inputValue = new Local(null, inputType);
		}
	}

	private void Emit(OpCode opcode)
	{
		il.Emit(opcode);
	}

	public void LoadValue(string value)
	{
		if (value == null)
		{
			LoadNullRef();
		}
		else
		{
			il.Emit(OpCodes.Ldstr, value);
		}
	}

	public void LoadValue(float value)
	{
		il.Emit(OpCodes.Ldc_R4, value);
	}

	public void LoadValue(double value)
	{
		il.Emit(OpCodes.Ldc_R8, value);
	}

	public void LoadValue(long value)
	{
		il.Emit(OpCodes.Ldc_I8, value);
	}

	public void LoadValue(int value)
	{
		switch (value)
		{
		case 0:
			Emit(OpCodes.Ldc_I4_0);
			return;
		case 1:
			Emit(OpCodes.Ldc_I4_1);
			return;
		case 2:
			Emit(OpCodes.Ldc_I4_2);
			return;
		case 3:
			Emit(OpCodes.Ldc_I4_3);
			return;
		case 4:
			Emit(OpCodes.Ldc_I4_4);
			return;
		case 5:
			Emit(OpCodes.Ldc_I4_5);
			return;
		case 6:
			Emit(OpCodes.Ldc_I4_6);
			return;
		case 7:
			Emit(OpCodes.Ldc_I4_7);
			return;
		case 8:
			Emit(OpCodes.Ldc_I4_8);
			return;
		case -1:
			Emit(OpCodes.Ldc_I4_M1);
			return;
		}
		if (value >= -128 && value <= 127)
		{
			il.Emit(OpCodes.Ldc_I4_S, (sbyte)value);
		}
		else
		{
			il.Emit(OpCodes.Ldc_I4, value);
		}
	}

	internal LocalBuilder GetFromPool(Type type)
	{
		int count = locals.Count;
		for (int i = 0; i < count; i++)
		{
			LocalBuilder localBuilder = (LocalBuilder)locals[i];
			if (localBuilder != null && (object)localBuilder.LocalType == type)
			{
				locals[i] = null;
				return localBuilder;
			}
		}
		return il.DeclareLocal(type);
	}

	internal void ReleaseToPool(LocalBuilder value)
	{
		int count = locals.Count;
		for (int i = 0; i < count; i++)
		{
			if (locals[i] == null)
			{
				locals[i] = value;
				return;
			}
		}
		locals.Add(value);
	}

	public void LoadReaderWriter()
	{
		Emit(isStatic ? OpCodes.Ldarg_1 : OpCodes.Ldarg_2);
	}

	public void StoreValue(Local local)
	{
		if (local == InputValue)
		{
			byte arg = ((!isStatic) ? ((byte)1) : ((byte)0));
			il.Emit(OpCodes.Starg_S, arg);
			return;
		}
		switch (local.Value.LocalIndex)
		{
		case 0:
			Emit(OpCodes.Stloc_0);
			break;
		case 1:
			Emit(OpCodes.Stloc_1);
			break;
		case 2:
			Emit(OpCodes.Stloc_2);
			break;
		case 3:
			Emit(OpCodes.Stloc_3);
			break;
		default:
		{
			OpCode opcode = (UseShortForm(local) ? OpCodes.Stloc_S : OpCodes.Stloc);
			il.Emit(opcode, local.Value);
			break;
		}
		}
	}

	public void LoadValue(Local local)
	{
		if (local == null)
		{
			return;
		}
		if (local == InputValue)
		{
			Emit(isStatic ? OpCodes.Ldarg_0 : OpCodes.Ldarg_1);
			return;
		}
		switch (local.Value.LocalIndex)
		{
		case 0:
			Emit(OpCodes.Ldloc_0);
			break;
		case 1:
			Emit(OpCodes.Ldloc_1);
			break;
		case 2:
			Emit(OpCodes.Ldloc_2);
			break;
		case 3:
			Emit(OpCodes.Ldloc_3);
			break;
		default:
		{
			OpCode opcode = (UseShortForm(local) ? OpCodes.Ldloc_S : OpCodes.Ldloc);
			il.Emit(opcode, local.Value);
			break;
		}
		}
	}

	public Local GetLocalWithValue(Type type, Local fromValue)
	{
		if (fromValue != null)
		{
			if ((object)fromValue.Type == type)
			{
				return fromValue.AsCopy();
			}
			LoadValue(fromValue);
			if (!type.IsValueType && ((object)fromValue.Type == null || !type.IsAssignableFrom(fromValue.Type)))
			{
				Cast(type);
			}
		}
		Local local = new Local(this, type);
		StoreValue(local);
		return local;
	}

	internal void EmitBasicRead(string methodName, Type expectedType)
	{
		MethodInfo methodInfo = MapType(typeof(ProtoReader)).GetMethod(methodName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		if ((object)methodInfo == null || (object)methodInfo.ReturnType != expectedType || methodInfo.GetParameters().Length != 0)
		{
			throw new ArgumentException("methodName");
		}
		LoadReaderWriter();
		EmitCall(methodInfo);
	}

	internal void EmitBasicRead(Type helperType, string methodName, Type expectedType)
	{
		MethodInfo methodInfo = helperType.GetMethod(methodName, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if ((object)methodInfo == null || (object)methodInfo.ReturnType != expectedType || methodInfo.GetParameters().Length != 1)
		{
			throw new ArgumentException("methodName");
		}
		LoadReaderWriter();
		EmitCall(methodInfo);
	}

	internal void EmitBasicWrite(string methodName, Local fromValue)
	{
		if (Helpers.IsNullOrEmpty(methodName))
		{
			throw new ArgumentNullException("methodName");
		}
		LoadValue(fromValue);
		LoadReaderWriter();
		EmitCall(GetWriterMethod(methodName));
	}

	private MethodInfo GetWriterMethod(string methodName)
	{
		Type type = MapType(typeof(ProtoWriter));
		MethodInfo[] methods = type.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		MethodInfo[] array = methods;
		foreach (MethodInfo methodInfo in array)
		{
			if (!(methodInfo.Name != methodName))
			{
				ParameterInfo[] parameters = methodInfo.GetParameters();
				if (parameters.Length == 2 && (object)parameters[1].ParameterType == type)
				{
					return methodInfo;
				}
			}
		}
		throw new ArgumentException("No suitable method found for: " + methodName, "methodName");
	}

	internal void EmitWrite(Type helperType, string methodName, Local valueFrom)
	{
		if (Helpers.IsNullOrEmpty(methodName))
		{
			throw new ArgumentNullException("methodName");
		}
		MethodInfo methodInfo = helperType.GetMethod(methodName, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		if ((object)methodInfo == null || (object)methodInfo.ReturnType != MapType(typeof(void)))
		{
			throw new ArgumentException("methodName");
		}
		LoadValue(valueFrom);
		LoadReaderWriter();
		EmitCall(methodInfo);
	}

	public void EmitCall(MethodInfo method)
	{
		CheckAccessibility(method);
		OpCode opcode = ((method.IsStatic || method.DeclaringType.IsValueType) ? OpCodes.Call : OpCodes.Callvirt);
		il.EmitCall(opcode, method, null);
	}

	public void LoadNullRef()
	{
		Emit(OpCodes.Ldnull);
	}

	internal void WriteNullCheckedTail(Type type, IProtoSerializer tail, Local valueFrom)
	{
		if (type.IsValueType)
		{
			Type type2 = null;
			type2 = Helpers.GetUnderlyingType(type);
			if ((object)type2 != null)
			{
				using (Local local = GetLocalWithValue(type, valueFrom))
				{
					LoadAddress(local, type);
					LoadValue(type.GetProperty("HasValue"));
					CodeLabel label = DefineLabel();
					BranchIfFalse(label, @short: false);
					LoadAddress(local, type);
					EmitCall(type.GetMethod("GetValueOrDefault", Helpers.EmptyTypes));
					tail.EmitWrite(this, null);
					MarkLabel(label);
					return;
				}
			}
			tail.EmitWrite(this, valueFrom);
		}
		else
		{
			LoadValue(valueFrom);
			CopyValue();
			CodeLabel label2 = DefineLabel();
			CodeLabel label3 = DefineLabel();
			BranchIfTrue(label2, @short: true);
			DiscardValue();
			Branch(label3, @short: false);
			MarkLabel(label2);
			tail.EmitWrite(this, null);
			MarkLabel(label3);
		}
	}

	internal void ReadNullCheckedTail(Type type, IProtoSerializer tail, Local valueFrom)
	{
		Type underlyingType;
		if (type.IsValueType && (object)(underlyingType = Helpers.GetUnderlyingType(type)) != null)
		{
			if (tail.RequiresOldValue)
			{
				using Local local = GetLocalWithValue(type, valueFrom);
				LoadAddress(local, type);
				EmitCall(type.GetMethod("GetValueOrDefault", Helpers.EmptyTypes));
			}
			tail.EmitRead(this, null);
			if (tail.ReturnsValue)
			{
				EmitCtor(type, underlyingType);
			}
		}
		else
		{
			tail.EmitRead(this, valueFrom);
		}
	}

	public void EmitCtor(Type type)
	{
		EmitCtor(type, Helpers.EmptyTypes);
	}

	public void EmitCtor(ConstructorInfo ctor)
	{
		if ((object)ctor == null)
		{
			throw new ArgumentNullException("ctor");
		}
		CheckAccessibility(ctor);
		il.Emit(OpCodes.Newobj, ctor);
	}

	public void EmitCtor(Type type, params Type[] parameterTypes)
	{
		if (type.IsValueType && parameterTypes.Length == 0)
		{
			il.Emit(OpCodes.Initobj, type);
			return;
		}
		ConstructorInfo constructor = Helpers.GetConstructor(type, parameterTypes, nonPublic: true);
		if ((object)constructor == null)
		{
			throw new InvalidOperationException("No suitable constructor found for " + type.FullName);
		}
		EmitCtor(constructor);
	}

	private bool InternalsVisible(Assembly assembly)
	{
		if (Helpers.IsNullOrEmpty(assemblyName))
		{
			return false;
		}
		if (knownTrustedAssemblies != null && knownTrustedAssemblies.IndexOfReference(assembly) >= 0)
		{
			return true;
		}
		if (knownUntrustedAssemblies != null && knownUntrustedAssemblies.IndexOfReference(assembly) >= 0)
		{
			return false;
		}
		bool flag = false;
		Type type = MapType(typeof(InternalsVisibleToAttribute));
		if ((object)type == null)
		{
			return false;
		}
		object[] customAttributes = assembly.GetCustomAttributes(type, inherit: false);
		for (int i = 0; i < customAttributes.Length; i++)
		{
			InternalsVisibleToAttribute internalsVisibleToAttribute = (InternalsVisibleToAttribute)customAttributes[i];
			if (internalsVisibleToAttribute.AssemblyName == assemblyName || internalsVisibleToAttribute.AssemblyName.StartsWith(assemblyName + ","))
			{
				flag = true;
				break;
			}
		}
		if (flag)
		{
			if (knownTrustedAssemblies == null)
			{
				knownTrustedAssemblies = new BasicList();
			}
			knownTrustedAssemblies.Add(assembly);
		}
		else
		{
			if (knownUntrustedAssemblies == null)
			{
				knownUntrustedAssemblies = new BasicList();
			}
			knownUntrustedAssemblies.Add(assembly);
		}
		return flag;
	}

	internal void CheckAccessibility(MemberInfo member)
	{
		if ((object)member == null)
		{
			throw new ArgumentNullException("member");
		}
		MemberTypes memberType = member.MemberType;
		if (NonPublic)
		{
			return;
		}
		bool flag;
		switch (memberType)
		{
		case MemberTypes.TypeInfo:
		{
			Type type = (Type)member;
			flag = type.IsPublic || InternalsVisible(type.Assembly);
			break;
		}
		case MemberTypes.NestedType:
		{
			Type type = (Type)member;
			do
			{
				flag = type.IsNestedPublic || type.IsPublic || (((object)type.DeclaringType == null || type.IsNestedAssembly || type.IsNestedFamORAssem) && InternalsVisible(type.Assembly));
			}
			while (flag && (object)(type = type.DeclaringType) != null);
			break;
		}
		case MemberTypes.Field:
		{
			FieldInfo fieldInfo = (FieldInfo)member;
			flag = fieldInfo.IsPublic || ((fieldInfo.IsAssembly || fieldInfo.IsFamilyOrAssembly) && InternalsVisible(fieldInfo.DeclaringType.Assembly));
			break;
		}
		case MemberTypes.Constructor:
		{
			ConstructorInfo constructorInfo = (ConstructorInfo)member;
			flag = constructorInfo.IsPublic || ((constructorInfo.IsAssembly || constructorInfo.IsFamilyOrAssembly) && InternalsVisible(constructorInfo.DeclaringType.Assembly));
			break;
		}
		case MemberTypes.Method:
		{
			MethodInfo methodInfo = (MethodInfo)member;
			flag = methodInfo.IsPublic || ((methodInfo.IsAssembly || methodInfo.IsFamilyOrAssembly) && InternalsVisible(methodInfo.DeclaringType.Assembly));
			if (!flag && (member is MethodBuilder || (object)member.DeclaringType == MapType(typeof(TypeModel))))
			{
				flag = true;
			}
			break;
		}
		case MemberTypes.Property:
			flag = true;
			break;
		default:
			throw new NotSupportedException(memberType.ToString());
		}
		if (!flag)
		{
			MemberTypes memberTypes = memberType;
			if (memberTypes == MemberTypes.TypeInfo || memberTypes == MemberTypes.NestedType)
			{
				throw new InvalidOperationException("Non-public type cannot be used with full dll compilation: " + ((Type)member).FullName);
			}
			throw new InvalidOperationException("Non-public member cannot be used with full dll compilation: " + member.DeclaringType.FullName + "." + member.Name);
		}
	}

	public void LoadValue(FieldInfo field)
	{
		CheckAccessibility(field);
		OpCode opcode = (field.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld);
		il.Emit(opcode, field);
	}

	public void StoreValue(FieldInfo field)
	{
		CheckAccessibility(field);
		OpCode opcode = (field.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld);
		il.Emit(opcode, field);
	}

	public void LoadValue(PropertyInfo property)
	{
		CheckAccessibility(property);
		EmitCall(Helpers.GetGetMethod(property, nonPublic: true, allowInternal: true));
	}

	public void StoreValue(PropertyInfo property)
	{
		CheckAccessibility(property);
		EmitCall(Helpers.GetSetMethod(property, nonPublic: true, allowInternal: true));
	}

	internal static void LoadValue(ILGenerator il, int value)
	{
		switch (value)
		{
		case 0:
			il.Emit(OpCodes.Ldc_I4_0);
			break;
		case 1:
			il.Emit(OpCodes.Ldc_I4_1);
			break;
		case 2:
			il.Emit(OpCodes.Ldc_I4_2);
			break;
		case 3:
			il.Emit(OpCodes.Ldc_I4_3);
			break;
		case 4:
			il.Emit(OpCodes.Ldc_I4_4);
			break;
		case 5:
			il.Emit(OpCodes.Ldc_I4_5);
			break;
		case 6:
			il.Emit(OpCodes.Ldc_I4_6);
			break;
		case 7:
			il.Emit(OpCodes.Ldc_I4_7);
			break;
		case 8:
			il.Emit(OpCodes.Ldc_I4_8);
			break;
		case -1:
			il.Emit(OpCodes.Ldc_I4_M1);
			break;
		default:
			il.Emit(OpCodes.Ldc_I4, value);
			break;
		}
	}

	private bool UseShortForm(Local local)
	{
		return local.Value.LocalIndex < 256;
	}

	internal void LoadAddress(Local local, Type type)
	{
		if (type.IsValueType)
		{
			if (local == null)
			{
				throw new InvalidOperationException("Cannot load the address of a struct at the head of the stack");
			}
			if (local == InputValue)
			{
				il.Emit(OpCodes.Ldarga_S, (!isStatic) ? ((byte)1) : ((byte)0));
				return;
			}
			OpCode opcode = (UseShortForm(local) ? OpCodes.Ldloca_S : OpCodes.Ldloca);
			il.Emit(opcode, local.Value);
		}
		else
		{
			LoadValue(local);
		}
	}

	internal void Branch(CodeLabel label, bool @short)
	{
		OpCode opcode = (@short ? OpCodes.Br_S : OpCodes.Br);
		il.Emit(opcode, label.Value);
	}

	internal void BranchIfFalse(CodeLabel label, bool @short)
	{
		OpCode opcode = (@short ? OpCodes.Brfalse_S : OpCodes.Brfalse);
		il.Emit(opcode, label.Value);
	}

	internal void BranchIfTrue(CodeLabel label, bool @short)
	{
		OpCode opcode = (@short ? OpCodes.Brtrue_S : OpCodes.Brtrue);
		il.Emit(opcode, label.Value);
	}

	internal void BranchIfEqual(CodeLabel label, bool @short)
	{
		OpCode opcode = (@short ? OpCodes.Beq_S : OpCodes.Beq);
		il.Emit(opcode, label.Value);
	}

	internal void CopyValue()
	{
		Emit(OpCodes.Dup);
	}

	internal void BranchIfGreater(CodeLabel label, bool @short)
	{
		OpCode opcode = (@short ? OpCodes.Bgt_S : OpCodes.Bgt);
		il.Emit(opcode, label.Value);
	}

	internal void BranchIfLess(CodeLabel label, bool @short)
	{
		OpCode opcode = (@short ? OpCodes.Blt_S : OpCodes.Blt);
		il.Emit(opcode, label.Value);
	}

	internal void DiscardValue()
	{
		Emit(OpCodes.Pop);
	}

	public void Subtract()
	{
		Emit(OpCodes.Sub);
	}

	public void Switch(CodeLabel[] jumpTable)
	{
		if (jumpTable.Length <= 128)
		{
			Label[] array = new Label[jumpTable.Length];
			for (int i = 0; i < array.Length; i++)
			{
				ref Label reference = ref array[i];
				reference = jumpTable[i].Value;
			}
			il.Emit(OpCodes.Switch, array);
			return;
		}
		using Local local = GetLocalWithValue(MapType(typeof(int)), null);
		int num = jumpTable.Length;
		int num2 = 0;
		int num3 = num / 128;
		if (num % 128 != 0)
		{
			num3++;
		}
		Label[] array2 = new Label[num3];
		for (int j = 0; j < num3; j++)
		{
			ref Label reference2 = ref array2[j];
			reference2 = il.DefineLabel();
		}
		CodeLabel label = DefineLabel();
		LoadValue(local);
		LoadValue(128);
		Emit(OpCodes.Div);
		il.Emit(OpCodes.Switch, array2);
		Branch(label, @short: false);
		Label[] array3 = new Label[128];
		for (int k = 0; k < num3; k++)
		{
			il.MarkLabel(array2[k]);
			int num4 = Math.Min(128, num);
			num -= num4;
			if (array3.Length != num4)
			{
				array3 = new Label[num4];
			}
			int num5 = num2;
			for (int l = 0; l < num4; l++)
			{
				ref Label reference3 = ref array3[l];
				reference3 = jumpTable[num2++].Value;
			}
			LoadValue(local);
			if (num5 != 0)
			{
				LoadValue(num5);
				Emit(OpCodes.Sub);
			}
			il.Emit(OpCodes.Switch, array3);
			if (num != 0)
			{
				Branch(label, @short: false);
			}
		}
		MarkLabel(label);
	}

	internal void EndFinally()
	{
		il.EndExceptionBlock();
	}

	internal void BeginFinally()
	{
		il.BeginFinallyBlock();
	}

	internal void EndTry(CodeLabel label, bool @short)
	{
		OpCode opcode = (@short ? OpCodes.Leave_S : OpCodes.Leave);
		il.Emit(opcode, label.Value);
	}

	internal CodeLabel BeginTry()
	{
		CodeLabel result = new CodeLabel(il.BeginExceptionBlock(), nextLabel++);
		return result;
	}

	internal void Constrain(Type type)
	{
		il.Emit(OpCodes.Constrained, type);
	}

	internal void TryCast(Type type)
	{
		il.Emit(OpCodes.Isinst, type);
	}

	internal void Cast(Type type)
	{
		il.Emit(OpCodes.Castclass, type);
	}

	public IDisposable Using(Local local)
	{
		return new UsingBlock(this, local);
	}

	internal void Add()
	{
		Emit(OpCodes.Add);
	}

	internal void LoadLength(Local arr, bool zeroIfNull)
	{
		if (zeroIfNull)
		{
			CodeLabel label = DefineLabel();
			CodeLabel label2 = DefineLabel();
			LoadValue(arr);
			CopyValue();
			BranchIfTrue(label, @short: true);
			DiscardValue();
			LoadValue(0);
			Branch(label2, @short: true);
			MarkLabel(label);
			Emit(OpCodes.Ldlen);
			Emit(OpCodes.Conv_I4);
			MarkLabel(label2);
		}
		else
		{
			LoadValue(arr);
			Emit(OpCodes.Ldlen);
			Emit(OpCodes.Conv_I4);
		}
	}

	internal void CreateArray(Type elementType, Local length)
	{
		LoadValue(length);
		il.Emit(OpCodes.Newarr, elementType);
	}

	internal void LoadArrayValue(Local arr, Local i)
	{
		Type type = arr.Type;
		type = type.GetElementType();
		LoadValue(arr);
		LoadValue(i);
		switch (Helpers.GetTypeCode(type))
		{
		case ProtoTypeCode.SByte:
			Emit(OpCodes.Ldelem_I1);
			return;
		case ProtoTypeCode.Int16:
			Emit(OpCodes.Ldelem_I2);
			return;
		case ProtoTypeCode.Int32:
			Emit(OpCodes.Ldelem_I4);
			return;
		case ProtoTypeCode.Int64:
			Emit(OpCodes.Ldelem_I8);
			return;
		case ProtoTypeCode.Byte:
			Emit(OpCodes.Ldelem_U1);
			return;
		case ProtoTypeCode.UInt16:
			Emit(OpCodes.Ldelem_U2);
			return;
		case ProtoTypeCode.UInt32:
			Emit(OpCodes.Ldelem_U4);
			return;
		case ProtoTypeCode.UInt64:
			Emit(OpCodes.Ldelem_I8);
			return;
		case ProtoTypeCode.Single:
			Emit(OpCodes.Ldelem_R4);
			return;
		case ProtoTypeCode.Double:
			Emit(OpCodes.Ldelem_R8);
			return;
		}
		if (type.IsValueType)
		{
			il.Emit(OpCodes.Ldelema, type);
			il.Emit(OpCodes.Ldobj, type);
		}
		else
		{
			Emit(OpCodes.Ldelem_Ref);
		}
	}

	internal void LoadValue(Type type)
	{
		il.Emit(OpCodes.Ldtoken, type);
		EmitCall(MapType(typeof(Type)).GetMethod("GetTypeFromHandle"));
	}

	internal void ConvertToInt32(ProtoTypeCode typeCode, bool uint32Overflow)
	{
		switch (typeCode)
		{
		case ProtoTypeCode.SByte:
		case ProtoTypeCode.Byte:
		case ProtoTypeCode.Int16:
		case ProtoTypeCode.UInt16:
			Emit(OpCodes.Conv_I4);
			break;
		case ProtoTypeCode.Int64:
			Emit(OpCodes.Conv_Ovf_I4);
			break;
		case ProtoTypeCode.UInt32:
			Emit(uint32Overflow ? OpCodes.Conv_Ovf_I4_Un : OpCodes.Conv_Ovf_I4);
			break;
		case ProtoTypeCode.UInt64:
			Emit(OpCodes.Conv_Ovf_I4_Un);
			break;
		default:
			throw new InvalidOperationException("ConvertToInt32 not implemented for: " + typeCode);
		case ProtoTypeCode.Int32:
			break;
		}
	}

	internal void ConvertFromInt32(ProtoTypeCode typeCode, bool uint32Overflow)
	{
		switch (typeCode)
		{
		case ProtoTypeCode.SByte:
			Emit(OpCodes.Conv_Ovf_I1);
			break;
		case ProtoTypeCode.Byte:
			Emit(OpCodes.Conv_Ovf_U1);
			break;
		case ProtoTypeCode.Int16:
			Emit(OpCodes.Conv_Ovf_I2);
			break;
		case ProtoTypeCode.UInt16:
			Emit(OpCodes.Conv_Ovf_U2);
			break;
		case ProtoTypeCode.UInt32:
			Emit(uint32Overflow ? OpCodes.Conv_Ovf_U4 : OpCodes.Conv_U4);
			break;
		case ProtoTypeCode.Int64:
			Emit(OpCodes.Conv_I8);
			break;
		case ProtoTypeCode.UInt64:
			Emit(OpCodes.Conv_U8);
			break;
		default:
			throw new InvalidOperationException();
		case ProtoTypeCode.Int32:
			break;
		}
	}

	internal void LoadValue(decimal value)
	{
		if (value == 0m)
		{
			LoadValue(typeof(decimal).GetField("Zero"));
			return;
		}
		int[] bits = decimal.GetBits(value);
		LoadValue(bits[0]);
		LoadValue(bits[1]);
		LoadValue(bits[2]);
		LoadValue(bits[3] >>> 31);
		LoadValue((bits[3] >> 16) & 0xFF);
		EmitCtor(MapType(typeof(decimal)), MapType(typeof(int)), MapType(typeof(int)), MapType(typeof(int)), MapType(typeof(bool)), MapType(typeof(byte)));
	}

	internal void LoadValue(Guid value)
	{
		if (value == Guid.Empty)
		{
			LoadValue(typeof(Guid).GetField("Empty"));
			return;
		}
		byte[] array = value.ToByteArray();
		int value2 = array[0] | (array[1] << 8) | (array[2] << 16) | (array[3] << 24);
		LoadValue(value2);
		short value3 = (short)(array[4] | (array[5] << 8));
		LoadValue(value3);
		value3 = (short)(array[6] | (array[7] << 8));
		LoadValue(value3);
		for (value2 = 8; value2 <= 15; value2++)
		{
			LoadValue(array[value2]);
		}
		EmitCtor(MapType(typeof(Guid)), MapType(typeof(int)), MapType(typeof(short)), MapType(typeof(short)), MapType(typeof(byte)), MapType(typeof(byte)), MapType(typeof(byte)), MapType(typeof(byte)), MapType(typeof(byte)), MapType(typeof(byte)), MapType(typeof(byte)), MapType(typeof(byte)));
	}

	internal void LoadSerializationContext()
	{
		LoadReaderWriter();
		LoadValue((isWriter ? typeof(ProtoWriter) : typeof(ProtoReader)).GetProperty("Context"));
	}

	internal Type MapType(Type type)
	{
		return model.MapType(type);
	}

	internal bool AllowInternal(PropertyInfo property)
	{
		if (!NonPublic)
		{
			return InternalsVisible(property.DeclaringType.Assembly);
		}
		return true;
	}
}


using System;
using System.Reflection;

private sealed class UsingBlock : IDisposable
{
	private Local local;

	private CompilerContext ctx;

	private CodeLabel label;

	public UsingBlock(CompilerContext ctx, Local local)
	{
		if (ctx == null)
		{
			throw new ArgumentNullException("ctx");
		}
		if (local == null)
		{
			throw new ArgumentNullException("local");
		}
		Type type = local.Type;
		if ((!type.IsValueType && !type.IsSealed) || ctx.MapType(typeof(IDisposable)).IsAssignableFrom(type))
		{
			this.local = local;
			this.ctx = ctx;
			label = ctx.BeginTry();
		}
	}

	public void Dispose()
	{
		if (this.local == null || ctx == null)
		{
			return;
		}
		ctx.EndTry(label, @short: false);
		ctx.BeginFinally();
		Type type = ctx.MapType(typeof(IDisposable));
		MethodInfo method = type.GetMethod("Dispose");
		Type type2 = this.local.Type;
		if (type2.IsValueType)
		{
			ctx.LoadAddress(this.local, type2);
			if (ctx.MetadataVersion == ILVersion.Net1)
			{
				ctx.LoadValue(this.local);
				ctx.CastToObject(type2);
			}
			else
			{
				ctx.Constrain(type2);
			}
			ctx.EmitCall(method);
		}
		else
		{
			CodeLabel codeLabel = ctx.DefineLabel();
			if (type.IsAssignableFrom(type2))
			{
				ctx.LoadValue(this.local);
				ctx.BranchIfFalse(codeLabel, @short: true);
				ctx.LoadAddress(this.local, type2);
			}
			else
			{
				using Local local = new Local(ctx, type);
				ctx.LoadValue(this.local);
				ctx.TryCast(type);
				ctx.CopyValue();
				ctx.StoreValue(local);
				ctx.BranchIfFalse(codeLabel, @short: true);
				ctx.LoadAddress(local, type);
			}
			ctx.EmitCall(method);
			ctx.MarkLabel(codeLabel);
		}
		ctx.EndFinally();
		this.local = null;
		ctx = null;
		label = default(CodeLabel);
	}
}


public enum ILVersion
{
	Net1,
	Net2
}


using System;
using System.Reflection.Emit;
using ProtoBuf.Compiler;

internal sealed class Local : IDisposable
{
	private LocalBuilder value;

	private CompilerContext ctx;

	private readonly Type type;

	public Type Type => type;

	internal LocalBuilder Value
	{
		get
		{
			if (value == null)
			{
				throw new ObjectDisposedException(GetType().Name);
			}
			return value;
		}
	}

	public Local AsCopy()
	{
		if (ctx == null)
		{
			return this;
		}
		return new Local(value, type);
	}

	public void Dispose()
	{
		if (ctx != null)
		{
			ctx.ReleaseToPool(value);
			value = null;
			ctx = null;
		}
	}

	private Local(LocalBuilder value, Type type)
	{
		this.value = value;
		this.type = type;
	}

	internal Local(CompilerContext ctx, Type type)
	{
		this.ctx = ctx;
		if (ctx != null)
		{
			value = ctx.GetFromPool(type);
		}
		this.type = type;
	}

	internal bool IsSame(Local other)
	{
		if (this == other)
		{
			return true;
		}
		object obj = value;
		if (other != null)
		{
			return obj == other.value;
		}
		return false;
	}
}


public enum DataFormat
{
	Default,
	ZigZag,
	TwosComplement,
	FixedSize,
	Group
}


using ProtoBuf;

public interface IExtensible
{
	IExtension GetExtensionObject(bool createIfMissing);
}


using System;
using System.Collections;
using System.Collections.Generic;
using ProtoBuf;
using ProtoBuf.Meta;

public abstract class Extensible : IExtensible
{
	private IExtension extensionObject;

	IExtension IExtensible.GetExtensionObject(bool createIfMissing)
	{
		return GetExtensionObject(createIfMissing);
	}

	protected virtual IExtension GetExtensionObject(bool createIfMissing)
	{
		return GetExtensionObject(ref extensionObject, createIfMissing);
	}

	public static IExtension GetExtensionObject(ref IExtension extensionObject, bool createIfMissing)
	{
		if (createIfMissing && extensionObject == null)
		{
			extensionObject = new BufferExtension();
		}
		return extensionObject;
	}

	public static void AppendValue<TValue>(IExtensible instance, int tag, TValue value)
	{
		AppendValue(instance, tag, DataFormat.Default, value);
	}

	public static void AppendValue<TValue>(IExtensible instance, int tag, DataFormat format, TValue value)
	{
		ExtensibleUtil.AppendExtendValue(RuntimeTypeModel.Default, instance, tag, format, value);
	}

	public static TValue GetValue<TValue>(IExtensible instance, int tag)
	{
		return GetValue<TValue>(instance, tag, DataFormat.Default);
	}

	public static TValue GetValue<TValue>(IExtensible instance, int tag, DataFormat format)
	{
		TryGetValue<TValue>(instance, tag, format, out var value);
		return value;
	}

	public static bool TryGetValue<TValue>(IExtensible instance, int tag, out TValue value)
	{
		return TryGetValue<TValue>(instance, tag, DataFormat.Default, out value);
	}

	public static bool TryGetValue<TValue>(IExtensible instance, int tag, DataFormat format, out TValue value)
	{
		return TryGetValue<TValue>(instance, tag, format, allowDefinedTag: false, out value);
	}

	public static bool TryGetValue<TValue>(IExtensible instance, int tag, DataFormat format, bool allowDefinedTag, out TValue value)
	{
		value = default(TValue);
		bool result = false;
		foreach (TValue extendedValue in ExtensibleUtil.GetExtendedValues<TValue>(instance, tag, format, singleton: true, allowDefinedTag))
		{
			value = extendedValue;
			result = true;
		}
		return result;
	}

	public static IEnumerable<TValue> GetValues<TValue>(IExtensible instance, int tag)
	{
		return ExtensibleUtil.GetExtendedValues<TValue>(instance, tag, DataFormat.Default, singleton: false, allowDefinedTag: false);
	}

	public static IEnumerable<TValue> GetValues<TValue>(IExtensible instance, int tag, DataFormat format)
	{
		return ExtensibleUtil.GetExtendedValues<TValue>(instance, tag, format, singleton: false, allowDefinedTag: false);
	}

	public static bool TryGetValue(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format, bool allowDefinedTag, out object value)
	{
		value = null;
		bool result = false;
		foreach (object extendedValue in ExtensibleUtil.GetExtendedValues(model, type, instance, tag, format, singleton: true, allowDefinedTag))
		{
			value = extendedValue;
			result = true;
		}
		return result;
	}

	public static IEnumerable GetValues(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format)
	{
		return ExtensibleUtil.GetExtendedValues(model, type, instance, tag, format, singleton: false, allowDefinedTag: false);
	}

	public static void AppendValue(TypeModel model, IExtensible instance, int tag, DataFormat format, object value)
	{
		ExtensibleUtil.AppendExtendValue(model, instance, tag, format, value);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using ProtoBuf;
using ProtoBuf.Meta;

internal static class ExtensibleUtil
{
	internal static IEnumerable<TValue> GetExtendedValues<TValue>(IExtensible instance, int tag, DataFormat format, bool singleton, bool allowDefinedTag)
	{
		foreach (TValue extendedValue in GetExtendedValues(RuntimeTypeModel.Default, typeof(TValue), instance, tag, format, singleton, allowDefinedTag))
		{
			yield return extendedValue;
		}
	}

	internal static IEnumerable GetExtendedValues(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format, bool singleton, bool allowDefinedTag)
	{
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		if (tag <= 0)
		{
			throw new ArgumentOutOfRangeException("tag");
		}
		IExtension extn = instance.GetExtensionObject(createIfMissing: false);
		if (extn == null)
		{
			yield break;
		}
		Stream stream = extn.BeginQuery();
		object value = null;
		ProtoReader reader = null;
		try
		{
			SerializationContext ctx = new SerializationContext();
			reader = ProtoReader.Create(stream, model, ctx, -1);
			while (model.TryDeserializeAuxiliaryType(reader, format, tag, type, ref value, skipOtherFields: true, asListItem: false, autoCreate: false, insideList: false) && value != null)
			{
				if (!singleton)
				{
					yield return value;
					value = null;
				}
			}
			if (singleton && value != null)
			{
				yield return value;
			}
		}
		finally
		{
			ProtoReader.Recycle(reader);
			extn.EndQuery(stream);
		}
	}

	internal static void AppendExtendValue(TypeModel model, IExtensible instance, int tag, DataFormat format, object value)
	{
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		IExtension extensionObject = instance.GetExtensionObject(createIfMissing: true);
		if (extensionObject == null)
		{
			throw new InvalidOperationException("No extension object available; appended data would be lost.");
		}
		bool commit = false;
		Stream stream = extensionObject.BeginAppend();
		try
		{
			using (ProtoWriter protoWriter = new ProtoWriter(stream, model, null))
			{
				model.TrySerializeAuxiliaryType(protoWriter, null, format, tag, value, isInsideList: false);
				protoWriter.Close();
			}
			commit = true;
		}
		finally
		{
			extensionObject.EndAppend(stream, commit);
		}
	}
}


#define TRACE
using System;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using ProtoBuf;

internal sealed class Helpers
{
	public static readonly Type[] EmptyTypes = Type.EmptyTypes;

	private Helpers()
	{
	}

	public static StringBuilder AppendLine(StringBuilder builder)
	{
		return builder.AppendLine();
	}

	public static bool IsNullOrEmpty(string value)
	{
		if (value != null)
		{
			return value.Length == 0;
		}
		return true;
	}

	[Conditional("DEBUG")]
	public static void DebugWriteLine(string message, object obj)
	{
	}

	[Conditional("DEBUG")]
	public static void DebugWriteLine(string message)
	{
	}

	[Conditional("TRACE")]
	public static void TraceWriteLine(string message)
	{
		Trace.WriteLine(message);
	}

	[Conditional("DEBUG")]
	public static void DebugAssert(bool condition, string message)
	{
	}

	[Conditional("DEBUG")]
	public static void DebugAssert(bool condition, string message, params object[] args)
	{
	}

	[Conditional("DEBUG")]
	public static void DebugAssert(bool condition)
	{
	}

	public static void Sort(int[] keys, object[] values)
	{
		bool flag;
		do
		{
			flag = false;
			for (int i = 1; i < keys.Length; i++)
			{
				if (keys[i - 1] > keys[i])
				{
					int num = keys[i];
					keys[i] = keys[i - 1];
					keys[i - 1] = num;
					object obj = values[i];
					values[i] = values[i - 1];
					values[i - 1] = obj;
					flag = true;
				}
			}
		}
		while (flag);
	}

	public static void BlockCopy(byte[] from, int fromIndex, byte[] to, int toIndex, int count)
	{
		Buffer.BlockCopy(from, fromIndex, to, toIndex, count);
	}

	public static bool IsInfinity(float value)
	{
		return float.IsInfinity(value);
	}

	internal static MethodInfo GetInstanceMethod(Type declaringType, string name)
	{
		return declaringType.GetMethod(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
	}

	internal static MethodInfo GetStaticMethod(Type declaringType, string name)
	{
		return declaringType.GetMethod(name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
	}

	internal static MethodInfo GetInstanceMethod(Type declaringType, string name, Type[] types)
	{
		if (types == null)
		{
			types = EmptyTypes;
		}
		return declaringType.GetMethod(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, types, null);
	}

	internal static bool IsSubclassOf(Type type, Type baseClass)
	{
		return type.IsSubclassOf(baseClass);
	}

	public static bool IsInfinity(double value)
	{
		return double.IsInfinity(value);
	}

	public static ProtoTypeCode GetTypeCode(Type type)
	{
		TypeCode typeCode = Type.GetTypeCode(type);
		switch (typeCode)
		{
		case TypeCode.Empty:
		case TypeCode.Boolean:
		case TypeCode.Char:
		case TypeCode.SByte:
		case TypeCode.Byte:
		case TypeCode.Int16:
		case TypeCode.UInt16:
		case TypeCode.Int32:
		case TypeCode.UInt32:
		case TypeCode.Int64:
		case TypeCode.UInt64:
		case TypeCode.Single:
		case TypeCode.Double:
		case TypeCode.Decimal:
		case TypeCode.DateTime:
		case TypeCode.String:
			return (ProtoTypeCode)typeCode;
		default:
			if ((object)type == typeof(TimeSpan))
			{
				return ProtoTypeCode.TimeSpan;
			}
			if ((object)type == typeof(Guid))
			{
				return ProtoTypeCode.Guid;
			}
			if ((object)type == typeof(Uri))
			{
				return ProtoTypeCode.Uri;
			}
			if ((object)type == typeof(byte[]))
			{
				return ProtoTypeCode.ByteArray;
			}
			if ((object)type == typeof(Type))
			{
				return ProtoTypeCode.Type;
			}
			return ProtoTypeCode.Unknown;
		}
	}

	internal static Type GetUnderlyingType(Type type)
	{
		return Nullable.GetUnderlyingType(type);
	}

	internal static bool IsValueType(Type type)
	{
		return type.IsValueType;
	}

	internal static bool IsEnum(Type type)
	{
		return type.IsEnum;
	}

	internal static MethodInfo GetGetMethod(PropertyInfo property, bool nonPublic, bool allowInternal)
	{
		if ((object)property == null)
		{
			return null;
		}
		MethodInfo methodInfo = property.GetGetMethod(nonPublic);
		if ((object)methodInfo == null && !nonPublic && allowInternal)
		{
			methodInfo = property.GetGetMethod(nonPublic: true);
			if ((object)methodInfo == null && !methodInfo.IsAssembly && !methodInfo.IsFamilyOrAssembly)
			{
				methodInfo = null;
			}
		}
		return methodInfo;
	}

	internal static MethodInfo GetSetMethod(PropertyInfo property, bool nonPublic, bool allowInternal)
	{
		if ((object)property == null)
		{
			return null;
		}
		MethodInfo methodInfo = property.GetSetMethod(nonPublic);
		if ((object)methodInfo == null && !nonPublic && allowInternal)
		{
			methodInfo = property.GetGetMethod(nonPublic: true);
			if ((object)methodInfo == null && !methodInfo.IsAssembly && !methodInfo.IsFamilyOrAssembly)
			{
				methodInfo = null;
			}
		}
		return methodInfo;
	}

	internal static ConstructorInfo GetConstructor(Type type, Type[] parameterTypes, bool nonPublic)
	{
		return type.GetConstructor(nonPublic ? (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : (BindingFlags.Instance | BindingFlags.Public), null, parameterTypes, null);
	}

	internal static ConstructorInfo[] GetConstructors(Type type, bool nonPublic)
	{
		return type.GetConstructors(nonPublic ? (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : (BindingFlags.Instance | BindingFlags.Public));
	}

	internal static PropertyInfo GetProperty(Type type, string name, bool nonPublic)
	{
		return type.GetProperty(name, nonPublic ? (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : (BindingFlags.Instance | BindingFlags.Public));
	}

	internal static object ParseEnum(Type type, string value)
	{
		return Enum.Parse(type, value, ignoreCase: true);
	}

	internal static MemberInfo[] GetInstanceFieldsAndProperties(Type type, bool publicOnly)
	{
		BindingFlags bindingAttr = (publicOnly ? (BindingFlags.Instance | BindingFlags.Public) : (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
		PropertyInfo[] properties = type.GetProperties(bindingAttr);
		FieldInfo[] fields = type.GetFields(bindingAttr);
		MemberInfo[] array = new MemberInfo[fields.Length + properties.Length];
		properties.CopyTo(array, 0);
		fields.CopyTo(array, properties.Length);
		return array;
	}

	internal static Type GetMemberType(MemberInfo member)
	{
		return member.MemberType switch
		{
			MemberTypes.Field => ((FieldInfo)member).FieldType, 
			MemberTypes.Property => ((PropertyInfo)member).PropertyType, 
			_ => null, 
		};
	}

	internal static bool IsAssignableFrom(Type target, Type type)
	{
		return target.IsAssignableFrom(type);
	}
}


internal enum ProtoTypeCode
{
	Empty = 0,
	Unknown = 1,
	Boolean = 3,
	Char = 4,
	SByte = 5,
	Byte = 6,
	Int16 = 7,
	UInt16 = 8,
	Int32 = 9,
	UInt32 = 10,
	Int64 = 11,
	UInt64 = 12,
	Single = 13,
	Double = 14,
	Decimal = 15,
	DateTime = 16,
	String = 18,
	TimeSpan = 100,
	ByteArray = 101,
	Guid = 102,
	Uri = 103,
	Type = 104
}


public enum ImplicitFields
{
	None,
	AllPublic,
	AllFields
}


using System;
using System.Reflection;
using ProtoBuf;
using ProtoBuf.Meta;

internal abstract class AttributeMap
{
	private sealed class ReflectionAttributeMap : AttributeMap
	{
		private readonly Attribute attribute;

		public override object Target => attribute;

		public override Type AttributeType => attribute.GetType();

		public override bool TryGet(string key, bool publicOnly, out object value)
		{
			MemberInfo[] instanceFieldsAndProperties = Helpers.GetInstanceFieldsAndProperties(attribute.GetType(), publicOnly);
			MemberInfo[] array = instanceFieldsAndProperties;
			foreach (MemberInfo memberInfo in array)
			{
				if (string.Equals(memberInfo.Name, key, StringComparison.OrdinalIgnoreCase))
				{
					if (memberInfo is PropertyInfo propertyInfo)
					{
						value = propertyInfo.GetValue(attribute, null);
						return true;
					}
					if (memberInfo is FieldInfo fieldInfo)
					{
						value = fieldInfo.GetValue(attribute);
						return true;
					}
					throw new NotSupportedException(memberInfo.GetType().Name);
				}
			}
			value = null;
			return false;
		}

		public ReflectionAttributeMap(Attribute attribute)
		{
			this.attribute = attribute;
		}
	}

	public abstract Type AttributeType { get; }

	public abstract object Target { get; }

	public abstract bool TryGet(string key, bool publicOnly, out object value);

	public bool TryGet(string key, out object value)
	{
		return TryGet(key, publicOnly: true, out value);
	}

	public static AttributeMap[] Create(TypeModel model, Type type, bool inherit)
	{
		object[] customAttributes = type.GetCustomAttributes(inherit);
		AttributeMap[] array = new AttributeMap[customAttributes.Length];
		for (int i = 0; i < customAttributes.Length; i++)
		{
			array[i] = new ReflectionAttributeMap((Attribute)customAttributes[i]);
		}
		return array;
	}

	public static AttributeMap[] Create(TypeModel model, MemberInfo member, bool inherit)
	{
		object[] customAttributes = member.GetCustomAttributes(inherit);
		AttributeMap[] array = new AttributeMap[customAttributes.Length];
		for (int i = 0; i < customAttributes.Length; i++)
		{
			array[i] = new ReflectionAttributeMap((Attribute)customAttributes[i]);
		}
		return array;
	}

	public static AttributeMap[] Create(TypeModel model, Assembly assembly)
	{
		object[] customAttributes = assembly.GetCustomAttributes(inherit: false);
		AttributeMap[] array = new AttributeMap[customAttributes.Length];
		for (int i = 0; i < customAttributes.Length; i++)
		{
			array[i] = new ReflectionAttributeMap((Attribute)customAttributes[i]);
		}
		return array;
	}
}


using System;
using System.Reflection;

private sealed class ReflectionAttributeMap : AttributeMap
{
	private readonly Attribute attribute;

	public override object Target => attribute;

	public override Type AttributeType => attribute.GetType();

	public override bool TryGet(string key, bool publicOnly, out object value)
	{
		MemberInfo[] instanceFieldsAndProperties = Helpers.GetInstanceFieldsAndProperties(attribute.GetType(), publicOnly);
		MemberInfo[] array = instanceFieldsAndProperties;
		foreach (MemberInfo memberInfo in array)
		{
			if (string.Equals(memberInfo.Name, key, StringComparison.OrdinalIgnoreCase))
			{
				if (memberInfo is PropertyInfo propertyInfo)
				{
					value = propertyInfo.GetValue(attribute, null);
					return true;
				}
				if (memberInfo is FieldInfo fieldInfo)
				{
					value = fieldInfo.GetValue(attribute);
					return true;
				}
				throw new NotSupportedException(memberInfo.GetType().Name);
			}
		}
		value = null;
		return false;
	}

	public ReflectionAttributeMap(Attribute attribute)
	{
		this.attribute = attribute;
	}
}


using System;
using System.Collections;
using ProtoBuf.Meta;

internal class BasicList : IEnumerable
{
	public struct NodeEnumerator : IEnumerator
	{
		private int position;

		private readonly Node node;

		public object Current => node[position];

		internal NodeEnumerator(Node node)
		{
			position = -1;
			this.node = node;
		}

		void IEnumerator.Reset()
		{
			position = -1;
		}

		public bool MoveNext()
		{
			int length = node.Length;
			if (position <= length)
			{
				return ++position < length;
			}
			return false;
		}
	}

	internal sealed class Node
	{
		private readonly object[] data;

		private int length;

		public object this[int index]
		{
			get
			{
				if (index >= 0 && index < length)
				{
					return data[index];
				}
				throw new ArgumentOutOfRangeException("index");
			}
			set
			{
				if (index >= 0 && index < length)
				{
					data[index] = value;
					return;
				}
				throw new ArgumentOutOfRangeException("index");
			}
		}

		public int Length => length;

		internal Node(object[] data, int length)
		{
			this.data = data;
			this.length = length;
		}

		public void RemoveLastWithMutate()
		{
			if (length == 0)
			{
				throw new InvalidOperationException();
			}
			length--;
		}

		public Node Append(object value)
		{
			int num = length + 1;
			object[] array;
			if (data == null)
			{
				array = new object[10];
			}
			else if (length == data.Length)
			{
				array = new object[data.Length * 2];
				Array.Copy(data, array, length);
			}
			else
			{
				array = data;
			}
			array[length] = value;
			return new Node(array, num);
		}

		public Node Trim()
		{
			if (length == 0 || length == data.Length)
			{
				return this;
			}
			object[] destinationArray = new object[length];
			Array.Copy(data, destinationArray, length);
			return new Node(destinationArray, length);
		}

		internal int IndexOfString(string value)
		{
			for (int i = 0; i < length; i++)
			{
				if (value == (string)data[i])
				{
					return i;
				}
			}
			return -1;
		}

		internal int IndexOfReference(object instance)
		{
			for (int i = 0; i < length; i++)
			{
				if (instance == data[i])
				{
					return i;
				}
			}
			return -1;
		}

		internal int IndexOf(MatchPredicate predicate, object ctx)
		{
			for (int i = 0; i < length; i++)
			{
				if (predicate(data[i], ctx))
				{
					return i;
				}
			}
			return -1;
		}

		internal void CopyTo(Array array, int offset)
		{
			if (length > 0)
			{
				Array.Copy(data, 0, array, offset, length);
			}
		}

		internal void Clear()
		{
			if (data != null)
			{
				Array.Clear(data, 0, data.Length);
			}
			length = 0;
		}
	}

	internal delegate bool MatchPredicate(object value, object ctx);

	internal sealed class Group
	{
		public readonly int First;

		public readonly BasicList Items;

		public Group(int first)
		{
			First = first;
			Items = new BasicList();
		}
	}

	private static readonly Node nil = new Node(null, 0);

	protected Node head = nil;

	public object this[int index] => head[index];

	public int Count => head.Length;

	public void CopyTo(Array array, int offset)
	{
		head.CopyTo(array, offset);
	}

	public int Add(object value)
	{
		return (head = head.Append(value)).Length - 1;
	}

	public void Trim()
	{
		head = head.Trim();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return new NodeEnumerator(head);
	}

	public NodeEnumerator GetEnumerator()
	{
		return new NodeEnumerator(head);
	}

	internal int IndexOf(MatchPredicate predicate, object ctx)
	{
		return head.IndexOf(predicate, ctx);
	}

	internal int IndexOfString(string value)
	{
		return head.IndexOfString(value);
	}

	internal int IndexOfReference(object instance)
	{
		return head.IndexOfReference(instance);
	}

	internal bool Contains(object value)
	{
		NodeEnumerator enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			object current = enumerator.Current;
			if (object.Equals(current, value))
			{
				return true;
			}
		}
		return false;
	}

	internal static BasicList GetContiguousGroups(int[] keys, object[] values)
	{
		if (keys == null)
		{
			throw new ArgumentNullException("keys");
		}
		if (values == null)
		{
			throw new ArgumentNullException("values");
		}
		if (values.Length < keys.Length)
		{
			throw new ArgumentException("Not all keys are covered by values", "values");
		}
		BasicList basicList = new BasicList();
		Group group = null;
		for (int i = 0; i < keys.Length; i++)
		{
			if (i == 0 || keys[i] != keys[i - 1])
			{
				group = null;
			}
			if (group == null)
			{
				group = new Group(keys[i]);
				basicList.Add(group);
			}
			group.Items.Add(values[i]);
		}
		return basicList;
	}
}


using System.Collections;

public struct NodeEnumerator : IEnumerator
{
	private int position;

	private readonly Node node;

	public object Current => node[position];

	internal NodeEnumerator(Node node)
	{
		position = -1;
		this.node = node;
	}

	void IEnumerator.Reset()
	{
		position = -1;
	}

	public bool MoveNext()
	{
		int length = node.Length;
		if (position <= length)
		{
			return ++position < length;
		}
		return false;
	}
}


using System;

internal sealed class Node
{
	private readonly object[] data;

	private int length;

	public object this[int index]
	{
		get
		{
			if (index >= 0 && index < length)
			{
				return data[index];
			}
			throw new ArgumentOutOfRangeException("index");
		}
		set
		{
			if (index >= 0 && index < length)
			{
				data[index] = value;
				return;
			}
			throw new ArgumentOutOfRangeException("index");
		}
	}

	public int Length => length;

	internal Node(object[] data, int length)
	{
		this.data = data;
		this.length = length;
	}

	public void RemoveLastWithMutate()
	{
		if (length == 0)
		{
			throw new InvalidOperationException();
		}
		length--;
	}

	public Node Append(object value)
	{
		int num = length + 1;
		object[] array;
		if (data == null)
		{
			array = new object[10];
		}
		else if (length == data.Length)
		{
			array = new object[data.Length * 2];
			Array.Copy(data, array, length);
		}
		else
		{
			array = data;
		}
		array[length] = value;
		return new Node(array, num);
	}

	public Node Trim()
	{
		if (length == 0 || length == data.Length)
		{
			return this;
		}
		object[] destinationArray = new object[length];
		Array.Copy(data, destinationArray, length);
		return new Node(destinationArray, length);
	}

	internal int IndexOfString(string value)
	{
		for (int i = 0; i < length; i++)
		{
			if (value == (string)data[i])
			{
				return i;
			}
		}
		return -1;
	}

	internal int IndexOfReference(object instance)
	{
		for (int i = 0; i < length; i++)
		{
			if (instance == data[i])
			{
				return i;
			}
		}
		return -1;
	}

	internal int IndexOf(MatchPredicate predicate, object ctx)
	{
		for (int i = 0; i < length; i++)
		{
			if (predicate(data[i], ctx))
			{
				return i;
			}
		}
		return -1;
	}

	internal void CopyTo(Array array, int offset)
	{
		if (length > 0)
		{
			Array.Copy(data, 0, array, offset, length);
		}
	}

	internal void Clear()
	{
		if (data != null)
		{
			Array.Clear(data, 0, data.Length);
		}
		length = 0;
	}
}


internal delegate bool MatchPredicate(object value, object ctx);


internal sealed class Group
{
	public readonly int First;

	public readonly BasicList Items;

	public Group(int first)
	{
		First = first;
		Items = new BasicList();
	}
}


using ProtoBuf.Meta;

internal sealed class MutableList : BasicList
{
	public new object this[int index]
	{
		get
		{
			return head[index];
		}
		set
		{
			head[index] = value;
		}
	}

	public void RemoveLast()
	{
		head.RemoveLastWithMutate();
	}

	public void Clear()
	{
		head.Clear();
	}
}


using System;
using System.Reflection;
using System.Runtime.Serialization;
using ProtoBuf;
using ProtoBuf.Meta;

public class CallbackSet
{
	private readonly MetaType metaType;

	private MethodInfo beforeSerialize;

	private MethodInfo afterSerialize;

	private MethodInfo beforeDeserialize;

	private MethodInfo afterDeserialize;

	internal MethodInfo this[TypeModel.CallbackType callbackType] => callbackType switch
	{
		TypeModel.CallbackType.BeforeSerialize => beforeSerialize, 
		TypeModel.CallbackType.AfterSerialize => afterSerialize, 
		TypeModel.CallbackType.BeforeDeserialize => beforeDeserialize, 
		TypeModel.CallbackType.AfterDeserialize => afterDeserialize, 
		_ => throw new ArgumentException("Callback type not supported: " + callbackType, "callbackType"), 
	};

	public MethodInfo BeforeSerialize
	{
		get
		{
			return beforeSerialize;
		}
		set
		{
			beforeSerialize = SanityCheckCallback(metaType.Model, value);
		}
	}

	public MethodInfo BeforeDeserialize
	{
		get
		{
			return beforeDeserialize;
		}
		set
		{
			beforeDeserialize = SanityCheckCallback(metaType.Model, value);
		}
	}

	public MethodInfo AfterSerialize
	{
		get
		{
			return afterSerialize;
		}
		set
		{
			afterSerialize = SanityCheckCallback(metaType.Model, value);
		}
	}

	public MethodInfo AfterDeserialize
	{
		get
		{
			return afterDeserialize;
		}
		set
		{
			afterDeserialize = SanityCheckCallback(metaType.Model, value);
		}
	}

	public bool NonTrivial
	{
		get
		{
			if ((object)beforeSerialize == null && (object)beforeDeserialize == null && (object)afterSerialize == null)
			{
				return (object)afterDeserialize != null;
			}
			return true;
		}
	}

	internal CallbackSet(MetaType metaType)
	{
		if (metaType == null)
		{
			throw new ArgumentNullException("metaType");
		}
		this.metaType = metaType;
	}

	internal static bool CheckCallbackParameters(TypeModel model, MethodInfo method)
	{
		ParameterInfo[] parameters = method.GetParameters();
		for (int i = 0; i < parameters.Length; i++)
		{
			Type parameterType = parameters[i].ParameterType;
			if ((object)parameterType != model.MapType(typeof(SerializationContext)) && (object)parameterType != model.MapType(typeof(Type)) && (object)parameterType != model.MapType(typeof(StreamingContext)))
			{
				return false;
			}
		}
		return true;
	}

	private MethodInfo SanityCheckCallback(TypeModel model, MethodInfo callback)
	{
		metaType.ThrowIfFrozen();
		if ((object)callback == null)
		{
			return callback;
		}
		if (callback.IsStatic)
		{
			throw new ArgumentException("Callbacks cannot be static", "callback");
		}
		if ((object)callback.ReturnType != model.MapType(typeof(void)) || !CheckCallbackParameters(model, callback))
		{
			throw CreateInvalidCallbackSignature(callback);
		}
		return callback;
	}

	internal static Exception CreateInvalidCallbackSignature(MethodInfo method)
	{
		return new NotSupportedException("Invalid callback signature in " + method.DeclaringType.FullName + "." + method.Name);
	}
}


using ProtoBuf.Serializers;

internal interface ISerializerProxy
{
	IProtoSerializer Serializer { get; }
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using ProtoBuf;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

public class MetaType : ISerializerProxy
{
	internal sealed class Comparer : IComparer, IComparer<MetaType>
	{
		public static readonly Comparer Default = new Comparer();

		public int Compare(object x, object y)
		{
			return Compare(x as MetaType, y as MetaType);
		}

		public int Compare(MetaType x, MetaType y)
		{
			if (object.ReferenceEquals(x, y))
			{
				return 0;
			}
			if (x == null)
			{
				return -1;
			}
			if (y == null)
			{
				return 1;
			}
			return string.Compare(x.GetSchemaTypeName(), y.GetSchemaTypeName(), StringComparison.Ordinal);
		}
	}

	[Flags]
	internal enum AttributeFamily
	{
		None = 0,
		ProtoBuf = 1,
		DataContractSerialier = 2,
		XmlSerializer = 4,
		AutoTuple = 8
	}

	private const byte OPTIONS_Pending = 1;

	private const byte OPTIONS_EnumPassThru = 2;

	private const byte OPTIONS_Frozen = 4;

	private const byte OPTIONS_PrivateOnApi = 8;

	private const byte OPTIONS_SkipConstructor = 16;

	private const byte OPTIONS_AsReferenceDefault = 32;

	private const byte OPTIONS_AutoTuple = 64;

	private const byte OPTIONS_IgnoreListHandling = 128;

	private MetaType baseType;

	private BasicList subTypes;

	internal static readonly Type ienumerable = typeof(IEnumerable);

	private CallbackSet callbacks;

	private string name;

	private MethodInfo factory;

	private readonly RuntimeTypeModel model;

	private readonly Type type;

	private IProtoTypeSerializer serializer;

	private Type constructType;

	private Type surrogate;

	private readonly BasicList fields = new BasicList();

	private volatile byte flags;

	IProtoSerializer ISerializerProxy.Serializer => Serializer;

	public MetaType BaseType => baseType;

	internal TypeModel Model => model;

	public bool IncludeSerializerMethod
	{
		get
		{
			return !HasFlag(8);
		}
		set
		{
			SetFlag(8, !value, throwIfFrozen: true);
		}
	}

	public bool AsReferenceDefault
	{
		get
		{
			return HasFlag(32);
		}
		set
		{
			SetFlag(32, value, throwIfFrozen: true);
		}
	}

	public bool HasCallbacks
	{
		get
		{
			if (callbacks != null)
			{
				return callbacks.NonTrivial;
			}
			return false;
		}
	}

	public bool HasSubtypes
	{
		get
		{
			if (subTypes != null)
			{
				return subTypes.Count != 0;
			}
			return false;
		}
	}

	public CallbackSet Callbacks
	{
		get
		{
			if (callbacks == null)
			{
				callbacks = new CallbackSet(this);
			}
			return callbacks;
		}
	}

	private bool IsValueType => type.IsValueType;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			ThrowIfFrozen();
			name = value;
		}
	}

	public Type Type => type;

	internal IProtoTypeSerializer Serializer
	{
		get
		{
			if (serializer == null)
			{
				int opaqueToken = 0;
				try
				{
					model.TakeLock(ref opaqueToken);
					if (serializer == null)
					{
						SetFlag(4, value: true, throwIfFrozen: false);
						serializer = BuildSerializer();
						if (model.AutoCompile)
						{
							CompileInPlace();
						}
					}
				}
				finally
				{
					model.ReleaseLock(opaqueToken);
				}
			}
			return serializer;
		}
	}

	internal bool IsList
	{
		get
		{
			Type type = (IgnoreListHandling ? null : TypeModel.GetListItemType(model, this.type));
			return (object)type != null;
		}
	}

	public bool UseConstructor
	{
		get
		{
			return !HasFlag(16);
		}
		set
		{
			SetFlag(16, !value, throwIfFrozen: true);
		}
	}

	public Type ConstructType
	{
		get
		{
			return constructType;
		}
		set
		{
			ThrowIfFrozen();
			constructType = value;
		}
	}

	public ValueMember this[int fieldNumber]
	{
		get
		{
			BasicList.NodeEnumerator enumerator = fields.GetEnumerator();
			while (enumerator.MoveNext())
			{
				ValueMember valueMember = (ValueMember)enumerator.Current;
				if (valueMember.FieldNumber == fieldNumber)
				{
					return valueMember;
				}
			}
			return null;
		}
	}

	public ValueMember this[MemberInfo member]
	{
		get
		{
			if ((object)member == null)
			{
				return null;
			}
			BasicList.NodeEnumerator enumerator = fields.GetEnumerator();
			while (enumerator.MoveNext())
			{
				ValueMember valueMember = (ValueMember)enumerator.Current;
				if ((object)valueMember.Member == member)
				{
					return valueMember;
				}
			}
			return null;
		}
	}

	public bool EnumPassthru
	{
		get
		{
			return HasFlag(2);
		}
		set
		{
			SetFlag(2, value, throwIfFrozen: true);
		}
	}

	public bool IgnoreListHandling
	{
		get
		{
			return HasFlag(128);
		}
		set
		{
			SetFlag(128, value, throwIfFrozen: true);
		}
	}

	internal bool Pending
	{
		get
		{
			return HasFlag(1);
		}
		set
		{
			SetFlag(1, value, throwIfFrozen: false);
		}
	}

	internal IEnumerable Fields => fields;

	internal bool IsAutoTuple => HasFlag(64);

	public override string ToString()
	{
		return type.ToString();
	}

	private bool IsValidSubType(Type subType)
	{
		return type.IsAssignableFrom(subType);
	}

	public MetaType AddSubType(int fieldNumber, Type derivedType)
	{
		return AddSubType(fieldNumber, derivedType, DataFormat.Default);
	}

	public MetaType AddSubType(int fieldNumber, Type derivedType, DataFormat dataFormat)
	{
		if ((object)derivedType == null)
		{
			throw new ArgumentNullException("derivedType");
		}
		if (fieldNumber < 1)
		{
			throw new ArgumentOutOfRangeException("fieldNumber");
		}
		if ((!type.IsClass && !type.IsInterface) || type.IsSealed)
		{
			throw new InvalidOperationException("Sub-types can only be added to non-sealed classes");
		}
		if (!IsValidSubType(derivedType))
		{
			throw new ArgumentException(derivedType.Name + " is not a valid sub-type of " + type.Name, "derivedType");
		}
		MetaType metaType = model[derivedType];
		ThrowIfFrozen();
		metaType.ThrowIfFrozen();
		SubType value = new SubType(fieldNumber, metaType, dataFormat);
		ThrowIfFrozen();
		metaType.SetBaseType(this);
		if (subTypes == null)
		{
			subTypes = new BasicList();
		}
		subTypes.Add(value);
		return this;
	}

	private void SetBaseType(MetaType baseType)
	{
		if (baseType == null)
		{
			throw new ArgumentNullException("baseType");
		}
		if (this.baseType == baseType)
		{
			return;
		}
		if (this.baseType != null)
		{
			throw new InvalidOperationException("A type can only participate in one inheritance hierarchy");
		}
		for (MetaType metaType = baseType; metaType != null; metaType = metaType.baseType)
		{
			if (object.ReferenceEquals(metaType, this))
			{
				throw new InvalidOperationException("Cyclic inheritance is not allowed");
			}
		}
		this.baseType = baseType;
	}

	public MetaType SetCallbacks(MethodInfo beforeSerialize, MethodInfo afterSerialize, MethodInfo beforeDeserialize, MethodInfo afterDeserialize)
	{
		CallbackSet callbackSet = Callbacks;
		callbackSet.BeforeSerialize = beforeSerialize;
		callbackSet.AfterSerialize = afterSerialize;
		callbackSet.BeforeDeserialize = beforeDeserialize;
		callbackSet.AfterDeserialize = afterDeserialize;
		return this;
	}

	public MetaType SetCallbacks(string beforeSerialize, string afterSerialize, string beforeDeserialize, string afterDeserialize)
	{
		if (IsValueType)
		{
			throw new InvalidOperationException();
		}
		CallbackSet callbackSet = Callbacks;
		callbackSet.BeforeSerialize = ResolveMethod(beforeSerialize, instance: true);
		callbackSet.AfterSerialize = ResolveMethod(afterSerialize, instance: true);
		callbackSet.BeforeDeserialize = ResolveMethod(beforeDeserialize, instance: true);
		callbackSet.AfterDeserialize = ResolveMethod(afterDeserialize, instance: true);
		return this;
	}

	internal string GetSchemaTypeName()
	{
		if ((object)surrogate != null)
		{
			return model[surrogate].GetSchemaTypeName();
		}
		if (!Helpers.IsNullOrEmpty(name))
		{
			return name;
		}
		string text = this.type.Name;
		if (this.type.IsGenericType)
		{
			StringBuilder stringBuilder = new StringBuilder(text);
			int num = text.IndexOf('`');
			if (num >= 0)
			{
				stringBuilder.Length = num;
			}
			Type[] genericArguments = this.type.GetGenericArguments();
			foreach (Type type in genericArguments)
			{
				stringBuilder.Append('_');
				Type type2 = type;
				int key = model.GetKey(ref type2);
				MetaType metaType;
				if (key >= 0 && (metaType = model[type2]) != null && (object)metaType.surrogate == null)
				{
					stringBuilder.Append(metaType.GetSchemaTypeName());
				}
				else
				{
					stringBuilder.Append(type2.Name);
				}
			}
			return stringBuilder.ToString();
		}
		return text;
	}

	public MetaType SetFactory(MethodInfo factory)
	{
		model.VerifyFactory(factory, type);
		ThrowIfFrozen();
		this.factory = factory;
		return this;
	}

	public MetaType SetFactory(string factory)
	{
		return SetFactory(ResolveMethod(factory, instance: false));
	}

	private MethodInfo ResolveMethod(string name, bool instance)
	{
		if (Helpers.IsNullOrEmpty(name))
		{
			return null;
		}
		if (!instance)
		{
			return Helpers.GetStaticMethod(type, name);
		}
		return Helpers.GetInstanceMethod(type, name);
	}

	internal static Exception InbuiltType(Type type)
	{
		return new ArgumentException("Data of this type has inbuilt behaviour, and cannot be added to a model in this way: " + type.FullName);
	}

	internal MetaType(RuntimeTypeModel model, Type type, MethodInfo factory)
	{
		this.factory = factory;
		if (model == null)
		{
			throw new ArgumentNullException("model");
		}
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		IProtoSerializer protoSerializer = model.TryGetBasicTypeSerializer(type);
		if (protoSerializer != null)
		{
			throw InbuiltType(type);
		}
		this.type = type;
		this.model = model;
		if (Helpers.IsEnum(type))
		{
			EnumPassthru = type.IsDefined(model.MapType(typeof(FlagsAttribute)), inherit: false);
		}
	}

	protected internal void ThrowIfFrozen()
	{
		if ((flags & 4) != 0)
		{
			throw new InvalidOperationException("The type cannot be changed once a serializer has been generated for " + type.FullName);
		}
	}

	private IProtoTypeSerializer BuildSerializer()
	{
		if (Helpers.IsEnum(type))
		{
			return new TagDecorator(1, WireType.Variant, strict: false, new EnumSerializer(type, GetEnumMap()));
		}
		Type itemType = (IgnoreListHandling ? null : TypeModel.GetListItemType(model, type));
		if ((object)itemType != null)
		{
			if ((object)surrogate != null)
			{
				throw new ArgumentException("Repeated data (a list, collection, etc) has inbuilt behaviour and cannot use a surrogate");
			}
			if (subTypes != null && subTypes.Count != 0)
			{
				throw new ArgumentException("Repeated data (a list, collection, etc) has inbuilt behaviour and cannot be subclassed");
			}
			Type defaultType = null;
			ResolveListTypes(model, type, ref itemType, ref defaultType);
			ValueMember valueMember = new ValueMember(model, 1, type, itemType, defaultType, DataFormat.Default);
			return new TypeSerializer(model, type, new int[1] { 1 }, new IProtoSerializer[1] { valueMember.Serializer }, null, isRootType: true, useConstructor: true, null, constructType, factory);
		}
		if ((object)surrogate != null)
		{
			MetaType metaType = model[surrogate];
			MetaType metaType2;
			while ((metaType2 = metaType.baseType) != null)
			{
				metaType = metaType2;
			}
			return new SurrogateSerializer(type, surrogate, metaType.Serializer);
		}
		if (IsAutoTuple)
		{
			MemberInfo[] mappedMembers;
			ConstructorInfo constructorInfo = ResolveTupleConstructor(type, out mappedMembers);
			if ((object)constructorInfo == null)
			{
				throw new InvalidOperationException();
			}
			return new TupleSerializer(model, constructorInfo, mappedMembers);
		}
		fields.Trim();
		int count = fields.Count;
		int num = ((subTypes != null) ? subTypes.Count : 0);
		int[] array = new int[count + num];
		IProtoSerializer[] array2 = new IProtoSerializer[count + num];
		int num2 = 0;
		if (num != 0)
		{
			BasicList.NodeEnumerator enumerator = subTypes.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SubType subType = (SubType)enumerator.Current;
				if (!subType.DerivedType.IgnoreListHandling && model.MapType(ienumerable).IsAssignableFrom(subType.DerivedType.Type))
				{
					throw new ArgumentException("Repeated data (a list, collection, etc) has inbuilt behaviour and cannot be used as a subclass");
				}
				array[num2] = subType.FieldNumber;
				array2[num2++] = subType.Serializer;
			}
		}
		if (count != 0)
		{
			BasicList.NodeEnumerator enumerator2 = fields.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				ValueMember valueMember2 = (ValueMember)enumerator2.Current;
				array[num2] = valueMember2.FieldNumber;
				array2[num2++] = valueMember2.Serializer;
			}
		}
		BasicList basicList = null;
		for (MetaType metaType3 = BaseType; metaType3 != null; metaType3 = metaType3.BaseType)
		{
			MethodInfo methodInfo = (metaType3.HasCallbacks ? metaType3.Callbacks.BeforeDeserialize : null);
			if ((object)methodInfo != null)
			{
				if (basicList == null)
				{
					basicList = new BasicList();
				}
				basicList.Add(methodInfo);
			}
		}
		MethodInfo[] array3 = null;
		if (basicList != null)
		{
			array3 = new MethodInfo[basicList.Count];
			basicList.CopyTo(array3, 0);
			Array.Reverse((Array)array3);
		}
		return new TypeSerializer(model, type, array, array2, array3, baseType == null, UseConstructor, callbacks, constructType, factory);
	}

	private static Type GetBaseType(MetaType type)
	{
		return type.type.BaseType;
	}

	internal static bool GetAsReferenceDefault(RuntimeTypeModel model, Type type)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		if (Helpers.IsEnum(type))
		{
			return false;
		}
		AttributeMap[] array = AttributeMap.Create(model, type, inherit: false);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].AttributeType.FullName == "ProtoBuf.ProtoContractAttribute" && array[i].TryGet("AsReferenceDefault", out var value))
			{
				return (bool)value;
			}
		}
		return false;
	}

	internal void ApplyDefaultBehaviour()
	{
		Type type = GetBaseType(this);
		if ((object)type != null && model.FindWithoutAdd(type) == null && GetContractFamily(model, type, null) != 0)
		{
			model.FindOrAddAuto(type, demand: true, addWithContractOnly: false, addEvenIfAutoDisabled: false);
		}
		AttributeMap[] array = AttributeMap.Create(model, this.type, inherit: false);
		AttributeFamily attributeFamily = GetContractFamily(model, this.type, array);
		if (attributeFamily == AttributeFamily.AutoTuple)
		{
			SetFlag(64, value: true, throwIfFrozen: true);
		}
		bool flag = !EnumPassthru && Helpers.IsEnum(this.type);
		if (attributeFamily == AttributeFamily.None && !flag)
		{
			return;
		}
		BasicList basicList = null;
		BasicList basicList2 = null;
		int dataMemberOffset = 0;
		int num = 1;
		bool flag2 = model.InferTagFromNameDefault;
		ImplicitFields implicitFields = ImplicitFields.None;
		string text = null;
		foreach (AttributeMap attributeMap in array)
		{
			string fullName = attributeMap.AttributeType.FullName;
			object value;
			if (!flag && fullName == "ProtoBuf.ProtoIncludeAttribute")
			{
				int fieldNumber = 0;
				if (attributeMap.TryGet("tag", out value))
				{
					fieldNumber = (int)value;
				}
				DataFormat dataFormat = DataFormat.Default;
				if (attributeMap.TryGet("DataFormat", out value))
				{
					dataFormat = (DataFormat)(int)value;
				}
				Type type2 = null;
				try
				{
					if (attributeMap.TryGet("knownTypeName", out value))
					{
						type2 = model.GetType((string)value, this.type.Assembly);
					}
					else if (attributeMap.TryGet("knownType", out value))
					{
						type2 = (Type)value;
					}
				}
				catch (Exception innerException)
				{
					throw new InvalidOperationException("Unable to resolve sub-type of: " + this.type.FullName, innerException);
				}
				if ((object)type2 == null)
				{
					throw new InvalidOperationException("Unable to resolve sub-type of: " + this.type.FullName);
				}
				if (IsValidSubType(type2))
				{
					AddSubType(fieldNumber, type2, dataFormat);
				}
			}
			if (fullName == "ProtoBuf.ProtoPartialIgnoreAttribute" && attributeMap.TryGet("MemberName", out value) && value != null)
			{
				if (basicList == null)
				{
					basicList = new BasicList();
				}
				basicList.Add((string)value);
			}
			if (!flag && fullName == "ProtoBuf.ProtoPartialMemberAttribute")
			{
				if (basicList2 == null)
				{
					basicList2 = new BasicList();
				}
				basicList2.Add(attributeMap);
			}
			if (fullName == "ProtoBuf.ProtoContractAttribute")
			{
				if (attributeMap.TryGet("Name", out value))
				{
					text = (string)value;
				}
				if (Helpers.IsEnum(this.type))
				{
					if (attributeMap.TryGet("EnumPassthruHasValue", publicOnly: false, out value) && (bool)value && attributeMap.TryGet("EnumPassthru", out value))
					{
						EnumPassthru = (bool)value;
						if (EnumPassthru)
						{
							flag = false;
						}
					}
				}
				else
				{
					if (attributeMap.TryGet("DataMemberOffset", out value))
					{
						dataMemberOffset = (int)value;
					}
					if (attributeMap.TryGet("InferTagFromNameHasValue", publicOnly: false, out value) && (bool)value && attributeMap.TryGet("InferTagFromName", out value))
					{
						flag2 = (bool)value;
					}
					if (attributeMap.TryGet("ImplicitFields", out value) && value != null)
					{
						implicitFields = (ImplicitFields)(int)value;
					}
					if (attributeMap.TryGet("SkipConstructor", out value))
					{
						UseConstructor = !(bool)value;
					}
					if (attributeMap.TryGet("IgnoreListHandling", out value))
					{
						IgnoreListHandling = (bool)value;
					}
					if (attributeMap.TryGet("AsReferenceDefault", out value))
					{
						AsReferenceDefault = (bool)value;
					}
					if (attributeMap.TryGet("ImplicitFirstTag", out value) && (int)value > 0)
					{
						num = (int)value;
					}
				}
			}
			if (fullName == "System.Runtime.Serialization.DataContractAttribute" && text == null && attributeMap.TryGet("Name", out value))
			{
				text = (string)value;
			}
			if (fullName == "System.Xml.Serialization.XmlTypeAttribute" && text == null && attributeMap.TryGet("TypeName", out value))
			{
				text = (string)value;
			}
		}
		if (!Helpers.IsNullOrEmpty(text))
		{
			Name = text;
		}
		if (implicitFields != 0)
		{
			attributeFamily &= AttributeFamily.ProtoBuf;
		}
		MethodInfo[] array2 = null;
		BasicList basicList3 = new BasicList();
		MemberInfo[] members = this.type.GetMembers(flag ? (BindingFlags.Static | BindingFlags.Public) : (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
		MemberInfo[] array3 = members;
		foreach (MemberInfo memberInfo in array3)
		{
			if ((object)memberInfo.DeclaringType != this.type || memberInfo.IsDefined(model.MapType(typeof(ProtoIgnoreAttribute)), inherit: true) || (basicList != null && basicList.Contains(memberInfo.Name)))
			{
				continue;
			}
			bool forced = false;
			if (memberInfo is PropertyInfo propertyInfo)
			{
				if (!flag)
				{
					Type effectiveType = propertyInfo.PropertyType;
					bool isPublic = (object)Helpers.GetGetMethod(propertyInfo, nonPublic: false, allowInternal: false) != null;
					bool isField = false;
					ApplyDefaultBehaviour_AddMembers(model, attributeFamily, flag, basicList2, dataMemberOffset, flag2, implicitFields, basicList3, memberInfo, ref forced, isPublic, isField, ref effectiveType);
				}
			}
			else if (memberInfo is FieldInfo fieldInfo)
			{
				Type effectiveType = fieldInfo.FieldType;
				bool isPublic = fieldInfo.IsPublic;
				bool isField = true;
				if (!flag || fieldInfo.IsStatic)
				{
					ApplyDefaultBehaviour_AddMembers(model, attributeFamily, flag, basicList2, dataMemberOffset, flag2, implicitFields, basicList3, memberInfo, ref forced, isPublic, isField, ref effectiveType);
				}
			}
			else if (memberInfo is MethodInfo methodInfo && !flag)
			{
				AttributeMap[] array4 = AttributeMap.Create(model, methodInfo, inherit: false);
				if (array4 != null && array4.Length > 0)
				{
					CheckForCallback(methodInfo, array4, "ProtoBuf.ProtoBeforeSerializationAttribute", ref array2, 0);
					CheckForCallback(methodInfo, array4, "ProtoBuf.ProtoAfterSerializationAttribute", ref array2, 1);
					CheckForCallback(methodInfo, array4, "ProtoBuf.ProtoBeforeDeserializationAttribute", ref array2, 2);
					CheckForCallback(methodInfo, array4, "ProtoBuf.ProtoAfterDeserializationAttribute", ref array2, 3);
					CheckForCallback(methodInfo, array4, "System.Runtime.Serialization.OnSerializingAttribute", ref array2, 4);
					CheckForCallback(methodInfo, array4, "System.Runtime.Serialization.OnSerializedAttribute", ref array2, 5);
					CheckForCallback(methodInfo, array4, "System.Runtime.Serialization.OnDeserializingAttribute", ref array2, 6);
					CheckForCallback(methodInfo, array4, "System.Runtime.Serialization.OnDeserializedAttribute", ref array2, 7);
				}
			}
		}
		ProtoMemberAttribute[] array5 = new ProtoMemberAttribute[basicList3.Count];
		basicList3.CopyTo(array5, 0);
		if (flag2 || implicitFields != 0)
		{
			Array.Sort(array5);
			int num2 = num;
			ProtoMemberAttribute[] array6 = array5;
			foreach (ProtoMemberAttribute protoMemberAttribute in array6)
			{
				if (!protoMemberAttribute.TagIsPinned)
				{
					protoMemberAttribute.Rebase(num2++);
				}
			}
		}
		ProtoMemberAttribute[] array7 = array5;
		foreach (ProtoMemberAttribute normalizedAttribute in array7)
		{
			ValueMember valueMember = ApplyDefaultBehaviour(flag, normalizedAttribute);
			if (valueMember != null)
			{
				Add(valueMember);
			}
		}
		if (array2 != null)
		{
			SetCallbacks(Coalesce(array2, 0, 4), Coalesce(array2, 1, 5), Coalesce(array2, 2, 6), Coalesce(array2, 3, 7));
		}
	}

	private static void ApplyDefaultBehaviour_AddMembers(TypeModel model, AttributeFamily family, bool isEnum, BasicList partialMembers, int dataMemberOffset, bool inferTagByName, ImplicitFields implicitMode, BasicList members, MemberInfo member, ref bool forced, bool isPublic, bool isField, ref Type effectiveType)
	{
		switch (implicitMode)
		{
		case ImplicitFields.AllFields:
			if (isField)
			{
				forced = true;
			}
			break;
		case ImplicitFields.AllPublic:
			if (isPublic)
			{
				forced = true;
			}
			break;
		}
		if (effectiveType.IsSubclassOf(model.MapType(typeof(Delegate))))
		{
			effectiveType = null;
		}
		if ((object)effectiveType != null)
		{
			ProtoMemberAttribute protoMemberAttribute = NormalizeProtoMember(model, member, family, forced, isEnum, partialMembers, dataMemberOffset, inferTagByName);
			if (protoMemberAttribute != null)
			{
				members.Add(protoMemberAttribute);
			}
		}
	}

	private static MethodInfo Coalesce(MethodInfo[] arr, int x, int y)
	{
		MethodInfo methodInfo = arr[x];
		if ((object)methodInfo == null)
		{
			methodInfo = arr[y];
		}
		return methodInfo;
	}

	internal static AttributeFamily GetContractFamily(RuntimeTypeModel model, Type type, AttributeMap[] attributes)
	{
		AttributeFamily attributeFamily = AttributeFamily.None;
		if (attributes == null)
		{
			attributes = AttributeMap.Create(model, type, inherit: false);
		}
		for (int i = 0; i < attributes.Length; i++)
		{
			switch (attributes[i].AttributeType.FullName)
			{
			case "ProtoBuf.ProtoContractAttribute":
			{
				bool value = false;
				GetFieldBoolean(ref value, attributes[i], "UseProtoMembersOnly");
				if (value)
				{
					return AttributeFamily.ProtoBuf;
				}
				attributeFamily |= AttributeFamily.ProtoBuf;
				break;
			}
			case "System.Xml.Serialization.XmlTypeAttribute":
				if (!model.AutoAddProtoContractTypesOnly)
				{
					attributeFamily |= AttributeFamily.XmlSerializer;
				}
				break;
			case "System.Runtime.Serialization.DataContractAttribute":
				if (!model.AutoAddProtoContractTypesOnly)
				{
					attributeFamily |= AttributeFamily.DataContractSerialier;
				}
				break;
			}
		}
		if (attributeFamily == AttributeFamily.None && (object)ResolveTupleConstructor(type, out var _) != null)
		{
			attributeFamily |= AttributeFamily.AutoTuple;
		}
		return attributeFamily;
	}

	internal static ConstructorInfo ResolveTupleConstructor(Type type, out MemberInfo[] mappedMembers)
	{
		mappedMembers = null;
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		if (type.IsAbstract)
		{
			return null;
		}
		ConstructorInfo[] constructors = Helpers.GetConstructors(type, nonPublic: false);
		if (constructors.Length == 0 || (constructors.Length == 1 && constructors[0].GetParameters().Length == 0))
		{
			return null;
		}
		MemberInfo[] instanceFieldsAndProperties = Helpers.GetInstanceFieldsAndProperties(type, publicOnly: true);
		BasicList basicList = new BasicList();
		for (int i = 0; i < instanceFieldsAndProperties.Length; i++)
		{
			if (instanceFieldsAndProperties[i] is PropertyInfo propertyInfo)
			{
				if (!propertyInfo.CanRead)
				{
					return null;
				}
				if (propertyInfo.CanWrite && (object)Helpers.GetSetMethod(propertyInfo, nonPublic: false, allowInternal: false) != null)
				{
					return null;
				}
				basicList.Add(propertyInfo);
			}
			else if (instanceFieldsAndProperties[i] is FieldInfo fieldInfo)
			{
				if (!fieldInfo.IsInitOnly)
				{
					return null;
				}
				basicList.Add(fieldInfo);
			}
		}
		if (basicList.Count == 0)
		{
			return null;
		}
		MemberInfo[] array = new MemberInfo[basicList.Count];
		basicList.CopyTo(array, 0);
		int[] array2 = new int[array.Length];
		int num = 0;
		ConstructorInfo result = null;
		mappedMembers = new MemberInfo[array2.Length];
		for (int j = 0; j < constructors.Length; j++)
		{
			ParameterInfo[] parameters = constructors[j].GetParameters();
			if (parameters.Length != array.Length)
			{
				continue;
			}
			for (int k = 0; k < array2.Length; k++)
			{
				array2[k] = -1;
			}
			for (int l = 0; l < parameters.Length; l++)
			{
				string text = parameters[l].Name.ToLower();
				for (int m = 0; m < array.Length; m++)
				{
					if (!(array[m].Name.ToLower() != text))
					{
						Type memberType = Helpers.GetMemberType(array[m]);
						if ((object)memberType == parameters[l].ParameterType)
						{
							array2[l] = m;
						}
					}
				}
			}
			bool flag = false;
			for (int n = 0; n < array2.Length; n++)
			{
				if (array2[n] < 0)
				{
					flag = true;
					break;
				}
				mappedMembers[n] = array[array2[n]];
			}
			if (!flag)
			{
				num++;
				result = constructors[j];
			}
		}
		if (num != 1)
		{
			return null;
		}
		return result;
	}

	private static void CheckForCallback(MethodInfo method, AttributeMap[] attributes, string callbackTypeName, ref MethodInfo[] callbacks, int index)
	{
		for (int i = 0; i < attributes.Length; i++)
		{
			if (attributes[i].AttributeType.FullName == callbackTypeName)
			{
				if (callbacks == null)
				{
					callbacks = new MethodInfo[8];
				}
				else if ((object)callbacks[index] != null)
				{
					Type reflectedType = method.ReflectedType;
					throw new ProtoException("Duplicate " + callbackTypeName + " callbacks on " + reflectedType.FullName);
				}
				callbacks[index] = method;
			}
		}
	}

	private static bool HasFamily(AttributeFamily value, AttributeFamily required)
	{
		return (value & required) == required;
	}

	private static ProtoMemberAttribute NormalizeProtoMember(TypeModel model, MemberInfo member, AttributeFamily family, bool forced, bool isEnum, BasicList partialMembers, int dataMemberOffset, bool inferByTagName)
	{
		if ((object)member == null || (family == AttributeFamily.None && !isEnum))
		{
			return null;
		}
		int value = int.MinValue;
		int num = ((!inferByTagName) ? 1 : (-1));
		string text = null;
		bool value2 = false;
		bool ignore = false;
		bool flag = false;
		bool value3 = false;
		bool value4 = false;
		bool value5 = false;
		bool value6 = false;
		bool tagIsPinned = false;
		bool value7 = false;
		DataFormat value8 = DataFormat.Default;
		if (isEnum)
		{
			forced = true;
		}
		AttributeMap[] attribs = AttributeMap.Create(model, member, inherit: true);
		if (isEnum)
		{
			AttributeMap attribute = GetAttribute(attribs, "ProtoBuf.ProtoIgnoreAttribute");
			if (attribute != null)
			{
				ignore = true;
			}
			else
			{
				attribute = GetAttribute(attribs, "ProtoBuf.ProtoEnumAttribute");
				value = Convert.ToInt32(((FieldInfo)member).GetRawConstantValue());
				if (attribute != null)
				{
					GetFieldName(ref text, attribute, "Name");
					if ((bool)Helpers.GetInstanceMethod(attribute.AttributeType, "HasValue").Invoke(attribute.Target, null) && attribute.TryGet("Value", out var value9))
					{
						value = (int)value9;
					}
				}
			}
			flag = true;
		}
		if (!ignore && !flag)
		{
			AttributeMap attribute = GetAttribute(attribs, "ProtoBuf.ProtoMemberAttribute");
			GetIgnore(ref ignore, attribute, attribs, "ProtoBuf.ProtoIgnoreAttribute");
			if (!ignore && attribute != null)
			{
				GetFieldNumber(ref value, attribute, "Tag");
				GetFieldName(ref text, attribute, "Name");
				GetFieldBoolean(ref value3, attribute, "IsRequired");
				GetFieldBoolean(ref value2, attribute, "IsPacked");
				GetFieldBoolean(ref value7, attribute, "OverwriteList");
				GetDataFormat(ref value8, attribute, "DataFormat");
				GetFieldBoolean(ref value5, attribute, "AsReferenceHasValue", publicOnly: false);
				if (value5)
				{
					value5 = GetFieldBoolean(ref value4, attribute, "AsReference", publicOnly: true);
				}
				GetFieldBoolean(ref value6, attribute, "DynamicType");
				flag = (tagIsPinned = value > 0);
			}
			if (!flag && partialMembers != null)
			{
				BasicList.NodeEnumerator enumerator = partialMembers.GetEnumerator();
				while (enumerator.MoveNext())
				{
					AttributeMap attributeMap = (AttributeMap)enumerator.Current;
					if (attributeMap.TryGet("MemberName", out var value10) && (string)value10 == member.Name)
					{
						GetFieldNumber(ref value, attributeMap, "Tag");
						GetFieldName(ref text, attributeMap, "Name");
						GetFieldBoolean(ref value3, attributeMap, "IsRequired");
						GetFieldBoolean(ref value2, attributeMap, "IsPacked");
						GetFieldBoolean(ref value7, attribute, "OverwriteList");
						GetDataFormat(ref value8, attributeMap, "DataFormat");
						GetFieldBoolean(ref value5, attribute, "AsReferenceHasValue", publicOnly: false);
						if (value5)
						{
							value5 = GetFieldBoolean(ref value4, attributeMap, "AsReference", publicOnly: true);
						}
						GetFieldBoolean(ref value6, attributeMap, "DynamicType");
						if (flag = (tagIsPinned = value > 0))
						{
							break;
						}
					}
				}
			}
		}
		if (!ignore && !flag && HasFamily(family, AttributeFamily.DataContractSerialier))
		{
			AttributeMap attribute = GetAttribute(attribs, "System.Runtime.Serialization.DataMemberAttribute");
			if (attribute != null)
			{
				GetFieldNumber(ref value, attribute, "Order");
				GetFieldName(ref text, attribute, "Name");
				GetFieldBoolean(ref value3, attribute, "IsRequired");
				flag = value >= num;
				if (flag)
				{
					value += dataMemberOffset;
				}
			}
		}
		if (!ignore && !flag && HasFamily(family, AttributeFamily.XmlSerializer))
		{
			AttributeMap attribute = GetAttribute(attribs, "System.Xml.Serialization.XmlElementAttribute");
			if (attribute == null)
			{
				attribute = GetAttribute(attribs, "System.Xml.Serialization.XmlArrayAttribute");
			}
			GetIgnore(ref ignore, attribute, attribs, "System.Xml.Serialization.XmlIgnoreAttribute");
			if (attribute != null && !ignore)
			{
				GetFieldNumber(ref value, attribute, "Order");
				GetFieldName(ref text, attribute, "ElementName");
				flag = value >= num;
			}
		}
		if (!ignore && !flag && GetAttribute(attribs, "System.NonSerializedAttribute") != null)
		{
			ignore = true;
		}
		if (ignore || (value < num && !forced))
		{
			return null;
		}
		ProtoMemberAttribute protoMemberAttribute = new ProtoMemberAttribute(value, forced || inferByTagName);
		protoMemberAttribute.AsReference = value4;
		protoMemberAttribute.AsReferenceHasValue = value5;
		protoMemberAttribute.DataFormat = value8;
		protoMemberAttribute.DynamicType = value6;
		protoMemberAttribute.IsPacked = value2;
		protoMemberAttribute.OverwriteList = value7;
		protoMemberAttribute.IsRequired = value3;
		protoMemberAttribute.Name = (Helpers.IsNullOrEmpty(text) ? member.Name : text);
		protoMemberAttribute.Member = member;
		protoMemberAttribute.TagIsPinned = tagIsPinned;
		return protoMemberAttribute;
	}

	private ValueMember ApplyDefaultBehaviour(bool isEnum, ProtoMemberAttribute normalizedAttribute)
	{
		MemberInfo member;
		if (normalizedAttribute == null || (object)(member = normalizedAttribute.Member) == null)
		{
			return null;
		}
		Type memberType = Helpers.GetMemberType(member);
		Type itemType = null;
		Type defaultType = null;
		ResolveListTypes(model, memberType, ref itemType, ref defaultType);
		if ((object)itemType != null)
		{
			int num = model.FindOrAddAuto(memberType, demand: false, addWithContractOnly: true, addEvenIfAutoDisabled: false);
			if (num >= 0 && model[memberType].IgnoreListHandling)
			{
				itemType = null;
				defaultType = null;
			}
		}
		AttributeMap[] attribs = AttributeMap.Create(model, member, inherit: true);
		object defaultValue = null;
		if (model.UseImplicitZeroDefaults)
		{
			switch (Helpers.GetTypeCode(memberType))
			{
			case ProtoTypeCode.Boolean:
				defaultValue = false;
				break;
			case ProtoTypeCode.Decimal:
				defaultValue = 0m;
				break;
			case ProtoTypeCode.Single:
				defaultValue = 0f;
				break;
			case ProtoTypeCode.Double:
				defaultValue = 0.0;
				break;
			case ProtoTypeCode.Byte:
				defaultValue = (byte)0;
				break;
			case ProtoTypeCode.Char:
				defaultValue = '\0';
				break;
			case ProtoTypeCode.Int16:
				defaultValue = (short)0;
				break;
			case ProtoTypeCode.Int32:
				defaultValue = 0;
				break;
			case ProtoTypeCode.Int64:
				defaultValue = 0L;
				break;
			case ProtoTypeCode.SByte:
				defaultValue = (sbyte)0;
				break;
			case ProtoTypeCode.UInt16:
				defaultValue = (ushort)0;
				break;
			case ProtoTypeCode.UInt32:
				defaultValue = 0u;
				break;
			case ProtoTypeCode.UInt64:
				defaultValue = 0uL;
				break;
			case ProtoTypeCode.TimeSpan:
				defaultValue = TimeSpan.Zero;
				break;
			case ProtoTypeCode.Guid:
				defaultValue = Guid.Empty;
				break;
			}
		}
		AttributeMap attribute;
		if ((attribute = GetAttribute(attribs, "System.ComponentModel.DefaultValueAttribute")) != null && attribute.TryGet("Value", out var value))
		{
			defaultValue = value;
		}
		ValueMember valueMember = ((isEnum || normalizedAttribute.Tag > 0) ? new ValueMember(model, type, normalizedAttribute.Tag, member, memberType, itemType, defaultType, normalizedAttribute.DataFormat, defaultValue) : null);
		if (valueMember != null)
		{
			Type declaringType = type;
			PropertyInfo propertyInfo = Helpers.GetProperty(declaringType, member.Name + "Specified", nonPublic: true);
			MethodInfo getMethod = Helpers.GetGetMethod(propertyInfo, nonPublic: true, allowInternal: true);
			if ((object)getMethod == null || getMethod.IsStatic)
			{
				propertyInfo = null;
			}
			if ((object)propertyInfo != null)
			{
				valueMember.SetSpecified(getMethod, Helpers.GetSetMethod(propertyInfo, nonPublic: true, allowInternal: true));
			}
			else
			{
				MethodInfo instanceMethod = Helpers.GetInstanceMethod(declaringType, "ShouldSerialize" + member.Name, Helpers.EmptyTypes);
				if ((object)instanceMethod != null && (object)instanceMethod.ReturnType == model.MapType(typeof(bool)))
				{
					valueMember.SetSpecified(instanceMethod, null);
				}
			}
			if (!Helpers.IsNullOrEmpty(normalizedAttribute.Name))
			{
				valueMember.SetName(normalizedAttribute.Name);
			}
			valueMember.IsPacked = normalizedAttribute.IsPacked;
			valueMember.IsRequired = normalizedAttribute.IsRequired;
			valueMember.OverwriteList = normalizedAttribute.OverwriteList;
			if (normalizedAttribute.AsReferenceHasValue)
			{
				valueMember.AsReference = normalizedAttribute.AsReference;
			}
			valueMember.DynamicType = normalizedAttribute.DynamicType;
		}
		return valueMember;
	}

	private static void GetDataFormat(ref DataFormat value, AttributeMap attrib, string memberName)
	{
		if (attrib != null && value == DataFormat.Default && attrib.TryGet(memberName, out var value2) && value2 != null)
		{
			value = (DataFormat)value2;
		}
	}

	private static void GetIgnore(ref bool ignore, AttributeMap attrib, AttributeMap[] attribs, string fullName)
	{
		if (!ignore && attrib != null)
		{
			ignore = GetAttribute(attribs, fullName) != null;
		}
	}

	private static void GetFieldBoolean(ref bool value, AttributeMap attrib, string memberName)
	{
		GetFieldBoolean(ref value, attrib, memberName, publicOnly: true);
	}

	private static bool GetFieldBoolean(ref bool value, AttributeMap attrib, string memberName, bool publicOnly)
	{
		if (attrib == null)
		{
			return false;
		}
		if (value)
		{
			return true;
		}
		if (attrib.TryGet(memberName, publicOnly, out var value2) && value2 != null)
		{
			value = (bool)value2;
			return true;
		}
		return false;
	}

	private static void GetFieldNumber(ref int value, AttributeMap attrib, string memberName)
	{
		if (attrib != null && value <= 0 && attrib.TryGet(memberName, out var value2) && value2 != null)
		{
			value = (int)value2;
		}
	}

	private static void GetFieldName(ref string name, AttributeMap attrib, string memberName)
	{
		if (attrib != null && Helpers.IsNullOrEmpty(name) && attrib.TryGet(memberName, out var value) && value != null)
		{
			name = (string)value;
		}
	}

	private static AttributeMap GetAttribute(AttributeMap[] attribs, string fullName)
	{
		foreach (AttributeMap attributeMap in attribs)
		{
			if (attributeMap != null && attributeMap.AttributeType.FullName == fullName)
			{
				return attributeMap;
			}
		}
		return null;
	}

	public MetaType Add(int fieldNumber, string memberName)
	{
		AddField(fieldNumber, memberName, null, null, null);
		return this;
	}

	public ValueMember AddField(int fieldNumber, string memberName)
	{
		return AddField(fieldNumber, memberName, null, null, null);
	}

	public MetaType Add(string memberName)
	{
		Add(GetNextFieldNumber(), memberName);
		return this;
	}

	public void SetSurrogate(Type surrogateType)
	{
		if ((object)surrogateType == type)
		{
			surrogateType = null;
		}
		if ((object)surrogateType != null && (object)surrogateType != null && Helpers.IsAssignableFrom(model.MapType(typeof(IEnumerable)), surrogateType))
		{
			throw new ArgumentException("Repeated data (a list, collection, etc) has inbuilt behaviour and cannot be used as a surrogate");
		}
		ThrowIfFrozen();
		surrogate = surrogateType;
	}

	internal MetaType GetSurrogateOrSelf()
	{
		if ((object)surrogate != null)
		{
			return model[surrogate];
		}
		return this;
	}

	internal MetaType GetSurrogateOrBaseOrSelf(bool deep)
	{
		if ((object)surrogate != null)
		{
			return model[surrogate];
		}
		MetaType metaType = baseType;
		if (metaType != null)
		{
			if (deep)
			{
				MetaType result;
				do
				{
					result = metaType;
					metaType = metaType.baseType;
				}
				while (metaType != null);
				return result;
			}
			return metaType;
		}
		return this;
	}

	private int GetNextFieldNumber()
	{
		int num = 0;
		BasicList.NodeEnumerator enumerator = fields.GetEnumerator();
		while (enumerator.MoveNext())
		{
			ValueMember valueMember = (ValueMember)enumerator.Current;
			if (valueMember.FieldNumber > num)
			{
				num = valueMember.FieldNumber;
			}
		}
		if (subTypes != null)
		{
			BasicList.NodeEnumerator enumerator2 = subTypes.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				SubType subType = (SubType)enumerator2.Current;
				if (subType.FieldNumber > num)
				{
					num = subType.FieldNumber;
				}
			}
		}
		return num + 1;
	}

	public MetaType Add(params string[] memberNames)
	{
		if (memberNames == null)
		{
			throw new ArgumentNullException("memberNames");
		}
		int nextFieldNumber = GetNextFieldNumber();
		for (int i = 0; i < memberNames.Length; i++)
		{
			Add(nextFieldNumber++, memberNames[i]);
		}
		return this;
	}

	public MetaType Add(int fieldNumber, string memberName, object defaultValue)
	{
		AddField(fieldNumber, memberName, null, null, defaultValue);
		return this;
	}

	public MetaType Add(int fieldNumber, string memberName, Type itemType, Type defaultType)
	{
		AddField(fieldNumber, memberName, itemType, defaultType, null);
		return this;
	}

	public ValueMember AddField(int fieldNumber, string memberName, Type itemType, Type defaultType)
	{
		return AddField(fieldNumber, memberName, itemType, defaultType, null);
	}

	private ValueMember AddField(int fieldNumber, string memberName, Type itemType, Type defaultType, object defaultValue)
	{
		MemberInfo memberInfo = null;
		MemberInfo[] member = type.GetMember(memberName, Helpers.IsEnum(type) ? (BindingFlags.Static | BindingFlags.Public) : (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
		if (member != null && member.Length == 1)
		{
			memberInfo = member[0];
		}
		if ((object)memberInfo == null)
		{
			throw new ArgumentException("Unable to determine member: " + memberName, "memberName");
		}
		Type memberType = memberInfo.MemberType switch
		{
			MemberTypes.Field => ((FieldInfo)memberInfo).FieldType, 
			MemberTypes.Property => ((PropertyInfo)memberInfo).PropertyType, 
			_ => throw new NotSupportedException(memberInfo.MemberType.ToString()), 
		};
		ResolveListTypes(model, memberType, ref itemType, ref defaultType);
		ValueMember valueMember = new ValueMember(model, type, fieldNumber, memberInfo, memberType, itemType, defaultType, DataFormat.Default, defaultValue);
		Add(valueMember);
		return valueMember;
	}

	internal static void ResolveListTypes(TypeModel model, Type type, ref Type itemType, ref Type defaultType)
	{
		if ((object)type == null)
		{
			return;
		}
		if (type.IsArray)
		{
			if (type.GetArrayRank() != 1)
			{
				throw new NotSupportedException("Multi-dimension arrays are supported");
			}
			itemType = type.GetElementType();
			if ((object)itemType == model.MapType(typeof(byte)))
			{
				defaultType = (itemType = null);
			}
			else
			{
				defaultType = type;
			}
		}
		if ((object)itemType == null)
		{
			itemType = TypeModel.GetListItemType(model, type);
		}
		if ((object)itemType != null)
		{
			Type itemType2 = null;
			Type defaultType2 = null;
			ResolveListTypes(model, itemType, ref itemType2, ref defaultType2);
			if ((object)itemType2 != null)
			{
				throw TypeModel.CreateNestedListsNotSupported();
			}
		}
		if ((object)itemType == null || (object)defaultType != null)
		{
			return;
		}
		if (type.IsClass && !type.IsAbstract && (object)Helpers.GetConstructor(type, Helpers.EmptyTypes, nonPublic: true) != null)
		{
			defaultType = type;
		}
		if ((object)defaultType == null && type.IsInterface)
		{
			Type[] genericArguments;
			if (type.IsGenericType && (object)type.GetGenericTypeDefinition() == model.MapType(typeof(IDictionary<, >)) && (object)itemType == model.MapType(typeof(KeyValuePair<, >)).MakeGenericType(genericArguments = type.GetGenericArguments()))
			{
				defaultType = model.MapType(typeof(Dictionary<, >)).MakeGenericType(genericArguments);
			}
			else
			{
				defaultType = model.MapType(typeof(List<>)).MakeGenericType(itemType);
			}
		}
		if ((object)defaultType != null && !Helpers.IsAssignableFrom(type, defaultType))
		{
			defaultType = null;
		}
	}

	private void Add(ValueMember member)
	{
		int opaqueToken = 0;
		try
		{
			model.TakeLock(ref opaqueToken);
			ThrowIfFrozen();
			fields.Add(member);
		}
		finally
		{
			model.ReleaseLock(opaqueToken);
		}
	}

	public ValueMember[] GetFields()
	{
		ValueMember[] array = new ValueMember[fields.Count];
		fields.CopyTo(array, 0);
		Array.Sort(array, ValueMember.Comparer.Default);
		return array;
	}

	public SubType[] GetSubtypes()
	{
		if (subTypes == null || subTypes.Count == 0)
		{
			return new SubType[0];
		}
		SubType[] array = new SubType[subTypes.Count];
		subTypes.CopyTo(array, 0);
		Array.Sort(array, SubType.Comparer.Default);
		return array;
	}

	public void CompileInPlace()
	{
		serializer = CompiledSerializer.Wrap(Serializer, model);
	}

	internal bool IsDefined(int fieldNumber)
	{
		BasicList.NodeEnumerator enumerator = fields.GetEnumerator();
		while (enumerator.MoveNext())
		{
			ValueMember valueMember = (ValueMember)enumerator.Current;
			if (valueMember.FieldNumber == fieldNumber)
			{
				return true;
			}
		}
		return false;
	}

	internal int GetKey(bool demand, bool getBaseKey)
	{
		return model.GetKey(type, demand, getBaseKey);
	}

	internal EnumSerializer.EnumPair[] GetEnumMap()
	{
		if (HasFlag(2))
		{
			return null;
		}
		EnumSerializer.EnumPair[] array = new EnumSerializer.EnumPair[fields.Count];
		for (int i = 0; i < array.Length; i++)
		{
			ValueMember valueMember = (ValueMember)fields[i];
			int fieldNumber = valueMember.FieldNumber;
			object rawEnumValue = valueMember.GetRawEnumValue();
			ref EnumSerializer.EnumPair reference = ref array[i];
			reference = new EnumSerializer.EnumPair(fieldNumber, rawEnumValue, valueMember.MemberType);
		}
		return array;
	}

	private bool HasFlag(byte flag)
	{
		return (flags & flag) == flag;
	}

	private void SetFlag(byte flag, bool value, bool throwIfFrozen)
	{
		if (throwIfFrozen && HasFlag(flag) != value)
		{
			ThrowIfFrozen();
		}
		if (value)
		{
			flags |= flag;
		}
		else
		{
			flags = (byte)(flags & ~flag);
		}
	}

	internal static MetaType GetRootType(MetaType source)
	{
		while (source.serializer != null)
		{
			MetaType metaType = source.baseType;
			if (metaType == null)
			{
				return source;
			}
			source = metaType;
		}
		RuntimeTypeModel runtimeTypeModel = source.model;
		int opaqueToken = 0;
		try
		{
			runtimeTypeModel.TakeLock(ref opaqueToken);
			MetaType metaType2;
			while ((metaType2 = source.baseType) != null)
			{
				source = metaType2;
			}
			return source;
		}
		finally
		{
			runtimeTypeModel.ReleaseLock(opaqueToken);
		}
	}

	internal bool IsPrepared()
	{
		return serializer is CompiledSerializer;
	}

	internal static StringBuilder NewLine(StringBuilder builder, int indent)
	{
		return Helpers.AppendLine(builder).Append(' ', indent * 3);
	}

	internal void WriteSchema(StringBuilder builder, int indent, ref bool requiresBclImport)
	{
		if ((object)surrogate != null)
		{
			return;
		}
		ValueMember[] array = new ValueMember[fields.Count];
		fields.CopyTo(array, 0);
		Array.Sort(array, ValueMember.Comparer.Default);
		if (IsList)
		{
			string schemaTypeName = model.GetSchemaTypeName(TypeModel.GetListItemType(model, type), DataFormat.Default, asReference: false, dynamicType: false, ref requiresBclImport);
			NewLine(builder, indent).Append("message ").Append(GetSchemaTypeName()).Append(" {");
			NewLine(builder, indent + 1).Append("repeated ").Append(schemaTypeName).Append(" items = 1;");
			NewLine(builder, indent).Append('}');
			return;
		}
		if (IsAutoTuple)
		{
			if ((object)ResolveTupleConstructor(type, out var mappedMembers) == null)
			{
				return;
			}
			NewLine(builder, indent).Append("message ").Append(GetSchemaTypeName()).Append(" {");
			for (int i = 0; i < mappedMembers.Length; i++)
			{
				Type effectiveType;
				if (mappedMembers[i] is PropertyInfo)
				{
					effectiveType = ((PropertyInfo)mappedMembers[i]).PropertyType;
				}
				else
				{
					if (!(mappedMembers[i] is FieldInfo))
					{
						throw new NotSupportedException("Unknown member type: " + mappedMembers[i].GetType().Name);
					}
					effectiveType = ((FieldInfo)mappedMembers[i]).FieldType;
				}
				NewLine(builder, indent + 1).Append("optional ").Append(model.GetSchemaTypeName(effectiveType, DataFormat.Default, asReference: false, dynamicType: false, ref requiresBclImport).Replace('.', '_')).Append(' ')
					.Append(mappedMembers[i].Name)
					.Append(" = ")
					.Append(i + 1)
					.Append(';');
			}
			NewLine(builder, indent).Append('}');
			return;
		}
		if (Helpers.IsEnum(type))
		{
			NewLine(builder, indent).Append("enum ").Append(GetSchemaTypeName()).Append(" {");
			if (array.Length == 0 && EnumPassthru)
			{
				if (type.IsDefined(model.MapType(typeof(FlagsAttribute)), inherit: false))
				{
					NewLine(builder, indent + 1).Append("// this is a composite/flags enumeration");
				}
				else
				{
					NewLine(builder, indent + 1).Append("// this enumeration will be passed as a raw value");
				}
				FieldInfo[] array2 = type.GetFields();
				foreach (FieldInfo fieldInfo in array2)
				{
					if (fieldInfo.IsStatic && fieldInfo.IsLiteral)
					{
						object rawConstantValue = fieldInfo.GetRawConstantValue();
						NewLine(builder, indent + 1).Append(fieldInfo.Name).Append(" = ").Append(rawConstantValue)
							.Append(";");
					}
				}
			}
			else
			{
				ValueMember[] array3 = array;
				foreach (ValueMember valueMember in array3)
				{
					NewLine(builder, indent + 1).Append(valueMember.Name).Append(" = ").Append(valueMember.FieldNumber)
						.Append(';');
				}
			}
			NewLine(builder, indent).Append('}');
			return;
		}
		NewLine(builder, indent).Append("message ").Append(GetSchemaTypeName()).Append(" {");
		ValueMember[] array4 = array;
		foreach (ValueMember valueMember2 in array4)
		{
			string value = (((object)valueMember2.ItemType != null) ? "repeated" : (valueMember2.IsRequired ? "required" : "optional"));
			NewLine(builder, indent + 1).Append(value).Append(' ');
			if (valueMember2.DataFormat == DataFormat.Group)
			{
				builder.Append("group ");
			}
			string schemaTypeName2 = valueMember2.GetSchemaTypeName(applyNetObjectProxy: true, ref requiresBclImport);
			builder.Append(schemaTypeName2).Append(" ").Append(valueMember2.Name)
				.Append(" = ")
				.Append(valueMember2.FieldNumber);
			if (valueMember2.DefaultValue != null)
			{
				if (valueMember2.DefaultValue is string)
				{
					builder.Append(" [default = \"").Append(valueMember2.DefaultValue).Append("\"]");
				}
				else if (valueMember2.DefaultValue is bool)
				{
					builder.Append(((bool)valueMember2.DefaultValue) ? " [default = true]" : " [default = false]");
				}
				else
				{
					builder.Append(" [default = ").Append(valueMember2.DefaultValue).Append(']');
				}
			}
			if ((object)valueMember2.ItemType != null && valueMember2.IsPacked)
			{
				builder.Append(" [packed=true]");
			}
			builder.Append(';');
			if (schemaTypeName2 == "bcl.NetObjectProxy" && valueMember2.AsReference && !valueMember2.DynamicType)
			{
				builder.Append(" // reference-tracked ").Append(valueMember2.GetSchemaTypeName(applyNetObjectProxy: false, ref requiresBclImport));
			}
		}
		if (subTypes != null && subTypes.Count != 0)
		{
			NewLine(builder, indent + 1).Append("// the following represent sub-types; at most 1 should have a value");
			SubType[] array5 = new SubType[subTypes.Count];
			subTypes.CopyTo(array5, 0);
			Array.Sort(array5, SubType.Comparer.Default);
			SubType[] array6 = array5;
			foreach (SubType subType in array6)
			{
				string schemaTypeName3 = subType.DerivedType.GetSchemaTypeName();
				NewLine(builder, indent + 1).Append("optional ").Append(schemaTypeName3).Append(" ")
					.Append(schemaTypeName3)
					.Append(" = ")
					.Append(subType.FieldNumber)
					.Append(';');
			}
		}
		NewLine(builder, indent).Append('}');
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

internal sealed class Comparer : IComparer, IComparer<MetaType>
{
	public static readonly Comparer Default = new Comparer();

	public int Compare(object x, object y)
	{
		return Compare(x as MetaType, y as MetaType);
	}

	public int Compare(MetaType x, MetaType y)
	{
		if (object.ReferenceEquals(x, y))
		{
			return 0;
		}
		if (x == null)
		{
			return -1;
		}
		if (y == null)
		{
			return 1;
		}
		return string.Compare(x.GetSchemaTypeName(), y.GetSchemaTypeName(), StringComparison.Ordinal);
	}
}


using System;

[Flags]
internal enum AttributeFamily
{
	None = 0,
	ProtoBuf = 1,
	DataContractSerialier = 2,
	XmlSerializer = 4,
	AutoTuple = 8
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using ProtoBuf;
using ProtoBuf.Meta;

public abstract class TypeModel
{
	private class DeserializeItemsIterator : IEnumerator, IEnumerable
	{
		private bool haveObject;

		private object current;

		private readonly Stream source;

		private readonly Type type;

		private readonly PrefixStyle style;

		private readonly int expectedField;

		private readonly Serializer.TypeResolver resolver;

		private readonly TypeModel model;

		private readonly SerializationContext context;

		public object Current => current;

		IEnumerator IEnumerable.GetEnumerator()
		{
			return this;
		}

		public bool MoveNext()
		{
			if (haveObject)
			{
				current = model.DeserializeWithLengthPrefix(source, null, type, style, expectedField, resolver, out var _, out haveObject, context);
			}
			return haveObject;
		}

		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		public DeserializeItemsIterator(TypeModel model, Stream source, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver, SerializationContext context)
		{
			haveObject = true;
			this.source = source;
			this.type = type;
			this.style = style;
			this.expectedField = expectedField;
			this.resolver = resolver;
			this.model = model;
			this.context = context;
		}
	}

	private sealed class DeserializeItemsIterator<T> : DeserializeItemsIterator, IEnumerator<T>, IDisposable, IEnumerator, IEnumerable<T>, IEnumerable
	{
		public new T Current => (T)base.Current;

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return this;
		}

		void IDisposable.Dispose()
		{
		}

		public DeserializeItemsIterator(TypeModel model, Stream source, PrefixStyle style, int expectedField, SerializationContext context)
			: base(model, source, model.MapType(typeof(T)), style, expectedField, null, context)
		{
		}
	}

	protected internal enum CallbackType
	{
		BeforeSerialize,
		AfterSerialize,
		BeforeDeserialize,
		AfterDeserialize
	}

	internal sealed class Formatter : IFormatter
	{
		private readonly TypeModel model;

		private readonly Type type;

		private SerializationBinder binder;

		private StreamingContext context;

		private ISurrogateSelector surrogateSelector;

		public SerializationBinder Binder
		{
			get
			{
				return binder;
			}
			set
			{
				binder = value;
			}
		}

		public StreamingContext Context
		{
			get
			{
				return context;
			}
			set
			{
				context = value;
			}
		}

		public ISurrogateSelector SurrogateSelector
		{
			get
			{
				return surrogateSelector;
			}
			set
			{
				surrogateSelector = value;
			}
		}

		internal Formatter(TypeModel model, Type type)
		{
			if (model == null)
			{
				throw new ArgumentNullException("model");
			}
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			this.model = model;
			this.type = type;
		}

		public object Deserialize(Stream source)
		{
			return model.Deserialize(source, null, type, -1, Context);
		}

		public void Serialize(Stream destination, object graph)
		{
			model.Serialize(destination, graph, Context);
		}
	}

	private static readonly Type ilist = typeof(IList);

	public event TypeFormatEventHandler DynamicTypeFormatting;

	protected internal Type MapType(Type type)
	{
		return MapType(type, demand: true);
	}

	protected internal virtual Type MapType(Type type, bool demand)
	{
		return type;
	}

	private WireType GetWireType(ProtoTypeCode code, DataFormat format, ref Type type, out int modelKey)
	{
		modelKey = -1;
		if (Helpers.IsEnum(type))
		{
			modelKey = GetKey(ref type);
			return WireType.Variant;
		}
		switch (code)
		{
		case ProtoTypeCode.Int64:
		case ProtoTypeCode.UInt64:
			if (format != DataFormat.FixedSize)
			{
				return WireType.Variant;
			}
			return WireType.Fixed64;
		case ProtoTypeCode.Boolean:
		case ProtoTypeCode.Char:
		case ProtoTypeCode.SByte:
		case ProtoTypeCode.Byte:
		case ProtoTypeCode.Int16:
		case ProtoTypeCode.UInt16:
		case ProtoTypeCode.Int32:
		case ProtoTypeCode.UInt32:
			if (format != DataFormat.FixedSize)
			{
				return WireType.Variant;
			}
			return WireType.Fixed32;
		case ProtoTypeCode.Double:
			return WireType.Fixed64;
		case ProtoTypeCode.Single:
			return WireType.Fixed32;
		case ProtoTypeCode.Decimal:
		case ProtoTypeCode.DateTime:
		case ProtoTypeCode.String:
		case ProtoTypeCode.TimeSpan:
		case ProtoTypeCode.ByteArray:
		case ProtoTypeCode.Guid:
		case ProtoTypeCode.Uri:
			return WireType.String;
		default:
			if ((modelKey = GetKey(ref type)) >= 0)
			{
				return WireType.String;
			}
			return WireType.None;
		}
	}

	internal bool TrySerializeAuxiliaryType(ProtoWriter writer, Type type, DataFormat format, int tag, object value, bool isInsideList)
	{
		if ((object)type == null)
		{
			type = value.GetType();
		}
		ProtoTypeCode typeCode = Helpers.GetTypeCode(type);
		int modelKey;
		WireType wireType = GetWireType(typeCode, format, ref type, out modelKey);
		if (modelKey >= 0)
		{
			if (Helpers.IsEnum(type))
			{
				Serialize(modelKey, value, writer);
				return true;
			}
			ProtoWriter.WriteFieldHeader(tag, wireType, writer);
			switch (wireType)
			{
			case WireType.None:
				throw ProtoWriter.CreateException(writer);
			case WireType.String:
			case WireType.StartGroup:
			{
				SubItemToken token = ProtoWriter.StartSubItem(value, writer);
				Serialize(modelKey, value, writer);
				ProtoWriter.EndSubItem(token, writer);
				return true;
			}
			default:
				Serialize(modelKey, value, writer);
				return true;
			}
		}
		if (wireType != WireType.None)
		{
			ProtoWriter.WriteFieldHeader(tag, wireType, writer);
		}
		switch (typeCode)
		{
		case ProtoTypeCode.Int16:
			ProtoWriter.WriteInt16((short)value, writer);
			return true;
		case ProtoTypeCode.Int32:
			ProtoWriter.WriteInt32((int)value, writer);
			return true;
		case ProtoTypeCode.Int64:
			ProtoWriter.WriteInt64((long)value, writer);
			return true;
		case ProtoTypeCode.UInt16:
			ProtoWriter.WriteUInt16((ushort)value, writer);
			return true;
		case ProtoTypeCode.UInt32:
			ProtoWriter.WriteUInt32((uint)value, writer);
			return true;
		case ProtoTypeCode.UInt64:
			ProtoWriter.WriteUInt64((ulong)value, writer);
			return true;
		case ProtoTypeCode.Boolean:
			ProtoWriter.WriteBoolean((bool)value, writer);
			return true;
		case ProtoTypeCode.SByte:
			ProtoWriter.WriteSByte((sbyte)value, writer);
			return true;
		case ProtoTypeCode.Byte:
			ProtoWriter.WriteByte((byte)value, writer);
			return true;
		case ProtoTypeCode.Char:
			ProtoWriter.WriteUInt16((char)value, writer);
			return true;
		case ProtoTypeCode.Double:
			ProtoWriter.WriteDouble((double)value, writer);
			return true;
		case ProtoTypeCode.Single:
			ProtoWriter.WriteSingle((float)value, writer);
			return true;
		case ProtoTypeCode.DateTime:
			BclHelpers.WriteDateTime((DateTime)value, writer);
			return true;
		case ProtoTypeCode.Decimal:
			BclHelpers.WriteDecimal((decimal)value, writer);
			return true;
		case ProtoTypeCode.String:
			ProtoWriter.WriteString((string)value, writer);
			return true;
		case ProtoTypeCode.ByteArray:
			ProtoWriter.WriteBytes((byte[])value, writer);
			return true;
		case ProtoTypeCode.TimeSpan:
			BclHelpers.WriteTimeSpan((TimeSpan)value, writer);
			return true;
		case ProtoTypeCode.Guid:
			BclHelpers.WriteGuid((Guid)value, writer);
			return true;
		case ProtoTypeCode.Uri:
			ProtoWriter.WriteString(((Uri)value).AbsoluteUri, writer);
			return true;
		default:
			if (value is IEnumerable enumerable)
			{
				if (isInsideList)
				{
					throw CreateNestedListsNotSupported();
				}
				foreach (object item in enumerable)
				{
					if (item == null)
					{
						throw new NullReferenceException();
					}
					if (!TrySerializeAuxiliaryType(writer, null, format, tag, item, isInsideList: true))
					{
						ThrowUnexpectedType(item.GetType());
					}
				}
				return true;
			}
			return false;
		}
	}

	private void SerializeCore(ProtoWriter writer, object value)
	{
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		Type type = value.GetType();
		int key = GetKey(ref type);
		if (key >= 0)
		{
			Serialize(key, value, writer);
		}
		else if (!TrySerializeAuxiliaryType(writer, type, DataFormat.Default, 1, value, isInsideList: false))
		{
			ThrowUnexpectedType(type);
		}
	}

	public void Serialize(Stream dest, object value)
	{
		Serialize(dest, value, null);
	}

	public void Serialize(Stream dest, object value, SerializationContext context)
	{
		using ProtoWriter protoWriter = new ProtoWriter(dest, this, context);
		protoWriter.SetRootObject(value);
		SerializeCore(protoWriter, value);
		protoWriter.Close();
	}

	public void Serialize(ProtoWriter dest, object value)
	{
		if (dest == null)
		{
			throw new ArgumentNullException("dest");
		}
		dest.CheckDepthFlushlock();
		dest.SetRootObject(value);
		SerializeCore(dest, value);
		dest.CheckDepthFlushlock();
		ProtoWriter.Flush(dest);
	}

	public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int fieldNumber)
	{
		int bytesRead;
		return DeserializeWithLengthPrefix(source, value, type, style, fieldNumber, null, out bytesRead);
	}

	public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver)
	{
		int bytesRead;
		return DeserializeWithLengthPrefix(source, value, type, style, expectedField, resolver, out bytesRead);
	}

	public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver, out int bytesRead)
	{
		bool haveObject;
		return DeserializeWithLengthPrefix(source, value, type, style, expectedField, resolver, out bytesRead, out haveObject, null);
	}

	private object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver, out int bytesRead, out bool haveObject, SerializationContext context)
	{
		haveObject = false;
		bytesRead = 0;
		if ((object)type == null && (style != PrefixStyle.Base128 || resolver == null))
		{
			throw new InvalidOperationException("A type must be provided unless base-128 prefixing is being used in combination with a resolver");
		}
		int num;
		bool flag2;
		do
		{
			bool flag = expectedField > 0 || resolver != null;
			num = ProtoReader.ReadLengthPrefix(source, flag, style, out var fieldNumber, out var bytesRead2);
			if (bytesRead2 == 0)
			{
				return value;
			}
			bytesRead += bytesRead2;
			if (num < 0)
			{
				return value;
			}
			if (style == PrefixStyle.Base128)
			{
				if (flag && expectedField == 0 && (object)type == null && resolver != null)
				{
					type = resolver(fieldNumber);
					flag2 = (object)type == null;
				}
				else
				{
					flag2 = expectedField != fieldNumber;
				}
			}
			else
			{
				flag2 = false;
			}
			if (flag2)
			{
				if (num == int.MaxValue)
				{
					throw new InvalidOperationException();
				}
				ProtoReader.Seek(source, num, null);
				bytesRead += num;
			}
		}
		while (flag2);
		ProtoReader protoReader = null;
		try
		{
			protoReader = ProtoReader.Create(source, this, context, num);
			int key = GetKey(ref type);
			if (key >= 0 && !Helpers.IsEnum(type))
			{
				value = Deserialize(key, value, protoReader);
			}
			else if (!TryDeserializeAuxiliaryType(protoReader, DataFormat.Default, 1, type, ref value, skipOtherFields: true, asListItem: false, autoCreate: true, insideList: false) && num != 0)
			{
				ThrowUnexpectedType(type);
			}
			bytesRead += protoReader.Position;
			haveObject = true;
			return value;
		}
		finally
		{
			ProtoReader.Recycle(protoReader);
		}
	}

	public IEnumerable DeserializeItems(Stream source, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver)
	{
		return DeserializeItems(source, type, style, expectedField, resolver, null);
	}

	public IEnumerable DeserializeItems(Stream source, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver, SerializationContext context)
	{
		return new DeserializeItemsIterator(this, source, type, style, expectedField, resolver, context);
	}

	public IEnumerable<T> DeserializeItems<T>(Stream source, PrefixStyle style, int expectedField)
	{
		return DeserializeItems<T>(source, style, expectedField, null);
	}

	public IEnumerable<T> DeserializeItems<T>(Stream source, PrefixStyle style, int expectedField, SerializationContext context)
	{
		return new DeserializeItemsIterator<T>(this, source, style, expectedField, context);
	}

	public void SerializeWithLengthPrefix(Stream dest, object value, Type type, PrefixStyle style, int fieldNumber)
	{
		SerializeWithLengthPrefix(dest, value, type, style, fieldNumber, null);
	}

	public void SerializeWithLengthPrefix(Stream dest, object value, Type type, PrefixStyle style, int fieldNumber, SerializationContext context)
	{
		if ((object)type == null)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			type = MapType(value.GetType());
		}
		int key = GetKey(ref type);
		using ProtoWriter protoWriter = new ProtoWriter(dest, this, context);
		switch (style)
		{
		case PrefixStyle.None:
			Serialize(key, value, protoWriter);
			break;
		case PrefixStyle.Base128:
		case PrefixStyle.Fixed32:
		case PrefixStyle.Fixed32BigEndian:
			ProtoWriter.WriteObject(value, key, protoWriter, style, fieldNumber);
			break;
		default:
			throw new ArgumentOutOfRangeException("style");
		}
		protoWriter.Close();
	}

	public object Deserialize(Stream source, object value, Type type)
	{
		return Deserialize(source, value, type, null);
	}

	public object Deserialize(Stream source, object value, Type type, SerializationContext context)
	{
		bool noAutoCreate = PrepareDeserialize(value, ref type);
		ProtoReader protoReader = null;
		try
		{
			protoReader = ProtoReader.Create(source, this, context, -1);
			if (value != null)
			{
				protoReader.SetRootObject(value);
			}
			object result = DeserializeCore(protoReader, type, value, noAutoCreate);
			protoReader.CheckFullyConsumed();
			return result;
		}
		finally
		{
			ProtoReader.Recycle(protoReader);
		}
	}

	private bool PrepareDeserialize(object value, ref Type type)
	{
		if ((object)type == null)
		{
			if (value == null)
			{
				throw new ArgumentNullException("type");
			}
			type = MapType(value.GetType());
		}
		bool result = true;
		Type underlyingType = Helpers.GetUnderlyingType(type);
		if ((object)underlyingType != null)
		{
			type = underlyingType;
			result = false;
		}
		return result;
	}

	public object Deserialize(Stream source, object value, Type type, int length)
	{
		return Deserialize(source, value, type, length, null);
	}

	public object Deserialize(Stream source, object value, Type type, int length, SerializationContext context)
	{
		bool noAutoCreate = PrepareDeserialize(value, ref type);
		ProtoReader protoReader = null;
		try
		{
			protoReader = ProtoReader.Create(source, this, context, length);
			if (value != null)
			{
				protoReader.SetRootObject(value);
			}
			object result = DeserializeCore(protoReader, type, value, noAutoCreate);
			protoReader.CheckFullyConsumed();
			return result;
		}
		finally
		{
			ProtoReader.Recycle(protoReader);
		}
	}

	public object Deserialize(ProtoReader source, object value, Type type)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		bool noAutoCreate = PrepareDeserialize(value, ref type);
		if (value != null)
		{
			source.SetRootObject(value);
		}
		object result = DeserializeCore(source, type, value, noAutoCreate);
		source.CheckFullyConsumed();
		return result;
	}

	private object DeserializeCore(ProtoReader reader, Type type, object value, bool noAutoCreate)
	{
		int key = GetKey(ref type);
		if (key >= 0 && !Helpers.IsEnum(type))
		{
			return Deserialize(key, value, reader);
		}
		TryDeserializeAuxiliaryType(reader, DataFormat.Default, 1, type, ref value, skipOtherFields: true, asListItem: false, noAutoCreate, insideList: false);
		return value;
	}

	internal static MethodInfo ResolveListAdd(TypeModel model, Type listType, Type itemType, out bool isList)
	{
		isList = model.MapType(ilist).IsAssignableFrom(listType);
		Type[] array = new Type[1] { itemType };
		MethodInfo instanceMethod = Helpers.GetInstanceMethod(listType, "Add", array);
		if ((object)instanceMethod == null)
		{
			bool flag = listType.IsInterface && (object)listType == model.MapType(typeof(IEnumerable<>)).MakeGenericType(array);
			Type type = model.MapType(typeof(ICollection<>)).MakeGenericType(array);
			if (flag || type.IsAssignableFrom(listType))
			{
				instanceMethod = Helpers.GetInstanceMethod(type, "Add", array);
			}
		}
		if ((object)instanceMethod == null)
		{
			Type[] interfaces = listType.GetInterfaces();
			foreach (Type type2 in interfaces)
			{
				if (type2.Name == "IProducerConsumerCollection`1" && type2.IsGenericType && type2.GetGenericTypeDefinition().FullName == "System.Collections.Concurrent.IProducerConsumerCollection`1")
				{
					instanceMethod = Helpers.GetInstanceMethod(type2, "TryAdd", array);
					if ((object)instanceMethod != null)
					{
						break;
					}
				}
			}
		}
		if ((object)instanceMethod == null)
		{
			array[0] = model.MapType(typeof(object));
			instanceMethod = Helpers.GetInstanceMethod(listType, "Add", array);
		}
		if ((object)instanceMethod == null && isList)
		{
			instanceMethod = Helpers.GetInstanceMethod(model.MapType(ilist), "Add", array);
		}
		return instanceMethod;
	}

	internal static Type GetListItemType(TypeModel model, Type listType)
	{
		if ((object)listType == model.MapType(typeof(string)) || listType.IsArray || !model.MapType(typeof(IEnumerable)).IsAssignableFrom(listType))
		{
			return null;
		}
		BasicList basicList = new BasicList();
		MethodInfo[] methods = listType.GetMethods();
		foreach (MethodInfo methodInfo in methods)
		{
			if (!methodInfo.IsStatic && !(methodInfo.Name != "Add"))
			{
				ParameterInfo[] parameters = methodInfo.GetParameters();
				Type parameterType;
				if (parameters.Length == 1 && !basicList.Contains(parameterType = parameters[0].ParameterType))
				{
					basicList.Add(parameterType);
				}
			}
		}
		string name = listType.Name;
		if (name == null || (name.IndexOf("Queue") < 0 && name.IndexOf("Stack") < 0))
		{
			TestEnumerableListPatterns(model, basicList, listType);
			Type[] interfaces = listType.GetInterfaces();
			foreach (Type iType in interfaces)
			{
				TestEnumerableListPatterns(model, basicList, iType);
			}
		}
		PropertyInfo[] properties = listType.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		foreach (PropertyInfo propertyInfo in properties)
		{
			if (!(propertyInfo.Name != "Item") && !basicList.Contains(propertyInfo.PropertyType))
			{
				ParameterInfo[] indexParameters = propertyInfo.GetIndexParameters();
				if (indexParameters.Length == 1 && (object)indexParameters[0].ParameterType == model.MapType(typeof(int)))
				{
					basicList.Add(propertyInfo.PropertyType);
				}
			}
		}
		switch (basicList.Count)
		{
		case 0:
			return null;
		case 1:
			return (Type)basicList[0];
		case 2:
			if (CheckDictionaryAccessors(model, (Type)basicList[0], (Type)basicList[1]))
			{
				return (Type)basicList[0];
			}
			if (CheckDictionaryAccessors(model, (Type)basicList[1], (Type)basicList[0]))
			{
				return (Type)basicList[1];
			}
			break;
		}
		return null;
	}

	private static void TestEnumerableListPatterns(TypeModel model, BasicList candidates, Type iType)
	{
		if (!iType.IsGenericType)
		{
			return;
		}
		Type genericTypeDefinition = iType.GetGenericTypeDefinition();
		if ((object)genericTypeDefinition == model.MapType(typeof(IEnumerable<>)) || (object)genericTypeDefinition == model.MapType(typeof(ICollection<>)) || genericTypeDefinition.FullName == "System.Collections.Concurrent.IProducerConsumerCollection`1")
		{
			Type[] genericArguments = iType.GetGenericArguments();
			if (!candidates.Contains(genericArguments[0]))
			{
				candidates.Add(genericArguments[0]);
			}
		}
	}

	private static bool CheckDictionaryAccessors(TypeModel model, Type pair, Type value)
	{
		if (pair.IsGenericType && (object)pair.GetGenericTypeDefinition() == model.MapType(typeof(KeyValuePair<, >)))
		{
			return (object)pair.GetGenericArguments()[1] == value;
		}
		return false;
	}

	private bool TryDeserializeList(TypeModel model, ProtoReader reader, DataFormat format, int tag, Type listType, Type itemType, ref object value)
	{
		bool isList;
		MethodInfo methodInfo = ResolveListAdd(model, listType, itemType, out isList);
		if ((object)methodInfo == null)
		{
			throw new NotSupportedException("Unknown list variant: " + listType.FullName);
		}
		bool result = false;
		object value2 = null;
		IList list = value as IList;
		object[] array = (isList ? null : new object[1]);
		BasicList basicList = (listType.IsArray ? new BasicList() : null);
		while (TryDeserializeAuxiliaryType(reader, format, tag, itemType, ref value2, skipOtherFields: true, asListItem: true, autoCreate: true, insideList: true))
		{
			result = true;
			if (value == null && basicList == null)
			{
				value = CreateListInstance(listType, itemType);
				list = value as IList;
			}
			if (list != null)
			{
				list.Add(value2);
			}
			else if (basicList != null)
			{
				basicList.Add(value2);
			}
			else
			{
				array[0] = value2;
				methodInfo.Invoke(value, array);
			}
			value2 = null;
		}
		if (basicList != null)
		{
			if (value != null)
			{
				if (basicList.Count != 0)
				{
					Array array2 = (Array)value;
					Array array3 = Array.CreateInstance(itemType, array2.Length + basicList.Count);
					Array.Copy(array2, array3, array2.Length);
					basicList.CopyTo(array3, array2.Length);
					value = array3;
				}
			}
			else
			{
				Array array3 = Array.CreateInstance(itemType, basicList.Count);
				basicList.CopyTo(array3, 0);
				value = array3;
			}
		}
		return result;
	}

	private static object CreateListInstance(Type listType, Type itemType)
	{
		Type type = listType;
		if (listType.IsArray)
		{
			return Array.CreateInstance(itemType, 0);
		}
		if (!listType.IsClass || listType.IsAbstract || (object)Helpers.GetConstructor(listType, Helpers.EmptyTypes, nonPublic: true) == null)
		{
			bool flag = false;
			string fullName;
			if (listType.IsInterface && (fullName = listType.FullName) != null && fullName.IndexOf("Dictionary") >= 0)
			{
				if (listType.IsGenericType && (object)listType.GetGenericTypeDefinition() == typeof(IDictionary<, >))
				{
					Type[] genericArguments = listType.GetGenericArguments();
					type = typeof(Dictionary<, >).MakeGenericType(genericArguments);
					flag = true;
				}
				if (!flag && (object)listType == typeof(IDictionary))
				{
					type = typeof(Hashtable);
					flag = true;
				}
			}
			if (!flag)
			{
				type = typeof(List<>).MakeGenericType(itemType);
				flag = true;
			}
			if (!flag)
			{
				type = typeof(ArrayList);
				flag = true;
			}
		}
		return Activator.CreateInstance(type);
	}

	internal bool TryDeserializeAuxiliaryType(ProtoReader reader, DataFormat format, int tag, Type type, ref object value, bool skipOtherFields, bool asListItem, bool autoCreate, bool insideList)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		Type type2 = null;
		ProtoTypeCode typeCode = Helpers.GetTypeCode(type);
		int modelKey;
		WireType wireType = GetWireType(typeCode, format, ref type, out modelKey);
		bool flag = false;
		if (wireType == WireType.None)
		{
			type2 = GetListItemType(this, type);
			if ((object)type2 == null && type.IsArray && type.GetArrayRank() == 1 && (object)type != typeof(byte[]))
			{
				type2 = type.GetElementType();
			}
			if ((object)type2 != null)
			{
				if (insideList)
				{
					throw CreateNestedListsNotSupported();
				}
				flag = TryDeserializeList(this, reader, format, tag, type, type2, ref value);
				if (!flag && autoCreate)
				{
					value = CreateListInstance(type, type2);
				}
				return flag;
			}
			ThrowUnexpectedType(type);
		}
		while (!flag || !asListItem)
		{
			int num = reader.ReadFieldHeader();
			if (num <= 0)
			{
				break;
			}
			if (num != tag)
			{
				if (skipOtherFields)
				{
					reader.SkipField();
					continue;
				}
				throw ProtoReader.AddErrorData(new InvalidOperationException("Expected field " + tag + ", but found " + num), reader);
			}
			flag = true;
			reader.Hint(wireType);
			if (modelKey >= 0)
			{
				switch (wireType)
				{
				case WireType.String:
				case WireType.StartGroup:
				{
					SubItemToken token = ProtoReader.StartSubItem(reader);
					value = Deserialize(modelKey, value, reader);
					ProtoReader.EndSubItem(token, reader);
					break;
				}
				default:
					value = Deserialize(modelKey, value, reader);
					break;
				}
				continue;
			}
			switch (typeCode)
			{
			case ProtoTypeCode.Int16:
				value = reader.ReadInt16();
				break;
			case ProtoTypeCode.Int32:
				value = reader.ReadInt32();
				break;
			case ProtoTypeCode.Int64:
				value = reader.ReadInt64();
				break;
			case ProtoTypeCode.UInt16:
				value = reader.ReadUInt16();
				break;
			case ProtoTypeCode.UInt32:
				value = reader.ReadUInt32();
				break;
			case ProtoTypeCode.UInt64:
				value = reader.ReadUInt64();
				break;
			case ProtoTypeCode.Boolean:
				value = reader.ReadBoolean();
				break;
			case ProtoTypeCode.SByte:
				value = reader.ReadSByte();
				break;
			case ProtoTypeCode.Byte:
				value = reader.ReadByte();
				break;
			case ProtoTypeCode.Char:
				value = (char)reader.ReadUInt16();
				break;
			case ProtoTypeCode.Double:
				value = reader.ReadDouble();
				break;
			case ProtoTypeCode.Single:
				value = reader.ReadSingle();
				break;
			case ProtoTypeCode.DateTime:
				value = BclHelpers.ReadDateTime(reader);
				break;
			case ProtoTypeCode.Decimal:
				value = BclHelpers.ReadDecimal(reader);
				break;
			case ProtoTypeCode.String:
				value = reader.ReadString();
				break;
			case ProtoTypeCode.ByteArray:
				value = ProtoReader.AppendBytes((byte[])value, reader);
				break;
			case ProtoTypeCode.TimeSpan:
				value = BclHelpers.ReadTimeSpan(reader);
				break;
			case ProtoTypeCode.Guid:
				value = BclHelpers.ReadGuid(reader);
				break;
			case ProtoTypeCode.Uri:
				value = new Uri(reader.ReadString());
				break;
			}
		}
		if (!flag && !asListItem && autoCreate && (object)type != typeof(string))
		{
			value = Activator.CreateInstance(type);
		}
		return flag;
	}

	public static RuntimeTypeModel Create()
	{
		return new RuntimeTypeModel(isDefault: false);
	}

	protected internal static Type ResolveProxies(Type type)
	{
		if ((object)type == null)
		{
			return null;
		}
		if (type.IsGenericParameter)
		{
			return null;
		}
		Type underlyingType = Helpers.GetUnderlyingType(type);
		if ((object)underlyingType != null)
		{
			return underlyingType;
		}
		string fullName = type.FullName;
		if (fullName != null && fullName.StartsWith("System.Data.Entity.DynamicProxies."))
		{
			return type.BaseType;
		}
		Type[] interfaces = type.GetInterfaces();
		for (int i = 0; i < interfaces.Length; i++)
		{
			switch (interfaces[i].FullName)
			{
			case "NHibernate.Proxy.INHibernateProxy":
			case "NHibernate.Proxy.DynamicProxy.IProxy":
			case "NHibernate.Intercept.IFieldInterceptorAccessor":
				return type.BaseType;
			}
		}
		return null;
	}

	public bool IsDefined(Type type)
	{
		return GetKey(ref type) >= 0;
	}

	protected internal int GetKey(ref Type type)
	{
		if ((object)type == null)
		{
			return -1;
		}
		int keyImpl = GetKeyImpl(type);
		if (keyImpl < 0)
		{
			Type type2 = ResolveProxies(type);
			if ((object)type2 != null)
			{
				type = type2;
				keyImpl = GetKeyImpl(type);
			}
		}
		return keyImpl;
	}

	protected abstract int GetKeyImpl(Type type);

	protected internal abstract void Serialize(int key, object value, ProtoWriter dest);

	protected internal abstract object Deserialize(int key, object value, ProtoReader source);

	public object DeepClone(object value)
	{
		if (value == null)
		{
			return null;
		}
		Type type = value.GetType();
		int key = GetKey(ref type);
		if (key >= 0 && !Helpers.IsEnum(type))
		{
			using (MemoryStream memoryStream = new MemoryStream())
			{
				using (ProtoWriter protoWriter = new ProtoWriter(memoryStream, this, null))
				{
					protoWriter.SetRootObject(value);
					Serialize(key, value, protoWriter);
					protoWriter.Close();
				}
				memoryStream.Position = 0L;
				ProtoReader protoReader = null;
				try
				{
					protoReader = ProtoReader.Create(memoryStream, this, null, -1);
					return Deserialize(key, null, protoReader);
				}
				finally
				{
					ProtoReader.Recycle(protoReader);
				}
			}
		}
		if ((object)type == typeof(byte[]))
		{
			byte[] array = (byte[])value;
			byte[] array2 = new byte[array.Length];
			Helpers.BlockCopy(array, 0, array2, 0, array.Length);
			return array2;
		}
		if (GetWireType(Helpers.GetTypeCode(type), DataFormat.Default, ref type, out var modelKey) != WireType.None && modelKey < 0)
		{
			return value;
		}
		using MemoryStream memoryStream2 = new MemoryStream();
		using (ProtoWriter protoWriter2 = new ProtoWriter(memoryStream2, this, null))
		{
			if (!TrySerializeAuxiliaryType(protoWriter2, type, DataFormat.Default, 1, value, isInsideList: false))
			{
				ThrowUnexpectedType(type);
			}
			protoWriter2.Close();
		}
		memoryStream2.Position = 0L;
		ProtoReader reader = null;
		try
		{
			reader = ProtoReader.Create(memoryStream2, this, null, -1);
			value = null;
			TryDeserializeAuxiliaryType(reader, DataFormat.Default, 1, type, ref value, skipOtherFields: true, asListItem: false, autoCreate: true, insideList: false);
			return value;
		}
		finally
		{
			ProtoReader.Recycle(reader);
		}
	}

	protected internal static void ThrowUnexpectedSubtype(Type expected, Type actual)
	{
		if ((object)expected != ResolveProxies(actual))
		{
			throw new InvalidOperationException("Unexpected sub-type: " + actual.FullName);
		}
	}

	protected internal static void ThrowUnexpectedType(Type type)
	{
		string text = (((object)type == null) ? "(unknown)" : type.FullName);
		if ((object)type != null)
		{
			Type baseType = type.BaseType;
			if ((object)baseType != null && baseType.IsGenericType && baseType.GetGenericTypeDefinition().Name == "GeneratedMessage`2")
			{
				throw new InvalidOperationException("Are you mixing protobuf-net and protobuf-csharp-port? See http://stackoverflow.com/q/11564914; type: " + text);
			}
		}
		throw new InvalidOperationException("Type is not expected, and no contract can be inferred: " + text);
	}

	internal static Exception CreateNestedListsNotSupported()
	{
		return new NotSupportedException("Nested or jagged lists and arrays are not supported");
	}

	public static void ThrowCannotCreateInstance(Type type)
	{
		throw new ProtoException("No parameterless constructor found for " + (((object)type == null) ? "(null)" : type.Name));
	}

	internal static string SerializeType(TypeModel model, Type type)
	{
		if (model != null)
		{
			TypeFormatEventHandler dynamicTypeFormatting = model.DynamicTypeFormatting;
			if (dynamicTypeFormatting != null)
			{
				TypeFormatEventArgs typeFormatEventArgs = new TypeFormatEventArgs(type);
				dynamicTypeFormatting(model, typeFormatEventArgs);
				if (!Helpers.IsNullOrEmpty(typeFormatEventArgs.FormattedName))
				{
					return typeFormatEventArgs.FormattedName;
				}
			}
		}
		return type.AssemblyQualifiedName;
	}

	internal static Type DeserializeType(TypeModel model, string value)
	{
		if (model != null)
		{
			TypeFormatEventHandler dynamicTypeFormatting = model.DynamicTypeFormatting;
			if (dynamicTypeFormatting != null)
			{
				TypeFormatEventArgs typeFormatEventArgs = new TypeFormatEventArgs(value);
				dynamicTypeFormatting(model, typeFormatEventArgs);
				if ((object)typeFormatEventArgs.Type != null)
				{
					return typeFormatEventArgs.Type;
				}
			}
		}
		return Type.GetType(value);
	}

	public bool CanSerializeContractType(Type type)
	{
		return CanSerialize(type, allowBasic: false, allowContract: true, allowLists: true);
	}

	public bool CanSerialize(Type type)
	{
		return CanSerialize(type, allowBasic: true, allowContract: true, allowLists: true);
	}

	public bool CanSerializeBasicType(Type type)
	{
		return CanSerialize(type, allowBasic: true, allowContract: false, allowLists: true);
	}

	private bool CanSerialize(Type type, bool allowBasic, bool allowContract, bool allowLists)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		Type underlyingType = Helpers.GetUnderlyingType(type);
		if ((object)underlyingType != null)
		{
			type = underlyingType;
		}
		switch (Helpers.GetTypeCode(type))
		{
		default:
			return allowBasic;
		case ProtoTypeCode.Empty:
		case ProtoTypeCode.Unknown:
		{
			int key = GetKey(ref type);
			if (key >= 0)
			{
				return allowContract;
			}
			if (allowLists)
			{
				Type type2 = null;
				if (type.IsArray)
				{
					if (type.GetArrayRank() == 1)
					{
						type2 = type.GetElementType();
					}
				}
				else
				{
					type2 = GetListItemType(this, type);
				}
				if ((object)type2 != null)
				{
					return CanSerialize(type2, allowBasic, allowContract, allowLists: false);
				}
			}
			return false;
		}
		}
	}

	public virtual string GetSchema(Type type)
	{
		throw new NotSupportedException();
	}

	public IFormatter CreateFormatter(Type type)
	{
		return new Formatter(this, type);
	}

	internal virtual Type GetType(string fullName, Assembly context)
	{
		return ResolveKnownType(fullName, this, context);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	internal static Type ResolveKnownType(string name, TypeModel model, Assembly assembly)
	{
		if (Helpers.IsNullOrEmpty(name))
		{
			return null;
		}
		try
		{
			Type type = Type.GetType(name);
			if ((object)type != null)
			{
				return type;
			}
		}
		catch
		{
		}
		try
		{
			int num = name.IndexOf(',');
			string name2 = ((num > 0) ? name.Substring(0, num) : name).Trim();
			if ((object)assembly == null)
			{
				assembly = Assembly.GetCallingAssembly();
			}
			Type type2 = assembly?.GetType(name2);
			if ((object)type2 != null)
			{
				return type2;
			}
		}
		catch
		{
		}
		return null;
	}
}


using System;
using System.Collections;
using System.IO;

private class DeserializeItemsIterator : IEnumerator, IEnumerable
{
	private bool haveObject;

	private object current;

	private readonly Stream source;

	private readonly Type type;

	private readonly PrefixStyle style;

	private readonly int expectedField;

	private readonly Serializer.TypeResolver resolver;

	private readonly TypeModel model;

	private readonly SerializationContext context;

	public object Current => current;

	IEnumerator IEnumerable.GetEnumerator()
	{
		return this;
	}

	public bool MoveNext()
	{
		if (haveObject)
		{
			current = model.DeserializeWithLengthPrefix(source, null, type, style, expectedField, resolver, out var _, out haveObject, context);
		}
		return haveObject;
	}

	void IEnumerator.Reset()
	{
		throw new NotSupportedException();
	}

	public DeserializeItemsIterator(TypeModel model, Stream source, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver, SerializationContext context)
	{
		haveObject = true;
		this.source = source;
		this.type = type;
		this.style = style;
		this.expectedField = expectedField;
		this.resolver = resolver;
		this.model = model;
		this.context = context;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;

private sealed class DeserializeItemsIterator<T> : DeserializeItemsIterator, IEnumerator<T>, IDisposable, IEnumerator, IEnumerable<T>, IEnumerable
{
	public new T Current => (T)base.Current;

	IEnumerator<T> IEnumerable<T>.GetEnumerator()
	{
		return this;
	}

	void IDisposable.Dispose()
	{
	}

	public DeserializeItemsIterator(TypeModel model, Stream source, PrefixStyle style, int expectedField, SerializationContext context)
		: base(model, source, model.MapType(typeof(T)), style, expectedField, null, context)
	{
	}
}


protected internal enum CallbackType
{
	BeforeSerialize,
	AfterSerialize,
	BeforeDeserialize,
	AfterDeserialize
}


using System;
using System.IO;
using System.Runtime.Serialization;

internal sealed class Formatter : IFormatter
{
	private readonly TypeModel model;

	private readonly Type type;

	private SerializationBinder binder;

	private StreamingContext context;

	private ISurrogateSelector surrogateSelector;

	public SerializationBinder Binder
	{
		get
		{
			return binder;
		}
		set
		{
			binder = value;
		}
	}

	public StreamingContext Context
	{
		get
		{
			return context;
		}
		set
		{
			context = value;
		}
	}

	public ISurrogateSelector SurrogateSelector
	{
		get
		{
			return surrogateSelector;
		}
		set
		{
			surrogateSelector = value;
		}
	}

	internal Formatter(TypeModel model, Type type)
	{
		if (model == null)
		{
			throw new ArgumentNullException("model");
		}
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		this.model = model;
		this.type = type;
	}

	public object Deserialize(Stream source)
	{
		return model.Deserialize(source, null, type, -1, Context);
	}

	public void Serialize(Stream destination, object graph)
	{
		model.Serialize(destination, graph, Context);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

public sealed class RuntimeTypeModel : TypeModel
{
	private sealed class Singleton
	{
		internal static readonly RuntimeTypeModel Value = new RuntimeTypeModel(isDefault: true);

		private Singleton()
		{
		}
	}

	private sealed class BasicType
	{
		private readonly Type type;

		private readonly IProtoSerializer serializer;

		public Type Type => type;

		public IProtoSerializer Serializer => serializer;

		public BasicType(Type type, IProtoSerializer serializer)
		{
			this.type = type;
			this.serializer = serializer;
		}
	}

	internal sealed class SerializerPair : IComparable
	{
		public readonly int MetaKey;

		public readonly int BaseKey;

		public readonly MetaType Type;

		public readonly MethodBuilder Serialize;

		public readonly MethodBuilder Deserialize;

		public readonly ILGenerator SerializeBody;

		public readonly ILGenerator DeserializeBody;

		int IComparable.CompareTo(object obj)
		{
			if (obj == null)
			{
				throw new ArgumentException("obj");
			}
			SerializerPair serializerPair = (SerializerPair)obj;
			if (BaseKey == MetaKey)
			{
				if (serializerPair.BaseKey == serializerPair.MetaKey)
				{
					int metaKey = MetaKey;
					return metaKey.CompareTo(serializerPair.MetaKey);
				}
				return 1;
			}
			if (serializerPair.BaseKey == serializerPair.MetaKey)
			{
				return -1;
			}
			int baseKey = BaseKey;
			int num = baseKey.CompareTo(serializerPair.BaseKey);
			if (num == 0)
			{
				int metaKey2 = MetaKey;
				num = metaKey2.CompareTo(serializerPair.MetaKey);
			}
			return num;
		}

		public SerializerPair(int metaKey, int baseKey, MetaType type, MethodBuilder serialize, MethodBuilder deserialize, ILGenerator serializeBody, ILGenerator deserializeBody)
		{
			MetaKey = metaKey;
			BaseKey = baseKey;
			Serialize = serialize;
			Deserialize = deserialize;
			SerializeBody = serializeBody;
			DeserializeBody = deserializeBody;
			Type = type;
		}
	}

	public sealed class CompilerOptions
	{
		private string targetFrameworkName;

		private string targetFrameworkDisplayName;

		private string typeName;

		private string outputPath;

		private string imageRuntimeVersion;

		private int metaDataVersion;

		private Accessibility accessibility;

		public string TargetFrameworkName
		{
			get
			{
				return targetFrameworkName;
			}
			set
			{
				targetFrameworkName = value;
			}
		}

		public string TargetFrameworkDisplayName
		{
			get
			{
				return targetFrameworkDisplayName;
			}
			set
			{
				targetFrameworkDisplayName = value;
			}
		}

		public string TypeName
		{
			get
			{
				return typeName;
			}
			set
			{
				typeName = value;
			}
		}

		public string OutputPath
		{
			get
			{
				return outputPath;
			}
			set
			{
				outputPath = value;
			}
		}

		public string ImageRuntimeVersion
		{
			get
			{
				return imageRuntimeVersion;
			}
			set
			{
				imageRuntimeVersion = value;
			}
		}

		public int MetaDataVersion
		{
			get
			{
				return metaDataVersion;
			}
			set
			{
				metaDataVersion = value;
			}
		}

		public Accessibility Accessibility
		{
			get
			{
				return accessibility;
			}
			set
			{
				accessibility = value;
			}
		}

		public void SetFrameworkOptions(MetaType from)
		{
			if (from == null)
			{
				throw new ArgumentNullException("from");
			}
			AttributeMap[] array = AttributeMap.Create(from.Model, from.Type.Assembly);
			AttributeMap[] array2 = array;
			foreach (AttributeMap attributeMap in array2)
			{
				if (attributeMap.AttributeType.FullName == "System.Runtime.Versioning.TargetFrameworkAttribute")
				{
					if (attributeMap.TryGet("FrameworkName", out var value))
					{
						TargetFrameworkName = (string)value;
					}
					if (attributeMap.TryGet("FrameworkDisplayName", out value))
					{
						TargetFrameworkDisplayName = (string)value;
					}
					break;
				}
			}
		}
	}

	public enum Accessibility
	{
		Public,
		Internal
	}

	private const byte OPTIONS_InferTagFromNameDefault = 1;

	private const byte OPTIONS_IsDefaultModel = 2;

	private const byte OPTIONS_Frozen = 4;

	private const byte OPTIONS_AutoAddMissingTypes = 8;

	private const byte OPTIONS_AutoCompile = 16;

	private const byte OPTIONS_UseImplicitZeroDefaults = 32;

	private const byte OPTIONS_AllowParseableTypes = 64;

	private const byte OPTIONS_AutoAddProtoContractTypesOnly = 128;

	private const int KnownTypes_Array = 1;

	private const int KnownTypes_Dictionary = 2;

	private const int KnownTypes_Hashtable = 3;

	private const int KnownTypes_ArrayCutoff = 20;

	private byte options;

	private static readonly BasicList.MatchPredicate MetaTypeFinder = MetaTypeFinderImpl;

	private static readonly BasicList.MatchPredicate BasicTypeFinder = BasicTypeFinderImpl;

	private BasicList basicTypes = new BasicList();

	private readonly BasicList types = new BasicList();

	private int metadataTimeoutMilliseconds = 5000;

	private int contentionCounter = 1;

	private readonly object contentionLock = new object();

	private MethodInfo defaultFactory;

	public bool InferTagFromNameDefault
	{
		get
		{
			return GetOption(1);
		}
		set
		{
			SetOption(1, value);
		}
	}

	public bool AutoAddProtoContractTypesOnly
	{
		get
		{
			return GetOption(128);
		}
		set
		{
			SetOption(128, value);
		}
	}

	public bool UseImplicitZeroDefaults
	{
		get
		{
			return GetOption(32);
		}
		set
		{
			if (!value && GetOption(2))
			{
				throw new InvalidOperationException("UseImplicitZeroDefaults cannot be disabled on the default model");
			}
			SetOption(32, value);
		}
	}

	public bool AllowParseableTypes
	{
		get
		{
			return GetOption(64);
		}
		set
		{
			SetOption(64, value);
		}
	}

	public static RuntimeTypeModel Default => Singleton.Value;

	public MetaType this[Type type] => (MetaType)types[FindOrAddAuto(type, demand: true, addWithContractOnly: false, addEvenIfAutoDisabled: false)];

	public bool AutoCompile
	{
		get
		{
			return GetOption(16);
		}
		set
		{
			SetOption(16, value);
		}
	}

	public bool AutoAddMissingTypes
	{
		get
		{
			return GetOption(8);
		}
		set
		{
			if (!value && GetOption(2))
			{
				throw new InvalidOperationException("The default model must allow missing types");
			}
			ThrowIfFrozen();
			SetOption(8, value);
		}
	}

	public int MetadataTimeoutMilliseconds
	{
		get
		{
			return metadataTimeoutMilliseconds;
		}
		set
		{
			if (value <= 0)
			{
				throw new ArgumentOutOfRangeException("MetadataTimeoutMilliseconds");
			}
			metadataTimeoutMilliseconds = value;
		}
	}

	public event LockContentedEventHandler LockContended;

	private bool GetOption(byte option)
	{
		return (options & option) == option;
	}

	private void SetOption(byte option, bool value)
	{
		if (value)
		{
			options |= option;
		}
		else
		{
			options &= (byte)(~option);
		}
	}

	public IEnumerable GetTypes()
	{
		return types;
	}

	public override string GetSchema(Type type)
	{
		BasicList basicList = new BasicList();
		MetaType metaType = null;
		bool flag = false;
		if ((object)type == null)
		{
			BasicList.NodeEnumerator enumerator = types.GetEnumerator();
			while (enumerator.MoveNext())
			{
				MetaType metaType2 = (MetaType)enumerator.Current;
				MetaType surrogateOrBaseOrSelf = metaType2.GetSurrogateOrBaseOrSelf(deep: false);
				if (!basicList.Contains(surrogateOrBaseOrSelf))
				{
					basicList.Add(surrogateOrBaseOrSelf);
					CascadeDependents(basicList, surrogateOrBaseOrSelf);
				}
			}
		}
		else
		{
			Type underlyingType = Helpers.GetUnderlyingType(type);
			if ((object)underlyingType != null)
			{
				type = underlyingType;
			}
			flag = ValueMember.TryGetCoreSerializer(this, DataFormat.Default, type, out var _, asReference: false, dynamicType: false, overwriteList: false, allowComplexTypes: false) != null;
			if (!flag)
			{
				int num = FindOrAddAuto(type, demand: false, addWithContractOnly: false, addEvenIfAutoDisabled: false);
				if (num < 0)
				{
					throw new ArgumentException("The type specified is not a contract-type", "type");
				}
				metaType = ((MetaType)types[num]).GetSurrogateOrBaseOrSelf(deep: false);
				basicList.Add(metaType);
				CascadeDependents(basicList, metaType);
			}
		}
		StringBuilder stringBuilder = new StringBuilder();
		string text = null;
		if (!flag)
		{
			IEnumerable enumerable = ((metaType == null) ? types : basicList);
			foreach (MetaType item in enumerable)
			{
				if (item.IsList)
				{
					continue;
				}
				string @namespace = item.Type.Namespace;
				if (!Helpers.IsNullOrEmpty(@namespace) && !@namespace.StartsWith("System."))
				{
					if (text == null)
					{
						text = @namespace;
					}
					else if (!(text == @namespace))
					{
						text = null;
						break;
					}
				}
			}
		}
		if (!Helpers.IsNullOrEmpty(text))
		{
			stringBuilder.Append("package ").Append(text).Append(';');
			Helpers.AppendLine(stringBuilder);
		}
		bool requiresBclImport = false;
		StringBuilder stringBuilder2 = new StringBuilder();
		MetaType[] array = new MetaType[basicList.Count];
		basicList.CopyTo(array, 0);
		Array.Sort(array, MetaType.Comparer.Default);
		if (flag)
		{
			Helpers.AppendLine(stringBuilder2).Append("message ").Append(type.Name)
				.Append(" {");
			MetaType.NewLine(stringBuilder2, 1).Append("optional ").Append(GetSchemaTypeName(type, DataFormat.Default, asReference: false, dynamicType: false, ref requiresBclImport))
				.Append(" value = 1;");
			Helpers.AppendLine(stringBuilder2).Append('}');
		}
		else
		{
			foreach (MetaType metaType4 in array)
			{
				if (!metaType4.IsList || metaType4 == metaType)
				{
					metaType4.WriteSchema(stringBuilder2, 0, ref requiresBclImport);
				}
			}
		}
		if (requiresBclImport)
		{
			stringBuilder.Append("import \"bcl.proto\"; // schema for protobuf-net's handling of core .NET types");
			Helpers.AppendLine(stringBuilder);
		}
		return Helpers.AppendLine(stringBuilder.Append((object?)stringBuilder2)).ToString();
	}

	private void CascadeDependents(BasicList list, MetaType metaType)
	{
		MetaType surrogateOrBaseOrSelf;
		if (metaType.IsList)
		{
			Type listItemType = TypeModel.GetListItemType(this, metaType.Type);
			WireType defaultWireType;
			IProtoSerializer protoSerializer = ValueMember.TryGetCoreSerializer(this, DataFormat.Default, listItemType, out defaultWireType, asReference: false, dynamicType: false, overwriteList: false, allowComplexTypes: false);
			if (protoSerializer != null)
			{
				return;
			}
			int num = FindOrAddAuto(listItemType, demand: false, addWithContractOnly: false, addEvenIfAutoDisabled: false);
			if (num >= 0)
			{
				surrogateOrBaseOrSelf = ((MetaType)types[num]).GetSurrogateOrBaseOrSelf(deep: false);
				if (!list.Contains(surrogateOrBaseOrSelf))
				{
					list.Add(surrogateOrBaseOrSelf);
					CascadeDependents(list, surrogateOrBaseOrSelf);
				}
			}
			return;
		}
		if (metaType.IsAutoTuple)
		{
			if ((object)MetaType.ResolveTupleConstructor(metaType.Type, out var mappedMembers) != null)
			{
				for (int i = 0; i < mappedMembers.Length; i++)
				{
					Type type = null;
					if (mappedMembers[i] is PropertyInfo)
					{
						type = ((PropertyInfo)mappedMembers[i]).PropertyType;
					}
					else if (mappedMembers[i] is FieldInfo)
					{
						type = ((FieldInfo)mappedMembers[i]).FieldType;
					}
					WireType defaultWireType2;
					IProtoSerializer protoSerializer2 = ValueMember.TryGetCoreSerializer(this, DataFormat.Default, type, out defaultWireType2, asReference: false, dynamicType: false, overwriteList: false, allowComplexTypes: false);
					if (protoSerializer2 != null)
					{
						continue;
					}
					int num2 = FindOrAddAuto(type, demand: false, addWithContractOnly: false, addEvenIfAutoDisabled: false);
					if (num2 >= 0)
					{
						surrogateOrBaseOrSelf = ((MetaType)types[num2]).GetSurrogateOrBaseOrSelf(deep: false);
						if (!list.Contains(surrogateOrBaseOrSelf))
						{
							list.Add(surrogateOrBaseOrSelf);
							CascadeDependents(list, surrogateOrBaseOrSelf);
						}
					}
				}
			}
		}
		else
		{
			foreach (ValueMember field in metaType.Fields)
			{
				Type type2 = field.ItemType;
				if ((object)type2 == null)
				{
					type2 = field.MemberType;
				}
				WireType defaultWireType3;
				IProtoSerializer protoSerializer3 = ValueMember.TryGetCoreSerializer(this, DataFormat.Default, type2, out defaultWireType3, asReference: false, dynamicType: false, overwriteList: false, allowComplexTypes: false);
				if (protoSerializer3 != null)
				{
					continue;
				}
				int num3 = FindOrAddAuto(type2, demand: false, addWithContractOnly: false, addEvenIfAutoDisabled: false);
				if (num3 >= 0)
				{
					surrogateOrBaseOrSelf = ((MetaType)types[num3]).GetSurrogateOrBaseOrSelf(deep: false);
					if (!list.Contains(surrogateOrBaseOrSelf))
					{
						list.Add(surrogateOrBaseOrSelf);
						CascadeDependents(list, surrogateOrBaseOrSelf);
					}
				}
			}
		}
		if (metaType.HasSubtypes)
		{
			SubType[] subtypes = metaType.GetSubtypes();
			foreach (SubType subType in subtypes)
			{
				surrogateOrBaseOrSelf = subType.DerivedType.GetSurrogateOrSelf();
				if (!list.Contains(surrogateOrBaseOrSelf))
				{
					list.Add(surrogateOrBaseOrSelf);
					CascadeDependents(list, surrogateOrBaseOrSelf);
				}
			}
		}
		surrogateOrBaseOrSelf = metaType.BaseType;
		if (surrogateOrBaseOrSelf != null)
		{
			surrogateOrBaseOrSelf = surrogateOrBaseOrSelf.GetSurrogateOrSelf();
		}
		if (surrogateOrBaseOrSelf != null && !list.Contains(surrogateOrBaseOrSelf))
		{
			list.Add(surrogateOrBaseOrSelf);
			CascadeDependents(list, surrogateOrBaseOrSelf);
		}
	}

	internal RuntimeTypeModel(bool isDefault)
	{
		AutoAddMissingTypes = true;
		UseImplicitZeroDefaults = true;
		SetOption(2, isDefault);
		AutoCompile = true;
	}

	internal MetaType FindWithoutAdd(Type type)
	{
		BasicList.NodeEnumerator enumerator = types.GetEnumerator();
		while (enumerator.MoveNext())
		{
			MetaType metaType = (MetaType)enumerator.Current;
			if ((object)metaType.Type == type)
			{
				if (metaType.Pending)
				{
					WaitOnLock(metaType);
				}
				return metaType;
			}
		}
		Type type2 = TypeModel.ResolveProxies(type);
		if ((object)type2 != null)
		{
			return FindWithoutAdd(type2);
		}
		return null;
	}

	private static bool MetaTypeFinderImpl(object value, object ctx)
	{
		return (object)((MetaType)value).Type == (Type)ctx;
	}

	private static bool BasicTypeFinderImpl(object value, object ctx)
	{
		return (object)((BasicType)value).Type == (Type)ctx;
	}

	private void WaitOnLock(MetaType type)
	{
		int opaqueToken = 0;
		try
		{
			TakeLock(ref opaqueToken);
		}
		finally
		{
			ReleaseLock(opaqueToken);
		}
	}

	internal IProtoSerializer TryGetBasicTypeSerializer(Type type)
	{
		int num = basicTypes.IndexOf(BasicTypeFinder, type);
		if (num >= 0)
		{
			return ((BasicType)basicTypes[num]).Serializer;
		}
		lock (basicTypes)
		{
			num = basicTypes.IndexOf(BasicTypeFinder, type);
			if (num >= 0)
			{
				return ((BasicType)basicTypes[num]).Serializer;
			}
			WireType defaultWireType;
			IProtoSerializer protoSerializer = ((MetaType.GetContractFamily(this, type, null) == MetaType.AttributeFamily.None) ? ValueMember.TryGetCoreSerializer(this, DataFormat.Default, type, out defaultWireType, asReference: false, dynamicType: false, overwriteList: false, allowComplexTypes: false) : null);
			if (protoSerializer != null)
			{
				basicTypes.Add(new BasicType(type, protoSerializer));
			}
			return protoSerializer;
		}
	}

	internal int FindOrAddAuto(Type type, bool demand, bool addWithContractOnly, bool addEvenIfAutoDisabled)
	{
		int num = types.IndexOf(MetaTypeFinder, type);
		if (num >= 0)
		{
			MetaType metaType = (MetaType)types[num];
			if (metaType.Pending)
			{
				WaitOnLock(metaType);
			}
			return num;
		}
		bool flag = AutoAddMissingTypes || addEvenIfAutoDisabled;
		if (!Helpers.IsEnum(type) && TryGetBasicTypeSerializer(type) != null)
		{
			if (flag && !addWithContractOnly)
			{
				throw MetaType.InbuiltType(type);
			}
			return -1;
		}
		Type type2 = TypeModel.ResolveProxies(type);
		if ((object)type2 != null)
		{
			num = types.IndexOf(MetaTypeFinder, type2);
			type = type2;
		}
		if (num < 0)
		{
			int opaqueToken = 0;
			try
			{
				TakeLock(ref opaqueToken);
				MetaType metaType;
				if ((metaType = RecogniseCommonTypes(type)) == null)
				{
					MetaType.AttributeFamily contractFamily = MetaType.GetContractFamily(this, type, null);
					if (contractFamily == MetaType.AttributeFamily.AutoTuple)
					{
						flag = (addEvenIfAutoDisabled = true);
					}
					if (!flag || (!Helpers.IsEnum(type) && addWithContractOnly && contractFamily == MetaType.AttributeFamily.None))
					{
						if (demand)
						{
							TypeModel.ThrowUnexpectedType(type);
						}
						return num;
					}
					metaType = Create(type);
				}
				metaType.Pending = true;
				bool flag2 = false;
				int num2 = types.IndexOf(MetaTypeFinder, type);
				if (num2 < 0)
				{
					ThrowIfFrozen();
					num = types.Add(metaType);
					flag2 = true;
				}
				else
				{
					num = num2;
				}
				if (flag2)
				{
					metaType.ApplyDefaultBehaviour();
					metaType.Pending = false;
				}
			}
			finally
			{
				ReleaseLock(opaqueToken);
			}
		}
		return num;
	}

	private MetaType RecogniseCommonTypes(Type type)
	{
		return null;
	}

	private MetaType Create(Type type)
	{
		ThrowIfFrozen();
		return new MetaType(this, type, defaultFactory);
	}

	public MetaType Add(Type type, bool applyDefaultBehaviour)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		MetaType metaType = FindWithoutAdd(type);
		if (metaType != null)
		{
			return metaType;
		}
		int opaqueToken = 0;
		if (type.IsInterface && MapType(MetaType.ienumerable).IsAssignableFrom(type) && (object)TypeModel.GetListItemType(this, type) == null)
		{
			throw new ArgumentException("IEnumerable[<T>] data cannot be used as a meta-type unless an Add method can be resolved");
		}
		try
		{
			metaType = RecogniseCommonTypes(type);
			if (metaType != null)
			{
				if (!applyDefaultBehaviour)
				{
					throw new ArgumentException("Default behaviour must be observed for certain types with special handling; " + type.FullName, "applyDefaultBehaviour");
				}
				applyDefaultBehaviour = false;
			}
			if (metaType == null)
			{
				metaType = Create(type);
			}
			metaType.Pending = true;
			TakeLock(ref opaqueToken);
			if (FindWithoutAdd(type) != null)
			{
				throw new ArgumentException("Duplicate type", "type");
			}
			ThrowIfFrozen();
			types.Add(metaType);
			if (applyDefaultBehaviour)
			{
				metaType.ApplyDefaultBehaviour();
			}
			metaType.Pending = false;
			return metaType;
		}
		finally
		{
			ReleaseLock(opaqueToken);
		}
	}

	private void ThrowIfFrozen()
	{
		if (GetOption(4))
		{
			throw new InvalidOperationException("The model cannot be changed once frozen");
		}
	}

	public void Freeze()
	{
		if (GetOption(2))
		{
			throw new InvalidOperationException("The default model cannot be frozen");
		}
		SetOption(4, value: true);
	}

	protected override int GetKeyImpl(Type type)
	{
		return GetKey(type, demand: false, getBaseKey: true);
	}

	internal int GetKey(Type type, bool demand, bool getBaseKey)
	{
		try
		{
			int num = FindOrAddAuto(type, demand, addWithContractOnly: true, addEvenIfAutoDisabled: false);
			if (num >= 0)
			{
				MetaType source = (MetaType)types[num];
				if (getBaseKey)
				{
					source = MetaType.GetRootType(source);
					num = FindOrAddAuto(source.Type, demand: true, addWithContractOnly: true, addEvenIfAutoDisabled: false);
				}
			}
			return num;
		}
		catch (NotSupportedException)
		{
			throw;
		}
		catch (Exception ex2)
		{
			if (ex2.Message.IndexOf(type.FullName) >= 0)
			{
				throw;
			}
			throw new ProtoException(ex2.Message + " (" + type.FullName + ")", ex2);
		}
	}

	protected internal override void Serialize(int key, object value, ProtoWriter dest)
	{
		((MetaType)types[key]).Serializer.Write(value, dest);
	}

	protected internal override object Deserialize(int key, object value, ProtoReader source)
	{
		IProtoSerializer serializer = ((MetaType)types[key]).Serializer;
		if (value == null && Helpers.IsValueType(serializer.ExpectedType))
		{
			if (serializer.RequiresOldValue)
			{
				value = Activator.CreateInstance(serializer.ExpectedType);
			}
			return serializer.Read(value, source);
		}
		return serializer.Read(value, source);
	}

	internal ProtoSerializer GetSerializer(IProtoSerializer serializer, bool compiled)
	{
		if (serializer == null)
		{
			throw new ArgumentNullException("serializer");
		}
		if (compiled)
		{
			return CompilerContext.BuildSerializer(serializer, this);
		}
		return serializer.Write;
	}

	public void CompileInPlace()
	{
		BasicList.NodeEnumerator enumerator = types.GetEnumerator();
		while (enumerator.MoveNext())
		{
			MetaType metaType = (MetaType)enumerator.Current;
			metaType.CompileInPlace();
		}
	}

	private void BuildAllSerializers()
	{
		for (int i = 0; i < types.Count; i++)
		{
			MetaType metaType = (MetaType)types[i];
			if (metaType.Serializer == null)
			{
				throw new InvalidOperationException("No serializer available for " + metaType.Type.Name);
			}
		}
	}

	public TypeModel Compile()
	{
		return Compile(null, null);
	}

	private static ILGenerator Override(TypeBuilder type, string name)
	{
		MethodInfo method = type.BaseType.GetMethod(name, BindingFlags.Instance | BindingFlags.NonPublic);
		ParameterInfo[] parameters = method.GetParameters();
		Type[] array = new Type[parameters.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = parameters[i].ParameterType;
		}
		MethodBuilder methodBuilder = type.DefineMethod(method.Name, (method.Attributes & ~MethodAttributes.Abstract) | MethodAttributes.Final, method.CallingConvention, method.ReturnType, array);
		ILGenerator iLGenerator = methodBuilder.GetILGenerator();
		type.DefineMethodOverride(methodBuilder, method);
		return iLGenerator;
	}

	public TypeModel Compile(string name, string path)
	{
		CompilerOptions compilerOptions = new CompilerOptions();
		compilerOptions.TypeName = name;
		compilerOptions.OutputPath = path;
		return Compile(compilerOptions);
	}

	public TypeModel Compile(CompilerOptions options)
	{
		if (options == null)
		{
			throw new ArgumentNullException("options");
		}
		string text = options.TypeName;
		string outputPath = options.OutputPath;
		BuildAllSerializers();
		Freeze();
		bool flag = !Helpers.IsNullOrEmpty(outputPath);
		if (Helpers.IsNullOrEmpty(text))
		{
			if (flag)
			{
				throw new ArgumentNullException("typeName");
			}
			text = Guid.NewGuid().ToString();
		}
		string text2;
		string text3;
		if (outputPath == null)
		{
			text2 = text;
			text3 = text2 + ".dll";
		}
		else
		{
			text2 = new FileInfo(Path.GetFileNameWithoutExtension(outputPath)).Name;
			text3 = text2 + Path.GetExtension(outputPath);
		}
		AssemblyName assemblyName = new AssemblyName();
		assemblyName.Name = text2;
		AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, (!flag) ? AssemblyBuilderAccess.Run : ((AssemblyBuilderAccess)3));
		ModuleBuilder module = (flag ? assemblyBuilder.DefineDynamicModule(text3, outputPath) : assemblyBuilder.DefineDynamicModule(text3));
		WriteAssemblyAttributes(options, text2, assemblyBuilder);
		TypeBuilder typeBuilder = WriteBasicTypeModel(options, text, module);
		WriteSerializers(options, text2, typeBuilder, out var index, out var hasInheritance, out var methodPairs, out var ilVersion);
		WriteGetKeyImpl(typeBuilder, hasInheritance, methodPairs, ilVersion, text2, out var il, out var knownTypesCategory, out var knownTypes, out var knownTypesLookupType);
		CompilerContext ctx = WriteSerializeDeserialize(text2, typeBuilder, methodPairs, ilVersion, ref il);
		WriteConstructors(typeBuilder, ref index, methodPairs, ref il, knownTypesCategory, knownTypes, knownTypesLookupType, ctx);
		Type type = typeBuilder.CreateType();
		if (!Helpers.IsNullOrEmpty(outputPath))
		{
			assemblyBuilder.Save(outputPath);
		}
		return (TypeModel)Activator.CreateInstance(type);
	}

	private void WriteConstructors(TypeBuilder type, ref int index, SerializerPair[] methodPairs, ref ILGenerator il, int knownTypesCategory, FieldBuilder knownTypes, Type knownTypesLookupType, CompilerContext ctx)
	{
		type.DefineDefaultConstructor(MethodAttributes.Public);
		il = type.DefineTypeInitializer().GetILGenerator();
		switch (knownTypesCategory)
		{
		case 1:
			CompilerContext.LoadValue(il, types.Count);
			il.Emit(OpCodes.Newarr, ctx.MapType(typeof(Type)));
			index = 0;
			foreach (SerializerPair serializerPair3 in methodPairs)
			{
				il.Emit(OpCodes.Dup);
				CompilerContext.LoadValue(il, index);
				il.Emit(OpCodes.Ldtoken, serializerPair3.Type.Type);
				il.EmitCall(OpCodes.Call, ctx.MapType(typeof(Type)).GetMethod("GetTypeFromHandle"), null);
				il.Emit(OpCodes.Stelem_Ref);
				index++;
			}
			il.Emit(OpCodes.Stsfld, knownTypes);
			il.Emit(OpCodes.Ret);
			break;
		case 2:
		{
			CompilerContext.LoadValue(il, types.Count);
			il.Emit(OpCodes.Newobj, knownTypesLookupType.GetConstructor(new Type[1] { MapType(typeof(int)) }));
			il.Emit(OpCodes.Stsfld, knownTypes);
			int num2 = 0;
			foreach (SerializerPair serializerPair2 in methodPairs)
			{
				il.Emit(OpCodes.Ldsfld, knownTypes);
				il.Emit(OpCodes.Ldtoken, serializerPair2.Type.Type);
				il.EmitCall(OpCodes.Call, ctx.MapType(typeof(Type)).GetMethod("GetTypeFromHandle"), null);
				int value2 = num2++;
				int baseKey2 = serializerPair2.BaseKey;
				if (baseKey2 != serializerPair2.MetaKey)
				{
					value2 = -1;
					for (int l = 0; l < methodPairs.Length; l++)
					{
						if (methodPairs[l].BaseKey == baseKey2 && methodPairs[l].MetaKey == baseKey2)
						{
							value2 = l;
							break;
						}
					}
				}
				CompilerContext.LoadValue(il, value2);
				il.EmitCall(OpCodes.Callvirt, knownTypesLookupType.GetMethod("Add", new Type[2]
				{
					MapType(typeof(Type)),
					MapType(typeof(int))
				}), null);
			}
			il.Emit(OpCodes.Ret);
			break;
		}
		case 3:
		{
			CompilerContext.LoadValue(il, types.Count);
			il.Emit(OpCodes.Newobj, knownTypesLookupType.GetConstructor(new Type[1] { MapType(typeof(int)) }));
			il.Emit(OpCodes.Stsfld, knownTypes);
			int num = 0;
			foreach (SerializerPair serializerPair in methodPairs)
			{
				il.Emit(OpCodes.Ldsfld, knownTypes);
				il.Emit(OpCodes.Ldtoken, serializerPair.Type.Type);
				il.EmitCall(OpCodes.Call, ctx.MapType(typeof(Type)).GetMethod("GetTypeFromHandle"), null);
				int value = num++;
				int baseKey = serializerPair.BaseKey;
				if (baseKey != serializerPair.MetaKey)
				{
					value = -1;
					for (int j = 0; j < methodPairs.Length; j++)
					{
						if (methodPairs[j].BaseKey == baseKey && methodPairs[j].MetaKey == baseKey)
						{
							value = j;
							break;
						}
					}
				}
				CompilerContext.LoadValue(il, value);
				il.Emit(OpCodes.Box, MapType(typeof(int)));
				il.EmitCall(OpCodes.Callvirt, knownTypesLookupType.GetMethod("Add", new Type[2]
				{
					MapType(typeof(object)),
					MapType(typeof(object))
				}), null);
			}
			il.Emit(OpCodes.Ret);
			break;
		}
		default:
			throw new InvalidOperationException();
		}
	}

	private CompilerContext WriteSerializeDeserialize(string assemblyName, TypeBuilder type, SerializerPair[] methodPairs, CompilerContext.ILVersion ilVersion, ref ILGenerator il)
	{
		il = Override(type, "Serialize");
		CompilerContext compilerContext = new CompilerContext(il, isStatic: false, isWriter: true, methodPairs, this, ilVersion, assemblyName, MapType(typeof(object)));
		CodeLabel[] array = new CodeLabel[types.Count];
		for (int i = 0; i < array.Length; i++)
		{
			ref CodeLabel reference = ref array[i];
			reference = compilerContext.DefineLabel();
		}
		il.Emit(OpCodes.Ldarg_1);
		compilerContext.Switch(array);
		compilerContext.Return();
		for (int j = 0; j < array.Length; j++)
		{
			SerializerPair serializerPair = methodPairs[j];
			compilerContext.MarkLabel(array[j]);
			il.Emit(OpCodes.Ldarg_2);
			compilerContext.CastFromObject(serializerPair.Type.Type);
			il.Emit(OpCodes.Ldarg_3);
			il.EmitCall(OpCodes.Call, serializerPair.Serialize, null);
			compilerContext.Return();
		}
		il = Override(type, "Deserialize");
		compilerContext = new CompilerContext(il, isStatic: false, isWriter: false, methodPairs, this, ilVersion, assemblyName, MapType(typeof(object)));
		for (int k = 0; k < array.Length; k++)
		{
			ref CodeLabel reference2 = ref array[k];
			reference2 = compilerContext.DefineLabel();
		}
		il.Emit(OpCodes.Ldarg_1);
		compilerContext.Switch(array);
		compilerContext.LoadNullRef();
		compilerContext.Return();
		for (int l = 0; l < array.Length; l++)
		{
			SerializerPair serializerPair2 = methodPairs[l];
			compilerContext.MarkLabel(array[l]);
			Type type2 = serializerPair2.Type.Type;
			if (type2.IsValueType)
			{
				il.Emit(OpCodes.Ldarg_2);
				il.Emit(OpCodes.Ldarg_3);
				il.EmitCall(OpCodes.Call, EmitBoxedSerializer(type, l, type2, methodPairs, this, ilVersion, assemblyName), null);
				compilerContext.Return();
			}
			else
			{
				il.Emit(OpCodes.Ldarg_2);
				compilerContext.CastFromObject(type2);
				il.Emit(OpCodes.Ldarg_3);
				il.EmitCall(OpCodes.Call, serializerPair2.Deserialize, null);
				compilerContext.Return();
			}
		}
		return compilerContext;
	}

	private void WriteGetKeyImpl(TypeBuilder type, bool hasInheritance, SerializerPair[] methodPairs, CompilerContext.ILVersion ilVersion, string assemblyName, out ILGenerator il, out int knownTypesCategory, out FieldBuilder knownTypes, out Type knownTypesLookupType)
	{
		il = Override(type, "GetKeyImpl");
		CompilerContext compilerContext = new CompilerContext(il, isStatic: false, isWriter: false, methodPairs, this, ilVersion, assemblyName, MapType(typeof(Type), demand: true));
		if (types.Count <= 20)
		{
			knownTypesCategory = 1;
			knownTypesLookupType = MapType(typeof(Type[]), demand: true);
		}
		else
		{
			knownTypesLookupType = MapType(typeof(Dictionary<Type, int>), demand: false);
			if ((object)knownTypesLookupType == null)
			{
				knownTypesLookupType = MapType(typeof(Hashtable), demand: true);
				knownTypesCategory = 3;
			}
			else
			{
				knownTypesCategory = 2;
			}
		}
		knownTypes = type.DefineField("knownTypes", knownTypesLookupType, FieldAttributes.Private | FieldAttributes.Static | FieldAttributes.InitOnly);
		switch (knownTypesCategory)
		{
		case 1:
			il.Emit(OpCodes.Ldsfld, knownTypes);
			il.Emit(OpCodes.Ldarg_1);
			il.EmitCall(OpCodes.Callvirt, MapType(typeof(IList)).GetMethod("IndexOf", new Type[1] { MapType(typeof(object)) }), null);
			if (hasInheritance)
			{
				il.DeclareLocal(MapType(typeof(int)));
				il.Emit(OpCodes.Dup);
				il.Emit(OpCodes.Stloc_0);
				BasicList basicList = new BasicList();
				int num = -1;
				for (int i = 0; i < methodPairs.Length && methodPairs[i].MetaKey != methodPairs[i].BaseKey; i++)
				{
					if (num == methodPairs[i].BaseKey)
					{
						basicList.Add(basicList[basicList.Count - 1]);
						continue;
					}
					basicList.Add(compilerContext.DefineLabel());
					num = methodPairs[i].BaseKey;
				}
				CodeLabel[] array = new CodeLabel[basicList.Count];
				basicList.CopyTo(array, 0);
				compilerContext.Switch(array);
				il.Emit(OpCodes.Ldloc_0);
				il.Emit(OpCodes.Ret);
				num = -1;
				for (int num2 = array.Length - 1; num2 >= 0; num2--)
				{
					if (num != methodPairs[num2].BaseKey)
					{
						num = methodPairs[num2].BaseKey;
						int value = -1;
						for (int j = array.Length; j < methodPairs.Length; j++)
						{
							if (methodPairs[j].BaseKey == num && methodPairs[j].MetaKey == num)
							{
								value = j;
								break;
							}
						}
						compilerContext.MarkLabel(array[num2]);
						CompilerContext.LoadValue(il, value);
						il.Emit(OpCodes.Ret);
					}
				}
			}
			else
			{
				il.Emit(OpCodes.Ret);
			}
			break;
		case 2:
		{
			LocalBuilder local = il.DeclareLocal(MapType(typeof(int)));
			Label label2 = il.DefineLabel();
			il.Emit(OpCodes.Ldsfld, knownTypes);
			il.Emit(OpCodes.Ldarg_1);
			il.Emit(OpCodes.Ldloca_S, local);
			il.EmitCall(OpCodes.Callvirt, knownTypesLookupType.GetMethod("TryGetValue", BindingFlags.Instance | BindingFlags.Public), null);
			il.Emit(OpCodes.Brfalse_S, label2);
			il.Emit(OpCodes.Ldloc_S, local);
			il.Emit(OpCodes.Ret);
			il.MarkLabel(label2);
			il.Emit(OpCodes.Ldc_I4_M1);
			il.Emit(OpCodes.Ret);
			break;
		}
		case 3:
		{
			Label label = il.DefineLabel();
			il.Emit(OpCodes.Ldsfld, knownTypes);
			il.Emit(OpCodes.Ldarg_1);
			il.EmitCall(OpCodes.Callvirt, knownTypesLookupType.GetProperty("Item").GetGetMethod(), null);
			il.Emit(OpCodes.Dup);
			il.Emit(OpCodes.Brfalse_S, label);
			if (ilVersion == CompilerContext.ILVersion.Net1)
			{
				il.Emit(OpCodes.Unbox, MapType(typeof(int)));
				il.Emit(OpCodes.Ldobj, MapType(typeof(int)));
			}
			else
			{
				il.Emit(OpCodes.Unbox_Any, MapType(typeof(int)));
			}
			il.Emit(OpCodes.Ret);
			il.MarkLabel(label);
			il.Emit(OpCodes.Pop);
			il.Emit(OpCodes.Ldc_I4_M1);
			il.Emit(OpCodes.Ret);
			break;
		}
		default:
			throw new InvalidOperationException();
		}
	}

	private void WriteSerializers(CompilerOptions options, string assemblyName, TypeBuilder type, out int index, out bool hasInheritance, out SerializerPair[] methodPairs, out CompilerContext.ILVersion ilVersion)
	{
		index = 0;
		hasInheritance = false;
		methodPairs = new SerializerPair[types.Count];
		BasicList.NodeEnumerator enumerator = types.GetEnumerator();
		while (enumerator.MoveNext())
		{
			MetaType metaType = (MetaType)enumerator.Current;
			MethodBuilder methodBuilder = type.DefineMethod("Write", MethodAttributes.Private | MethodAttributes.Static, CallingConventions.Standard, MapType(typeof(void)), new Type[2]
			{
				metaType.Type,
				MapType(typeof(ProtoWriter))
			});
			MethodBuilder methodBuilder2 = type.DefineMethod("Read", MethodAttributes.Private | MethodAttributes.Static, CallingConventions.Standard, metaType.Type, new Type[2]
			{
				metaType.Type,
				MapType(typeof(ProtoReader))
			});
			SerializerPair serializerPair = new SerializerPair(GetKey(metaType.Type, demand: true, getBaseKey: false), GetKey(metaType.Type, demand: true, getBaseKey: true), metaType, methodBuilder, methodBuilder2, methodBuilder.GetILGenerator(), methodBuilder2.GetILGenerator());
			methodPairs[index++] = serializerPair;
			if (serializerPair.MetaKey != serializerPair.BaseKey)
			{
				hasInheritance = true;
			}
		}
		if (hasInheritance)
		{
			Array.Sort(methodPairs);
		}
		ilVersion = CompilerContext.ILVersion.Net2;
		if (options.MetaDataVersion == 65536)
		{
			ilVersion = CompilerContext.ILVersion.Net1;
		}
		for (index = 0; index < methodPairs.Length; index++)
		{
			SerializerPair serializerPair2 = methodPairs[index];
			CompilerContext compilerContext = new CompilerContext(serializerPair2.SerializeBody, isStatic: true, isWriter: true, methodPairs, this, ilVersion, assemblyName, serializerPair2.Type.Type);
			compilerContext.CheckAccessibility(serializerPair2.Deserialize.ReturnType);
			serializerPair2.Type.Serializer.EmitWrite(compilerContext, compilerContext.InputValue);
			compilerContext.Return();
			compilerContext = new CompilerContext(serializerPair2.DeserializeBody, isStatic: true, isWriter: false, methodPairs, this, ilVersion, assemblyName, serializerPair2.Type.Type);
			serializerPair2.Type.Serializer.EmitRead(compilerContext, compilerContext.InputValue);
			if (!serializerPair2.Type.Serializer.ReturnsValue)
			{
				compilerContext.LoadValue(compilerContext.InputValue);
			}
			compilerContext.Return();
		}
	}

	private TypeBuilder WriteBasicTypeModel(CompilerOptions options, string typeName, ModuleBuilder module)
	{
		Type type = MapType(typeof(TypeModel));
		TypeAttributes typeAttributes = (type.Attributes & ~TypeAttributes.Abstract) | TypeAttributes.Sealed;
		if (options.Accessibility == Accessibility.Internal)
		{
			typeAttributes &= ~TypeAttributes.Public;
		}
		return module.DefineType(typeName, typeAttributes, type);
	}

	private void WriteAssemblyAttributes(CompilerOptions options, string assemblyName, AssemblyBuilder asm)
	{
		if (!Helpers.IsNullOrEmpty(options.TargetFrameworkName))
		{
			Type type = null;
			try
			{
				type = GetType("System.Runtime.Versioning.TargetFrameworkAttribute", MapType(typeof(string)).Assembly);
			}
			catch
			{
			}
			if ((object)type != null)
			{
				PropertyInfo[] namedProperties;
				object[] propertyValues;
				if (Helpers.IsNullOrEmpty(options.TargetFrameworkDisplayName))
				{
					namedProperties = new PropertyInfo[0];
					propertyValues = new object[0];
				}
				else
				{
					namedProperties = new PropertyInfo[1] { type.GetProperty("FrameworkDisplayName") };
					propertyValues = new object[1] { options.TargetFrameworkDisplayName };
				}
				CustomAttributeBuilder customAttribute = new CustomAttributeBuilder(type.GetConstructor(new Type[1] { MapType(typeof(string)) }), new object[1] { options.TargetFrameworkName }, namedProperties, propertyValues);
				asm.SetCustomAttribute(customAttribute);
			}
		}
		Type type2 = null;
		try
		{
			type2 = MapType(typeof(InternalsVisibleToAttribute));
		}
		catch
		{
		}
		if ((object)type2 == null)
		{
			return;
		}
		BasicList basicList = new BasicList();
		BasicList basicList2 = new BasicList();
		BasicList.NodeEnumerator enumerator = types.GetEnumerator();
		while (enumerator.MoveNext())
		{
			MetaType metaType = (MetaType)enumerator.Current;
			Assembly assembly = metaType.Type.Assembly;
			if (basicList2.IndexOfReference(assembly) >= 0)
			{
				continue;
			}
			basicList2.Add(assembly);
			AttributeMap[] array = AttributeMap.Create(this, assembly);
			for (int i = 0; i < array.Length; i++)
			{
				if ((object)array[i].AttributeType == type2)
				{
					array[i].TryGet("AssemblyName", out var value);
					string text = value as string;
					if (!(text == assemblyName) && !Helpers.IsNullOrEmpty(text) && basicList.IndexOfString(text) < 0)
					{
						basicList.Add(text);
						CustomAttributeBuilder customAttribute2 = new CustomAttributeBuilder(type2.GetConstructor(new Type[1] { MapType(typeof(string)) }), new object[1] { text });
						asm.SetCustomAttribute(customAttribute2);
					}
				}
			}
		}
	}

	private static MethodBuilder EmitBoxedSerializer(TypeBuilder type, int i, Type valueType, SerializerPair[] methodPairs, TypeModel model, CompilerContext.ILVersion ilVersion, string assemblyName)
	{
		MethodInfo deserialize = methodPairs[i].Deserialize;
		MethodBuilder methodBuilder = type.DefineMethod("_" + i, MethodAttributes.Static, CallingConventions.Standard, model.MapType(typeof(object)), new Type[2]
		{
			model.MapType(typeof(object)),
			model.MapType(typeof(ProtoReader))
		});
		CompilerContext compilerContext = new CompilerContext(methodBuilder.GetILGenerator(), isStatic: true, isWriter: false, methodPairs, model, ilVersion, assemblyName, model.MapType(typeof(object)));
		compilerContext.LoadValue(compilerContext.InputValue);
		CodeLabel label = compilerContext.DefineLabel();
		compilerContext.BranchIfFalse(label, @short: true);
		compilerContext.LoadValue(compilerContext.InputValue);
		compilerContext.CastFromObject(valueType);
		compilerContext.LoadReaderWriter();
		compilerContext.EmitCall(deserialize);
		compilerContext.CastToObject(valueType);
		compilerContext.Return();
		compilerContext.MarkLabel(label);
		using Local local = new Local(compilerContext, valueType);
		compilerContext.LoadAddress(local, valueType);
		compilerContext.EmitCtor(valueType);
		compilerContext.LoadValue(local);
		compilerContext.LoadReaderWriter();
		compilerContext.EmitCall(deserialize);
		compilerContext.CastToObject(valueType);
		compilerContext.Return();
		return methodBuilder;
	}

	internal bool IsPrepared(Type type)
	{
		return FindWithoutAdd(type)?.IsPrepared() ?? false;
	}

	internal EnumSerializer.EnumPair[] GetEnumMap(Type type)
	{
		int num = FindOrAddAuto(type, demand: false, addWithContractOnly: false, addEvenIfAutoDisabled: false);
		if (num >= 0)
		{
			return ((MetaType)types[num]).GetEnumMap();
		}
		return null;
	}

	internal void TakeLock(ref int opaqueToken)
	{
		opaqueToken = 0;
		if (Monitor.TryEnter(types, metadataTimeoutMilliseconds))
		{
			opaqueToken = GetContention();
			return;
		}
		AddContention();
		throw new TimeoutException("Timeout while inspecting metadata; this may indicate a deadlock. This can often be avoided by preparing necessary serializers during application initialization, rather than allowing multiple threads to perform the initial metadata inspection; please also see the LockContended event");
	}

	private int GetContention()
	{
		lock (contentionLock)
		{
			return contentionCounter;
		}
	}

	private void AddContention()
	{
		lock (contentionLock)
		{
			contentionCounter++;
		}
	}

	internal void ReleaseLock(int opaqueToken)
	{
		if (opaqueToken == 0)
		{
			return;
		}
		Monitor.Exit(types);
		if (opaqueToken == GetContention())
		{
			return;
		}
		LockContentedEventHandler lockContended = this.LockContended;
		if (lockContended != null)
		{
			string stackTrace;
			try
			{
				throw new ProtoException();
			}
			catch (Exception ex)
			{
				stackTrace = ex.StackTrace;
			}
			lockContended(this, new LockContentedEventArgs(stackTrace));
		}
	}

	internal void ResolveListTypes(Type type, ref Type itemType, ref Type defaultType)
	{
		if ((object)type == null || Helpers.GetTypeCode(type) != ProtoTypeCode.Unknown || this[type].IgnoreListHandling)
		{
			return;
		}
		if (type.IsArray)
		{
			if (type.GetArrayRank() != 1)
			{
				throw new NotSupportedException("Multi-dimension arrays are supported");
			}
			itemType = type.GetElementType();
			if ((object)itemType == MapType(typeof(byte)))
			{
				defaultType = (itemType = null);
			}
			else
			{
				defaultType = type;
			}
		}
		if ((object)itemType == null)
		{
			itemType = TypeModel.GetListItemType(this, type);
		}
		if ((object)itemType != null)
		{
			Type itemType2 = null;
			Type defaultType2 = null;
			ResolveListTypes(itemType, ref itemType2, ref defaultType2);
			if ((object)itemType2 != null)
			{
				throw TypeModel.CreateNestedListsNotSupported();
			}
		}
		if ((object)itemType == null || (object)defaultType != null)
		{
			return;
		}
		if (type.IsClass && !type.IsAbstract && (object)Helpers.GetConstructor(type, Helpers.EmptyTypes, nonPublic: true) != null)
		{
			defaultType = type;
		}
		if ((object)defaultType == null && type.IsInterface)
		{
			Type[] genericArguments;
			if (type.IsGenericType && (object)type.GetGenericTypeDefinition() == MapType(typeof(IDictionary<, >)) && (object)itemType == MapType(typeof(KeyValuePair<, >)).MakeGenericType(genericArguments = type.GetGenericArguments()))
			{
				defaultType = MapType(typeof(Dictionary<, >)).MakeGenericType(genericArguments);
			}
			else
			{
				defaultType = MapType(typeof(List<>)).MakeGenericType(itemType);
			}
		}
		if ((object)defaultType != null && !Helpers.IsAssignableFrom(type, defaultType))
		{
			defaultType = null;
		}
	}

	internal string GetSchemaTypeName(Type effectiveType, DataFormat dataFormat, bool asReference, bool dynamicType, ref bool requiresBclImport)
	{
		Type underlyingType = Helpers.GetUnderlyingType(effectiveType);
		if ((object)underlyingType != null)
		{
			effectiveType = underlyingType;
		}
		if ((object)effectiveType == MapType(typeof(byte[])))
		{
			return "bytes";
		}
		WireType defaultWireType;
		IProtoSerializer protoSerializer = ValueMember.TryGetCoreSerializer(this, dataFormat, effectiveType, out defaultWireType, asReference: false, dynamicType: false, overwriteList: false, allowComplexTypes: false);
		if (protoSerializer == null)
		{
			if (asReference || dynamicType)
			{
				requiresBclImport = true;
				return "bcl.NetObjectProxy";
			}
			return this[effectiveType].GetSurrogateOrBaseOrSelf(deep: true).GetSchemaTypeName();
		}
		if (protoSerializer is ParseableSerializer)
		{
			if (asReference)
			{
				requiresBclImport = true;
			}
			if (!asReference)
			{
				return "string";
			}
			return "bcl.NetObjectProxy";
		}
		switch (Helpers.GetTypeCode(effectiveType))
		{
		case ProtoTypeCode.Boolean:
			return "bool";
		case ProtoTypeCode.Single:
			return "float";
		case ProtoTypeCode.Double:
			return "double";
		case ProtoTypeCode.String:
			if (asReference)
			{
				requiresBclImport = true;
			}
			if (!asReference)
			{
				return "string";
			}
			return "bcl.NetObjectProxy";
		case ProtoTypeCode.Char:
		case ProtoTypeCode.Byte:
		case ProtoTypeCode.UInt16:
		case ProtoTypeCode.UInt32:
			if (dataFormat == DataFormat.FixedSize)
			{
				return "fixed32";
			}
			return "uint32";
		case ProtoTypeCode.SByte:
		case ProtoTypeCode.Int16:
		case ProtoTypeCode.Int32:
			return dataFormat switch
			{
				DataFormat.ZigZag => "sint32", 
				DataFormat.FixedSize => "sfixed32", 
				_ => "int32", 
			};
		case ProtoTypeCode.UInt64:
			if (dataFormat == DataFormat.FixedSize)
			{
				return "fixed64";
			}
			return "uint64";
		case ProtoTypeCode.Int64:
			return dataFormat switch
			{
				DataFormat.ZigZag => "sint64", 
				DataFormat.FixedSize => "sfixed64", 
				_ => "int64", 
			};
		case ProtoTypeCode.DateTime:
			requiresBclImport = true;
			return "bcl.DateTime";
		case ProtoTypeCode.TimeSpan:
			requiresBclImport = true;
			return "bcl.TimeSpan";
		case ProtoTypeCode.Decimal:
			requiresBclImport = true;
			return "bcl.Decimal";
		case ProtoTypeCode.Guid:
			requiresBclImport = true;
			return "bcl.Guid";
		default:
			throw new NotSupportedException("No .proto map found for: " + effectiveType.FullName);
		}
	}

	public void SetDefaultFactory(MethodInfo methodInfo)
	{
		VerifyFactory(methodInfo, null);
		defaultFactory = methodInfo;
	}

	internal void VerifyFactory(MethodInfo factory, Type type)
	{
		if ((object)factory != null)
		{
			if ((object)type != null && Helpers.IsValueType(type))
			{
				throw new InvalidOperationException();
			}
			if (!factory.IsStatic)
			{
				throw new ArgumentException("A factory-method must be static", "factory");
			}
			if ((object)type != null && (object)factory.ReturnType != type && (object)factory.ReturnType != MapType(typeof(object)))
			{
				throw new ArgumentException("The factory-method must return object" + (((object)type == null) ? "" : (" or " + type.FullName)), "factory");
			}
			if (!CallbackSet.CheckCallbackParameters(this, factory))
			{
				throw new ArgumentException("Invalid factory signature in " + factory.DeclaringType.FullName + "." + factory.Name, "factory");
			}
		}
	}
}


private sealed class Singleton
{
	internal static readonly RuntimeTypeModel Value = new RuntimeTypeModel(isDefault: true);

	private Singleton()
	{
	}
}


using System;
using ProtoBuf.Serializers;

private sealed class BasicType
{
	private readonly Type type;

	private readonly IProtoSerializer serializer;

	public Type Type => type;

	public IProtoSerializer Serializer => serializer;

	public BasicType(Type type, IProtoSerializer serializer)
	{
		this.type = type;
		this.serializer = serializer;
	}
}


using System;
using System.Reflection.Emit;

internal sealed class SerializerPair : IComparable
{
	public readonly int MetaKey;

	public readonly int BaseKey;

	public readonly MetaType Type;

	public readonly MethodBuilder Serialize;

	public readonly MethodBuilder Deserialize;

	public readonly ILGenerator SerializeBody;

	public readonly ILGenerator DeserializeBody;

	int IComparable.CompareTo(object obj)
	{
		if (obj == null)
		{
			throw new ArgumentException("obj");
		}
		SerializerPair serializerPair = (SerializerPair)obj;
		if (BaseKey == MetaKey)
		{
			if (serializerPair.BaseKey == serializerPair.MetaKey)
			{
				int metaKey = MetaKey;
				return metaKey.CompareTo(serializerPair.MetaKey);
			}
			return 1;
		}
		if (serializerPair.BaseKey == serializerPair.MetaKey)
		{
			return -1;
		}
		int baseKey = BaseKey;
		int num = baseKey.CompareTo(serializerPair.BaseKey);
		if (num == 0)
		{
			int metaKey2 = MetaKey;
			num = metaKey2.CompareTo(serializerPair.MetaKey);
		}
		return num;
	}

	public SerializerPair(int metaKey, int baseKey, MetaType type, MethodBuilder serialize, MethodBuilder deserialize, ILGenerator serializeBody, ILGenerator deserializeBody)
	{
		MetaKey = metaKey;
		BaseKey = baseKey;
		Serialize = serialize;
		Deserialize = deserialize;
		SerializeBody = serializeBody;
		DeserializeBody = deserializeBody;
		Type = type;
	}
}


using System;

public sealed class CompilerOptions
{
	private string targetFrameworkName;

	private string targetFrameworkDisplayName;

	private string typeName;

	private string outputPath;

	private string imageRuntimeVersion;

	private int metaDataVersion;

	private Accessibility accessibility;

	public string TargetFrameworkName
	{
		get
		{
			return targetFrameworkName;
		}
		set
		{
			targetFrameworkName = value;
		}
	}

	public string TargetFrameworkDisplayName
	{
		get
		{
			return targetFrameworkDisplayName;
		}
		set
		{
			targetFrameworkDisplayName = value;
		}
	}

	public string TypeName
	{
		get
		{
			return typeName;
		}
		set
		{
			typeName = value;
		}
	}

	public string OutputPath
	{
		get
		{
			return outputPath;
		}
		set
		{
			outputPath = value;
		}
	}

	public string ImageRuntimeVersion
	{
		get
		{
			return imageRuntimeVersion;
		}
		set
		{
			imageRuntimeVersion = value;
		}
	}

	public int MetaDataVersion
	{
		get
		{
			return metaDataVersion;
		}
		set
		{
			metaDataVersion = value;
		}
	}

	public Accessibility Accessibility
	{
		get
		{
			return accessibility;
		}
		set
		{
			accessibility = value;
		}
	}

	public void SetFrameworkOptions(MetaType from)
	{
		if (from == null)
		{
			throw new ArgumentNullException("from");
		}
		AttributeMap[] array = AttributeMap.Create(from.Model, from.Type.Assembly);
		AttributeMap[] array2 = array;
		foreach (AttributeMap attributeMap in array2)
		{
			if (attributeMap.AttributeType.FullName == "System.Runtime.Versioning.TargetFrameworkAttribute")
			{
				if (attributeMap.TryGet("FrameworkName", out var value))
				{
					TargetFrameworkName = (string)value;
				}
				if (attributeMap.TryGet("FrameworkDisplayName", out value))
				{
					TargetFrameworkDisplayName = (string)value;
				}
				break;
			}
		}
	}
}


public enum Accessibility
{
	Public,
	Internal
}


using System;

public sealed class LockContentedEventArgs : EventArgs
{
	private readonly string ownerStackTrace;

	public string OwnerStackTrace => ownerStackTrace;

	internal LockContentedEventArgs(string ownerStackTrace)
	{
		this.ownerStackTrace = ownerStackTrace;
	}
}


using ProtoBuf.Meta;

public delegate void LockContentedEventHandler(object sender, LockContentedEventArgs args);


using System;
using System.Collections;
using System.Collections.Generic;
using ProtoBuf;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

public sealed class SubType
{
	internal sealed class Comparer : IComparer, IComparer<SubType>
	{
		public static readonly Comparer Default = new Comparer();

		public int Compare(object x, object y)
		{
			return Compare(x as SubType, y as SubType);
		}

		public int Compare(SubType x, SubType y)
		{
			if (object.ReferenceEquals(x, y))
			{
				return 0;
			}
			if (x == null)
			{
				return -1;
			}
			if (y == null)
			{
				return 1;
			}
			return x.FieldNumber.CompareTo(y.FieldNumber);
		}
	}

	private readonly int fieldNumber;

	private readonly MetaType derivedType;

	private readonly DataFormat dataFormat;

	private IProtoSerializer serializer;

	public int FieldNumber => fieldNumber;

	public MetaType DerivedType => derivedType;

	internal IProtoSerializer Serializer
	{
		get
		{
			if (serializer == null)
			{
				serializer = BuildSerializer();
			}
			return serializer;
		}
	}

	public SubType(int fieldNumber, MetaType derivedType, DataFormat format)
	{
		if (derivedType == null)
		{
			throw new ArgumentNullException("derivedType");
		}
		if (fieldNumber <= 0)
		{
			throw new ArgumentOutOfRangeException("fieldNumber");
		}
		this.fieldNumber = fieldNumber;
		this.derivedType = derivedType;
		dataFormat = format;
	}

	private IProtoSerializer BuildSerializer()
	{
		WireType wireType = WireType.String;
		if (dataFormat == DataFormat.Group)
		{
			wireType = WireType.StartGroup;
		}
		IProtoSerializer tail = new SubItemSerializer(derivedType.Type, derivedType.GetKey(demand: false, getBaseKey: false), derivedType, recursionCheck: false);
		return new TagDecorator(fieldNumber, wireType, strict: false, tail);
	}
}


using System.Collections;
using System.Collections.Generic;

internal sealed class Comparer : IComparer, IComparer<SubType>
{
	public static readonly Comparer Default = new Comparer();

	public int Compare(object x, object y)
	{
		return Compare(x as SubType, y as SubType);
	}

	public int Compare(SubType x, SubType y)
	{
		if (object.ReferenceEquals(x, y))
		{
			return 0;
		}
		if (x == null)
		{
			return -1;
		}
		if (y == null)
		{
			return 1;
		}
		return x.FieldNumber.CompareTo(y.FieldNumber);
	}
}


using System;
using ProtoBuf;

public class TypeFormatEventArgs : EventArgs
{
	private Type type;

	private string formattedName;

	private readonly bool typeFixed;

	public Type Type
	{
		get
		{
			return type;
		}
		set
		{
			if ((object)type != value)
			{
				if (typeFixed)
				{
					throw new InvalidOperationException("The type is fixed and cannot be changed");
				}
				type = value;
			}
		}
	}

	public string FormattedName
	{
		get
		{
			return formattedName;
		}
		set
		{
			if (formattedName != value)
			{
				if (!typeFixed)
				{
					throw new InvalidOperationException("The formatted-name is fixed and cannot be changed");
				}
				formattedName = value;
			}
		}
	}

	internal TypeFormatEventArgs(string formattedName)
	{
		if (Helpers.IsNullOrEmpty(formattedName))
		{
			throw new ArgumentNullException("formattedName");
		}
		this.formattedName = formattedName;
	}

	internal TypeFormatEventArgs(Type type)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		this.type = type;
		typeFixed = true;
	}
}


using ProtoBuf.Meta;

public delegate void TypeFormatEventHandler(object sender, TypeFormatEventArgs args);


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using ProtoBuf;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

public class ValueMember
{
	internal sealed class Comparer : IComparer, IComparer<ValueMember>
	{
		public static readonly Comparer Default = new Comparer();

		public int Compare(object x, object y)
		{
			return Compare(x as ValueMember, y as ValueMember);
		}

		public int Compare(ValueMember x, ValueMember y)
		{
			if (object.ReferenceEquals(x, y))
			{
				return 0;
			}
			if (x == null)
			{
				return -1;
			}
			if (y == null)
			{
				return 1;
			}
			return x.FieldNumber.CompareTo(y.FieldNumber);
		}
	}

	private const byte OPTIONS_IsStrict = 1;

	private const byte OPTIONS_IsPacked = 2;

	private const byte OPTIONS_IsRequired = 4;

	private const byte OPTIONS_OverwriteList = 8;

	private const byte OPTIONS_SupportNull = 16;

	private readonly int fieldNumber;

	private readonly MemberInfo member;

	private readonly Type parentType;

	private readonly Type itemType;

	private readonly Type defaultType;

	private readonly Type memberType;

	private object defaultValue;

	private readonly RuntimeTypeModel model;

	private IProtoSerializer serializer;

	private DataFormat dataFormat;

	private bool asReference;

	private bool dynamicType;

	private MethodInfo getSpecified;

	private MethodInfo setSpecified;

	private string name;

	private byte flags;

	public int FieldNumber => fieldNumber;

	public MemberInfo Member => member;

	public Type ItemType => itemType;

	public Type MemberType => memberType;

	public Type DefaultType => defaultType;

	public Type ParentType => parentType;

	public object DefaultValue
	{
		get
		{
			return defaultValue;
		}
		set
		{
			ThrowIfFrozen();
			defaultValue = value;
		}
	}

	internal IProtoSerializer Serializer
	{
		get
		{
			if (serializer == null)
			{
				serializer = BuildSerializer();
			}
			return serializer;
		}
	}

	public DataFormat DataFormat
	{
		get
		{
			return dataFormat;
		}
		set
		{
			ThrowIfFrozen();
			dataFormat = value;
		}
	}

	public bool IsStrict
	{
		get
		{
			return HasFlag(1);
		}
		set
		{
			SetFlag(1, value, throwIfFrozen: true);
		}
	}

	public bool IsPacked
	{
		get
		{
			return HasFlag(2);
		}
		set
		{
			SetFlag(2, value, throwIfFrozen: true);
		}
	}

	public bool OverwriteList
	{
		get
		{
			return HasFlag(8);
		}
		set
		{
			SetFlag(8, value, throwIfFrozen: true);
		}
	}

	public bool IsRequired
	{
		get
		{
			return HasFlag(4);
		}
		set
		{
			SetFlag(4, value, throwIfFrozen: true);
		}
	}

	public bool AsReference
	{
		get
		{
			return asReference;
		}
		set
		{
			ThrowIfFrozen();
			asReference = value;
		}
	}

	public bool DynamicType
	{
		get
		{
			return dynamicType;
		}
		set
		{
			ThrowIfFrozen();
			dynamicType = value;
		}
	}

	public string Name
	{
		get
		{
			if (!Helpers.IsNullOrEmpty(name))
			{
				return name;
			}
			return member.Name;
		}
	}

	public bool SupportNull
	{
		get
		{
			return HasFlag(16);
		}
		set
		{
			SetFlag(16, value, throwIfFrozen: true);
		}
	}

	public ValueMember(RuntimeTypeModel model, Type parentType, int fieldNumber, MemberInfo member, Type memberType, Type itemType, Type defaultType, DataFormat dataFormat, object defaultValue)
		: this(model, fieldNumber, memberType, itemType, defaultType, dataFormat)
	{
		if ((object)member == null)
		{
			throw new ArgumentNullException("member");
		}
		if ((object)parentType == null)
		{
			throw new ArgumentNullException("parentType");
		}
		if (fieldNumber < 1 && !Helpers.IsEnum(parentType))
		{
			throw new ArgumentOutOfRangeException("fieldNumber");
		}
		this.member = member;
		this.parentType = parentType;
		if (fieldNumber < 1 && !Helpers.IsEnum(parentType))
		{
			throw new ArgumentOutOfRangeException("fieldNumber");
		}
		if (defaultValue != null && (object)model.MapType(defaultValue.GetType()) != memberType)
		{
			defaultValue = ParseDefaultValue(memberType, defaultValue);
		}
		this.defaultValue = defaultValue;
		MetaType metaType = model.FindWithoutAdd(memberType);
		if (metaType != null)
		{
			asReference = metaType.AsReferenceDefault;
		}
		else
		{
			asReference = MetaType.GetAsReferenceDefault(model, memberType);
		}
	}

	internal ValueMember(RuntimeTypeModel model, int fieldNumber, Type memberType, Type itemType, Type defaultType, DataFormat dataFormat)
	{
		if ((object)memberType == null)
		{
			throw new ArgumentNullException("memberType");
		}
		if (model == null)
		{
			throw new ArgumentNullException("model");
		}
		this.fieldNumber = fieldNumber;
		this.memberType = memberType;
		this.itemType = itemType;
		this.defaultType = defaultType;
		this.model = model;
		this.dataFormat = dataFormat;
	}

	internal object GetRawEnumValue()
	{
		return ((FieldInfo)member).GetRawConstantValue();
	}

	private static object ParseDefaultValue(Type type, object value)
	{
		Type underlyingType = Helpers.GetUnderlyingType(type);
		if ((object)underlyingType != null)
		{
			type = underlyingType;
		}
		if (value is string)
		{
			string text = (string)value;
			if (Helpers.IsEnum(type))
			{
				return Helpers.ParseEnum(type, text);
			}
			switch (Helpers.GetTypeCode(type))
			{
			case ProtoTypeCode.Boolean:
				return bool.Parse(text);
			case ProtoTypeCode.Byte:
				return byte.Parse(text, NumberStyles.Integer, CultureInfo.InvariantCulture);
			case ProtoTypeCode.Char:
				if (text.Length == 1)
				{
					return text[0];
				}
				throw new FormatException("Single character expected: \"" + text + "\"");
			case ProtoTypeCode.DateTime:
				return DateTime.Parse(text, CultureInfo.InvariantCulture);
			case ProtoTypeCode.Decimal:
				return decimal.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
			case ProtoTypeCode.Double:
				return double.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
			case ProtoTypeCode.Int16:
				return short.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
			case ProtoTypeCode.Int32:
				return int.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
			case ProtoTypeCode.Int64:
				return long.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
			case ProtoTypeCode.SByte:
				return sbyte.Parse(text, NumberStyles.Integer, CultureInfo.InvariantCulture);
			case ProtoTypeCode.Single:
				return float.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
			case ProtoTypeCode.String:
				return text;
			case ProtoTypeCode.UInt16:
				return ushort.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
			case ProtoTypeCode.UInt32:
				return uint.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
			case ProtoTypeCode.UInt64:
				return ulong.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
			case ProtoTypeCode.TimeSpan:
				return TimeSpan.Parse(text);
			case ProtoTypeCode.Uri:
				return text;
			case ProtoTypeCode.Guid:
				return new Guid(text);
			}
		}
		if (Helpers.IsEnum(type))
		{
			return Enum.ToObject(type, value);
		}
		return Convert.ChangeType(value, type, CultureInfo.InvariantCulture);
	}

	public void SetSpecified(MethodInfo getSpecified, MethodInfo setSpecified)
	{
		if ((object)getSpecified != null && ((object)getSpecified.ReturnType != model.MapType(typeof(bool)) || getSpecified.IsStatic || getSpecified.GetParameters().Length != 0))
		{
			throw new ArgumentException("Invalid pattern for checking member-specified", "getSpecified");
		}
		ParameterInfo[] parameters;
		if ((object)setSpecified != null && ((object)setSpecified.ReturnType != model.MapType(typeof(void)) || setSpecified.IsStatic || (parameters = setSpecified.GetParameters()).Length != 1 || (object)parameters[0].ParameterType != model.MapType(typeof(bool))))
		{
			throw new ArgumentException("Invalid pattern for setting member-specified", "setSpecified");
		}
		ThrowIfFrozen();
		this.getSpecified = getSpecified;
		this.setSpecified = setSpecified;
	}

	private void ThrowIfFrozen()
	{
		if (serializer != null)
		{
			throw new InvalidOperationException("The type cannot be changed once a serializer has been generated");
		}
	}

	private IProtoSerializer BuildSerializer()
	{
		int opaqueToken = 0;
		try
		{
			model.TakeLock(ref opaqueToken);
			Type type = (((object)itemType == null) ? memberType : itemType);
			IProtoSerializer protoSerializer = TryGetCoreSerializer(model, dataFormat, type, out var defaultWireType, asReference, dynamicType, OverwriteList, allowComplexTypes: true);
			if (protoSerializer == null)
			{
				throw new InvalidOperationException("No serializer defined for type: " + type.FullName);
			}
			if ((object)itemType != null && SupportNull)
			{
				if (IsPacked)
				{
					throw new NotSupportedException("Packed encodings cannot support null values");
				}
				protoSerializer = new TagDecorator(1, defaultWireType, IsStrict, protoSerializer);
				protoSerializer = new NullDecorator(model, protoSerializer);
				protoSerializer = new TagDecorator(fieldNumber, WireType.StartGroup, strict: false, protoSerializer);
			}
			else
			{
				protoSerializer = new TagDecorator(fieldNumber, defaultWireType, IsStrict, protoSerializer);
			}
			if ((object)itemType != null)
			{
				if (!SupportNull)
				{
					Helpers.GetUnderlyingType(itemType);
				}
				protoSerializer = ((!memberType.IsArray) ? ((ProtoDecoratorBase)ListDecorator.Create(model, memberType, defaultType, protoSerializer, fieldNumber, IsPacked, defaultWireType, (object)member != null && PropertyDecorator.CanWrite(model, member), OverwriteList, SupportNull)) : ((ProtoDecoratorBase)new ArrayDecorator(model, protoSerializer, fieldNumber, IsPacked, defaultWireType, memberType, OverwriteList, SupportNull)));
			}
			else if (defaultValue != null && !IsRequired && (object)getSpecified == null)
			{
				protoSerializer = new DefaultValueDecorator(model, defaultValue, protoSerializer);
			}
			if ((object)memberType == model.MapType(typeof(Uri)))
			{
				protoSerializer = new UriDecorator(model, protoSerializer);
			}
			if ((object)member != null)
			{
				if (member is PropertyInfo)
				{
					protoSerializer = new PropertyDecorator(model, parentType, (PropertyInfo)member, protoSerializer);
				}
				else
				{
					if (!(member is FieldInfo))
					{
						throw new InvalidOperationException();
					}
					protoSerializer = new FieldDecorator(parentType, (FieldInfo)member, protoSerializer);
				}
				if ((object)getSpecified != null || (object)setSpecified != null)
				{
					protoSerializer = new MemberSpecifiedDecorator(getSpecified, setSpecified, protoSerializer);
				}
			}
			return protoSerializer;
		}
		finally
		{
			model.ReleaseLock(opaqueToken);
		}
	}

	private static WireType GetIntWireType(DataFormat format, int width)
	{
		switch (format)
		{
		case DataFormat.ZigZag:
			return WireType.SignedVariant;
		case DataFormat.FixedSize:
			if (width != 32)
			{
				return WireType.Fixed64;
			}
			return WireType.Fixed32;
		case DataFormat.Default:
		case DataFormat.TwosComplement:
			return WireType.Variant;
		default:
			throw new InvalidOperationException();
		}
	}

	private static WireType GetDateTimeWireType(DataFormat format)
	{
		return format switch
		{
			DataFormat.Group => WireType.StartGroup, 
			DataFormat.FixedSize => WireType.Fixed64, 
			DataFormat.Default => WireType.String, 
			_ => throw new InvalidOperationException(), 
		};
	}

	internal static IProtoSerializer TryGetCoreSerializer(RuntimeTypeModel model, DataFormat dataFormat, Type type, out WireType defaultWireType, bool asReference, bool dynamicType, bool overwriteList, bool allowComplexTypes)
	{
		Type underlyingType = Helpers.GetUnderlyingType(type);
		if ((object)underlyingType != null)
		{
			type = underlyingType;
		}
		if (Helpers.IsEnum(type))
		{
			if (allowComplexTypes && model != null)
			{
				defaultWireType = WireType.Variant;
				return new EnumSerializer(type, model.GetEnumMap(type));
			}
			defaultWireType = WireType.None;
			return null;
		}
		switch (Helpers.GetTypeCode(type))
		{
		case ProtoTypeCode.Int32:
			defaultWireType = GetIntWireType(dataFormat, 32);
			return new Int32Serializer(model);
		case ProtoTypeCode.UInt32:
			defaultWireType = GetIntWireType(dataFormat, 32);
			return new UInt32Serializer(model);
		case ProtoTypeCode.Int64:
			defaultWireType = GetIntWireType(dataFormat, 64);
			return new Int64Serializer(model);
		case ProtoTypeCode.UInt64:
			defaultWireType = GetIntWireType(dataFormat, 64);
			return new UInt64Serializer(model);
		case ProtoTypeCode.String:
			defaultWireType = WireType.String;
			if (asReference)
			{
				return new NetObjectSerializer(model, model.MapType(typeof(string)), 0, BclHelpers.NetObjectOptions.AsReference);
			}
			return new StringSerializer(model);
		case ProtoTypeCode.Single:
			defaultWireType = WireType.Fixed32;
			return new SingleSerializer(model);
		case ProtoTypeCode.Double:
			defaultWireType = WireType.Fixed64;
			return new DoubleSerializer(model);
		case ProtoTypeCode.Boolean:
			defaultWireType = WireType.Variant;
			return new BooleanSerializer(model);
		case ProtoTypeCode.DateTime:
			defaultWireType = GetDateTimeWireType(dataFormat);
			return new DateTimeSerializer(model);
		case ProtoTypeCode.Decimal:
			defaultWireType = WireType.String;
			return new DecimalSerializer(model);
		case ProtoTypeCode.Byte:
			defaultWireType = GetIntWireType(dataFormat, 32);
			return new ByteSerializer(model);
		case ProtoTypeCode.SByte:
			defaultWireType = GetIntWireType(dataFormat, 32);
			return new SByteSerializer(model);
		case ProtoTypeCode.Char:
			defaultWireType = WireType.Variant;
			return new CharSerializer(model);
		case ProtoTypeCode.Int16:
			defaultWireType = GetIntWireType(dataFormat, 32);
			return new Int16Serializer(model);
		case ProtoTypeCode.UInt16:
			defaultWireType = GetIntWireType(dataFormat, 32);
			return new UInt16Serializer(model);
		case ProtoTypeCode.TimeSpan:
			defaultWireType = GetDateTimeWireType(dataFormat);
			return new TimeSpanSerializer(model);
		case ProtoTypeCode.Guid:
			defaultWireType = WireType.String;
			return new GuidSerializer(model);
		case ProtoTypeCode.Uri:
			defaultWireType = WireType.String;
			return new StringSerializer(model);
		case ProtoTypeCode.ByteArray:
			defaultWireType = WireType.String;
			return new BlobSerializer(model, overwriteList);
		case ProtoTypeCode.Type:
			defaultWireType = WireType.String;
			return new SystemTypeSerializer(model);
		default:
		{
			IProtoSerializer protoSerializer = (model.AllowParseableTypes ? ParseableSerializer.TryCreate(type, model) : null);
			if (protoSerializer != null)
			{
				defaultWireType = WireType.String;
				return protoSerializer;
			}
			if (allowComplexTypes && model != null)
			{
				int key = model.GetKey(type, demand: false, getBaseKey: true);
				if (asReference || dynamicType)
				{
					defaultWireType = ((dataFormat == DataFormat.Group) ? WireType.StartGroup : WireType.String);
					BclHelpers.NetObjectOptions netObjectOptions = BclHelpers.NetObjectOptions.None;
					if (asReference)
					{
						netObjectOptions |= BclHelpers.NetObjectOptions.AsReference;
					}
					if (dynamicType)
					{
						netObjectOptions |= BclHelpers.NetObjectOptions.DynamicType;
					}
					if (key >= 0)
					{
						if (asReference && Helpers.IsValueType(type))
						{
							string text = "AsReference cannot be used with value-types";
							text = ((!(type.Name == "KeyValuePair`2")) ? (text + ": " + type.FullName) : (text + "; please see http://stackoverflow.com/q/14436606/"));
							throw new InvalidOperationException(text);
						}
						MetaType metaType = model[type];
						if (asReference && metaType.IsAutoTuple)
						{
							netObjectOptions |= BclHelpers.NetObjectOptions.LateSet;
						}
						if (metaType.UseConstructor)
						{
							netObjectOptions |= BclHelpers.NetObjectOptions.UseConstructor;
						}
					}
					return new NetObjectSerializer(model, type, key, netObjectOptions);
				}
				if (key >= 0)
				{
					defaultWireType = ((dataFormat == DataFormat.Group) ? WireType.StartGroup : WireType.String);
					return new SubItemSerializer(type, key, model[type], recursionCheck: true);
				}
			}
			defaultWireType = WireType.None;
			return null;
		}
		}
	}

	internal void SetName(string name)
	{
		ThrowIfFrozen();
		this.name = name;
	}

	private bool HasFlag(byte flag)
	{
		return (flags & flag) == flag;
	}

	private void SetFlag(byte flag, bool value, bool throwIfFrozen)
	{
		if (throwIfFrozen && HasFlag(flag) != value)
		{
			ThrowIfFrozen();
		}
		if (value)
		{
			flags |= flag;
		}
		else
		{
			flags = (byte)(flags & ~flag);
		}
	}

	internal string GetSchemaTypeName(bool applyNetObjectProxy, ref bool requiresBclImport)
	{
		Type type = ItemType;
		if ((object)type == null)
		{
			type = MemberType;
		}
		return model.GetSchemaTypeName(type, DataFormat, applyNetObjectProxy && asReference, applyNetObjectProxy && dynamicType, ref requiresBclImport);
	}
}


using System.Collections;
using System.Collections.Generic;

internal sealed class Comparer : IComparer, IComparer<ValueMember>
{
	public static readonly Comparer Default = new Comparer();

	public int Compare(object x, object y)
	{
		return Compare(x as ValueMember, y as ValueMember);
	}

	public int Compare(ValueMember x, ValueMember y)
	{
		if (object.ReferenceEquals(x, y))
		{
			return 0;
		}
		if (x == null)
		{
			return -1;
		}
		if (y == null)
		{
			return 1;
		}
		return x.FieldNumber.CompareTo(y.FieldNumber);
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using ProtoBuf;
using ProtoBuf.Meta;

internal sealed class NetObjectCache
{
	private sealed class ReferenceComparer : IEqualityComparer<object>
	{
		public static readonly ReferenceComparer Default = new ReferenceComparer();

		private ReferenceComparer()
		{
		}

		bool IEqualityComparer<object>.Equals(object x, object y)
		{
			return x == y;
		}

		int IEqualityComparer<object>.GetHashCode(object obj)
		{
			return RuntimeHelpers.GetHashCode(obj);
		}
	}

	internal const int Root = 0;

	private MutableList underlyingList;

	private object rootObject;

	private int trapStartIndex;

	private Dictionary<string, int> stringKeys;

	private Dictionary<object, int> objectKeys;

	private MutableList List
	{
		get
		{
			if (underlyingList == null)
			{
				underlyingList = new MutableList();
			}
			return underlyingList;
		}
	}

	internal object GetKeyedObject(int key)
	{
		if (key-- == 0)
		{
			if (rootObject == null)
			{
				throw new ProtoException("No root object assigned");
			}
			return rootObject;
		}
		BasicList list = List;
		if (key < 0 || key >= list.Count)
		{
			throw new ProtoException("Internal error; a missing key occurred");
		}
		object obj = list[key];
		if (obj == null)
		{
			throw new ProtoException("A deferred key does not have a value yet");
		}
		return obj;
	}

	internal void SetKeyedObject(int key, object value)
	{
		if (key-- == 0)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (rootObject != null && rootObject != value)
			{
				throw new ProtoException("The root object cannot be reassigned");
			}
			rootObject = value;
			return;
		}
		MutableList list = List;
		if (key < list.Count)
		{
			object obj = list[key];
			if (obj == null)
			{
				list[key] = value;
			}
			else if (!object.ReferenceEquals(obj, value))
			{
				throw new ProtoException("Reference-tracked objects cannot change reference");
			}
		}
		else if (key != list.Add(value))
		{
			throw new ProtoException("Internal error; a key mismatch occurred");
		}
	}

	internal int AddObjectKey(object value, out bool existing)
	{
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		if (value == rootObject)
		{
			existing = true;
			return 0;
		}
		string text = value as string;
		BasicList list = List;
		int value2;
		if (text == null)
		{
			if (objectKeys == null)
			{
				objectKeys = new Dictionary<object, int>(ReferenceComparer.Default);
				value2 = -1;
			}
			else if (!objectKeys.TryGetValue(value, out value2))
			{
				value2 = -1;
			}
		}
		else if (stringKeys == null)
		{
			stringKeys = new Dictionary<string, int>();
			value2 = -1;
		}
		else if (!stringKeys.TryGetValue(text, out value2))
		{
			value2 = -1;
		}
		if (!(existing = value2 >= 0))
		{
			value2 = list.Add(value);
			if (text == null)
			{
				objectKeys.Add(value, value2);
			}
			else
			{
				stringKeys.Add(text, value2);
			}
		}
		return value2 + 1;
	}

	internal void RegisterTrappedObject(object value)
	{
		if (rootObject == null)
		{
			rootObject = value;
		}
		else
		{
			if (underlyingList == null)
			{
				return;
			}
			for (int i = trapStartIndex; i < underlyingList.Count; i++)
			{
				trapStartIndex = i + 1;
				if (underlyingList[i] == null)
				{
					underlyingList[i] = value;
					break;
				}
			}
		}
	}

	internal void Clear()
	{
		trapStartIndex = 0;
		rootObject = null;
		if (underlyingList != null)
		{
			underlyingList.Clear();
		}
		if (stringKeys != null)
		{
			stringKeys.Clear();
		}
		if (objectKeys != null)
		{
			objectKeys.Clear();
		}
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;

private sealed class ReferenceComparer : IEqualityComparer<object>
{
	public static readonly ReferenceComparer Default = new ReferenceComparer();

	private ReferenceComparer()
	{
	}

	bool IEqualityComparer<object>.Equals(object x, object y)
	{
		return x == y;
	}

	int IEqualityComparer<object>.GetHashCode(object obj)
	{
		return RuntimeHelpers.GetHashCode(obj);
	}
}


public enum PrefixStyle
{
	None,
	Base128,
	Fixed32,
	Fixed32BigEndian
}


using System;
using ProtoBuf;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
public sealed class ProtoContractAttribute : Attribute
{
	private const byte OPTIONS_InferTagFromName = 1;

	private const byte OPTIONS_InferTagFromNameHasValue = 2;

	private const byte OPTIONS_UseProtoMembersOnly = 4;

	private const byte OPTIONS_SkipConstructor = 8;

	private const byte OPTIONS_IgnoreListHandling = 16;

	private const byte OPTIONS_AsReferenceDefault = 32;

	private const byte OPTIONS_EnumPassthru = 64;

	private const byte OPTIONS_EnumPassthruHasValue = 128;

	private string name;

	private int implicitFirstTag;

	private ImplicitFields implicitFields;

	private int dataMemberOffset;

	private byte flags;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public int ImplicitFirstTag
	{
		get
		{
			return implicitFirstTag;
		}
		set
		{
			if (value < 1)
			{
				throw new ArgumentOutOfRangeException("ImplicitFirstTag");
			}
			implicitFirstTag = value;
		}
	}

	public bool UseProtoMembersOnly
	{
		get
		{
			return HasFlag(4);
		}
		set
		{
			SetFlag(4, value);
		}
	}

	public bool IgnoreListHandling
	{
		get
		{
			return HasFlag(16);
		}
		set
		{
			SetFlag(16, value);
		}
	}

	public ImplicitFields ImplicitFields
	{
		get
		{
			return implicitFields;
		}
		set
		{
			implicitFields = value;
		}
	}

	public bool InferTagFromName
	{
		get
		{
			return HasFlag(1);
		}
		set
		{
			SetFlag(1, value);
			SetFlag(2, value: true);
		}
	}

	internal bool InferTagFromNameHasValue => HasFlag(2);

	public int DataMemberOffset
	{
		get
		{
			return dataMemberOffset;
		}
		set
		{
			dataMemberOffset = value;
		}
	}

	public bool SkipConstructor
	{
		get
		{
			return HasFlag(8);
		}
		set
		{
			SetFlag(8, value);
		}
	}

	public bool AsReferenceDefault
	{
		get
		{
			return HasFlag(32);
		}
		set
		{
			SetFlag(32, value);
		}
	}

	public bool EnumPassthru
	{
		get
		{
			return HasFlag(64);
		}
		set
		{
			SetFlag(64, value);
			SetFlag(128, value: true);
		}
	}

	internal bool EnumPassthruHasValue => HasFlag(128);

	private bool HasFlag(byte flag)
	{
		return (flags & flag) == flag;
	}

	private void SetFlag(byte flag, bool value)
	{
		if (value)
		{
			flags |= flag;
		}
		else
		{
			flags = (byte)(flags & ~flag);
		}
	}
}


using System;

[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
public sealed class ProtoEnumAttribute : Attribute
{
	private bool hasValue;

	private int enumValue;

	private string name;

	public int Value
	{
		get
		{
			return enumValue;
		}
		set
		{
			enumValue = value;
			hasValue = true;
		}
	}

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public bool HasValue()
	{
		return hasValue;
	}
}


using System;
using System.Runtime.Serialization;

[Serializable]
public class ProtoException : Exception
{
	public ProtoException()
	{
	}

	public ProtoException(string message)
		: base(message)
	{
	}

	public ProtoException(string message, Exception innerException)
		: base(message, innerException)
	{
	}

	protected ProtoException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
public class ProtoIgnoreAttribute : Attribute
{
}


using System;
using ProtoBuf;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
public sealed class ProtoPartialIgnoreAttribute : ProtoIgnoreAttribute
{
	private readonly string memberName;

	public string MemberName => memberName;

	public ProtoPartialIgnoreAttribute(string memberName)
	{
		if (Helpers.IsNullOrEmpty(memberName))
		{
			throw new ArgumentNullException("memberName");
		}
		this.memberName = memberName;
	}
}


using System;
using System.ComponentModel;
using ProtoBuf;
using ProtoBuf.Meta;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = true, Inherited = false)]
public sealed class ProtoIncludeAttribute : Attribute
{
	private readonly int tag;

	private readonly string knownTypeName;

	private DataFormat dataFormat;

	public int Tag => tag;

	public string KnownTypeName => knownTypeName;

	public Type KnownType => TypeModel.ResolveKnownType(KnownTypeName, null, null);

	[DefaultValue(DataFormat.Default)]
	public DataFormat DataFormat
	{
		get
		{
			return dataFormat;
		}
		set
		{
			dataFormat = value;
		}
	}

	public ProtoIncludeAttribute(int tag, Type knownType)
		: this(tag, ((object)knownType == null) ? "" : knownType.AssemblyQualifiedName)
	{
	}

	public ProtoIncludeAttribute(int tag, string knownTypeName)
	{
		if (tag <= 0)
		{
			throw new ArgumentOutOfRangeException("tag", "Tags must be positive integers");
		}
		if (Helpers.IsNullOrEmpty(knownTypeName))
		{
			throw new ArgumentNullException("knownTypeName", "Known type cannot be blank");
		}
		this.tag = tag;
		this.knownTypeName = knownTypeName;
	}
}


using System;
using System.Reflection;
using ProtoBuf;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
public class ProtoMemberAttribute : Attribute, IComparable, IComparable<ProtoMemberAttribute>
{
	internal MemberInfo Member;

	internal bool TagIsPinned;

	private string name;

	private DataFormat dataFormat;

	private int tag;

	private MemberSerializationOptions options;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public DataFormat DataFormat
	{
		get
		{
			return dataFormat;
		}
		set
		{
			dataFormat = value;
		}
	}

	public int Tag => tag;

	public bool IsRequired
	{
		get
		{
			return (options & MemberSerializationOptions.Required) == MemberSerializationOptions.Required;
		}
		set
		{
			if (value)
			{
				options |= MemberSerializationOptions.Required;
			}
			else
			{
				options &= ~MemberSerializationOptions.Required;
			}
		}
	}

	public bool IsPacked
	{
		get
		{
			return (options & MemberSerializationOptions.Packed) == MemberSerializationOptions.Packed;
		}
		set
		{
			if (value)
			{
				options |= MemberSerializationOptions.Packed;
			}
			else
			{
				options &= ~MemberSerializationOptions.Packed;
			}
		}
	}

	public bool OverwriteList
	{
		get
		{
			return (options & MemberSerializationOptions.OverwriteList) == MemberSerializationOptions.OverwriteList;
		}
		set
		{
			if (value)
			{
				options |= MemberSerializationOptions.OverwriteList;
			}
			else
			{
				options &= ~MemberSerializationOptions.OverwriteList;
			}
		}
	}

	public bool AsReference
	{
		get
		{
			return (options & MemberSerializationOptions.AsReference) == MemberSerializationOptions.AsReference;
		}
		set
		{
			if (value)
			{
				options |= MemberSerializationOptions.AsReference;
			}
			else
			{
				options &= ~MemberSerializationOptions.AsReference;
			}
			options |= MemberSerializationOptions.AsReferenceHasValue;
		}
	}

	internal bool AsReferenceHasValue
	{
		get
		{
			return (options & MemberSerializationOptions.AsReferenceHasValue) == MemberSerializationOptions.AsReferenceHasValue;
		}
		set
		{
			if (value)
			{
				options |= MemberSerializationOptions.AsReferenceHasValue;
			}
			else
			{
				options &= ~MemberSerializationOptions.AsReferenceHasValue;
			}
		}
	}

	public bool DynamicType
	{
		get
		{
			return (options & MemberSerializationOptions.DynamicType) == MemberSerializationOptions.DynamicType;
		}
		set
		{
			if (value)
			{
				options |= MemberSerializationOptions.DynamicType;
			}
			else
			{
				options &= ~MemberSerializationOptions.DynamicType;
			}
		}
	}

	public MemberSerializationOptions Options
	{
		get
		{
			return options;
		}
		set
		{
			options = value;
		}
	}

	public int CompareTo(object other)
	{
		return CompareTo(other as ProtoMemberAttribute);
	}

	public int CompareTo(ProtoMemberAttribute other)
	{
		if (other == null)
		{
			return -1;
		}
		if (this == other)
		{
			return 0;
		}
		int num = tag.CompareTo(other.tag);
		if (num == 0)
		{
			num = string.CompareOrdinal(name, other.name);
		}
		return num;
	}

	public ProtoMemberAttribute(int tag)
		: this(tag, forced: false)
	{
	}

	internal ProtoMemberAttribute(int tag, bool forced)
	{
		if (tag <= 0 && !forced)
		{
			throw new ArgumentOutOfRangeException("tag");
		}
		this.tag = tag;
	}

	internal void Rebase(int tag)
	{
		this.tag = tag;
	}
}


using System;

[Flags]
public enum MemberSerializationOptions
{
	None = 0,
	Packed = 1,
	Required = 2,
	AsReference = 4,
	DynamicType = 8,
	OverwriteList = 0x10,
	AsReferenceHasValue = 0x20
}


using System;
using ProtoBuf;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
public sealed class ProtoPartialMemberAttribute : ProtoMemberAttribute
{
	private readonly string memberName;

	public string MemberName => memberName;

	public ProtoPartialMemberAttribute(int tag, string memberName)
		: base(tag)
	{
		if (Helpers.IsNullOrEmpty(memberName))
		{
			throw new ArgumentNullException("memberName");
		}
		this.memberName = memberName;
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using ProtoBuf;
using ProtoBuf.Meta;

public sealed class ProtoReader : IDisposable
{
	internal const int TO_EOF = -1;

	private const long Int64Msb = long.MinValue;

	private const int Int32Msb = int.MinValue;

	private Stream source;

	private byte[] ioBuffer;

	private TypeModel model;

	private int fieldNumber;

	private int depth;

	private int dataRemaining;

	private int ioIndex;

	private int position;

	private int available;

	private int blockEnd;

	private WireType wireType;

	private bool isFixedLength;

	private bool internStrings;

	private NetObjectCache netCache;

	private uint trapCount;

	private SerializationContext context;

	private Dictionary<string, string> stringInterner;

	private static readonly UTF8Encoding encoding = new UTF8Encoding();

	private static readonly byte[] EmptyBlob = new byte[0];

	[ThreadStatic]
	private static ProtoReader lastReader;

	public int FieldNumber => fieldNumber;

	public WireType WireType => wireType;

	public bool InternStrings
	{
		get
		{
			return internStrings;
		}
		set
		{
			internStrings = value;
		}
	}

	public SerializationContext Context => context;

	public int Position => position;

	public TypeModel Model => model;

	internal NetObjectCache NetCache => netCache;

	public ProtoReader(Stream source, TypeModel model, SerializationContext context)
	{
		Init(this, source, model, context, -1);
	}

	public ProtoReader(Stream source, TypeModel model, SerializationContext context, int length)
	{
		Init(this, source, model, context, length);
	}

	private static void Init(ProtoReader reader, Stream source, TypeModel model, SerializationContext context, int length)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		if (!source.CanRead)
		{
			throw new ArgumentException("Cannot read from stream", "source");
		}
		reader.source = source;
		reader.ioBuffer = BufferPool.GetBuffer();
		reader.model = model;
		reader.dataRemaining = ((reader.isFixedLength = length >= 0) ? length : 0);
		if (context == null)
		{
			context = SerializationContext.Default;
		}
		else
		{
			context.Freeze();
		}
		reader.context = context;
		reader.position = (reader.available = (reader.depth = (reader.fieldNumber = (reader.ioIndex = 0))));
		reader.blockEnd = int.MaxValue;
		reader.internStrings = true;
		reader.wireType = WireType.None;
		reader.trapCount = 1u;
		if (reader.netCache == null)
		{
			reader.netCache = new NetObjectCache();
		}
	}

	public void Dispose()
	{
		source = null;
		model = null;
		BufferPool.ReleaseBufferToPool(ref ioBuffer);
		if (stringInterner != null)
		{
			stringInterner.Clear();
		}
		if (netCache != null)
		{
			netCache.Clear();
		}
	}

	internal int TryReadUInt32VariantWithoutMoving(bool trimNegative, out uint value)
	{
		if (available < 10)
		{
			Ensure(10, strict: false);
		}
		if (available == 0)
		{
			value = 0u;
			return 0;
		}
		int num = ioIndex;
		value = ioBuffer[num++];
		if ((value & 0x80) == 0)
		{
			return 1;
		}
		value &= 127u;
		if (available == 1)
		{
			throw EoF(this);
		}
		uint num2 = ioBuffer[num++];
		value |= (num2 & 0x7F) << 7;
		if ((num2 & 0x80) == 0)
		{
			return 2;
		}
		if (available == 2)
		{
			throw EoF(this);
		}
		num2 = ioBuffer[num++];
		value |= (num2 & 0x7F) << 14;
		if ((num2 & 0x80) == 0)
		{
			return 3;
		}
		if (available == 3)
		{
			throw EoF(this);
		}
		num2 = ioBuffer[num++];
		value |= (num2 & 0x7F) << 21;
		if ((num2 & 0x80) == 0)
		{
			return 4;
		}
		if (available == 4)
		{
			throw EoF(this);
		}
		num2 = ioBuffer[num];
		value |= num2 << 28;
		if ((num2 & 0xF0) == 0)
		{
			return 5;
		}
		if (trimNegative && (num2 & 0xF0) == 240 && available >= 10 && ioBuffer[++num] == byte.MaxValue && ioBuffer[++num] == byte.MaxValue && ioBuffer[++num] == byte.MaxValue && ioBuffer[++num] == byte.MaxValue && ioBuffer[++num] == 1)
		{
			return 10;
		}
		throw AddErrorData(new OverflowException(), this);
	}

	private uint ReadUInt32Variant(bool trimNegative)
	{
		uint value;
		int num = TryReadUInt32VariantWithoutMoving(trimNegative, out value);
		if (num > 0)
		{
			ioIndex += num;
			available -= num;
			position += num;
			return value;
		}
		throw EoF(this);
	}

	private bool TryReadUInt32Variant(out uint value)
	{
		int num = TryReadUInt32VariantWithoutMoving(trimNegative: false, out value);
		if (num > 0)
		{
			ioIndex += num;
			available -= num;
			position += num;
			return true;
		}
		return false;
	}

	public uint ReadUInt32()
	{
		switch (wireType)
		{
		case WireType.Variant:
			return ReadUInt32Variant(trimNegative: false);
		case WireType.Fixed32:
			if (available < 4)
			{
				Ensure(4, strict: true);
			}
			position += 4;
			available -= 4;
			return (uint)(ioBuffer[ioIndex++] | (ioBuffer[ioIndex++] << 8) | (ioBuffer[ioIndex++] << 16) | (ioBuffer[ioIndex++] << 24));
		case WireType.Fixed64:
		{
			ulong num = ReadUInt64();
			return checked((uint)num);
		}
		default:
			throw CreateWireTypeException();
		}
	}

	internal void Ensure(int count, bool strict)
	{
		if (count > ioBuffer.Length)
		{
			BufferPool.ResizeAndFlushLeft(ref ioBuffer, count, ioIndex, available);
			ioIndex = 0;
		}
		else if (ioIndex + count >= ioBuffer.Length)
		{
			Helpers.BlockCopy(ioBuffer, ioIndex, ioBuffer, 0, available);
			ioIndex = 0;
		}
		count -= available;
		int num = ioIndex + available;
		int num2 = ioBuffer.Length - num;
		if (isFixedLength && dataRemaining < num2)
		{
			num2 = dataRemaining;
		}
		int num3;
		while (count > 0 && num2 > 0 && (num3 = source.Read(ioBuffer, num, num2)) > 0)
		{
			available += num3;
			count -= num3;
			num2 -= num3;
			num += num3;
			if (isFixedLength)
			{
				dataRemaining -= num3;
			}
		}
		if (strict && count > 0)
		{
			throw EoF(this);
		}
	}

	public short ReadInt16()
	{
		return checked((short)ReadInt32());
	}

	public ushort ReadUInt16()
	{
		return checked((ushort)ReadUInt32());
	}

	public byte ReadByte()
	{
		return checked((byte)ReadUInt32());
	}

	public sbyte ReadSByte()
	{
		return checked((sbyte)ReadInt32());
	}

	public int ReadInt32()
	{
		switch (wireType)
		{
		case WireType.Variant:
			return (int)ReadUInt32Variant(trimNegative: true);
		case WireType.Fixed32:
			if (available < 4)
			{
				Ensure(4, strict: true);
			}
			position += 4;
			available -= 4;
			return ioBuffer[ioIndex++] | (ioBuffer[ioIndex++] << 8) | (ioBuffer[ioIndex++] << 16) | (ioBuffer[ioIndex++] << 24);
		case WireType.Fixed64:
		{
			long num = ReadInt64();
			return checked((int)num);
		}
		case WireType.SignedVariant:
			return Zag(ReadUInt32Variant(trimNegative: true));
		default:
			throw CreateWireTypeException();
		}
	}

	private static int Zag(uint ziggedValue)
	{
		return (int)(0 - (ziggedValue & 1)) ^ (((int)ziggedValue >> 1) & 0x7FFFFFFF);
	}

	private static long Zag(ulong ziggedValue)
	{
		return (long)(0L - (ziggedValue & 1)) ^ (((long)ziggedValue >> 1) & 0x7FFFFFFFFFFFFFFFL);
	}

	public long ReadInt64()
	{
		switch (wireType)
		{
		case WireType.Variant:
			return (long)ReadUInt64Variant();
		case WireType.Fixed32:
			return ReadInt32();
		case WireType.Fixed64:
			if (available < 8)
			{
				Ensure(8, strict: true);
			}
			position += 8;
			available -= 8;
			return (long)(ioBuffer[ioIndex++] | ((ulong)ioBuffer[ioIndex++] << 8) | ((ulong)ioBuffer[ioIndex++] << 16) | ((ulong)ioBuffer[ioIndex++] << 24) | ((ulong)ioBuffer[ioIndex++] << 32) | ((ulong)ioBuffer[ioIndex++] << 40) | ((ulong)ioBuffer[ioIndex++] << 48) | ((ulong)ioBuffer[ioIndex++] << 56));
		case WireType.SignedVariant:
			return Zag(ReadUInt64Variant());
		default:
			throw CreateWireTypeException();
		}
	}

	private int TryReadUInt64VariantWithoutMoving(out ulong value)
	{
		if (available < 10)
		{
			Ensure(10, strict: false);
		}
		if (available == 0)
		{
			value = 0uL;
			return 0;
		}
		int num = ioIndex;
		value = ioBuffer[num++];
		if ((value & 0x80) == 0)
		{
			return 1;
		}
		value &= 127uL;
		if (available == 1)
		{
			throw EoF(this);
		}
		ulong num2 = ioBuffer[num++];
		value |= (num2 & 0x7F) << 7;
		if ((num2 & 0x80) == 0)
		{
			return 2;
		}
		if (available == 2)
		{
			throw EoF(this);
		}
		num2 = ioBuffer[num++];
		value |= (num2 & 0x7F) << 14;
		if ((num2 & 0x80) == 0)
		{
			return 3;
		}
		if (available == 3)
		{
			throw EoF(this);
		}
		num2 = ioBuffer[num++];
		value |= (num2 & 0x7F) << 21;
		if ((num2 & 0x80) == 0)
		{
			return 4;
		}
		if (available == 4)
		{
			throw EoF(this);
		}
		num2 = ioBuffer[num++];
		value |= (num2 & 0x7F) << 28;
		if ((num2 & 0x80) == 0)
		{
			return 5;
		}
		if (available == 5)
		{
			throw EoF(this);
		}
		num2 = ioBuffer[num++];
		value |= (num2 & 0x7F) << 35;
		if ((num2 & 0x80) == 0)
		{
			return 6;
		}
		if (available == 6)
		{
			throw EoF(this);
		}
		num2 = ioBuffer[num++];
		value |= (num2 & 0x7F) << 42;
		if ((num2 & 0x80) == 0)
		{
			return 7;
		}
		if (available == 7)
		{
			throw EoF(this);
		}
		num2 = ioBuffer[num++];
		value |= (num2 & 0x7F) << 49;
		if ((num2 & 0x80) == 0)
		{
			return 8;
		}
		if (available == 8)
		{
			throw EoF(this);
		}
		num2 = ioBuffer[num++];
		value |= (num2 & 0x7F) << 56;
		if ((num2 & 0x80) == 0)
		{
			return 9;
		}
		if (available == 9)
		{
			throw EoF(this);
		}
		num2 = ioBuffer[num];
		value |= num2 << 63;
		if ((num2 & 0xFFFFFFFFFFFFFFFEuL) != 0)
		{
			throw AddErrorData(new OverflowException(), this);
		}
		return 10;
	}

	private ulong ReadUInt64Variant()
	{
		ulong value;
		int num = TryReadUInt64VariantWithoutMoving(out value);
		if (num > 0)
		{
			ioIndex += num;
			available -= num;
			position += num;
			return value;
		}
		throw EoF(this);
	}

	private string Intern(string value)
	{
		if (value == null)
		{
			return null;
		}
		if (value.Length == 0)
		{
			return "";
		}
		string value2;
		if (stringInterner == null)
		{
			stringInterner = new Dictionary<string, string>();
			stringInterner.Add(value, value);
		}
		else if (stringInterner.TryGetValue(value, out value2))
		{
			value = value2;
		}
		else
		{
			stringInterner.Add(value, value);
		}
		return value;
	}

	public string ReadString()
	{
		if (wireType == WireType.String)
		{
			int num = (int)ReadUInt32Variant(trimNegative: false);
			if (num == 0)
			{
				return "";
			}
			if (available < num)
			{
				Ensure(num, strict: true);
			}
			string text = encoding.GetString(ioBuffer, ioIndex, num);
			if (internStrings)
			{
				text = Intern(text);
			}
			available -= num;
			position += num;
			ioIndex += num;
			return text;
		}
		throw CreateWireTypeException();
	}

	public void ThrowEnumException(Type type, int value)
	{
		string text = (((object)type == null) ? "<null>" : type.FullName);
		throw AddErrorData(new ProtoException("No " + text + " enum is mapped to the wire-value " + value), this);
	}

	private Exception CreateWireTypeException()
	{
		return CreateException("Invalid wire-type; this usually means you have over-written a file without truncating or setting the length; see http://stackoverflow.com/q/2152978/23354");
	}

	private Exception CreateException(string message)
	{
		return AddErrorData(new ProtoException(message), this);
	}

	public double ReadDouble()
	{
		switch (wireType)
		{
		case WireType.Fixed32:
			return ReadSingle();
		case WireType.Fixed64:
		{
			long value = ReadInt64();
			return BitConverter.ToDouble(BitConverter.GetBytes(value), 0);
		}
		default:
			throw CreateWireTypeException();
		}
	}

	public static object ReadObject(object value, int key, ProtoReader reader)
	{
		return ReadTypedObject(value, key, reader, null);
	}

	internal static object ReadTypedObject(object value, int key, ProtoReader reader, Type type)
	{
		if (reader.model == null)
		{
			throw AddErrorData(new InvalidOperationException("Cannot deserialize sub-objects unless a model is provided"), reader);
		}
		SubItemToken token = StartSubItem(reader);
		if (key >= 0)
		{
			value = reader.model.Deserialize(key, value, reader);
		}
		else if ((object)type == null || !reader.model.TryDeserializeAuxiliaryType(reader, DataFormat.Default, 1, type, ref value, skipOtherFields: true, asListItem: false, autoCreate: true, insideList: false))
		{
			TypeModel.ThrowUnexpectedType(type);
		}
		EndSubItem(token, reader);
		return value;
	}

	public static void EndSubItem(SubItemToken token, ProtoReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		int value = token.value;
		WireType wireType = reader.wireType;
		if (wireType == WireType.EndGroup)
		{
			if (value >= 0)
			{
				throw AddErrorData(new ArgumentException("token"), reader);
			}
			if (-value != reader.fieldNumber)
			{
				throw reader.CreateException("Wrong group was ended");
			}
			reader.wireType = WireType.None;
			reader.depth--;
		}
		else
		{
			if (value < reader.position)
			{
				throw reader.CreateException("Sub-message not read entirely");
			}
			if (reader.blockEnd != reader.position && reader.blockEnd != int.MaxValue)
			{
				throw reader.CreateException("Sub-message not read correctly");
			}
			reader.blockEnd = value;
			reader.depth--;
		}
	}

	public static SubItemToken StartSubItem(ProtoReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		switch (reader.wireType)
		{
		case WireType.StartGroup:
			reader.wireType = WireType.None;
			reader.depth++;
			return new SubItemToken(-reader.fieldNumber);
		case WireType.String:
		{
			int num = (int)reader.ReadUInt32Variant(trimNegative: false);
			if (num < 0)
			{
				throw AddErrorData(new InvalidOperationException(), reader);
			}
			int value = reader.blockEnd;
			reader.blockEnd = reader.position + num;
			reader.depth++;
			return new SubItemToken(value);
		}
		default:
			throw reader.CreateWireTypeException();
		}
	}

	public int ReadFieldHeader()
	{
		if (blockEnd <= position || wireType == WireType.EndGroup)
		{
			return 0;
		}
		if (TryReadUInt32Variant(out var value))
		{
			wireType = (WireType)(value & 7);
			fieldNumber = (int)(value >> 3);
			if (fieldNumber < 1)
			{
				throw new ProtoException("Invalid field in source data: " + fieldNumber);
			}
		}
		else
		{
			wireType = WireType.None;
			fieldNumber = 0;
		}
		if (wireType == WireType.EndGroup)
		{
			if (depth > 0)
			{
				return 0;
			}
			throw new ProtoException("Unexpected end-group in source data; this usually means the source data is corrupt");
		}
		return fieldNumber;
	}

	public bool TryReadFieldHeader(int field)
	{
		if (blockEnd <= position || this.wireType == WireType.EndGroup)
		{
			return false;
		}
		uint value;
		int num = TryReadUInt32VariantWithoutMoving(trimNegative: false, out value);
		WireType wireType;
		if (num > 0 && (int)value >> 3 == field && (wireType = (WireType)(value & 7)) != WireType.EndGroup)
		{
			this.wireType = wireType;
			fieldNumber = field;
			position += num;
			ioIndex += num;
			available -= num;
			return true;
		}
		return false;
	}

	public void Hint(WireType wireType)
	{
		if (this.wireType != wireType && (wireType & (WireType)7) == this.wireType)
		{
			this.wireType = wireType;
		}
	}

	public void Assert(WireType wireType)
	{
		if (this.wireType != wireType)
		{
			if ((wireType & (WireType)7) != this.wireType)
			{
				throw CreateWireTypeException();
			}
			this.wireType = wireType;
		}
	}

	public void SkipField()
	{
		switch (wireType)
		{
		case WireType.Fixed32:
			if (available < 4)
			{
				Ensure(4, strict: true);
			}
			available -= 4;
			ioIndex += 4;
			position += 4;
			break;
		case WireType.Fixed64:
			if (available < 8)
			{
				Ensure(8, strict: true);
			}
			available -= 8;
			ioIndex += 8;
			position += 8;
			break;
		case WireType.String:
		{
			int num2 = (int)ReadUInt32Variant(trimNegative: false);
			if (num2 <= available)
			{
				available -= num2;
				ioIndex += num2;
				position += num2;
				break;
			}
			position += num2;
			num2 -= available;
			ioIndex = (available = 0);
			if (isFixedLength)
			{
				if (num2 > dataRemaining)
				{
					throw EoF(this);
				}
				dataRemaining -= num2;
			}
			Seek(source, num2, ioBuffer);
			break;
		}
		case WireType.Variant:
		case WireType.SignedVariant:
			ReadUInt64Variant();
			break;
		case WireType.StartGroup:
		{
			int num = fieldNumber;
			depth++;
			while (ReadFieldHeader() > 0)
			{
				SkipField();
			}
			depth--;
			if (wireType == WireType.EndGroup && fieldNumber == num)
			{
				wireType = WireType.None;
				break;
			}
			throw CreateWireTypeException();
		}
		default:
			throw CreateWireTypeException();
		}
	}

	public ulong ReadUInt64()
	{
		switch (wireType)
		{
		case WireType.Variant:
			return ReadUInt64Variant();
		case WireType.Fixed32:
			return ReadUInt32();
		case WireType.Fixed64:
			if (available < 8)
			{
				Ensure(8, strict: true);
			}
			position += 8;
			available -= 8;
			return ioBuffer[ioIndex++] | ((ulong)ioBuffer[ioIndex++] << 8) | ((ulong)ioBuffer[ioIndex++] << 16) | ((ulong)ioBuffer[ioIndex++] << 24) | ((ulong)ioBuffer[ioIndex++] << 32) | ((ulong)ioBuffer[ioIndex++] << 40) | ((ulong)ioBuffer[ioIndex++] << 48) | ((ulong)ioBuffer[ioIndex++] << 56);
		default:
			throw CreateWireTypeException();
		}
	}

	public float ReadSingle()
	{
		switch (wireType)
		{
		case WireType.Fixed32:
		{
			int value = ReadInt32();
			return BitConverter.ToSingle(BitConverter.GetBytes(value), 0);
		}
		case WireType.Fixed64:
		{
			double num = ReadDouble();
			float num2 = (float)num;
			if (Helpers.IsInfinity(num2) && !Helpers.IsInfinity(num))
			{
				throw AddErrorData(new OverflowException(), this);
			}
			return num2;
		}
		default:
			throw CreateWireTypeException();
		}
	}

	public bool ReadBoolean()
	{
		return ReadUInt32() switch
		{
			0u => false, 
			1u => true, 
			_ => throw CreateException("Unexpected boolean value"), 
		};
	}

	public static byte[] AppendBytes(byte[] value, ProtoReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		WireType wireType = reader.wireType;
		if (wireType == WireType.String)
		{
			int num = (int)reader.ReadUInt32Variant(trimNegative: false);
			reader.wireType = WireType.None;
			if (num == 0)
			{
				if (value != null)
				{
					return value;
				}
				return EmptyBlob;
			}
			int num2;
			if (value == null || value.Length == 0)
			{
				num2 = 0;
				value = new byte[num];
			}
			else
			{
				num2 = value.Length;
				byte[] array = new byte[value.Length + num];
				Helpers.BlockCopy(value, 0, array, 0, value.Length);
				value = array;
			}
			reader.position += num;
			while (num > reader.available)
			{
				if (reader.available > 0)
				{
					Helpers.BlockCopy(reader.ioBuffer, reader.ioIndex, value, num2, reader.available);
					num -= reader.available;
					num2 += reader.available;
					reader.ioIndex = (reader.available = 0);
				}
				int num3 = ((num > reader.ioBuffer.Length) ? reader.ioBuffer.Length : num);
				if (num3 > 0)
				{
					reader.Ensure(num3, strict: true);
				}
			}
			if (num > 0)
			{
				Helpers.BlockCopy(reader.ioBuffer, reader.ioIndex, value, num2, num);
				reader.ioIndex += num;
				reader.available -= num;
			}
			return value;
		}
		throw reader.CreateWireTypeException();
	}

	private static int ReadByteOrThrow(Stream source)
	{
		int num = source.ReadByte();
		if (num < 0)
		{
			throw EoF(null);
		}
		return num;
	}

	public static int ReadLengthPrefix(Stream source, bool expectHeader, PrefixStyle style, out int fieldNumber)
	{
		int bytesRead;
		return ReadLengthPrefix(source, expectHeader, style, out fieldNumber, out bytesRead);
	}

	public static int DirectReadLittleEndianInt32(Stream source)
	{
		return ReadByteOrThrow(source) | (ReadByteOrThrow(source) << 8) | (ReadByteOrThrow(source) << 16) | (ReadByteOrThrow(source) << 24);
	}

	public static int DirectReadBigEndianInt32(Stream source)
	{
		return (ReadByteOrThrow(source) << 24) | (ReadByteOrThrow(source) << 16) | (ReadByteOrThrow(source) << 8) | ReadByteOrThrow(source);
	}

	public static int DirectReadVarintInt32(Stream source)
	{
		uint value;
		int num = TryReadUInt32Variant(source, out value);
		if (num <= 0)
		{
			throw EoF(null);
		}
		return (int)value;
	}

	public static void DirectReadBytes(Stream source, byte[] buffer, int offset, int count)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		int num;
		while (count > 0 && (num = source.Read(buffer, offset, count)) > 0)
		{
			count -= num;
			offset += num;
		}
		if (count > 0)
		{
			throw EoF(null);
		}
	}

	public static byte[] DirectReadBytes(Stream source, int count)
	{
		byte[] array = new byte[count];
		DirectReadBytes(source, array, 0, count);
		return array;
	}

	public static string DirectReadString(Stream source, int length)
	{
		byte[] array = new byte[length];
		DirectReadBytes(source, array, 0, length);
		return Encoding.UTF8.GetString(array, 0, length);
	}

	public static int ReadLengthPrefix(Stream source, bool expectHeader, PrefixStyle style, out int fieldNumber, out int bytesRead)
	{
		fieldNumber = 0;
		switch (style)
		{
		case PrefixStyle.None:
			bytesRead = 0;
			return int.MaxValue;
		case PrefixStyle.Base128:
		{
			bytesRead = 0;
			uint value;
			int num2;
			if (expectHeader)
			{
				num2 = TryReadUInt32Variant(source, out value);
				bytesRead += num2;
				if (num2 > 0)
				{
					if ((value & 7) != 2)
					{
						throw new InvalidOperationException();
					}
					fieldNumber = (int)(value >> 3);
					num2 = TryReadUInt32Variant(source, out value);
					bytesRead += num2;
					if (bytesRead == 0)
					{
						throw EoF(null);
					}
					return (int)value;
				}
				bytesRead = 0;
				return -1;
			}
			num2 = TryReadUInt32Variant(source, out value);
			bytesRead += num2;
			if (bytesRead >= 0)
			{
				return (int)value;
			}
			return -1;
		}
		case PrefixStyle.Fixed32:
		{
			int num3 = source.ReadByte();
			if (num3 < 0)
			{
				bytesRead = 0;
				return -1;
			}
			bytesRead = 4;
			return num3 | (ReadByteOrThrow(source) << 8) | (ReadByteOrThrow(source) << 16) | (ReadByteOrThrow(source) << 24);
		}
		case PrefixStyle.Fixed32BigEndian:
		{
			int num = source.ReadByte();
			if (num < 0)
			{
				bytesRead = 0;
				return -1;
			}
			bytesRead = 4;
			return (num << 24) | (ReadByteOrThrow(source) << 16) | (ReadByteOrThrow(source) << 8) | ReadByteOrThrow(source);
		}
		default:
			throw new ArgumentOutOfRangeException("style");
		}
	}

	private static int TryReadUInt32Variant(Stream source, out uint value)
	{
		value = 0u;
		int num = source.ReadByte();
		if (num < 0)
		{
			return 0;
		}
		value = (uint)num;
		if ((value & 0x80) == 0)
		{
			return 1;
		}
		value &= 127u;
		num = source.ReadByte();
		if (num < 0)
		{
			throw EoF(null);
		}
		value |= (uint)((num & 0x7F) << 7);
		if ((num & 0x80) == 0)
		{
			return 2;
		}
		num = source.ReadByte();
		if (num < 0)
		{
			throw EoF(null);
		}
		value |= (uint)((num & 0x7F) << 14);
		if ((num & 0x80) == 0)
		{
			return 3;
		}
		num = source.ReadByte();
		if (num < 0)
		{
			throw EoF(null);
		}
		value |= (uint)((num & 0x7F) << 21);
		if ((num & 0x80) == 0)
		{
			return 4;
		}
		num = source.ReadByte();
		if (num < 0)
		{
			throw EoF(null);
		}
		value |= (uint)(num << 28);
		if ((num & 0xF0) == 0)
		{
			return 5;
		}
		throw new OverflowException();
	}

	internal static void Seek(Stream source, int count, byte[] buffer)
	{
		if (source.CanSeek)
		{
			source.Seek(count, SeekOrigin.Current);
			count = 0;
		}
		else if (buffer != null)
		{
			int num;
			while (count > buffer.Length && (num = source.Read(buffer, 0, buffer.Length)) > 0)
			{
				count -= num;
			}
			while (count > 0 && (num = source.Read(buffer, 0, count)) > 0)
			{
				count -= num;
			}
		}
		else
		{
			buffer = BufferPool.GetBuffer();
			try
			{
				int num2;
				while (count > buffer.Length && (num2 = source.Read(buffer, 0, buffer.Length)) > 0)
				{
					count -= num2;
				}
				while (count > 0 && (num2 = source.Read(buffer, 0, count)) > 0)
				{
					count -= num2;
				}
			}
			finally
			{
				BufferPool.ReleaseBufferToPool(ref buffer);
			}
		}
		if (count > 0)
		{
			throw EoF(null);
		}
	}

	internal static Exception AddErrorData(Exception exception, ProtoReader source)
	{
		if (exception != null && source != null && !exception.Data.Contains("protoSource"))
		{
			exception.Data.Add("protoSource", $"tag={source.fieldNumber}; wire-type={source.wireType}; offset={source.position}; depth={source.depth}");
		}
		return exception;
	}

	private static Exception EoF(ProtoReader source)
	{
		return AddErrorData(new EndOfStreamException(), source);
	}

	public void AppendExtensionData(IExtensible instance)
	{
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		IExtension extensionObject = instance.GetExtensionObject(createIfMissing: true);
		bool commit = false;
		Stream stream = extensionObject.BeginAppend();
		try
		{
			using (ProtoWriter protoWriter = new ProtoWriter(stream, model, null))
			{
				AppendExtensionField(protoWriter);
				protoWriter.Close();
			}
			commit = true;
		}
		finally
		{
			extensionObject.EndAppend(stream, commit);
		}
	}

	private void AppendExtensionField(ProtoWriter writer)
	{
		ProtoWriter.WriteFieldHeader(fieldNumber, wireType, writer);
		switch (wireType)
		{
		case WireType.Fixed32:
			ProtoWriter.WriteInt32(ReadInt32(), writer);
			break;
		case WireType.Variant:
		case WireType.Fixed64:
		case WireType.SignedVariant:
			ProtoWriter.WriteInt64(ReadInt64(), writer);
			break;
		case WireType.String:
			ProtoWriter.WriteBytes(AppendBytes(null, this), writer);
			break;
		case WireType.StartGroup:
		{
			SubItemToken token = StartSubItem(this);
			SubItemToken token2 = ProtoWriter.StartSubItem(null, writer);
			while (ReadFieldHeader() > 0)
			{
				AppendExtensionField(writer);
			}
			EndSubItem(token, this);
			ProtoWriter.EndSubItem(token2, writer);
			break;
		}
		default:
			throw CreateWireTypeException();
		}
	}

	public static bool HasSubValue(WireType wireType, ProtoReader source)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		if (source.blockEnd <= source.position || wireType == WireType.EndGroup)
		{
			return false;
		}
		source.wireType = wireType;
		return true;
	}

	internal int GetTypeKey(ref Type type)
	{
		return model.GetKey(ref type);
	}

	internal Type DeserializeType(string value)
	{
		return TypeModel.DeserializeType(model, value);
	}

	internal void SetRootObject(object value)
	{
		netCache.SetKeyedObject(0, value);
		trapCount--;
	}

	public static void NoteObject(object value, ProtoReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		if (reader.trapCount != 0)
		{
			reader.netCache.RegisterTrappedObject(value);
			reader.trapCount--;
		}
	}

	public Type ReadType()
	{
		return TypeModel.DeserializeType(model, ReadString());
	}

	internal void TrapNextObject(int newObjectKey)
	{
		trapCount++;
		netCache.SetKeyedObject(newObjectKey, null);
	}

	internal void CheckFullyConsumed()
	{
		if (isFixedLength)
		{
			if (dataRemaining != 0)
			{
				throw new ProtoException("Incorrect number of bytes consumed");
			}
		}
		else if (available != 0)
		{
			throw new ProtoException("Unconsumed data left in the buffer; this suggests corrupt input");
		}
	}

	public static object Merge(ProtoReader parent, object from, object to)
	{
		if (parent == null)
		{
			throw new ArgumentNullException("parent");
		}
		TypeModel typeModel = parent.Model;
		SerializationContext serializationContext = parent.Context;
		if (typeModel == null)
		{
			throw new InvalidOperationException("Types cannot be merged unless a type-model has been specified");
		}
		using MemoryStream memoryStream = new MemoryStream();
		typeModel.Serialize(memoryStream, from, serializationContext);
		memoryStream.Position = 0L;
		return typeModel.Deserialize(memoryStream, to, null);
	}

	internal static ProtoReader Create(Stream source, TypeModel model, SerializationContext context, int len)
	{
		ProtoReader recycled = GetRecycled();
		if (recycled == null)
		{
			return new ProtoReader(source, model, context, len);
		}
		Init(recycled, source, model, context, len);
		return recycled;
	}

	private static ProtoReader GetRecycled()
	{
		ProtoReader result = lastReader;
		lastReader = null;
		return result;
	}

	internal static void Recycle(ProtoReader reader)
	{
		if (reader != null)
		{
			reader.Dispose();
			lastReader = reader;
		}
	}
}


using System;
using System.IO;
using System.Text;
using ProtoBuf;
using ProtoBuf.Meta;

public sealed class ProtoWriter : IDisposable
{
	private const int RecursionCheckDepth = 25;

	private Stream dest;

	private TypeModel model;

	private readonly NetObjectCache netCache = new NetObjectCache();

	private int fieldNumber;

	private int flushLock;

	private WireType wireType;

	private int depth;

	private MutableList recursionStack;

	private readonly SerializationContext context;

	private byte[] ioBuffer;

	private int ioIndex;

	private int position;

	private static readonly UTF8Encoding encoding = new UTF8Encoding();

	private int packedFieldNumber;

	internal NetObjectCache NetCache => netCache;

	internal WireType WireType => wireType;

	public SerializationContext Context => context;

	public TypeModel Model => model;

	public static void WriteObject(object value, int key, ProtoWriter writer)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		if (writer.model == null)
		{
			throw new InvalidOperationException("Cannot serialize sub-objects unless a model is provided");
		}
		SubItemToken token = StartSubItem(value, writer);
		if (key >= 0)
		{
			writer.model.Serialize(key, value, writer);
		}
		else if (writer.model == null || !writer.model.TrySerializeAuxiliaryType(writer, value.GetType(), DataFormat.Default, 1, value, isInsideList: false))
		{
			TypeModel.ThrowUnexpectedType(value.GetType());
		}
		EndSubItem(token, writer);
	}

	public static void WriteRecursionSafeObject(object value, int key, ProtoWriter writer)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		if (writer.model == null)
		{
			throw new InvalidOperationException("Cannot serialize sub-objects unless a model is provided");
		}
		SubItemToken token = StartSubItem(null, writer);
		writer.model.Serialize(key, value, writer);
		EndSubItem(token, writer);
	}

	internal static void WriteObject(object value, int key, ProtoWriter writer, PrefixStyle style, int fieldNumber)
	{
		if (writer.model == null)
		{
			throw new InvalidOperationException("Cannot serialize sub-objects unless a model is provided");
		}
		if (writer.wireType != WireType.None)
		{
			throw CreateException(writer);
		}
		switch (style)
		{
		case PrefixStyle.Base128:
			writer.wireType = WireType.String;
			writer.fieldNumber = fieldNumber;
			if (fieldNumber > 0)
			{
				WriteHeaderCore(fieldNumber, WireType.String, writer);
			}
			break;
		case PrefixStyle.Fixed32:
		case PrefixStyle.Fixed32BigEndian:
			writer.fieldNumber = 0;
			writer.wireType = WireType.Fixed32;
			break;
		default:
			throw new ArgumentOutOfRangeException("style");
		}
		SubItemToken token = StartSubItem(value, writer, allowFixed: true);
		if (key < 0)
		{
			if (!writer.model.TrySerializeAuxiliaryType(writer, value.GetType(), DataFormat.Default, 1, value, isInsideList: false))
			{
				TypeModel.ThrowUnexpectedType(value.GetType());
			}
		}
		else
		{
			writer.model.Serialize(key, value, writer);
		}
		EndSubItem(token, writer, style);
	}

	internal int GetTypeKey(ref Type type)
	{
		return model.GetKey(ref type);
	}

	public static void WriteFieldHeader(int fieldNumber, WireType wireType, ProtoWriter writer)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		if (writer.wireType != WireType.None)
		{
			throw new InvalidOperationException("Cannot write a " + wireType.ToString() + " header until the " + writer.wireType.ToString() + " data has been written");
		}
		if (fieldNumber < 0)
		{
			throw new ArgumentOutOfRangeException("fieldNumber");
		}
		if (writer.packedFieldNumber == 0)
		{
			writer.fieldNumber = fieldNumber;
			writer.wireType = wireType;
			WriteHeaderCore(fieldNumber, wireType, writer);
			return;
		}
		if (writer.packedFieldNumber == fieldNumber)
		{
			switch (wireType)
			{
			default:
				throw new InvalidOperationException("Wire-type cannot be encoded as packed: " + wireType);
			case WireType.Variant:
			case WireType.Fixed64:
			case WireType.Fixed32:
			case WireType.SignedVariant:
				writer.fieldNumber = fieldNumber;
				writer.wireType = wireType;
				break;
			}
			return;
		}
		throw new InvalidOperationException("Field mismatch during packed encoding; expected " + writer.packedFieldNumber + " but received " + fieldNumber);
	}

	internal static void WriteHeaderCore(int fieldNumber, WireType wireType, ProtoWriter writer)
	{
		uint value = (uint)(fieldNumber << 3) | (uint)(wireType & (WireType)7);
		WriteUInt32Variant(value, writer);
	}

	public static void WriteBytes(byte[] data, ProtoWriter writer)
	{
		if (data == null)
		{
			throw new ArgumentNullException("data");
		}
		WriteBytes(data, 0, data.Length, writer);
	}

	public static void WriteBytes(byte[] data, int offset, int length, ProtoWriter writer)
	{
		if (data == null)
		{
			throw new ArgumentNullException("data");
		}
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		switch (writer.wireType)
		{
		case WireType.Fixed32:
			if (length != 4)
			{
				throw new ArgumentException("length");
			}
			break;
		case WireType.Fixed64:
			if (length != 8)
			{
				throw new ArgumentException("length");
			}
			break;
		case WireType.String:
			WriteUInt32Variant((uint)length, writer);
			writer.wireType = WireType.None;
			if (length == 0)
			{
				return;
			}
			if (writer.flushLock == 0 && length > writer.ioBuffer.Length)
			{
				Flush(writer);
				writer.dest.Write(data, offset, length);
				writer.position += length;
				return;
			}
			break;
		default:
			throw CreateException(writer);
		}
		DemandSpace(length, writer);
		Helpers.BlockCopy(data, offset, writer.ioBuffer, writer.ioIndex, length);
		IncrementedAndReset(length, writer);
	}

	private static void CopyRawFromStream(Stream source, ProtoWriter writer)
	{
		byte[] array = writer.ioBuffer;
		int num = array.Length - writer.ioIndex;
		int num2 = 1;
		while (num > 0 && (num2 = source.Read(array, writer.ioIndex, num)) > 0)
		{
			writer.ioIndex += num2;
			writer.position += num2;
			num -= num2;
		}
		if (num2 <= 0)
		{
			return;
		}
		if (writer.flushLock == 0)
		{
			Flush(writer);
			while ((num2 = source.Read(array, 0, array.Length)) > 0)
			{
				writer.dest.Write(array, 0, num2);
				writer.position += num2;
			}
			return;
		}
		while (true)
		{
			DemandSpace(128, writer);
			if ((num2 = source.Read(writer.ioBuffer, writer.ioIndex, writer.ioBuffer.Length - writer.ioIndex)) <= 0)
			{
				break;
			}
			writer.position += num2;
			writer.ioIndex += num2;
		}
	}

	private static void IncrementedAndReset(int length, ProtoWriter writer)
	{
		writer.ioIndex += length;
		writer.position += length;
		writer.wireType = WireType.None;
	}

	public static SubItemToken StartSubItem(object instance, ProtoWriter writer)
	{
		return StartSubItem(instance, writer, allowFixed: false);
	}

	private void CheckRecursionStackAndPush(object instance)
	{
		int num;
		if (recursionStack == null)
		{
			recursionStack = new MutableList();
		}
		else if (instance != null && (num = recursionStack.IndexOfReference(instance)) >= 0)
		{
			throw new ProtoException("Possible recursion detected (offset: " + (recursionStack.Count - num) + " level(s)): " + instance.ToString());
		}
		recursionStack.Add(instance);
	}

	private void PopRecursionStack()
	{
		recursionStack.RemoveLast();
	}

	private static SubItemToken StartSubItem(object instance, ProtoWriter writer, bool allowFixed)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		if (++writer.depth > 25)
		{
			writer.CheckRecursionStackAndPush(instance);
		}
		if (writer.packedFieldNumber != 0)
		{
			throw new InvalidOperationException("Cannot begin a sub-item while performing packed encoding");
		}
		switch (writer.wireType)
		{
		case WireType.StartGroup:
			writer.wireType = WireType.None;
			return new SubItemToken(-writer.fieldNumber);
		case WireType.String:
			writer.wireType = WireType.None;
			DemandSpace(32, writer);
			writer.flushLock++;
			writer.position++;
			return new SubItemToken(writer.ioIndex++);
		case WireType.Fixed32:
		{
			if (!allowFixed)
			{
				throw CreateException(writer);
			}
			DemandSpace(32, writer);
			writer.flushLock++;
			SubItemToken result = new SubItemToken(writer.ioIndex);
			IncrementedAndReset(4, writer);
			return result;
		}
		default:
			throw CreateException(writer);
		}
	}

	public static void EndSubItem(SubItemToken token, ProtoWriter writer)
	{
		EndSubItem(token, writer, PrefixStyle.Base128);
	}

	private static void EndSubItem(SubItemToken token, ProtoWriter writer, PrefixStyle style)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		if (writer.wireType != WireType.None)
		{
			throw CreateException(writer);
		}
		int value = token.value;
		if (writer.depth <= 0)
		{
			throw CreateException(writer);
		}
		if (writer.depth-- > 25)
		{
			writer.PopRecursionStack();
		}
		writer.packedFieldNumber = 0;
		if (value < 0)
		{
			WriteHeaderCore(-value, WireType.EndGroup, writer);
			writer.wireType = WireType.None;
			return;
		}
		switch (style)
		{
		case PrefixStyle.Fixed32:
		{
			int num = writer.ioIndex - value - 4;
			WriteInt32ToBuffer(num, writer.ioBuffer, value);
			break;
		}
		case PrefixStyle.Fixed32BigEndian:
		{
			int num = writer.ioIndex - value - 4;
			byte[] array2 = writer.ioBuffer;
			WriteInt32ToBuffer(num, array2, value);
			byte b = array2[value];
			array2[value] = array2[value + 3];
			array2[value + 3] = b;
			b = array2[value + 1];
			array2[value + 1] = array2[value + 2];
			array2[value + 2] = b;
			break;
		}
		case PrefixStyle.Base128:
		{
			int num = writer.ioIndex - value - 1;
			int num2 = 0;
			uint num3 = (uint)num;
			while ((num3 >>= 7) != 0)
			{
				num2++;
			}
			if (num2 == 0)
			{
				writer.ioBuffer[value] = (byte)(num & 0x7F);
				break;
			}
			DemandSpace(num2, writer);
			byte[] array = writer.ioBuffer;
			Helpers.BlockCopy(array, value + 1, array, value + 1 + num2, num);
			num3 = (uint)num;
			do
			{
				array[value++] = (byte)((num3 & 0x7F) | 0x80);
			}
			while ((num3 >>= 7) != 0);
			array[value - 1] = (byte)(array[value - 1] & -129);
			writer.position += num2;
			writer.ioIndex += num2;
			break;
		}
		default:
			throw new ArgumentOutOfRangeException("style");
		}
		if (--writer.flushLock == 0 && writer.ioIndex >= 1024)
		{
			Flush(writer);
		}
	}

	public ProtoWriter(Stream dest, TypeModel model, SerializationContext context)
	{
		if (dest == null)
		{
			throw new ArgumentNullException("dest");
		}
		if (!dest.CanWrite)
		{
			throw new ArgumentException("Cannot write to stream", "dest");
		}
		this.dest = dest;
		ioBuffer = BufferPool.GetBuffer();
		this.model = model;
		wireType = WireType.None;
		if (context == null)
		{
			context = SerializationContext.Default;
		}
		else
		{
			context.Freeze();
		}
		this.context = context;
	}

	void IDisposable.Dispose()
	{
		Dispose();
	}

	private void Dispose()
	{
		if (dest != null)
		{
			Flush(this);
			dest = null;
		}
		model = null;
		BufferPool.ReleaseBufferToPool(ref ioBuffer);
	}

	internal static int GetPosition(ProtoWriter writer)
	{
		return writer.position;
	}

	private static void DemandSpace(int required, ProtoWriter writer)
	{
		if (writer.ioBuffer.Length - writer.ioIndex >= required)
		{
			return;
		}
		if (writer.flushLock == 0)
		{
			Flush(writer);
			if (writer.ioBuffer.Length - writer.ioIndex >= required)
			{
				return;
			}
		}
		BufferPool.ResizeAndFlushLeft(ref writer.ioBuffer, required + writer.ioIndex, 0, writer.ioIndex);
	}

	public void Close()
	{
		if (depth != 0 || flushLock != 0)
		{
			throw new InvalidOperationException("Unable to close stream in an incomplete state");
		}
		Dispose();
	}

	internal void CheckDepthFlushlock()
	{
		if (depth != 0 || flushLock != 0)
		{
			throw new InvalidOperationException("The writer is in an incomplete state");
		}
	}

	internal static void Flush(ProtoWriter writer)
	{
		if (writer.flushLock == 0 && writer.ioIndex != 0)
		{
			writer.dest.Write(writer.ioBuffer, 0, writer.ioIndex);
			writer.ioIndex = 0;
		}
	}

	private static void WriteUInt32Variant(uint value, ProtoWriter writer)
	{
		DemandSpace(5, writer);
		int num = 0;
		do
		{
			writer.ioBuffer[writer.ioIndex++] = (byte)((value & 0x7F) | 0x80);
			num++;
		}
		while ((value >>= 7) != 0);
		writer.ioBuffer[writer.ioIndex - 1] &= 127;
		writer.position += num;
	}

	internal static uint Zig(int value)
	{
		return (uint)((value << 1) ^ (value >> 31));
	}

	internal static ulong Zig(long value)
	{
		return (ulong)((value << 1) ^ (value >> 63));
	}

	private static void WriteUInt64Variant(ulong value, ProtoWriter writer)
	{
		DemandSpace(10, writer);
		int num = 0;
		do
		{
			writer.ioBuffer[writer.ioIndex++] = (byte)((value & 0x7F) | 0x80);
			num++;
		}
		while ((value >>= 7) != 0);
		writer.ioBuffer[writer.ioIndex - 1] &= 127;
		writer.position += num;
	}

	public static void WriteString(string value, ProtoWriter writer)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		if (writer.wireType != WireType.String)
		{
			throw CreateException(writer);
		}
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		if (value.Length == 0)
		{
			WriteUInt32Variant(0u, writer);
			writer.wireType = WireType.None;
			return;
		}
		int byteCount = encoding.GetByteCount(value);
		WriteUInt32Variant((uint)byteCount, writer);
		DemandSpace(byteCount, writer);
		int bytes = encoding.GetBytes(value, 0, value.Length, writer.ioBuffer, writer.ioIndex);
		IncrementedAndReset(bytes, writer);
	}

	public static void WriteUInt64(ulong value, ProtoWriter writer)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		switch (writer.wireType)
		{
		case WireType.Fixed64:
			WriteInt64((long)value, writer);
			break;
		case WireType.Variant:
			WriteUInt64Variant(value, writer);
			writer.wireType = WireType.None;
			break;
		case WireType.Fixed32:
			WriteUInt32(checked((uint)value), writer);
			break;
		default:
			throw CreateException(writer);
		}
	}

	public static void WriteInt64(long value, ProtoWriter writer)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		switch (writer.wireType)
		{
		case WireType.Fixed64:
		{
			DemandSpace(8, writer);
			byte[] array = writer.ioBuffer;
			int num = writer.ioIndex;
			array[num] = (byte)value;
			array[num + 1] = (byte)(value >> 8);
			array[num + 2] = (byte)(value >> 16);
			array[num + 3] = (byte)(value >> 24);
			array[num + 4] = (byte)(value >> 32);
			array[num + 5] = (byte)(value >> 40);
			array[num + 6] = (byte)(value >> 48);
			array[num + 7] = (byte)(value >> 56);
			IncrementedAndReset(8, writer);
			break;
		}
		case WireType.SignedVariant:
			WriteUInt64Variant(Zig(value), writer);
			writer.wireType = WireType.None;
			break;
		case WireType.Variant:
		{
			if (value >= 0)
			{
				WriteUInt64Variant((ulong)value, writer);
				writer.wireType = WireType.None;
				break;
			}
			DemandSpace(10, writer);
			byte[] array = writer.ioBuffer;
			int num = writer.ioIndex;
			array[num] = (byte)(value | 0x80);
			array[num + 1] = (byte)((int)(value >> 7) | 0x80);
			array[num + 2] = (byte)((int)(value >> 14) | 0x80);
			array[num + 3] = (byte)((int)(value >> 21) | 0x80);
			array[num + 4] = (byte)((int)(value >> 28) | 0x80);
			array[num + 5] = (byte)((int)(value >> 35) | 0x80);
			array[num + 6] = (byte)((int)(value >> 42) | 0x80);
			array[num + 7] = (byte)((int)(value >> 49) | 0x80);
			array[num + 8] = (byte)((int)(value >> 56) | 0x80);
			array[num + 9] = 1;
			IncrementedAndReset(10, writer);
			break;
		}
		case WireType.Fixed32:
			WriteInt32(checked((int)value), writer);
			break;
		default:
			throw CreateException(writer);
		}
	}

	public static void WriteUInt32(uint value, ProtoWriter writer)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		switch (writer.wireType)
		{
		case WireType.Fixed32:
			WriteInt32((int)value, writer);
			break;
		case WireType.Fixed64:
			WriteInt64((int)value, writer);
			break;
		case WireType.Variant:
			WriteUInt32Variant(value, writer);
			writer.wireType = WireType.None;
			break;
		default:
			throw CreateException(writer);
		}
	}

	public static void WriteInt16(short value, ProtoWriter writer)
	{
		WriteInt32(value, writer);
	}

	public static void WriteUInt16(ushort value, ProtoWriter writer)
	{
		WriteUInt32(value, writer);
	}

	public static void WriteByte(byte value, ProtoWriter writer)
	{
		WriteUInt32(value, writer);
	}

	public static void WriteSByte(sbyte value, ProtoWriter writer)
	{
		WriteInt32(value, writer);
	}

	private static void WriteInt32ToBuffer(int value, byte[] buffer, int index)
	{
		buffer[index] = (byte)value;
		buffer[index + 1] = (byte)(value >> 8);
		buffer[index + 2] = (byte)(value >> 16);
		buffer[index + 3] = (byte)(value >> 24);
	}

	public static void WriteInt32(int value, ProtoWriter writer)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		switch (writer.wireType)
		{
		case WireType.Fixed32:
			DemandSpace(4, writer);
			WriteInt32ToBuffer(value, writer.ioBuffer, writer.ioIndex);
			IncrementedAndReset(4, writer);
			break;
		case WireType.Fixed64:
		{
			DemandSpace(8, writer);
			byte[] array = writer.ioBuffer;
			int num = writer.ioIndex;
			array[num] = (byte)value;
			array[num + 1] = (byte)(value >> 8);
			array[num + 2] = (byte)(value >> 16);
			array[num + 3] = (byte)(value >> 24);
			array[num + 4] = (array[num + 5] = (array[num + 6] = (array[num + 7] = 0)));
			IncrementedAndReset(8, writer);
			break;
		}
		case WireType.SignedVariant:
			WriteUInt32Variant(Zig(value), writer);
			writer.wireType = WireType.None;
			break;
		case WireType.Variant:
		{
			if (value >= 0)
			{
				WriteUInt32Variant((uint)value, writer);
				writer.wireType = WireType.None;
				break;
			}
			DemandSpace(10, writer);
			byte[] array = writer.ioBuffer;
			int num = writer.ioIndex;
			array[num] = (byte)(value | 0x80);
			array[num + 1] = (byte)((value >> 7) | 0x80);
			array[num + 2] = (byte)((value >> 14) | 0x80);
			array[num + 3] = (byte)((value >> 21) | 0x80);
			array[num + 4] = (byte)((value >> 28) | 0x80);
			byte[] array2 = array;
			int num2 = num + 5;
			byte[] array3 = array;
			int num3 = num + 6;
			byte[] array4 = array;
			int num4 = num + 7;
			byte b;
			array[num + 8] = (b = byte.MaxValue);
			array2[num2] = (array3[num3] = (array4[num4] = b));
			array[num + 9] = 1;
			IncrementedAndReset(10, writer);
			break;
		}
		default:
			throw CreateException(writer);
		}
	}

	public static void WriteDouble(double value, ProtoWriter writer)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		switch (writer.wireType)
		{
		case WireType.Fixed32:
		{
			float value2 = (float)value;
			if (Helpers.IsInfinity(value2) && !Helpers.IsInfinity(value))
			{
				throw new OverflowException();
			}
			WriteSingle(value2, writer);
			break;
		}
		case WireType.Fixed64:
			WriteInt64(BitConverter.ToInt64(BitConverter.GetBytes(value), 0), writer);
			break;
		default:
			throw CreateException(writer);
		}
	}

	public static void WriteSingle(float value, ProtoWriter writer)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		switch (writer.wireType)
		{
		case WireType.Fixed32:
			WriteInt32(BitConverter.ToInt32(BitConverter.GetBytes(value), 0), writer);
			break;
		case WireType.Fixed64:
			WriteDouble(value, writer);
			break;
		default:
			throw CreateException(writer);
		}
	}

	public static void ThrowEnumException(ProtoWriter writer, object enumValue)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		string text = ((enumValue == null) ? "<null>" : (enumValue.GetType().FullName + "." + enumValue.ToString()));
		throw new ProtoException("No wire-value is mapped to the enum " + text + " at position " + writer.position);
	}

	internal static Exception CreateException(ProtoWriter writer)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		return new ProtoException("Invalid serialization operation with wire-type " + writer.wireType.ToString() + " at position " + writer.position);
	}

	public static void WriteBoolean(bool value, ProtoWriter writer)
	{
		WriteUInt32(value ? 1u : 0u, writer);
	}

	public static void AppendExtensionData(IExtensible instance, ProtoWriter writer)
	{
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		if (writer.wireType != WireType.None)
		{
			throw CreateException(writer);
		}
		IExtension extensionObject = instance.GetExtensionObject(createIfMissing: false);
		if (extensionObject != null)
		{
			Stream stream = extensionObject.BeginQuery();
			try
			{
				CopyRawFromStream(stream, writer);
			}
			finally
			{
				extensionObject.EndQuery(stream);
			}
		}
	}

	public static void SetPackedField(int fieldNumber, ProtoWriter writer)
	{
		if (fieldNumber <= 0)
		{
			throw new ArgumentOutOfRangeException("fieldNumber");
		}
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		writer.packedFieldNumber = fieldNumber;
	}

	internal string SerializeType(Type type)
	{
		return TypeModel.SerializeType(model, type);
	}

	public void SetRootObject(object value)
	{
		NetCache.SetKeyedObject(0, value);
	}

	public static void WriteType(Type value, ProtoWriter writer)
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		WriteString(writer.SerializeType(value), writer);
	}
}


using System;
using System.Runtime.Serialization;
using ProtoBuf;

public sealed class SerializationContext
{
	private bool frozen;

	private object context;

	private static readonly SerializationContext @default;

	private StreamingContextStates state = StreamingContextStates.Persistence;

	public object Context
	{
		get
		{
			return context;
		}
		set
		{
			if (context != value)
			{
				ThrowIfFrozen();
				context = value;
			}
		}
	}

	internal static SerializationContext Default => @default;

	public StreamingContextStates State
	{
		get
		{
			return state;
		}
		set
		{
			if (state != value)
			{
				ThrowIfFrozen();
				state = value;
			}
		}
	}

	internal void Freeze()
	{
		frozen = true;
	}

	private void ThrowIfFrozen()
	{
		if (frozen)
		{
			throw new InvalidOperationException("The serialization-context cannot be changed once it is in use");
		}
	}

	static SerializationContext()
	{
		@default = new SerializationContext();
		@default.Freeze();
	}

	public static implicit operator StreamingContext(SerializationContext ctx)
	{
		if (ctx == null)
		{
			return new StreamingContext(StreamingContextStates.Persistence);
		}
		return new StreamingContext(ctx.state, ctx.context);
	}

	public static implicit operator SerializationContext(StreamingContext ctx)
	{
		SerializationContext serializationContext = new SerializationContext();
		serializationContext.Context = ctx.Context;
		serializationContext.State = ctx.State;
		return serializationContext;
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization;
using System.Xml;
using System.Xml.Serialization;
using ProtoBuf;
using ProtoBuf.Meta;

public static class Serializer
{
	public static class NonGeneric
	{
		public static object DeepClone(object instance)
		{
			if (instance != null)
			{
				return RuntimeTypeModel.Default.DeepClone(instance);
			}
			return null;
		}

		public static void Serialize(Stream dest, object instance)
		{
			if (instance != null)
			{
				RuntimeTypeModel.Default.Serialize(dest, instance);
			}
		}

		public static object Deserialize(Type type, Stream source)
		{
			return RuntimeTypeModel.Default.Deserialize(source, null, type);
		}

		public static object Merge(Stream source, object instance)
		{
			if (instance == null)
			{
				throw new ArgumentNullException("instance");
			}
			return RuntimeTypeModel.Default.Deserialize(source, instance, instance.GetType(), null);
		}

		public static void SerializeWithLengthPrefix(Stream destination, object instance, PrefixStyle style, int fieldNumber)
		{
			if (instance == null)
			{
				throw new ArgumentNullException("instance");
			}
			RuntimeTypeModel @default = RuntimeTypeModel.Default;
			@default.SerializeWithLengthPrefix(destination, instance, @default.MapType(instance.GetType()), style, fieldNumber);
		}

		public static bool TryDeserializeWithLengthPrefix(Stream source, PrefixStyle style, TypeResolver resolver, out object value)
		{
			value = RuntimeTypeModel.Default.DeserializeWithLengthPrefix(source, null, null, style, 0, resolver);
			return value != null;
		}

		public static bool CanSerialize(Type type)
		{
			return RuntimeTypeModel.Default.IsDefined(type);
		}
	}

	public static class GlobalOptions
	{
		[Obsolete("Please use RuntimeTypeModel.Default.InferTagFromNameDefault instead (or on a per-model basis)", false)]
		public static bool InferTagFromName
		{
			get
			{
				return RuntimeTypeModel.Default.InferTagFromNameDefault;
			}
			set
			{
				RuntimeTypeModel.Default.InferTagFromNameDefault = value;
			}
		}
	}

	public delegate Type TypeResolver(int fieldNumber);

	private const string ProtoBinaryField = "proto";

	public const int ListItemTag = 1;

	public static string GetProto<T>()
	{
		return RuntimeTypeModel.Default.GetSchema(RuntimeTypeModel.Default.MapType(typeof(T)));
	}

	public static T DeepClone<T>(T instance)
	{
		if (instance != null)
		{
			return (T)RuntimeTypeModel.Default.DeepClone(instance);
		}
		return instance;
	}

	public static T Merge<T>(Stream source, T instance)
	{
		return (T)RuntimeTypeModel.Default.Deserialize(source, instance, typeof(T));
	}

	public static T Deserialize<T>(Stream source)
	{
		return (T)RuntimeTypeModel.Default.Deserialize(source, null, typeof(T));
	}

	public static void Serialize<T>(Stream destination, T instance)
	{
		if (instance != null)
		{
			RuntimeTypeModel.Default.Serialize(destination, instance);
		}
	}

	public static TTo ChangeType<TFrom, TTo>(TFrom instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize((Stream)memoryStream, instance);
		memoryStream.Position = 0L;
		return Deserialize<TTo>(memoryStream);
	}

	public static void Serialize<T>(SerializationInfo info, T instance) where T : class, ISerializable
	{
		Serialize(info, new StreamingContext(StreamingContextStates.Persistence), instance);
	}

	public static void Serialize<T>(SerializationInfo info, StreamingContext context, T instance) where T : class, ISerializable
	{
		if (info == null)
		{
			throw new ArgumentNullException("info");
		}
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		if ((object)instance.GetType() != typeof(T))
		{
			throw new ArgumentException("Incorrect type", "instance");
		}
		using MemoryStream memoryStream = new MemoryStream();
		RuntimeTypeModel.Default.Serialize(memoryStream, instance, context);
		info.AddValue("proto", memoryStream.ToArray());
	}

	public static void Serialize<T>(XmlWriter writer, T instance) where T : IXmlSerializable
	{
		if (writer == null)
		{
			throw new ArgumentNullException("writer");
		}
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		using MemoryStream memoryStream = new MemoryStream();
		Serialize((Stream)memoryStream, instance);
		writer.WriteBase64(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
	}

	public static void Merge<T>(XmlReader reader, T instance) where T : IXmlSerializable
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Invalid comparison between Unknown and I4
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		byte[] array = new byte[4096];
		using MemoryStream memoryStream = new MemoryStream();
		int depth = reader.Depth;
		while (reader.Read() && reader.Depth > depth)
		{
			if ((int)reader.NodeType == 3)
			{
				int count;
				while ((count = reader.ReadContentAsBase64(array, 0, 4096)) > 0)
				{
					memoryStream.Write(array, 0, count);
				}
				if (reader.Depth <= depth)
				{
					break;
				}
			}
		}
		memoryStream.Position = 0L;
		Merge((Stream)memoryStream, instance);
	}

	public static void Merge<T>(SerializationInfo info, T instance) where T : class, ISerializable
	{
		Merge(info, new StreamingContext(StreamingContextStates.Persistence), instance);
	}

	public static void Merge<T>(SerializationInfo info, StreamingContext context, T instance) where T : class, ISerializable
	{
		if (info == null)
		{
			throw new ArgumentNullException("info");
		}
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		if ((object)instance.GetType() != typeof(T))
		{
			throw new ArgumentException("Incorrect type", "instance");
		}
		byte[] buffer = (byte[])info.GetValue("proto", typeof(byte[]));
		using MemoryStream source = new MemoryStream(buffer);
		T objA = (T)RuntimeTypeModel.Default.Deserialize(source, instance, typeof(T), context);
		if (!object.ReferenceEquals(objA, instance))
		{
			throw new ProtoException("Deserialization changed the instance; cannot succeed.");
		}
	}

	public static void PrepareSerializer<T>()
	{
		RuntimeTypeModel @default = RuntimeTypeModel.Default;
		@default[@default.MapType(typeof(T))].CompileInPlace();
	}

	public static IFormatter CreateFormatter<T>()
	{
		return RuntimeTypeModel.Default.CreateFormatter(typeof(T));
	}

	public static IEnumerable<T> DeserializeItems<T>(Stream source, PrefixStyle style, int fieldNumber)
	{
		return RuntimeTypeModel.Default.DeserializeItems<T>(source, style, fieldNumber);
	}

	public static T DeserializeWithLengthPrefix<T>(Stream source, PrefixStyle style)
	{
		return DeserializeWithLengthPrefix<T>(source, style, 0);
	}

	public static T DeserializeWithLengthPrefix<T>(Stream source, PrefixStyle style, int fieldNumber)
	{
		RuntimeTypeModel @default = RuntimeTypeModel.Default;
		return (T)@default.DeserializeWithLengthPrefix(source, null, @default.MapType(typeof(T)), style, fieldNumber);
	}

	public static T MergeWithLengthPrefix<T>(Stream source, T instance, PrefixStyle style)
	{
		RuntimeTypeModel @default = RuntimeTypeModel.Default;
		return (T)@default.DeserializeWithLengthPrefix(source, instance, @default.MapType(typeof(T)), style, 0);
	}

	public static void SerializeWithLengthPrefix<T>(Stream destination, T instance, PrefixStyle style)
	{
		SerializeWithLengthPrefix(destination, instance, style, 0);
	}

	public static void SerializeWithLengthPrefix<T>(Stream destination, T instance, PrefixStyle style, int fieldNumber)
	{
		RuntimeTypeModel @default = RuntimeTypeModel.Default;
		@default.SerializeWithLengthPrefix(destination, instance, @default.MapType(typeof(T)), style, fieldNumber);
	}

	public static bool TryReadLengthPrefix(Stream source, PrefixStyle style, out int length)
	{
		length = ProtoReader.ReadLengthPrefix(source, expectHeader: false, style, out var _, out var bytesRead);
		return bytesRead > 0;
	}

	public static bool TryReadLengthPrefix(byte[] buffer, int index, int count, PrefixStyle style, out int length)
	{
		using Stream source = new MemoryStream(buffer, index, count);
		return TryReadLengthPrefix(source, style, out length);
	}

	public static void FlushPool()
	{
		BufferPool.Flush();
	}
}


using System;
using System.IO;
using ProtoBuf.Meta;

public static class NonGeneric
{
	public static object DeepClone(object instance)
	{
		if (instance != null)
		{
			return RuntimeTypeModel.Default.DeepClone(instance);
		}
		return null;
	}

	public static void Serialize(Stream dest, object instance)
	{
		if (instance != null)
		{
			RuntimeTypeModel.Default.Serialize(dest, instance);
		}
	}

	public static object Deserialize(Type type, Stream source)
	{
		return RuntimeTypeModel.Default.Deserialize(source, null, type);
	}

	public static object Merge(Stream source, object instance)
	{
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		return RuntimeTypeModel.Default.Deserialize(source, instance, instance.GetType(), null);
	}

	public static void SerializeWithLengthPrefix(Stream destination, object instance, PrefixStyle style, int fieldNumber)
	{
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		RuntimeTypeModel @default = RuntimeTypeModel.Default;
		@default.SerializeWithLengthPrefix(destination, instance, @default.MapType(instance.GetType()), style, fieldNumber);
	}

	public static bool TryDeserializeWithLengthPrefix(Stream source, PrefixStyle style, TypeResolver resolver, out object value)
	{
		value = RuntimeTypeModel.Default.DeserializeWithLengthPrefix(source, null, null, style, 0, resolver);
		return value != null;
	}

	public static bool CanSerialize(Type type)
	{
		return RuntimeTypeModel.Default.IsDefined(type);
	}
}


using System;
using ProtoBuf.Meta;

public static class GlobalOptions
{
	[Obsolete("Please use RuntimeTypeModel.Default.InferTagFromNameDefault instead (or on a per-model basis)", false)]
	public static bool InferTagFromName
	{
		get
		{
			return RuntimeTypeModel.Default.InferTagFromNameDefault;
		}
		set
		{
			RuntimeTypeModel.Default.InferTagFromNameDefault = value;
		}
	}
}


using System;

public delegate Type TypeResolver(int fieldNumber);


using System;
using ProtoBuf;
using ProtoBuf.Compiler;

internal interface IProtoSerializer
{
	Type ExpectedType { get; }

	bool RequiresOldValue { get; }

	bool ReturnsValue { get; }

	void Write(object value, ProtoWriter dest);

	object Read(object value, ProtoReader source);

	void EmitWrite(CompilerContext ctx, Local valueFrom);

	void EmitRead(CompilerContext ctx, Local entity);
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class BlobSerializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(byte[]);

	private readonly bool overwriteList;

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => !overwriteList;

	bool IProtoSerializer.ReturnsValue => true;

	public BlobSerializer(TypeModel model, bool overwriteList)
	{
		this.overwriteList = overwriteList;
	}

	public object Read(object value, ProtoReader source)
	{
		return ProtoReader.AppendBytes(overwriteList ? null : ((byte[])value), source);
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteBytes((byte[])value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteBytes", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		if (overwriteList)
		{
			ctx.LoadNullRef();
		}
		else
		{
			ctx.LoadValue(valueFrom);
		}
		ctx.LoadReaderWriter();
		ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("AppendBytes"));
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal class UInt16Serializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(ushort);

	public virtual Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public UInt16Serializer(TypeModel model)
	{
	}

	public virtual object Read(object value, ProtoReader source)
	{
		return source.ReadUInt16();
	}

	public virtual void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteUInt16((ushort)value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteUInt16", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadUInt16", ctx.MapType(typeof(ushort)));
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class CharSerializer : UInt16Serializer
{
	private static readonly Type expectedType = typeof(char);

	public override Type ExpectedType => expectedType;

	public CharSerializer(TypeModel model)
		: base(model)
	{
	}

	public override void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteUInt16((char)value, dest);
	}

	public override object Read(object value, ProtoReader source)
	{
		return (char)source.ReadUInt16();
	}
}


using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal interface IProtoTypeSerializer : IProtoSerializer
{
	bool HasCallbacks(TypeModel.CallbackType callbackType);

	bool CanCreateInstance();

	object CreateInstance(ProtoReader source);

	void Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context);

	void EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType);

	void EmitCreateInstance(CompilerContext ctx);
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class CompiledSerializer : IProtoTypeSerializer, IProtoSerializer
{
	private readonly IProtoTypeSerializer head;

	private readonly ProtoSerializer serializer;

	private readonly ProtoDeserializer deserializer;

	bool IProtoSerializer.RequiresOldValue => head.RequiresOldValue;

	bool IProtoSerializer.ReturnsValue => head.ReturnsValue;

	Type IProtoSerializer.ExpectedType => head.ExpectedType;

	bool IProtoTypeSerializer.HasCallbacks(TypeModel.CallbackType callbackType)
	{
		return head.HasCallbacks(callbackType);
	}

	bool IProtoTypeSerializer.CanCreateInstance()
	{
		return head.CanCreateInstance();
	}

	object IProtoTypeSerializer.CreateInstance(ProtoReader source)
	{
		return head.CreateInstance(source);
	}

	public void Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context)
	{
		head.Callback(value, callbackType, context);
	}

	public static CompiledSerializer Wrap(IProtoTypeSerializer head, TypeModel model)
	{
		CompiledSerializer compiledSerializer = head as CompiledSerializer;
		if (compiledSerializer == null)
		{
			compiledSerializer = new CompiledSerializer(head, model);
		}
		return compiledSerializer;
	}

	private CompiledSerializer(IProtoTypeSerializer head, TypeModel model)
	{
		this.head = head;
		serializer = CompilerContext.BuildSerializer(head, model);
		deserializer = CompilerContext.BuildDeserializer(head, model);
	}

	void IProtoSerializer.Write(object value, ProtoWriter dest)
	{
		serializer(value, dest);
	}

	object IProtoSerializer.Read(object value, ProtoReader source)
	{
		return deserializer(value, source);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		head.EmitWrite(ctx, valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		head.EmitRead(ctx, valueFrom);
	}

	void IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
	{
		head.EmitCallback(ctx, valueFrom, callbackType);
	}

	void IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
	{
		head.EmitCreateInstance(ctx);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class BooleanSerializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(bool);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public BooleanSerializer(TypeModel model)
	{
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteBoolean((bool)value, dest);
	}

	public object Read(object value, ProtoReader source)
	{
		return source.ReadBoolean();
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteBoolean", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadBoolean", ExpectedType);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Serializers;

internal abstract class ProtoDecoratorBase : IProtoSerializer
{
	protected readonly IProtoSerializer Tail;

	public abstract Type ExpectedType { get; }

	public abstract bool ReturnsValue { get; }

	public abstract bool RequiresOldValue { get; }

	protected ProtoDecoratorBase(IProtoSerializer tail)
	{
		Tail = tail;
	}

	public abstract void Write(object value, ProtoWriter dest);

	public abstract object Read(object value, ProtoReader source);

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		EmitWrite(ctx, valueFrom);
	}

	protected abstract void EmitWrite(CompilerContext ctx, Local valueFrom);

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		EmitRead(ctx, valueFrom);
	}

	protected abstract void EmitRead(CompilerContext ctx, Local valueFrom);
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class ArrayDecorator : ProtoDecoratorBase
{
	private const byte OPTIONS_WritePacked = 1;

	private const byte OPTIONS_OverwriteList = 2;

	private const byte OPTIONS_SupportNull = 4;

	private readonly int fieldNumber;

	private readonly byte options;

	private readonly WireType packedWireType;

	private readonly Type arrayType;

	private readonly Type itemType;

	public override Type ExpectedType => arrayType;

	public override bool RequiresOldValue => AppendToCollection;

	public override bool ReturnsValue => true;

	private bool AppendToCollection => (options & 2) == 0;

	private bool SupportNull => (options & 4) != 0;

	public ArrayDecorator(TypeModel model, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, Type arrayType, bool overwriteList, bool supportNull)
		: base(tail)
	{
		itemType = arrayType.GetElementType();
		if (!supportNull)
		{
			Helpers.GetUnderlyingType(itemType);
		}
		if ((writePacked || packedWireType != WireType.None) && fieldNumber <= 0)
		{
			throw new ArgumentOutOfRangeException("fieldNumber");
		}
		if (!ListDecorator.CanPack(packedWireType))
		{
			if (writePacked)
			{
				throw new InvalidOperationException("Only simple data-types can use packed encoding");
			}
			packedWireType = WireType.None;
		}
		this.fieldNumber = fieldNumber;
		this.packedWireType = packedWireType;
		if (writePacked)
		{
			options |= 1;
		}
		if (overwriteList)
		{
			options |= 2;
		}
		if (supportNull)
		{
			options |= 4;
		}
		this.arrayType = arrayType;
	}

	protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		using Local local = ctx.GetLocalWithValue(arrayType, valueFrom);
		using Local i = new Local(ctx, ctx.MapType(typeof(int)));
		bool flag = (options & 1) != 0;
		using Local local2 = (flag ? new Local(ctx, ctx.MapType(typeof(SubItemToken))) : null);
		Type type = ctx.MapType(typeof(ProtoWriter));
		if (flag)
		{
			ctx.LoadValue(fieldNumber);
			ctx.LoadValue(2);
			ctx.LoadReaderWriter();
			ctx.EmitCall(type.GetMethod("WriteFieldHeader"));
			ctx.LoadValue(local);
			ctx.LoadReaderWriter();
			ctx.EmitCall(type.GetMethod("StartSubItem"));
			ctx.StoreValue(local2);
			ctx.LoadValue(fieldNumber);
			ctx.LoadReaderWriter();
			ctx.EmitCall(type.GetMethod("SetPackedField"));
		}
		EmitWriteArrayLoop(ctx, i, local);
		if (flag)
		{
			ctx.LoadValue(local2);
			ctx.LoadReaderWriter();
			ctx.EmitCall(type.GetMethod("EndSubItem"));
		}
	}

	private void EmitWriteArrayLoop(CompilerContext ctx, Local i, Local arr)
	{
		ctx.LoadValue(0);
		ctx.StoreValue(i);
		CodeLabel label = ctx.DefineLabel();
		CodeLabel label2 = ctx.DefineLabel();
		ctx.Branch(label, @short: false);
		ctx.MarkLabel(label2);
		ctx.LoadArrayValue(arr, i);
		if (SupportNull)
		{
			Tail.EmitWrite(ctx, null);
		}
		else
		{
			ctx.WriteNullCheckedTail(itemType, Tail, null);
		}
		ctx.LoadValue(i);
		ctx.LoadValue(1);
		ctx.Add();
		ctx.StoreValue(i);
		ctx.MarkLabel(label);
		ctx.LoadValue(i);
		ctx.LoadLength(arr, zeroIfNull: false);
		ctx.BranchIfLess(label2, @short: false);
	}

	public override void Write(object value, ProtoWriter dest)
	{
		IList list = (IList)value;
		int count = list.Count;
		bool flag = (options & 1) != 0;
		SubItemToken token;
		if (flag)
		{
			ProtoWriter.WriteFieldHeader(fieldNumber, WireType.String, dest);
			token = ProtoWriter.StartSubItem(value, dest);
			ProtoWriter.SetPackedField(fieldNumber, dest);
		}
		else
		{
			token = default(SubItemToken);
		}
		bool flag2 = !SupportNull;
		for (int i = 0; i < count; i++)
		{
			object obj = list[i];
			if (flag2 && obj == null)
			{
				throw new NullReferenceException();
			}
			Tail.Write(obj, dest);
		}
		if (flag)
		{
			ProtoWriter.EndSubItem(token, dest);
		}
	}

	public override object Read(object value, ProtoReader source)
	{
		int field = source.FieldNumber;
		BasicList basicList = new BasicList();
		if (packedWireType != WireType.None && source.WireType == WireType.String)
		{
			SubItemToken token = ProtoReader.StartSubItem(source);
			while (ProtoReader.HasSubValue(packedWireType, source))
			{
				basicList.Add(Tail.Read(null, source));
			}
			ProtoReader.EndSubItem(token, source);
		}
		else
		{
			do
			{
				basicList.Add(Tail.Read(null, source));
			}
			while (source.TryReadFieldHeader(field));
		}
		int num = (AppendToCollection ? ((value != null) ? ((Array)value).Length : 0) : 0);
		Array array = Array.CreateInstance(itemType, num + basicList.Count);
		if (num != 0)
		{
			((Array)value).CopyTo(array, 0);
		}
		basicList.CopyTo(array, num);
		return array;
	}

	protected override void EmitRead(CompilerContext ctx, Local valueFrom)
	{
		Type type = ctx.MapType(typeof(List<>)).MakeGenericType(itemType);
		Type expectedType = ExpectedType;
		using Local local2 = (AppendToCollection ? ctx.GetLocalWithValue(expectedType, valueFrom) : null);
		using Local local4 = new Local(ctx, expectedType);
		using Local local = new Local(ctx, type);
		ctx.EmitCtor(type);
		ctx.StoreValue(local);
		ListDecorator.EmitReadList(ctx, local, Tail, type.GetMethod("Add"), packedWireType, castListForAdd: false);
		using (Local local3 = (AppendToCollection ? new Local(ctx, ctx.MapType(typeof(int))) : null))
		{
			Type[] array = new Type[2]
			{
				ctx.MapType(typeof(Array)),
				ctx.MapType(typeof(int))
			};
			if (AppendToCollection)
			{
				ctx.LoadLength(local2, zeroIfNull: true);
				ctx.CopyValue();
				ctx.StoreValue(local3);
				ctx.LoadAddress(local, type);
				ctx.LoadValue(type.GetProperty("Count"));
				ctx.Add();
				ctx.CreateArray(itemType, null);
				ctx.StoreValue(local4);
				ctx.LoadValue(local3);
				CodeLabel label = ctx.DefineLabel();
				ctx.BranchIfFalse(label, @short: true);
				ctx.LoadValue(local2);
				ctx.LoadValue(local4);
				ctx.LoadValue(0);
				ctx.EmitCall(expectedType.GetMethod("CopyTo", array));
				ctx.MarkLabel(label);
				ctx.LoadValue(local);
				ctx.LoadValue(local4);
				ctx.LoadValue(local3);
			}
			else
			{
				ctx.LoadAddress(local, type);
				ctx.LoadValue(type.GetProperty("Count"));
				ctx.CreateArray(itemType, null);
				ctx.StoreValue(local4);
				ctx.LoadAddress(local, type);
				ctx.LoadValue(local4);
				ctx.LoadValue(0);
			}
			array[0] = expectedType;
			MethodInfo method = type.GetMethod("CopyTo", array);
			if ((object)method == null)
			{
				array[1] = ctx.MapType(typeof(Array));
				method = type.GetMethod("CopyTo", array);
			}
			ctx.EmitCall(method);
		}
		ctx.LoadValue(local4);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class ByteSerializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(byte);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public ByteSerializer(TypeModel model)
	{
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteByte((byte)value, dest);
	}

	public object Read(object value, ProtoReader source)
	{
		return source.ReadByte();
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteByte", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadByte", ExpectedType);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal class ListDecorator : ProtoDecoratorBase
{
	private const byte OPTIONS_IsList = 1;

	private const byte OPTIONS_SuppressIList = 2;

	private const byte OPTIONS_WritePacked = 4;

	private const byte OPTIONS_ReturnList = 8;

	private const byte OPTIONS_OverwriteList = 16;

	private const byte OPTIONS_SupportNull = 32;

	private readonly byte options;

	private readonly Type declaredType;

	private readonly Type concreteType;

	private readonly MethodInfo add;

	private readonly int fieldNumber;

	protected readonly WireType packedWireType;

	private static readonly Type ienumeratorType = typeof(IEnumerator);

	private static readonly Type ienumerableType = typeof(IEnumerable);

	private bool IsList => (options & 1) != 0;

	private bool SuppressIList => (options & 2) != 0;

	private bool WritePacked => (options & 4) != 0;

	private bool SupportNull => (options & 0x20) != 0;

	private bool ReturnList => (options & 8) != 0;

	protected virtual bool RequireAdd => true;

	public override Type ExpectedType => declaredType;

	public override bool RequiresOldValue => AppendToCollection;

	public override bool ReturnsValue => ReturnList;

	protected bool AppendToCollection => (options & 0x10) == 0;

	internal static bool CanPack(WireType wireType)
	{
		switch (wireType)
		{
		case WireType.Variant:
		case WireType.Fixed64:
		case WireType.Fixed32:
		case WireType.SignedVariant:
			return true;
		default:
			return false;
		}
	}

	internal static ListDecorator Create(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull)
	{
		if (returnList && ImmutableCollectionDecorator.IdentifyImmutable(model, declaredType, out var builderFactory, out var methodInfo, out var addRange, out var finish))
		{
			return new ImmutableCollectionDecorator(model, declaredType, concreteType, tail, fieldNumber, writePacked, packedWireType, returnList, overwriteList, supportNull, builderFactory, methodInfo, addRange, finish);
		}
		return new ListDecorator(model, declaredType, concreteType, tail, fieldNumber, writePacked, packedWireType, returnList, overwriteList, supportNull);
	}

	protected ListDecorator(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull)
		: base(tail)
	{
		if (returnList)
		{
			options |= 8;
		}
		if (overwriteList)
		{
			options |= 16;
		}
		if (supportNull)
		{
			options |= 32;
		}
		if ((writePacked || packedWireType != WireType.None) && fieldNumber <= 0)
		{
			throw new ArgumentOutOfRangeException("fieldNumber");
		}
		if (!CanPack(packedWireType))
		{
			if (writePacked)
			{
				throw new InvalidOperationException("Only simple data-types can use packed encoding");
			}
			packedWireType = WireType.None;
		}
		this.fieldNumber = fieldNumber;
		if (writePacked)
		{
			options |= 4;
		}
		this.packedWireType = packedWireType;
		if ((object)declaredType == null)
		{
			throw new ArgumentNullException("declaredType");
		}
		if (declaredType.IsArray)
		{
			throw new ArgumentException("Cannot treat arrays as lists", "declaredType");
		}
		this.declaredType = declaredType;
		this.concreteType = concreteType;
		if (!RequireAdd)
		{
			return;
		}
		add = TypeModel.ResolveListAdd(model, declaredType, tail.ExpectedType, out var isList);
		if (isList)
		{
			options |= 1;
			string fullName = declaredType.FullName;
			if (fullName != null && fullName.StartsWith("System.Data.Linq.EntitySet`1[["))
			{
				options |= 2;
			}
		}
		if ((object)add == null)
		{
			throw new InvalidOperationException("Unable to resolve a suitable Add method for " + declaredType.FullName);
		}
	}

	protected override void EmitRead(CompilerContext ctx, Local valueFrom)
	{
		bool returnList = ReturnList;
		using Local local = (AppendToCollection ? ctx.GetLocalWithValue(ExpectedType, valueFrom) : new Local(ctx, declaredType));
		using Local local2 = ((returnList && AppendToCollection) ? new Local(ctx, ExpectedType) : null);
		if (!AppendToCollection)
		{
			ctx.LoadNullRef();
			ctx.StoreValue(local);
		}
		else if (returnList)
		{
			ctx.LoadValue(local);
			ctx.StoreValue(local2);
		}
		if ((object)concreteType != null)
		{
			ctx.LoadValue(local);
			CodeLabel label = ctx.DefineLabel();
			ctx.BranchIfTrue(label, @short: true);
			ctx.EmitCtor(concreteType);
			ctx.StoreValue(local);
			ctx.MarkLabel(label);
		}
		bool castListForAdd = !add.DeclaringType.IsAssignableFrom(declaredType);
		EmitReadList(ctx, local, Tail, add, packedWireType, castListForAdd);
		if (returnList)
		{
			if (AppendToCollection)
			{
				ctx.LoadValue(local2);
				ctx.LoadValue(local);
				CodeLabel label2 = ctx.DefineLabel();
				CodeLabel label3 = ctx.DefineLabel();
				ctx.BranchIfEqual(label2, @short: true);
				ctx.LoadValue(local);
				ctx.Branch(label3, @short: true);
				ctx.MarkLabel(label2);
				ctx.LoadNullRef();
				ctx.MarkLabel(label3);
			}
			else
			{
				ctx.LoadValue(local);
			}
		}
	}

	internal static void EmitReadList(CompilerContext ctx, Local list, IProtoSerializer tail, MethodInfo add, WireType packedWireType, bool castListForAdd)
	{
		using Local local = new Local(ctx, ctx.MapType(typeof(int)));
		CodeLabel label = ((packedWireType == WireType.None) ? default(CodeLabel) : ctx.DefineLabel());
		if (packedWireType != WireType.None)
		{
			ctx.LoadReaderWriter();
			ctx.LoadValue(typeof(ProtoReader).GetProperty("WireType"));
			ctx.LoadValue(2);
			ctx.BranchIfEqual(label, @short: false);
		}
		ctx.LoadReaderWriter();
		ctx.LoadValue(typeof(ProtoReader).GetProperty("FieldNumber"));
		ctx.StoreValue(local);
		CodeLabel label2 = ctx.DefineLabel();
		ctx.MarkLabel(label2);
		EmitReadAndAddItem(ctx, list, tail, add, castListForAdd);
		ctx.LoadReaderWriter();
		ctx.LoadValue(local);
		ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("TryReadFieldHeader"));
		ctx.BranchIfTrue(label2, @short: false);
		if (packedWireType != WireType.None)
		{
			CodeLabel label3 = ctx.DefineLabel();
			ctx.Branch(label3, @short: false);
			ctx.MarkLabel(label);
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("StartSubItem"));
			CodeLabel label4 = ctx.DefineLabel();
			CodeLabel label5 = ctx.DefineLabel();
			ctx.MarkLabel(label4);
			ctx.LoadValue((int)packedWireType);
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("HasSubValue"));
			ctx.BranchIfFalse(label5, @short: false);
			EmitReadAndAddItem(ctx, list, tail, add, castListForAdd);
			ctx.Branch(label4, @short: false);
			ctx.MarkLabel(label5);
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("EndSubItem"));
			ctx.MarkLabel(label3);
		}
	}

	private static void EmitReadAndAddItem(CompilerContext ctx, Local list, IProtoSerializer tail, MethodInfo add, bool castListForAdd)
	{
		ctx.LoadAddress(list, list.Type);
		if (castListForAdd)
		{
			ctx.Cast(add.DeclaringType);
		}
		Type expectedType = tail.ExpectedType;
		bool returnsValue = tail.ReturnsValue;
		if (tail.RequiresOldValue)
		{
			if (expectedType.IsValueType || !returnsValue)
			{
				using Local local = new Local(ctx, expectedType);
				if (expectedType.IsValueType)
				{
					ctx.LoadAddress(local, expectedType);
					ctx.EmitCtor(expectedType);
				}
				else
				{
					ctx.LoadNullRef();
					ctx.StoreValue(local);
				}
				tail.EmitRead(ctx, local);
				if (!returnsValue)
				{
					ctx.LoadValue(local);
				}
			}
			else
			{
				ctx.LoadNullRef();
				tail.EmitRead(ctx, null);
			}
		}
		else
		{
			if (!returnsValue)
			{
				throw new InvalidOperationException();
			}
			tail.EmitRead(ctx, null);
		}
		Type parameterType = add.GetParameters()[0].ParameterType;
		if ((object)parameterType != expectedType)
		{
			if ((object)parameterType == ctx.MapType(typeof(object)))
			{
				ctx.CastToObject(expectedType);
			}
			else
			{
				if ((object)Helpers.GetUnderlyingType(parameterType) != expectedType)
				{
					throw new InvalidOperationException("Conflicting item/add type");
				}
				ConstructorInfo constructor = Helpers.GetConstructor(parameterType, new Type[1] { expectedType }, nonPublic: false);
				ctx.EmitCtor(constructor);
			}
		}
		ctx.EmitCall(add);
		if ((object)add.ReturnType != ctx.MapType(typeof(void)))
		{
			ctx.DiscardValue();
		}
	}

	protected MethodInfo GetEnumeratorInfo(TypeModel model, out MethodInfo moveNext, out MethodInfo current)
	{
		Type type = null;
		Type expectedType = ExpectedType;
		MethodInfo instanceMethod = Helpers.GetInstanceMethod(expectedType, "GetEnumerator", null);
		Type expectedType2 = Tail.ExpectedType;
		Type type2 = null;
		Type type3;
		if ((object)instanceMethod != null)
		{
			type2 = instanceMethod.ReturnType;
			type3 = type2;
			moveNext = Helpers.GetInstanceMethod(type3, "MoveNext", null);
			PropertyInfo property = Helpers.GetProperty(type3, "Current", nonPublic: false);
			current = (((object)property == null) ? null : Helpers.GetGetMethod(property, nonPublic: false, allowInternal: false));
			if ((object)moveNext == null && model.MapType(ienumeratorType).IsAssignableFrom(type3))
			{
				moveNext = Helpers.GetInstanceMethod(model.MapType(ienumeratorType), "MoveNext", null);
			}
			if ((object)moveNext != null && (object)moveNext.ReturnType == model.MapType(typeof(bool)) && (object)current != null && (object)current.ReturnType == expectedType2)
			{
				return instanceMethod;
			}
			moveNext = (current = (instanceMethod = null));
		}
		Type type4 = model.MapType(typeof(IEnumerable<>), demand: false);
		if ((object)type4 != null)
		{
			type4 = type4.MakeGenericType(expectedType2);
			type = type4;
		}
		if ((object)type != null && type.IsAssignableFrom(expectedType))
		{
			instanceMethod = Helpers.GetInstanceMethod(type, "GetEnumerator");
			type2 = instanceMethod.ReturnType;
			type3 = type2;
			moveNext = Helpers.GetInstanceMethod(model.MapType(ienumeratorType), "MoveNext");
			current = Helpers.GetGetMethod(Helpers.GetProperty(type3, "Current", nonPublic: false), nonPublic: false, allowInternal: false);
			return instanceMethod;
		}
		type = model.MapType(ienumerableType);
		instanceMethod = Helpers.GetInstanceMethod(type, "GetEnumerator");
		type2 = instanceMethod.ReturnType;
		type3 = type2;
		moveNext = Helpers.GetInstanceMethod(type3, "MoveNext");
		current = Helpers.GetGetMethod(Helpers.GetProperty(type3, "Current", nonPublic: false), nonPublic: false, allowInternal: false);
		return instanceMethod;
	}

	protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		using Local local = ctx.GetLocalWithValue(ExpectedType, valueFrom);
		MethodInfo moveNext;
		MethodInfo current;
		MethodInfo enumeratorInfo = GetEnumeratorInfo(ctx.Model, out moveNext, out current);
		Type returnType = enumeratorInfo.ReturnType;
		bool writePacked = WritePacked;
		using Local local3 = new Local(ctx, returnType);
		using Local local2 = (writePacked ? new Local(ctx, ctx.MapType(typeof(SubItemToken))) : null);
		if (writePacked)
		{
			ctx.LoadValue(fieldNumber);
			ctx.LoadValue(2);
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("WriteFieldHeader"));
			ctx.LoadValue(local);
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("StartSubItem"));
			ctx.StoreValue(local2);
			ctx.LoadValue(fieldNumber);
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("SetPackedField"));
		}
		ctx.LoadAddress(local, ExpectedType);
		ctx.EmitCall(enumeratorInfo);
		ctx.StoreValue(local3);
		using (ctx.Using(local3))
		{
			CodeLabel label = ctx.DefineLabel();
			CodeLabel label2 = ctx.DefineLabel();
			ctx.Branch(label2, @short: false);
			ctx.MarkLabel(label);
			ctx.LoadAddress(local3, returnType);
			ctx.EmitCall(current);
			Type expectedType = Tail.ExpectedType;
			if ((object)expectedType != ctx.MapType(typeof(object)) && (object)current.ReturnType == ctx.MapType(typeof(object)))
			{
				ctx.CastFromObject(expectedType);
			}
			Tail.EmitWrite(ctx, null);
			ctx.MarkLabel(label2);
			ctx.LoadAddress(local3, returnType);
			ctx.EmitCall(moveNext);
			ctx.BranchIfTrue(label, @short: false);
		}
		if (writePacked)
		{
			ctx.LoadValue(local2);
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("EndSubItem"));
		}
	}

	public override void Write(object value, ProtoWriter dest)
	{
		bool writePacked = WritePacked;
		SubItemToken token;
		if (writePacked)
		{
			ProtoWriter.WriteFieldHeader(fieldNumber, WireType.String, dest);
			token = ProtoWriter.StartSubItem(value, dest);
			ProtoWriter.SetPackedField(fieldNumber, dest);
		}
		else
		{
			token = default(SubItemToken);
		}
		bool flag = !SupportNull;
		foreach (object item in (IEnumerable)value)
		{
			if (flag && item == null)
			{
				throw new NullReferenceException();
			}
			Tail.Write(item, dest);
		}
		if (writePacked)
		{
			ProtoWriter.EndSubItem(token, dest);
		}
	}

	public override object Read(object value, ProtoReader source)
	{
		int field = source.FieldNumber;
		object obj = value;
		if (value == null)
		{
			value = Activator.CreateInstance(concreteType);
		}
		bool flag = IsList && !SuppressIList;
		if (packedWireType != WireType.None && source.WireType == WireType.String)
		{
			SubItemToken token = ProtoReader.StartSubItem(source);
			if (flag)
			{
				IList list = (IList)value;
				while (ProtoReader.HasSubValue(packedWireType, source))
				{
					list.Add(Tail.Read(null, source));
				}
			}
			else
			{
				object[] array = new object[1];
				while (ProtoReader.HasSubValue(packedWireType, source))
				{
					array[0] = Tail.Read(null, source);
					add.Invoke(value, array);
				}
			}
			ProtoReader.EndSubItem(token, source);
		}
		else if (flag)
		{
			IList list2 = (IList)value;
			do
			{
				list2.Add(Tail.Read(null, source));
			}
			while (source.TryReadFieldHeader(field));
		}
		else
		{
			object[] array2 = new object[1];
			do
			{
				array2[0] = Tail.Read(null, source);
				add.Invoke(value, array2);
			}
			while (source.TryReadFieldHeader(field));
		}
		if (obj != value)
		{
			return value;
		}
		return null;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class ImmutableCollectionDecorator : ListDecorator
{
	private readonly MethodInfo builderFactory;

	private readonly MethodInfo add;

	private readonly MethodInfo addRange;

	private readonly MethodInfo finish;

	protected override bool RequireAdd => false;

	private static Type ResolveIReadOnlyCollection(Type declaredType, Type t)
	{
		Type[] interfaces = declaredType.GetInterfaces();
		foreach (Type type in interfaces)
		{
			if (!type.IsGenericType || !type.Name.StartsWith("IReadOnlyCollection`"))
			{
				continue;
			}
			if ((object)t != null)
			{
				Type[] genericArguments = type.GetGenericArguments();
				if (genericArguments.Length != 1 && (object)genericArguments[0] != t)
				{
					continue;
				}
			}
			return type;
		}
		return null;
	}

	internal static bool IdentifyImmutable(TypeModel model, Type declaredType, out MethodInfo builderFactory, out MethodInfo add, out MethodInfo addRange, out MethodInfo finish)
	{
		builderFactory = (add = (addRange = (finish = null)));
		if (model == null || (object)declaredType == null)
		{
			return false;
		}
		if (!declaredType.IsGenericType)
		{
			return false;
		}
		Type[] genericArguments = declaredType.GetGenericArguments();
		Type[] array;
		switch (genericArguments.Length)
		{
		case 1:
			array = genericArguments;
			break;
		case 2:
		{
			Type type = model.MapType(typeof(KeyValuePair<, >));
			if ((object)type == null)
			{
				return false;
			}
			type = type.MakeGenericType(genericArguments);
			array = new Type[1] { type };
			break;
		}
		default:
			return false;
		}
		if ((object)ResolveIReadOnlyCollection(declaredType, null) == null)
		{
			return false;
		}
		string name = declaredType.Name;
		int num = name.IndexOf('`');
		if (num <= 0)
		{
			return false;
		}
		name = (declaredType.IsInterface ? name.Substring(1, num - 1) : name.Substring(0, num));
		Type type2 = model.GetType(declaredType.Namespace + "." + name, declaredType.Assembly);
		if ((object)type2 == null && name == "ImmutableSet")
		{
			type2 = model.GetType(declaredType.Namespace + ".ImmutableHashSet", declaredType.Assembly);
		}
		if ((object)type2 == null)
		{
			return false;
		}
		MethodInfo[] methods = type2.GetMethods();
		foreach (MethodInfo methodInfo in methods)
		{
			if (methodInfo.IsStatic && !(methodInfo.Name != "CreateBuilder") && methodInfo.IsGenericMethodDefinition && methodInfo.GetParameters().Length == 0 && methodInfo.GetGenericArguments().Length == genericArguments.Length)
			{
				builderFactory = methodInfo.MakeGenericMethod(genericArguments);
				break;
			}
		}
		Type type3 = model.MapType(typeof(void));
		if ((object)builderFactory == null || (object)builderFactory.ReturnType == null || (object)builderFactory.ReturnType == type3)
		{
			return false;
		}
		add = Helpers.GetInstanceMethod(builderFactory.ReturnType, "Add", array);
		if ((object)add == null)
		{
			return false;
		}
		finish = Helpers.GetInstanceMethod(builderFactory.ReturnType, "ToImmutable", Helpers.EmptyTypes);
		if ((object)finish == null || (object)finish.ReturnType == null || (object)finish.ReturnType == type3)
		{
			return false;
		}
		if ((object)finish.ReturnType != declaredType && !Helpers.IsAssignableFrom(declaredType, finish.ReturnType))
		{
			return false;
		}
		addRange = Helpers.GetInstanceMethod(builderFactory.ReturnType, "AddRange", new Type[1] { declaredType });
		if ((object)addRange == null)
		{
			Type type4 = model.MapType(typeof(IEnumerable<>), demand: false);
			if ((object)type4 != null)
			{
				addRange = Helpers.GetInstanceMethod(builderFactory.ReturnType, "AddRange", new Type[1] { type4.MakeGenericType(array) });
			}
		}
		return true;
	}

	internal ImmutableCollectionDecorator(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull, MethodInfo builderFactory, MethodInfo add, MethodInfo addRange, MethodInfo finish)
		: base(model, declaredType, concreteType, tail, fieldNumber, writePacked, packedWireType, returnList, overwriteList, supportNull)
	{
		this.builderFactory = builderFactory;
		this.add = add;
		this.addRange = addRange;
		this.finish = finish;
	}

	public override object Read(object value, ProtoReader source)
	{
		object obj = builderFactory.Invoke(null, null);
		int field = source.FieldNumber;
		object[] array = new object[1];
		if (base.AppendToCollection && value != null && ((IList)value).Count != 0)
		{
			if ((object)addRange != null)
			{
				array[0] = value;
				addRange.Invoke(obj, array);
			}
			else
			{
				foreach (object item in (IList)value)
				{
					array[0] = item;
					add.Invoke(obj, array);
				}
			}
		}
		if (packedWireType != WireType.None && source.WireType == WireType.String)
		{
			SubItemToken token = ProtoReader.StartSubItem(source);
			while (ProtoReader.HasSubValue(packedWireType, source))
			{
				array[0] = Tail.Read(null, source);
				add.Invoke(obj, array);
			}
			ProtoReader.EndSubItem(token, source);
		}
		else
		{
			do
			{
				array[0] = Tail.Read(null, source);
				add.Invoke(obj, array);
			}
			while (source.TryReadFieldHeader(field));
		}
		return finish.Invoke(obj, null);
	}

	protected override void EmitRead(CompilerContext ctx, Local valueFrom)
	{
		using Local local2 = (base.AppendToCollection ? ctx.GetLocalWithValue(ExpectedType, valueFrom) : null);
		using Local local = new Local(ctx, builderFactory.ReturnType);
		ctx.EmitCall(builderFactory);
		ctx.StoreValue(local);
		if (base.AppendToCollection)
		{
			CodeLabel label = ctx.DefineLabel();
			if (!ExpectedType.IsValueType)
			{
				ctx.LoadValue(local2);
				ctx.BranchIfFalse(label, @short: false);
			}
			PropertyInfo property = Helpers.GetProperty(ExpectedType, "Length", nonPublic: false);
			if ((object)property == null)
			{
				property = Helpers.GetProperty(ExpectedType, "Count", nonPublic: false);
			}
			if ((object)property == null)
			{
				property = Helpers.GetProperty(ResolveIReadOnlyCollection(ExpectedType, Tail.ExpectedType), "Count", nonPublic: false);
			}
			ctx.LoadAddress(local2, local2.Type);
			ctx.EmitCall(Helpers.GetGetMethod(property, nonPublic: false, allowInternal: false));
			ctx.BranchIfFalse(label, @short: false);
			Type type = ctx.MapType(typeof(void));
			if ((object)addRange != null)
			{
				ctx.LoadValue(local);
				ctx.LoadValue(local2);
				ctx.EmitCall(addRange);
				if ((object)addRange.ReturnType != null && (object)add.ReturnType != type)
				{
					ctx.DiscardValue();
				}
			}
			else
			{
				MethodInfo moveNext;
				MethodInfo current;
				MethodInfo enumeratorInfo = GetEnumeratorInfo(ctx.Model, out moveNext, out current);
				Type returnType = enumeratorInfo.ReturnType;
				using Local local3 = new Local(ctx, returnType);
				ctx.LoadAddress(local2, ExpectedType);
				ctx.EmitCall(enumeratorInfo);
				ctx.StoreValue(local3);
				using (ctx.Using(local3))
				{
					CodeLabel label2 = ctx.DefineLabel();
					CodeLabel label3 = ctx.DefineLabel();
					ctx.Branch(label3, @short: false);
					ctx.MarkLabel(label2);
					ctx.LoadAddress(local, local.Type);
					ctx.LoadAddress(local3, returnType);
					ctx.EmitCall(current);
					ctx.EmitCall(add);
					if ((object)add.ReturnType != null && (object)add.ReturnType != type)
					{
						ctx.DiscardValue();
					}
					ctx.MarkLabel(label3);
					ctx.LoadAddress(local3, returnType);
					ctx.EmitCall(moveNext);
					ctx.BranchIfTrue(label2, @short: false);
				}
			}
			ctx.MarkLabel(label);
		}
		ListDecorator.EmitReadList(ctx, local, Tail, add, packedWireType, castListForAdd: false);
		ctx.LoadAddress(local, local.Type);
		ctx.EmitCall(finish);
		if ((object)ExpectedType != finish.ReturnType)
		{
			ctx.Cast(ExpectedType);
		}
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class NullDecorator : ProtoDecoratorBase
{
	public const int Tag = 1;

	private readonly Type expectedType;

	public override Type ExpectedType => expectedType;

	public override bool ReturnsValue => true;

	public override bool RequiresOldValue => true;

	public NullDecorator(TypeModel model, IProtoSerializer tail)
		: base(tail)
	{
		if (!tail.ReturnsValue)
		{
			throw new NotSupportedException("NullDecorator only supports implementations that return values");
		}
		Type type = tail.ExpectedType;
		if (Helpers.IsValueType(type))
		{
			expectedType = model.MapType(typeof(Nullable<>)).MakeGenericType(type);
		}
		else
		{
			expectedType = type;
		}
	}

	protected override void EmitRead(CompilerContext ctx, Local valueFrom)
	{
		using Local local3 = ctx.GetLocalWithValue(expectedType, valueFrom);
		using Local local = new Local(ctx, ctx.MapType(typeof(SubItemToken)));
		using Local local2 = new Local(ctx, ctx.MapType(typeof(int)));
		ctx.LoadReaderWriter();
		ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("StartSubItem"));
		ctx.StoreValue(local);
		CodeLabel label = ctx.DefineLabel();
		CodeLabel label2 = ctx.DefineLabel();
		CodeLabel label3 = ctx.DefineLabel();
		ctx.MarkLabel(label);
		ctx.EmitBasicRead("ReadFieldHeader", ctx.MapType(typeof(int)));
		ctx.CopyValue();
		ctx.StoreValue(local2);
		ctx.LoadValue(1);
		ctx.BranchIfEqual(label2, @short: true);
		ctx.LoadValue(local2);
		ctx.LoadValue(1);
		ctx.BranchIfLess(label3, @short: false);
		ctx.LoadReaderWriter();
		ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("SkipField"));
		ctx.Branch(label, @short: true);
		ctx.MarkLabel(label2);
		if (Tail.RequiresOldValue)
		{
			if (expectedType.IsValueType)
			{
				ctx.LoadAddress(local3, expectedType);
				ctx.EmitCall(expectedType.GetMethod("GetValueOrDefault", Helpers.EmptyTypes));
			}
			else
			{
				ctx.LoadValue(local3);
			}
		}
		Tail.EmitRead(ctx, null);
		if (expectedType.IsValueType)
		{
			ctx.EmitCtor(expectedType, Tail.ExpectedType);
		}
		ctx.StoreValue(local3);
		ctx.Branch(label, @short: false);
		ctx.MarkLabel(label3);
		ctx.LoadValue(local);
		ctx.LoadReaderWriter();
		ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("EndSubItem"));
		ctx.LoadValue(local3);
	}

	protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		using Local local2 = ctx.GetLocalWithValue(expectedType, valueFrom);
		using Local local = new Local(ctx, ctx.MapType(typeof(SubItemToken)));
		ctx.LoadNullRef();
		ctx.LoadReaderWriter();
		ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("StartSubItem"));
		ctx.StoreValue(local);
		if (expectedType.IsValueType)
		{
			ctx.LoadAddress(local2, expectedType);
			ctx.LoadValue(expectedType.GetProperty("HasValue"));
		}
		else
		{
			ctx.LoadValue(local2);
		}
		CodeLabel label = ctx.DefineLabel();
		ctx.BranchIfFalse(label, @short: false);
		if (expectedType.IsValueType)
		{
			ctx.LoadAddress(local2, expectedType);
			ctx.EmitCall(expectedType.GetMethod("GetValueOrDefault", Helpers.EmptyTypes));
		}
		else
		{
			ctx.LoadValue(local2);
		}
		Tail.EmitWrite(ctx, null);
		ctx.MarkLabel(label);
		ctx.LoadValue(local);
		ctx.LoadReaderWriter();
		ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("EndSubItem"));
	}

	public override object Read(object value, ProtoReader source)
	{
		SubItemToken token = ProtoReader.StartSubItem(source);
		int num;
		while ((num = source.ReadFieldHeader()) > 0)
		{
			if (num == 1)
			{
				value = Tail.Read(value, source);
			}
			else
			{
				source.SkipField();
			}
		}
		ProtoReader.EndSubItem(token, source);
		return value;
	}

	public override void Write(object value, ProtoWriter dest)
	{
		SubItemToken token = ProtoWriter.StartSubItem(null, dest);
		if (value != null)
		{
			Tail.Write(value, dest);
		}
		ProtoWriter.EndSubItem(token, dest);
	}
}


using System;
using System.Reflection;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class ParseableSerializer : IProtoSerializer
{
	private readonly MethodInfo parse;

	public Type ExpectedType => parse.DeclaringType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public static ParseableSerializer TryCreate(Type type, TypeModel model)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		MethodInfo method = type.GetMethod("Parse", BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public, null, new Type[1] { model.MapType(typeof(string)) }, null);
		if ((object)method != null && (object)method.ReturnType == type)
		{
			if (Helpers.IsValueType(type))
			{
				MethodInfo customToString = GetCustomToString(type);
				if ((object)customToString == null || (object)customToString.ReturnType != model.MapType(typeof(string)))
				{
					return null;
				}
			}
			return new ParseableSerializer(method);
		}
		return null;
	}

	private static MethodInfo GetCustomToString(Type type)
	{
		return type.GetMethod("ToString", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public, null, Helpers.EmptyTypes, null);
	}

	private ParseableSerializer(MethodInfo parse)
	{
		this.parse = parse;
	}

	public object Read(object value, ProtoReader source)
	{
		return parse.Invoke(null, new object[1] { source.ReadString() });
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteString(value.ToString(), dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		Type expectedType = ExpectedType;
		if (expectedType.IsValueType)
		{
			using Local local = ctx.GetLocalWithValue(expectedType, valueFrom);
			ctx.LoadAddress(local, expectedType);
			ctx.EmitCall(GetCustomToString(expectedType));
		}
		else
		{
			ctx.EmitCall(ctx.MapType(typeof(object)).GetMethod("ToString"));
		}
		ctx.EmitBasicWrite("WriteString", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadString", ctx.MapType(typeof(string)));
		ctx.EmitCall(parse);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class NetObjectSerializer : IProtoSerializer
{
	private readonly int key;

	private readonly Type type;

	private readonly BclHelpers.NetObjectOptions options;

	public Type ExpectedType => type;

	public bool ReturnsValue => true;

	public bool RequiresOldValue => true;

	public NetObjectSerializer(TypeModel model, Type type, int key, BclHelpers.NetObjectOptions options)
	{
		bool flag = (options & BclHelpers.NetObjectOptions.DynamicType) != 0;
		this.key = (flag ? (-1) : key);
		this.type = (flag ? model.MapType(typeof(object)) : type);
		this.options = options;
	}

	public object Read(object value, ProtoReader source)
	{
		return BclHelpers.ReadNetObject(value, source, key, ((object)type == typeof(object)) ? null : type, options);
	}

	public void Write(object value, ProtoWriter dest)
	{
		BclHelpers.WriteNetObject(value, dest, key, options);
	}

	public void EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.LoadValue(valueFrom);
		ctx.CastToObject(type);
		ctx.LoadReaderWriter();
		ctx.LoadValue(ctx.MapMetaKeyToCompiledKey(key));
		if ((object)type == ctx.MapType(typeof(object)))
		{
			ctx.LoadNullRef();
		}
		else
		{
			ctx.LoadValue(type);
		}
		ctx.LoadValue((int)options);
		ctx.EmitCall(ctx.MapType(typeof(BclHelpers)).GetMethod("ReadNetObject"));
		ctx.CastFromObject(type);
	}

	public void EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.LoadValue(valueFrom);
		ctx.CastToObject(type);
		ctx.LoadReaderWriter();
		ctx.LoadValue(ctx.MapMetaKeyToCompiledKey(key));
		ctx.LoadValue((int)options);
		ctx.EmitCall(ctx.MapType(typeof(BclHelpers)).GetMethod("WriteNetObject"));
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class SByteSerializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(sbyte);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public SByteSerializer(TypeModel model)
	{
	}

	public object Read(object value, ProtoReader source)
	{
		return source.ReadSByte();
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteSByte((sbyte)value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteSByte", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadSByte", ExpectedType);
	}
}


using System;
using System.Reflection;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Serializers;

internal sealed class MemberSpecifiedDecorator : ProtoDecoratorBase
{
	private readonly MethodInfo getSpecified;

	private readonly MethodInfo setSpecified;

	public override Type ExpectedType => Tail.ExpectedType;

	public override bool RequiresOldValue => Tail.RequiresOldValue;

	public override bool ReturnsValue => Tail.ReturnsValue;

	public MemberSpecifiedDecorator(MethodInfo getSpecified, MethodInfo setSpecified, IProtoSerializer tail)
		: base(tail)
	{
		if ((object)getSpecified == null && (object)setSpecified == null)
		{
			throw new InvalidOperationException();
		}
		this.getSpecified = getSpecified;
		this.setSpecified = setSpecified;
	}

	public override void Write(object value, ProtoWriter dest)
	{
		if ((object)getSpecified == null || (bool)getSpecified.Invoke(value, null))
		{
			Tail.Write(value, dest);
		}
	}

	public override object Read(object value, ProtoReader source)
	{
		object result = Tail.Read(value, source);
		if ((object)setSpecified != null)
		{
			setSpecified.Invoke(value, new object[1] { true });
		}
		return result;
	}

	protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		if ((object)getSpecified == null)
		{
			Tail.EmitWrite(ctx, valueFrom);
			return;
		}
		using Local local = ctx.GetLocalWithValue(ExpectedType, valueFrom);
		ctx.LoadAddress(local, ExpectedType);
		ctx.EmitCall(getSpecified);
		CodeLabel label = ctx.DefineLabel();
		ctx.BranchIfFalse(label, @short: false);
		Tail.EmitWrite(ctx, local);
		ctx.MarkLabel(label);
	}

	protected override void EmitRead(CompilerContext ctx, Local valueFrom)
	{
		if ((object)setSpecified == null)
		{
			Tail.EmitRead(ctx, valueFrom);
			return;
		}
		using Local local = ctx.GetLocalWithValue(ExpectedType, valueFrom);
		Tail.EmitRead(ctx, local);
		ctx.LoadAddress(local, ExpectedType);
		ctx.LoadValue(1);
		ctx.EmitCall(setSpecified);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class SystemTypeSerializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(Type);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public SystemTypeSerializer(TypeModel model)
	{
	}

	void IProtoSerializer.Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteType((Type)value, dest);
	}

	object IProtoSerializer.Read(object value, ProtoReader source)
	{
		return source.ReadType();
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteType", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadType", ExpectedType);
	}
}


using System;
using System.Reflection;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class TupleSerializer : IProtoTypeSerializer, IProtoSerializer
{
	private readonly MemberInfo[] members;

	private readonly ConstructorInfo ctor;

	private IProtoSerializer[] tails;

	public Type ExpectedType => ctor.DeclaringType;

	public bool RequiresOldValue => true;

	public bool ReturnsValue => false;

	public TupleSerializer(RuntimeTypeModel model, ConstructorInfo ctor, MemberInfo[] members)
	{
		if ((object)ctor == null)
		{
			throw new ArgumentNullException("ctor");
		}
		if (members == null)
		{
			throw new ArgumentNullException("members");
		}
		this.ctor = ctor;
		this.members = members;
		tails = new IProtoSerializer[members.Length];
		ParameterInfo[] parameters = ctor.GetParameters();
		for (int i = 0; i < members.Length; i++)
		{
			Type parameterType = parameters[i].ParameterType;
			Type itemType = null;
			Type defaultType = null;
			MetaType.ResolveListTypes(model, parameterType, ref itemType, ref defaultType);
			Type type = (((object)itemType == null) ? parameterType : itemType);
			bool asReference = false;
			int num = model.FindOrAddAuto(type, demand: false, addWithContractOnly: true, addEvenIfAutoDisabled: false);
			if (num >= 0)
			{
				asReference = model[type].AsReferenceDefault;
			}
			IProtoSerializer protoSerializer = ValueMember.TryGetCoreSerializer(model, DataFormat.Default, type, out var defaultWireType, asReference, dynamicType: false, overwriteList: false, allowComplexTypes: true);
			if (protoSerializer == null)
			{
				throw new InvalidOperationException("No serializer defined for type: " + type.FullName);
			}
			protoSerializer = new TagDecorator(i + 1, defaultWireType, strict: false, protoSerializer);
			IProtoSerializer protoSerializer2 = (((object)itemType != null) ? ((!parameterType.IsArray) ? ((ProtoDecoratorBase)ListDecorator.Create(model, parameterType, defaultType, protoSerializer, i + 1, writePacked: false, defaultWireType, returnList: true, overwriteList: false, supportNull: false)) : ((ProtoDecoratorBase)new ArrayDecorator(model, protoSerializer, i + 1, writePacked: false, defaultWireType, parameterType, overwriteList: false, supportNull: false))) : protoSerializer);
			tails[i] = protoSerializer2;
		}
	}

	public bool HasCallbacks(TypeModel.CallbackType callbackType)
	{
		return false;
	}

	public void EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
	{
	}

	void IProtoTypeSerializer.Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context)
	{
	}

	object IProtoTypeSerializer.CreateInstance(ProtoReader source)
	{
		throw new NotSupportedException();
	}

	private object GetValue(object obj, int index)
	{
		if (members[index] is PropertyInfo propertyInfo)
		{
			if (obj == null)
			{
				if (!Helpers.IsValueType(propertyInfo.PropertyType))
				{
					return null;
				}
				return Activator.CreateInstance(propertyInfo.PropertyType);
			}
			return propertyInfo.GetValue(obj, null);
		}
		if (members[index] is FieldInfo fieldInfo)
		{
			if (obj == null)
			{
				if (!Helpers.IsValueType(fieldInfo.FieldType))
				{
					return null;
				}
				return Activator.CreateInstance(fieldInfo.FieldType);
			}
			return fieldInfo.GetValue(obj);
		}
		throw new InvalidOperationException();
	}

	public object Read(object value, ProtoReader source)
	{
		object[] array = new object[members.Length];
		bool flag = false;
		if (value == null)
		{
			flag = true;
		}
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = GetValue(value, i);
		}
		int num;
		while ((num = source.ReadFieldHeader()) > 0)
		{
			flag = true;
			if (num <= tails.Length)
			{
				IProtoSerializer protoSerializer = tails[num - 1];
				array[num - 1] = tails[num - 1].Read(protoSerializer.RequiresOldValue ? array[num - 1] : null, source);
			}
			else
			{
				source.SkipField();
			}
		}
		if (!flag)
		{
			return value;
		}
		return ctor.Invoke(array);
	}

	public void Write(object value, ProtoWriter dest)
	{
		for (int i = 0; i < tails.Length; i++)
		{
			object value2 = GetValue(value, i);
			if (value2 != null)
			{
				tails[i].Write(value2, dest);
			}
		}
	}

	private Type GetMemberType(int index)
	{
		Type memberType = Helpers.GetMemberType(members[index]);
		if ((object)memberType == null)
		{
			throw new InvalidOperationException();
		}
		return memberType;
	}

	bool IProtoTypeSerializer.CanCreateInstance()
	{
		return false;
	}

	public void EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		using Local local = ctx.GetLocalWithValue(ctor.DeclaringType, valueFrom);
		for (int i = 0; i < tails.Length; i++)
		{
			Type memberType = GetMemberType(i);
			ctx.LoadAddress(local, ExpectedType);
			switch (members[i].MemberType)
			{
			case MemberTypes.Field:
				ctx.LoadValue((FieldInfo)members[i]);
				break;
			case MemberTypes.Property:
				ctx.LoadValue((PropertyInfo)members[i]);
				break;
			}
			ctx.WriteNullCheckedTail(memberType, tails[i], null);
		}
	}

	void IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
	{
		throw new NotSupportedException();
	}

	public void EmitRead(CompilerContext ctx, Local incoming)
	{
		using Local local = ctx.GetLocalWithValue(ExpectedType, incoming);
		Local[] array = new Local[members.Length];
		try
		{
			for (int i = 0; i < array.Length; i++)
			{
				Type memberType = GetMemberType(i);
				bool flag = true;
				array[i] = new Local(ctx, memberType);
				if (ExpectedType.IsValueType)
				{
					continue;
				}
				if (memberType.IsValueType)
				{
					switch (Helpers.GetTypeCode(memberType))
					{
					case ProtoTypeCode.Boolean:
					case ProtoTypeCode.SByte:
					case ProtoTypeCode.Byte:
					case ProtoTypeCode.Int16:
					case ProtoTypeCode.UInt16:
					case ProtoTypeCode.Int32:
					case ProtoTypeCode.UInt32:
						ctx.LoadValue(0);
						break;
					case ProtoTypeCode.Int64:
					case ProtoTypeCode.UInt64:
						ctx.LoadValue(0L);
						break;
					case ProtoTypeCode.Single:
						ctx.LoadValue(0f);
						break;
					case ProtoTypeCode.Double:
						ctx.LoadValue(0.0);
						break;
					case ProtoTypeCode.Decimal:
						ctx.LoadValue(0m);
						break;
					case ProtoTypeCode.Guid:
						ctx.LoadValue(Guid.Empty);
						break;
					default:
						ctx.LoadAddress(array[i], memberType);
						ctx.EmitCtor(memberType);
						flag = false;
						break;
					}
				}
				else
				{
					ctx.LoadNullRef();
				}
				if (flag)
				{
					ctx.StoreValue(array[i]);
				}
			}
			CodeLabel label = (ExpectedType.IsValueType ? default(CodeLabel) : ctx.DefineLabel());
			if (!ExpectedType.IsValueType)
			{
				ctx.LoadAddress(local, ExpectedType);
				ctx.BranchIfFalse(label, @short: false);
			}
			for (int j = 0; j < members.Length; j++)
			{
				ctx.LoadAddress(local, ExpectedType);
				switch (members[j].MemberType)
				{
				case MemberTypes.Field:
					ctx.LoadValue((FieldInfo)members[j]);
					break;
				case MemberTypes.Property:
					ctx.LoadValue((PropertyInfo)members[j]);
					break;
				}
				ctx.StoreValue(array[j]);
			}
			if (!ExpectedType.IsValueType)
			{
				ctx.MarkLabel(label);
			}
			using (Local local2 = new Local(ctx, ctx.MapType(typeof(int))))
			{
				CodeLabel label2 = ctx.DefineLabel();
				CodeLabel label3 = ctx.DefineLabel();
				CodeLabel label4 = ctx.DefineLabel();
				ctx.Branch(label2, @short: false);
				CodeLabel[] array2 = new CodeLabel[members.Length];
				for (int k = 0; k < members.Length; k++)
				{
					ref CodeLabel reference = ref array2[k];
					reference = ctx.DefineLabel();
				}
				ctx.MarkLabel(label3);
				ctx.LoadValue(local2);
				ctx.LoadValue(1);
				ctx.Subtract();
				ctx.Switch(array2);
				ctx.Branch(label4, @short: false);
				for (int l = 0; l < array2.Length; l++)
				{
					ctx.MarkLabel(array2[l]);
					IProtoSerializer protoSerializer = tails[l];
					Local valueFrom = (protoSerializer.RequiresOldValue ? array[l] : null);
					ctx.ReadNullCheckedTail(array[l].Type, protoSerializer, valueFrom);
					if (protoSerializer.ReturnsValue)
					{
						if (array[l].Type.IsValueType)
						{
							ctx.StoreValue(array[l]);
						}
						else
						{
							CodeLabel label5 = ctx.DefineLabel();
							CodeLabel label6 = ctx.DefineLabel();
							ctx.CopyValue();
							ctx.BranchIfTrue(label5, @short: true);
							ctx.DiscardValue();
							ctx.Branch(label6, @short: true);
							ctx.MarkLabel(label5);
							ctx.StoreValue(array[l]);
							ctx.MarkLabel(label6);
						}
					}
					ctx.Branch(label2, @short: false);
				}
				ctx.MarkLabel(label4);
				ctx.LoadReaderWriter();
				ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("SkipField"));
				ctx.MarkLabel(label2);
				ctx.EmitBasicRead("ReadFieldHeader", ctx.MapType(typeof(int)));
				ctx.CopyValue();
				ctx.StoreValue(local2);
				ctx.LoadValue(0);
				ctx.BranchIfGreater(label3, @short: false);
			}
			for (int m = 0; m < array.Length; m++)
			{
				ctx.LoadValue(array[m]);
			}
			ctx.EmitCtor(ctor);
			ctx.StoreValue(local);
		}
		finally
		{
			for (int n = 0; n < array.Length; n++)
			{
				if (array[n] != null)
				{
					array[n].Dispose();
				}
			}
		}
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class UriDecorator : ProtoDecoratorBase
{
	private static readonly Type expectedType = typeof(Uri);

	public override Type ExpectedType => expectedType;

	public override bool RequiresOldValue => false;

	public override bool ReturnsValue => true;

	public UriDecorator(TypeModel model, IProtoSerializer tail)
		: base(tail)
	{
	}

	public override void Write(object value, ProtoWriter dest)
	{
		Tail.Write(((Uri)value).AbsoluteUri, dest);
	}

	public override object Read(object value, ProtoReader source)
	{
		string text = (string)Tail.Read(null, source);
		if (text.Length != 0)
		{
			return new Uri(text);
		}
		return null;
	}

	protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.LoadValue(valueFrom);
		ctx.LoadValue(typeof(Uri).GetProperty("AbsoluteUri"));
		Tail.EmitWrite(ctx, null);
	}

	protected override void EmitRead(CompilerContext ctx, Local valueFrom)
	{
		Tail.EmitRead(ctx, valueFrom);
		ctx.CopyValue();
		CodeLabel label = ctx.DefineLabel();
		CodeLabel label2 = ctx.DefineLabel();
		ctx.LoadValue(typeof(string).GetProperty("Length"));
		ctx.BranchIfTrue(label, @short: true);
		ctx.DiscardValue();
		ctx.LoadNullRef();
		ctx.Branch(label2, @short: true);
		ctx.MarkLabel(label);
		ctx.EmitCtor(ctx.MapType(typeof(Uri)), ctx.MapType(typeof(string)));
		ctx.MarkLabel(label2);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class EnumSerializer : IProtoSerializer
{
	public struct EnumPair
	{
		public readonly object RawValue;

		public readonly Enum TypedValue;

		public readonly int WireValue;

		public EnumPair(int wireValue, object raw, Type type)
		{
			WireValue = wireValue;
			RawValue = raw;
			TypedValue = (Enum)Enum.ToObject(type, raw);
		}
	}

	private readonly Type enumType;

	private readonly EnumPair[] map;

	public Type ExpectedType => enumType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public EnumSerializer(Type enumType, EnumPair[] map)
	{
		if ((object)enumType == null)
		{
			throw new ArgumentNullException("enumType");
		}
		this.enumType = enumType;
		this.map = map;
		if (map == null)
		{
			return;
		}
		for (int i = 1; i < map.Length; i++)
		{
			for (int j = 0; j < i; j++)
			{
				if (map[i].WireValue == map[j].WireValue && !object.Equals(map[i].RawValue, map[j].RawValue))
				{
					int wireValue = map[i].WireValue;
					throw new ProtoException("Multiple enums with wire-value " + wireValue);
				}
				if (object.Equals(map[i].RawValue, map[j].RawValue) && map[i].WireValue != map[j].WireValue)
				{
					throw new ProtoException("Multiple enums with deserialized-value " + map[i].RawValue);
				}
			}
		}
	}

	private ProtoTypeCode GetTypeCode()
	{
		Type underlyingType = Helpers.GetUnderlyingType(enumType);
		if ((object)underlyingType == null)
		{
			underlyingType = enumType;
		}
		return Helpers.GetTypeCode(underlyingType);
	}

	private int EnumToWire(object value)
	{
		return GetTypeCode() switch
		{
			ProtoTypeCode.Byte => (byte)value, 
			ProtoTypeCode.SByte => (sbyte)value, 
			ProtoTypeCode.Int16 => (short)value, 
			ProtoTypeCode.Int32 => (int)value, 
			ProtoTypeCode.Int64 => (int)(long)value, 
			ProtoTypeCode.UInt16 => (ushort)value, 
			ProtoTypeCode.UInt32 => (int)(uint)value, 
			ProtoTypeCode.UInt64 => (int)(ulong)value, 
			_ => throw new InvalidOperationException(), 
		};
	}

	private object WireToEnum(int value)
	{
		return GetTypeCode() switch
		{
			ProtoTypeCode.Byte => Enum.ToObject(enumType, (byte)value), 
			ProtoTypeCode.SByte => Enum.ToObject(enumType, (sbyte)value), 
			ProtoTypeCode.Int16 => Enum.ToObject(enumType, (short)value), 
			ProtoTypeCode.Int32 => Enum.ToObject(enumType, value), 
			ProtoTypeCode.Int64 => Enum.ToObject(enumType, (long)value), 
			ProtoTypeCode.UInt16 => Enum.ToObject(enumType, (ushort)value), 
			ProtoTypeCode.UInt32 => Enum.ToObject(enumType, (uint)value), 
			ProtoTypeCode.UInt64 => Enum.ToObject(enumType, (ulong)value), 
			_ => throw new InvalidOperationException(), 
		};
	}

	public object Read(object value, ProtoReader source)
	{
		int num = source.ReadInt32();
		if (map == null)
		{
			return WireToEnum(num);
		}
		for (int i = 0; i < map.Length; i++)
		{
			if (map[i].WireValue == num)
			{
				return map[i].TypedValue;
			}
		}
		source.ThrowEnumException(ExpectedType, num);
		return null;
	}

	public void Write(object value, ProtoWriter dest)
	{
		if (map == null)
		{
			ProtoWriter.WriteInt32(EnumToWire(value), dest);
			return;
		}
		for (int i = 0; i < map.Length; i++)
		{
			if (object.Equals(map[i].TypedValue, value))
			{
				ProtoWriter.WriteInt32(map[i].WireValue, dest);
				return;
			}
		}
		ProtoWriter.ThrowEnumException(dest, value);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ProtoTypeCode typeCode = GetTypeCode();
		if (map == null)
		{
			ctx.LoadValue(valueFrom);
			ctx.ConvertToInt32(typeCode, uint32Overflow: false);
			ctx.EmitBasicWrite("WriteInt32", null);
			return;
		}
		using Local local = ctx.GetLocalWithValue(ExpectedType, valueFrom);
		CodeLabel label = ctx.DefineLabel();
		for (int i = 0; i < map.Length; i++)
		{
			CodeLabel label2 = ctx.DefineLabel();
			CodeLabel label3 = ctx.DefineLabel();
			ctx.LoadValue(local);
			WriteEnumValue(ctx, typeCode, map[i].RawValue);
			ctx.BranchIfEqual(label3, @short: true);
			ctx.Branch(label2, @short: true);
			ctx.MarkLabel(label3);
			ctx.LoadValue(map[i].WireValue);
			ctx.EmitBasicWrite("WriteInt32", null);
			ctx.Branch(label, @short: false);
			ctx.MarkLabel(label2);
		}
		ctx.LoadReaderWriter();
		ctx.LoadValue(local);
		ctx.CastToObject(ExpectedType);
		ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("ThrowEnumException"));
		ctx.MarkLabel(label);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ProtoTypeCode typeCode = GetTypeCode();
		if (map == null)
		{
			ctx.EmitBasicRead("ReadInt32", ctx.MapType(typeof(int)));
			ctx.ConvertFromInt32(typeCode, uint32Overflow: false);
			return;
		}
		int[] array = new int[map.Length];
		object[] array2 = new object[map.Length];
		for (int i = 0; i < map.Length; i++)
		{
			array[i] = map[i].WireValue;
			array2[i] = map[i].RawValue;
		}
		using Local local2 = new Local(ctx, ExpectedType);
		using Local local = new Local(ctx, ctx.MapType(typeof(int)));
		ctx.EmitBasicRead("ReadInt32", ctx.MapType(typeof(int)));
		ctx.StoreValue(local);
		CodeLabel codeLabel = ctx.DefineLabel();
		BasicList.NodeEnumerator enumerator = BasicList.GetContiguousGroups(array, array2).GetEnumerator();
		while (enumerator.MoveNext())
		{
			BasicList.Group group = (BasicList.Group)enumerator.Current;
			CodeLabel label = ctx.DefineLabel();
			int count = group.Items.Count;
			if (count == 1)
			{
				ctx.LoadValue(local);
				ctx.LoadValue(group.First);
				CodeLabel codeLabel2 = ctx.DefineLabel();
				ctx.BranchIfEqual(codeLabel2, @short: true);
				ctx.Branch(label, @short: false);
				WriteEnumValue(ctx, typeCode, codeLabel2, codeLabel, group.Items[0], local2);
			}
			else
			{
				ctx.LoadValue(local);
				ctx.LoadValue(group.First);
				ctx.Subtract();
				CodeLabel[] array3 = new CodeLabel[count];
				for (int j = 0; j < count; j++)
				{
					ref CodeLabel reference = ref array3[j];
					reference = ctx.DefineLabel();
				}
				ctx.Switch(array3);
				ctx.Branch(label, @short: false);
				for (int k = 0; k < count; k++)
				{
					WriteEnumValue(ctx, typeCode, array3[k], codeLabel, group.Items[k], local2);
				}
			}
			ctx.MarkLabel(label);
		}
		ctx.LoadReaderWriter();
		ctx.LoadValue(ExpectedType);
		ctx.LoadValue(local);
		ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("ThrowEnumException"));
		ctx.MarkLabel(codeLabel);
		ctx.LoadValue(local2);
	}

	private static void WriteEnumValue(CompilerContext ctx, ProtoTypeCode typeCode, object value)
	{
		switch (typeCode)
		{
		case ProtoTypeCode.Byte:
			ctx.LoadValue((byte)value);
			break;
		case ProtoTypeCode.SByte:
			ctx.LoadValue((sbyte)value);
			break;
		case ProtoTypeCode.Int16:
			ctx.LoadValue((short)value);
			break;
		case ProtoTypeCode.Int32:
			ctx.LoadValue((int)value);
			break;
		case ProtoTypeCode.Int64:
			ctx.LoadValue((long)value);
			break;
		case ProtoTypeCode.UInt16:
			ctx.LoadValue((ushort)value);
			break;
		case ProtoTypeCode.UInt32:
			ctx.LoadValue((int)(uint)value);
			break;
		case ProtoTypeCode.UInt64:
			ctx.LoadValue((long)(ulong)value);
			break;
		default:
			throw new InvalidOperationException();
		}
	}

	private static void WriteEnumValue(CompilerContext ctx, ProtoTypeCode typeCode, CodeLabel handler, CodeLabel @continue, object value, Local local)
	{
		ctx.MarkLabel(handler);
		WriteEnumValue(ctx, typeCode, value);
		ctx.StoreValue(local);
		ctx.Branch(@continue, @short: false);
	}
}


using System;

public struct EnumPair
{
	public readonly object RawValue;

	public readonly Enum TypedValue;

	public readonly int WireValue;

	public EnumPair(int wireValue, object raw, Type type)
	{
		WireValue = wireValue;
		RawValue = raw;
		TypedValue = (Enum)Enum.ToObject(type, raw);
	}
}


using System;
using System.Reflection;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class DefaultValueDecorator : ProtoDecoratorBase
{
	private readonly object defaultValue;

	public override Type ExpectedType => Tail.ExpectedType;

	public override bool RequiresOldValue => Tail.RequiresOldValue;

	public override bool ReturnsValue => Tail.ReturnsValue;

	public DefaultValueDecorator(TypeModel model, object defaultValue, IProtoSerializer tail)
		: base(tail)
	{
		if (defaultValue == null)
		{
			throw new ArgumentNullException("defaultValue");
		}
		Type type = model.MapType(defaultValue.GetType());
		if ((object)type != tail.ExpectedType)
		{
			throw new ArgumentException("Default value is of incorrect type", "defaultValue");
		}
		this.defaultValue = defaultValue;
	}

	public override void Write(object value, ProtoWriter dest)
	{
		if (!object.Equals(value, defaultValue))
		{
			Tail.Write(value, dest);
		}
	}

	public override object Read(object value, ProtoReader source)
	{
		return Tail.Read(value, source);
	}

	protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		CodeLabel label = ctx.DefineLabel();
		if (valueFrom == null)
		{
			ctx.CopyValue();
			CodeLabel label2 = ctx.DefineLabel();
			EmitBranchIfDefaultValue(ctx, label2);
			Tail.EmitWrite(ctx, null);
			ctx.Branch(label, @short: true);
			ctx.MarkLabel(label2);
			ctx.DiscardValue();
		}
		else
		{
			ctx.LoadValue(valueFrom);
			EmitBranchIfDefaultValue(ctx, label);
			Tail.EmitWrite(ctx, valueFrom);
		}
		ctx.MarkLabel(label);
	}

	private void EmitBeq(CompilerContext ctx, CodeLabel label, Type type)
	{
		switch (Helpers.GetTypeCode(type))
		{
		case ProtoTypeCode.Boolean:
		case ProtoTypeCode.Char:
		case ProtoTypeCode.SByte:
		case ProtoTypeCode.Byte:
		case ProtoTypeCode.Int16:
		case ProtoTypeCode.UInt16:
		case ProtoTypeCode.Int32:
		case ProtoTypeCode.UInt32:
		case ProtoTypeCode.Int64:
		case ProtoTypeCode.UInt64:
		case ProtoTypeCode.Single:
		case ProtoTypeCode.Double:
			ctx.BranchIfEqual(label, @short: false);
			return;
		}
		MethodInfo method = type.GetMethod("op_Equality", BindingFlags.Static | BindingFlags.Public, null, new Type[2] { type, type }, null);
		if ((object)method == null || (object)method.ReturnType != ctx.MapType(typeof(bool)))
		{
			throw new InvalidOperationException("No suitable equality operator found for default-values of type: " + type.FullName);
		}
		ctx.EmitCall(method);
		ctx.BranchIfTrue(label, @short: false);
	}

	private void EmitBranchIfDefaultValue(CompilerContext ctx, CodeLabel label)
	{
		Type expectedType = ExpectedType;
		switch (Helpers.GetTypeCode(expectedType))
		{
		case ProtoTypeCode.Boolean:
			if ((bool)defaultValue)
			{
				ctx.BranchIfTrue(label, @short: false);
			}
			else
			{
				ctx.BranchIfFalse(label, @short: false);
			}
			break;
		case ProtoTypeCode.Byte:
			if ((byte)defaultValue == 0)
			{
				ctx.BranchIfFalse(label, @short: false);
				break;
			}
			ctx.LoadValue((byte)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.SByte:
			if ((sbyte)defaultValue == 0)
			{
				ctx.BranchIfFalse(label, @short: false);
				break;
			}
			ctx.LoadValue((sbyte)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.Int16:
			if ((short)defaultValue == 0)
			{
				ctx.BranchIfFalse(label, @short: false);
				break;
			}
			ctx.LoadValue((short)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.UInt16:
			if ((ushort)defaultValue == 0)
			{
				ctx.BranchIfFalse(label, @short: false);
				break;
			}
			ctx.LoadValue((ushort)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.Int32:
			if ((int)defaultValue == 0)
			{
				ctx.BranchIfFalse(label, @short: false);
				break;
			}
			ctx.LoadValue((int)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.UInt32:
			if ((uint)defaultValue == 0)
			{
				ctx.BranchIfFalse(label, @short: false);
				break;
			}
			ctx.LoadValue((int)(uint)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.Char:
			if ((char)defaultValue == '\0')
			{
				ctx.BranchIfFalse(label, @short: false);
				break;
			}
			ctx.LoadValue((char)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.Int64:
			ctx.LoadValue((long)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.UInt64:
			ctx.LoadValue((long)(ulong)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.Double:
			ctx.LoadValue((double)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.Single:
			ctx.LoadValue((float)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.String:
			ctx.LoadValue((string)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.Decimal:
		{
			decimal value = (decimal)defaultValue;
			ctx.LoadValue(value);
			EmitBeq(ctx, label, expectedType);
			break;
		}
		case ProtoTypeCode.TimeSpan:
		{
			TimeSpan timeSpan = (TimeSpan)defaultValue;
			if (timeSpan == TimeSpan.Zero)
			{
				ctx.LoadValue(typeof(TimeSpan).GetField("Zero"));
			}
			else
			{
				ctx.LoadValue(timeSpan.Ticks);
				ctx.EmitCall(ctx.MapType(typeof(TimeSpan)).GetMethod("FromTicks"));
			}
			EmitBeq(ctx, label, expectedType);
			break;
		}
		case ProtoTypeCode.Guid:
			ctx.LoadValue((Guid)defaultValue);
			EmitBeq(ctx, label, expectedType);
			break;
		case ProtoTypeCode.DateTime:
			ctx.LoadValue(((DateTime)defaultValue).ToBinary());
			ctx.EmitCall(ctx.MapType(typeof(DateTime)).GetMethod("FromBinary"));
			EmitBeq(ctx, label, expectedType);
			break;
		default:
			throw new NotSupportedException("Type cannot be represented as a default value: " + expectedType.FullName);
		}
	}

	protected override void EmitRead(CompilerContext ctx, Local valueFrom)
	{
		Tail.EmitRead(ctx, valueFrom);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class GuidSerializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(Guid);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public GuidSerializer(TypeModel model)
	{
	}

	public void Write(object value, ProtoWriter dest)
	{
		BclHelpers.WriteGuid((Guid)value, dest);
	}

	public object Read(object value, ProtoReader source)
	{
		return BclHelpers.ReadGuid(source);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitWrite(ctx.MapType(typeof(BclHelpers)), "WriteGuid", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead(ctx.MapType(typeof(BclHelpers)), "ReadGuid", ExpectedType);
	}
}


using System;
using System.Reflection;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class SurrogateSerializer : IProtoTypeSerializer, IProtoSerializer
{
	private readonly Type forType;

	private readonly Type declaredType;

	private readonly MethodInfo toTail;

	private readonly MethodInfo fromTail;

	private IProtoTypeSerializer rootTail;

	public bool ReturnsValue => false;

	public bool RequiresOldValue => true;

	public Type ExpectedType => forType;

	bool IProtoTypeSerializer.HasCallbacks(TypeModel.CallbackType callbackType)
	{
		return false;
	}

	void IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
	{
	}

	void IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
	{
		throw new NotSupportedException();
	}

	bool IProtoTypeSerializer.CanCreateInstance()
	{
		return false;
	}

	object IProtoTypeSerializer.CreateInstance(ProtoReader source)
	{
		throw new NotSupportedException();
	}

	void IProtoTypeSerializer.Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context)
	{
	}

	public SurrogateSerializer(Type forType, Type declaredType, IProtoTypeSerializer rootTail)
	{
		this.forType = forType;
		this.declaredType = declaredType;
		this.rootTail = rootTail;
		toTail = GetConversion(toTail: true);
		fromTail = GetConversion(toTail: false);
	}

	private static bool HasCast(Type type, Type from, Type to, out MethodInfo op)
	{
		MethodInfo[] methods = type.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		foreach (MethodInfo methodInfo in methods)
		{
			if ((!(methodInfo.Name != "op_Implicit") || !(methodInfo.Name != "op_Explicit")) && (object)methodInfo.ReturnType == to)
			{
				ParameterInfo[] parameters = methodInfo.GetParameters();
				if (parameters.Length == 1 && (object)parameters[0].ParameterType == from)
				{
					op = methodInfo;
					return true;
				}
			}
		}
		op = null;
		return false;
	}

	public MethodInfo GetConversion(bool toTail)
	{
		Type to = (toTail ? declaredType : forType);
		Type from = (toTail ? forType : declaredType);
		if (HasCast(declaredType, from, to, out var op) || HasCast(forType, from, to, out op))
		{
			return op;
		}
		throw new InvalidOperationException("No suitable conversion operator found for surrogate: " + forType.FullName + " / " + declaredType.FullName);
	}

	public void Write(object value, ProtoWriter writer)
	{
		rootTail.Write(toTail.Invoke(null, new object[1] { value }), writer);
	}

	public object Read(object value, ProtoReader source)
	{
		object[] array = new object[1] { value };
		value = toTail.Invoke(null, array);
		array[0] = rootTail.Read(value, source);
		return fromTail.Invoke(null, array);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		using Local local = new Local(ctx, declaredType);
		ctx.LoadValue(valueFrom);
		ctx.EmitCall(toTail);
		ctx.StoreValue(local);
		rootTail.EmitRead(ctx, local);
		ctx.LoadValue(local);
		ctx.EmitCall(fromTail);
		ctx.StoreValue(valueFrom);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.LoadValue(valueFrom);
		ctx.EmitCall(toTail);
		rootTail.EmitWrite(ctx, null);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class Int16Serializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(short);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public Int16Serializer(TypeModel model)
	{
	}

	public object Read(object value, ProtoReader source)
	{
		return source.ReadInt16();
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteInt16((short)value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteInt16", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadInt16", ExpectedType);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class DecimalSerializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(decimal);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public DecimalSerializer(TypeModel model)
	{
	}

	public object Read(object value, ProtoReader source)
	{
		return BclHelpers.ReadDecimal(source);
	}

	public void Write(object value, ProtoWriter dest)
	{
		BclHelpers.WriteDecimal((decimal)value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitWrite(ctx.MapType(typeof(BclHelpers)), "WriteDecimal", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead(ctx.MapType(typeof(BclHelpers)), "ReadDecimal", ExpectedType);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class TimeSpanSerializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(TimeSpan);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public TimeSpanSerializer(TypeModel model)
	{
	}

	public object Read(object value, ProtoReader source)
	{
		return BclHelpers.ReadTimeSpan(source);
	}

	public void Write(object value, ProtoWriter dest)
	{
		BclHelpers.WriteTimeSpan((TimeSpan)value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitWrite(ctx.MapType(typeof(BclHelpers)), "WriteTimeSpan", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead(ctx.MapType(typeof(BclHelpers)), "ReadTimeSpan", ExpectedType);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class DateTimeSerializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(DateTime);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public DateTimeSerializer(TypeModel model)
	{
	}

	public object Read(object value, ProtoReader source)
	{
		return BclHelpers.ReadDateTime(source);
	}

	public void Write(object value, ProtoWriter dest)
	{
		BclHelpers.WriteDateTime((DateTime)value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitWrite(ctx.MapType(typeof(BclHelpers)), "WriteDateTime", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead(ctx.MapType(typeof(BclHelpers)), "ReadDateTime", ExpectedType);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class UInt32Serializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(uint);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public UInt32Serializer(TypeModel model)
	{
	}

	public object Read(object value, ProtoReader source)
	{
		return source.ReadUInt32();
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteUInt32((uint)value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteUInt32", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadUInt32", ctx.MapType(typeof(uint)));
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class UInt64Serializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(ulong);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public UInt64Serializer(TypeModel model)
	{
	}

	public object Read(object value, ProtoReader source)
	{
		return source.ReadUInt64();
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteUInt64((ulong)value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteUInt64", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadUInt64", ExpectedType);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class Int64Serializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(long);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public Int64Serializer(TypeModel model)
	{
	}

	public object Read(object value, ProtoReader source)
	{
		return source.ReadInt64();
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteInt64((long)value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteInt64", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadInt64", ExpectedType);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class DoubleSerializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(double);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public DoubleSerializer(TypeModel model)
	{
	}

	public object Read(object value, ProtoReader source)
	{
		return source.ReadDouble();
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteDouble((double)value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteDouble", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadDouble", ExpectedType);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class SingleSerializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(float);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public SingleSerializer(TypeModel model)
	{
	}

	public object Read(object value, ProtoReader source)
	{
		return source.ReadSingle();
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteSingle((float)value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteSingle", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadSingle", ExpectedType);
	}
}


using System;
using System.Reflection;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Serializers;

internal sealed class FieldDecorator : ProtoDecoratorBase
{
	private readonly FieldInfo field;

	private readonly Type forType;

	public override Type ExpectedType => forType;

	public override bool RequiresOldValue => true;

	public override bool ReturnsValue => false;

	public FieldDecorator(Type forType, FieldInfo field, IProtoSerializer tail)
		: base(tail)
	{
		this.forType = forType;
		this.field = field;
	}

	public override void Write(object value, ProtoWriter dest)
	{
		value = field.GetValue(value);
		if (value != null)
		{
			Tail.Write(value, dest);
		}
	}

	public override object Read(object value, ProtoReader source)
	{
		object obj = Tail.Read(Tail.RequiresOldValue ? field.GetValue(value) : null, source);
		if (obj != null)
		{
			field.SetValue(value, obj);
		}
		return null;
	}

	protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.LoadAddress(valueFrom, ExpectedType);
		ctx.LoadValue(field);
		ctx.WriteNullCheckedTail(field.FieldType, Tail, null);
	}

	protected override void EmitRead(CompilerContext ctx, Local valueFrom)
	{
		using Local local = ctx.GetLocalWithValue(ExpectedType, valueFrom);
		if (Tail.RequiresOldValue)
		{
			ctx.LoadAddress(local, ExpectedType);
			ctx.LoadValue(field);
		}
		ctx.ReadNullCheckedTail(field.FieldType, Tail, null);
		if (!Tail.ReturnsValue)
		{
			return;
		}
		using Local local2 = new Local(ctx, field.FieldType);
		ctx.StoreValue(local2);
		if (field.FieldType.IsValueType)
		{
			ctx.LoadAddress(local, ExpectedType);
			ctx.LoadValue(local2);
			ctx.StoreValue(field);
			return;
		}
		CodeLabel label = ctx.DefineLabel();
		ctx.LoadValue(local2);
		ctx.BranchIfFalse(label, @short: true);
		ctx.LoadAddress(local, ExpectedType);
		ctx.LoadValue(local2);
		ctx.StoreValue(field);
		ctx.MarkLabel(label);
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class Int32Serializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(int);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public Int32Serializer(TypeModel model)
	{
	}

	public object Read(object value, ProtoReader source)
	{
		return source.ReadInt32();
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteInt32((int)value, dest);
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteInt32", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadInt32", ExpectedType);
	}
}


using System;
using System.Reflection;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class PropertyDecorator : ProtoDecoratorBase
{
	private readonly PropertyInfo property;

	private readonly Type forType;

	private readonly bool readOptionsWriteValue;

	private readonly MethodInfo shadowSetter;

	public override Type ExpectedType => forType;

	public override bool RequiresOldValue => true;

	public override bool ReturnsValue => false;

	public PropertyDecorator(TypeModel model, Type forType, PropertyInfo property, IProtoSerializer tail)
		: base(tail)
	{
		this.forType = forType;
		this.property = property;
		SanityCheck(model, property, tail, out readOptionsWriteValue, nonPublic: true, allowInternal: true);
		shadowSetter = GetShadowSetter(model, property);
	}

	private static void SanityCheck(TypeModel model, PropertyInfo property, IProtoSerializer tail, out bool writeValue, bool nonPublic, bool allowInternal)
	{
		if ((object)property == null)
		{
			throw new ArgumentNullException("property");
		}
		writeValue = tail.ReturnsValue && ((object)GetShadowSetter(model, property) != null || (property.CanWrite && (object)Helpers.GetSetMethod(property, nonPublic, allowInternal) != null));
		if (!property.CanRead || (object)Helpers.GetGetMethod(property, nonPublic, allowInternal) == null)
		{
			throw new InvalidOperationException("Cannot serialize property without a get accessor");
		}
		if (!writeValue && (!tail.RequiresOldValue || Helpers.IsValueType(tail.ExpectedType)))
		{
			throw new InvalidOperationException("Cannot apply changes to property " + property.DeclaringType.FullName + "." + property.Name);
		}
	}

	private static MethodInfo GetShadowSetter(TypeModel model, PropertyInfo property)
	{
		Type reflectedType = property.ReflectedType;
		MethodInfo instanceMethod = Helpers.GetInstanceMethod(reflectedType, "Set" + property.Name, new Type[1] { property.PropertyType });
		if ((object)instanceMethod == null || !instanceMethod.IsPublic || (object)instanceMethod.ReturnType != model.MapType(typeof(void)))
		{
			return null;
		}
		return instanceMethod;
	}

	public override void Write(object value, ProtoWriter dest)
	{
		value = property.GetValue(value, null);
		if (value != null)
		{
			Tail.Write(value, dest);
		}
	}

	public override object Read(object value, ProtoReader source)
	{
		object value2 = (Tail.RequiresOldValue ? property.GetValue(value, null) : null);
		object obj = Tail.Read(value2, source);
		if (readOptionsWriteValue && obj != null)
		{
			if ((object)shadowSetter == null)
			{
				property.SetValue(value, obj, null);
			}
			else
			{
				shadowSetter.Invoke(value, new object[1] { obj });
			}
		}
		return null;
	}

	protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.LoadAddress(valueFrom, ExpectedType);
		ctx.LoadValue(property);
		ctx.WriteNullCheckedTail(property.PropertyType, Tail, null);
	}

	protected override void EmitRead(CompilerContext ctx, Local valueFrom)
	{
		SanityCheck(ctx.Model, property, Tail, out var writeValue, ctx.NonPublic, ctx.AllowInternal(property));
		if (ExpectedType.IsValueType && valueFrom == null)
		{
			throw new InvalidOperationException("Attempt to mutate struct on the head of the stack; changes would be lost");
		}
		using Local local = ctx.GetLocalWithValue(ExpectedType, valueFrom);
		if (Tail.RequiresOldValue)
		{
			ctx.LoadAddress(local, ExpectedType);
			ctx.LoadValue(property);
		}
		Type propertyType = property.PropertyType;
		ctx.ReadNullCheckedTail(propertyType, Tail, null);
		if (writeValue)
		{
			using (Local local2 = new Local(ctx, property.PropertyType))
			{
				ctx.StoreValue(local2);
				CodeLabel label = default(CodeLabel);
				if (!propertyType.IsValueType)
				{
					label = ctx.DefineLabel();
					ctx.LoadValue(local2);
					ctx.BranchIfFalse(label, @short: true);
				}
				ctx.LoadAddress(local, ExpectedType);
				ctx.LoadValue(local2);
				if ((object)shadowSetter == null)
				{
					ctx.StoreValue(property);
				}
				else
				{
					ctx.EmitCall(shadowSetter);
				}
				if (!propertyType.IsValueType)
				{
					ctx.MarkLabel(label);
				}
				return;
			}
		}
		if (Tail.ReturnsValue)
		{
			ctx.DiscardValue();
		}
	}

	internal static bool CanWrite(TypeModel model, MemberInfo member)
	{
		if ((object)member == null)
		{
			throw new ArgumentNullException("member");
		}
		if (member is PropertyInfo propertyInfo)
		{
			if (!propertyInfo.CanWrite)
			{
				return (object)GetShadowSetter(model, propertyInfo) != null;
			}
			return true;
		}
		return member is FieldInfo;
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class StringSerializer : IProtoSerializer
{
	private static readonly Type expectedType = typeof(string);

	public Type ExpectedType => expectedType;

	bool IProtoSerializer.RequiresOldValue => false;

	bool IProtoSerializer.ReturnsValue => true;

	public StringSerializer(TypeModel model)
	{
	}

	public void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteString((string)value, dest);
	}

	public object Read(object value, ProtoReader source)
	{
		return source.ReadString();
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicWrite("WriteString", valueFrom);
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		ctx.EmitBasicRead("ReadString", ExpectedType);
	}
}


using System;
using System.Reflection.Emit;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class SubItemSerializer : IProtoTypeSerializer, IProtoSerializer
{
	private readonly int key;

	private readonly Type type;

	private readonly ISerializerProxy proxy;

	private readonly bool recursionCheck;

	Type IProtoSerializer.ExpectedType => type;

	bool IProtoSerializer.RequiresOldValue => true;

	bool IProtoSerializer.ReturnsValue => true;

	bool IProtoTypeSerializer.HasCallbacks(TypeModel.CallbackType callbackType)
	{
		return ((IProtoTypeSerializer)proxy.Serializer).HasCallbacks(callbackType);
	}

	bool IProtoTypeSerializer.CanCreateInstance()
	{
		return ((IProtoTypeSerializer)proxy.Serializer).CanCreateInstance();
	}

	void IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
	{
		((IProtoTypeSerializer)proxy.Serializer).EmitCallback(ctx, valueFrom, callbackType);
	}

	void IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
	{
		((IProtoTypeSerializer)proxy.Serializer).EmitCreateInstance(ctx);
	}

	void IProtoTypeSerializer.Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context)
	{
		((IProtoTypeSerializer)proxy.Serializer).Callback(value, callbackType, context);
	}

	object IProtoTypeSerializer.CreateInstance(ProtoReader source)
	{
		return ((IProtoTypeSerializer)proxy.Serializer).CreateInstance(source);
	}

	public SubItemSerializer(Type type, int key, ISerializerProxy proxy, bool recursionCheck)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		if (proxy == null)
		{
			throw new ArgumentNullException("proxy");
		}
		this.type = type;
		this.proxy = proxy;
		this.key = key;
		this.recursionCheck = recursionCheck;
	}

	void IProtoSerializer.Write(object value, ProtoWriter dest)
	{
		if (recursionCheck)
		{
			ProtoWriter.WriteObject(value, key, dest);
		}
		else
		{
			ProtoWriter.WriteRecursionSafeObject(value, key, dest);
		}
	}

	object IProtoSerializer.Read(object value, ProtoReader source)
	{
		return ProtoReader.ReadObject(value, key, source);
	}

	private bool EmitDedicatedMethod(CompilerContext ctx, Local valueFrom, bool read)
	{
		MethodBuilder dedicatedMethod = ctx.GetDedicatedMethod(key, read);
		if ((object)dedicatedMethod == null)
		{
			return false;
		}
		using (Local local = new Local(ctx, ctx.MapType(typeof(SubItemToken))))
		{
			Type type = ctx.MapType(read ? typeof(ProtoReader) : typeof(ProtoWriter));
			ctx.LoadValue(valueFrom);
			if (!read)
			{
				if (this.type.IsValueType || !recursionCheck)
				{
					ctx.LoadNullRef();
				}
				else
				{
					ctx.CopyValue();
				}
			}
			ctx.LoadReaderWriter();
			ctx.EmitCall(type.GetMethod("StartSubItem"));
			ctx.StoreValue(local);
			ctx.LoadReaderWriter();
			ctx.EmitCall(dedicatedMethod);
			if (read && (object)this.type != dedicatedMethod.ReturnType)
			{
				ctx.Cast(this.type);
			}
			ctx.LoadValue(local);
			ctx.LoadReaderWriter();
			ctx.EmitCall(type.GetMethod("EndSubItem"));
		}
		return true;
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		if (!EmitDedicatedMethod(ctx, valueFrom, read: false))
		{
			ctx.LoadValue(valueFrom);
			if (type.IsValueType)
			{
				ctx.CastToObject(type);
			}
			ctx.LoadValue(ctx.MapMetaKeyToCompiledKey(key));
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod(recursionCheck ? "WriteObject" : "WriteRecursionSafeObject"));
		}
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		if (!EmitDedicatedMethod(ctx, valueFrom, read: true))
		{
			ctx.LoadValue(valueFrom);
			if (type.IsValueType)
			{
				ctx.CastToObject(type);
			}
			ctx.LoadValue(ctx.MapMetaKeyToCompiledKey(key));
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("ReadObject"));
			ctx.CastFromObject(type);
		}
	}
}


using System;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class TagDecorator : ProtoDecoratorBase, IProtoTypeSerializer, IProtoSerializer
{
	private readonly bool strict;

	private readonly int fieldNumber;

	private readonly WireType wireType;

	public override Type ExpectedType => Tail.ExpectedType;

	public override bool RequiresOldValue => Tail.RequiresOldValue;

	public override bool ReturnsValue => Tail.ReturnsValue;

	private bool NeedsHint => (wireType & (WireType)(-8)) != 0;

	public bool HasCallbacks(TypeModel.CallbackType callbackType)
	{
		if (Tail is IProtoTypeSerializer protoTypeSerializer)
		{
			return protoTypeSerializer.HasCallbacks(callbackType);
		}
		return false;
	}

	public bool CanCreateInstance()
	{
		if (Tail is IProtoTypeSerializer protoTypeSerializer)
		{
			return protoTypeSerializer.CanCreateInstance();
		}
		return false;
	}

	public object CreateInstance(ProtoReader source)
	{
		return ((IProtoTypeSerializer)Tail).CreateInstance(source);
	}

	public void Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context)
	{
		if (Tail is IProtoTypeSerializer protoTypeSerializer)
		{
			protoTypeSerializer.Callback(value, callbackType, context);
		}
	}

	public void EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
	{
		((IProtoTypeSerializer)Tail).EmitCallback(ctx, valueFrom, callbackType);
	}

	public void EmitCreateInstance(CompilerContext ctx)
	{
		((IProtoTypeSerializer)Tail).EmitCreateInstance(ctx);
	}

	public TagDecorator(int fieldNumber, WireType wireType, bool strict, IProtoSerializer tail)
		: base(tail)
	{
		this.fieldNumber = fieldNumber;
		this.wireType = wireType;
		this.strict = strict;
	}

	public override object Read(object value, ProtoReader source)
	{
		if (strict)
		{
			source.Assert(wireType);
		}
		else if (NeedsHint)
		{
			source.Hint(wireType);
		}
		return Tail.Read(value, source);
	}

	public override void Write(object value, ProtoWriter dest)
	{
		ProtoWriter.WriteFieldHeader(fieldNumber, wireType, dest);
		Tail.Write(value, dest);
	}

	protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		ctx.LoadValue(fieldNumber);
		ctx.LoadValue((int)wireType);
		ctx.LoadReaderWriter();
		ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("WriteFieldHeader"));
		Tail.EmitWrite(ctx, valueFrom);
	}

	protected override void EmitRead(CompilerContext ctx, Local valueFrom)
	{
		if (strict || NeedsHint)
		{
			ctx.LoadReaderWriter();
			ctx.LoadValue((int)wireType);
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod(strict ? "Assert" : "Hint"));
		}
		Tail.EmitRead(ctx, valueFrom);
	}
}


using System;
using System.Reflection;
using System.Runtime.Serialization;
using ProtoBuf;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

internal sealed class TypeSerializer : IProtoTypeSerializer, IProtoSerializer
{
	private readonly Type forType;

	private readonly Type constructType;

	private readonly IProtoSerializer[] serializers;

	private readonly int[] fieldNumbers;

	private readonly bool isRootType;

	private readonly bool useConstructor;

	private readonly bool isExtensible;

	private readonly bool hasConstructor;

	private readonly CallbackSet callbacks;

	private readonly MethodInfo[] baseCtorCallbacks;

	private readonly MethodInfo factory;

	private static readonly Type iextensible = typeof(IExtensible);

	public Type ExpectedType => forType;

	private bool CanHaveInheritance
	{
		get
		{
			if (forType.IsClass || forType.IsInterface)
			{
				return !forType.IsSealed;
			}
			return false;
		}
	}

	bool IProtoSerializer.RequiresOldValue => true;

	bool IProtoSerializer.ReturnsValue => false;

	public bool HasCallbacks(TypeModel.CallbackType callbackType)
	{
		if (callbacks != null && (object)callbacks[callbackType] != null)
		{
			return true;
		}
		for (int i = 0; i < serializers.Length; i++)
		{
			if ((object)serializers[i].ExpectedType != forType && ((IProtoTypeSerializer)serializers[i]).HasCallbacks(callbackType))
			{
				return true;
			}
		}
		return false;
	}

	public TypeSerializer(TypeModel model, Type forType, int[] fieldNumbers, IProtoSerializer[] serializers, MethodInfo[] baseCtorCallbacks, bool isRootType, bool useConstructor, CallbackSet callbacks, Type constructType, MethodInfo factory)
	{
		Helpers.Sort(fieldNumbers, serializers);
		bool flag = false;
		for (int i = 1; i < fieldNumbers.Length; i++)
		{
			if (fieldNumbers[i] == fieldNumbers[i - 1])
			{
				throw new InvalidOperationException("Duplicate field-number detected; " + fieldNumbers[i] + " on: " + forType.FullName);
			}
			if (!flag && (object)serializers[i].ExpectedType != forType)
			{
				flag = true;
			}
		}
		this.forType = forType;
		this.factory = factory;
		if ((object)constructType == null)
		{
			constructType = forType;
		}
		else if (!forType.IsAssignableFrom(constructType))
		{
			throw new InvalidOperationException(forType.FullName + " cannot be assigned from " + constructType.FullName);
		}
		this.constructType = constructType;
		this.serializers = serializers;
		this.fieldNumbers = fieldNumbers;
		this.callbacks = callbacks;
		this.isRootType = isRootType;
		this.useConstructor = useConstructor;
		if (baseCtorCallbacks != null && baseCtorCallbacks.Length == 0)
		{
			baseCtorCallbacks = null;
		}
		this.baseCtorCallbacks = baseCtorCallbacks;
		if ((object)Helpers.GetUnderlyingType(forType) != null)
		{
			throw new ArgumentException("Cannot create a TypeSerializer for nullable types", "forType");
		}
		if (model.MapType(iextensible).IsAssignableFrom(forType))
		{
			if (forType.IsValueType || !isRootType || flag)
			{
				throw new NotSupportedException("IExtensible is not supported in structs or classes with inheritance");
			}
			isExtensible = true;
		}
		hasConstructor = !constructType.IsAbstract && (object)Helpers.GetConstructor(constructType, Helpers.EmptyTypes, nonPublic: true) != null;
		if ((object)constructType != forType && useConstructor && !hasConstructor)
		{
			throw new ArgumentException("The supplied default implementation cannot be created: " + constructType.FullName, "constructType");
		}
	}

	bool IProtoTypeSerializer.CanCreateInstance()
	{
		return true;
	}

	object IProtoTypeSerializer.CreateInstance(ProtoReader source)
	{
		return CreateInstance(source, includeLocalCallback: false);
	}

	public void Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context)
	{
		if (callbacks != null)
		{
			InvokeCallback(callbacks[callbackType], value, context);
		}
		((IProtoTypeSerializer)GetMoreSpecificSerializer(value))?.Callback(value, callbackType, context);
	}

	private IProtoSerializer GetMoreSpecificSerializer(object value)
	{
		if (!CanHaveInheritance)
		{
			return null;
		}
		Type type = value.GetType();
		if ((object)type == forType)
		{
			return null;
		}
		for (int i = 0; i < serializers.Length; i++)
		{
			IProtoSerializer protoSerializer = serializers[i];
			if ((object)protoSerializer.ExpectedType != forType && Helpers.IsAssignableFrom(protoSerializer.ExpectedType, type))
			{
				return protoSerializer;
			}
		}
		if ((object)type == constructType)
		{
			return null;
		}
		TypeModel.ThrowUnexpectedSubtype(forType, type);
		return null;
	}

	public void Write(object value, ProtoWriter dest)
	{
		if (isRootType)
		{
			Callback(value, TypeModel.CallbackType.BeforeSerialize, dest.Context);
		}
		GetMoreSpecificSerializer(value)?.Write(value, dest);
		for (int i = 0; i < serializers.Length; i++)
		{
			IProtoSerializer protoSerializer = serializers[i];
			if ((object)protoSerializer.ExpectedType == forType)
			{
				protoSerializer.Write(value, dest);
			}
		}
		if (isExtensible)
		{
			ProtoWriter.AppendExtensionData((IExtensible)value, dest);
		}
		if (isRootType)
		{
			Callback(value, TypeModel.CallbackType.AfterSerialize, dest.Context);
		}
	}

	public object Read(object value, ProtoReader source)
	{
		if (isRootType && value != null)
		{
			Callback(value, TypeModel.CallbackType.BeforeDeserialize, source.Context);
		}
		int num = 0;
		int num2 = 0;
		int num3;
		while ((num3 = source.ReadFieldHeader()) > 0)
		{
			bool flag = false;
			if (num3 < num)
			{
				num = (num2 = 0);
			}
			for (int i = num2; i < fieldNumbers.Length; i++)
			{
				if (fieldNumbers[i] != num3)
				{
					continue;
				}
				IProtoSerializer protoSerializer = serializers[i];
				Type expectedType = protoSerializer.ExpectedType;
				if (value == null)
				{
					if ((object)expectedType == forType)
					{
						value = CreateInstance(source, includeLocalCallback: true);
					}
				}
				else if ((object)expectedType != forType && ((IProtoTypeSerializer)protoSerializer).CanCreateInstance() && expectedType.IsSubclassOf(value.GetType()))
				{
					value = ProtoReader.Merge(source, value, ((IProtoTypeSerializer)protoSerializer).CreateInstance(source));
				}
				if (protoSerializer.ReturnsValue)
				{
					value = protoSerializer.Read(value, source);
				}
				else
				{
					protoSerializer.Read(value, source);
				}
				num2 = i;
				num = num3;
				flag = true;
				break;
			}
			if (!flag)
			{
				if (value == null)
				{
					value = CreateInstance(source, includeLocalCallback: true);
				}
				if (isExtensible)
				{
					source.AppendExtensionData((IExtensible)value);
				}
				else
				{
					source.SkipField();
				}
			}
		}
		if (value == null)
		{
			value = CreateInstance(source, includeLocalCallback: true);
		}
		if (isRootType)
		{
			Callback(value, TypeModel.CallbackType.AfterDeserialize, source.Context);
		}
		return value;
	}

	private object InvokeCallback(MethodInfo method, object obj, SerializationContext context)
	{
		object result = null;
		if ((object)method != null)
		{
			ParameterInfo[] parameters = method.GetParameters();
			object[] array;
			bool flag;
			if (parameters.Length == 0)
			{
				array = null;
				flag = true;
			}
			else
			{
				array = new object[parameters.Length];
				flag = true;
				for (int i = 0; i < array.Length; i++)
				{
					Type parameterType = parameters[i].ParameterType;
					object obj2;
					if ((object)parameterType == typeof(SerializationContext))
					{
						obj2 = context;
					}
					else if ((object)parameterType == typeof(Type))
					{
						obj2 = constructType;
					}
					else if ((object)parameterType == typeof(StreamingContext))
					{
						obj2 = (StreamingContext)context;
					}
					else
					{
						obj2 = null;
						flag = false;
					}
					array[i] = obj2;
				}
			}
			if (!flag)
			{
				throw CallbackSet.CreateInvalidCallbackSignature(method);
			}
			result = method.Invoke(obj, array);
		}
		return result;
	}

	private object CreateInstance(ProtoReader source, bool includeLocalCallback)
	{
		object obj;
		if ((object)factory != null)
		{
			obj = InvokeCallback(factory, null, source.Context);
		}
		else if (useConstructor)
		{
			if (!hasConstructor)
			{
				TypeModel.ThrowCannotCreateInstance(constructType);
			}
			obj = Activator.CreateInstance(constructType, nonPublic: true);
		}
		else
		{
			obj = BclHelpers.GetUninitializedObject(constructType);
		}
		ProtoReader.NoteObject(obj, source);
		if (baseCtorCallbacks != null)
		{
			for (int i = 0; i < baseCtorCallbacks.Length; i++)
			{
				InvokeCallback(baseCtorCallbacks[i], obj, source.Context);
			}
		}
		if (includeLocalCallback && callbacks != null)
		{
			InvokeCallback(callbacks.BeforeDeserialize, obj, source.Context);
		}
		return obj;
	}

	void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
	{
		Type expectedType = ExpectedType;
		using Local local = ctx.GetLocalWithValue(expectedType, valueFrom);
		EmitCallbackIfNeeded(ctx, local, TypeModel.CallbackType.BeforeSerialize);
		CodeLabel label = ctx.DefineLabel();
		if (CanHaveInheritance)
		{
			for (int i = 0; i < serializers.Length; i++)
			{
				IProtoSerializer protoSerializer = serializers[i];
				Type expectedType2 = protoSerializer.ExpectedType;
				if ((object)expectedType2 != forType)
				{
					CodeLabel label2 = ctx.DefineLabel();
					CodeLabel label3 = ctx.DefineLabel();
					ctx.LoadValue(local);
					ctx.TryCast(expectedType2);
					ctx.CopyValue();
					ctx.BranchIfTrue(label2, @short: true);
					ctx.DiscardValue();
					ctx.Branch(label3, @short: true);
					ctx.MarkLabel(label2);
					protoSerializer.EmitWrite(ctx, null);
					ctx.Branch(label, @short: false);
					ctx.MarkLabel(label3);
				}
			}
			if ((object)constructType != null && (object)constructType != forType)
			{
				using Local local2 = new Local(ctx, ctx.MapType(typeof(Type)));
				ctx.LoadValue(local);
				ctx.EmitCall(ctx.MapType(typeof(object)).GetMethod("GetType"));
				ctx.CopyValue();
				ctx.StoreValue(local2);
				ctx.LoadValue(forType);
				ctx.BranchIfEqual(label, @short: true);
				ctx.LoadValue(local2);
				ctx.LoadValue(constructType);
				ctx.BranchIfEqual(label, @short: true);
			}
			else
			{
				ctx.LoadValue(local);
				ctx.EmitCall(ctx.MapType(typeof(object)).GetMethod("GetType"));
				ctx.LoadValue(forType);
				ctx.BranchIfEqual(label, @short: true);
			}
			ctx.LoadValue(forType);
			ctx.LoadValue(local);
			ctx.EmitCall(ctx.MapType(typeof(object)).GetMethod("GetType"));
			ctx.EmitCall(ctx.MapType(typeof(TypeModel)).GetMethod("ThrowUnexpectedSubtype", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic));
		}
		ctx.MarkLabel(label);
		for (int j = 0; j < serializers.Length; j++)
		{
			IProtoSerializer protoSerializer2 = serializers[j];
			if ((object)protoSerializer2.ExpectedType == forType)
			{
				protoSerializer2.EmitWrite(ctx, local);
			}
		}
		if (isExtensible)
		{
			ctx.LoadValue(local);
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("AppendExtensionData"));
		}
		EmitCallbackIfNeeded(ctx, local, TypeModel.CallbackType.AfterSerialize);
	}

	private static void EmitInvokeCallback(CompilerContext ctx, MethodInfo method, bool copyValue, Type constructType, Type type)
	{
		if ((object)method == null)
		{
			return;
		}
		if (copyValue)
		{
			ctx.CopyValue();
		}
		ParameterInfo[] parameters = method.GetParameters();
		bool flag = true;
		for (int i = 0; i < parameters.Length; i++)
		{
			Type parameterType = parameters[0].ParameterType;
			if ((object)parameterType == ctx.MapType(typeof(SerializationContext)))
			{
				ctx.LoadSerializationContext();
			}
			else if ((object)parameterType == ctx.MapType(typeof(Type)))
			{
				Type type2 = constructType;
				if ((object)type2 == null)
				{
					type2 = type;
				}
				ctx.LoadValue(type2);
			}
			else if ((object)parameterType == ctx.MapType(typeof(StreamingContext)))
			{
				ctx.LoadSerializationContext();
				MethodInfo method2 = ctx.MapType(typeof(SerializationContext)).GetMethod("op_Implicit", new Type[1] { ctx.MapType(typeof(SerializationContext)) });
				if ((object)method2 != null)
				{
					ctx.EmitCall(method2);
					flag = true;
				}
			}
			else
			{
				flag = false;
			}
		}
		if (flag)
		{
			ctx.EmitCall(method);
			if ((object)constructType != null && (object)method.ReturnType == ctx.MapType(typeof(object)))
			{
				ctx.CastFromObject(type);
			}
			return;
		}
		throw CallbackSet.CreateInvalidCallbackSignature(method);
	}

	private void EmitCallbackIfNeeded(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
	{
		if (isRootType && ((IProtoTypeSerializer)this).HasCallbacks(callbackType))
		{
			((IProtoTypeSerializer)this).EmitCallback(ctx, valueFrom, callbackType);
		}
	}

	void IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
	{
		bool flag = false;
		if (CanHaveInheritance)
		{
			for (int i = 0; i < serializers.Length; i++)
			{
				IProtoSerializer protoSerializer = serializers[i];
				if ((object)protoSerializer.ExpectedType != forType && ((IProtoTypeSerializer)protoSerializer).HasCallbacks(callbackType))
				{
					flag = true;
				}
			}
		}
		MethodInfo methodInfo = ((callbacks == null) ? null : callbacks[callbackType]);
		if ((object)methodInfo == null && !flag)
		{
			return;
		}
		ctx.LoadAddress(valueFrom, ExpectedType);
		EmitInvokeCallback(ctx, methodInfo, flag, null, forType);
		if (!flag)
		{
			return;
		}
		CodeLabel label = ctx.DefineLabel();
		for (int j = 0; j < serializers.Length; j++)
		{
			IProtoSerializer protoSerializer2 = serializers[j];
			Type expectedType = protoSerializer2.ExpectedType;
			IProtoTypeSerializer protoTypeSerializer;
			if ((object)expectedType != forType && (protoTypeSerializer = (IProtoTypeSerializer)protoSerializer2).HasCallbacks(callbackType))
			{
				CodeLabel label2 = ctx.DefineLabel();
				CodeLabel label3 = ctx.DefineLabel();
				ctx.CopyValue();
				ctx.TryCast(expectedType);
				ctx.CopyValue();
				ctx.BranchIfTrue(label2, @short: true);
				ctx.DiscardValue();
				ctx.Branch(label3, @short: false);
				ctx.MarkLabel(label2);
				protoTypeSerializer.EmitCallback(ctx, null, callbackType);
				ctx.Branch(label, @short: false);
				ctx.MarkLabel(label3);
			}
		}
		ctx.MarkLabel(label);
		ctx.DiscardValue();
	}

	void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
	{
		Type expectedType = ExpectedType;
		using Local local = ctx.GetLocalWithValue(expectedType, valueFrom);
		using Local local2 = new Local(ctx, ctx.MapType(typeof(int)));
		if (HasCallbacks(TypeModel.CallbackType.BeforeDeserialize))
		{
			if (ExpectedType.IsValueType)
			{
				EmitCallbackIfNeeded(ctx, local, TypeModel.CallbackType.BeforeDeserialize);
			}
			else
			{
				CodeLabel label = ctx.DefineLabel();
				ctx.LoadValue(local);
				ctx.BranchIfFalse(label, @short: false);
				EmitCallbackIfNeeded(ctx, local, TypeModel.CallbackType.BeforeDeserialize);
				ctx.MarkLabel(label);
			}
		}
		CodeLabel codeLabel = ctx.DefineLabel();
		CodeLabel label2 = ctx.DefineLabel();
		ctx.Branch(codeLabel, @short: false);
		ctx.MarkLabel(label2);
		BasicList.NodeEnumerator enumerator = BasicList.GetContiguousGroups(fieldNumbers, serializers).GetEnumerator();
		while (enumerator.MoveNext())
		{
			BasicList.Group group = (BasicList.Group)enumerator.Current;
			CodeLabel label3 = ctx.DefineLabel();
			int count = group.Items.Count;
			if (count == 1)
			{
				ctx.LoadValue(local2);
				ctx.LoadValue(group.First);
				CodeLabel codeLabel2 = ctx.DefineLabel();
				ctx.BranchIfEqual(codeLabel2, @short: true);
				ctx.Branch(label3, @short: false);
				WriteFieldHandler(ctx, expectedType, local, codeLabel2, codeLabel, (IProtoSerializer)group.Items[0]);
			}
			else
			{
				ctx.LoadValue(local2);
				ctx.LoadValue(group.First);
				ctx.Subtract();
				CodeLabel[] array = new CodeLabel[count];
				for (int i = 0; i < count; i++)
				{
					ref CodeLabel reference = ref array[i];
					reference = ctx.DefineLabel();
				}
				ctx.Switch(array);
				ctx.Branch(label3, @short: false);
				for (int j = 0; j < count; j++)
				{
					WriteFieldHandler(ctx, expectedType, local, array[j], codeLabel, (IProtoSerializer)group.Items[j]);
				}
			}
			ctx.MarkLabel(label3);
		}
		EmitCreateIfNull(ctx, local);
		ctx.LoadReaderWriter();
		if (isExtensible)
		{
			ctx.LoadValue(local);
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("AppendExtensionData"));
		}
		else
		{
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("SkipField"));
		}
		ctx.MarkLabel(codeLabel);
		ctx.EmitBasicRead("ReadFieldHeader", ctx.MapType(typeof(int)));
		ctx.CopyValue();
		ctx.StoreValue(local2);
		ctx.LoadValue(0);
		ctx.BranchIfGreater(label2, @short: false);
		EmitCreateIfNull(ctx, local);
		EmitCallbackIfNeeded(ctx, local, TypeModel.CallbackType.AfterDeserialize);
		if (valueFrom != null && !local.IsSame(valueFrom))
		{
			ctx.LoadValue(local);
			ctx.Cast(valueFrom.Type);
			ctx.StoreValue(valueFrom);
		}
	}

	private void WriteFieldHandler(CompilerContext ctx, Type expected, Local loc, CodeLabel handler, CodeLabel @continue, IProtoSerializer serializer)
	{
		ctx.MarkLabel(handler);
		Type expectedType = serializer.ExpectedType;
		if ((object)expectedType == forType)
		{
			EmitCreateIfNull(ctx, loc);
			serializer.EmitRead(ctx, loc);
		}
		else
		{
			if (((IProtoTypeSerializer)serializer).CanCreateInstance())
			{
				CodeLabel label = ctx.DefineLabel();
				ctx.LoadValue(loc);
				ctx.BranchIfFalse(label, @short: false);
				ctx.LoadValue(loc);
				ctx.TryCast(expectedType);
				ctx.BranchIfTrue(label, @short: false);
				ctx.LoadReaderWriter();
				ctx.LoadValue(loc);
				((IProtoTypeSerializer)serializer).EmitCreateInstance(ctx);
				ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("Merge"));
				ctx.Cast(expected);
				ctx.StoreValue(loc);
				ctx.MarkLabel(label);
			}
			ctx.LoadValue(loc);
			ctx.Cast(expectedType);
			serializer.EmitRead(ctx, null);
		}
		if (serializer.ReturnsValue)
		{
			ctx.StoreValue(loc);
		}
		ctx.Branch(@continue, @short: false);
	}

	void IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
	{
		bool flag = true;
		if ((object)factory != null)
		{
			EmitInvokeCallback(ctx, factory, copyValue: false, constructType, forType);
		}
		else if (!useConstructor)
		{
			ctx.LoadValue(constructType);
			ctx.EmitCall(ctx.MapType(typeof(BclHelpers)).GetMethod("GetUninitializedObject"));
			ctx.Cast(forType);
		}
		else if (constructType.IsClass && hasConstructor)
		{
			ctx.EmitCtor(constructType);
		}
		else
		{
			ctx.LoadValue(ExpectedType);
			ctx.EmitCall(ctx.MapType(typeof(TypeModel)).GetMethod("ThrowCannotCreateInstance", BindingFlags.Static | BindingFlags.Public));
			ctx.LoadNullRef();
			flag = false;
		}
		if (flag)
		{
			ctx.CopyValue();
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("NoteObject", BindingFlags.Static | BindingFlags.Public));
		}
		if (baseCtorCallbacks != null)
		{
			for (int i = 0; i < baseCtorCallbacks.Length; i++)
			{
				EmitInvokeCallback(ctx, baseCtorCallbacks[i], copyValue: true, null, forType);
			}
		}
	}

	private void EmitCreateIfNull(CompilerContext ctx, Local storage)
	{
		if (!ExpectedType.IsValueType)
		{
			CodeLabel label = ctx.DefineLabel();
			ctx.LoadValue(storage);
			ctx.BranchIfTrue(label, @short: false);
			((IProtoTypeSerializer)this).EmitCreateInstance(ctx);
			if (callbacks != null)
			{
				EmitInvokeCallback(ctx, callbacks.BeforeDeserialize, copyValue: true, null, forType);
			}
			ctx.StoreValue(storage);
			ctx.MarkLabel(label);
		}
	}
}


public struct SubItemToken
{
	internal readonly int value;

	internal SubItemToken(int value)
	{
		this.value = value;
	}
}


public enum WireType
{
	None = -1,
	Variant = 0,
	Fixed64 = 1,
	String = 2,
	StartGroup = 3,
	EndGroup = 4,
	Fixed32 = 5,
	SignedVariant = 8
}


