using System;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;

[CompilerGenerated]
[Embedded]
internal sealed class IsUnmanagedAttribute : Attribute
{
}


public enum UidType
{
	NetworkableId,
	ItemContainerId,
	ItemId,
	Clear
}


public delegate void UidInspector<T>(UidType type, ref T value);


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class EffectData : IDisposable, IPooled, IProto<EffectData>, IProto
{
	[NonSerialized]
	public uint type;

	[NonSerialized]
	public uint pooledstringid;

	[NonSerialized]
	public int number;

	[NonSerialized]
	public Vector3 origin;

	[NonSerialized]
	public Vector3 normal;

	[NonSerialized]
	public float scale;

	[NonSerialized]
	public NetworkableId entity;

	[NonSerialized]
	public uint bone;

	[NonSerialized]
	public ulong source;

	[NonSerialized]
	public float distanceOverride;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EffectData instance)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.type = 0u;
			instance.pooledstringid = 0u;
			instance.number = 0;
			instance.origin = default(Vector3);
			instance.normal = default(Vector3);
			instance.scale = 0f;
			instance.entity = default(NetworkableId);
			instance.bone = 0u;
			instance.source = 0uL;
			instance.distanceOverride = 0f;
			Pool.Free<EffectData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EffectData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EffectData instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.type = type;
		instance.pooledstringid = pooledstringid;
		instance.number = number;
		instance.origin = origin;
		instance.normal = normal;
		instance.scale = scale;
		instance.entity = entity;
		instance.bone = bone;
		instance.source = source;
		instance.distanceOverride = distanceOverride;
	}

	public EffectData Copy()
	{
		EffectData effectData = Pool.Get<EffectData>();
		CopyTo(effectData);
		return effectData;
	}

	public static EffectData Deserialize(BufferStream stream)
	{
		EffectData effectData = Pool.Get<EffectData>();
		Deserialize(stream, effectData, isDelta: false);
		return effectData;
	}

	public static EffectData DeserializeLengthDelimited(BufferStream stream)
	{
		EffectData effectData = Pool.Get<EffectData>();
		DeserializeLengthDelimited(stream, effectData, isDelta: false);
		return effectData;
	}

	public static EffectData DeserializeLength(BufferStream stream, int length)
	{
		EffectData effectData = Pool.Get<EffectData>();
		DeserializeLength(stream, length, effectData, isDelta: false);
		return effectData;
	}

	public static EffectData Deserialize(byte[] buffer)
	{
		EffectData effectData = Pool.Get<EffectData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, effectData, isDelta: false);
		return effectData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EffectData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EffectData Deserialize(BufferStream stream, EffectData instance, bool isDelta)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.pooledstringid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.number = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 53:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.bone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.source = ProtocolParser.ReadUInt64(stream);
				continue;
			case 85:
				instance.distanceOverride = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EffectData DeserializeLengthDelimited(BufferStream stream, EffectData instance, bool isDelta)
	{
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.pooledstringid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.number = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 53:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.bone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.source = ProtocolParser.ReadUInt64(stream);
				continue;
			case 85:
				instance.distanceOverride = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EffectData DeserializeLength(BufferStream stream, int length, EffectData instance, bool isDelta)
	{
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.pooledstringid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.number = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 53:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.bone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.source = ProtocolParser.ReadUInt64(stream);
				continue;
			case 85:
				instance.distanceOverride = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EffectData instance, EffectData previous)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.type);
		}
		if (instance.pooledstringid != previous.pooledstringid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.pooledstringid);
		}
		if (instance.number != previous.number)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.number);
		}
		if (instance.origin != previous.origin)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.origin, previous.origin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != previous.normal)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.scale != previous.scale)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.scale);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, instance.entity.Value);
		if (instance.bone != previous.bone)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.bone);
		}
		if (instance.source != previous.source)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, instance.source);
		}
		if (instance.distanceOverride != previous.distanceOverride)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.distanceOverride);
		}
	}

	public static void Serialize(BufferStream stream, EffectData instance)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.type);
		}
		if (instance.pooledstringid != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.pooledstringid);
		}
		if (instance.number != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.number);
		}
		if (instance.origin != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.origin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.scale != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.scale);
		}
		if (instance.entity != default(NetworkableId))
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.entity.Value);
		}
		if (instance.bone != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.bone);
		}
		if (instance.source != 0L)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, instance.source);
		}
		if (instance.distanceOverride != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.distanceOverride);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class InputMessage : IDisposable, IPooled, IProto<InputMessage>, IProto
{
	[NonSerialized]
	public int buttons;

	[NonSerialized]
	public Vector3 aimAngles;

	[NonSerialized]
	public Vector3 mouseDelta;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InputMessage instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.buttons = 0;
			instance.aimAngles = default(Vector3);
			instance.mouseDelta = default(Vector3);
			Pool.Free<InputMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InputMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InputMessage instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.buttons = buttons;
		instance.aimAngles = aimAngles;
		instance.mouseDelta = mouseDelta;
	}

	public InputMessage Copy()
	{
		InputMessage inputMessage = Pool.Get<InputMessage>();
		CopyTo(inputMessage);
		return inputMessage;
	}

	public static InputMessage Deserialize(BufferStream stream)
	{
		InputMessage inputMessage = Pool.Get<InputMessage>();
		Deserialize(stream, inputMessage, isDelta: false);
		return inputMessage;
	}

	public static InputMessage DeserializeLengthDelimited(BufferStream stream)
	{
		InputMessage inputMessage = Pool.Get<InputMessage>();
		DeserializeLengthDelimited(stream, inputMessage, isDelta: false);
		return inputMessage;
	}

	public static InputMessage DeserializeLength(BufferStream stream, int length)
	{
		InputMessage inputMessage = Pool.Get<InputMessage>();
		DeserializeLength(stream, length, inputMessage, isDelta: false);
		return inputMessage;
	}

	public static InputMessage Deserialize(byte[] buffer)
	{
		InputMessage inputMessage = Pool.Get<InputMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, inputMessage, isDelta: false);
		return inputMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InputMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InputMessage Deserialize(BufferStream stream, InputMessage instance, bool isDelta)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimAngles, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InputMessage DeserializeLengthDelimited(BufferStream stream, InputMessage instance, bool isDelta)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimAngles, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InputMessage DeserializeLength(BufferStream stream, int length, InputMessage instance, bool isDelta)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimAngles, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InputMessage instance, InputMessage previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (instance.buttons != previous.buttons)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.buttons);
		}
		if (instance.aimAngles != previous.aimAngles)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aimAngles, previous.aimAngles);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimAngles (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.mouseDelta != previous.mouseDelta)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.mouseDelta, previous.mouseDelta);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mouseDelta (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, InputMessage instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (instance.buttons != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.buttons);
		}
		if (instance.aimAngles != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aimAngles);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimAngles (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.mouseDelta != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.mouseDelta);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mouseDelta (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ModelState : IDisposable, IPooled, IProto<ModelState>, IProto
{
	public enum Flag
	{
		Ducked = 1,
		Jumped = 2,
		OnGround = 4,
		Sleeping = 8,
		Sprinting = 0x10,
		OnLadder = 0x20,
		Flying = 0x40,
		Aiming = 0x80,
		Prone = 0x100,
		Mounted = 0x200,
		Relaxed = 0x400,
		OnPhone = 0x800,
		Crawling = 0x1000,
		Loading = 0x2000,
		HeadLook = 0x4000,
		HasParachute = 0x8000,
		Blocking = 0x10000,
		Ragdolling = 0x20000,
		Catching = 0x40000
	}

	[NonSerialized]
	public float waterLevel;

	[NonSerialized]
	public Vector3 lookDir;

	[NonSerialized]
	public int flags;

	[NonSerialized]
	public int poseType;

	[NonSerialized]
	public Vector3 inheritedVelocity;

	[NonSerialized]
	public int ladderType;

	[NonSerialized]
	public Vector3 guidePosition;

	[NonSerialized]
	public Vector3 guideRotation;

	[NonSerialized]
	public uint guidePrefab;

	[NonSerialized]
	public bool guideValid;

	[NonSerialized]
	public int guideVersion;

	[NonSerialized]
	public float ducking;

	[NonSerialized]
	public Vector3 localShieldPos;

	[NonSerialized]
	public Vector3 localShieldRot;

	public bool ShouldPool = true;

	private bool _disposed;

	public bool ducked
	{
		get
		{
			return HasFlag(Flag.Ducked);
		}
		set
		{
			SetFlag(Flag.Ducked, value);
		}
	}

	public bool jumped
	{
		get
		{
			return HasFlag(Flag.Jumped);
		}
		set
		{
			SetFlag(Flag.Jumped, value);
		}
	}

	public bool onground
	{
		get
		{
			return HasFlag(Flag.OnGround);
		}
		set
		{
			SetFlag(Flag.OnGround, value);
		}
	}

	public bool sleeping
	{
		get
		{
			return HasFlag(Flag.Sleeping);
		}
		set
		{
			SetFlag(Flag.Sleeping, value);
		}
	}

	public bool sprinting
	{
		get
		{
			return HasFlag(Flag.Sprinting);
		}
		set
		{
			SetFlag(Flag.Sprinting, value);
		}
	}

	public bool onLadder
	{
		get
		{
			return HasFlag(Flag.OnLadder);
		}
		set
		{
			SetFlag(Flag.OnLadder, value);
		}
	}

	public bool flying
	{
		get
		{
			return HasFlag(Flag.Flying);
		}
		set
		{
			SetFlag(Flag.Flying, value);
		}
	}

	public bool aiming
	{
		get
		{
			return HasFlag(Flag.Aiming);
		}
		set
		{
			SetFlag(Flag.Aiming, value);
		}
	}

	public bool prone
	{
		get
		{
			return HasFlag(Flag.Prone);
		}
		set
		{
			SetFlag(Flag.Prone, value);
		}
	}

	public bool mounted
	{
		get
		{
			return HasFlag(Flag.Mounted);
		}
		set
		{
			SetFlag(Flag.Mounted, value);
		}
	}

	public bool relaxed
	{
		get
		{
			return HasFlag(Flag.Relaxed);
		}
		set
		{
			SetFlag(Flag.Relaxed, value);
		}
	}

	public bool onPhone
	{
		get
		{
			return HasFlag(Flag.OnPhone);
		}
		set
		{
			SetFlag(Flag.OnPhone, value);
		}
	}

	public bool crawling
	{
		get
		{
			return HasFlag(Flag.Crawling);
		}
		set
		{
			SetFlag(Flag.Crawling, value);
		}
	}

	public bool catching
	{
		get
		{
			return HasFlag(Flag.Catching);
		}
		set
		{
			SetFlag(Flag.Catching, value);
		}
	}

	public bool hasParachute
	{
		get
		{
			return HasFlag(Flag.HasParachute);
		}
		set
		{
			SetFlag(Flag.HasParachute, value);
		}
	}

	public bool ragdolling
	{
		get
		{
			return HasFlag(Flag.Ragdolling);
		}
		set
		{
			SetFlag(Flag.Ragdolling, value);
		}
	}

	public bool blocking
	{
		get
		{
			return HasFlag(Flag.Blocking);
		}
		set
		{
			SetFlag(Flag.Blocking, value);
		}
	}

	public bool headLook
	{
		get
		{
			return HasFlag(Flag.HeadLook);
		}
		set
		{
			SetFlag(Flag.HeadLook, value);
		}
	}

	public bool loading
	{
		get
		{
			return HasFlag(Flag.Loading);
		}
		set
		{
			SetFlag(Flag.Loading, value);
		}
	}

	public static void ResetToPool(ModelState instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.waterLevel = 0f;
			instance.lookDir = default(Vector3);
			instance.flags = 0;
			instance.poseType = 0;
			instance.inheritedVelocity = default(Vector3);
			instance.ladderType = 0;
			instance.guidePosition = default(Vector3);
			instance.guideRotation = default(Vector3);
			instance.guidePrefab = 0u;
			instance.guideValid = false;
			instance.guideVersion = 0;
			instance.ducking = 0f;
			instance.localShieldPos = default(Vector3);
			instance.localShieldRot = default(Vector3);
			Pool.Free<ModelState>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ModelState with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ModelState instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		instance.waterLevel = waterLevel;
		instance.lookDir = lookDir;
		instance.flags = flags;
		instance.poseType = poseType;
		instance.inheritedVelocity = inheritedVelocity;
		instance.ladderType = ladderType;
		instance.guidePosition = guidePosition;
		instance.guideRotation = guideRotation;
		instance.guidePrefab = guidePrefab;
		instance.guideValid = guideValid;
		instance.guideVersion = guideVersion;
		instance.ducking = ducking;
		instance.localShieldPos = localShieldPos;
		instance.localShieldRot = localShieldRot;
	}

	public ModelState Copy()
	{
		ModelState modelState = Pool.Get<ModelState>();
		CopyTo(modelState);
		return modelState;
	}

	public static ModelState Deserialize(BufferStream stream)
	{
		ModelState modelState = Pool.Get<ModelState>();
		Deserialize(stream, modelState, isDelta: false);
		return modelState;
	}

	public static ModelState DeserializeLengthDelimited(BufferStream stream)
	{
		ModelState modelState = Pool.Get<ModelState>();
		DeserializeLengthDelimited(stream, modelState, isDelta: false);
		return modelState;
	}

	public static ModelState DeserializeLength(BufferStream stream, int length)
	{
		ModelState modelState = Pool.Get<ModelState>();
		DeserializeLength(stream, length, modelState, isDelta: false);
		return modelState;
	}

	public static ModelState Deserialize(byte[] buffer)
	{
		ModelState modelState = Pool.Get<ModelState>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, modelState, isDelta: false);
		return modelState;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ModelState previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ModelState Deserialize(BufferStream stream, ModelState instance, bool isDelta)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 37:
				instance.waterLevel = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.lookDir, isDelta);
				continue;
			case 88:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.poseType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 106:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inheritedVelocity, isDelta);
				continue;
			case 112:
				instance.ladderType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.guidePosition, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.guideRotation, isDelta);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.guidePrefab = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.Varint)
				{
					instance.guideValid = ProtocolParser.ReadBool(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.guideVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.ducking = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localShieldPos, isDelta);
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localShieldRot, isDelta);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static ModelState DeserializeLengthDelimited(BufferStream stream, ModelState instance, bool isDelta)
	{
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 37:
				instance.waterLevel = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.lookDir, isDelta);
				continue;
			case 88:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.poseType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 106:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inheritedVelocity, isDelta);
				continue;
			case 112:
				instance.ladderType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.guidePosition, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.guideRotation, isDelta);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.guidePrefab = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.Varint)
				{
					instance.guideValid = ProtocolParser.ReadBool(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.guideVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.ducking = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localShieldPos, isDelta);
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localShieldRot, isDelta);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ModelState DeserializeLength(BufferStream stream, int length, ModelState instance, bool isDelta)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 37:
				instance.waterLevel = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.lookDir, isDelta);
				continue;
			case 88:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.poseType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 106:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inheritedVelocity, isDelta);
				continue;
			case 112:
				instance.ladderType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.guidePosition, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.guideRotation, isDelta);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.guidePrefab = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.Varint)
				{
					instance.guideValid = ProtocolParser.ReadBool(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.guideVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.ducking = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localShieldPos, isDelta);
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localShieldRot, isDelta);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ModelState instance, ModelState previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_034a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		if (instance.waterLevel != previous.waterLevel)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.waterLevel);
		}
		if (instance.lookDir != previous.lookDir)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.lookDir, previous.lookDir);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field lookDir (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.flags != previous.flags)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.poseType != previous.poseType)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.poseType);
		}
		if (instance.inheritedVelocity != previous.inheritedVelocity)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.inheritedVelocity, previous.inheritedVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inheritedVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.ladderType != previous.ladderType)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ladderType);
		}
		if (instance.guidePosition != previous.guidePosition)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.guidePosition, previous.guidePosition);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field guidePosition (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.guideRotation != previous.guideRotation)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.guideRotation, previous.guideRotation);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field guideRotation (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.guidePrefab != previous.guidePrefab)
		{
			stream.WriteByte(136);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.guidePrefab);
		}
		stream.WriteByte(144);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.guideValid);
		if (instance.guideVersion != previous.guideVersion)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.guideVersion);
		}
		if (instance.ducking != previous.ducking)
		{
			stream.WriteByte(165);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.ducking);
		}
		if (instance.localShieldPos != previous.localShieldPos)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.localShieldPos, previous.localShieldPos);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localShieldPos (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.localShieldRot != previous.localShieldRot)
		{
			stream.WriteByte(178);
			stream.WriteByte(1);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.localShieldRot, previous.localShieldRot);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localShieldRot (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
	}

	public static void Serialize(BufferStream stream, ModelState instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.waterLevel != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.waterLevel);
		}
		if (instance.lookDir != default(Vector3))
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.lookDir);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field lookDir (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.flags != 0)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.poseType != 0)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.poseType);
		}
		if (instance.inheritedVelocity != default(Vector3))
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.inheritedVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inheritedVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.ladderType != 0)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ladderType);
		}
		if (instance.guidePosition != default(Vector3))
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.guidePosition);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field guidePosition (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.guideRotation != default(Vector3))
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.guideRotation);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field guideRotation (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.guidePrefab != 0)
		{
			stream.WriteByte(136);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.guidePrefab);
		}
		if (instance.guideValid)
		{
			stream.WriteByte(144);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.guideValid);
		}
		if (instance.guideVersion != 0)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.guideVersion);
		}
		if (instance.ducking != 0f)
		{
			stream.WriteByte(165);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.ducking);
		}
		if (instance.localShieldPos != default(Vector3))
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.localShieldPos);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localShieldPos (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.localShieldRot != default(Vector3))
		{
			stream.WriteByte(178);
			stream.WriteByte(1);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.localShieldRot);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localShieldRot (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}

	public ModelState()
	{
		onground = true;
		waterLevel = 0f;
		flying = false;
		sprinting = false;
		ducked = false;
		onLadder = false;
		sleeping = false;
		mounted = false;
		relaxed = false;
		crawling = false;
		loading = false;
		ragdolling = false;
		poseType = 0;
		ducking = 0f;
	}

	public bool HasFlag(Flag f)
	{
		return ((uint)flags & (uint)f) == (uint)f;
	}

	public void SetFlag(Flag f, bool b)
	{
		if (b)
		{
			flags |= (int)f;
		}
		else
		{
			flags &= (int)(~f);
		}
	}

	public static bool Equal(ModelState a, ModelState b)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		if (a == b)
		{
			return true;
		}
		if (a == null || b == null)
		{
			return false;
		}
		if (a.flags != b.flags)
		{
			return false;
		}
		if (a.waterLevel != b.waterLevel)
		{
			return false;
		}
		if (a.lookDir != b.lookDir)
		{
			return false;
		}
		if (a.poseType != b.poseType)
		{
			return false;
		}
		if (a.guidePrefab != b.guidePrefab)
		{
			return false;
		}
		if (a.guidePosition != b.guidePosition)
		{
			return false;
		}
		if (a.guideRotation != b.guideRotation)
		{
			return false;
		}
		if (a.guideValid != b.guideValid)
		{
			return false;
		}
		if (a.ducking != b.ducking)
		{
			return false;
		}
		return true;
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerTick : IDisposable, IPooled, IProto<PlayerTick>, IProto
{
	[NonSerialized]
	public InputMessage inputState;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public ModelState modelState;

	[NonSerialized]
	public ItemId activeItem;

	[NonSerialized]
	public Vector3 eyePos;

	[NonSerialized]
	public NetworkableId parentID;

	[NonSerialized]
	public uint deltaMs;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerTick instance)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			if (instance.inputState != null)
			{
				instance.inputState.ResetToPool();
				instance.inputState = null;
			}
			instance.position = default(Vector3);
			if (instance.modelState != null)
			{
				instance.modelState.ResetToPool();
				instance.modelState = null;
			}
			instance.activeItem = default(ItemId);
			instance.eyePos = default(Vector3);
			instance.parentID = default(NetworkableId);
			instance.deltaMs = 0u;
			Pool.Free<PlayerTick>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerTick with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerTick instance)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		if (inputState != null)
		{
			if (instance.inputState == null)
			{
				instance.inputState = inputState.Copy();
			}
			else
			{
				inputState.CopyTo(instance.inputState);
			}
		}
		else
		{
			instance.inputState = null;
		}
		instance.position = position;
		if (modelState != null)
		{
			if (instance.modelState == null)
			{
				instance.modelState = modelState.Copy();
			}
			else
			{
				modelState.CopyTo(instance.modelState);
			}
		}
		else
		{
			instance.modelState = null;
		}
		instance.activeItem = activeItem;
		instance.eyePos = eyePos;
		instance.parentID = parentID;
		instance.deltaMs = deltaMs;
	}

	public PlayerTick Copy()
	{
		PlayerTick playerTick = Pool.Get<PlayerTick>();
		CopyTo(playerTick);
		return playerTick;
	}

	public static PlayerTick Deserialize(BufferStream stream)
	{
		PlayerTick playerTick = Pool.Get<PlayerTick>();
		Deserialize(stream, playerTick, isDelta: false);
		return playerTick;
	}

	public static PlayerTick DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerTick playerTick = Pool.Get<PlayerTick>();
		DeserializeLengthDelimited(stream, playerTick, isDelta: false);
		return playerTick;
	}

	public static PlayerTick DeserializeLength(BufferStream stream, int length)
	{
		PlayerTick playerTick = Pool.Get<PlayerTick>();
		DeserializeLength(stream, length, playerTick, isDelta: false);
		return playerTick;
	}

	public static PlayerTick Deserialize(byte[] buffer)
	{
		PlayerTick playerTick = Pool.Get<PlayerTick>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerTick, isDelta: false);
		return playerTick;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerTick previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerTick Deserialize(BufferStream stream, PlayerTick instance, bool isDelta)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.inputState == null)
				{
					instance.inputState = InputMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					InputMessage.DeserializeLengthDelimited(stream, instance.inputState, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				break;
			case 34:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				break;
			case 40:
				instance.activeItem = new ItemId(ProtocolParser.ReadUInt64(stream));
				break;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.eyePos, isDelta);
				break;
			case 56:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 64:
				instance.deltaMs = ProtocolParser.ReadUInt32(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static PlayerTick DeserializeLengthDelimited(BufferStream stream, PlayerTick instance, bool isDelta)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.inputState == null)
				{
					instance.inputState = InputMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					InputMessage.DeserializeLengthDelimited(stream, instance.inputState, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				break;
			case 34:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				break;
			case 40:
				instance.activeItem = new ItemId(ProtocolParser.ReadUInt64(stream));
				break;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.eyePos, isDelta);
				break;
			case 56:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 64:
				instance.deltaMs = ProtocolParser.ReadUInt32(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerTick DeserializeLength(BufferStream stream, int length, PlayerTick instance, bool isDelta)
	{
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.inputState == null)
				{
					instance.inputState = InputMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					InputMessage.DeserializeLengthDelimited(stream, instance.inputState, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				break;
			case 34:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				break;
			case 40:
				instance.activeItem = new ItemId(ProtocolParser.ReadUInt64(stream));
				break;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.eyePos, isDelta);
				break;
			case 56:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 64:
				instance.deltaMs = ProtocolParser.ReadUInt32(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerTick instance, PlayerTick previous)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		if (instance.inputState == null)
		{
			throw new ArgumentNullException("inputState", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int num = stream.Position;
		InputMessage.SerializeDelta(stream, instance.inputState, previous.inputState);
		int num2 = stream.Position - num;
		if (num2 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inputState (global::InputMessage)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num2, span, 0);
		if (instance.position != previous.position)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.modelState == null)
		{
			throw new ArgumentNullException("modelState", "Required by proto specification.");
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range3 = stream.GetRange(2);
		int num5 = stream.Position;
		ModelState.SerializeDelta(stream, instance.modelState, previous.modelState);
		int num6 = stream.Position - num5;
		if (num6 > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modelState (global::ModelState)");
		}
		Span<byte> span3 = range3.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num6, span3, 0) < 2)
		{
			span3[0] |= 128;
			span3[1] = 0;
		}
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.activeItem.Value);
		if (instance.eyePos != previous.eyePos)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.eyePos, previous.eyePos);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field eyePos (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		if (instance.deltaMs != previous.deltaMs)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.deltaMs);
		}
	}

	public static void Serialize(BufferStream stream, PlayerTick instance)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		if (instance.inputState == null)
		{
			throw new ArgumentNullException("inputState", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int num = stream.Position;
		InputMessage.Serialize(stream, instance.inputState);
		int num2 = stream.Position - num;
		if (num2 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inputState (global::InputMessage)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num2, span, 0);
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.modelState == null)
		{
			throw new ArgumentNullException("modelState", "Required by proto specification.");
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range3 = stream.GetRange(2);
		int num5 = stream.Position;
		ModelState.Serialize(stream, instance.modelState);
		int num6 = stream.Position - num5;
		if (num6 > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modelState (global::ModelState)");
		}
		Span<byte> span3 = range3.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num6, span3, 0) < 2)
		{
			span3[0] |= 128;
			span3[1] = 0;
		}
		if (instance.activeItem != default(ItemId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.activeItem.Value);
		}
		if (instance.eyePos != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.eyePos);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field eyePos (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		if (instance.parentID != default(NetworkableId))
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		}
		if (instance.deltaMs != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.deltaMs);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		inputState?.InspectUids(action);
		modelState?.InspectUids(action);
		action(UidType.ItemId, ref activeItem.Value);
		action(UidType.NetworkableId, ref parentID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public static class ProtoStreamExtensions
{
	public static void WriteToStream(this IProto proto, Stream stream, bool lengthDelimited = false, int maxSizeHint = 2097152)
	{
		if (proto == null)
		{
			throw new ArgumentNullException("proto");
		}
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
		using BufferStream bufferStream = Pool.Get<BufferStream>().Initialize();
		(int MaxLength, int LengthPrefixSize) lengthPrefixSize = GetLengthPrefixSize(maxSizeHint);
		int item = lengthPrefixSize.MaxLength;
		int item2 = lengthPrefixSize.LengthPrefixSize;
		BufferStream.RangeHandle rangeHandle = default(BufferStream.RangeHandle);
		if (lengthDelimited)
		{
			rangeHandle = bufferStream.GetRange(item2);
		}
		int position = bufferStream.Position;
		proto.WriteToStream(bufferStream);
		if (lengthDelimited)
		{
			int num = bufferStream.Position - position;
			if (num > item)
			{
				throw new InvalidOperationException($"Written proto exceeds maximum size hint (maxSizeHint={maxSizeHint}, actualLength={num})");
			}
			Span<byte> span = rangeHandle.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 != item2)
			{
				span[num2 - 1] |= 128;
				while (num2 < item2 - 1)
				{
					span[num2++] = 128;
				}
				span[num2] = 0;
			}
		}
		if (bufferStream.Length > 0)
		{
			ArraySegment<byte> buffer = bufferStream.GetBuffer();
			stream.Write(buffer.Array, buffer.Offset, buffer.Count);
		}
	}

	private static (int MaxLength, int LengthPrefixSize) GetLengthPrefixSize(int maxSizeHint)
	{
		if (maxSizeHint < 0)
		{
			throw new ArgumentOutOfRangeException("maxSizeHint");
		}
		if (maxSizeHint <= 127)
		{
			return (MaxLength: 127, LengthPrefixSize: 1);
		}
		if (maxSizeHint <= 16383)
		{
			return (MaxLength: 16383, LengthPrefixSize: 2);
		}
		if (maxSizeHint <= 2097151)
		{
			return (MaxLength: 2097151, LengthPrefixSize: 3);
		}
		if (maxSizeHint <= 268435455)
		{
			return (MaxLength: 16777215, LengthPrefixSize: 4);
		}
		throw new ArgumentOutOfRangeException("maxSizeHint");
	}

	public static void ReadFromStream(this IProto proto, Stream stream, bool isDelta = false, int maxSize = 1048576)
	{
		if (proto == null)
		{
			throw new ArgumentNullException("proto");
		}
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
		long position = stream.Position;
		byte[] array = BufferStream.Shared.ArrayPool.Rent(maxSize);
		int num = 0;
		int num2 = maxSize;
		while (num2 > 0)
		{
			int num3 = stream.Read(array, num, num2);
			if (num3 <= 0)
			{
				break;
			}
			num += num3;
			num2 -= num3;
		}
		using BufferStream bufferStream = Pool.Get<BufferStream>().Initialize(array, num);
		proto.ReadFromStream(bufferStream, isDelta);
		BufferStream.Shared.ArrayPool.Return(array);
		int position2 = bufferStream.Position;
		stream.Position = position + position2;
	}

	public static void ReadFromStream(this IProto proto, Stream stream, int length, bool isDelta = false)
	{
		if (proto == null)
		{
			throw new ArgumentNullException("proto");
		}
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
		if (length <= 0)
		{
			throw new ArgumentOutOfRangeException("length");
		}
		byte[] array = BufferStream.Shared.ArrayPool.Rent(length);
		int num = 0;
		int num2 = length;
		while (num2 > 0)
		{
			int num3 = stream.Read(array, num, num2);
			if (num3 <= 0)
			{
				throw new InvalidOperationException("Unexpected end of stream");
			}
			num += num3;
			num2 -= num3;
		}
		using BufferStream stream2 = Pool.Get<BufferStream>().Initialize(array, length);
		proto.ReadFromStream(stream2, isDelta);
		BufferStream.Shared.ArrayPool.Return(array);
	}

	public static void ReadFromStreamLengthDelimited(this IProto proto, Stream stream, bool isDelta = false)
	{
		if (proto == null)
		{
			throw new ArgumentNullException("proto");
		}
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
		int length = (int)ProtocolParser.ReadUInt32(stream);
		proto.ReadFromStream(stream, length, isDelta);
	}

	public static byte[] ToProtoBytes(this IProto proto)
	{
		if (proto == null)
		{
			throw new ArgumentNullException("proto");
		}
		using BufferStream bufferStream = Pool.Get<BufferStream>().Initialize();
		proto.WriteToStream(bufferStream);
		ArraySegment<byte> buffer = bufferStream.GetBuffer();
		byte[] array = new byte[bufferStream.Position];
		new Span<byte>(buffer.Array, buffer.Offset, buffer.Count).CopyTo(array);
		return array;
	}
}


using System;
using System.Runtime.CompilerServices;
using Facepunch;
using UnityEngine;

public sealed class BufferStream : IDisposable, IPooled
{
	public static class Shared
	{
		public static int StartingCapacity = 64;

		public static int MaximumCapacity = 536870912;

		public static int MaximumPooledSize = 67108864;

		public static readonly ArrayPool<byte> ArrayPool = new ArrayPool<byte>(MaximumPooledSize);
	}

	public readonly ref struct RangeHandle
	{
		private readonly BufferStream _stream;

		private readonly int _offset;

		private readonly int _length;

		public RangeHandle(BufferStream stream, int offset, int length)
		{
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			_stream = stream ?? throw new ArgumentNullException("stream");
			_offset = offset;
			_length = length;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Span<byte> GetSpan()
		{
			return new Span<byte>(_stream._buffer, _offset, _length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public ArraySegment<byte> GetSegment()
		{
			return new ArraySegment<byte>(_stream._buffer, _offset, _length);
		}
	}

	private bool _isBufferOwned;

	private byte[] _buffer;

	private int _length;

	private int _position;

	public int Length
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return _length;
		}
		set
		{
			if (value < 0)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			if (_position > value)
			{
				throw new InvalidOperationException("Cannot shrink buffer below current position!");
			}
			int num = value - _length;
			if (num > 0)
			{
				EnsureCapacity(num);
			}
			_length = value;
		}
	}

	public int Position
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return _position;
		}
		set
		{
			if (value < 0 || value > _length)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			_position = value;
		}
	}

	public BufferStream Initialize()
	{
		_isBufferOwned = true;
		_buffer = null;
		_length = 0;
		_position = 0;
		return this;
	}

	public BufferStream Initialize(Span<byte> buffer)
	{
		_isBufferOwned = true;
		_buffer = null;
		_length = buffer.Length;
		_position = 0;
		EnsureCapacity(buffer.Length);
		buffer.CopyTo(_buffer);
		return this;
	}

	public BufferStream Initialize(byte[] buffer, int length = -1)
	{
		if (buffer == null)
		{
			throw new ArgumentNullException("buffer");
		}
		if (length > buffer.Length)
		{
			throw new ArgumentOutOfRangeException("length");
		}
		_isBufferOwned = false;
		_buffer = buffer;
		_length = ((length < 0) ? buffer.Length : length);
		_position = 0;
		return this;
	}

	public void Dispose()
	{
		if (_isBufferOwned && _buffer != null)
		{
			ReturnBuffer(_buffer);
		}
		_buffer = null;
		BufferStream bufferStream = this;
		Pool.Free<BufferStream>(ref bufferStream);
	}

	void IPooled.EnterPool()
	{
		if (_isBufferOwned && _buffer != null)
		{
			ReturnBuffer(_buffer);
		}
		_buffer = null;
	}

	void IPooled.LeavePool()
	{
	}

	public void Clear()
	{
		_length = 0;
		_position = 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int ReadByte()
	{
		if (_position >= _length)
		{
			return -1;
		}
		return _buffer[_position++];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void WriteByte(byte b)
	{
		EnsureCapacity(1);
		_buffer[_position++] = b;
		_length = Math.Max(_length, _position);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public T Read<T>() where T : unmanaged
	{
		int num = Unsafe.SizeOf<T>();
		if (_length - _position < num)
		{
			ThrowReadOutOfBounds();
		}
		ref T reference = ref Unsafe.As<byte, T>(ref _buffer[_position]);
		_position += num;
		return reference;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public T Peek<T>() where T : unmanaged
	{
		int num = Unsafe.SizeOf<T>();
		if (_length - _position < num)
		{
			ThrowReadOutOfBounds();
		}
		return Unsafe.As<byte, T>(ref _buffer[_position]);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void ThrowReadOutOfBounds()
	{
		throw new InvalidOperationException("Attempted to read past the end of the BufferStream");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Write<T>(T value) where T : unmanaged
	{
		int num = Unsafe.SizeOf<T>();
		EnsureCapacity(num);
		Unsafe.As<byte, T>(ref _buffer[_position]) = value;
		_position += num;
		_length = Math.Max(_length, _position);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public RangeHandle GetRange(int count)
	{
		EnsureCapacity(count);
		RangeHandle result = new RangeHandle(this, _position, count);
		_position += count;
		_length = Math.Max(_length, _position);
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Skip(int count)
	{
		_position += count;
	}

	public ArraySegment<byte> GetBuffer()
	{
		if (_length == 0)
		{
			return new ArraySegment<byte>(Array.Empty<byte>(), 0, 0);
		}
		return new ArraySegment<byte>(_buffer, 0, _length);
	}

	private void EnsureCapacity(int spaceRequired)
	{
		if (spaceRequired < 0)
		{
			throw new ArgumentOutOfRangeException("spaceRequired");
		}
		if (_buffer == null)
		{
			if (!_isBufferOwned)
			{
				throw new InvalidOperationException("Cannot allocate for BufferStream that doesn't own the buffer (did you forget to call Initialize?)");
			}
			int num = ((spaceRequired <= Shared.StartingCapacity) ? Shared.StartingCapacity : spaceRequired);
			int num2 = Mathf.NextPowerOfTwo(num);
			if (num2 > Shared.MaximumCapacity)
			{
				throw new Exception($"Preventing BufferStream buffer from growing too large (requiredLength={num})");
			}
			_buffer = RentBuffer(num2);
		}
		else if (_buffer.Length - _position < spaceRequired)
		{
			int num3 = _position + spaceRequired;
			int num4 = Mathf.NextPowerOfTwo(Math.Max(num3, _buffer.Length));
			if (!_isBufferOwned)
			{
				throw new InvalidOperationException($"Cannot grow buffer for BufferStream that doesn't own the buffer (requiredLength={num3})");
			}
			if (num4 > Shared.MaximumCapacity)
			{
				throw new Exception($"Preventing BufferStream buffer from growing too large (requiredLength={num3})");
			}
			byte[] array = RentBuffer(num4);
			Buffer.BlockCopy(_buffer, 0, array, 0, _length);
			ReturnBuffer(_buffer);
			_buffer = array;
		}
	}

	private static byte[] RentBuffer(int minSize)
	{
		if (minSize > Shared.MaximumPooledSize)
		{
			return new byte[minSize];
		}
		return Shared.ArrayPool.Rent(minSize);
	}

	private static void ReturnBuffer(byte[] buffer)
	{
		if (buffer != null && buffer.Length <= Shared.MaximumPooledSize)
		{
			Shared.ArrayPool.Return(buffer);
		}
	}
}


public interface IStreamReader
{
	byte UInt8();

	ushort UInt16();

	uint UInt32();

	ulong UInt64();

	sbyte Int8();

	short Int16();

	int Int32();

	long Int64();

	bool Bool();

	float Float();

	double Double();

	uint VarUInt32();

	string StringRaw(int maxLength, bool variableLength = false);

	byte[] BytesWithSize(uint maxLength, bool variableLength = false);
}


public interface IStreamWriter
{
	void UInt8(byte val);

	void UInt16(ushort val);

	void UInt32(uint val);

	void UInt64(ulong val);

	void Int8(sbyte val);

	void Int16(short val);

	void Int32(int val);

	void Int64(long val);

	void Bool(bool val);

	void Float(float val);

	void Double(double val);

	void Bytes(byte[] val);

	void BytesWithSize(byte[] val, bool variableLength = false);

	void String(string val, bool variableLength = false);
}


using System;

public struct ItemContainerId : IEquatable<ItemContainerId>
{
	public ulong Value;

	public static readonly ItemContainerId Invalid = new ItemContainerId(ulong.MaxValue);

	public bool IsValid => Value != 0;

	public ItemContainerId(ulong value)
	{
		Value = value;
	}

	public override string ToString()
	{
		return Value.ToString("G");
	}

	public bool Equals(ItemContainerId other)
	{
		return Value == other.Value;
	}

	public override bool Equals(object obj)
	{
		if (obj is ItemContainerId other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public static bool operator ==(ItemContainerId left, ItemContainerId right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(ItemContainerId left, ItemContainerId right)
	{
		return !left.Equals(right);
	}
}


using System;

public struct ItemId : IEquatable<ItemId>
{
	public ulong Value;

	public bool IsValid => Value != 0;

	public ItemId(ulong value)
	{
		Value = value;
	}

	public override string ToString()
	{
		return Value.ToString("G");
	}

	public bool Equals(ItemId other)
	{
		return Value == other.Value;
	}

	public override bool Equals(object obj)
	{
		if (obj is ItemId other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public static bool operator ==(ItemId left, ItemId right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(ItemId left, ItemId right)
	{
		return !left.Equals(right);
	}
}


using System;

[Flags]
public enum ItemMoveModifier
{
	None = 0,
	Alt = 2,
	Shift = 4,
	Ctrl = 8,
	BackpackOpen = 0x10
}


using System;

public struct NetworkableId : IEquatable<NetworkableId>
{
	public ulong Value;

	public bool IsValid => Value != 0;

	public static NetworkableId EmptyId => new NetworkableId(0uL);

	public NetworkableId(ulong value)
	{
		Value = value;
	}

	public override string ToString()
	{
		return Value.ToString("G");
	}

	public bool Equals(NetworkableId other)
	{
		return Value == other.Value;
	}

	public override bool Equals(object obj)
	{
		if (obj is NetworkableId other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public static bool operator ==(NetworkableId left, NetworkableId right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(NetworkableId left, NetworkableId right)
	{
		return !left.Equals(right);
	}
}


public class NetworkDefines
{
	public const int MinNetWriteBufferSize = 2048;

	public const int MaxNetWriteBufferSize = 4194304;

	public const int MaxNetReadPacketSize = 6291456;

	public const int MinNetReadBufferSize = 2048;

	public const int MaxNetReadBufferSize = 8388608;

	public const int MaxServerPacketSize = 10000000;
}


using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		MonoScriptData result = default(MonoScriptData);
		result.FilePathsData = new byte[628]
		{
			0, 0, 1, 178, 0, 0, 0, 54, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 68,
			97, 116, 97, 92, 103, 101, 110, 101, 114, 97,
			116, 101, 100, 92, 80, 114, 111, 116, 111, 99,
			111, 108, 66, 117, 102, 102, 101, 114, 115, 46,
			99, 115, 0, 0, 1, 184, 0, 0, 0, 65,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 82, 117, 115, 116,
			46, 68, 97, 116, 97, 92, 103, 101, 110, 101,
			114, 97, 116, 101, 100, 92, 80, 114, 111, 116,
			111, 99, 111, 108, 66, 117, 102, 102, 101, 114,
			115, 46, 83, 101, 114, 105, 97, 108, 105, 122,
			101, 114, 46, 99, 115, 0, 0, 0, 11, 0,
			0, 0, 53, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 82,
			117, 115, 116, 46, 68, 97, 116, 97, 92, 103,
			101, 110, 101, 114, 97, 116, 101, 100, 92, 80,
			114, 111, 116, 111, 99, 111, 108, 80, 97, 114,
			115, 101, 114, 46, 99, 115, 0, 0, 0, 1,
			0, 0, 0, 34, 92, 65, 115, 115, 101, 116,
			115, 92, 80, 108, 117, 103, 105, 110, 115, 92,
			82, 117, 115, 116, 46, 68, 97, 116, 97, 92,
			72, 97, 108, 102, 51, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 42, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 82, 117, 115, 116, 46, 68, 97, 116,
			97, 92, 73, 83, 116, 114, 101, 97, 109, 82,
			101, 97, 100, 101, 114, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 42, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 82, 117, 115, 116, 46, 68, 97, 116,
			97, 92, 73, 83, 116, 114, 101, 97, 109, 87,
			114, 105, 116, 101, 114, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 44, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 82, 117, 115, 116, 46, 68, 97, 116,
			97, 92, 73, 116, 101, 109, 67, 111, 110, 116,
			97, 105, 110, 101, 114, 73, 100, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 35, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 68,
			97, 116, 97, 92, 73, 116, 101, 109, 73, 100,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			39, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 82, 117, 115,
			116, 46, 68, 97, 116, 97, 92, 77, 111, 100,
			101, 108, 83, 116, 97, 116, 101, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 42, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 68,
			97, 116, 97, 92, 78, 101, 116, 119, 111, 114,
			107, 97, 98, 108, 101, 73, 100, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 43, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 68,
			97, 116, 97, 92, 78, 101, 116, 119, 111, 114,
			107, 68, 101, 102, 105, 110, 101, 115, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 39, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 82, 117, 115, 116, 46,
			68, 97, 116, 97, 92, 86, 101, 99, 116, 111,
			114, 68, 97, 116, 97, 46, 99, 115
		};
		result.TypesData = new byte[26069]
		{
			1, 0, 0, 0, 35, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 103, 103, 114, 101, 115,
			115, 105, 111, 110, 84, 105, 109, 101, 114, 65,
			73, 69, 118, 101, 110, 116, 68, 97, 116, 97,
			1, 0, 0, 0, 17, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 73, 68, 101, 115, 105,
			103, 110, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 73, 69, 118,
			101, 110, 116, 68, 97, 116, 97, 1, 0, 0,
			0, 25, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 73, 83, 116, 97, 116, 101, 67, 111,
			110, 116, 97, 105, 110, 101, 114, 1, 0, 0,
			0, 29, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 109, 109, 111, 66, 101, 108, 111, 119,
			65, 73, 69, 118, 101, 110, 116, 68, 97, 116,
			97, 1, 0, 0, 0, 21, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 112, 112, 66, 114,
			111, 97, 100, 99, 97, 115, 116, 1, 0, 0,
			0, 22, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 67, 97, 109, 101, 114, 97,
			73, 110, 102, 111, 1, 0, 0, 0, 23, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 67, 97, 109, 101, 114, 97, 73, 110, 112,
			117, 116, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 112, 112, 67,
			97, 109, 101, 114, 97, 82, 97, 121, 115, 1,
			0, 0, 0, 29, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 65, 112, 112, 67, 97, 109, 101,
			114, 97, 82, 97, 121, 115, 124, 69, 110, 116,
			105, 116, 121, 1, 0, 0, 0, 27, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			67, 97, 109, 101, 114, 97, 83, 117, 98, 115,
			99, 114, 105, 98, 101, 1, 0, 0, 0, 23,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 67, 108, 97, 110, 67, 104, 97, 110,
			103, 101, 100, 1, 0, 0, 0, 20, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			67, 108, 97, 110, 67, 104, 97, 116, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 67, 108, 97, 110, 73,
			110, 102, 111, 1, 0, 0, 0, 23, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			67, 108, 97, 110, 77, 101, 115, 115, 97, 103,
			101, 1, 0, 0, 0, 17, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 112, 112, 69, 109,
			112, 116, 121, 1, 0, 0, 0, 25, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			69, 110, 116, 105, 116, 121, 67, 104, 97, 110,
			103, 101, 100, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			69, 110, 116, 105, 116, 121, 73, 110, 102, 111,
			1, 0, 0, 0, 25, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 69, 110, 116,
			105, 116, 121, 80, 97, 121, 108, 111, 97, 100,
			1, 0, 0, 0, 30, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 65, 112, 112, 69, 110, 116,
			105, 116, 121, 80, 97, 121, 108, 111, 97, 100,
			124, 73, 116, 101, 109, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 69, 114, 114, 111, 114, 1, 0, 0,
			0, 16, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 70, 108, 97, 103, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 71, 101, 116, 78, 101,
			120, 117, 115, 65, 117, 116, 104, 1, 0, 0,
			0, 16, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 73, 110, 102, 111, 1, 0,
			0, 0, 15, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 77, 97, 112, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 65, 112, 112, 77, 97, 112, 124, 77,
			111, 110, 117, 109, 101, 110, 116, 1, 0, 0,
			0, 22, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 77, 97, 112, 77, 97, 114,
			107, 101, 114, 115, 1, 0, 0, 0, 18, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 77, 97, 114, 107, 101, 114, 1, 0, 0,
			0, 28, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 65, 112, 112, 77, 97, 114, 107, 101, 114,
			124, 83, 101, 108, 108, 79, 114, 100, 101, 114,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 77, 101, 115,
			115, 97, 103, 101, 1, 0, 0, 0, 26, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 78, 101, 119, 67, 108, 97, 110, 77, 101,
			115, 115, 97, 103, 101, 1, 0, 0, 0, 26,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 78, 101, 119, 84, 101, 97, 109, 77,
			101, 115, 115, 97, 103, 101, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 112, 112, 78, 101, 120, 117, 115, 65, 117,
			116, 104, 1, 0, 0, 0, 27, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 112, 112, 80,
			114, 111, 109, 111, 116, 101, 84, 111, 76, 101,
			97, 100, 101, 114, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 82, 101, 113, 117, 101, 115, 116, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 82, 101, 115, 112, 111,
			110, 115, 101, 1, 0, 0, 0, 17, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			114, 111, 118, 97, 108, 1, 0, 0, 0, 23,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			112, 112, 83, 101, 110, 100, 77, 101, 115, 115,
			97, 103, 101, 1, 0, 0, 0, 26, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			83, 101, 116, 69, 110, 116, 105, 116, 121, 86,
			97, 108, 117, 101, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 83, 117, 99, 99, 101, 115, 115, 1, 0,
			0, 0, 23, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 84, 101, 97, 109, 67,
			104, 97, 110, 103, 101, 100, 1, 0, 0, 0,
			20, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 112, 112, 84, 101, 97, 109, 67, 104, 97,
			116, 1, 0, 0, 0, 20, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 112, 112, 84, 101,
			97, 109, 73, 110, 102, 111, 1, 0, 0, 0,
			27, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			65, 112, 112, 84, 101, 97, 109, 73, 110, 102,
			111, 124, 77, 101, 109, 98, 101, 114, 1, 0,
			0, 0, 25, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 65, 112, 112, 84, 101, 97, 109, 73,
			110, 102, 111, 124, 78, 111, 116, 101, 1, 0,
			0, 0, 23, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 84, 101, 97, 109, 77,
			101, 115, 115, 97, 103, 101, 1, 0, 0, 0,
			16, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 112, 112, 84, 105, 109, 101, 1, 0, 0,
			0, 19, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 114, 99, 97, 100, 101, 71, 97, 109,
			101, 1, 0, 0, 0, 29, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 65, 114, 99, 97, 100,
			101, 71, 97, 109, 101, 124, 97, 114, 99, 97,
			100, 101, 69, 110, 116, 1, 0, 0, 0, 22,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 65,
			114, 99, 97, 100, 101, 77, 97, 99, 104, 105,
			110, 101, 1, 0, 0, 0, 33, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 65, 114, 99, 97,
			100, 101, 77, 97, 99, 104, 105, 110, 101, 124,
			83, 99, 111, 114, 101, 69, 110, 116, 114, 121,
			1, 0, 0, 0, 24, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 115, 115, 111, 99, 105,
			97, 116, 101, 100, 70, 105, 108, 101, 115, 1,
			0, 0, 0, 39, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 65, 115, 115, 111, 99, 105, 97,
			116, 101, 100, 70, 105, 108, 101, 115, 124, 65,
			115, 115, 111, 99, 105, 97, 116, 101, 100, 70,
			105, 108, 101, 1, 0, 0, 0, 15, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 116, 116,
			97, 99, 107, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 116, 116,
			97, 99, 107, 72, 101, 108, 105, 1, 0, 0,
			0, 26, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 116, 116, 97, 99, 107, 72, 101, 108,
			105, 82, 111, 99, 107, 101, 116, 115, 1, 0,
			0, 0, 25, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 116, 116, 97, 99, 107, 72, 101,
			108, 105, 84, 117, 114, 114, 101, 116, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 117, 100, 105, 111, 69, 110, 116,
			105, 116, 121, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 117, 116,
			111, 84, 117, 114, 114, 101, 116, 1, 0, 0,
			0, 17, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 66, 97, 108, 108, 105, 115, 116, 97, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 66, 97, 108, 108, 105, 115, 116,
			97, 71, 117, 110, 1, 0, 0, 0, 17, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 66, 97,
			115, 101, 66, 111, 97, 116, 1, 0, 0, 0,
			19, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			66, 97, 115, 101, 67, 111, 109, 98, 97, 116,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 66, 97, 115, 101, 69, 110,
			116, 105, 116, 121, 1, 0, 0, 0, 18, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 66, 97,
			115, 101, 77, 101, 108, 101, 101, 1, 0, 0,
			0, 24, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 66, 97, 115, 101, 78, 101, 116, 119, 111,
			114, 107, 97, 98, 108, 101, 1, 0, 0, 0,
			16, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			66, 97, 115, 101, 78, 80, 67, 1, 0, 0,
			0, 17, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 66, 97, 115, 101, 79, 118, 101, 110, 1,
			0, 0, 0, 29, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 66, 97, 115, 101, 79, 118, 101,
			110, 124, 67, 111, 111, 107, 105, 110, 103, 73,
			116, 101, 109, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 66, 97, 115,
			101, 80, 108, 97, 121, 101, 114, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 66, 97, 115, 101, 80, 114, 111, 106, 101,
			99, 116, 105, 108, 101, 1, 0, 0, 0, 21,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			97, 115, 101, 82, 101, 115, 111, 117, 114, 99,
			101, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 97, 115, 101, 83,
			99, 117, 108, 112, 116, 117, 114, 101, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 66, 97, 115, 101, 84, 114, 97, 105,
			110, 1, 0, 0, 0, 20, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 97, 115, 101, 86,
			101, 104, 105, 99, 108, 101, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			66, 97, 115, 101, 86, 101, 104, 105, 99, 108,
			101, 124, 77, 111, 117, 110, 116, 80, 111, 105,
			110, 116, 1, 0, 0, 0, 21, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 66, 97, 116, 116,
			101, 114, 105, 110, 103, 82, 97, 109, 1, 0,
			0, 0, 16, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 66, 101, 101, 104, 105, 118, 101, 1,
			0, 0, 0, 23, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 66, 101, 101, 77, 97, 115, 116,
			101, 114, 83, 119, 97, 114, 109, 1, 0, 0,
			0, 13, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 66, 105, 107, 101, 1, 0, 0, 0, 16,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			111, 111, 109, 66, 111, 120, 1, 0, 0, 0,
			19, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			66, 114, 97, 100, 108, 101, 121, 65, 80, 67,
			1, 0, 0, 0, 23, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 66, 114, 97, 105, 110, 67,
			111, 109, 112, 111, 110, 101, 110, 116, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 66, 117, 105, 108, 100, 105, 110, 103,
			66, 108, 111, 99, 107, 1, 0, 0, 0, 26,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			117, 105, 108, 100, 105, 110, 103, 80, 114, 105,
			118, 105, 108, 101, 103, 101, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			66, 117, 105, 108, 100, 105, 110, 103, 80, 114,
			105, 118, 105, 108, 101, 103, 101, 82, 101, 116,
			114, 111, 1, 0, 0, 0, 35, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 66, 117, 105, 108,
			100, 105, 110, 103, 80, 114, 105, 118, 105, 108,
			101, 103, 101, 82, 101, 116, 114, 111, 84, 111,
			111, 108, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 66, 117, 114, 105,
			101, 100, 73, 116, 101, 109, 115, 1, 0, 0,
			0, 37, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 66, 117, 114, 105, 101, 100, 73, 116, 101,
			109, 115, 124, 83, 116, 111, 114, 101, 100, 66,
			117, 114, 105, 101, 100, 73, 116, 101, 109, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 97, 109, 112, 101, 114, 77,
			111, 100, 117, 108, 101, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			97, 114, 100, 71, 97, 109, 101, 1, 0, 0,
			0, 27, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 67, 97, 114, 100, 71, 97, 109, 101, 124,
			66, 108, 97, 99, 107, 106, 97, 99, 107, 1,
			0, 0, 0, 37, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 67, 97, 114, 100, 71, 97, 109,
			101, 124, 66, 108, 97, 99, 107, 106, 97, 99,
			107, 67, 97, 114, 100, 80, 108, 97, 121, 101,
			114, 1, 0, 0, 0, 26, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 67, 97, 114, 100, 71,
			97, 109, 101, 124, 67, 97, 114, 100, 76, 105,
			115, 116, 1, 0, 0, 0, 28, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 67, 97, 114, 100,
			71, 97, 109, 101, 124, 67, 97, 114, 100, 80,
			108, 97, 121, 101, 114, 1, 0, 0, 0, 30,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 67,
			97, 114, 100, 71, 97, 109, 101, 124, 82, 111,
			117, 110, 100, 82, 101, 115, 117, 108, 116, 115,
			1, 0, 0, 0, 37, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 67, 97, 114, 100, 71, 97,
			109, 101, 43, 82, 111, 117, 110, 100, 82, 101,
			115, 117, 108, 116, 115, 124, 82, 101, 115, 117,
			108, 116, 1, 0, 0, 0, 29, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 67, 97, 114, 100,
			71, 97, 109, 101, 124, 84, 101, 120, 97, 115,
			72, 111, 108, 100, 69, 109, 1, 0, 0, 0,
			19, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 97, 114, 103, 111, 80, 108, 97, 110, 101,
			1, 0, 0, 0, 18, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 97, 114, 103, 111, 83,
			104, 105, 112, 1, 0, 0, 0, 27, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 67, 97, 114,
			103, 111, 83, 104, 105, 112, 67, 111, 110, 116,
			97, 105, 110, 101, 114, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			97, 115, 115, 101, 116, 116, 101, 1, 0, 0,
			0, 17, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 67, 97, 116, 97, 112, 117, 108, 116, 1,
			0, 0, 0, 26, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 104, 97, 110, 99, 101, 65,
			73, 69, 118, 101, 110, 116, 68, 97, 116, 97,
			1, 0, 0, 0, 20, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 104, 105, 99, 107, 101,
			110, 67, 111, 111, 112, 1, 0, 0, 0, 32,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			104, 105, 99, 107, 101, 110, 67, 111, 111, 112,
			83, 116, 97, 116, 117, 115, 85, 112, 100, 97,
			116, 101, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 67, 104, 105, 99,
			107, 101, 110, 83, 116, 97, 116, 117, 115, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 105, 110, 101, 109, 97, 116,
			105, 99, 69, 110, 116, 105, 116, 121, 1, 0,
			0, 0, 25, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 108, 97, 110, 65, 99, 116, 105,
			111, 110, 82, 101, 115, 117, 108, 116, 1, 0,
			0, 0, 35, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 78, 101, 120, 117, 115, 124, 67, 108,
			97, 110, 67, 104, 97, 116, 66, 97, 116, 99,
			104, 82, 101, 113, 117, 101, 115, 116, 1, 0,
			0, 0, 43, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 78, 101, 120, 117, 115, 46, 67, 108,
			97, 110, 67, 104, 97, 116, 66, 97, 116, 99,
			104, 82, 101, 113, 117, 101, 115, 116, 124, 77,
			101, 115, 115, 97, 103, 101, 1, 0, 0, 0,
			17, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 108, 97, 110, 73, 110, 102, 111, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 108, 97, 110, 73, 110, 102, 111,
			124, 73, 110, 118, 105, 116, 101, 1, 0, 0,
			0, 24, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 67, 108, 97, 110, 73, 110, 102, 111, 124,
			77, 101, 109, 98, 101, 114, 1, 0, 0, 0,
			22, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			67, 108, 97, 110, 73, 110, 102, 111, 124, 82,
			111, 108, 101, 1, 0, 0, 0, 24, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 67, 108, 97,
			110, 73, 110, 118, 105, 116, 97, 116, 105, 111,
			110, 115, 1, 0, 0, 0, 35, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 67, 108, 97, 110,
			73, 110, 118, 105, 116, 97, 116, 105, 111, 110,
			115, 124, 73, 110, 118, 105, 116, 97, 116, 105,
			111, 110, 1, 0, 0, 0, 24, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 67, 108, 97, 110,
			76, 101, 97, 100, 101, 114, 98, 111, 97, 114,
			100, 1, 0, 0, 0, 30, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 67, 108, 97, 110, 76,
			101, 97, 100, 101, 114, 98, 111, 97, 114, 100,
			124, 69, 110, 116, 114, 121, 1, 0, 0, 0,
			16, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 108, 97, 110, 76, 111, 103, 1, 0, 0,
			0, 22, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 67, 108, 97, 110, 76, 111, 103, 124, 69,
			110, 116, 114, 121, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 67, 108,
			97, 110, 77, 97, 110, 97, 103, 101, 114, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 108, 97, 110, 83, 99, 111,
			114, 101, 69, 118, 101, 110, 116, 115, 1, 0,
			0, 0, 30, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 108, 97, 110, 83, 99, 111, 114,
			101, 69, 118, 101, 110, 116, 115, 124, 69, 110,
			116, 114, 121, 1, 0, 0, 0, 20, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 67, 108, 105,
			101, 110, 116, 82, 101, 97, 100, 121, 1, 0,
			0, 0, 31, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 108, 105, 101, 110, 116, 82, 101,
			97, 100, 121, 124, 67, 108, 105, 101, 110, 116,
			73, 110, 102, 111, 1, 0, 0, 0, 21, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 67, 111,
			97, 108, 105, 110, 103, 84, 111, 119, 101, 114,
			1, 0, 0, 0, 17, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 111, 100, 101, 76, 111,
			99, 107, 1, 0, 0, 0, 25, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 67, 111, 100, 101,
			76, 111, 99, 107, 124, 80, 114, 105, 118, 97,
			116, 101, 1, 0, 0, 0, 21, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 67, 111, 109, 109,
			97, 110, 100, 66, 108, 111, 99, 107, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 111, 109, 112, 111, 115, 116, 101,
			114, 1, 0, 0, 0, 24, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 67, 111, 109, 112, 117,
			116, 101, 114, 83, 116, 97, 116, 105, 111, 110,
			1, 0, 0, 0, 25, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 111, 110, 110, 101, 99,
			116, 101, 100, 83, 112, 101, 97, 107, 101, 114,
			1, 0, 0, 0, 28, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 111, 110, 115, 116, 114,
			117, 99, 116, 97, 98, 108, 101, 69, 110, 116,
			105, 116, 121, 1, 0, 0, 0, 28, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 67, 111, 110,
			116, 97, 105, 110, 101, 114, 67, 111, 114, 112,
			115, 101, 68, 97, 116, 97, 1, 0, 0, 0,
			28, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 111, 112, 121, 80, 97, 115, 116, 101, 69,
			110, 116, 105, 116, 121, 73, 110, 102, 111, 1,
			0, 0, 0, 15, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 111, 114, 112, 115, 101, 1,
			0, 0, 0, 14, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 114, 97, 110, 101, 1, 0,
			0, 0, 23, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 114, 101, 97, 116, 101, 66, 117,
			105, 108, 100, 105, 110, 103, 1, 0, 0, 0,
			24, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 117, 115, 116, 111, 109, 86, 105, 116, 97,
			108, 73, 110, 102, 111, 1, 0, 0, 0, 21,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			117, 115, 116, 111, 109, 86, 105, 116, 97, 108,
			115, 1, 0, 0, 0, 20, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 68, 101, 99, 97, 121,
			69, 110, 116, 105, 116, 121, 1, 0, 0, 0,
			22, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			68, 101, 108, 105, 118, 101, 114, 121, 68, 114,
			111, 110, 101, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 68, 101, 109,
			111, 72, 101, 97, 100, 101, 114, 1, 0, 0,
			0, 17, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 68, 101, 109, 111, 83, 104, 111, 116, 1,
			0, 0, 0, 30, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 68, 101, 109, 111, 83, 104, 111,
			116, 70, 108, 111, 97, 116, 75, 101, 121, 102,
			114, 97, 109, 101, 1, 0, 0, 0, 27, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 68, 101,
			109, 111, 83, 104, 111, 116, 70, 108, 111, 97,
			116, 84, 114, 97, 99, 107, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			68, 101, 109, 111, 83, 104, 111, 116, 80, 97,
			114, 101, 110, 116, 75, 101, 121, 102, 114, 97,
			109, 101, 1, 0, 0, 0, 28, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 68, 101, 109, 111,
			83, 104, 111, 116, 80, 97, 114, 101, 110, 116,
			84, 114, 97, 99, 107, 1, 0, 0, 0, 35,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 68,
			101, 109, 111, 83, 104, 111, 116, 81, 117, 97,
			116, 101, 114, 110, 105, 111, 110, 75, 101, 121,
			102, 114, 97, 109, 101, 1, 0, 0, 0, 32,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 68,
			101, 109, 111, 83, 104, 111, 116, 81, 117, 97,
			116, 101, 114, 110, 105, 111, 110, 84, 114, 97,
			99, 107, 1, 0, 0, 0, 31, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 68, 101, 109, 111,
			83, 104, 111, 116, 86, 101, 99, 116, 111, 114,
			75, 101, 121, 102, 114, 97, 109, 101, 1, 0,
			0, 0, 28, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 68, 101, 109, 111, 83, 104, 111, 116,
			86, 101, 99, 116, 111, 114, 84, 114, 97, 99,
			107, 1, 0, 0, 0, 21, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 68, 105, 101, 115, 101,
			108, 69, 110, 103, 105, 110, 101, 1, 0, 0,
			0, 21, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 68, 105, 103, 105, 116, 97, 108, 67, 108,
			111, 99, 107, 1, 0, 0, 0, 26, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 68, 105, 103,
			105, 116, 97, 108, 67, 108, 111, 99, 107, 65,
			108, 97, 114, 109, 1, 0, 0, 0, 28, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 68, 105,
			103, 105, 116, 97, 108, 67, 108, 111, 99, 107,
			77, 101, 115, 115, 97, 103, 101, 1, 0, 0,
			0, 31, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 68, 105, 118, 101, 114, 80, 114, 111, 112,
			117, 108, 115, 105, 111, 110, 86, 101, 104, 105,
			99, 108, 101, 1, 0, 0, 0, 13, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 68, 111, 111,
			114, 1, 0, 0, 0, 14, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 68, 114, 111, 110, 101,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 68, 117, 100, 69, 120, 112,
			108, 111, 115, 105, 118, 101, 1, 0, 0, 0,
			11, 124, 69, 102, 102, 101, 99, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 16, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 69, 103, 103, 72,
			117, 110, 116, 1, 0, 0, 0, 26, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 69, 103, 103,
			72, 117, 110, 116, 124, 69, 103, 103, 72, 117,
			110, 116, 101, 114, 1, 0, 0, 0, 17, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 69, 108,
			101, 118, 97, 116, 111, 114, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			69, 108, 101, 118, 97, 116, 111, 114, 76, 105,
			102, 116, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 69, 110, 103, 105,
			110, 101, 83, 116, 111, 114, 97, 103, 101, 1,
			0, 0, 0, 15, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 69, 110, 116, 105, 116, 121, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 69, 110, 116, 105, 116, 121, 73,
			100, 76, 105, 115, 116, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 69,
			110, 116, 105, 116, 121, 76, 105, 115, 116, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 69, 110, 116, 105, 116, 121, 83,
			108, 111, 116, 115, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 69, 110,
			118, 105, 114, 111, 110, 109, 101, 110, 116, 1,
			0, 0, 0, 23, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 70, 97, 114, 109, 97, 98, 108,
			101, 65, 110, 105, 109, 97, 108, 1, 0, 0,
			0, 29, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 70, 97, 114, 109, 97, 98, 108, 101, 65,
			110, 105, 109, 97, 108, 83, 116, 97, 116, 117,
			115, 1, 0, 0, 0, 33, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 78, 101, 120, 117, 115,
			124, 70, 101, 114, 114, 121, 82, 101, 116, 105,
			114, 101, 82, 101, 113, 117, 101, 115, 116, 1,
			0, 0, 0, 26, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 78, 101, 120, 117, 115, 124, 70,
			101, 114, 114, 121, 83, 116, 97, 116, 117, 115,
			1, 0, 0, 0, 33, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 78, 101, 120, 117, 115, 124,
			70, 101, 114, 114, 121, 83, 116, 97, 116, 117,
			115, 82, 101, 113, 117, 101, 115, 116, 1, 0,
			0, 0, 34, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 78, 101, 120, 117, 115, 124, 70, 101,
			114, 114, 121, 83, 116, 97, 116, 117, 115, 82,
			101, 115, 112, 111, 110, 115, 101, 1, 0, 0,
			0, 41, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 78, 101, 120, 117, 115, 124, 70, 101, 114,
			114, 121, 85, 112, 100, 97, 116, 101, 83, 99,
			104, 101, 100, 117, 108, 101, 82, 101, 113, 117,
			101, 115, 116, 1, 0, 0, 0, 29, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 70, 105, 108,
			101, 83, 116, 111, 114, 97, 103, 101, 67, 97,
			99, 104, 101, 68, 97, 116, 97, 1, 0, 0,
			0, 26, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 70, 114, 97, 110, 107, 101, 110, 115, 116,
			101, 105, 110, 84, 97, 98, 108, 101, 1, 0,
			0, 0, 17, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 71, 97, 109, 101, 77, 111, 100, 101,
			1, 0, 0, 0, 29, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 71, 97, 109, 101, 77, 111,
			100, 101, 124, 80, 108, 97, 121, 101, 114, 83,
			99, 111, 114, 101, 1, 0, 0, 0, 29, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 71, 97,
			109, 101, 77, 111, 100, 101, 124, 83, 99, 111,
			114, 101, 67, 111, 108, 117, 109, 110, 1, 0,
			0, 0, 26, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 71, 97, 109, 101, 77, 111, 100, 101,
			124, 84, 101, 97, 109, 73, 110, 102, 111, 1,
			0, 0, 0, 23, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 71, 101, 110, 101, 114, 105, 99,
			83, 112, 97, 119, 110, 101, 114, 1, 0, 0,
			0, 34, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 71, 101, 110, 101, 114, 105, 99, 83, 112,
			97, 119, 110, 101, 114, 124, 83, 112, 97, 119,
			110, 101, 100, 69, 110, 116, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			71, 108, 111, 98, 97, 108, 69, 110, 116, 105,
			116, 121, 67, 111, 108, 108, 101, 99, 116, 105,
			111, 110, 1, 0, 0, 0, 25, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 71, 108, 111, 98,
			97, 108, 69, 110, 116, 105, 116, 121, 68, 97,
			116, 97, 1, 0, 0, 0, 23, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 71, 114, 111, 119,
			97, 98, 108, 101, 69, 110, 116, 105, 116, 121,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 71, 117, 110, 87, 101, 97,
			112, 111, 110, 77, 111, 100, 1, 0, 0, 0,
			14, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			72, 97, 108, 102, 51, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 72,
			97, 114, 98, 111, 114, 67, 114, 97, 110, 101,
			1, 0, 0, 0, 31, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 72, 97, 114, 98, 111, 114,
			67, 114, 97, 110, 101, 124, 81, 117, 101, 117,
			101, 100, 77, 111, 118, 101, 1, 0, 0, 0,
			17, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			72, 101, 97, 100, 68, 97, 116, 97, 1, 0,
			0, 0, 31, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 72, 101, 97, 108, 116, 104, 66, 101,
			108, 111, 119, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 72, 101,
			108, 100, 69, 110, 116, 105, 116, 121, 1, 0,
			0, 0, 19, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 72, 101, 108, 105, 99, 111, 112, 116,
			101, 114, 1, 0, 0, 0, 25, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 72, 101, 108, 105,
			99, 111, 112, 116, 101, 114, 70, 108, 97, 114,
			101, 115, 1, 0, 0, 0, 14, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 72, 111, 114, 115,
			101, 1, 0, 0, 0, 23, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 72, 111, 114, 115, 101,
			77, 111, 100, 105, 102, 105, 101, 114, 115, 1,
			0, 0, 0, 22, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 72, 111, 116, 65, 105, 114, 66,
			97, 108, 108, 111, 111, 110, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			72, 117, 110, 103, 101, 114, 65, 98, 111, 118,
			101, 65, 73, 69, 118, 101, 110, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 27, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 73, 110, 100, 117,
			115, 116, 114, 105, 97, 108, 67, 111, 110, 118,
			101, 121, 111, 114, 1, 0, 0, 0, 38, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 73, 110,
			100, 117, 115, 116, 114, 105, 97, 108, 67, 111,
			110, 118, 101, 121, 111, 114, 124, 73, 116, 101,
			109, 70, 105, 108, 116, 101, 114, 1, 0, 0,
			0, 42, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 73, 110, 100, 117, 115, 116, 114, 105, 97,
			108, 67, 111, 110, 118, 101, 121, 111, 114, 124,
			73, 116, 101, 109, 70, 105, 108, 116, 101, 114,
			76, 105, 115, 116, 1, 0, 0, 0, 35, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 73, 110,
			100, 117, 115, 116, 114, 105, 97, 108, 67, 111,
			110, 118, 101, 121, 111, 114, 84, 114, 97, 110,
			115, 102, 101, 114, 1, 0, 0, 0, 48, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 73, 110,
			100, 117, 115, 116, 114, 105, 97, 108, 67, 111,
			110, 118, 101, 121, 111, 114, 84, 114, 97, 110,
			115, 102, 101, 114, 124, 73, 116, 101, 109, 84,
			114, 97, 110, 115, 102, 101, 114, 1, 0, 0,
			0, 26, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 73, 110, 100, 117, 115, 116, 114, 105, 97,
			108, 67, 114, 97, 102, 116, 101, 114, 1, 0,
			0, 0, 13, 124, 73, 110, 112, 117, 116, 77,
			101, 115, 115, 97, 103, 101, 1, 0, 0, 0,
			27, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			73, 110, 82, 97, 110, 103, 101, 65, 73, 69,
			118, 101, 110, 116, 68, 97, 116, 97, 1, 0,
			0, 0, 33, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 73, 110, 82, 97, 110, 103, 101, 79,
			102, 72, 111, 109, 101, 65, 73, 69, 118, 101,
			110, 116, 68, 97, 116, 97, 1, 0, 0, 0,
			30, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			73, 110, 115, 116, 114, 117, 109, 101, 110, 116,
			77, 105, 100, 105, 66, 105, 110, 100, 105, 110,
			103, 1, 0, 0, 0, 31, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 73, 110, 115, 116, 114,
			117, 109, 101, 110, 116, 77, 105, 100, 105, 66,
			105, 110, 100, 105, 110, 103, 115, 1, 0, 0,
			0, 28, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 73, 110, 115, 116, 114, 117, 109, 101, 110,
			116, 82, 101, 99, 111, 114, 100, 105, 110, 103,
			1, 0, 0, 0, 32, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 73, 110, 115, 116, 114, 117,
			109, 101, 110, 116, 82, 101, 99, 111, 114, 100,
			105, 110, 103, 78, 111, 116, 101, 1, 0, 0,
			0, 17, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 73, 79, 69, 110, 116, 105, 116, 121, 1,
			0, 0, 0, 30, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 73, 79, 69, 110, 116, 105, 116,
			121, 124, 73, 79, 67, 111, 110, 110, 101, 99,
			116, 105, 111, 110, 1, 0, 0, 0, 44, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 73, 79,
			69, 110, 116, 105, 116, 121, 43, 73, 79, 67,
			111, 110, 110, 101, 99, 116, 105, 111, 110, 124,
			76, 105, 110, 101, 80, 111, 105, 110, 116, 76,
			105, 115, 116, 1, 0, 0, 0, 38, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 73, 79, 69,
			110, 116, 105, 116, 121, 43, 73, 79, 67, 111,
			110, 110, 101, 99, 116, 105, 111, 110, 124, 76,
			105, 110, 101, 86, 101, 99, 1, 0, 0, 0,
			13, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			73, 116, 101, 109, 1, 0, 0, 0, 27, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 73, 116,
			101, 109, 124, 67, 111, 110, 100, 105, 116, 105,
			111, 110, 68, 97, 116, 97, 1, 0, 0, 0,
			26, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			73, 116, 101, 109, 124, 73, 110, 115, 116, 97,
			110, 99, 101, 68, 97, 116, 97, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 73, 116, 101, 109, 65, 109, 111, 117, 110,
			116, 76, 105, 115, 116, 1, 0, 0, 0, 22,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 73,
			116, 101, 109, 67, 111, 110, 116, 97, 105, 110,
			101, 114, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 73, 116, 101, 109,
			67, 114, 97, 102, 116, 101, 114, 1, 0, 0,
			0, 25, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 73, 116, 101, 109, 67, 114, 97, 102, 116,
			101, 114, 124, 84, 97, 115, 107, 1, 0, 0,
			0, 28, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 73, 116, 101, 109, 79, 119, 110, 101, 114,
			115, 104, 105, 112, 65, 109, 111, 117, 110, 116,
			1, 0, 0, 0, 16, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 75, 101, 121, 76, 111, 99,
			107, 1, 0, 0, 0, 17, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 76, 97, 110, 100, 109,
			105, 110, 101, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 76, 101, 103,
			97, 99, 121, 83, 104, 101, 108, 116, 101, 114,
			1, 0, 0, 0, 13, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 76, 105, 102, 116, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 76, 105, 103, 104, 116, 68, 101, 112,
			108, 111, 121, 101, 114, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 76,
			105, 103, 104, 116, 83, 116, 114, 105, 110, 103,
			1, 0, 0, 0, 32, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 76, 105, 103, 104, 116, 83,
			116, 114, 105, 110, 103, 124, 83, 116, 114, 105,
			110, 103, 80, 111, 105, 110, 116, 1, 0, 0,
			0, 18, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 76, 105, 110, 101, 80, 111, 105, 110, 116,
			1, 0, 0, 0, 13, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 76, 111, 111, 116, 1, 0,
			0, 0, 23, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 76, 111, 111, 116, 97, 98, 108, 101,
			67, 111, 114, 112, 115, 101, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			76, 111, 111, 116, 97, 98, 108, 101, 67, 111,
			114, 112, 115, 101, 124, 80, 114, 105, 118, 97,
			116, 101, 1, 0, 0, 0, 17, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 97, 103, 97,
			122, 105, 110, 101, 1, 0, 0, 0, 16, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 77, 97,
			105, 108, 98, 111, 120, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 77,
			97, 110, 110, 101, 113, 117, 105, 110, 1, 0,
			0, 0, 31, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 77, 97, 110, 110, 101, 113, 117, 105,
			110, 124, 67, 108, 111, 116, 104, 105, 110, 103,
			73, 116, 101, 109, 1, 0, 0, 0, 16, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 77, 97,
			112, 68, 97, 116, 97, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 77,
			97, 112, 69, 110, 116, 105, 116, 121, 1, 0,
			0, 0, 16, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 77, 97, 112, 78, 111, 116, 101, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 97, 112, 78, 111, 116, 101,
			76, 105, 115, 116, 1, 0, 0, 0, 23, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 77, 97,
			114, 107, 101, 116, 84, 101, 114, 109, 105, 110,
			97, 108, 1, 0, 0, 0, 36, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 77, 97, 114, 107,
			101, 116, 84, 101, 114, 109, 105, 110, 97, 108,
			124, 80, 101, 110, 100, 105, 110, 103, 79, 114,
			100, 101, 114, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 101, 109,
			111, 114, 121, 66, 97, 110, 107, 1, 0, 0,
			0, 28, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 77, 101, 116, 97, 108, 68, 101, 116, 101,
			99, 116, 111, 114, 83, 111, 117, 114, 99, 101,
			1, 0, 0, 0, 24, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 77, 105, 99, 114, 111, 112,
			104, 111, 110, 101, 83, 116, 97, 110, 100, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 105, 110, 105, 99, 111, 112,
			116, 101, 114, 1, 0, 0, 0, 21, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 105, 110,
			105, 110, 103, 81, 117, 97, 114, 114, 121, 1,
			0, 0, 0, 22, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 105, 115, 115, 105, 111, 110,
			69, 110, 116, 105, 116, 121, 1, 0, 0, 0,
			24, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			77, 105, 115, 115, 105, 111, 110, 73, 110, 115,
			116, 97, 110, 99, 101, 1, 0, 0, 0, 28,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 77,
			105, 115, 115, 105, 111, 110, 73, 110, 115, 116,
			97, 110, 99, 101, 68, 97, 116, 97, 1, 0,
			0, 0, 25, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 77, 105, 115, 115, 105, 111, 110, 77,
			97, 112, 77, 97, 114, 107, 101, 114, 1, 0,
			0, 0, 21, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 77, 105, 115, 115, 105, 111, 110, 80,
			111, 105, 110, 116, 1, 0, 0, 0, 22, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 77, 105,
			115, 115, 105, 111, 110, 82, 101, 119, 97, 114,
			100, 1, 0, 0, 0, 17, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 77, 105, 115, 115, 105,
			111, 110, 115, 1, 0, 0, 0, 20, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 105, 120,
			105, 110, 103, 84, 97, 98, 108, 101, 1, 0,
			0, 0, 13, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 77, 76, 82, 83, 1, 0, 0, 0,
			11, 124, 77, 111, 100, 101, 108, 83, 116, 97,
			116, 101, 1, 0, 0, 0, 17, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 111, 100, 105,
			102, 105, 101, 114, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 77, 111,
			100, 117, 108, 97, 114, 67, 97, 114, 1, 0,
			0, 0, 23, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 77, 111, 100, 117, 108, 97, 114, 86,
			101, 104, 105, 99, 108, 101, 1, 0, 0, 0,
			22, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			77, 111, 100, 117, 108, 101, 77, 101, 115, 115,
			97, 103, 101, 1, 0, 0, 0, 18, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 111, 116,
			111, 114, 98, 111, 97, 116, 1, 0, 0, 0,
			17, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			78, 101, 111, 110, 83, 105, 103, 110, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 78, 101, 111, 110, 83, 105, 103, 110,
			124, 76, 105, 103, 104, 116, 115, 1, 0, 0,
			0, 26, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 78, 101, 120, 117, 115, 68, 111, 99, 107,
			84, 101, 114, 109, 105, 110, 97, 108, 1, 0,
			0, 0, 40, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 78, 101, 120, 117, 115, 68, 111, 99,
			107, 84, 101, 114, 109, 105, 110, 97, 108, 124,
			83, 99, 104, 101, 100, 117, 108, 101, 69, 110,
			116, 114, 121, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 78, 101, 120,
			117, 115, 70, 101, 114, 114, 121, 1, 0, 0,
			0, 20, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 78, 101, 120, 117, 115, 73, 115, 108, 97,
			110, 100, 1, 0, 0, 0, 23, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 78, 80, 67, 83,
			101, 110, 115, 101, 115, 83, 116, 97, 116, 101,
			1, 0, 0, 0, 26, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 78, 80, 67, 86, 101, 110,
			100, 105, 110, 103, 77, 97, 99, 104, 105, 110,
			101, 1, 0, 0, 0, 24, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 79, 98, 106, 101, 99,
			116, 105, 118, 101, 83, 116, 97, 116, 117, 115,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 79, 99, 101, 97, 110, 80,
			97, 116, 104, 115, 1, 0, 0, 0, 18, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 79, 119,
			110, 101, 114, 73, 110, 102, 111, 1, 0, 0,
			0, 21, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 78, 101, 120, 117, 115, 124, 80, 97, 99,
			107, 101, 116, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 80, 97, 105,
			110, 116, 97, 98, 108, 101, 83, 105, 103, 110,
			1, 0, 0, 0, 20, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 80, 97, 105, 110, 116, 101,
			100, 73, 116, 101, 109, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 80,
			97, 114, 101, 110, 116, 73, 110, 102, 111, 1,
			0, 0, 0, 18, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 97, 114, 116, 121, 68, 97,
			116, 97, 1, 0, 0, 0, 24, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 80, 97, 114, 116,
			121, 77, 101, 109, 98, 101, 114, 68, 97, 116,
			97, 1, 0, 0, 0, 21, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 97, 115, 116, 101,
			82, 101, 113, 117, 101, 115, 116, 1, 0, 0,
			0, 17, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 97, 116, 104, 68, 97, 116, 97, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 97, 116, 116, 101, 114, 110,
			70, 105, 114, 101, 119, 111, 114, 107, 1, 0,
			0, 0, 31, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 80, 97, 116, 116, 101, 114, 110, 70,
			105, 114, 101, 119, 111, 114, 107, 124, 68, 101,
			115, 105, 103, 110, 1, 0, 0, 0, 36, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 80, 97,
			116, 116, 101, 114, 110, 70, 105, 114, 101, 119,
			111, 114, 107, 124, 83, 97, 118, 101, 100, 68,
			101, 115, 105, 103, 110, 1, 0, 0, 0, 29,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 80,
			97, 116, 116, 101, 114, 110, 70, 105, 114, 101,
			119, 111, 114, 107, 124, 83, 116, 97, 114, 1,
			0, 0, 0, 25, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 101, 114, 115, 105, 115, 116,
			97, 110, 116, 80, 108, 97, 121, 101, 114, 1,
			0, 0, 0, 23, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 104, 111, 110, 101, 68, 105,
			114, 101, 99, 116, 111, 114, 121, 1, 0, 0,
			0, 38, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 80, 104, 111, 110, 101, 68, 105, 114, 101,
			99, 116, 111, 114, 121, 124, 68, 105, 114, 101,
			99, 116, 111, 114, 121, 69, 110, 116, 114, 121,
			1, 0, 0, 0, 14, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 80, 104, 111, 116, 111, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 104, 111, 116, 111, 70, 114,
			97, 109, 101, 1, 0, 0, 0, 26, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 78, 101, 120,
			117, 115, 124, 80, 105, 110, 103, 82, 101, 113,
			117, 101, 115, 116, 1, 0, 0, 0, 27, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			120, 117, 115, 124, 80, 105, 110, 103, 82, 101,
			115, 112, 111, 110, 115, 101, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			80, 108, 97, 121, 101, 114, 65, 116, 116, 97,
			99, 107, 1, 0, 0, 0, 34, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 80, 108, 97, 121,
			101, 114, 68, 101, 116, 101, 99, 116, 101, 100,
			65, 73, 69, 118, 101, 110, 116, 68, 97, 116,
			97, 1, 0, 0, 0, 24, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 108, 97, 121, 101,
			114, 73, 110, 118, 101, 110, 116, 111, 114, 121,
			1, 0, 0, 0, 24, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 80, 108, 97, 121, 101, 114,
			76, 105, 102, 101, 83, 116, 111, 114, 121, 1,
			0, 0, 0, 34, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 80, 108, 97, 121, 101, 114, 76,
			105, 102, 101, 83, 116, 111, 114, 121, 124, 68,
			101, 97, 116, 104, 73, 110, 102, 111, 1, 0,
			0, 0, 36, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 80, 108, 97, 121, 101, 114, 76, 105,
			102, 101, 83, 116, 111, 114, 121, 124, 71, 101,
			110, 101, 114, 105, 99, 83, 116, 97, 116, 1,
			0, 0, 0, 36, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 80, 108, 97, 121, 101, 114, 76,
			105, 102, 101, 83, 116, 111, 114, 121, 124, 87,
			101, 97, 112, 111, 110, 83, 116, 97, 116, 115,
			1, 0, 0, 0, 36, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 78, 101, 120, 117, 115, 124,
			80, 108, 97, 121, 101, 114, 77, 97, 110, 105,
			102, 101, 115, 116, 82, 101, 113, 117, 101, 115,
			116, 1, 0, 0, 0, 25, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 108, 97, 121, 101,
			114, 77, 101, 116, 97, 98, 111, 108, 105, 115,
			109, 1, 0, 0, 0, 24, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 108, 97, 121, 101,
			114, 77, 111, 100, 105, 102, 105, 101, 114, 115,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 80, 108, 97, 121, 101, 114,
			78, 97, 109, 101, 73, 68, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			80, 108, 97, 121, 101, 114, 80, 114, 111, 106,
			101, 99, 116, 105, 108, 101, 65, 116, 116, 97,
			99, 107, 1, 0, 0, 0, 33, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 80, 108, 97, 121,
			101, 114, 80, 114, 111, 106, 101, 99, 116, 105,
			108, 101, 82, 105, 99, 111, 99, 104, 101, 116,
			1, 0, 0, 0, 31, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 80, 108, 97, 121, 101, 114,
			80, 114, 111, 106, 101, 99, 116, 105, 108, 101,
			85, 112, 100, 97, 116, 101, 1, 0, 0, 0,
			34, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			78, 101, 120, 117, 115, 124, 80, 108, 97, 121,
			101, 114, 83, 101, 99, 111, 110, 100, 97, 114,
			121, 68, 97, 116, 97, 1, 0, 0, 0, 51,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 46, 80, 108, 97, 121, 101,
			114, 83, 101, 99, 111, 110, 100, 97, 114, 121,
			68, 97, 116, 97, 124, 82, 101, 108, 97, 116,
			105, 111, 110, 115, 104, 105, 112, 68, 97, 116,
			97, 1, 0, 0, 0, 20, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 108, 97, 121, 101,
			114, 83, 116, 97, 116, 101, 1, 0, 0, 0,
			19, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			80, 108, 97, 121, 101, 114, 84, 101, 97, 109,
			1, 0, 0, 0, 30, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 80, 108, 97, 121, 101, 114,
			84, 101, 97, 109, 124, 84, 101, 97, 109, 77,
			101, 109, 98, 101, 114, 1, 0, 0, 0, 11,
			124, 80, 108, 97, 121, 101, 114, 84, 105, 99,
			107, 1, 0, 0, 0, 25, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 108, 97, 121, 101,
			114, 85, 112, 100, 97, 116, 101, 76, 111, 111,
			116, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 114, 101, 102, 97,
			98, 68, 97, 116, 97, 1, 0, 0, 0, 26,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 80,
			114, 111, 99, 101, 100, 117, 114, 97, 108, 68,
			117, 110, 103, 101, 111, 110, 1, 0, 0, 0,
			24, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			80, 114, 111, 106, 101, 99, 116, 105, 108, 101,
			83, 104, 111, 111, 116, 1, 0, 0, 0, 35,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 80,
			114, 111, 106, 101, 99, 116, 105, 108, 101, 83,
			104, 111, 111, 116, 124, 80, 114, 111, 106, 101,
			99, 116, 105, 108, 101, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 80,
			117, 122, 122, 108, 101, 82, 101, 115, 101, 116,
			1, 0, 0, 0, 18, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 82, 97, 100, 105, 111, 76,
			105, 115, 116, 1, 0, 0, 0, 16, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 82, 97, 103,
			100, 111, 108, 108, 1, 0, 0, 0, 17, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 82, 67,
			69, 110, 116, 105, 116, 121, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			82, 101, 99, 108, 97, 105, 109, 77, 97, 110,
			97, 103, 101, 114, 1, 0, 0, 0, 35, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 82, 101,
			99, 108, 97, 105, 109, 77, 97, 110, 97, 103,
			101, 114, 124, 82, 101, 99, 108, 97, 105, 109,
			73, 110, 102, 111, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 82, 101,
			99, 108, 97, 105, 109, 84, 101, 114, 109, 105,
			110, 97, 108, 1, 0, 0, 0, 28, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 82, 101, 108,
			97, 116, 105, 111, 110, 115, 104, 105, 112, 77,
			97, 110, 97, 103, 101, 114, 1, 0, 0, 0,
			51, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			82, 101, 108, 97, 116, 105, 111, 110, 115, 104,
			105, 112, 77, 97, 110, 97, 103, 101, 114, 124,
			80, 108, 97, 121, 101, 114, 82, 101, 108, 97,
			116, 105, 111, 110, 115, 104, 105, 112, 73, 110,
			102, 111, 1, 0, 0, 0, 48, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 82, 101, 108, 97,
			116, 105, 111, 110, 115, 104, 105, 112, 77, 97,
			110, 97, 103, 101, 114, 124, 80, 108, 97, 121,
			101, 114, 82, 101, 108, 97, 116, 105, 111, 110,
			115, 104, 105, 112, 115, 1, 0, 0, 0, 22,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 124, 82, 101, 113, 117, 101,
			115, 116, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 82, 101, 115, 101,
			97, 114, 99, 104, 84, 97, 98, 108, 101, 1,
			0, 0, 0, 26, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 82, 101, 115, 111, 117, 114, 99,
			101, 69, 120, 116, 114, 97, 99, 116, 111, 114,
			1, 0, 0, 0, 27, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 82, 101, 115, 112, 97, 119,
			110, 73, 110, 102, 111, 114, 109, 97, 116, 105,
			111, 110, 1, 0, 0, 0, 40, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 82, 101, 115, 112,
			97, 119, 110, 73, 110, 102, 111, 114, 109, 97,
			116, 105, 111, 110, 124, 83, 112, 97, 119, 110,
			79, 112, 116, 105, 111, 110, 115, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 78, 101, 120, 117, 115, 124, 82, 101, 115,
			112, 111, 110, 115, 101, 1, 0, 0, 0, 21,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 82,
			111, 99, 107, 105, 110, 103, 67, 104, 97, 105,
			114, 1, 0, 0, 0, 18, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 83, 97, 108, 101, 115,
			68, 97, 116, 97, 1, 0, 0, 0, 16, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 65,
			77, 83, 105, 116, 101, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 83,
			101, 114, 118, 101, 114, 71, 105, 98, 1, 0,
			0, 0, 19, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 104, 111, 112, 75, 101, 101, 112,
			101, 114, 1, 0, 0, 0, 19, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 105, 101, 103,
			101, 84, 111, 119, 101, 114, 1, 0, 0, 0,
			13, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			83, 105, 103, 110, 1, 0, 0, 0, 18, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 105,
			109, 112, 108, 101, 73, 110, 116, 1, 0, 0,
			0, 18, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 83, 105, 109, 112, 108, 101, 85, 73, 68,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 83, 105, 109, 112, 108, 101,
			85, 73, 110, 116, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 107,
			117, 108, 108, 84, 114, 111, 112, 104, 121, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 83, 108, 101, 101, 112, 105, 110,
			103, 66, 97, 103, 1, 0, 0, 0, 26, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 108,
			101, 101, 112, 105, 110, 103, 66, 97, 103, 67,
			97, 109, 112, 101, 114, 1, 0, 0, 0, 40,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 124, 83, 108, 101, 101, 112,
			105, 110, 103, 66, 97, 103, 68, 101, 115, 116,
			114, 111, 121, 82, 101, 113, 117, 101, 115, 116,
			1, 0, 0, 0, 40, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 78, 101, 120, 117, 115, 124,
			83, 108, 101, 101, 112, 105, 110, 103, 66, 97,
			103, 82, 101, 115, 112, 97, 119, 110, 82, 101,
			113, 117, 101, 115, 116, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 83,
			108, 111, 116, 77, 97, 99, 104, 105, 110, 101,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 83, 109, 97, 114, 116, 65,
			108, 97, 114, 109, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 110,
			111, 119, 109, 111, 98, 105, 108, 101, 1, 0,
			0, 0, 21, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 111, 114, 116, 83, 101, 116, 116,
			105, 110, 103, 115, 1, 0, 0, 0, 18, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 112,
			97, 119, 110, 97, 98, 108, 101, 1, 0, 0,
			0, 34, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 78, 101, 120, 117, 115, 124, 83, 112, 97,
			119, 110, 79, 112, 116, 105, 111, 110, 115, 82,
			101, 113, 117, 101, 115, 116, 1, 0, 0, 0,
			35, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			78, 101, 120, 117, 115, 124, 83, 112, 97, 119,
			110, 79, 112, 116, 105, 111, 110, 115, 82, 101,
			115, 112, 111, 110, 115, 101, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			83, 112, 101, 99, 116, 97, 116, 101, 84, 101,
			97, 109, 1, 0, 0, 0, 25, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 112, 101, 99,
			116, 97, 116, 101, 84, 101, 97, 109, 73, 110,
			102, 111, 1, 0, 0, 0, 21, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 112, 104, 101,
			114, 101, 69, 110, 116, 105, 116, 121, 1, 0,
			0, 0, 21, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 112, 105, 110, 110, 101, 114, 87,
			104, 101, 101, 108, 1, 0, 0, 0, 14, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 112,
			114, 97, 121, 1, 0, 0, 0, 18, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 83, 112, 114,
			97, 121, 76, 105, 110, 101, 1, 0, 0, 0,
			18, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			83, 112, 114, 97, 121, 76, 105, 115, 116, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 83, 116, 97, 98, 105, 108, 105,
			116, 121, 69, 110, 116, 105, 116, 121, 1, 0,
			0, 0, 30, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 116, 97, 116, 105, 99, 82, 101,
			115, 112, 97, 119, 110, 65, 114, 101, 97, 68,
			97, 116, 97, 1, 0, 0, 0, 21, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 78, 101, 120,
			117, 115, 124, 83, 116, 97, 116, 117, 115, 1,
			0, 0, 0, 23, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 83, 116, 111, 114, 97, 103, 101,
			65, 100, 97, 112, 116, 111, 114, 1, 0, 0,
			0, 19, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 83, 116, 111, 114, 97, 103, 101, 66, 111,
			120, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 83, 117, 98, 69, 110,
			116, 105, 116, 121, 76, 105, 115, 116, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 117, 98, 109, 97, 114, 105, 110,
			101, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 84, 97, 107, 101, 68,
			97, 109, 97, 103, 101, 1, 0, 0, 0, 34,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 84,
			97, 114, 103, 101, 116, 68, 101, 116, 101, 99,
			116, 101, 100, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 18, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 84, 101,
			108, 101, 112, 104, 111, 110, 101, 1, 0, 0,
			0, 25, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 84, 101, 109, 112, 111, 114, 97, 114, 121,
			82, 97, 103, 100, 111, 108, 108, 1, 0, 0,
			0, 34, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 84, 104, 114, 101, 97, 116, 68, 101, 116,
			101, 99, 116, 101, 100, 65, 73, 69, 118, 101,
			110, 116, 68, 97, 116, 97, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			84, 105, 109, 101, 100, 69, 120, 112, 108, 111,
			115, 105, 118, 101, 1, 0, 0, 0, 25, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 84, 105,
			109, 101, 114, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 35, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 84, 105,
			109, 101, 83, 105, 110, 99, 101, 84, 104, 114,
			101, 97, 116, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 84, 105,
			110, 67, 97, 110, 65, 108, 97, 114, 109, 1,
			0, 0, 0, 34, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 84, 105, 114, 101, 100, 110, 101,
			115, 115, 65, 98, 111, 118, 101, 65, 73, 69,
			118, 101, 110, 116, 68, 97, 116, 97, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 84, 114, 97, 105, 110, 69, 110, 103,
			105, 110, 101, 1, 0, 0, 0, 30, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 78, 101, 120,
			117, 115, 124, 84, 114, 97, 110, 115, 102, 101,
			114, 82, 101, 113, 117, 101, 115, 116, 1, 0,
			0, 0, 25, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 84, 114, 97, 118, 101, 108, 108, 105,
			110, 103, 86, 101, 110, 100, 111, 114, 1, 0,
			0, 0, 13, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 84, 114, 101, 101, 1, 0, 0, 0,
			17, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			84, 114, 101, 101, 76, 105, 115, 116, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 84, 114, 101, 101, 82, 101, 115, 112,
			97, 119, 110, 1, 0, 0, 0, 23, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 84, 117, 116,
			111, 114, 105, 97, 108, 73, 115, 108, 97, 110,
			100, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 85, 112, 100, 97, 116,
			101, 73, 116, 101, 109, 1, 0, 0, 0, 28,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 85,
			112, 100, 97, 116, 101, 73, 116, 101, 109, 67,
			111, 110, 116, 97, 105, 110, 101, 114, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 68, 68, 114, 97, 119, 69, 110,
			116, 114, 121, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 86, 101, 99,
			116, 111, 114, 68, 97, 116, 97, 1, 0, 0,
			0, 19, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 86, 101, 99, 116, 111, 114, 76, 105, 115,
			116, 1, 0, 0, 0, 20, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 86, 101, 104, 105, 99,
			108, 101, 76, 105, 102, 116, 1, 0, 0, 0,
			22, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			86, 101, 104, 105, 99, 108, 101, 77, 111, 100,
			117, 108, 101, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 86, 101, 104,
			105, 99, 108, 101, 86, 101, 110, 100, 111, 114,
			1, 0, 0, 0, 36, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 86, 101, 104, 105, 99, 108,
			101, 86, 101, 110, 100, 111, 114, 124, 80, 108,
			97, 121, 101, 114, 83, 116, 111, 114, 97, 103,
			101, 1, 0, 0, 0, 56, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 86, 101, 104, 105, 99,
			108, 101, 86, 101, 110, 100, 111, 114, 43, 80,
			108, 97, 121, 101, 114, 83, 116, 111, 114, 97,
			103, 101, 124, 80, 108, 97, 121, 101, 114, 83,
			116, 111, 114, 101, 100, 86, 101, 104, 105, 99,
			108, 101, 1, 0, 0, 0, 30, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 86, 101, 110, 100,
			105, 110, 103, 68, 121, 110, 97, 109, 105, 99,
			80, 114, 105, 99, 105, 110, 103, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 86, 101, 110, 100, 105, 110, 103, 77, 97,
			99, 104, 105, 110, 101, 1, 0, 0, 0, 33,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 86,
			101, 110, 100, 105, 110, 103, 77, 97, 99, 104,
			105, 110, 101, 124, 83, 101, 108, 108, 79, 114,
			100, 101, 114, 1, 0, 0, 0, 42, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 86, 101, 110,
			100, 105, 110, 103, 77, 97, 99, 104, 105, 110,
			101, 124, 83, 101, 108, 108, 79, 114, 100, 101,
			114, 67, 111, 110, 116, 97, 105, 110, 101, 114,
			1, 0, 0, 0, 36, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 86, 101, 110, 100, 105, 110,
			103, 77, 97, 99, 104, 105, 110, 101, 76, 111,
			110, 103, 84, 101, 114, 109, 83, 116, 97, 116,
			115, 1, 0, 0, 0, 50, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 86, 101, 110, 100, 105,
			110, 103, 77, 97, 99, 104, 105, 110, 101, 80,
			117, 114, 99, 104, 97, 115, 101, 72, 105, 115,
			116, 111, 114, 121, 69, 110, 116, 114, 121, 77,
			101, 115, 115, 97, 103, 101, 1, 0, 0, 0,
			55, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			86, 101, 110, 100, 105, 110, 103, 77, 97, 99,
			104, 105, 110, 101, 80, 117, 114, 99, 104, 97,
			115, 101, 72, 105, 115, 116, 111, 114, 121, 69,
			110, 116, 114, 121, 83, 109, 97, 108, 108, 77,
			101, 115, 115, 97, 103, 101, 1, 0, 0, 0,
			45, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			86, 101, 110, 100, 105, 110, 103, 77, 97, 99,
			104, 105, 110, 101, 80, 117, 114, 99, 104, 97,
			115, 101, 72, 105, 115, 116, 111, 114, 121, 77,
			101, 115, 115, 97, 103, 101, 1, 0, 0, 0,
			28, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			86, 101, 110, 100, 105, 110, 103, 77, 97, 99,
			104, 105, 110, 101, 83, 116, 97, 116, 115, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 86, 105, 110, 101, 68, 101, 115,
			116, 105, 110, 97, 116, 105, 111, 110, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 105, 110, 101, 77, 111, 117, 110,
			116, 97, 98, 108, 101, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 86,
			105, 110, 101, 84, 114, 101, 101, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 86, 111, 105, 99, 101, 109, 97, 105, 108,
			69, 110, 116, 114, 121, 1, 0, 0, 0, 22,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 87,
			97, 108, 108, 112, 97, 112, 101, 114, 84, 111,
			111, 108, 1, 0, 0, 0, 21, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 87, 97, 110, 116,
			101, 100, 80, 111, 115, 116, 101, 114, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 87, 97, 116, 101, 114, 80, 111, 111,
			108, 1, 0, 0, 0, 18, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 87, 97, 116, 101, 114,
			87, 101, 108, 108, 1, 0, 0, 0, 21, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 87, 97,
			121, 112, 111, 105, 110, 116, 82, 97, 99, 101,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 87, 101, 97, 112, 111, 110,
			82, 97, 99, 107, 1, 0, 0, 0, 23, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 87, 101,
			97, 112, 111, 110, 82, 97, 99, 107, 73, 116,
			101, 109, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 87, 104, 105, 116,
			101, 108, 105, 115, 116, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 87,
			105, 112, 101, 76, 97, 112, 116, 111, 112, 1,
			0, 0, 0, 30, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 87, 105, 114, 101, 67, 111, 110,
			110, 101, 99, 116, 105, 111, 110, 77, 101, 115,
			115, 97, 103, 101, 1, 0, 0, 0, 27, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 87, 105,
			114, 101, 76, 105, 110, 101, 65, 110, 99, 104,
			111, 114, 73, 110, 102, 111, 1, 0, 0, 0,
			29, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			87, 105, 114, 101, 82, 101, 99, 111, 110, 110,
			101, 99, 116, 77, 101, 115, 115, 97, 103, 101,
			1, 0, 0, 0, 18, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 87, 111, 114, 108, 100, 68,
			97, 116, 97, 1, 0, 0, 0, 18, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 87, 111, 114,
			108, 100, 73, 116, 101, 109, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			87, 111, 114, 108, 100, 77, 101, 115, 115, 97,
			103, 101, 1, 0, 0, 0, 16, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 90, 105, 112, 108,
			105, 110, 101, 1, 0, 0, 0, 28, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 90, 105, 112,
			108, 105, 110, 101, 65, 114, 114, 105, 118, 97,
			108, 80, 111, 105, 110, 116, 1, 0, 0, 0,
			25, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			90, 105, 112, 108, 105, 110, 101, 77, 111, 117,
			110, 116, 97, 98, 108, 101, 1, 0, 0, 0,
			35, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 103, 103, 114, 101, 115, 115, 105, 111, 110,
			84, 105, 109, 101, 114, 65, 73, 69, 118, 101,
			110, 116, 68, 97, 116, 97, 1, 0, 0, 0,
			17, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 73, 68, 101, 115, 105, 103, 110, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 73, 69, 118, 101, 110, 116, 68,
			97, 116, 97, 1, 0, 0, 0, 25, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 73, 83,
			116, 97, 116, 101, 67, 111, 110, 116, 97, 105,
			110, 101, 114, 1, 0, 0, 0, 29, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 109, 109,
			111, 66, 101, 108, 111, 119, 65, 73, 69, 118,
			101, 110, 116, 68, 97, 116, 97, 1, 0, 0,
			0, 21, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 66, 114, 111, 97, 100, 99,
			97, 115, 116, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			67, 97, 109, 101, 114, 97, 73, 110, 102, 111,
			1, 0, 0, 0, 23, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 67, 97, 109,
			101, 114, 97, 73, 110, 112, 117, 116, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 67, 97, 109, 101, 114,
			97, 82, 97, 121, 115, 1, 0, 0, 0, 29,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 65,
			112, 112, 67, 97, 109, 101, 114, 97, 82, 97,
			121, 115, 124, 69, 110, 116, 105, 116, 121, 1,
			0, 0, 0, 27, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 67, 97, 109, 101,
			114, 97, 83, 117, 98, 115, 99, 114, 105, 98,
			101, 1, 0, 0, 0, 23, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 112, 112, 67, 108,
			97, 110, 67, 104, 97, 110, 103, 101, 100, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 67, 108, 97, 110,
			67, 104, 97, 116, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 67, 108, 97, 110, 73, 110, 102, 111, 1,
			0, 0, 0, 23, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 67, 108, 97, 110,
			77, 101, 115, 115, 97, 103, 101, 1, 0, 0,
			0, 17, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 69, 109, 112, 116, 121, 1,
			0, 0, 0, 25, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 69, 110, 116, 105,
			116, 121, 67, 104, 97, 110, 103, 101, 100, 1,
			0, 0, 0, 22, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 69, 110, 116, 105,
			116, 121, 73, 110, 102, 111, 1, 0, 0, 0,
			25, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 112, 112, 69, 110, 116, 105, 116, 121, 80,
			97, 121, 108, 111, 97, 100, 1, 0, 0, 0,
			30, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			65, 112, 112, 69, 110, 116, 105, 116, 121, 80,
			97, 121, 108, 111, 97, 100, 124, 73, 116, 101,
			109, 1, 0, 0, 0, 17, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 112, 112, 69, 114,
			114, 111, 114, 1, 0, 0, 0, 16, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			70, 108, 97, 103, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 71, 101, 116, 78, 101, 120, 117, 115, 65,
			117, 116, 104, 1, 0, 0, 0, 16, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			73, 110, 102, 111, 1, 0, 0, 0, 15, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 77, 97, 112, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 65, 112,
			112, 77, 97, 112, 124, 77, 111, 110, 117, 109,
			101, 110, 116, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 112, 112,
			77, 97, 112, 77, 97, 114, 107, 101, 114, 115,
			1, 0, 0, 0, 18, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 77, 97, 114,
			107, 101, 114, 1, 0, 0, 0, 28, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 65, 112, 112,
			77, 97, 114, 107, 101, 114, 124, 83, 101, 108,
			108, 79, 114, 100, 101, 114, 1, 0, 0, 0,
			19, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 112, 112, 77, 101, 115, 115, 97, 103, 101,
			1, 0, 0, 0, 26, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 78, 101, 119,
			67, 108, 97, 110, 77, 101, 115, 115, 97, 103,
			101, 1, 0, 0, 0, 26, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 112, 112, 78, 101,
			119, 84, 101, 97, 109, 77, 101, 115, 115, 97,
			103, 101, 1, 0, 0, 0, 21, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 112, 112, 78,
			101, 120, 117, 115, 65, 117, 116, 104, 1, 0,
			0, 0, 27, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 65, 112, 112, 80, 114, 111, 109, 111,
			116, 101, 84, 111, 76, 101, 97, 100, 101, 114,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 82, 101, 113,
			117, 101, 115, 116, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 82, 101, 115, 112, 111, 110, 115, 101, 1,
			0, 0, 0, 17, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 114, 111, 118, 97,
			108, 1, 0, 0, 0, 23, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 112, 112, 83, 101,
			110, 100, 77, 101, 115, 115, 97, 103, 101, 1,
			0, 0, 0, 26, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 112, 112, 83, 101, 116, 69,
			110, 116, 105, 116, 121, 86, 97, 108, 117, 101,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 65, 112, 112, 83, 117, 99,
			99, 101, 115, 115, 1, 0, 0, 0, 23, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 84, 101, 97, 109, 67, 104, 97, 110, 103,
			101, 100, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 112, 112, 84,
			101, 97, 109, 67, 104, 97, 116, 1, 0, 0,
			0, 20, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 65, 112, 112, 84, 101, 97, 109, 73, 110,
			102, 111, 1, 0, 0, 0, 27, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 65, 112, 112, 84,
			101, 97, 109, 73, 110, 102, 111, 124, 77, 101,
			109, 98, 101, 114, 1, 0, 0, 0, 25, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 65, 112,
			112, 84, 101, 97, 109, 73, 110, 102, 111, 124,
			78, 111, 116, 101, 1, 0, 0, 0, 23, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 112,
			112, 84, 101, 97, 109, 77, 101, 115, 115, 97,
			103, 101, 1, 0, 0, 0, 16, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 65, 112, 112, 84,
			105, 109, 101, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 114, 99,
			97, 100, 101, 71, 97, 109, 101, 1, 0, 0,
			0, 29, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 65, 114, 99, 97, 100, 101, 71, 97, 109,
			101, 124, 97, 114, 99, 97, 100, 101, 69, 110,
			116, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 65, 114, 99, 97, 100,
			101, 77, 97, 99, 104, 105, 110, 101, 1, 0,
			0, 0, 33, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 65, 114, 99, 97, 100, 101, 77, 97,
			99, 104, 105, 110, 101, 124, 83, 99, 111, 114,
			101, 69, 110, 116, 114, 121, 1, 0, 0, 0,
			24, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			65, 115, 115, 111, 99, 105, 97, 116, 101, 100,
			70, 105, 108, 101, 115, 1, 0, 0, 0, 39,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 65,
			115, 115, 111, 99, 105, 97, 116, 101, 100, 70,
			105, 108, 101, 115, 124, 65, 115, 115, 111, 99,
			105, 97, 116, 101, 100, 70, 105, 108, 101, 1,
			0, 0, 0, 15, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 116, 116, 97, 99, 107, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 116, 116, 97, 99, 107, 72,
			101, 108, 105, 1, 0, 0, 0, 26, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 65, 116, 116,
			97, 99, 107, 72, 101, 108, 105, 82, 111, 99,
			107, 101, 116, 115, 1, 0, 0, 0, 25, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 116,
			116, 97, 99, 107, 72, 101, 108, 105, 84, 117,
			114, 114, 101, 116, 1, 0, 0, 0, 20, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 65, 117,
			100, 105, 111, 69, 110, 116, 105, 116, 121, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 65, 117, 116, 111, 84, 117, 114,
			114, 101, 116, 1, 0, 0, 0, 17, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 66, 97, 108,
			108, 105, 115, 116, 97, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			97, 108, 108, 105, 115, 116, 97, 71, 117, 110,
			1, 0, 0, 0, 17, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 66, 97, 115, 101, 66, 111,
			97, 116, 1, 0, 0, 0, 19, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 66, 97, 115, 101,
			67, 111, 109, 98, 97, 116, 1, 0, 0, 0,
			19, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			66, 97, 115, 101, 69, 110, 116, 105, 116, 121,
			1, 0, 0, 0, 18, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 66, 97, 115, 101, 77, 101,
			108, 101, 101, 1, 0, 0, 0, 24, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 66, 97, 115,
			101, 78, 101, 116, 119, 111, 114, 107, 97, 98,
			108, 101, 1, 0, 0, 0, 16, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 66, 97, 115, 101,
			78, 80, 67, 1, 0, 0, 0, 17, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 66, 97, 115,
			101, 79, 118, 101, 110, 1, 0, 0, 0, 29,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 66,
			97, 115, 101, 79, 118, 101, 110, 124, 67, 111,
			111, 107, 105, 110, 103, 73, 116, 101, 109, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 66, 97, 115, 101, 80, 108, 97,
			121, 101, 114, 1, 0, 0, 0, 23, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 66, 97, 115,
			101, 80, 114, 111, 106, 101, 99, 116, 105, 108,
			101, 1, 0, 0, 0, 21, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 97, 115, 101, 82,
			101, 115, 111, 117, 114, 99, 101, 1, 0, 0,
			0, 22, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 66, 97, 115, 101, 83, 99, 117, 108, 112,
			116, 117, 114, 101, 1, 0, 0, 0, 18, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 66, 97,
			115, 101, 84, 114, 97, 105, 110, 1, 0, 0,
			0, 20, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 66, 97, 115, 101, 86, 101, 104, 105, 99,
			108, 101, 1, 0, 0, 0, 31, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 66, 97, 115, 101,
			86, 101, 104, 105, 99, 108, 101, 124, 77, 111,
			117, 110, 116, 80, 111, 105, 110, 116, 1, 0,
			0, 0, 21, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 66, 97, 116, 116, 101, 114, 105, 110,
			103, 82, 97, 109, 1, 0, 0, 0, 16, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 66, 101,
			101, 104, 105, 118, 101, 1, 0, 0, 0, 23,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 66,
			101, 101, 77, 97, 115, 116, 101, 114, 83, 119,
			97, 114, 109, 1, 0, 0, 0, 13, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 66, 105, 107,
			101, 1, 0, 0, 0, 16, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 111, 111, 109, 66,
			111, 120, 1, 0, 0, 0, 19, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 66, 114, 97, 100,
			108, 101, 121, 65, 80, 67, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			66, 114, 97, 105, 110, 67, 111, 109, 112, 111,
			110, 101, 110, 116, 1, 0, 0, 0, 22, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 66, 117,
			105, 108, 100, 105, 110, 103, 66, 108, 111, 99,
			107, 1, 0, 0, 0, 26, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 66, 117, 105, 108, 100,
			105, 110, 103, 80, 114, 105, 118, 105, 108, 101,
			103, 101, 1, 0, 0, 0, 31, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 66, 117, 105, 108,
			100, 105, 110, 103, 80, 114, 105, 118, 105, 108,
			101, 103, 101, 82, 101, 116, 114, 111, 1, 0,
			0, 0, 35, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 66, 117, 105, 108, 100, 105, 110, 103,
			80, 114, 105, 118, 105, 108, 101, 103, 101, 82,
			101, 116, 114, 111, 84, 111, 111, 108, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 66, 117, 114, 105, 101, 100, 73, 116,
			101, 109, 115, 1, 0, 0, 0, 37, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 66, 117, 114,
			105, 101, 100, 73, 116, 101, 109, 115, 124, 83,
			116, 111, 114, 101, 100, 66, 117, 114, 105, 101,
			100, 73, 116, 101, 109, 1, 0, 0, 0, 21,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			97, 109, 112, 101, 114, 77, 111, 100, 117, 108,
			101, 1, 0, 0, 0, 17, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 67, 97, 114, 100, 71,
			97, 109, 101, 1, 0, 0, 0, 27, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 67, 97, 114,
			100, 71, 97, 109, 101, 124, 66, 108, 97, 99,
			107, 106, 97, 99, 107, 1, 0, 0, 0, 37,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 67,
			97, 114, 100, 71, 97, 109, 101, 124, 66, 108,
			97, 99, 107, 106, 97, 99, 107, 67, 97, 114,
			100, 80, 108, 97, 121, 101, 114, 1, 0, 0,
			0, 26, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 67, 97, 114, 100, 71, 97, 109, 101, 124,
			67, 97, 114, 100, 76, 105, 115, 116, 1, 0,
			0, 0, 28, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 97, 114, 100, 71, 97, 109, 101,
			124, 67, 97, 114, 100, 80, 108, 97, 121, 101,
			114, 1, 0, 0, 0, 30, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 67, 97, 114, 100, 71,
			97, 109, 101, 124, 82, 111, 117, 110, 100, 82,
			101, 115, 117, 108, 116, 115, 1, 0, 0, 0,
			37, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			67, 97, 114, 100, 71, 97, 109, 101, 43, 82,
			111, 117, 110, 100, 82, 101, 115, 117, 108, 116,
			115, 124, 82, 101, 115, 117, 108, 116, 1, 0,
			0, 0, 29, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 97, 114, 100, 71, 97, 109, 101,
			124, 84, 101, 120, 97, 115, 72, 111, 108, 100,
			69, 109, 1, 0, 0, 0, 19, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 67, 97, 114, 103,
			111, 80, 108, 97, 110, 101, 1, 0, 0, 0,
			18, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 97, 114, 103, 111, 83, 104, 105, 112, 1,
			0, 0, 0, 27, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 97, 114, 103, 111, 83, 104,
			105, 112, 67, 111, 110, 116, 97, 105, 110, 101,
			114, 1, 0, 0, 0, 17, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 67, 97, 115, 115, 101,
			116, 116, 101, 1, 0, 0, 0, 17, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 67, 97, 116,
			97, 112, 117, 108, 116, 1, 0, 0, 0, 26,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			104, 97, 110, 99, 101, 65, 73, 69, 118, 101,
			110, 116, 68, 97, 116, 97, 1, 0, 0, 0,
			20, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 104, 105, 99, 107, 101, 110, 67, 111, 111,
			112, 1, 0, 0, 0, 32, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 67, 104, 105, 99, 107,
			101, 110, 67, 111, 111, 112, 83, 116, 97, 116,
			117, 115, 85, 112, 100, 97, 116, 101, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 104, 105, 99, 107, 101, 110, 83,
			116, 97, 116, 117, 115, 1, 0, 0, 0, 24,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			105, 110, 101, 109, 97, 116, 105, 99, 69, 110,
			116, 105, 116, 121, 1, 0, 0, 0, 25, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 67, 108,
			97, 110, 65, 99, 116, 105, 111, 110, 82, 101,
			115, 117, 108, 116, 1, 0, 0, 0, 35, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			120, 117, 115, 124, 67, 108, 97, 110, 67, 104,
			97, 116, 66, 97, 116, 99, 104, 82, 101, 113,
			117, 101, 115, 116, 1, 0, 0, 0, 43, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			120, 117, 115, 46, 67, 108, 97, 110, 67, 104,
			97, 116, 66, 97, 116, 99, 104, 82, 101, 113,
			117, 101, 115, 116, 124, 77, 101, 115, 115, 97,
			103, 101, 1, 0, 0, 0, 17, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 67, 108, 97, 110,
			73, 110, 102, 111, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 67, 108,
			97, 110, 73, 110, 102, 111, 124, 73, 110, 118,
			105, 116, 101, 1, 0, 0, 0, 24, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 67, 108, 97,
			110, 73, 110, 102, 111, 124, 77, 101, 109, 98,
			101, 114, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 67, 108, 97, 110,
			73, 110, 102, 111, 124, 82, 111, 108, 101, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 108, 97, 110, 73, 110, 118,
			105, 116, 97, 116, 105, 111, 110, 115, 1, 0,
			0, 0, 35, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 108, 97, 110, 73, 110, 118, 105,
			116, 97, 116, 105, 111, 110, 115, 124, 73, 110,
			118, 105, 116, 97, 116, 105, 111, 110, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 108, 97, 110, 76, 101, 97, 100,
			101, 114, 98, 111, 97, 114, 100, 1, 0, 0,
			0, 30, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 67, 108, 97, 110, 76, 101, 97, 100, 101,
			114, 98, 111, 97, 114, 100, 124, 69, 110, 116,
			114, 121, 1, 0, 0, 0, 16, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 67, 108, 97, 110,
			76, 111, 103, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 67, 108, 97,
			110, 76, 111, 103, 124, 69, 110, 116, 114, 121,
			1, 0, 0, 0, 20, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 108, 97, 110, 77, 97,
			110, 97, 103, 101, 114, 1, 0, 0, 0, 24,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 67,
			108, 97, 110, 83, 99, 111, 114, 101, 69, 118,
			101, 110, 116, 115, 1, 0, 0, 0, 30, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 67, 108,
			97, 110, 83, 99, 111, 114, 101, 69, 118, 101,
			110, 116, 115, 124, 69, 110, 116, 114, 121, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 108, 105, 101, 110, 116, 82,
			101, 97, 100, 121, 1, 0, 0, 0, 31, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 67, 108,
			105, 101, 110, 116, 82, 101, 97, 100, 121, 124,
			67, 108, 105, 101, 110, 116, 73, 110, 102, 111,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 111, 97, 108, 105, 110,
			103, 84, 111, 119, 101, 114, 1, 0, 0, 0,
			17, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 111, 100, 101, 76, 111, 99, 107, 1, 0,
			0, 0, 25, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 67, 111, 100, 101, 76, 111, 99, 107,
			124, 80, 114, 105, 118, 97, 116, 101, 0, 0,
			0, 0, 27, 85, 110, 105, 116, 121, 69, 110,
			103, 105, 110, 101, 124, 67, 111, 108, 111, 114,
			83, 101, 114, 105, 97, 108, 105, 122, 101, 100,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 67, 111, 109, 109, 97, 110,
			100, 66, 108, 111, 99, 107, 1, 0, 0, 0,
			18, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 111, 109, 112, 111, 115, 116, 101, 114, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 67, 111, 109, 112, 117, 116, 101,
			114, 83, 116, 97, 116, 105, 111, 110, 1, 0,
			0, 0, 25, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 111, 110, 110, 101, 99, 116, 101,
			100, 83, 112, 101, 97, 107, 101, 114, 1, 0,
			0, 0, 28, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 67, 111, 110, 115, 116, 114, 117, 99,
			116, 97, 98, 108, 101, 69, 110, 116, 105, 116,
			121, 1, 0, 0, 0, 28, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 67, 111, 110, 116, 97,
			105, 110, 101, 114, 67, 111, 114, 112, 115, 101,
			68, 97, 116, 97, 1, 0, 0, 0, 28, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 67, 111,
			112, 121, 80, 97, 115, 116, 101, 69, 110, 116,
			105, 116, 121, 73, 110, 102, 111, 1, 0, 0,
			0, 15, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 67, 111, 114, 112, 115, 101, 1, 0, 0,
			0, 14, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 67, 114, 97, 110, 101, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			67, 114, 101, 97, 116, 101, 66, 117, 105, 108,
			100, 105, 110, 103, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 67, 117,
			115, 116, 111, 109, 86, 105, 116, 97, 108, 73,
			110, 102, 111, 1, 0, 0, 0, 21, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 67, 117, 115,
			116, 111, 109, 86, 105, 116, 97, 108, 115, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 68, 101, 99, 97, 121, 69, 110,
			116, 105, 116, 121, 1, 0, 0, 0, 22, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 68, 101,
			108, 105, 118, 101, 114, 121, 68, 114, 111, 110,
			101, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 68, 101, 109, 111, 72,
			101, 97, 100, 101, 114, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 68,
			101, 109, 111, 83, 104, 111, 116, 1, 0, 0,
			0, 30, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 68, 101, 109, 111, 83, 104, 111, 116, 70,
			108, 111, 97, 116, 75, 101, 121, 102, 114, 97,
			109, 101, 1, 0, 0, 0, 27, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 68, 101, 109, 111,
			83, 104, 111, 116, 70, 108, 111, 97, 116, 84,
			114, 97, 99, 107, 1, 0, 0, 0, 31, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 68, 101,
			109, 111, 83, 104, 111, 116, 80, 97, 114, 101,
			110, 116, 75, 101, 121, 102, 114, 97, 109, 101,
			1, 0, 0, 0, 28, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 68, 101, 109, 111, 83, 104,
			111, 116, 80, 97, 114, 101, 110, 116, 84, 114,
			97, 99, 107, 1, 0, 0, 0, 35, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 68, 101, 109,
			111, 83, 104, 111, 116, 81, 117, 97, 116, 101,
			114, 110, 105, 111, 110, 75, 101, 121, 102, 114,
			97, 109, 101, 1, 0, 0, 0, 32, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 68, 101, 109,
			111, 83, 104, 111, 116, 81, 117, 97, 116, 101,
			114, 110, 105, 111, 110, 84, 114, 97, 99, 107,
			1, 0, 0, 0, 31, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 68, 101, 109, 111, 83, 104,
			111, 116, 86, 101, 99, 116, 111, 114, 75, 101,
			121, 102, 114, 97, 109, 101, 1, 0, 0, 0,
			28, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			68, 101, 109, 111, 83, 104, 111, 116, 86, 101,
			99, 116, 111, 114, 84, 114, 97, 99, 107, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 68, 105, 101, 115, 101, 108, 69,
			110, 103, 105, 110, 101, 1, 0, 0, 0, 21,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 68,
			105, 103, 105, 116, 97, 108, 67, 108, 111, 99,
			107, 1, 0, 0, 0, 26, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 68, 105, 103, 105, 116,
			97, 108, 67, 108, 111, 99, 107, 65, 108, 97,
			114, 109, 1, 0, 0, 0, 28, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 68, 105, 103, 105,
			116, 97, 108, 67, 108, 111, 99, 107, 77, 101,
			115, 115, 97, 103, 101, 1, 0, 0, 0, 31,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 68,
			105, 118, 101, 114, 80, 114, 111, 112, 117, 108,
			115, 105, 111, 110, 86, 101, 104, 105, 99, 108,
			101, 1, 0, 0, 0, 13, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 68, 111, 111, 114, 1,
			0, 0, 0, 14, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 68, 114, 111, 110, 101, 1, 0,
			0, 0, 21, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 68, 117, 100, 69, 120, 112, 108, 111,
			115, 105, 118, 101, 1, 0, 0, 0, 11, 124,
			69, 102, 102, 101, 99, 116, 68, 97, 116, 97,
			1, 0, 0, 0, 16, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 69, 103, 103, 72, 117, 110,
			116, 1, 0, 0, 0, 26, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 69, 103, 103, 72, 117,
			110, 116, 124, 69, 103, 103, 72, 117, 110, 116,
			101, 114, 1, 0, 0, 0, 17, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 69, 108, 101, 118,
			97, 116, 111, 114, 1, 0, 0, 0, 21, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 69, 108,
			101, 118, 97, 116, 111, 114, 76, 105, 102, 116,
			1, 0, 0, 0, 22, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 69, 110, 103, 105, 110, 101,
			83, 116, 111, 114, 97, 103, 101, 1, 0, 0,
			0, 15, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 69, 110, 116, 105, 116, 121, 1, 0, 0,
			0, 21, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 69, 110, 116, 105, 116, 121, 73, 100, 76,
			105, 115, 116, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 69, 110, 116,
			105, 116, 121, 76, 105, 115, 116, 1, 0, 0,
			0, 20, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 69, 110, 116, 105, 116, 121, 83, 108, 111,
			116, 115, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 69, 110, 118, 105,
			114, 111, 110, 109, 101, 110, 116, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 70, 97, 114, 109, 97, 98, 108, 101, 65,
			110, 105, 109, 97, 108, 1, 0, 0, 0, 29,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 70,
			97, 114, 109, 97, 98, 108, 101, 65, 110, 105,
			109, 97, 108, 83, 116, 97, 116, 117, 115, 1,
			0, 0, 0, 33, 80, 114, 111, 116, 111, 66,
			117, 102, 46, 78, 101, 120, 117, 115, 124, 70,
			101, 114, 114, 121, 82, 101, 116, 105, 114, 101,
			82, 101, 113, 117, 101, 115, 116, 1, 0, 0,
			0, 26, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 78, 101, 120, 117, 115, 124, 70, 101, 114,
			114, 121, 83, 116, 97, 116, 117, 115, 1, 0,
			0, 0, 33, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 78, 101, 120, 117, 115, 124, 70, 101,
			114, 114, 121, 83, 116, 97, 116, 117, 115, 82,
			101, 113, 117, 101, 115, 116, 1, 0, 0, 0,
			34, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			78, 101, 120, 117, 115, 124, 70, 101, 114, 114,
			121, 83, 116, 97, 116, 117, 115, 82, 101, 115,
			112, 111, 110, 115, 101, 1, 0, 0, 0, 41,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 124, 70, 101, 114, 114, 121,
			85, 112, 100, 97, 116, 101, 83, 99, 104, 101,
			100, 117, 108, 101, 82, 101, 113, 117, 101, 115,
			116, 1, 0, 0, 0, 29, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 70, 105, 108, 101, 83,
			116, 111, 114, 97, 103, 101, 67, 97, 99, 104,
			101, 68, 97, 116, 97, 1, 0, 0, 0, 26,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 70,
			114, 97, 110, 107, 101, 110, 115, 116, 101, 105,
			110, 84, 97, 98, 108, 101, 1, 0, 0, 0,
			17, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			71, 97, 109, 101, 77, 111, 100, 101, 1, 0,
			0, 0, 29, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 71, 97, 109, 101, 77, 111, 100, 101,
			124, 80, 108, 97, 121, 101, 114, 83, 99, 111,
			114, 101, 1, 0, 0, 0, 29, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 71, 97, 109, 101,
			77, 111, 100, 101, 124, 83, 99, 111, 114, 101,
			67, 111, 108, 117, 109, 110, 1, 0, 0, 0,
			26, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			71, 97, 109, 101, 77, 111, 100, 101, 124, 84,
			101, 97, 109, 73, 110, 102, 111, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 71, 101, 110, 101, 114, 105, 99, 83, 112,
			97, 119, 110, 101, 114, 1, 0, 0, 0, 34,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 71,
			101, 110, 101, 114, 105, 99, 83, 112, 97, 119,
			110, 101, 114, 124, 83, 112, 97, 119, 110, 101,
			100, 69, 110, 116, 1, 0, 0, 0, 31, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 71, 108,
			111, 98, 97, 108, 69, 110, 116, 105, 116, 121,
			67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
			1, 0, 0, 0, 25, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 71, 108, 111, 98, 97, 108,
			69, 110, 116, 105, 116, 121, 68, 97, 116, 97,
			1, 0, 0, 0, 23, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 71, 114, 111, 119, 97, 98,
			108, 101, 69, 110, 116, 105, 116, 121, 1, 0,
			0, 0, 21, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 71, 117, 110, 87, 101, 97, 112, 111,
			110, 77, 111, 100, 1, 0, 0, 0, 14, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 72, 97,
			108, 102, 51, 1, 0, 0, 0, 20, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 72, 97, 114,
			98, 111, 114, 67, 114, 97, 110, 101, 1, 0,
			0, 0, 31, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 72, 97, 114, 98, 111, 114, 67, 114,
			97, 110, 101, 124, 81, 117, 101, 117, 101, 100,
			77, 111, 118, 101, 1, 0, 0, 0, 17, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 72, 101,
			97, 100, 68, 97, 116, 97, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			72, 101, 97, 108, 116, 104, 66, 101, 108, 111,
			119, 65, 73, 69, 118, 101, 110, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 19, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 72, 101, 108, 100,
			69, 110, 116, 105, 116, 121, 1, 0, 0, 0,
			19, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			72, 101, 108, 105, 99, 111, 112, 116, 101, 114,
			1, 0, 0, 0, 25, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 72, 101, 108, 105, 99, 111,
			112, 116, 101, 114, 70, 108, 97, 114, 101, 115,
			1, 0, 0, 0, 14, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 72, 111, 114, 115, 101, 1,
			0, 0, 0, 23, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 72, 111, 114, 115, 101, 77, 111,
			100, 105, 102, 105, 101, 114, 115, 1, 0, 0,
			0, 22, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 72, 111, 116, 65, 105, 114, 66, 97, 108,
			108, 111, 111, 110, 1, 0, 0, 0, 31, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 72, 117,
			110, 103, 101, 114, 65, 98, 111, 118, 101, 65,
			73, 69, 118, 101, 110, 116, 68, 97, 116, 97,
			1, 0, 0, 0, 27, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 73, 110, 100, 117, 115, 116,
			114, 105, 97, 108, 67, 111, 110, 118, 101, 121,
			111, 114, 1, 0, 0, 0, 38, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 73, 110, 100, 117,
			115, 116, 114, 105, 97, 108, 67, 111, 110, 118,
			101, 121, 111, 114, 124, 73, 116, 101, 109, 70,
			105, 108, 116, 101, 114, 1, 0, 0, 0, 42,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 73,
			110, 100, 117, 115, 116, 114, 105, 97, 108, 67,
			111, 110, 118, 101, 121, 111, 114, 124, 73, 116,
			101, 109, 70, 105, 108, 116, 101, 114, 76, 105,
			115, 116, 1, 0, 0, 0, 35, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 73, 110, 100, 117,
			115, 116, 114, 105, 97, 108, 67, 111, 110, 118,
			101, 121, 111, 114, 84, 114, 97, 110, 115, 102,
			101, 114, 1, 0, 0, 0, 48, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 73, 110, 100, 117,
			115, 116, 114, 105, 97, 108, 67, 111, 110, 118,
			101, 121, 111, 114, 84, 114, 97, 110, 115, 102,
			101, 114, 124, 73, 116, 101, 109, 84, 114, 97,
			110, 115, 102, 101, 114, 1, 0, 0, 0, 26,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 73,
			110, 100, 117, 115, 116, 114, 105, 97, 108, 67,
			114, 97, 102, 116, 101, 114, 1, 0, 0, 0,
			13, 124, 73, 110, 112, 117, 116, 77, 101, 115,
			115, 97, 103, 101, 1, 0, 0, 0, 27, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 73, 110,
			82, 97, 110, 103, 101, 65, 73, 69, 118, 101,
			110, 116, 68, 97, 116, 97, 1, 0, 0, 0,
			33, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			73, 110, 82, 97, 110, 103, 101, 79, 102, 72,
			111, 109, 101, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 30, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 73, 110,
			115, 116, 114, 117, 109, 101, 110, 116, 77, 105,
			100, 105, 66, 105, 110, 100, 105, 110, 103, 1,
			0, 0, 0, 31, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 73, 110, 115, 116, 114, 117, 109,
			101, 110, 116, 77, 105, 100, 105, 66, 105, 110,
			100, 105, 110, 103, 115, 1, 0, 0, 0, 28,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 73,
			110, 115, 116, 114, 117, 109, 101, 110, 116, 82,
			101, 99, 111, 114, 100, 105, 110, 103, 1, 0,
			0, 0, 32, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 73, 110, 115, 116, 114, 117, 109, 101,
			110, 116, 82, 101, 99, 111, 114, 100, 105, 110,
			103, 78, 111, 116, 101, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 73,
			79, 69, 110, 116, 105, 116, 121, 1, 0, 0,
			0, 30, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 73, 79, 69, 110, 116, 105, 116, 121, 124,
			73, 79, 67, 111, 110, 110, 101, 99, 116, 105,
			111, 110, 1, 0, 0, 0, 44, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 73, 79, 69, 110,
			116, 105, 116, 121, 43, 73, 79, 67, 111, 110,
			110, 101, 99, 116, 105, 111, 110, 124, 76, 105,
			110, 101, 80, 111, 105, 110, 116, 76, 105, 115,
			116, 1, 0, 0, 0, 38, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 73, 79, 69, 110, 116,
			105, 116, 121, 43, 73, 79, 67, 111, 110, 110,
			101, 99, 116, 105, 111, 110, 124, 76, 105, 110,
			101, 86, 101, 99, 1, 0, 0, 0, 13, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 73, 116,
			101, 109, 1, 0, 0, 0, 27, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 73, 116, 101, 109,
			124, 67, 111, 110, 100, 105, 116, 105, 111, 110,
			68, 97, 116, 97, 1, 0, 0, 0, 26, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 73, 116,
			101, 109, 124, 73, 110, 115, 116, 97, 110, 99,
			101, 68, 97, 116, 97, 1, 0, 0, 0, 23,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 73,
			116, 101, 109, 65, 109, 111, 117, 110, 116, 76,
			105, 115, 116, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 73, 116, 101,
			109, 67, 111, 110, 116, 97, 105, 110, 101, 114,
			1, 0, 0, 0, 20, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 73, 116, 101, 109, 67, 114,
			97, 102, 116, 101, 114, 1, 0, 0, 0, 25,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 73,
			116, 101, 109, 67, 114, 97, 102, 116, 101, 114,
			124, 84, 97, 115, 107, 1, 0, 0, 0, 28,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 73,
			116, 101, 109, 79, 119, 110, 101, 114, 115, 104,
			105, 112, 65, 109, 111, 117, 110, 116, 1, 0,
			0, 0, 16, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 75, 101, 121, 76, 111, 99, 107, 1,
			0, 0, 0, 17, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 76, 97, 110, 100, 109, 105, 110,
			101, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 76, 101, 103, 97, 99,
			121, 83, 104, 101, 108, 116, 101, 114, 1, 0,
			0, 0, 13, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 76, 105, 102, 116, 1, 0, 0, 0,
			22, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			76, 105, 103, 104, 116, 68, 101, 112, 108, 111,
			121, 101, 114, 1, 0, 0, 0, 20, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 76, 105, 103,
			104, 116, 83, 116, 114, 105, 110, 103, 1, 0,
			0, 0, 32, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 76, 105, 103, 104, 116, 83, 116, 114,
			105, 110, 103, 124, 83, 116, 114, 105, 110, 103,
			80, 111, 105, 110, 116, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 76,
			105, 110, 101, 80, 111, 105, 110, 116, 1, 0,
			0, 0, 13, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 76, 111, 111, 116, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			76, 111, 111, 116, 97, 98, 108, 101, 67, 111,
			114, 112, 115, 101, 1, 0, 0, 0, 31, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 76, 111,
			111, 116, 97, 98, 108, 101, 67, 111, 114, 112,
			115, 101, 124, 80, 114, 105, 118, 97, 116, 101,
			1, 0, 0, 0, 17, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 77, 97, 103, 97, 122, 105,
			110, 101, 1, 0, 0, 0, 16, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 97, 105, 108,
			98, 111, 120, 1, 0, 0, 0, 18, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 97, 110,
			110, 101, 113, 117, 105, 110, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			77, 97, 110, 110, 101, 113, 117, 105, 110, 124,
			67, 108, 111, 116, 104, 105, 110, 103, 73, 116,
			101, 109, 1, 0, 0, 0, 16, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 97, 112, 68,
			97, 116, 97, 1, 0, 0, 0, 18, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 97, 112,
			69, 110, 116, 105, 116, 121, 1, 0, 0, 0,
			16, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			77, 97, 112, 78, 111, 116, 101, 1, 0, 0,
			0, 20, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 77, 97, 112, 78, 111, 116, 101, 76, 105,
			115, 116, 1, 0, 0, 0, 23, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 97, 114, 107,
			101, 116, 84, 101, 114, 109, 105, 110, 97, 108,
			1, 0, 0, 0, 36, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 77, 97, 114, 107, 101, 116,
			84, 101, 114, 109, 105, 110, 97, 108, 124, 80,
			101, 110, 100, 105, 110, 103, 79, 114, 100, 101,
			114, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 77, 101, 109, 111, 114,
			121, 66, 97, 110, 107, 1, 0, 0, 0, 28,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 77,
			101, 116, 97, 108, 68, 101, 116, 101, 99, 116,
			111, 114, 83, 111, 117, 114, 99, 101, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 77, 105, 99, 114, 111, 112, 104, 111,
			110, 101, 83, 116, 97, 110, 100, 1, 0, 0,
			0, 19, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 77, 105, 110, 105, 99, 111, 112, 116, 101,
			114, 1, 0, 0, 0, 21, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 77, 105, 110, 105, 110,
			103, 81, 117, 97, 114, 114, 121, 1, 0, 0,
			0, 22, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 77, 105, 115, 115, 105, 111, 110, 69, 110,
			116, 105, 116, 121, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 77, 105,
			115, 115, 105, 111, 110, 73, 110, 115, 116, 97,
			110, 99, 101, 1, 0, 0, 0, 28, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 77, 105, 115,
			115, 105, 111, 110, 73, 110, 115, 116, 97, 110,
			99, 101, 68, 97, 116, 97, 1, 0, 0, 0,
			25, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			77, 105, 115, 115, 105, 111, 110, 77, 97, 112,
			77, 97, 114, 107, 101, 114, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			77, 105, 115, 115, 105, 111, 110, 80, 111, 105,
			110, 116, 1, 0, 0, 0, 22, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 105, 115, 115,
			105, 111, 110, 82, 101, 119, 97, 114, 100, 1,
			0, 0, 0, 17, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 77, 105, 115, 115, 105, 111, 110,
			115, 1, 0, 0, 0, 20, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 77, 105, 120, 105, 110,
			103, 84, 97, 98, 108, 101, 1, 0, 0, 0,
			13, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			77, 76, 82, 83, 1, 0, 0, 0, 11, 124,
			77, 111, 100, 101, 108, 83, 116, 97, 116, 101,
			1, 0, 0, 0, 17, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 77, 111, 100, 105, 102, 105,
			101, 114, 1, 0, 0, 0, 19, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 77, 111, 100, 117,
			108, 97, 114, 67, 97, 114, 1, 0, 0, 0,
			23, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			77, 111, 100, 117, 108, 97, 114, 86, 101, 104,
			105, 99, 108, 101, 1, 0, 0, 0, 22, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 77, 111,
			100, 117, 108, 101, 77, 101, 115, 115, 97, 103,
			101, 1, 0, 0, 0, 18, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 77, 111, 116, 111, 114,
			98, 111, 97, 116, 1, 0, 0, 0, 17, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 78, 101,
			111, 110, 83, 105, 103, 110, 1, 0, 0, 0,
			24, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			78, 101, 111, 110, 83, 105, 103, 110, 124, 76,
			105, 103, 104, 116, 115, 1, 0, 0, 0, 26,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 78,
			101, 120, 117, 115, 68, 111, 99, 107, 84, 101,
			114, 109, 105, 110, 97, 108, 1, 0, 0, 0,
			40, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			78, 101, 120, 117, 115, 68, 111, 99, 107, 84,
			101, 114, 109, 105, 110, 97, 108, 124, 83, 99,
			104, 101, 100, 117, 108, 101, 69, 110, 116, 114,
			121, 1, 0, 0, 0, 19, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 78, 101, 120, 117, 115,
			70, 101, 114, 114, 121, 1, 0, 0, 0, 20,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 78,
			101, 120, 117, 115, 73, 115, 108, 97, 110, 100,
			1, 0, 0, 0, 23, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 78, 80, 67, 83, 101, 110,
			115, 101, 115, 83, 116, 97, 116, 101, 1, 0,
			0, 0, 26, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 78, 80, 67, 86, 101, 110, 100, 105,
			110, 103, 77, 97, 99, 104, 105, 110, 101, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 79, 98, 106, 101, 99, 116, 105,
			118, 101, 83, 116, 97, 116, 117, 115, 1, 0,
			0, 0, 19, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 79, 99, 101, 97, 110, 80, 97, 116,
			104, 115, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 79, 119, 110, 101,
			114, 73, 110, 102, 111, 1, 0, 0, 0, 21,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 124, 80, 97, 99, 107, 101,
			116, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 80, 97, 105, 110, 116,
			97, 98, 108, 101, 83, 105, 103, 110, 1, 0,
			0, 0, 20, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 80, 97, 105, 110, 116, 101, 100, 73,
			116, 101, 109, 1, 0, 0, 0, 19, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 80, 97, 114,
			101, 110, 116, 73, 110, 102, 111, 1, 0, 0,
			0, 18, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 97, 114, 116, 121, 68, 97, 116, 97,
			1, 0, 0, 0, 24, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 80, 97, 114, 116, 121, 77,
			101, 109, 98, 101, 114, 68, 97, 116, 97, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 97, 115, 116, 101, 82, 101,
			113, 117, 101, 115, 116, 1, 0, 0, 0, 17,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 80,
			97, 116, 104, 68, 97, 116, 97, 1, 0, 0,
			0, 24, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 97, 116, 116, 101, 114, 110, 70, 105,
			114, 101, 119, 111, 114, 107, 1, 0, 0, 0,
			31, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			80, 97, 116, 116, 101, 114, 110, 70, 105, 114,
			101, 119, 111, 114, 107, 124, 68, 101, 115, 105,
			103, 110, 1, 0, 0, 0, 36, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 80, 97, 116, 116,
			101, 114, 110, 70, 105, 114, 101, 119, 111, 114,
			107, 124, 83, 97, 118, 101, 100, 68, 101, 115,
			105, 103, 110, 1, 0, 0, 0, 29, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 80, 97, 116,
			116, 101, 114, 110, 70, 105, 114, 101, 119, 111,
			114, 107, 124, 83, 116, 97, 114, 1, 0, 0,
			0, 25, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 101, 114, 115, 105, 115, 116, 97, 110,
			116, 80, 108, 97, 121, 101, 114, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 104, 111, 110, 101, 68, 105, 114, 101,
			99, 116, 111, 114, 121, 1, 0, 0, 0, 38,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 80,
			104, 111, 110, 101, 68, 105, 114, 101, 99, 116,
			111, 114, 121, 124, 68, 105, 114, 101, 99, 116,
			111, 114, 121, 69, 110, 116, 114, 121, 1, 0,
			0, 0, 14, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 80, 104, 111, 116, 111, 1, 0, 0,
			0, 19, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 80, 104, 111, 116, 111, 70, 114, 97, 109,
			101, 1, 0, 0, 0, 26, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 78, 101, 120, 117, 115,
			124, 80, 105, 110, 103, 82, 101, 113, 117, 101,
			115, 116, 1, 0, 0, 0, 27, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 78, 101, 120, 117,
			115, 124, 80, 105, 110, 103, 82, 101, 115, 112,
			111, 110, 115, 101, 1, 0, 0, 0, 21, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 80, 108,
			97, 121, 101, 114, 65, 116, 116, 97, 99, 107,
			1, 0, 0, 0, 34, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 80, 108, 97, 121, 101, 114,
			68, 101, 116, 101, 99, 116, 101, 100, 65, 73,
			69, 118, 101, 110, 116, 68, 97, 116, 97, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 108, 97, 121, 101, 114, 73,
			110, 118, 101, 110, 116, 111, 114, 121, 1, 0,
			0, 0, 24, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 80, 108, 97, 121, 101, 114, 76, 105,
			102, 101, 83, 116, 111, 114, 121, 1, 0, 0,
			0, 34, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 80, 108, 97, 121, 101, 114, 76, 105, 102,
			101, 83, 116, 111, 114, 121, 124, 68, 101, 97,
			116, 104, 73, 110, 102, 111, 1, 0, 0, 0,
			36, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			80, 108, 97, 121, 101, 114, 76, 105, 102, 101,
			83, 116, 111, 114, 121, 124, 71, 101, 110, 101,
			114, 105, 99, 83, 116, 97, 116, 1, 0, 0,
			0, 36, 80, 114, 111, 116, 111, 66, 117, 102,
			46, 80, 108, 97, 121, 101, 114, 76, 105, 102,
			101, 83, 116, 111, 114, 121, 124, 87, 101, 97,
			112, 111, 110, 83, 116, 97, 116, 115, 1, 0,
			0, 0, 36, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 78, 101, 120, 117, 115, 124, 80, 108,
			97, 121, 101, 114, 77, 97, 110, 105, 102, 101,
			115, 116, 82, 101, 113, 117, 101, 115, 116, 1,
			0, 0, 0, 25, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 108, 97, 121, 101, 114, 77,
			101, 116, 97, 98, 111, 108, 105, 115, 109, 1,
			0, 0, 0, 24, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 108, 97, 121, 101, 114, 77,
			111, 100, 105, 102, 105, 101, 114, 115, 1, 0,
			0, 0, 21, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 80, 108, 97, 121, 101, 114, 78, 97,
			109, 101, 73, 68, 1, 0, 0, 0, 31, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 80, 108,
			97, 121, 101, 114, 80, 114, 111, 106, 101, 99,
			116, 105, 108, 101, 65, 116, 116, 97, 99, 107,
			1, 0, 0, 0, 33, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 80, 108, 97, 121, 101, 114,
			80, 114, 111, 106, 101, 99, 116, 105, 108, 101,
			82, 105, 99, 111, 99, 104, 101, 116, 1, 0,
			0, 0, 31, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 80, 108, 97, 121, 101, 114, 80, 114,
			111, 106, 101, 99, 116, 105, 108, 101, 85, 112,
			100, 97, 116, 101, 1, 0, 0, 0, 34, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			120, 117, 115, 124, 80, 108, 97, 121, 101, 114,
			83, 101, 99, 111, 110, 100, 97, 114, 121, 68,
			97, 116, 97, 1, 0, 0, 0, 51, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 78, 101, 120,
			117, 115, 46, 80, 108, 97, 121, 101, 114, 83,
			101, 99, 111, 110, 100, 97, 114, 121, 68, 97,
			116, 97, 124, 82, 101, 108, 97, 116, 105, 111,
			110, 115, 104, 105, 112, 68, 97, 116, 97, 1,
			0, 0, 0, 20, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 108, 97, 121, 101, 114, 83,
			116, 97, 116, 101, 1, 0, 0, 0, 19, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 80, 108,
			97, 121, 101, 114, 84, 101, 97, 109, 1, 0,
			0, 0, 30, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 80, 108, 97, 121, 101, 114, 84, 101,
			97, 109, 124, 84, 101, 97, 109, 77, 101, 109,
			98, 101, 114, 1, 0, 0, 0, 11, 124, 80,
			108, 97, 121, 101, 114, 84, 105, 99, 107, 1,
			0, 0, 0, 25, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 108, 97, 121, 101, 114, 85,
			112, 100, 97, 116, 101, 76, 111, 111, 116, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 80, 114, 101, 102, 97, 98, 68,
			97, 116, 97, 1, 0, 0, 0, 26, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 80, 114, 111,
			99, 101, 100, 117, 114, 97, 108, 68, 117, 110,
			103, 101, 111, 110, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 80, 114,
			111, 106, 101, 99, 116, 105, 108, 101, 83, 104,
			111, 111, 116, 1, 0, 0, 0, 35, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 80, 114, 111,
			106, 101, 99, 116, 105, 108, 101, 83, 104, 111,
			111, 116, 124, 80, 114, 111, 106, 101, 99, 116,
			105, 108, 101, 1, 0, 0, 0, 20, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 80, 117, 122,
			122, 108, 101, 82, 101, 115, 101, 116, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 82, 97, 100, 105, 111, 76, 105, 115,
			116, 1, 0, 0, 0, 16, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 82, 97, 103, 100, 111,
			108, 108, 0, 0, 0, 0, 25, 85, 110, 105,
			116, 121, 69, 110, 103, 105, 110, 101, 124, 82,
			97, 121, 83, 101, 114, 105, 97, 108, 105, 122,
			101, 100, 1, 0, 0, 0, 17, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 82, 67, 69, 110,
			116, 105, 116, 121, 1, 0, 0, 0, 23, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 82, 101,
			99, 108, 97, 105, 109, 77, 97, 110, 97, 103,
			101, 114, 1, 0, 0, 0, 35, 80, 114, 111,
			116, 111, 66, 117, 102, 46, 82, 101, 99, 108,
			97, 105, 109, 77, 97, 110, 97, 103, 101, 114,
			124, 82, 101, 99, 108, 97, 105, 109, 73, 110,
			102, 111, 1, 0, 0, 0, 24, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 82, 101, 99, 108,
			97, 105, 109, 84, 101, 114, 109, 105, 110, 97,
			108, 1, 0, 0, 0, 28, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 82, 101, 108, 97, 116,
			105, 111, 110, 115, 104, 105, 112, 77, 97, 110,
			97, 103, 101, 114, 1, 0, 0, 0, 51, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 82, 101,
			108, 97, 116, 105, 111, 110, 115, 104, 105, 112,
			77, 97, 110, 97, 103, 101, 114, 124, 80, 108,
			97, 121, 101, 114, 82, 101, 108, 97, 116, 105,
			111, 110, 115, 104, 105, 112, 73, 110, 102, 111,
			1, 0, 0, 0, 48, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 82, 101, 108, 97, 116, 105,
			111, 110, 115, 104, 105, 112, 77, 97, 110, 97,
			103, 101, 114, 124, 80, 108, 97, 121, 101, 114,
			82, 101, 108, 97, 116, 105, 111, 110, 115, 104,
			105, 112, 115, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 78, 101, 120,
			117, 115, 124, 82, 101, 113, 117, 101, 115, 116,
			1, 0, 0, 0, 22, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 82, 101, 115, 101, 97, 114,
			99, 104, 84, 97, 98, 108, 101, 1, 0, 0,
			0, 26, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 82, 101, 115, 111, 117, 114, 99, 101, 69,
			120, 116, 114, 97, 99, 116, 111, 114, 1, 0,
			0, 0, 27, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 82, 101, 115, 112, 97, 119, 110, 73,
			110, 102, 111, 114, 109, 97, 116, 105, 111, 110,
			1, 0, 0, 0, 40, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 82, 101, 115, 112, 97, 119,
			110, 73, 110, 102, 111, 114, 109, 97, 116, 105,
			111, 110, 124, 83, 112, 97, 119, 110, 79, 112,
			116, 105, 111, 110, 115, 1, 0, 0, 0, 23,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 124, 82, 101, 115, 112, 111,
			110, 115, 101, 1, 0, 0, 0, 21, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 82, 111, 99,
			107, 105, 110, 103, 67, 104, 97, 105, 114, 1,
			0, 0, 0, 18, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 83, 97, 108, 101, 115, 68, 97,
			116, 97, 1, 0, 0, 0, 16, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 65, 77, 83,
			105, 116, 101, 1, 0, 0, 0, 18, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 83, 101, 114,
			118, 101, 114, 71, 105, 98, 1, 0, 0, 0,
			19, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			83, 104, 111, 112, 75, 101, 101, 112, 101, 114,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 83, 105, 101, 103, 101, 84,
			111, 119, 101, 114, 1, 0, 0, 0, 13, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 105,
			103, 110, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 105, 109, 112,
			108, 101, 73, 110, 116, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 83,
			105, 109, 112, 108, 101, 85, 73, 68, 1, 0,
			0, 0, 19, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 105, 109, 112, 108, 101, 85, 73,
			110, 116, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 107, 117, 108,
			108, 84, 114, 111, 112, 104, 121, 1, 0, 0,
			0, 20, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 83, 108, 101, 101, 112, 105, 110, 103, 66,
			97, 103, 1, 0, 0, 0, 26, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 108, 101, 101,
			112, 105, 110, 103, 66, 97, 103, 67, 97, 109,
			112, 101, 114, 1, 0, 0, 0, 40, 80, 114,
			111, 116, 111, 66, 117, 102, 46, 78, 101, 120,
			117, 115, 124, 83, 108, 101, 101, 112, 105, 110,
			103, 66, 97, 103, 68, 101, 115, 116, 114, 111,
			121, 82, 101, 113, 117, 101, 115, 116, 1, 0,
			0, 0, 40, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 78, 101, 120, 117, 115, 124, 83, 108,
			101, 101, 112, 105, 110, 103, 66, 97, 103, 82,
			101, 115, 112, 97, 119, 110, 82, 101, 113, 117,
			101, 115, 116, 1, 0, 0, 0, 20, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 83, 108, 111,
			116, 77, 97, 99, 104, 105, 110, 101, 1, 0,
			0, 0, 19, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 83, 109, 97, 114, 116, 65, 108, 97,
			114, 109, 1, 0, 0, 0, 19, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 110, 111, 119,
			109, 111, 98, 105, 108, 101, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			83, 111, 114, 116, 83, 101, 116, 116, 105, 110,
			103, 115, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 112, 97, 119,
			110, 97, 98, 108, 101, 1, 0, 0, 0, 34,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 78,
			101, 120, 117, 115, 124, 83, 112, 97, 119, 110,
			79, 112, 116, 105, 111, 110, 115, 82, 101, 113,
			117, 101, 115, 116, 1, 0, 0, 0, 35, 80,
			114, 111, 116, 111, 66, 117, 102, 46, 78, 101,
			120, 117, 115, 124, 83, 112, 97, 119, 110, 79,
			112, 116, 105, 111, 110, 115, 82, 101, 115, 112,
			111, 110, 115, 101, 1, 0, 0, 0, 21, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 112,
			101, 99, 116, 97, 116, 101, 84, 101, 97, 109,
			1, 0, 0, 0, 25, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 83, 112, 101, 99, 116, 97,
			116, 101, 84, 101, 97, 109, 73, 110, 102, 111,
			1, 0, 0, 0, 21, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 83, 112, 104, 101, 114, 101,
			69, 110, 116, 105, 116, 121, 1, 0, 0, 0,
			21, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			83, 112, 105, 110, 110, 101, 114, 87, 104, 101,
			101, 108, 1, 0, 0, 0, 14, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 83, 112, 114, 97,
			121, 1, 0, 0, 0, 18, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 83, 112, 114, 97, 121,
			76, 105, 110, 101, 1, 0, 0, 0, 18, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 83, 112,
			114, 97, 121, 76, 105, 115, 116, 1, 0, 0,
			0, 24, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 83, 116, 97, 98, 105, 108, 105, 116, 121,
			69, 110, 116, 105, 116, 121, 1, 0, 0, 0,
			30, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			83, 116, 97, 116, 105, 99, 82, 101, 115, 112,
			97, 119, 110, 65, 114, 101, 97, 68, 97, 116,
			97, 1, 0, 0, 0, 21, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 78, 101, 120, 117, 115,
			124, 83, 116, 97, 116, 117, 115, 1, 0, 0,
			0, 23, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 83, 116, 111, 114, 97, 103, 101, 65, 100,
			97, 112, 116, 111, 114, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 83,
			116, 111, 114, 97, 103, 101, 66, 111, 120, 1,
			0, 0, 0, 22, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 83, 117, 98, 69, 110, 116, 105,
			116, 121, 76, 105, 115, 116, 1, 0, 0, 0,
			18, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			83, 117, 98, 109, 97, 114, 105, 110, 101, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 84, 97, 107, 101, 68, 97, 109,
			97, 103, 101, 1, 0, 0, 0, 34, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 84, 97, 114,
			103, 101, 116, 68, 101, 116, 101, 99, 116, 101,
			100, 65, 73, 69, 118, 101, 110, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 18, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 84, 101, 108, 101,
			112, 104, 111, 110, 101, 1, 0, 0, 0, 25,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 84,
			101, 109, 112, 111, 114, 97, 114, 121, 82, 97,
			103, 100, 111, 108, 108, 1, 0, 0, 0, 34,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 84,
			104, 114, 101, 97, 116, 68, 101, 116, 101, 99,
			116, 101, 100, 65, 73, 69, 118, 101, 110, 116,
			68, 97, 116, 97, 1, 0, 0, 0, 23, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 84, 105,
			109, 101, 100, 69, 120, 112, 108, 111, 115, 105,
			118, 101, 1, 0, 0, 0, 25, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 84, 105, 109, 101,
			114, 65, 73, 69, 118, 101, 110, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 35, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 84, 105, 109, 101,
			83, 105, 110, 99, 101, 84, 104, 114, 101, 97,
			116, 65, 73, 69, 118, 101, 110, 116, 68, 97,
			116, 97, 1, 0, 0, 0, 20, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 84, 105, 110, 67,
			97, 110, 65, 108, 97, 114, 109, 1, 0, 0,
			0, 34, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 84, 105, 114, 101, 100, 110, 101, 115, 115,
			65, 98, 111, 118, 101, 65, 73, 69, 118, 101,
			110, 116, 68, 97, 116, 97, 1, 0, 0, 0,
			20, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			84, 114, 97, 105, 110, 69, 110, 103, 105, 110,
			101, 1, 0, 0, 0, 30, 80, 114, 111, 116,
			111, 66, 117, 102, 46, 78, 101, 120, 117, 115,
			124, 84, 114, 97, 110, 115, 102, 101, 114, 82,
			101, 113, 117, 101, 115, 116, 1, 0, 0, 0,
			25, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			84, 114, 97, 118, 101, 108, 108, 105, 110, 103,
			86, 101, 110, 100, 111, 114, 1, 0, 0, 0,
			13, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			84, 114, 101, 101, 1, 0, 0, 0, 17, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 84, 114,
			101, 101, 76, 105, 115, 116, 1, 0, 0, 0,
			20, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			84, 114, 101, 101, 82, 101, 115, 112, 97, 119,
			110, 1, 0, 0, 0, 23, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 84, 117, 116, 111, 114,
			105, 97, 108, 73, 115, 108, 97, 110, 100, 1,
			0, 0, 0, 19, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 85, 112, 100, 97, 116, 101, 73,
			116, 101, 109, 1, 0, 0, 0, 28, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 85, 112, 100,
			97, 116, 101, 73, 116, 101, 109, 67, 111, 110,
			116, 97, 105, 110, 101, 114, 0, 0, 0, 0,
			30, 70, 97, 99, 101, 112, 117, 110, 99, 104,
			46, 78, 101, 120, 117, 115, 124, 85, 117, 105,
			100, 83, 101, 114, 105, 97, 108, 105, 122, 101,
			100, 1, 0, 0, 0, 20, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 86, 68, 68, 114, 97,
			119, 69, 110, 116, 114, 121, 0, 0, 0, 0,
			29, 85, 110, 105, 116, 121, 69, 110, 103, 105,
			110, 101, 124, 86, 101, 99, 116, 111, 114, 50,
			83, 101, 114, 105, 97, 108, 105, 122, 101, 100,
			0, 0, 0, 0, 29, 85, 110, 105, 116, 121,
			69, 110, 103, 105, 110, 101, 124, 86, 101, 99,
			116, 111, 114, 51, 83, 101, 114, 105, 97, 108,
			105, 122, 101, 100, 0, 0, 0, 0, 29, 85,
			110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
			124, 86, 101, 99, 116, 111, 114, 52, 83, 101,
			114, 105, 97, 108, 105, 122, 101, 100, 1, 0,
			0, 0, 19, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 101, 99, 116, 111, 114, 68, 97,
			116, 97, 1, 0, 0, 0, 19, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 86, 101, 99, 116,
			111, 114, 76, 105, 115, 116, 1, 0, 0, 0,
			20, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			86, 101, 104, 105, 99, 108, 101, 76, 105, 102,
			116, 1, 0, 0, 0, 22, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 86, 101, 104, 105, 99,
			108, 101, 77, 111, 100, 117, 108, 101, 1, 0,
			0, 0, 22, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 86, 101, 104, 105, 99, 108, 101, 86,
			101, 110, 100, 111, 114, 1, 0, 0, 0, 36,
			80, 114, 111, 116, 111, 66, 117, 102, 46, 86,
			101, 104, 105, 99, 108, 101, 86, 101, 110, 100,
			111, 114, 124, 80, 108, 97, 121, 101, 114, 83,
			116, 111, 114, 97, 103, 101, 1, 0, 0, 0,
			56, 80, 114, 111, 116, 111, 66, 117, 102, 46,
			86, 101, 104, 105, 99, 108, 101, 86, 101, 110,
			100, 111, 114, 43, 80, 108, 97, 121, 101, 114,
			83, 116, 111, 114, 97, 103, 101, 124, 80, 108,
			97, 121, 101, 114, 83, 116, 111, 114, 101, 100,
			86, 101, 104, 105, 99, 108, 101, 1, 0, 0,
			0, 30, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 86, 101, 110, 100, 105, 110, 103, 68, 121,
			110, 97, 109, 105, 99, 80, 114, 105, 99, 105,
			110, 103, 1, 0, 0, 0, 23, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 86, 101, 110, 100,
			105, 110, 103, 77, 97, 99, 104, 105, 110, 101,
			1, 0, 0, 0, 33, 80, 114, 111, 116, 111,
			66, 117, 102, 46, 86, 101, 110, 100, 105, 110,
			103, 77, 97, 99, 104, 105, 110, 101, 124, 83,
			101, 108, 108, 79, 114, 100, 101, 114, 1, 0,
			0, 0, 42, 80, 114, 111, 116, 111, 66, 117,
			102, 46, 86, 101, 110, 100, 105, 110, 103, 77,
			97, 99, 104, 105, 110, 101, 124, 83, 101, 108,
			108, 79, 114, 100, 101, 114, 67, 111, 110, 116,
			97, 105, 110, 101, 114, 1, 0, 0, 0, 36,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 86,
			101, 110, 100, 105, 110, 103, 77, 97, 99, 104,
			105, 110, 101, 76, 111, 110, 103, 84, 101, 114,
			109, 83, 116, 97, 116, 115, 1, 0, 0, 0,
			50, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			86, 101, 110, 100, 105, 110, 103, 77, 97, 99,
			104, 105, 110, 101, 80, 117, 114, 99, 104, 97,
			115, 101, 72, 105, 115, 116, 111, 114, 121, 69,
			110, 116, 114, 121, 77, 101, 115, 115, 97, 103,
			101, 1, 0, 0, 0, 55, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 86, 101, 110, 100, 105,
			110, 103, 77, 97, 99, 104, 105, 110, 101, 80,
			117, 114, 99, 104, 97, 115, 101, 72, 105, 115,
			116, 111, 114, 121, 69, 110, 116, 114, 121, 83,
			109, 97, 108, 108, 77, 101, 115, 115, 97, 103,
			101, 1, 0, 0, 0, 45, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 86, 101, 110, 100, 105,
			110, 103, 77, 97, 99, 104, 105, 110, 101, 80,
			117, 114, 99, 104, 97, 115, 101, 72, 105, 115,
			116, 111, 114, 121, 77, 101, 115, 115, 97, 103,
			101, 1, 0, 0, 0, 28, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 86, 101, 110, 100, 105,
			110, 103, 77, 97, 99, 104, 105, 110, 101, 83,
			116, 97, 116, 115, 1, 0, 0, 0, 24, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 86, 105,
			110, 101, 68, 101, 115, 116, 105, 110, 97, 116,
			105, 111, 110, 1, 0, 0, 0, 22, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 86, 105, 110,
			101, 77, 111, 117, 110, 116, 97, 98, 108, 101,
			1, 0, 0, 0, 17, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 86, 105, 110, 101, 84, 114,
			101, 101, 1, 0, 0, 0, 23, 80, 114, 111,
			116, 111, 66, 117, 102, 124, 86, 111, 105, 99,
			101, 109, 97, 105, 108, 69, 110, 116, 114, 121,
			1, 0, 0, 0, 22, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 87, 97, 108, 108, 112, 97,
			112, 101, 114, 84, 111, 111, 108, 1, 0, 0,
			0, 21, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 87, 97, 110, 116, 101, 100, 80, 111, 115,
			116, 101, 114, 1, 0, 0, 0, 18, 80, 114,
			111, 116, 111, 66, 117, 102, 124, 87, 97, 116,
			101, 114, 80, 111, 111, 108, 1, 0, 0, 0,
			18, 80, 114, 111, 116, 111, 66, 117, 102, 124,
			87, 97, 116, 101, 114, 87, 101, 108, 108, 1,
			0, 0, 0, 21, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 87, 97, 121, 112, 111, 105, 110,
			116, 82, 97, 99, 101, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 87,
			101, 97, 112, 111, 110, 82, 97, 99, 107, 1,
			0, 0, 0, 23, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 87, 101, 97, 112, 111, 110, 82,
			97, 99, 107, 73, 116, 101, 109, 1, 0, 0,
			0, 18, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 87, 104, 105, 116, 101, 108, 105, 115, 116,
			1, 0, 0, 0, 19, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 87, 105, 112, 101, 76, 97,
			112, 116, 111, 112, 1, 0, 0, 0, 30, 80,
			114, 111, 116, 111, 66, 117, 102, 124, 87, 105,
			114, 101, 67, 111, 110, 110, 101, 99, 116, 105,
			111, 110, 77, 101, 115, 115, 97, 103, 101, 1,
			0, 0, 0, 27, 80, 114, 111, 116, 111, 66,
			117, 102, 124, 87, 105, 114, 101, 76, 105, 110,
			101, 65, 110, 99, 104, 111, 114, 73, 110, 102,
			111, 1, 0, 0, 0, 29, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 87, 105, 114, 101, 82,
			101, 99, 111, 110, 110, 101, 99, 116, 77, 101,
			115, 115, 97, 103, 101, 1, 0, 0, 0, 18,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 87,
			111, 114, 108, 100, 68, 97, 116, 97, 1, 0,
			0, 0, 18, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 87, 111, 114, 108, 100, 73, 116, 101,
			109, 1, 0, 0, 0, 21, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 87, 111, 114, 108, 100,
			77, 101, 115, 115, 97, 103, 101, 1, 0, 0,
			0, 16, 80, 114, 111, 116, 111, 66, 117, 102,
			124, 90, 105, 112, 108, 105, 110, 101, 1, 0,
			0, 0, 28, 80, 114, 111, 116, 111, 66, 117,
			102, 124, 90, 105, 112, 108, 105, 110, 101, 65,
			114, 114, 105, 118, 97, 108, 80, 111, 105, 110,
			116, 1, 0, 0, 0, 25, 80, 114, 111, 116,
			111, 66, 117, 102, 124, 90, 105, 112, 108, 105,
			110, 101, 77, 111, 117, 110, 116, 97, 98, 108,
			101, 1, 0, 0, 0, 34, 83, 105, 108, 101,
			110, 116, 79, 114, 98, 105, 116, 46, 80, 114,
			111, 116, 111, 99, 111, 108, 66, 117, 102, 102,
			101, 114, 115, 124, 73, 80, 114, 111, 116, 111,
			1, 0, 0, 0, 34, 83, 105, 108, 101, 110,
			116, 79, 114, 98, 105, 116, 46, 80, 114, 111,
			116, 111, 99, 111, 108, 66, 117, 102, 102, 101,
			114, 115, 124, 73, 80, 114, 111, 116, 111, 1,
			0, 0, 0, 42, 83, 105, 108, 101, 110, 116,
			79, 114, 98, 105, 116, 46, 80, 114, 111, 116,
			111, 99, 111, 108, 66, 117, 102, 102, 101, 114,
			115, 124, 80, 114, 111, 116, 111, 99, 111, 108,
			80, 97, 114, 115, 101, 114, 0, 0, 0, 0,
			22, 124, 80, 114, 111, 116, 111, 83, 116, 114,
			101, 97, 109, 69, 120, 116, 101, 110, 115, 105,
			111, 110, 115, 0, 0, 0, 0, 51, 83, 105,
			108, 101, 110, 116, 79, 114, 98, 105, 116, 46,
			80, 114, 111, 116, 111, 99, 111, 108, 66, 117,
			102, 102, 101, 114, 115, 124, 80, 114, 111, 116,
			111, 99, 111, 108, 66, 117, 102, 102, 101, 114,
			69, 120, 99, 101, 112, 116, 105, 111, 110, 0,
			0, 0, 0, 31, 83, 105, 108, 101, 110, 116,
			79, 114, 98, 105, 116, 46, 80, 114, 111, 116,
			111, 99, 111, 108, 66, 117, 102, 102, 101, 114,
			115, 124, 75, 101, 121, 1, 0, 0, 0, 42,
			83, 105, 108, 101, 110, 116, 79, 114, 98, 105,
			116, 46, 80, 114, 111, 116, 111, 99, 111, 108,
			66, 117, 102, 102, 101, 114, 115, 124, 80, 114,
			111, 116, 111, 99, 111, 108, 80, 97, 114, 115,
			101, 114, 1, 0, 0, 0, 42, 83, 105, 108,
			101, 110, 116, 79, 114, 98, 105, 116, 46, 80,
			114, 111, 116, 111, 99, 111, 108, 66, 117, 102,
			102, 101, 114, 115, 124, 80, 114, 111, 116, 111,
			99, 111, 108, 80, 97, 114, 115, 101, 114, 0,
			0, 0, 0, 13, 124, 66, 117, 102, 102, 101,
			114, 83, 116, 114, 101, 97, 109, 0, 0, 0,
			0, 19, 66, 117, 102, 102, 101, 114, 83, 116,
			114, 101, 97, 109, 124, 83, 104, 97, 114, 101,
			100, 0, 0, 0, 0, 24, 66, 117, 102, 102,
			101, 114, 83, 116, 114, 101, 97, 109, 124, 82,
			97, 110, 103, 101, 72, 97, 110, 100, 108, 101,
			1, 0, 0, 0, 14, 80, 114, 111, 116, 111,
			66, 117, 102, 124, 72, 97, 108, 102, 51, 0,
			0, 0, 0, 14, 124, 73, 83, 116, 114, 101,
			97, 109, 82, 101, 97, 100, 101, 114, 0, 0,
			0, 0, 14, 124, 73, 83, 116, 114, 101, 97,
			109, 87, 114, 105, 116, 101, 114, 0, 0, 0,
			0, 16, 124, 73, 116, 101, 109, 67, 111, 110,
			116, 97, 105, 110, 101, 114, 73, 100, 0, 0,
			0, 0, 7, 124, 73, 116, 101, 109, 73, 100,
			1, 0, 0, 0, 11, 124, 77, 111, 100, 101,
			108, 83, 116, 97, 116, 101, 0, 0, 0, 0,
			14, 124, 78, 101, 116, 119, 111, 114, 107, 97,
			98, 108, 101, 73, 100, 0, 0, 0, 0, 15,
			124, 78, 101, 116, 119, 111, 114, 107, 68, 101,
			102, 105, 110, 101, 115, 1, 0, 0, 0, 19,
			80, 114, 111, 116, 111, 66, 117, 102, 124, 86,
			101, 99, 116, 111, 114, 68, 97, 116, 97
		};
		result.TotalFiles = 12;
		result.TotalTypes = 894;
		result.IsEditorOnly = false;
		return result;
	}
}


public interface IProto
{
	void WriteToStream(BufferStream stream);

	void ReadFromStream(BufferStream stream, bool isDelta = false);

	void ReadFromStream(BufferStream stream, int size, bool isDelta = false);
}


using SilentOrbit.ProtocolBuffers;

public interface IProto<in T> : IProto where T : IProto
{
	void WriteToStreamDelta(BufferStream stream, T previousProto);

	void CopyTo(T other);
}


using System;
using System.IO;
using System.Text;
using SilentOrbit.ProtocolBuffers;

public static class ProtocolParser
{
	private const int staticBufferSize = 131072;

	[ThreadStatic]
	private static byte[] _staticBuffer;

	private static byte[] GetStaticBuffer()
	{
		return _staticBuffer ?? (_staticBuffer = new byte[131072]);
	}

	public static int ReadFixedInt32(BufferStream stream)
	{
		return stream.Read<int>();
	}

	public static void WriteFixedInt32(BufferStream stream, int i)
	{
		stream.Write(i);
	}

	public static long ReadFixedInt64(BufferStream stream)
	{
		return stream.Read<long>();
	}

	public static void WriteFixedInt64(BufferStream stream, long i)
	{
		stream.Write(i);
	}

	public static float ReadSingle(BufferStream stream)
	{
		return stream.Read<float>();
	}

	public static void WriteSingle(BufferStream stream, float f)
	{
		stream.Write(f);
	}

	public static double ReadDouble(BufferStream stream)
	{
		return stream.Read<double>();
	}

	public static void WriteDouble(BufferStream stream, double f)
	{
		stream.Write(f);
	}

	public unsafe static string ReadString(BufferStream stream)
	{
		int num = (int)ReadUInt32(stream);
		if (num <= 0)
		{
			return "";
		}
		string @string;
		fixed (byte* bytes = &stream.GetRange(num).GetSpan()[0])
		{
			@string = Encoding.UTF8.GetString(bytes, num);
		}
		return @string;
	}

	public static void WriteString(BufferStream stream, string val)
	{
		byte[] staticBuffer = GetStaticBuffer();
		int bytes = Encoding.UTF8.GetBytes(val, 0, val.Length, staticBuffer, 0);
		WriteUInt32(stream, (uint)bytes);
		if (bytes > 0)
		{
			new Span<byte>(staticBuffer, 0, bytes).CopyTo(stream.GetRange(bytes).GetSpan());
		}
	}

	public static byte[] ReadBytes(BufferStream stream)
	{
		int num = (int)ReadUInt32(stream);
		byte[] array = new byte[num];
		ReadBytesInto(stream, array, num);
		return array;
	}

	public static ArraySegment<byte> ReadPooledBytes(BufferStream stream)
	{
		int num = (int)ReadUInt32(stream);
		byte[] array = BufferStream.Shared.ArrayPool.Rent(num);
		ReadBytesInto(stream, array, num);
		return new ArraySegment<byte>(array, 0, num);
	}

	private static void ReadBytesInto(BufferStream stream, byte[] buffer, int length)
	{
		stream.GetRange(length).GetSpan().CopyTo(buffer);
	}

	public static void SkipBytes(BufferStream stream)
	{
		int count = (int)ReadUInt32(stream);
		stream.Skip(count);
	}

	public static void WriteBytes(BufferStream stream, byte[] val)
	{
		WriteUInt32(stream, (uint)val.Length);
		new Span<byte>(val).CopyTo(stream.GetRange(val.Length).GetSpan());
	}

	public static void WritePooledBytes(BufferStream stream, ArraySegment<byte> segment)
	{
		if (segment.Array == null)
		{
			WriteUInt32(stream, 0u);
			return;
		}
		WriteUInt32(stream, (uint)segment.Count);
		new Span<byte>(segment.Array, segment.Offset, segment.Count).CopyTo(stream.GetRange(segment.Count).GetSpan());
	}

	public static Key ReadKey(BufferStream stream)
	{
		uint num = ReadUInt32(stream);
		return new Key(num >> 3, (Wire)(num & 7));
	}

	public static Key ReadKey(byte firstByte, BufferStream stream)
	{
		if (firstByte < 128)
		{
			return new Key((uint)(firstByte >> 3), (Wire)(firstByte & 7));
		}
		return new Key((ReadUInt32(stream) << 4) | (uint)((firstByte >> 3) & 0xF), (Wire)(firstByte & 7));
	}

	public static void WriteKey(BufferStream stream, Key key)
	{
		uint val = (key.Field << 3) | (uint)key.WireType;
		WriteUInt32(stream, val);
	}

	public static void SkipKey(BufferStream stream, Key key)
	{
		switch (key.WireType)
		{
		case Wire.Fixed32:
			stream.Skip(4);
			break;
		case Wire.Fixed64:
			stream.Skip(8);
			break;
		case Wire.LengthDelimited:
			stream.Skip((int)ReadUInt32(stream));
			break;
		case Wire.Varint:
			ReadSkipVarInt(stream);
			break;
		default:
			throw new NotImplementedException("Unknown wire type: " + key.WireType);
		}
	}

	public static void ReadSkipVarInt(BufferStream stream)
	{
		int num;
		do
		{
			num = stream.ReadByte();
			if (num < 0)
			{
				throw new IOException("Stream ended too early");
			}
		}
		while ((num & 0x80) != 0);
	}

	public static uint ReadUInt32(Span<byte> array, int pos, out int length)
	{
		uint num = 0u;
		length = 0;
		for (int i = 0; i < 5; i++)
		{
			length++;
			if (pos >= array.Length)
			{
				break;
			}
			int num2 = array[pos++];
			if (num2 < 0)
			{
				throw new IOException("Stream ended too early");
			}
			if (i == 4 && (num2 & 0xF0) != 0)
			{
				throw new ProtocolBufferException("Got larger VarInt than 32bit unsigned");
			}
			if ((num2 & 0x80) == 0)
			{
				return num | (uint)(num2 << 7 * i);
			}
			num |= (uint)((num2 & 0x7F) << 7 * i);
		}
		throw new ProtocolBufferException("Got larger VarInt than 32bit unsigned");
	}

	public static int WriteUInt32(uint val, Span<byte> array, int pos)
	{
		int num = 0;
		while (pos < array.Length)
		{
			num++;
			byte b = (byte)(val & 0x7F);
			val >>= 7;
			if (val == 0)
			{
				array[pos++] = b;
				break;
			}
			b |= 0x80;
			array[pos++] = b;
		}
		return num;
	}

	public static int ReadZInt32(BufferStream stream)
	{
		uint num = ReadUInt32(stream);
		return (int)(num >> 1) ^ ((int)(num << 31) >> 31);
	}

	public static void WriteZInt32(BufferStream stream, int val)
	{
		WriteUInt32(stream, (uint)((val << 1) ^ (val >> 31)));
	}

	public static uint ReadUInt32(BufferStream stream)
	{
		uint num = 0u;
		for (int i = 0; i < 5; i++)
		{
			int num2 = stream.ReadByte();
			if (num2 < 0)
			{
				throw new IOException("Stream ended too early");
			}
			if (i == 4 && (num2 & 0xF0) != 0)
			{
				throw new ProtocolBufferException("Got larger VarInt than 32bit unsigned");
			}
			if ((num2 & 0x80) == 0)
			{
				return num | (uint)(num2 << 7 * i);
			}
			num |= (uint)((num2 & 0x7F) << 7 * i);
		}
		throw new ProtocolBufferException("Got larger VarInt than 32bit unsigned");
	}

	public static void WriteUInt32(BufferStream stream, uint val)
	{
		byte b;
		while (true)
		{
			b = (byte)(val & 0x7F);
			val >>= 7;
			if (val == 0)
			{
				break;
			}
			b |= 0x80;
			stream.WriteByte(b);
		}
		stream.WriteByte(b);
	}

	public static uint ReadUInt32(Stream stream)
	{
		uint num = 0u;
		for (int i = 0; i < 5; i++)
		{
			int num2 = stream.ReadByte();
			if (num2 < 0)
			{
				throw new IOException("Stream ended too early");
			}
			if (i == 4 && (num2 & 0xF0) != 0)
			{
				throw new ProtocolBufferException("Got larger VarInt than 32bit unsigned");
			}
			if ((num2 & 0x80) == 0)
			{
				return num | (uint)(num2 << 7 * i);
			}
			num |= (uint)((num2 & 0x7F) << 7 * i);
		}
		throw new ProtocolBufferException("Got larger VarInt than 32bit unsigned");
	}

	public static void WriteUInt32(Stream stream, uint val)
	{
		byte b;
		while (true)
		{
			b = (byte)(val & 0x7F);
			val >>= 7;
			if (val == 0)
			{
				break;
			}
			b |= 0x80;
			stream.WriteByte(b);
		}
		stream.WriteByte(b);
	}

	public static long ReadZInt64(BufferStream stream)
	{
		ulong num = ReadUInt64(stream);
		return (long)(num >> 1) ^ ((long)(num << 63) >> 63);
	}

	public static void WriteZInt64(BufferStream stream, long val)
	{
		WriteUInt64(stream, (ulong)((val << 1) ^ (val >> 63)));
	}

	public static ulong ReadUInt64(BufferStream stream)
	{
		ulong num = 0uL;
		for (int i = 0; i < 10; i++)
		{
			int num2 = stream.ReadByte();
			if (num2 < 0)
			{
				throw new IOException("Stream ended too early");
			}
			if (i == 9 && (num2 & 0xFE) != 0)
			{
				throw new ProtocolBufferException("Got larger VarInt than 64 bit unsigned");
			}
			if ((num2 & 0x80) == 0)
			{
				return num | (ulong)((long)num2 << 7 * i);
			}
			num |= (ulong)((long)(num2 & 0x7F) << 7 * i);
		}
		throw new ProtocolBufferException("Got larger VarInt than 64 bit unsigned");
	}

	public static void WriteUInt64(BufferStream stream, ulong val)
	{
		byte b;
		while (true)
		{
			b = (byte)(val & 0x7F);
			val >>= 7;
			if (val == 0L)
			{
				break;
			}
			b |= 0x80;
			stream.WriteByte(b);
		}
		stream.WriteByte(b);
	}

	public static ulong ReadUInt64(Span<byte> array, int pos, out int length)
	{
		ulong num = 0uL;
		length = 0;
		for (int i = 0; i < 10; i++)
		{
			length++;
			int num2 = array[pos++];
			if (num2 < 0)
			{
				throw new IOException("Stream ended too early");
			}
			if (i == 9 && (num2 & 0xFE) != 0)
			{
				throw new ProtocolBufferException("Got larger VarInt than 64 bit unsigned");
			}
			if ((num2 & 0x80) == 0)
			{
				return num | (ulong)((long)num2 << 7 * i);
			}
			num |= (ulong)((long)(num2 & 0x7F) << 7 * i);
		}
		throw new ProtocolBufferException("Got larger VarInt than 64 bit unsigned");
	}

	public static int WriteUInt64(ulong val, Span<byte> buffer, int pos)
	{
		int num = 0;
		byte b;
		while (true)
		{
			num++;
			b = (byte)(val & 0x7F);
			val >>= 7;
			if (val == 0L)
			{
				break;
			}
			b |= 0x80;
			buffer[pos++] = b;
		}
		buffer[pos] = b;
		return num;
	}

	public static bool ReadBool(BufferStream stream)
	{
		int num = stream.ReadByte();
		if (num < 0)
		{
			throw new IOException("Stream ended too early");
		}
		return num switch
		{
			1 => true, 
			0 => false, 
			_ => throw new ProtocolBufferException("Invalid boolean value"), 
		};
	}

	public static void WriteBool(BufferStream stream, bool val)
	{
		stream.WriteByte((byte)(val ? 1 : 0));
	}
}


using System;

public class ProtocolBufferException : Exception
{
	public ProtocolBufferException(string message)
		: base(message)
	{
	}
}


public enum Wire
{
	Varint = 0,
	Fixed64 = 1,
	LengthDelimited = 2,
	Fixed32 = 5
}


using SilentOrbit.ProtocolBuffers;

public struct Key
{
	public uint Field { get; set; }

	public Wire WireType { get; set; }

	public Key(uint field, Wire wireType)
	{
		Field = field;
		WireType = wireType;
	}

	public override string ToString()
	{
		return $"[Key: {Field}, {WireType}]";
	}
}


using System.IO;
using Facepunch.Nexus;
using SilentOrbit.ProtocolBuffers;

public class UuidSerialized
{
	public static void ResetToPool(Uuid instance)
	{
		((Uuid)(ref instance)).NodeId = 0;
		((Uuid)(ref instance)).Sequence = 0;
		((Uuid)(ref instance)).Timestamp = 0uL;
	}

	public static Uuid Deserialize(BufferStream stream, ref Uuid instance, bool isDelta)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				((Uuid)(ref instance)).NodeId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				((Uuid)(ref instance)).Sequence = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				((Uuid)(ref instance)).Timestamp = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Uuid DeserializeLengthDelimited(BufferStream stream, ref Uuid instance, bool isDelta)
	{
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				((Uuid)(ref instance)).NodeId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				((Uuid)(ref instance)).Sequence = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				((Uuid)(ref instance)).Timestamp = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Uuid DeserializeLength(BufferStream stream, int length, ref Uuid instance, bool isDelta)
	{
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				((Uuid)(ref instance)).NodeId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				((Uuid)(ref instance)).Sequence = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				((Uuid)(ref instance)).Timestamp = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Uuid instance, Uuid previous)
	{
		if (((Uuid)(ref instance)).NodeId != ((Uuid)(ref previous)).NodeId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)((Uuid)(ref instance)).NodeId);
		}
		if (((Uuid)(ref instance)).Sequence != ((Uuid)(ref previous)).Sequence)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)((Uuid)(ref instance)).Sequence);
		}
		if (((Uuid)(ref instance)).Timestamp != ((Uuid)(ref previous)).Timestamp)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, ((Uuid)(ref instance)).Timestamp);
		}
	}

	public static void Serialize(BufferStream stream, Uuid instance)
	{
		if (((Uuid)(ref instance)).NodeId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)((Uuid)(ref instance)).NodeId);
		}
		if (((Uuid)(ref instance)).Sequence != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)((Uuid)(ref instance)).Sequence);
		}
		if (((Uuid)(ref instance)).Timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, ((Uuid)(ref instance)).Timestamp);
		}
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System.IO;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ColorSerialized
{
	public static void ResetToPool(Color instance)
	{
		instance.r = 0f;
		instance.g = 0f;
		instance.b = 0f;
		instance.a = 0f;
	}

	public static Color Deserialize(BufferStream stream, ref Color instance, bool isDelta)
	{
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.r = 0f;
			instance.g = 0f;
			instance.b = 0f;
			instance.a = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.r = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.g = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.b = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.a = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Color DeserializeLengthDelimited(BufferStream stream, ref Color instance, bool isDelta)
	{
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.r = 0f;
			instance.g = 0f;
			instance.b = 0f;
			instance.a = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.r = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.g = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.b = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.a = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Color DeserializeLength(BufferStream stream, int length, ref Color instance, bool isDelta)
	{
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.r = 0f;
			instance.g = 0f;
			instance.b = 0f;
			instance.a = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.r = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.g = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.b = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.a = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Color instance, Color previous)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.r != previous.r)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.r);
		}
		if (instance.g != previous.g)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.g);
		}
		if (instance.b != previous.b)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.b);
		}
		if (instance.a != previous.a)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.a);
		}
	}

	public static void Serialize(BufferStream stream, Color instance)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (instance.r != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.r);
		}
		if (instance.g != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.g);
		}
		if (instance.b != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.b);
		}
		if (instance.a != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.a);
		}
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class RaySerialized
{
	public static void ResetToPool(Ray instance)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		((Ray)(ref instance)).origin = default(Vector3);
		((Ray)(ref instance)).direction = default(Vector3);
	}

	public static Ray Deserialize(BufferStream stream, ref Ray instance, bool isDelta)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance3 = ((Ray)(ref instance)).origin;
				((Ray)(ref instance)).origin = Vector3Serialized.DeserializeLengthDelimited(stream, ref instance3, isDelta);
				break;
			}
			case 18:
			{
				Vector3 instance2 = ((Ray)(ref instance)).direction;
				((Ray)(ref instance)).direction = Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Ray DeserializeLengthDelimited(BufferStream stream, ref Ray instance, bool isDelta)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance3 = ((Ray)(ref instance)).origin;
				((Ray)(ref instance)).origin = Vector3Serialized.DeserializeLengthDelimited(stream, ref instance3, isDelta);
				break;
			}
			case 18:
			{
				Vector3 instance2 = ((Ray)(ref instance)).direction;
				((Ray)(ref instance)).direction = Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Ray DeserializeLength(BufferStream stream, int length, ref Ray instance, bool isDelta)
	{
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance3 = ((Ray)(ref instance)).origin;
				((Ray)(ref instance)).origin = Vector3Serialized.DeserializeLengthDelimited(stream, ref instance3, isDelta);
				break;
			}
			case 18:
			{
				Vector3 instance2 = ((Ray)(ref instance)).direction;
				((Ray)(ref instance)).direction = Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Ray instance, Ray previous)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (((Ray)(ref instance)).origin != ((Ray)(ref previous)).origin)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, ((Ray)(ref instance)).origin, ((Ray)(ref previous)).origin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (((Ray)(ref instance)).direction != ((Ray)(ref previous)).direction)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, ((Ray)(ref instance)).direction, ((Ray)(ref previous)).direction);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field direction (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, Ray instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		if (((Ray)(ref instance)).origin != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, ((Ray)(ref instance)).origin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (((Ray)(ref instance)).direction != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, ((Ray)(ref instance)).direction);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field direction (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System.IO;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Vector2Serialized
{
	public static void ResetToPool(Vector2 instance)
	{
		instance.x = 0f;
		instance.y = 0f;
	}

	public static Vector2 Deserialize(BufferStream stream, ref Vector2 instance, bool isDelta)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Vector2 DeserializeLengthDelimited(BufferStream stream, ref Vector2 instance, bool isDelta)
	{
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Vector2 DeserializeLength(BufferStream stream, int length, ref Vector2 instance, bool isDelta)
	{
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Vector2 instance, Vector2 previous)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		if (instance.x != previous.x)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
	}

	public static void Serialize(BufferStream stream, Vector2 instance)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (instance.x != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System.IO;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Vector3Serialized
{
	public static void ResetToPool(Vector3 instance)
	{
		instance.x = 0f;
		instance.y = 0f;
		instance.z = 0f;
	}

	public static Vector3 Deserialize(BufferStream stream, ref Vector3 instance, bool isDelta)
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.z = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Vector3 DeserializeLengthDelimited(BufferStream stream, ref Vector3 instance, bool isDelta)
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.z = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Vector3 DeserializeLength(BufferStream stream, int length, ref Vector3 instance, bool isDelta)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.z = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Vector3 instance, Vector3 previous)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.x != previous.x)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != previous.z)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
	}

	public static void Serialize(BufferStream stream, Vector3 instance)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (instance.x != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System.IO;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Vector4Serialized
{
	public static void ResetToPool(Vector4 instance)
	{
		instance.x = 0f;
		instance.y = 0f;
		instance.z = 0f;
		instance.w = 0f;
	}

	public static Vector4 Deserialize(BufferStream stream, ref Vector4 instance, bool isDelta)
	{
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.z = 0f;
			instance.w = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.w = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Vector4 DeserializeLengthDelimited(BufferStream stream, ref Vector4 instance, bool isDelta)
	{
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.z = 0f;
			instance.w = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.w = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Vector4 DeserializeLength(BufferStream stream, int length, ref Vector4 instance, bool isDelta)
	{
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.z = 0f;
			instance.w = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.w = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Vector4 instance, Vector4 previous)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.x != previous.x)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != previous.z)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
		if (instance.w != previous.w)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.w);
		}
	}

	public static void Serialize(BufferStream stream, Vector4 instance)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (instance.x != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
		if (instance.w != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.w);
		}
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AggressionTimerAIEventData : IDisposable, IPooled, IProto<AggressionTimerAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AggressionTimerAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<AggressionTimerAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AggressionTimerAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AggressionTimerAIEventData instance)
	{
		instance.value = value;
	}

	public AggressionTimerAIEventData Copy()
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		CopyTo(aggressionTimerAIEventData);
		return aggressionTimerAIEventData;
	}

	public static AggressionTimerAIEventData Deserialize(BufferStream stream)
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		Deserialize(stream, aggressionTimerAIEventData, isDelta: false);
		return aggressionTimerAIEventData;
	}

	public static AggressionTimerAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		DeserializeLengthDelimited(stream, aggressionTimerAIEventData, isDelta: false);
		return aggressionTimerAIEventData;
	}

	public static AggressionTimerAIEventData DeserializeLength(BufferStream stream, int length)
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		DeserializeLength(stream, length, aggressionTimerAIEventData, isDelta: false);
		return aggressionTimerAIEventData;
	}

	public static AggressionTimerAIEventData Deserialize(byte[] buffer)
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, aggressionTimerAIEventData, isDelta: false);
		return aggressionTimerAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AggressionTimerAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AggressionTimerAIEventData Deserialize(BufferStream stream, AggressionTimerAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AggressionTimerAIEventData DeserializeLengthDelimited(BufferStream stream, AggressionTimerAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AggressionTimerAIEventData DeserializeLength(BufferStream stream, int length, AggressionTimerAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AggressionTimerAIEventData instance, AggressionTimerAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, AggressionTimerAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AIDesign : IDisposable, IPooled, IProto<AIDesign>, IProto
{
	[NonSerialized]
	public List<int> availableStates;

	[NonSerialized]
	public List<AIStateContainer> stateContainers;

	[NonSerialized]
	public int defaultStateContainer;

	[NonSerialized]
	public string description;

	[NonSerialized]
	public int scope;

	[NonSerialized]
	public int intialViewStateID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AIDesign instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.availableStates != null)
		{
			List<int> list = instance.availableStates;
			Pool.FreeUnmanaged<int>(ref list);
			instance.availableStates = list;
		}
		if (instance.stateContainers != null)
		{
			for (int i = 0; i < instance.stateContainers.Count; i++)
			{
				if (instance.stateContainers[i] != null)
				{
					instance.stateContainers[i].ResetToPool();
					instance.stateContainers[i] = null;
				}
			}
			List<AIStateContainer> list2 = instance.stateContainers;
			Pool.Free<AIStateContainer>(ref list2, false);
			instance.stateContainers = list2;
		}
		instance.defaultStateContainer = 0;
		instance.description = string.Empty;
		instance.scope = 0;
		instance.intialViewStateID = 0;
		Pool.Free<AIDesign>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AIDesign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AIDesign instance)
	{
		if (availableStates != null)
		{
			instance.availableStates = Pool.Get<List<int>>();
			for (int i = 0; i < availableStates.Count; i++)
			{
				int item = availableStates[i];
				instance.availableStates.Add(item);
			}
		}
		else
		{
			instance.availableStates = null;
		}
		if (stateContainers != null)
		{
			instance.stateContainers = Pool.Get<List<AIStateContainer>>();
			for (int j = 0; j < stateContainers.Count; j++)
			{
				AIStateContainer item2 = stateContainers[j].Copy();
				instance.stateContainers.Add(item2);
			}
		}
		else
		{
			instance.stateContainers = null;
		}
		instance.defaultStateContainer = defaultStateContainer;
		instance.description = description;
		instance.scope = scope;
		instance.intialViewStateID = intialViewStateID;
	}

	public AIDesign Copy()
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		CopyTo(aIDesign);
		return aIDesign;
	}

	public static AIDesign Deserialize(BufferStream stream)
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		Deserialize(stream, aIDesign, isDelta: false);
		return aIDesign;
	}

	public static AIDesign DeserializeLengthDelimited(BufferStream stream)
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		DeserializeLengthDelimited(stream, aIDesign, isDelta: false);
		return aIDesign;
	}

	public static AIDesign DeserializeLength(BufferStream stream, int length)
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		DeserializeLength(stream, length, aIDesign, isDelta: false);
		return aIDesign;
	}

	public static AIDesign Deserialize(byte[] buffer)
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, aIDesign, isDelta: false);
		return aIDesign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AIDesign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AIDesign Deserialize(BufferStream stream, AIDesign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.availableStates == null)
			{
				instance.availableStates = Pool.Get<List<int>>();
			}
			if (instance.stateContainers == null)
			{
				instance.stateContainers = Pool.Get<List<AIStateContainer>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.availableStates.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.stateContainers.Add(AIStateContainer.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.defaultStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.description = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.scope = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.intialViewStateID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AIDesign DeserializeLengthDelimited(BufferStream stream, AIDesign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.availableStates == null)
			{
				instance.availableStates = Pool.Get<List<int>>();
			}
			if (instance.stateContainers == null)
			{
				instance.stateContainers = Pool.Get<List<AIStateContainer>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.availableStates.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.stateContainers.Add(AIStateContainer.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.defaultStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.description = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.scope = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.intialViewStateID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AIDesign DeserializeLength(BufferStream stream, int length, AIDesign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.availableStates == null)
			{
				instance.availableStates = Pool.Get<List<int>>();
			}
			if (instance.stateContainers == null)
			{
				instance.stateContainers = Pool.Get<List<AIStateContainer>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.availableStates.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.stateContainers.Add(AIStateContainer.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.defaultStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.description = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.scope = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.intialViewStateID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AIDesign instance, AIDesign previous)
	{
		if (instance.availableStates != null)
		{
			for (int i = 0; i < instance.availableStates.Count; i++)
			{
				int num = instance.availableStates[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.stateContainers != null)
		{
			for (int j = 0; j < instance.stateContainers.Count; j++)
			{
				AIStateContainer aIStateContainer = instance.stateContainers[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				AIStateContainer.SerializeDelta(stream, aIStateContainer, aIStateContainer);
				int num2 = stream.Position - position;
				if (num2 > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stateContainers (ProtoBuf.AIStateContainer)");
				}
				Span<byte> span = range.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
				if (num3 < 3)
				{
					span[num3 - 1] |= 128;
					while (num3 < 2)
					{
						span[num3++] = 128;
					}
					span[2] = 0;
				}
			}
		}
		if (instance.defaultStateContainer != previous.defaultStateContainer)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.defaultStateContainer);
		}
		if (instance.description != null && instance.description != previous.description)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.description);
		}
		if (instance.scope != previous.scope)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scope);
		}
		if (instance.intialViewStateID != previous.intialViewStateID)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.intialViewStateID);
		}
	}

	public static void Serialize(BufferStream stream, AIDesign instance)
	{
		if (instance.availableStates != null)
		{
			for (int i = 0; i < instance.availableStates.Count; i++)
			{
				int num = instance.availableStates[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.stateContainers != null)
		{
			for (int j = 0; j < instance.stateContainers.Count; j++)
			{
				AIStateContainer instance2 = instance.stateContainers[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				AIStateContainer.Serialize(stream, instance2);
				int num2 = stream.Position - position;
				if (num2 > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stateContainers (ProtoBuf.AIStateContainer)");
				}
				Span<byte> span = range.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
				if (num3 < 3)
				{
					span[num3 - 1] |= 128;
					while (num3 < 2)
					{
						span[num3++] = 128;
					}
					span[2] = 0;
				}
			}
		}
		if (instance.defaultStateContainer != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.defaultStateContainer);
		}
		if (instance.description != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.description);
		}
		if (instance.scope != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scope);
		}
		if (instance.intialViewStateID != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.intialViewStateID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (stateContainers != null)
		{
			for (int i = 0; i < stateContainers.Count; i++)
			{
				stateContainers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AIEventData : IDisposable, IPooled, IProto<AIEventData>, IProto
{
	[NonSerialized]
	public int eventType;

	[NonSerialized]
	public int triggerStateContainer;

	[NonSerialized]
	public bool inverted;

	[NonSerialized]
	public int inputMemorySlot;

	[NonSerialized]
	public int outputMemorySlot;

	[NonSerialized]
	public int id;

	[NonSerialized]
	public TimerAIEventData timerData;

	[NonSerialized]
	public PlayerDetectedAIEventData playerDetectedData;

	[NonSerialized]
	public HealthBelowAIEventData healthBelowData;

	[NonSerialized]
	public InRangeAIEventData inRangeData;

	[NonSerialized]
	public HungerAboveAIEventData hungerAboveData;

	[NonSerialized]
	public TirednessAboveAIEventData tirednessAboveData;

	[NonSerialized]
	public ThreatDetectedAIEventData threatDetectedData;

	[NonSerialized]
	public TargetDetectedAIEventData targetDetectedData;

	[NonSerialized]
	public AmmoBelowAIEventData ammoBelowData;

	[NonSerialized]
	public ChanceAIEventData chanceData;

	[NonSerialized]
	public TimeSinceThreatAIEventData timeSinceThreatData;

	[NonSerialized]
	public AggressionTimerAIEventData aggressionTimerData;

	[NonSerialized]
	public InRangeOfHomeAIEventData inRangeOfHomeData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.eventType = 0;
			instance.triggerStateContainer = 0;
			instance.inverted = false;
			instance.inputMemorySlot = 0;
			instance.outputMemorySlot = 0;
			instance.id = 0;
			if (instance.timerData != null)
			{
				instance.timerData.ResetToPool();
				instance.timerData = null;
			}
			if (instance.playerDetectedData != null)
			{
				instance.playerDetectedData.ResetToPool();
				instance.playerDetectedData = null;
			}
			if (instance.healthBelowData != null)
			{
				instance.healthBelowData.ResetToPool();
				instance.healthBelowData = null;
			}
			if (instance.inRangeData != null)
			{
				instance.inRangeData.ResetToPool();
				instance.inRangeData = null;
			}
			if (instance.hungerAboveData != null)
			{
				instance.hungerAboveData.ResetToPool();
				instance.hungerAboveData = null;
			}
			if (instance.tirednessAboveData != null)
			{
				instance.tirednessAboveData.ResetToPool();
				instance.tirednessAboveData = null;
			}
			if (instance.threatDetectedData != null)
			{
				instance.threatDetectedData.ResetToPool();
				instance.threatDetectedData = null;
			}
			if (instance.targetDetectedData != null)
			{
				instance.targetDetectedData.ResetToPool();
				instance.targetDetectedData = null;
			}
			if (instance.ammoBelowData != null)
			{
				instance.ammoBelowData.ResetToPool();
				instance.ammoBelowData = null;
			}
			if (instance.chanceData != null)
			{
				instance.chanceData.ResetToPool();
				instance.chanceData = null;
			}
			if (instance.timeSinceThreatData != null)
			{
				instance.timeSinceThreatData.ResetToPool();
				instance.timeSinceThreatData = null;
			}
			if (instance.aggressionTimerData != null)
			{
				instance.aggressionTimerData.ResetToPool();
				instance.aggressionTimerData = null;
			}
			if (instance.inRangeOfHomeData != null)
			{
				instance.inRangeOfHomeData.ResetToPool();
				instance.inRangeOfHomeData = null;
			}
			Pool.Free<AIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AIEventData instance)
	{
		instance.eventType = eventType;
		instance.triggerStateContainer = triggerStateContainer;
		instance.inverted = inverted;
		instance.inputMemorySlot = inputMemorySlot;
		instance.outputMemorySlot = outputMemorySlot;
		instance.id = id;
		if (timerData != null)
		{
			if (instance.timerData == null)
			{
				instance.timerData = timerData.Copy();
			}
			else
			{
				timerData.CopyTo(instance.timerData);
			}
		}
		else
		{
			instance.timerData = null;
		}
		if (playerDetectedData != null)
		{
			if (instance.playerDetectedData == null)
			{
				instance.playerDetectedData = playerDetectedData.Copy();
			}
			else
			{
				playerDetectedData.CopyTo(instance.playerDetectedData);
			}
		}
		else
		{
			instance.playerDetectedData = null;
		}
		if (healthBelowData != null)
		{
			if (instance.healthBelowData == null)
			{
				instance.healthBelowData = healthBelowData.Copy();
			}
			else
			{
				healthBelowData.CopyTo(instance.healthBelowData);
			}
		}
		else
		{
			instance.healthBelowData = null;
		}
		if (inRangeData != null)
		{
			if (instance.inRangeData == null)
			{
				instance.inRangeData = inRangeData.Copy();
			}
			else
			{
				inRangeData.CopyTo(instance.inRangeData);
			}
		}
		else
		{
			instance.inRangeData = null;
		}
		if (hungerAboveData != null)
		{
			if (instance.hungerAboveData == null)
			{
				instance.hungerAboveData = hungerAboveData.Copy();
			}
			else
			{
				hungerAboveData.CopyTo(instance.hungerAboveData);
			}
		}
		else
		{
			instance.hungerAboveData = null;
		}
		if (tirednessAboveData != null)
		{
			if (instance.tirednessAboveData == null)
			{
				instance.tirednessAboveData = tirednessAboveData.Copy();
			}
			else
			{
				tirednessAboveData.CopyTo(instance.tirednessAboveData);
			}
		}
		else
		{
			instance.tirednessAboveData = null;
		}
		if (threatDetectedData != null)
		{
			if (instance.threatDetectedData == null)
			{
				instance.threatDetectedData = threatDetectedData.Copy();
			}
			else
			{
				threatDetectedData.CopyTo(instance.threatDetectedData);
			}
		}
		else
		{
			instance.threatDetectedData = null;
		}
		if (targetDetectedData != null)
		{
			if (instance.targetDetectedData == null)
			{
				instance.targetDetectedData = targetDetectedData.Copy();
			}
			else
			{
				targetDetectedData.CopyTo(instance.targetDetectedData);
			}
		}
		else
		{
			instance.targetDetectedData = null;
		}
		if (ammoBelowData != null)
		{
			if (instance.ammoBelowData == null)
			{
				instance.ammoBelowData = ammoBelowData.Copy();
			}
			else
			{
				ammoBelowData.CopyTo(instance.ammoBelowData);
			}
		}
		else
		{
			instance.ammoBelowData = null;
		}
		if (chanceData != null)
		{
			if (instance.chanceData == null)
			{
				instance.chanceData = chanceData.Copy();
			}
			else
			{
				chanceData.CopyTo(instance.chanceData);
			}
		}
		else
		{
			instance.chanceData = null;
		}
		if (timeSinceThreatData != null)
		{
			if (instance.timeSinceThreatData == null)
			{
				instance.timeSinceThreatData = timeSinceThreatData.Copy();
			}
			else
			{
				timeSinceThreatData.CopyTo(instance.timeSinceThreatData);
			}
		}
		else
		{
			instance.timeSinceThreatData = null;
		}
		if (aggressionTimerData != null)
		{
			if (instance.aggressionTimerData == null)
			{
				instance.aggressionTimerData = aggressionTimerData.Copy();
			}
			else
			{
				aggressionTimerData.CopyTo(instance.aggressionTimerData);
			}
		}
		else
		{
			instance.aggressionTimerData = null;
		}
		if (inRangeOfHomeData != null)
		{
			if (instance.inRangeOfHomeData == null)
			{
				instance.inRangeOfHomeData = inRangeOfHomeData.Copy();
			}
			else
			{
				inRangeOfHomeData.CopyTo(instance.inRangeOfHomeData);
			}
		}
		else
		{
			instance.inRangeOfHomeData = null;
		}
	}

	public AIEventData Copy()
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		CopyTo(aIEventData);
		return aIEventData;
	}

	public static AIEventData Deserialize(BufferStream stream)
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		Deserialize(stream, aIEventData, isDelta: false);
		return aIEventData;
	}

	public static AIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		DeserializeLengthDelimited(stream, aIEventData, isDelta: false);
		return aIEventData;
	}

	public static AIEventData DeserializeLength(BufferStream stream, int length)
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		DeserializeLength(stream, length, aIEventData, isDelta: false);
		return aIEventData;
	}

	public static AIEventData Deserialize(byte[] buffer)
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, aIEventData, isDelta: false);
		return aIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AIEventData Deserialize(BufferStream stream, AIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.eventType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.triggerStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.inverted = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.outputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timerData == null)
					{
						instance.timerData = TimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimerAIEventData.DeserializeLengthDelimited(stream, instance.timerData, isDelta);
					}
				}
				break;
			case 101u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.playerDetectedData == null)
					{
						instance.playerDetectedData = PlayerDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerDetectedAIEventData.DeserializeLengthDelimited(stream, instance.playerDetectedData, isDelta);
					}
				}
				break;
			case 102u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.healthBelowData == null)
					{
						instance.healthBelowData = HealthBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HealthBelowAIEventData.DeserializeLengthDelimited(stream, instance.healthBelowData, isDelta);
					}
				}
				break;
			case 103u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeData == null)
					{
						instance.inRangeData = InRangeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeData, isDelta);
					}
				}
				break;
			case 104u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.hungerAboveData == null)
					{
						instance.hungerAboveData = HungerAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HungerAboveAIEventData.DeserializeLengthDelimited(stream, instance.hungerAboveData, isDelta);
					}
				}
				break;
			case 105u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.tirednessAboveData == null)
					{
						instance.tirednessAboveData = TirednessAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TirednessAboveAIEventData.DeserializeLengthDelimited(stream, instance.tirednessAboveData, isDelta);
					}
				}
				break;
			case 106u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.threatDetectedData == null)
					{
						instance.threatDetectedData = ThreatDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ThreatDetectedAIEventData.DeserializeLengthDelimited(stream, instance.threatDetectedData, isDelta);
					}
				}
				break;
			case 107u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.targetDetectedData == null)
					{
						instance.targetDetectedData = TargetDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TargetDetectedAIEventData.DeserializeLengthDelimited(stream, instance.targetDetectedData, isDelta);
					}
				}
				break;
			case 108u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.ammoBelowData == null)
					{
						instance.ammoBelowData = AmmoBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AmmoBelowAIEventData.DeserializeLengthDelimited(stream, instance.ammoBelowData, isDelta);
					}
				}
				break;
			case 109u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.chanceData == null)
					{
						instance.chanceData = ChanceAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ChanceAIEventData.DeserializeLengthDelimited(stream, instance.chanceData, isDelta);
					}
				}
				break;
			case 110u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timeSinceThreatData == null)
					{
						instance.timeSinceThreatData = TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream, instance.timeSinceThreatData, isDelta);
					}
				}
				break;
			case 111u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.aggressionTimerData == null)
					{
						instance.aggressionTimerData = AggressionTimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AggressionTimerAIEventData.DeserializeLengthDelimited(stream, instance.aggressionTimerData, isDelta);
					}
				}
				break;
			case 112u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeOfHomeData == null)
					{
						instance.inRangeOfHomeData = InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeOfHomeData, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static AIEventData DeserializeLengthDelimited(BufferStream stream, AIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.eventType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.triggerStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.inverted = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.outputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timerData == null)
					{
						instance.timerData = TimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimerAIEventData.DeserializeLengthDelimited(stream, instance.timerData, isDelta);
					}
				}
				break;
			case 101u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.playerDetectedData == null)
					{
						instance.playerDetectedData = PlayerDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerDetectedAIEventData.DeserializeLengthDelimited(stream, instance.playerDetectedData, isDelta);
					}
				}
				break;
			case 102u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.healthBelowData == null)
					{
						instance.healthBelowData = HealthBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HealthBelowAIEventData.DeserializeLengthDelimited(stream, instance.healthBelowData, isDelta);
					}
				}
				break;
			case 103u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeData == null)
					{
						instance.inRangeData = InRangeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeData, isDelta);
					}
				}
				break;
			case 104u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.hungerAboveData == null)
					{
						instance.hungerAboveData = HungerAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HungerAboveAIEventData.DeserializeLengthDelimited(stream, instance.hungerAboveData, isDelta);
					}
				}
				break;
			case 105u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.tirednessAboveData == null)
					{
						instance.tirednessAboveData = TirednessAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TirednessAboveAIEventData.DeserializeLengthDelimited(stream, instance.tirednessAboveData, isDelta);
					}
				}
				break;
			case 106u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.threatDetectedData == null)
					{
						instance.threatDetectedData = ThreatDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ThreatDetectedAIEventData.DeserializeLengthDelimited(stream, instance.threatDetectedData, isDelta);
					}
				}
				break;
			case 107u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.targetDetectedData == null)
					{
						instance.targetDetectedData = TargetDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TargetDetectedAIEventData.DeserializeLengthDelimited(stream, instance.targetDetectedData, isDelta);
					}
				}
				break;
			case 108u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.ammoBelowData == null)
					{
						instance.ammoBelowData = AmmoBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AmmoBelowAIEventData.DeserializeLengthDelimited(stream, instance.ammoBelowData, isDelta);
					}
				}
				break;
			case 109u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.chanceData == null)
					{
						instance.chanceData = ChanceAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ChanceAIEventData.DeserializeLengthDelimited(stream, instance.chanceData, isDelta);
					}
				}
				break;
			case 110u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timeSinceThreatData == null)
					{
						instance.timeSinceThreatData = TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream, instance.timeSinceThreatData, isDelta);
					}
				}
				break;
			case 111u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.aggressionTimerData == null)
					{
						instance.aggressionTimerData = AggressionTimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AggressionTimerAIEventData.DeserializeLengthDelimited(stream, instance.aggressionTimerData, isDelta);
					}
				}
				break;
			case 112u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeOfHomeData == null)
					{
						instance.inRangeOfHomeData = InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeOfHomeData, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AIEventData DeserializeLength(BufferStream stream, int length, AIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.eventType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.triggerStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.inverted = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.outputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timerData == null)
					{
						instance.timerData = TimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimerAIEventData.DeserializeLengthDelimited(stream, instance.timerData, isDelta);
					}
				}
				break;
			case 101u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.playerDetectedData == null)
					{
						instance.playerDetectedData = PlayerDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerDetectedAIEventData.DeserializeLengthDelimited(stream, instance.playerDetectedData, isDelta);
					}
				}
				break;
			case 102u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.healthBelowData == null)
					{
						instance.healthBelowData = HealthBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HealthBelowAIEventData.DeserializeLengthDelimited(stream, instance.healthBelowData, isDelta);
					}
				}
				break;
			case 103u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeData == null)
					{
						instance.inRangeData = InRangeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeData, isDelta);
					}
				}
				break;
			case 104u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.hungerAboveData == null)
					{
						instance.hungerAboveData = HungerAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HungerAboveAIEventData.DeserializeLengthDelimited(stream, instance.hungerAboveData, isDelta);
					}
				}
				break;
			case 105u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.tirednessAboveData == null)
					{
						instance.tirednessAboveData = TirednessAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TirednessAboveAIEventData.DeserializeLengthDelimited(stream, instance.tirednessAboveData, isDelta);
					}
				}
				break;
			case 106u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.threatDetectedData == null)
					{
						instance.threatDetectedData = ThreatDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ThreatDetectedAIEventData.DeserializeLengthDelimited(stream, instance.threatDetectedData, isDelta);
					}
				}
				break;
			case 107u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.targetDetectedData == null)
					{
						instance.targetDetectedData = TargetDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TargetDetectedAIEventData.DeserializeLengthDelimited(stream, instance.targetDetectedData, isDelta);
					}
				}
				break;
			case 108u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.ammoBelowData == null)
					{
						instance.ammoBelowData = AmmoBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AmmoBelowAIEventData.DeserializeLengthDelimited(stream, instance.ammoBelowData, isDelta);
					}
				}
				break;
			case 109u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.chanceData == null)
					{
						instance.chanceData = ChanceAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ChanceAIEventData.DeserializeLengthDelimited(stream, instance.chanceData, isDelta);
					}
				}
				break;
			case 110u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timeSinceThreatData == null)
					{
						instance.timeSinceThreatData = TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream, instance.timeSinceThreatData, isDelta);
					}
				}
				break;
			case 111u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.aggressionTimerData == null)
					{
						instance.aggressionTimerData = AggressionTimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AggressionTimerAIEventData.DeserializeLengthDelimited(stream, instance.aggressionTimerData, isDelta);
					}
				}
				break;
			case 112u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeOfHomeData == null)
					{
						instance.inRangeOfHomeData = InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeOfHomeData, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AIEventData instance, AIEventData previous)
	{
		if (instance.eventType != previous.eventType)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.eventType);
		}
		if (instance.triggerStateContainer != previous.triggerStateContainer)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.triggerStateContainer);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.inverted);
		if (instance.inputMemorySlot != previous.inputMemorySlot)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputMemorySlot);
		}
		if (instance.outputMemorySlot != previous.outputMemorySlot)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.outputMemorySlot);
		}
		if (instance.id != previous.id)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.id);
		}
		if (instance.timerData != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(6);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			TimerAIEventData.SerializeDelta(stream, instance.timerData, previous.timerData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field timerData (ProtoBuf.TimerAIEventData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.playerDetectedData != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(6);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PlayerDetectedAIEventData.SerializeDelta(stream, instance.playerDetectedData, previous.playerDetectedData);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerDetectedData (ProtoBuf.PlayerDetectedAIEventData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.healthBelowData != null)
		{
			stream.WriteByte(178);
			stream.WriteByte(6);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			HealthBelowAIEventData.SerializeDelta(stream, instance.healthBelowData, previous.healthBelowData);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field healthBelowData (ProtoBuf.HealthBelowAIEventData)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.inRangeData != null)
		{
			stream.WriteByte(186);
			stream.WriteByte(6);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			InRangeAIEventData.SerializeDelta(stream, instance.inRangeData, previous.inRangeData);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inRangeData (ProtoBuf.InRangeAIEventData)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.hungerAboveData != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(6);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			HungerAboveAIEventData.SerializeDelta(stream, instance.hungerAboveData, previous.hungerAboveData);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hungerAboveData (ProtoBuf.HungerAboveAIEventData)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.tirednessAboveData != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(6);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			TirednessAboveAIEventData.SerializeDelta(stream, instance.tirednessAboveData, previous.tirednessAboveData);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field tirednessAboveData (ProtoBuf.TirednessAboveAIEventData)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.threatDetectedData != null)
		{
			stream.WriteByte(210);
			stream.WriteByte(6);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			ThreatDetectedAIEventData.SerializeDelta(stream, instance.threatDetectedData, previous.threatDetectedData);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field threatDetectedData (ProtoBuf.ThreatDetectedAIEventData)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.targetDetectedData != null)
		{
			stream.WriteByte(218);
			stream.WriteByte(6);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			TargetDetectedAIEventData.SerializeDelta(stream, instance.targetDetectedData, previous.targetDetectedData);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetDetectedData (ProtoBuf.TargetDetectedAIEventData)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
		if (instance.ammoBelowData != null)
		{
			stream.WriteByte(226);
			stream.WriteByte(6);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AmmoBelowAIEventData.SerializeDelta(stream, instance.ammoBelowData, previous.ammoBelowData);
			int num9 = stream.Position - position9;
			if (num9 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ammoBelowData (ProtoBuf.AmmoBelowAIEventData)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num9, span9, 0);
		}
		if (instance.chanceData != null)
		{
			stream.WriteByte(234);
			stream.WriteByte(6);
			BufferStream.RangeHandle range10 = stream.GetRange(1);
			int position10 = stream.Position;
			ChanceAIEventData.SerializeDelta(stream, instance.chanceData, previous.chanceData);
			int num10 = stream.Position - position10;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field chanceData (ProtoBuf.ChanceAIEventData)");
			}
			Span<byte> span10 = range10.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		}
		if (instance.timeSinceThreatData != null)
		{
			stream.WriteByte(242);
			stream.WriteByte(6);
			BufferStream.RangeHandle range11 = stream.GetRange(1);
			int position11 = stream.Position;
			TimeSinceThreatAIEventData.SerializeDelta(stream, instance.timeSinceThreatData, previous.timeSinceThreatData);
			int num11 = stream.Position - position11;
			if (num11 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field timeSinceThreatData (ProtoBuf.TimeSinceThreatAIEventData)");
			}
			Span<byte> span11 = range11.GetSpan();
			ProtocolParser.WriteUInt32((uint)num11, span11, 0);
		}
		if (instance.aggressionTimerData != null)
		{
			stream.WriteByte(250);
			stream.WriteByte(6);
			BufferStream.RangeHandle range12 = stream.GetRange(1);
			int position12 = stream.Position;
			AggressionTimerAIEventData.SerializeDelta(stream, instance.aggressionTimerData, previous.aggressionTimerData);
			int num12 = stream.Position - position12;
			if (num12 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aggressionTimerData (ProtoBuf.AggressionTimerAIEventData)");
			}
			Span<byte> span12 = range12.GetSpan();
			ProtocolParser.WriteUInt32((uint)num12, span12, 0);
		}
		if (instance.inRangeOfHomeData != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(7);
			BufferStream.RangeHandle range13 = stream.GetRange(1);
			int position13 = stream.Position;
			InRangeOfHomeAIEventData.SerializeDelta(stream, instance.inRangeOfHomeData, previous.inRangeOfHomeData);
			int num13 = stream.Position - position13;
			if (num13 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inRangeOfHomeData (ProtoBuf.InRangeOfHomeAIEventData)");
			}
			Span<byte> span13 = range13.GetSpan();
			ProtocolParser.WriteUInt32((uint)num13, span13, 0);
		}
	}

	public static void Serialize(BufferStream stream, AIEventData instance)
	{
		if (instance.eventType != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.eventType);
		}
		if (instance.triggerStateContainer != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.triggerStateContainer);
		}
		if (instance.inverted)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.inverted);
		}
		if (instance.inputMemorySlot != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputMemorySlot);
		}
		if (instance.outputMemorySlot != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.outputMemorySlot);
		}
		if (instance.id != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.id);
		}
		if (instance.timerData != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(6);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			TimerAIEventData.Serialize(stream, instance.timerData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field timerData (ProtoBuf.TimerAIEventData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.playerDetectedData != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(6);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PlayerDetectedAIEventData.Serialize(stream, instance.playerDetectedData);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerDetectedData (ProtoBuf.PlayerDetectedAIEventData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.healthBelowData != null)
		{
			stream.WriteByte(178);
			stream.WriteByte(6);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			HealthBelowAIEventData.Serialize(stream, instance.healthBelowData);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field healthBelowData (ProtoBuf.HealthBelowAIEventData)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.inRangeData != null)
		{
			stream.WriteByte(186);
			stream.WriteByte(6);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			InRangeAIEventData.Serialize(stream, instance.inRangeData);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inRangeData (ProtoBuf.InRangeAIEventData)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.hungerAboveData != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(6);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			HungerAboveAIEventData.Serialize(stream, instance.hungerAboveData);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hungerAboveData (ProtoBuf.HungerAboveAIEventData)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.tirednessAboveData != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(6);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			TirednessAboveAIEventData.Serialize(stream, instance.tirednessAboveData);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field tirednessAboveData (ProtoBuf.TirednessAboveAIEventData)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.threatDetectedData != null)
		{
			stream.WriteByte(210);
			stream.WriteByte(6);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			ThreatDetectedAIEventData.Serialize(stream, instance.threatDetectedData);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field threatDetectedData (ProtoBuf.ThreatDetectedAIEventData)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.targetDetectedData != null)
		{
			stream.WriteByte(218);
			stream.WriteByte(6);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			TargetDetectedAIEventData.Serialize(stream, instance.targetDetectedData);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetDetectedData (ProtoBuf.TargetDetectedAIEventData)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
		if (instance.ammoBelowData != null)
		{
			stream.WriteByte(226);
			stream.WriteByte(6);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AmmoBelowAIEventData.Serialize(stream, instance.ammoBelowData);
			int num9 = stream.Position - position9;
			if (num9 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ammoBelowData (ProtoBuf.AmmoBelowAIEventData)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num9, span9, 0);
		}
		if (instance.chanceData != null)
		{
			stream.WriteByte(234);
			stream.WriteByte(6);
			BufferStream.RangeHandle range10 = stream.GetRange(1);
			int position10 = stream.Position;
			ChanceAIEventData.Serialize(stream, instance.chanceData);
			int num10 = stream.Position - position10;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field chanceData (ProtoBuf.ChanceAIEventData)");
			}
			Span<byte> span10 = range10.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		}
		if (instance.timeSinceThreatData != null)
		{
			stream.WriteByte(242);
			stream.WriteByte(6);
			BufferStream.RangeHandle range11 = stream.GetRange(1);
			int position11 = stream.Position;
			TimeSinceThreatAIEventData.Serialize(stream, instance.timeSinceThreatData);
			int num11 = stream.Position - position11;
			if (num11 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field timeSinceThreatData (ProtoBuf.TimeSinceThreatAIEventData)");
			}
			Span<byte> span11 = range11.GetSpan();
			ProtocolParser.WriteUInt32((uint)num11, span11, 0);
		}
		if (instance.aggressionTimerData != null)
		{
			stream.WriteByte(250);
			stream.WriteByte(6);
			BufferStream.RangeHandle range12 = stream.GetRange(1);
			int position12 = stream.Position;
			AggressionTimerAIEventData.Serialize(stream, instance.aggressionTimerData);
			int num12 = stream.Position - position12;
			if (num12 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aggressionTimerData (ProtoBuf.AggressionTimerAIEventData)");
			}
			Span<byte> span12 = range12.GetSpan();
			ProtocolParser.WriteUInt32((uint)num12, span12, 0);
		}
		if (instance.inRangeOfHomeData != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(7);
			BufferStream.RangeHandle range13 = stream.GetRange(1);
			int position13 = stream.Position;
			InRangeOfHomeAIEventData.Serialize(stream, instance.inRangeOfHomeData);
			int num13 = stream.Position - position13;
			if (num13 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inRangeOfHomeData (ProtoBuf.InRangeOfHomeAIEventData)");
			}
			Span<byte> span13 = range13.GetSpan();
			ProtocolParser.WriteUInt32((uint)num13, span13, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		timerData?.InspectUids(action);
		playerDetectedData?.InspectUids(action);
		healthBelowData?.InspectUids(action);
		inRangeData?.InspectUids(action);
		hungerAboveData?.InspectUids(action);
		tirednessAboveData?.InspectUids(action);
		threatDetectedData?.InspectUids(action);
		targetDetectedData?.InspectUids(action);
		ammoBelowData?.InspectUids(action);
		chanceData?.InspectUids(action);
		timeSinceThreatData?.InspectUids(action);
		aggressionTimerData?.InspectUids(action);
		inRangeOfHomeData?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AIStateContainer : IDisposable, IPooled, IProto<AIStateContainer>, IProto
{
	[NonSerialized]
	public int id;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public List<AIEventData> events;

	[NonSerialized]
	public int inputMemorySlot;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AIStateContainer instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.id = 0;
		instance.state = 0;
		if (instance.events != null)
		{
			for (int i = 0; i < instance.events.Count; i++)
			{
				if (instance.events[i] != null)
				{
					instance.events[i].ResetToPool();
					instance.events[i] = null;
				}
			}
			List<AIEventData> list = instance.events;
			Pool.Free<AIEventData>(ref list, false);
			instance.events = list;
		}
		instance.inputMemorySlot = 0;
		Pool.Free<AIStateContainer>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AIStateContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AIStateContainer instance)
	{
		instance.id = id;
		instance.state = state;
		if (events != null)
		{
			instance.events = Pool.Get<List<AIEventData>>();
			for (int i = 0; i < events.Count; i++)
			{
				AIEventData item = events[i].Copy();
				instance.events.Add(item);
			}
		}
		else
		{
			instance.events = null;
		}
		instance.inputMemorySlot = inputMemorySlot;
	}

	public AIStateContainer Copy()
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		CopyTo(aIStateContainer);
		return aIStateContainer;
	}

	public static AIStateContainer Deserialize(BufferStream stream)
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		Deserialize(stream, aIStateContainer, isDelta: false);
		return aIStateContainer;
	}

	public static AIStateContainer DeserializeLengthDelimited(BufferStream stream)
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		DeserializeLengthDelimited(stream, aIStateContainer, isDelta: false);
		return aIStateContainer;
	}

	public static AIStateContainer DeserializeLength(BufferStream stream, int length)
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		DeserializeLength(stream, length, aIStateContainer, isDelta: false);
		return aIStateContainer;
	}

	public static AIStateContainer Deserialize(byte[] buffer)
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, aIStateContainer, isDelta: false);
		return aIStateContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AIStateContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AIStateContainer Deserialize(BufferStream stream, AIStateContainer instance, bool isDelta)
	{
		if (!isDelta && instance.events == null)
		{
			instance.events = Pool.Get<List<AIEventData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.events.Add(AIEventData.DeserializeLengthDelimited(stream));
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AIStateContainer DeserializeLengthDelimited(BufferStream stream, AIStateContainer instance, bool isDelta)
	{
		if (!isDelta && instance.events == null)
		{
			instance.events = Pool.Get<List<AIEventData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.events.Add(AIEventData.DeserializeLengthDelimited(stream));
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AIStateContainer DeserializeLength(BufferStream stream, int length, AIStateContainer instance, bool isDelta)
	{
		if (!isDelta && instance.events == null)
		{
			instance.events = Pool.Get<List<AIEventData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.events.Add(AIEventData.DeserializeLengthDelimited(stream));
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AIStateContainer instance, AIStateContainer previous)
	{
		if (instance.id != previous.id)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.id);
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.events != null)
		{
			for (int i = 0; i < instance.events.Count; i++)
			{
				AIEventData aIEventData = instance.events[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(2);
				int position = stream.Position;
				AIEventData.SerializeDelta(stream, aIEventData, aIEventData);
				int num = stream.Position - position;
				if (num > 16383)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field events (ProtoBuf.AIEventData)");
				}
				Span<byte> span = range.GetSpan();
				if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
				{
					span[0] |= 128;
					span[1] = 0;
				}
			}
		}
		if (instance.inputMemorySlot != previous.inputMemorySlot)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputMemorySlot);
		}
	}

	public static void Serialize(BufferStream stream, AIStateContainer instance)
	{
		if (instance.id != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.id);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.events != null)
		{
			for (int i = 0; i < instance.events.Count; i++)
			{
				AIEventData instance2 = instance.events[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(2);
				int position = stream.Position;
				AIEventData.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 16383)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field events (ProtoBuf.AIEventData)");
				}
				Span<byte> span = range.GetSpan();
				if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
				{
					span[0] |= 128;
					span[1] = 0;
				}
			}
		}
		if (instance.inputMemorySlot != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputMemorySlot);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (events != null)
		{
			for (int i = 0; i < events.Count; i++)
			{
				events[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AmmoBelowAIEventData : IDisposable, IPooled, IProto<AmmoBelowAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AmmoBelowAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<AmmoBelowAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AmmoBelowAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AmmoBelowAIEventData instance)
	{
		instance.value = value;
	}

	public AmmoBelowAIEventData Copy()
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		CopyTo(ammoBelowAIEventData);
		return ammoBelowAIEventData;
	}

	public static AmmoBelowAIEventData Deserialize(BufferStream stream)
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		Deserialize(stream, ammoBelowAIEventData, isDelta: false);
		return ammoBelowAIEventData;
	}

	public static AmmoBelowAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		DeserializeLengthDelimited(stream, ammoBelowAIEventData, isDelta: false);
		return ammoBelowAIEventData;
	}

	public static AmmoBelowAIEventData DeserializeLength(BufferStream stream, int length)
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		DeserializeLength(stream, length, ammoBelowAIEventData, isDelta: false);
		return ammoBelowAIEventData;
	}

	public static AmmoBelowAIEventData Deserialize(byte[] buffer)
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ammoBelowAIEventData, isDelta: false);
		return ammoBelowAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AmmoBelowAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AmmoBelowAIEventData Deserialize(BufferStream stream, AmmoBelowAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AmmoBelowAIEventData DeserializeLengthDelimited(BufferStream stream, AmmoBelowAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AmmoBelowAIEventData DeserializeLength(BufferStream stream, int length, AmmoBelowAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AmmoBelowAIEventData instance, AmmoBelowAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, AmmoBelowAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppBroadcast : IDisposable, IPooled, IProto<AppBroadcast>, IProto
{
	[NonSerialized]
	public AppTeamChanged teamChanged;

	[NonSerialized]
	public AppNewTeamMessage teamMessage;

	[NonSerialized]
	public AppEntityChanged entityChanged;

	[NonSerialized]
	public AppClanChanged clanChanged;

	[NonSerialized]
	public AppNewClanMessage clanMessage;

	[NonSerialized]
	public AppCameraRays cameraRays;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppBroadcast instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.teamChanged != null)
			{
				instance.teamChanged.ResetToPool();
				instance.teamChanged = null;
			}
			if (instance.teamMessage != null)
			{
				instance.teamMessage.ResetToPool();
				instance.teamMessage = null;
			}
			if (instance.entityChanged != null)
			{
				instance.entityChanged.ResetToPool();
				instance.entityChanged = null;
			}
			if (instance.clanChanged != null)
			{
				instance.clanChanged.ResetToPool();
				instance.clanChanged = null;
			}
			if (instance.clanMessage != null)
			{
				instance.clanMessage.ResetToPool();
				instance.clanMessage = null;
			}
			if (instance.cameraRays != null)
			{
				instance.cameraRays.ResetToPool();
				instance.cameraRays = null;
			}
			Pool.Free<AppBroadcast>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppBroadcast with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppBroadcast instance)
	{
		if (teamChanged != null)
		{
			if (instance.teamChanged == null)
			{
				instance.teamChanged = teamChanged.Copy();
			}
			else
			{
				teamChanged.CopyTo(instance.teamChanged);
			}
		}
		else
		{
			instance.teamChanged = null;
		}
		if (teamMessage != null)
		{
			if (instance.teamMessage == null)
			{
				instance.teamMessage = teamMessage.Copy();
			}
			else
			{
				teamMessage.CopyTo(instance.teamMessage);
			}
		}
		else
		{
			instance.teamMessage = null;
		}
		if (entityChanged != null)
		{
			if (instance.entityChanged == null)
			{
				instance.entityChanged = entityChanged.Copy();
			}
			else
			{
				entityChanged.CopyTo(instance.entityChanged);
			}
		}
		else
		{
			instance.entityChanged = null;
		}
		if (clanChanged != null)
		{
			if (instance.clanChanged == null)
			{
				instance.clanChanged = clanChanged.Copy();
			}
			else
			{
				clanChanged.CopyTo(instance.clanChanged);
			}
		}
		else
		{
			instance.clanChanged = null;
		}
		if (clanMessage != null)
		{
			if (instance.clanMessage == null)
			{
				instance.clanMessage = clanMessage.Copy();
			}
			else
			{
				clanMessage.CopyTo(instance.clanMessage);
			}
		}
		else
		{
			instance.clanMessage = null;
		}
		if (cameraRays != null)
		{
			if (instance.cameraRays == null)
			{
				instance.cameraRays = cameraRays.Copy();
			}
			else
			{
				cameraRays.CopyTo(instance.cameraRays);
			}
		}
		else
		{
			instance.cameraRays = null;
		}
	}

	public AppBroadcast Copy()
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		CopyTo(appBroadcast);
		return appBroadcast;
	}

	public static AppBroadcast Deserialize(BufferStream stream)
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		Deserialize(stream, appBroadcast, isDelta: false);
		return appBroadcast;
	}

	public static AppBroadcast DeserializeLengthDelimited(BufferStream stream)
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		DeserializeLengthDelimited(stream, appBroadcast, isDelta: false);
		return appBroadcast;
	}

	public static AppBroadcast DeserializeLength(BufferStream stream, int length)
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		DeserializeLength(stream, length, appBroadcast, isDelta: false);
		return appBroadcast;
	}

	public static AppBroadcast Deserialize(byte[] buffer)
	{
		AppBroadcast appBroadcast = Pool.Get<AppBroadcast>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appBroadcast, isDelta: false);
		return appBroadcast;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppBroadcast previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppBroadcast Deserialize(BufferStream stream, AppBroadcast instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 34:
				if (instance.teamChanged == null)
				{
					instance.teamChanged = AppTeamChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChanged.DeserializeLengthDelimited(stream, instance.teamChanged, isDelta);
				}
				break;
			case 42:
				if (instance.teamMessage == null)
				{
					instance.teamMessage = AppNewTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewTeamMessage.DeserializeLengthDelimited(stream, instance.teamMessage, isDelta);
				}
				break;
			case 50:
				if (instance.entityChanged == null)
				{
					instance.entityChanged = AppEntityChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityChanged.DeserializeLengthDelimited(stream, instance.entityChanged, isDelta);
				}
				break;
			case 58:
				if (instance.clanChanged == null)
				{
					instance.clanChanged = AppClanChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanChanged.DeserializeLengthDelimited(stream, instance.clanChanged, isDelta);
				}
				break;
			case 66:
				if (instance.clanMessage == null)
				{
					instance.clanMessage = AppNewClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewClanMessage.DeserializeLengthDelimited(stream, instance.clanMessage, isDelta);
				}
				break;
			case 82:
				if (instance.cameraRays == null)
				{
					instance.cameraRays = AppCameraRays.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppCameraRays.DeserializeLengthDelimited(stream, instance.cameraRays, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppBroadcast DeserializeLengthDelimited(BufferStream stream, AppBroadcast instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 34:
				if (instance.teamChanged == null)
				{
					instance.teamChanged = AppTeamChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChanged.DeserializeLengthDelimited(stream, instance.teamChanged, isDelta);
				}
				break;
			case 42:
				if (instance.teamMessage == null)
				{
					instance.teamMessage = AppNewTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewTeamMessage.DeserializeLengthDelimited(stream, instance.teamMessage, isDelta);
				}
				break;
			case 50:
				if (instance.entityChanged == null)
				{
					instance.entityChanged = AppEntityChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityChanged.DeserializeLengthDelimited(stream, instance.entityChanged, isDelta);
				}
				break;
			case 58:
				if (instance.clanChanged == null)
				{
					instance.clanChanged = AppClanChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanChanged.DeserializeLengthDelimited(stream, instance.clanChanged, isDelta);
				}
				break;
			case 66:
				if (instance.clanMessage == null)
				{
					instance.clanMessage = AppNewClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewClanMessage.DeserializeLengthDelimited(stream, instance.clanMessage, isDelta);
				}
				break;
			case 82:
				if (instance.cameraRays == null)
				{
					instance.cameraRays = AppCameraRays.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppCameraRays.DeserializeLengthDelimited(stream, instance.cameraRays, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppBroadcast DeserializeLength(BufferStream stream, int length, AppBroadcast instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 34:
				if (instance.teamChanged == null)
				{
					instance.teamChanged = AppTeamChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChanged.DeserializeLengthDelimited(stream, instance.teamChanged, isDelta);
				}
				break;
			case 42:
				if (instance.teamMessage == null)
				{
					instance.teamMessage = AppNewTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewTeamMessage.DeserializeLengthDelimited(stream, instance.teamMessage, isDelta);
				}
				break;
			case 50:
				if (instance.entityChanged == null)
				{
					instance.entityChanged = AppEntityChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityChanged.DeserializeLengthDelimited(stream, instance.entityChanged, isDelta);
				}
				break;
			case 58:
				if (instance.clanChanged == null)
				{
					instance.clanChanged = AppClanChanged.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanChanged.DeserializeLengthDelimited(stream, instance.clanChanged, isDelta);
				}
				break;
			case 66:
				if (instance.clanMessage == null)
				{
					instance.clanMessage = AppNewClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppNewClanMessage.DeserializeLengthDelimited(stream, instance.clanMessage, isDelta);
				}
				break;
			case 82:
				if (instance.cameraRays == null)
				{
					instance.cameraRays = AppCameraRays.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppCameraRays.DeserializeLengthDelimited(stream, instance.cameraRays, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppBroadcast instance, AppBroadcast previous)
	{
		if (instance.teamChanged != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppTeamChanged.SerializeDelta(stream, instance.teamChanged, previous.teamChanged);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.teamMessage != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			AppNewTeamMessage.SerializeDelta(stream, instance.teamMessage, previous.teamMessage);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.entityChanged != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(3);
			int position3 = stream.Position;
			AppEntityChanged.SerializeDelta(stream, instance.entityChanged, previous.entityChanged);
			int num3 = stream.Position - position3;
			if (num3 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entityChanged (ProtoBuf.AppEntityChanged)");
			}
			Span<byte> span3 = range3.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			if (num4 < 3)
			{
				span3[num4 - 1] |= 128;
				while (num4 < 2)
				{
					span3[num4++] = 128;
				}
				span3[2] = 0;
			}
		}
		if (instance.clanChanged != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			AppClanChanged.SerializeDelta(stream, instance.clanChanged, previous.clanChanged);
			int val3 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)val3, span4, 0);
			if (num5 < 5)
			{
				span4[num5 - 1] |= 128;
				while (num5 < 4)
				{
					span4[num5++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.clanMessage != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			AppNewClanMessage.SerializeDelta(stream, instance.clanMessage, previous.clanMessage);
			int val4 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val4, span5, 0);
			if (num6 < 5)
			{
				span5[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span5[num6++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.cameraRays == null)
		{
			return;
		}
		stream.WriteByte(82);
		BufferStream.RangeHandle range6 = stream.GetRange(5);
		int position6 = stream.Position;
		AppCameraRays.SerializeDelta(stream, instance.cameraRays, previous.cameraRays);
		int val5 = stream.Position - position6;
		Span<byte> span6 = range6.GetSpan();
		int num7 = ProtocolParser.WriteUInt32((uint)val5, span6, 0);
		if (num7 < 5)
		{
			span6[num7 - 1] |= 128;
			while (num7 < 4)
			{
				span6[num7++] = 128;
			}
			span6[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppBroadcast instance)
	{
		if (instance.teamChanged != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppTeamChanged.Serialize(stream, instance.teamChanged);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.teamMessage != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			AppNewTeamMessage.Serialize(stream, instance.teamMessage);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.entityChanged != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(3);
			int position3 = stream.Position;
			AppEntityChanged.Serialize(stream, instance.entityChanged);
			int num3 = stream.Position - position3;
			if (num3 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entityChanged (ProtoBuf.AppEntityChanged)");
			}
			Span<byte> span3 = range3.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			if (num4 < 3)
			{
				span3[num4 - 1] |= 128;
				while (num4 < 2)
				{
					span3[num4++] = 128;
				}
				span3[2] = 0;
			}
		}
		if (instance.clanChanged != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			AppClanChanged.Serialize(stream, instance.clanChanged);
			int val3 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)val3, span4, 0);
			if (num5 < 5)
			{
				span4[num5 - 1] |= 128;
				while (num5 < 4)
				{
					span4[num5++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.clanMessage != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			AppNewClanMessage.Serialize(stream, instance.clanMessage);
			int val4 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val4, span5, 0);
			if (num6 < 5)
			{
				span5[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span5[num6++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.cameraRays == null)
		{
			return;
		}
		stream.WriteByte(82);
		BufferStream.RangeHandle range6 = stream.GetRange(5);
		int position6 = stream.Position;
		AppCameraRays.Serialize(stream, instance.cameraRays);
		int val5 = stream.Position - position6;
		Span<byte> span6 = range6.GetSpan();
		int num7 = ProtocolParser.WriteUInt32((uint)val5, span6, 0);
		if (num7 < 5)
		{
			span6[num7 - 1] |= 128;
			while (num7 < 4)
			{
				span6[num7++] = 128;
			}
			span6[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		teamChanged?.InspectUids(action);
		teamMessage?.InspectUids(action);
		entityChanged?.InspectUids(action);
		clanChanged?.InspectUids(action);
		clanMessage?.InspectUids(action);
		cameraRays?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppCameraInfo : IDisposable, IPooled, IProto<AppCameraInfo>, IProto
{
	[NonSerialized]
	public int width;

	[NonSerialized]
	public int height;

	[NonSerialized]
	public float nearPlane;

	[NonSerialized]
	public float farPlane;

	[NonSerialized]
	public int controlFlags;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppCameraInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.width = 0;
			instance.height = 0;
			instance.nearPlane = 0f;
			instance.farPlane = 0f;
			instance.controlFlags = 0;
			Pool.Free<AppCameraInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppCameraInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppCameraInfo instance)
	{
		instance.width = width;
		instance.height = height;
		instance.nearPlane = nearPlane;
		instance.farPlane = farPlane;
		instance.controlFlags = controlFlags;
	}

	public AppCameraInfo Copy()
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		CopyTo(appCameraInfo);
		return appCameraInfo;
	}

	public static AppCameraInfo Deserialize(BufferStream stream)
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		Deserialize(stream, appCameraInfo, isDelta: false);
		return appCameraInfo;
	}

	public static AppCameraInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		DeserializeLengthDelimited(stream, appCameraInfo, isDelta: false);
		return appCameraInfo;
	}

	public static AppCameraInfo DeserializeLength(BufferStream stream, int length)
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		DeserializeLength(stream, length, appCameraInfo, isDelta: false);
		return appCameraInfo;
	}

	public static AppCameraInfo Deserialize(byte[] buffer)
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appCameraInfo, isDelta: false);
		return appCameraInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppCameraInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppCameraInfo Deserialize(BufferStream stream, AppCameraInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0;
			instance.height = 0;
			instance.nearPlane = 0f;
			instance.farPlane = 0f;
			instance.controlFlags = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.width = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.height = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.nearPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.farPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.controlFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppCameraInfo DeserializeLengthDelimited(BufferStream stream, AppCameraInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0;
			instance.height = 0;
			instance.nearPlane = 0f;
			instance.farPlane = 0f;
			instance.controlFlags = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.width = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.height = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.nearPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.farPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.controlFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppCameraInfo DeserializeLength(BufferStream stream, int length, AppCameraInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0;
			instance.height = 0;
			instance.nearPlane = 0f;
			instance.farPlane = 0f;
			instance.controlFlags = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.width = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.height = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.nearPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.farPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.controlFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppCameraInfo instance, AppCameraInfo previous)
	{
		if (instance.width != previous.width)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.width);
		}
		if (instance.height != previous.height)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.height);
		}
		if (instance.nearPlane != previous.nearPlane)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.nearPlane);
		}
		if (instance.farPlane != previous.farPlane)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.farPlane);
		}
		if (instance.controlFlags != previous.controlFlags)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.controlFlags);
		}
	}

	public static void Serialize(BufferStream stream, AppCameraInfo instance)
	{
		if (instance.width != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.width);
		}
		if (instance.height != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.height);
		}
		if (instance.nearPlane != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.nearPlane);
		}
		if (instance.farPlane != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.farPlane);
		}
		if (instance.controlFlags != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.controlFlags);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class AppCameraInput : IDisposable, IPooled, IProto<AppCameraInput>, IProto
{
	[NonSerialized]
	public int buttons;

	[NonSerialized]
	public Vector2 mouseDelta;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppCameraInput instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.buttons = 0;
			instance.mouseDelta = default(Vector2);
			Pool.Free<AppCameraInput>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppCameraInput with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppCameraInput instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.buttons = buttons;
		instance.mouseDelta = mouseDelta;
	}

	public AppCameraInput Copy()
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		CopyTo(appCameraInput);
		return appCameraInput;
	}

	public static AppCameraInput Deserialize(BufferStream stream)
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		Deserialize(stream, appCameraInput, isDelta: false);
		return appCameraInput;
	}

	public static AppCameraInput DeserializeLengthDelimited(BufferStream stream)
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		DeserializeLengthDelimited(stream, appCameraInput, isDelta: false);
		return appCameraInput;
	}

	public static AppCameraInput DeserializeLength(BufferStream stream, int length)
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		DeserializeLength(stream, length, appCameraInput, isDelta: false);
		return appCameraInput;
	}

	public static AppCameraInput Deserialize(byte[] buffer)
	{
		AppCameraInput appCameraInput = Pool.Get<AppCameraInput>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appCameraInput, isDelta: false);
		return appCameraInput;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppCameraInput previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppCameraInput Deserialize(BufferStream stream, AppCameraInput instance, bool isDelta)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.buttons = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppCameraInput DeserializeLengthDelimited(BufferStream stream, AppCameraInput instance, bool isDelta)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.buttons = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppCameraInput DeserializeLength(BufferStream stream, int length, AppCameraInput instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.buttons = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.buttons = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.mouseDelta, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppCameraInput instance, AppCameraInput previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.buttons != previous.buttons)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.buttons);
		}
		if (instance.mouseDelta != previous.mouseDelta)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector2Serialized.SerializeDelta(stream, instance.mouseDelta, previous.mouseDelta);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mouseDelta (UnityEngine.Vector2)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, AppCameraInput instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.buttons != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.buttons);
		}
		if (instance.mouseDelta != default(Vector2))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector2Serialized.Serialize(stream, instance.mouseDelta);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mouseDelta (UnityEngine.Vector2)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class AppCameraRays : IDisposable, IPooled, IProto<AppCameraRays>, IProto
{
	public enum EntityType
	{
		Tree = 1,
		Player
	}

	public class Entity : IDisposable, IPooled, IProto<Entity>, IProto
	{
		[NonSerialized]
		public NetworkableId entityId;

		[NonSerialized]
		public EntityType type;

		[NonSerialized]
		public Vector3 position;

		[NonSerialized]
		public Vector3 rotation;

		[NonSerialized]
		public Vector3 size;

		[NonSerialized]
		public string name;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Entity instance)
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.entityId = default(NetworkableId);
				instance.type = (EntityType)0;
				instance.position = default(Vector3);
				instance.rotation = default(Vector3);
				instance.size = default(Vector3);
				instance.name = string.Empty;
				Pool.Free<Entity>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Entity with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Entity instance)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			instance.entityId = entityId;
			instance.type = type;
			instance.position = position;
			instance.rotation = rotation;
			instance.size = size;
			instance.name = name;
		}

		public Entity Copy()
		{
			Entity entity = Pool.Get<Entity>();
			CopyTo(entity);
			return entity;
		}

		public static Entity Deserialize(BufferStream stream)
		{
			Entity entity = Pool.Get<Entity>();
			Deserialize(stream, entity, isDelta: false);
			return entity;
		}

		public static Entity DeserializeLengthDelimited(BufferStream stream)
		{
			Entity entity = Pool.Get<Entity>();
			DeserializeLengthDelimited(stream, entity, isDelta: false);
			return entity;
		}

		public static Entity DeserializeLength(BufferStream stream, int length)
		{
			Entity entity = Pool.Get<Entity>();
			DeserializeLength(stream, length, entity, isDelta: false);
			return entity;
		}

		public static Entity Deserialize(byte[] buffer)
		{
			Entity entity = Pool.Get<Entity>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, entity, isDelta: false);
			return entity;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Entity previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Entity Deserialize(BufferStream stream, Entity instance, bool isDelta)
		{
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
					continue;
				case 50:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Entity DeserializeLengthDelimited(BufferStream stream, Entity instance, bool isDelta)
		{
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
					continue;
				case 50:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Entity DeserializeLength(BufferStream stream, int length, Entity instance, bool isDelta)
		{
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
					continue;
				case 50:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Entity instance, Entity previous)
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			if (instance.position != previous.position)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.rotation != previous.rotation)
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.rotation, previous.rotation);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
			if (instance.size != previous.size)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int num5 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.size, previous.size);
				int num6 = stream.Position - num5;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span3, 0);
			}
			if (instance.name != null && instance.name != previous.name)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.name);
			}
		}

		public static void Serialize(BufferStream stream, Entity instance)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_013d: Unknown result type (might be due to invalid IL or missing references)
			if (instance.entityId != default(NetworkableId))
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
			}
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			if (instance.position != default(Vector3))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.Serialize(stream, instance.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.rotation != default(Vector3))
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.rotation);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
			if (instance.size != default(Vector3))
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int num5 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.size);
				int num6 = stream.Position - num5;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span3, 0);
			}
			if (instance.name != null)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.name);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref entityId.Value);
		}
	}

	[NonSerialized]
	public float verticalFov;

	[NonSerialized]
	public int sampleOffset;

	[NonSerialized]
	public ArraySegment<byte> rayData;

	[NonSerialized]
	public float distance;

	[NonSerialized]
	public List<Entity> entities;

	[NonSerialized]
	public float timeOfDay;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppCameraRays instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.verticalFov = 0f;
		instance.sampleOffset = 0;
		if (instance.rayData.Array != null)
		{
			BufferStream.Shared.ArrayPool.Return(instance.rayData.Array);
		}
		instance.rayData = default(ArraySegment<byte>);
		instance.distance = 0f;
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				if (instance.entities[i] != null)
				{
					instance.entities[i].ResetToPool();
					instance.entities[i] = null;
				}
			}
			List<Entity> list = instance.entities;
			Pool.Free<Entity>(ref list, false);
			instance.entities = list;
		}
		instance.timeOfDay = 0f;
		Pool.Free<AppCameraRays>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppCameraRays with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppCameraRays instance)
	{
		instance.verticalFov = verticalFov;
		instance.sampleOffset = sampleOffset;
		if (rayData.Array == null)
		{
			instance.rayData = default(ArraySegment<byte>);
		}
		else
		{
			byte[] array = BufferStream.Shared.ArrayPool.Rent(rayData.Count);
			Array.Copy(rayData.Array, 0, array, 0, rayData.Count);
			instance.rayData = new ArraySegment<byte>(array, 0, rayData.Count);
		}
		instance.distance = distance;
		if (entities != null)
		{
			instance.entities = Pool.Get<List<Entity>>();
			for (int i = 0; i < entities.Count; i++)
			{
				Entity item = entities[i].Copy();
				instance.entities.Add(item);
			}
		}
		else
		{
			instance.entities = null;
		}
		instance.timeOfDay = timeOfDay;
	}

	public AppCameraRays Copy()
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		CopyTo(appCameraRays);
		return appCameraRays;
	}

	public static AppCameraRays Deserialize(BufferStream stream)
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		Deserialize(stream, appCameraRays, isDelta: false);
		return appCameraRays;
	}

	public static AppCameraRays DeserializeLengthDelimited(BufferStream stream)
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		DeserializeLengthDelimited(stream, appCameraRays, isDelta: false);
		return appCameraRays;
	}

	public static AppCameraRays DeserializeLength(BufferStream stream, int length)
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		DeserializeLength(stream, length, appCameraRays, isDelta: false);
		return appCameraRays;
	}

	public static AppCameraRays Deserialize(byte[] buffer)
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appCameraRays, isDelta: false);
		return appCameraRays;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppCameraRays previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppCameraRays Deserialize(BufferStream stream, AppCameraRays instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.verticalFov = 0f;
			instance.sampleOffset = 0;
			instance.distance = 0f;
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			instance.timeOfDay = 1f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.verticalFov = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.sampleOffset = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.rayData = ProtocolParser.ReadPooledBytes(stream);
				continue;
			case 37:
				instance.distance = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.timeOfDay = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppCameraRays DeserializeLengthDelimited(BufferStream stream, AppCameraRays instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.verticalFov = 0f;
			instance.sampleOffset = 0;
			instance.distance = 0f;
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			instance.timeOfDay = 1f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.verticalFov = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.sampleOffset = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.rayData = ProtocolParser.ReadPooledBytes(stream);
				continue;
			case 37:
				instance.distance = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.timeOfDay = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppCameraRays DeserializeLength(BufferStream stream, int length, AppCameraRays instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.verticalFov = 0f;
			instance.sampleOffset = 0;
			instance.distance = 0f;
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			instance.timeOfDay = 1f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.verticalFov = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.sampleOffset = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.rayData = ProtocolParser.ReadPooledBytes(stream);
				continue;
			case 37:
				instance.distance = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.timeOfDay = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppCameraRays instance, AppCameraRays previous)
	{
		if (instance.verticalFov != previous.verticalFov)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.verticalFov);
		}
		if (instance.sampleOffset != previous.sampleOffset)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sampleOffset);
		}
		if (instance.rayData.Array == null)
		{
			throw new ArgumentNullException("rayData", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WritePooledBytes(stream, instance.rayData);
		if (instance.distance != previous.distance)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.distance);
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				Entity entity = instance.entities[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Entity.SerializeDelta(stream, entity, entity);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.timeOfDay != previous.timeOfDay)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.timeOfDay);
		}
	}

	public static void Serialize(BufferStream stream, AppCameraRays instance)
	{
		if (instance.verticalFov != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.verticalFov);
		}
		if (instance.sampleOffset != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sampleOffset);
		}
		if (instance.rayData.Array == null)
		{
			throw new ArgumentNullException("rayData", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WritePooledBytes(stream, instance.rayData);
		if (instance.distance != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.distance);
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				Entity instance2 = instance.entities[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Entity.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.timeOfDay != 1f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.timeOfDay);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entities != null)
		{
			for (int i = 0; i < entities.Count; i++)
			{
				entities[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppCameraSubscribe : IDisposable, IPooled, IProto<AppCameraSubscribe>, IProto
{
	[NonSerialized]
	public string cameraId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppCameraSubscribe instance)
	{
		if (instance.ShouldPool)
		{
			instance.cameraId = string.Empty;
			Pool.Free<AppCameraSubscribe>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppCameraSubscribe with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppCameraSubscribe instance)
	{
		instance.cameraId = cameraId;
	}

	public AppCameraSubscribe Copy()
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		CopyTo(appCameraSubscribe);
		return appCameraSubscribe;
	}

	public static AppCameraSubscribe Deserialize(BufferStream stream)
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		Deserialize(stream, appCameraSubscribe, isDelta: false);
		return appCameraSubscribe;
	}

	public static AppCameraSubscribe DeserializeLengthDelimited(BufferStream stream)
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		DeserializeLengthDelimited(stream, appCameraSubscribe, isDelta: false);
		return appCameraSubscribe;
	}

	public static AppCameraSubscribe DeserializeLength(BufferStream stream, int length)
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		DeserializeLength(stream, length, appCameraSubscribe, isDelta: false);
		return appCameraSubscribe;
	}

	public static AppCameraSubscribe Deserialize(byte[] buffer)
	{
		AppCameraSubscribe appCameraSubscribe = Pool.Get<AppCameraSubscribe>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appCameraSubscribe, isDelta: false);
		return appCameraSubscribe;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppCameraSubscribe previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppCameraSubscribe Deserialize(BufferStream stream, AppCameraSubscribe instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.cameraId = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppCameraSubscribe DeserializeLengthDelimited(BufferStream stream, AppCameraSubscribe instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.cameraId = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppCameraSubscribe DeserializeLength(BufferStream stream, int length, AppCameraSubscribe instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.cameraId = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppCameraSubscribe instance, AppCameraSubscribe previous)
	{
		if (instance.cameraId != previous.cameraId)
		{
			if (instance.cameraId == null)
			{
				throw new ArgumentNullException("cameraId", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.cameraId);
		}
	}

	public static void Serialize(BufferStream stream, AppCameraSubscribe instance)
	{
		if (instance.cameraId == null)
		{
			throw new ArgumentNullException("cameraId", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.cameraId);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppClanChanged : IDisposable, IPooled, IProto<AppClanChanged>, IProto
{
	[NonSerialized]
	public ClanInfo clanInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppClanChanged instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.clanInfo != null)
			{
				instance.clanInfo.ResetToPool();
				instance.clanInfo = null;
			}
			Pool.Free<AppClanChanged>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppClanChanged with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppClanChanged instance)
	{
		if (clanInfo != null)
		{
			if (instance.clanInfo == null)
			{
				instance.clanInfo = clanInfo.Copy();
			}
			else
			{
				clanInfo.CopyTo(instance.clanInfo);
			}
		}
		else
		{
			instance.clanInfo = null;
		}
	}

	public AppClanChanged Copy()
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		CopyTo(appClanChanged);
		return appClanChanged;
	}

	public static AppClanChanged Deserialize(BufferStream stream)
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		Deserialize(stream, appClanChanged, isDelta: false);
		return appClanChanged;
	}

	public static AppClanChanged DeserializeLengthDelimited(BufferStream stream)
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		DeserializeLengthDelimited(stream, appClanChanged, isDelta: false);
		return appClanChanged;
	}

	public static AppClanChanged DeserializeLength(BufferStream stream, int length)
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		DeserializeLength(stream, length, appClanChanged, isDelta: false);
		return appClanChanged;
	}

	public static AppClanChanged Deserialize(byte[] buffer)
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appClanChanged, isDelta: false);
		return appClanChanged;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppClanChanged previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppClanChanged Deserialize(BufferStream stream, AppClanChanged instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppClanChanged DeserializeLengthDelimited(BufferStream stream, AppClanChanged instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppClanChanged DeserializeLength(BufferStream stream, int length, AppClanChanged instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppClanChanged instance, AppClanChanged previous)
	{
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.SerializeDelta(stream, instance.clanInfo, previous.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppClanChanged instance)
	{
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.Serialize(stream, instance.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		clanInfo?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppClanChat : IDisposable, IPooled, IProto<AppClanChat>, IProto
{
	[NonSerialized]
	public List<AppClanMessage> messages;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppClanChat instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.messages != null)
		{
			for (int i = 0; i < instance.messages.Count; i++)
			{
				if (instance.messages[i] != null)
				{
					instance.messages[i].ResetToPool();
					instance.messages[i] = null;
				}
			}
			List<AppClanMessage> list = instance.messages;
			Pool.Free<AppClanMessage>(ref list, false);
			instance.messages = list;
		}
		Pool.Free<AppClanChat>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppClanChat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppClanChat instance)
	{
		if (messages != null)
		{
			instance.messages = Pool.Get<List<AppClanMessage>>();
			for (int i = 0; i < messages.Count; i++)
			{
				AppClanMessage item = messages[i].Copy();
				instance.messages.Add(item);
			}
		}
		else
		{
			instance.messages = null;
		}
	}

	public AppClanChat Copy()
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		CopyTo(appClanChat);
		return appClanChat;
	}

	public static AppClanChat Deserialize(BufferStream stream)
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		Deserialize(stream, appClanChat, isDelta: false);
		return appClanChat;
	}

	public static AppClanChat DeserializeLengthDelimited(BufferStream stream)
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		DeserializeLengthDelimited(stream, appClanChat, isDelta: false);
		return appClanChat;
	}

	public static AppClanChat DeserializeLength(BufferStream stream, int length)
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		DeserializeLength(stream, length, appClanChat, isDelta: false);
		return appClanChat;
	}

	public static AppClanChat Deserialize(byte[] buffer)
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appClanChat, isDelta: false);
		return appClanChat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppClanChat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppClanChat Deserialize(BufferStream stream, AppClanChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppClanMessage>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.messages.Add(AppClanMessage.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppClanChat DeserializeLengthDelimited(BufferStream stream, AppClanChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppClanMessage>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(AppClanMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppClanChat DeserializeLength(BufferStream stream, int length, AppClanChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppClanMessage>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(AppClanMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppClanChat instance, AppClanChat previous)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			AppClanMessage appClanMessage = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppClanMessage.SerializeDelta(stream, appClanMessage, appClanMessage);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AppClanChat instance)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			AppClanMessage instance2 = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppClanMessage.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (messages != null)
		{
			for (int i = 0; i < messages.Count; i++)
			{
				messages[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppClanInfo : IDisposable, IPooled, IProto<AppClanInfo>, IProto
{
	[NonSerialized]
	public ClanInfo clanInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppClanInfo instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.clanInfo != null)
			{
				instance.clanInfo.ResetToPool();
				instance.clanInfo = null;
			}
			Pool.Free<AppClanInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppClanInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppClanInfo instance)
	{
		if (clanInfo != null)
		{
			if (instance.clanInfo == null)
			{
				instance.clanInfo = clanInfo.Copy();
			}
			else
			{
				clanInfo.CopyTo(instance.clanInfo);
			}
		}
		else
		{
			instance.clanInfo = null;
		}
	}

	public AppClanInfo Copy()
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		CopyTo(appClanInfo);
		return appClanInfo;
	}

	public static AppClanInfo Deserialize(BufferStream stream)
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		Deserialize(stream, appClanInfo, isDelta: false);
		return appClanInfo;
	}

	public static AppClanInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		DeserializeLengthDelimited(stream, appClanInfo, isDelta: false);
		return appClanInfo;
	}

	public static AppClanInfo DeserializeLength(BufferStream stream, int length)
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		DeserializeLength(stream, length, appClanInfo, isDelta: false);
		return appClanInfo;
	}

	public static AppClanInfo Deserialize(byte[] buffer)
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appClanInfo, isDelta: false);
		return appClanInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppClanInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppClanInfo Deserialize(BufferStream stream, AppClanInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppClanInfo DeserializeLengthDelimited(BufferStream stream, AppClanInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppClanInfo DeserializeLength(BufferStream stream, int length, AppClanInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppClanInfo instance, AppClanInfo previous)
	{
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.SerializeDelta(stream, instance.clanInfo, previous.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppClanInfo instance)
	{
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.Serialize(stream, instance.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		clanInfo?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppClanMessage : IDisposable, IPooled, IProto<AppClanMessage>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public string message;

	[NonSerialized]
	public long time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppClanMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.name = string.Empty;
			instance.message = string.Empty;
			instance.time = 0L;
			Pool.Free<AppClanMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppClanMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppClanMessage instance)
	{
		instance.steamId = steamId;
		instance.name = name;
		instance.message = message;
		instance.time = time;
	}

	public AppClanMessage Copy()
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		CopyTo(appClanMessage);
		return appClanMessage;
	}

	public static AppClanMessage Deserialize(BufferStream stream)
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		Deserialize(stream, appClanMessage, isDelta: false);
		return appClanMessage;
	}

	public static AppClanMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		DeserializeLengthDelimited(stream, appClanMessage, isDelta: false);
		return appClanMessage;
	}

	public static AppClanMessage DeserializeLength(BufferStream stream, int length)
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		DeserializeLength(stream, length, appClanMessage, isDelta: false);
		return appClanMessage;
	}

	public static AppClanMessage Deserialize(byte[] buffer)
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appClanMessage, isDelta: false);
		return appClanMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppClanMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppClanMessage Deserialize(BufferStream stream, AppClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.time = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppClanMessage DeserializeLengthDelimited(BufferStream stream, AppClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.time = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppClanMessage DeserializeLength(BufferStream stream, int length, AppClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.time = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppClanMessage instance, AppClanMessage previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.message != previous.message)
		{
			if (instance.message == null)
			{
				throw new ArgumentNullException("message", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.message);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.time);
	}

	public static void Serialize(BufferStream stream, AppClanMessage instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.message);
		if (instance.time != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppEmpty : IDisposable, IPooled, IProto<AppEmpty>, IProto
{
	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppEmpty instance)
	{
		if (instance.ShouldPool)
		{
			Pool.Free<AppEmpty>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppEmpty with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppEmpty instance)
	{
	}

	public AppEmpty Copy()
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		CopyTo(appEmpty);
		return appEmpty;
	}

	public static AppEmpty Deserialize(BufferStream stream)
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		Deserialize(stream, appEmpty, isDelta: false);
		return appEmpty;
	}

	public static AppEmpty DeserializeLengthDelimited(BufferStream stream)
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		DeserializeLengthDelimited(stream, appEmpty, isDelta: false);
		return appEmpty;
	}

	public static AppEmpty DeserializeLength(BufferStream stream, int length)
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		DeserializeLength(stream, length, appEmpty, isDelta: false);
		return appEmpty;
	}

	public static AppEmpty Deserialize(byte[] buffer)
	{
		AppEmpty appEmpty = Pool.Get<AppEmpty>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appEmpty, isDelta: false);
		return appEmpty;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppEmpty previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppEmpty Deserialize(BufferStream stream, AppEmpty instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1 || num == 0)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static AppEmpty DeserializeLengthDelimited(BufferStream stream, AppEmpty instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static AppEmpty DeserializeLength(BufferStream stream, int length, AppEmpty instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppEmpty instance, AppEmpty previous)
	{
	}

	public static void Serialize(BufferStream stream, AppEmpty instance)
	{
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppEntityChanged : IDisposable, IPooled, IProto<AppEntityChanged>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public AppEntityPayload payload;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppEntityChanged instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			if (instance.payload != null)
			{
				instance.payload.ResetToPool();
				instance.payload = null;
			}
			Pool.Free<AppEntityChanged>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppEntityChanged with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppEntityChanged instance)
	{
		instance.entityId = entityId;
		if (payload != null)
		{
			if (instance.payload == null)
			{
				instance.payload = payload.Copy();
			}
			else
			{
				payload.CopyTo(instance.payload);
			}
		}
		else
		{
			instance.payload = null;
		}
	}

	public AppEntityChanged Copy()
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		CopyTo(appEntityChanged);
		return appEntityChanged;
	}

	public static AppEntityChanged Deserialize(BufferStream stream)
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		Deserialize(stream, appEntityChanged, isDelta: false);
		return appEntityChanged;
	}

	public static AppEntityChanged DeserializeLengthDelimited(BufferStream stream)
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		DeserializeLengthDelimited(stream, appEntityChanged, isDelta: false);
		return appEntityChanged;
	}

	public static AppEntityChanged DeserializeLength(BufferStream stream, int length)
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		DeserializeLength(stream, length, appEntityChanged, isDelta: false);
		return appEntityChanged;
	}

	public static AppEntityChanged Deserialize(byte[] buffer)
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appEntityChanged, isDelta: false);
		return appEntityChanged;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppEntityChanged previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppEntityChanged Deserialize(BufferStream stream, AppEntityChanged instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppEntityChanged DeserializeLengthDelimited(BufferStream stream, AppEntityChanged instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppEntityChanged DeserializeLength(BufferStream stream, int length, AppEntityChanged instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppEntityChanged instance, AppEntityChanged previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		if (instance.payload == null)
		{
			throw new ArgumentNullException("payload", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		AppEntityPayload.SerializeDelta(stream, instance.payload, previous.payload);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field payload (ProtoBuf.AppEntityPayload)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppEntityChanged instance)
	{
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.payload == null)
		{
			throw new ArgumentNullException("payload", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		AppEntityPayload.Serialize(stream, instance.payload);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field payload (ProtoBuf.AppEntityPayload)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
		payload?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppEntityInfo : IDisposable, IPooled, IProto<AppEntityInfo>, IProto
{
	[NonSerialized]
	public AppEntityType type;

	[NonSerialized]
	public AppEntityPayload payload;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppEntityInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = (AppEntityType)0;
			if (instance.payload != null)
			{
				instance.payload.ResetToPool();
				instance.payload = null;
			}
			Pool.Free<AppEntityInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppEntityInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppEntityInfo instance)
	{
		instance.type = type;
		if (payload != null)
		{
			if (instance.payload == null)
			{
				instance.payload = payload.Copy();
			}
			else
			{
				payload.CopyTo(instance.payload);
			}
		}
		else
		{
			instance.payload = null;
		}
	}

	public AppEntityInfo Copy()
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		CopyTo(appEntityInfo);
		return appEntityInfo;
	}

	public static AppEntityInfo Deserialize(BufferStream stream)
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		Deserialize(stream, appEntityInfo, isDelta: false);
		return appEntityInfo;
	}

	public static AppEntityInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		DeserializeLengthDelimited(stream, appEntityInfo, isDelta: false);
		return appEntityInfo;
	}

	public static AppEntityInfo DeserializeLength(BufferStream stream, int length)
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		DeserializeLength(stream, length, appEntityInfo, isDelta: false);
		return appEntityInfo;
	}

	public static AppEntityInfo Deserialize(byte[] buffer)
	{
		AppEntityInfo appEntityInfo = Pool.Get<AppEntityInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appEntityInfo, isDelta: false);
		return appEntityInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppEntityInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppEntityInfo Deserialize(BufferStream stream, AppEntityInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (AppEntityType)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppEntityInfo DeserializeLengthDelimited(BufferStream stream, AppEntityInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (AppEntityType)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppEntityInfo DeserializeLength(BufferStream stream, int length, AppEntityInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (AppEntityType)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppEntityInfo instance, AppEntityInfo previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.payload == null)
		{
			throw new ArgumentNullException("payload", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		AppEntityPayload.SerializeDelta(stream, instance.payload, previous.payload);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field payload (ProtoBuf.AppEntityPayload)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppEntityInfo instance)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.payload == null)
		{
			throw new ArgumentNullException("payload", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		AppEntityPayload.Serialize(stream, instance.payload);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field payload (ProtoBuf.AppEntityPayload)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		payload?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppEntityPayload : IDisposable, IPooled, IProto<AppEntityPayload>, IProto
{
	public class Item : IDisposable, IPooled, IProto<Item>, IProto
	{
		[NonSerialized]
		public int itemId;

		[NonSerialized]
		public int quantity;

		[NonSerialized]
		public bool itemIsBlueprint;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Item instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.itemIsBlueprint = false;
				Pool.Free<Item>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Item with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Item instance)
		{
			instance.itemId = itemId;
			instance.quantity = quantity;
			instance.itemIsBlueprint = itemIsBlueprint;
		}

		public Item Copy()
		{
			Item item = Pool.Get<Item>();
			CopyTo(item);
			return item;
		}

		public static Item Deserialize(BufferStream stream)
		{
			Item item = Pool.Get<Item>();
			Deserialize(stream, item, isDelta: false);
			return item;
		}

		public static Item DeserializeLengthDelimited(BufferStream stream)
		{
			Item item = Pool.Get<Item>();
			DeserializeLengthDelimited(stream, item, isDelta: false);
			return item;
		}

		public static Item DeserializeLength(BufferStream stream, int length)
		{
			Item item = Pool.Get<Item>();
			DeserializeLength(stream, length, item, isDelta: false);
			return item;
		}

		public static Item Deserialize(byte[] buffer)
		{
			Item item = Pool.Get<Item>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, item, isDelta: false);
			return item;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Item previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Item Deserialize(BufferStream stream, Item instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.itemIsBlueprint = false;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Item DeserializeLengthDelimited(BufferStream stream, Item instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.itemIsBlueprint = false;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Item DeserializeLength(BufferStream stream, int length, Item instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.itemIsBlueprint = false;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Item instance, Item previous)
		{
			if (instance.itemId != previous.itemId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.quantity != previous.quantity)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		}

		public static void Serialize(BufferStream stream, Item instance)
		{
			if (instance.itemId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.quantity != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
			}
			if (instance.itemIsBlueprint)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public bool value;

	[NonSerialized]
	public List<Item> items;

	[NonSerialized]
	public int capacity;

	[NonSerialized]
	public bool hasProtection;

	[NonSerialized]
	public uint protectionExpiry;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppEntityPayload instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.value = false;
		if (instance.items != null)
		{
			for (int i = 0; i < instance.items.Count; i++)
			{
				if (instance.items[i] != null)
				{
					instance.items[i].ResetToPool();
					instance.items[i] = null;
				}
			}
			List<Item> list = instance.items;
			Pool.Free<Item>(ref list, false);
			instance.items = list;
		}
		instance.capacity = 0;
		instance.hasProtection = false;
		instance.protectionExpiry = 0u;
		Pool.Free<AppEntityPayload>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppEntityPayload with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppEntityPayload instance)
	{
		instance.value = value;
		if (items != null)
		{
			instance.items = Pool.Get<List<Item>>();
			for (int i = 0; i < items.Count; i++)
			{
				Item item = items[i].Copy();
				instance.items.Add(item);
			}
		}
		else
		{
			instance.items = null;
		}
		instance.capacity = capacity;
		instance.hasProtection = hasProtection;
		instance.protectionExpiry = protectionExpiry;
	}

	public AppEntityPayload Copy()
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		CopyTo(appEntityPayload);
		return appEntityPayload;
	}

	public static AppEntityPayload Deserialize(BufferStream stream)
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		Deserialize(stream, appEntityPayload, isDelta: false);
		return appEntityPayload;
	}

	public static AppEntityPayload DeserializeLengthDelimited(BufferStream stream)
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		DeserializeLengthDelimited(stream, appEntityPayload, isDelta: false);
		return appEntityPayload;
	}

	public static AppEntityPayload DeserializeLength(BufferStream stream, int length)
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		DeserializeLength(stream, length, appEntityPayload, isDelta: false);
		return appEntityPayload;
	}

	public static AppEntityPayload Deserialize(byte[] buffer)
	{
		AppEntityPayload appEntityPayload = Pool.Get<AppEntityPayload>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appEntityPayload, isDelta: false);
		return appEntityPayload;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppEntityPayload previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppEntityPayload Deserialize(BufferStream stream, AppEntityPayload instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
			if (instance.items == null)
			{
				instance.items = Pool.Get<List<Item>>();
			}
			instance.capacity = 0;
			instance.protectionExpiry = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.items.Add(Item.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.capacity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.hasProtection = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.protectionExpiry = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppEntityPayload DeserializeLengthDelimited(BufferStream stream, AppEntityPayload instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
			if (instance.items == null)
			{
				instance.items = Pool.Get<List<Item>>();
			}
			instance.capacity = 0;
			instance.protectionExpiry = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.items.Add(Item.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.capacity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.hasProtection = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.protectionExpiry = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppEntityPayload DeserializeLength(BufferStream stream, int length, AppEntityPayload instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
			if (instance.items == null)
			{
				instance.items = Pool.Get<List<Item>>();
			}
			instance.capacity = 0;
			instance.protectionExpiry = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.items.Add(Item.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.capacity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.hasProtection = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.protectionExpiry = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppEntityPayload instance, AppEntityPayload previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.value);
		if (instance.items != null)
		{
			for (int i = 0; i < instance.items.Count; i++)
			{
				Item item = instance.items[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Item.SerializeDelta(stream, item, item);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field items (ProtoBuf.AppEntityPayload.Item)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.capacity != previous.capacity)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.capacity);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.hasProtection);
		if (instance.protectionExpiry != previous.protectionExpiry)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.protectionExpiry);
		}
	}

	public static void Serialize(BufferStream stream, AppEntityPayload instance)
	{
		if (instance.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.value);
		}
		if (instance.items != null)
		{
			for (int i = 0; i < instance.items.Count; i++)
			{
				Item instance2 = instance.items[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Item.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field items (ProtoBuf.AppEntityPayload.Item)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.capacity != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.capacity);
		}
		if (instance.hasProtection)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.hasProtection);
		}
		if (instance.protectionExpiry != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.protectionExpiry);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (items != null)
		{
			for (int i = 0; i < items.Count; i++)
			{
				items[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppError : IDisposable, IPooled, IProto<AppError>, IProto
{
	[NonSerialized]
	public string error;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppError instance)
	{
		if (instance.ShouldPool)
		{
			instance.error = string.Empty;
			Pool.Free<AppError>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppError with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppError instance)
	{
		instance.error = error;
	}

	public AppError Copy()
	{
		AppError appError = Pool.Get<AppError>();
		CopyTo(appError);
		return appError;
	}

	public static AppError Deserialize(BufferStream stream)
	{
		AppError appError = Pool.Get<AppError>();
		Deserialize(stream, appError, isDelta: false);
		return appError;
	}

	public static AppError DeserializeLengthDelimited(BufferStream stream)
	{
		AppError appError = Pool.Get<AppError>();
		DeserializeLengthDelimited(stream, appError, isDelta: false);
		return appError;
	}

	public static AppError DeserializeLength(BufferStream stream, int length)
	{
		AppError appError = Pool.Get<AppError>();
		DeserializeLength(stream, length, appError, isDelta: false);
		return appError;
	}

	public static AppError Deserialize(byte[] buffer)
	{
		AppError appError = Pool.Get<AppError>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appError, isDelta: false);
		return appError;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppError previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppError Deserialize(BufferStream stream, AppError instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.error = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppError DeserializeLengthDelimited(BufferStream stream, AppError instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.error = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppError DeserializeLength(BufferStream stream, int length, AppError instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.error = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppError instance, AppError previous)
	{
		if (instance.error != previous.error)
		{
			if (instance.error == null)
			{
				throw new ArgumentNullException("error", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.error);
		}
	}

	public static void Serialize(BufferStream stream, AppError instance)
	{
		if (instance.error == null)
		{
			throw new ArgumentNullException("error", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.error);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppFlag : IDisposable, IPooled, IProto<AppFlag>, IProto
{
	[NonSerialized]
	public bool value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppFlag instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = false;
			Pool.Free<AppFlag>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppFlag with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppFlag instance)
	{
		instance.value = value;
	}

	public AppFlag Copy()
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		CopyTo(appFlag);
		return appFlag;
	}

	public static AppFlag Deserialize(BufferStream stream)
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		Deserialize(stream, appFlag, isDelta: false);
		return appFlag;
	}

	public static AppFlag DeserializeLengthDelimited(BufferStream stream)
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		DeserializeLengthDelimited(stream, appFlag, isDelta: false);
		return appFlag;
	}

	public static AppFlag DeserializeLength(BufferStream stream, int length)
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		DeserializeLength(stream, length, appFlag, isDelta: false);
		return appFlag;
	}

	public static AppFlag Deserialize(byte[] buffer)
	{
		AppFlag appFlag = Pool.Get<AppFlag>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appFlag, isDelta: false);
		return appFlag;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppFlag previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppFlag Deserialize(BufferStream stream, AppFlag instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppFlag DeserializeLengthDelimited(BufferStream stream, AppFlag instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppFlag DeserializeLength(BufferStream stream, int length, AppFlag instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppFlag instance, AppFlag previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.value);
	}

	public static void Serialize(BufferStream stream, AppFlag instance)
	{
		if (instance.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppGetNexusAuth : IDisposable, IPooled, IProto<AppGetNexusAuth>, IProto
{
	[NonSerialized]
	public string appKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppGetNexusAuth instance)
	{
		if (instance.ShouldPool)
		{
			instance.appKey = string.Empty;
			Pool.Free<AppGetNexusAuth>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppGetNexusAuth with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppGetNexusAuth instance)
	{
		instance.appKey = appKey;
	}

	public AppGetNexusAuth Copy()
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		CopyTo(appGetNexusAuth);
		return appGetNexusAuth;
	}

	public static AppGetNexusAuth Deserialize(BufferStream stream)
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		Deserialize(stream, appGetNexusAuth, isDelta: false);
		return appGetNexusAuth;
	}

	public static AppGetNexusAuth DeserializeLengthDelimited(BufferStream stream)
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		DeserializeLengthDelimited(stream, appGetNexusAuth, isDelta: false);
		return appGetNexusAuth;
	}

	public static AppGetNexusAuth DeserializeLength(BufferStream stream, int length)
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		DeserializeLength(stream, length, appGetNexusAuth, isDelta: false);
		return appGetNexusAuth;
	}

	public static AppGetNexusAuth Deserialize(byte[] buffer)
	{
		AppGetNexusAuth appGetNexusAuth = Pool.Get<AppGetNexusAuth>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appGetNexusAuth, isDelta: false);
		return appGetNexusAuth;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppGetNexusAuth previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppGetNexusAuth Deserialize(BufferStream stream, AppGetNexusAuth instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.appKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppGetNexusAuth DeserializeLengthDelimited(BufferStream stream, AppGetNexusAuth instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.appKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppGetNexusAuth DeserializeLength(BufferStream stream, int length, AppGetNexusAuth instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.appKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppGetNexusAuth instance, AppGetNexusAuth previous)
	{
		if (instance.appKey != previous.appKey)
		{
			if (instance.appKey == null)
			{
				throw new ArgumentNullException("appKey", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.appKey);
		}
	}

	public static void Serialize(BufferStream stream, AppGetNexusAuth instance)
	{
		if (instance.appKey == null)
		{
			throw new ArgumentNullException("appKey", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.appKey);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppInfo : IDisposable, IPooled, IProto<AppInfo>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public string headerImage;

	[NonSerialized]
	public string url;

	[NonSerialized]
	public string map;

	[NonSerialized]
	public uint mapSize;

	[NonSerialized]
	public uint wipeTime;

	[NonSerialized]
	public uint players;

	[NonSerialized]
	public uint maxPlayers;

	[NonSerialized]
	public uint queuedPlayers;

	[NonSerialized]
	public uint seed;

	[NonSerialized]
	public uint salt;

	[NonSerialized]
	public string logoImage;

	[NonSerialized]
	public string nexus;

	[NonSerialized]
	public int nexusId;

	[NonSerialized]
	public string nexusZone;

	[NonSerialized]
	public bool camerasEnabled;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.headerImage = string.Empty;
			instance.url = string.Empty;
			instance.map = string.Empty;
			instance.mapSize = 0u;
			instance.wipeTime = 0u;
			instance.players = 0u;
			instance.maxPlayers = 0u;
			instance.queuedPlayers = 0u;
			instance.seed = 0u;
			instance.salt = 0u;
			instance.logoImage = string.Empty;
			instance.nexus = string.Empty;
			instance.nexusId = 0;
			instance.nexusZone = string.Empty;
			instance.camerasEnabled = false;
			Pool.Free<AppInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppInfo instance)
	{
		instance.name = name;
		instance.headerImage = headerImage;
		instance.url = url;
		instance.map = map;
		instance.mapSize = mapSize;
		instance.wipeTime = wipeTime;
		instance.players = players;
		instance.maxPlayers = maxPlayers;
		instance.queuedPlayers = queuedPlayers;
		instance.seed = seed;
		instance.salt = salt;
		instance.logoImage = logoImage;
		instance.nexus = nexus;
		instance.nexusId = nexusId;
		instance.nexusZone = nexusZone;
		instance.camerasEnabled = camerasEnabled;
	}

	public AppInfo Copy()
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		CopyTo(appInfo);
		return appInfo;
	}

	public static AppInfo Deserialize(BufferStream stream)
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		Deserialize(stream, appInfo, isDelta: false);
		return appInfo;
	}

	public static AppInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		DeserializeLengthDelimited(stream, appInfo, isDelta: false);
		return appInfo;
	}

	public static AppInfo DeserializeLength(BufferStream stream, int length)
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		DeserializeLength(stream, length, appInfo, isDelta: false);
		return appInfo;
	}

	public static AppInfo Deserialize(byte[] buffer)
	{
		AppInfo appInfo = Pool.Get<AppInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appInfo, isDelta: false);
		return appInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppInfo Deserialize(BufferStream stream, AppInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.mapSize = 0u;
			instance.wipeTime = 0u;
			instance.players = 0u;
			instance.maxPlayers = 0u;
			instance.queuedPlayers = 0u;
			instance.seed = 0u;
			instance.salt = 0u;
			instance.nexusId = 0;
			instance.camerasEnabled = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.headerImage = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.url = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.map = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.mapSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.wipeTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.players = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.maxPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.queuedPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.salt = ProtocolParser.ReadUInt32(stream);
				continue;
			case 98:
				instance.logoImage = ProtocolParser.ReadString(stream);
				continue;
			case 106:
				instance.nexus = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.camerasEnabled = ProtocolParser.ReadBool(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static AppInfo DeserializeLengthDelimited(BufferStream stream, AppInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.mapSize = 0u;
			instance.wipeTime = 0u;
			instance.players = 0u;
			instance.maxPlayers = 0u;
			instance.queuedPlayers = 0u;
			instance.seed = 0u;
			instance.salt = 0u;
			instance.nexusId = 0;
			instance.camerasEnabled = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.headerImage = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.url = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.map = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.mapSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.wipeTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.players = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.maxPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.queuedPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.salt = ProtocolParser.ReadUInt32(stream);
				continue;
			case 98:
				instance.logoImage = ProtocolParser.ReadString(stream);
				continue;
			case 106:
				instance.nexus = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.camerasEnabled = ProtocolParser.ReadBool(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppInfo DeserializeLength(BufferStream stream, int length, AppInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.mapSize = 0u;
			instance.wipeTime = 0u;
			instance.players = 0u;
			instance.maxPlayers = 0u;
			instance.queuedPlayers = 0u;
			instance.seed = 0u;
			instance.salt = 0u;
			instance.nexusId = 0;
			instance.camerasEnabled = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.headerImage = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.url = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.map = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.mapSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 48:
				instance.wipeTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.players = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.maxPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 72:
				instance.queuedPlayers = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.salt = ProtocolParser.ReadUInt32(stream);
				continue;
			case 98:
				instance.logoImage = ProtocolParser.ReadString(stream);
				continue;
			case 106:
				instance.nexus = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.camerasEnabled = ProtocolParser.ReadBool(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppInfo instance, AppInfo previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.headerImage != previous.headerImage)
		{
			if (instance.headerImage == null)
			{
				throw new ArgumentNullException("headerImage", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.headerImage);
		}
		if (instance.url != previous.url)
		{
			if (instance.url == null)
			{
				throw new ArgumentNullException("url", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.url);
		}
		if (instance.map != previous.map)
		{
			if (instance.map == null)
			{
				throw new ArgumentNullException("map", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.map);
		}
		if (instance.mapSize != previous.mapSize)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.mapSize);
		}
		if (instance.wipeTime != previous.wipeTime)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.wipeTime);
		}
		if (instance.players != previous.players)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.players);
		}
		if (instance.maxPlayers != previous.maxPlayers)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.maxPlayers);
		}
		if (instance.queuedPlayers != previous.queuedPlayers)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.queuedPlayers);
		}
		if (instance.seed != previous.seed)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.salt != previous.salt)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt32(stream, instance.salt);
		}
		if (instance.logoImage != null && instance.logoImage != previous.logoImage)
		{
			stream.WriteByte(98);
			ProtocolParser.WriteString(stream, instance.logoImage);
		}
		if (instance.nexus != null && instance.nexus != previous.nexus)
		{
			stream.WriteByte(106);
			ProtocolParser.WriteString(stream, instance.nexus);
		}
		if (instance.nexusId != previous.nexusId)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nexusId);
		}
		if (instance.nexusZone != null && instance.nexusZone != previous.nexusZone)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		stream.WriteByte(128);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.camerasEnabled);
	}

	public static void Serialize(BufferStream stream, AppInfo instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.headerImage == null)
		{
			throw new ArgumentNullException("headerImage", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.headerImage);
		if (instance.url == null)
		{
			throw new ArgumentNullException("url", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.url);
		if (instance.map == null)
		{
			throw new ArgumentNullException("map", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteString(stream, instance.map);
		if (instance.mapSize != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.mapSize);
		}
		if (instance.wipeTime != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.wipeTime);
		}
		if (instance.players != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.players);
		}
		if (instance.maxPlayers != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.maxPlayers);
		}
		if (instance.queuedPlayers != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.queuedPlayers);
		}
		if (instance.seed != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.salt != 0)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt32(stream, instance.salt);
		}
		if (instance.logoImage != null)
		{
			stream.WriteByte(98);
			ProtocolParser.WriteString(stream, instance.logoImage);
		}
		if (instance.nexus != null)
		{
			stream.WriteByte(106);
			ProtocolParser.WriteString(stream, instance.nexus);
		}
		if (instance.nexusId != 0)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nexusId);
		}
		if (instance.nexusZone != null)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		if (instance.camerasEnabled)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.camerasEnabled);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppMap : IDisposable, IPooled, IProto<AppMap>, IProto
{
	public class Monument : IDisposable, IPooled, IProto<Monument>, IProto
	{
		[NonSerialized]
		public string token;

		[NonSerialized]
		public float x;

		[NonSerialized]
		public float y;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Monument instance)
		{
			if (instance.ShouldPool)
			{
				instance.token = string.Empty;
				instance.x = 0f;
				instance.y = 0f;
				Pool.Free<Monument>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Monument with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Monument instance)
		{
			instance.token = token;
			instance.x = x;
			instance.y = y;
		}

		public Monument Copy()
		{
			Monument monument = Pool.Get<Monument>();
			CopyTo(monument);
			return monument;
		}

		public static Monument Deserialize(BufferStream stream)
		{
			Monument monument = Pool.Get<Monument>();
			Deserialize(stream, monument, isDelta: false);
			return monument;
		}

		public static Monument DeserializeLengthDelimited(BufferStream stream)
		{
			Monument monument = Pool.Get<Monument>();
			DeserializeLengthDelimited(stream, monument, isDelta: false);
			return monument;
		}

		public static Monument DeserializeLength(BufferStream stream, int length)
		{
			Monument monument = Pool.Get<Monument>();
			DeserializeLength(stream, length, monument, isDelta: false);
			return monument;
		}

		public static Monument Deserialize(byte[] buffer)
		{
			Monument monument = Pool.Get<Monument>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, monument, isDelta: false);
			return monument;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Monument previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Monument Deserialize(BufferStream stream, Monument instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.x = 0f;
				instance.y = 0f;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.token = ProtocolParser.ReadString(stream);
					continue;
				case 21:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 29:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Monument DeserializeLengthDelimited(BufferStream stream, Monument instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.x = 0f;
				instance.y = 0f;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.token = ProtocolParser.ReadString(stream);
					continue;
				case 21:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 29:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Monument DeserializeLength(BufferStream stream, int length, Monument instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.x = 0f;
				instance.y = 0f;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.token = ProtocolParser.ReadString(stream);
					continue;
				case 21:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 29:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Monument instance, Monument previous)
		{
			if (instance.token != previous.token)
			{
				if (instance.token == null)
				{
					throw new ArgumentNullException("token", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.token);
			}
			if (instance.x != previous.x)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != previous.y)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
		}

		public static void Serialize(BufferStream stream, Monument instance)
		{
			if (instance.token == null)
			{
				throw new ArgumentNullException("token", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.token);
			if (instance.x != 0f)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public uint width;

	[NonSerialized]
	public uint height;

	[NonSerialized]
	public byte[] jpgImage;

	[NonSerialized]
	public int oceanMargin;

	[NonSerialized]
	public List<Monument> monuments;

	[NonSerialized]
	public string background;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppMap instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.width = 0u;
		instance.height = 0u;
		instance.jpgImage = null;
		instance.oceanMargin = 0;
		if (instance.monuments != null)
		{
			for (int i = 0; i < instance.monuments.Count; i++)
			{
				if (instance.monuments[i] != null)
				{
					instance.monuments[i].ResetToPool();
					instance.monuments[i] = null;
				}
			}
			List<Monument> list = instance.monuments;
			Pool.Free<Monument>(ref list, false);
			instance.monuments = list;
		}
		instance.background = string.Empty;
		Pool.Free<AppMap>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppMap with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppMap instance)
	{
		instance.width = width;
		instance.height = height;
		if (jpgImage == null)
		{
			instance.jpgImage = null;
		}
		else
		{
			instance.jpgImage = new byte[jpgImage.Length];
			Array.Copy(jpgImage, instance.jpgImage, instance.jpgImage.Length);
		}
		instance.oceanMargin = oceanMargin;
		if (monuments != null)
		{
			instance.monuments = Pool.Get<List<Monument>>();
			for (int i = 0; i < monuments.Count; i++)
			{
				Monument item = monuments[i].Copy();
				instance.monuments.Add(item);
			}
		}
		else
		{
			instance.monuments = null;
		}
		instance.background = background;
	}

	public AppMap Copy()
	{
		AppMap appMap = Pool.Get<AppMap>();
		CopyTo(appMap);
		return appMap;
	}

	public static AppMap Deserialize(BufferStream stream)
	{
		AppMap appMap = Pool.Get<AppMap>();
		Deserialize(stream, appMap, isDelta: false);
		return appMap;
	}

	public static AppMap DeserializeLengthDelimited(BufferStream stream)
	{
		AppMap appMap = Pool.Get<AppMap>();
		DeserializeLengthDelimited(stream, appMap, isDelta: false);
		return appMap;
	}

	public static AppMap DeserializeLength(BufferStream stream, int length)
	{
		AppMap appMap = Pool.Get<AppMap>();
		DeserializeLength(stream, length, appMap, isDelta: false);
		return appMap;
	}

	public static AppMap Deserialize(byte[] buffer)
	{
		AppMap appMap = Pool.Get<AppMap>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appMap, isDelta: false);
		return appMap;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppMap previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppMap Deserialize(BufferStream stream, AppMap instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0u;
			instance.height = 0u;
			instance.oceanMargin = 0;
			if (instance.monuments == null)
			{
				instance.monuments = Pool.Get<List<Monument>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.width = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.height = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				instance.jpgImage = ProtocolParser.ReadBytes(stream);
				continue;
			case 32:
				instance.oceanMargin = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.monuments.Add(Monument.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.background = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppMap DeserializeLengthDelimited(BufferStream stream, AppMap instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0u;
			instance.height = 0u;
			instance.oceanMargin = 0;
			if (instance.monuments == null)
			{
				instance.monuments = Pool.Get<List<Monument>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.width = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.height = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				instance.jpgImage = ProtocolParser.ReadBytes(stream);
				continue;
			case 32:
				instance.oceanMargin = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.monuments.Add(Monument.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.background = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppMap DeserializeLength(BufferStream stream, int length, AppMap instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0u;
			instance.height = 0u;
			instance.oceanMargin = 0;
			if (instance.monuments == null)
			{
				instance.monuments = Pool.Get<List<Monument>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.width = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.height = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				instance.jpgImage = ProtocolParser.ReadBytes(stream);
				continue;
			case 32:
				instance.oceanMargin = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.monuments.Add(Monument.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.background = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppMap instance, AppMap previous)
	{
		if (instance.width != previous.width)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.width);
		}
		if (instance.height != previous.height)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.height);
		}
		if (instance.jpgImage == null)
		{
			throw new ArgumentNullException("jpgImage", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteBytes(stream, instance.jpgImage);
		if (instance.oceanMargin != previous.oceanMargin)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oceanMargin);
		}
		if (instance.monuments != null)
		{
			for (int i = 0; i < instance.monuments.Count; i++)
			{
				Monument monument = instance.monuments[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Monument.SerializeDelta(stream, monument, monument);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.background != null && instance.background != previous.background)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.background);
		}
	}

	public static void Serialize(BufferStream stream, AppMap instance)
	{
		if (instance.width != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.width);
		}
		if (instance.height != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.height);
		}
		if (instance.jpgImage == null)
		{
			throw new ArgumentNullException("jpgImage", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteBytes(stream, instance.jpgImage);
		if (instance.oceanMargin != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oceanMargin);
		}
		if (instance.monuments != null)
		{
			for (int i = 0; i < instance.monuments.Count; i++)
			{
				Monument instance2 = instance.monuments[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Monument.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.background != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.background);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (monuments != null)
		{
			for (int i = 0; i < monuments.Count; i++)
			{
				monuments[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppMapMarkers : IDisposable, IPooled, IProto<AppMapMarkers>, IProto
{
	[NonSerialized]
	public List<AppMarker> markers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppMapMarkers instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.markers != null)
		{
			for (int i = 0; i < instance.markers.Count; i++)
			{
				if (instance.markers[i] != null)
				{
					instance.markers[i].ResetToPool();
					instance.markers[i] = null;
				}
			}
			List<AppMarker> list = instance.markers;
			Pool.Free<AppMarker>(ref list, false);
			instance.markers = list;
		}
		Pool.Free<AppMapMarkers>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppMapMarkers with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppMapMarkers instance)
	{
		if (markers != null)
		{
			instance.markers = Pool.Get<List<AppMarker>>();
			for (int i = 0; i < markers.Count; i++)
			{
				AppMarker item = markers[i].Copy();
				instance.markers.Add(item);
			}
		}
		else
		{
			instance.markers = null;
		}
	}

	public AppMapMarkers Copy()
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		CopyTo(appMapMarkers);
		return appMapMarkers;
	}

	public static AppMapMarkers Deserialize(BufferStream stream)
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		Deserialize(stream, appMapMarkers, isDelta: false);
		return appMapMarkers;
	}

	public static AppMapMarkers DeserializeLengthDelimited(BufferStream stream)
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		DeserializeLengthDelimited(stream, appMapMarkers, isDelta: false);
		return appMapMarkers;
	}

	public static AppMapMarkers DeserializeLength(BufferStream stream, int length)
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		DeserializeLength(stream, length, appMapMarkers, isDelta: false);
		return appMapMarkers;
	}

	public static AppMapMarkers Deserialize(byte[] buffer)
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appMapMarkers, isDelta: false);
		return appMapMarkers;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppMapMarkers previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppMapMarkers Deserialize(BufferStream stream, AppMapMarkers instance, bool isDelta)
	{
		if (!isDelta && instance.markers == null)
		{
			instance.markers = Pool.Get<List<AppMarker>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.markers.Add(AppMarker.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppMapMarkers DeserializeLengthDelimited(BufferStream stream, AppMapMarkers instance, bool isDelta)
	{
		if (!isDelta && instance.markers == null)
		{
			instance.markers = Pool.Get<List<AppMarker>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.markers.Add(AppMarker.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppMapMarkers DeserializeLength(BufferStream stream, int length, AppMapMarkers instance, bool isDelta)
	{
		if (!isDelta && instance.markers == null)
		{
			instance.markers = Pool.Get<List<AppMarker>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.markers.Add(AppMarker.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppMapMarkers instance, AppMapMarkers previous)
	{
		if (instance.markers == null)
		{
			return;
		}
		for (int i = 0; i < instance.markers.Count; i++)
		{
			AppMarker appMarker = instance.markers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppMarker.SerializeDelta(stream, appMarker, appMarker);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AppMapMarkers instance)
	{
		if (instance.markers == null)
		{
			return;
		}
		for (int i = 0; i < instance.markers.Count; i++)
		{
			AppMarker instance2 = instance.markers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppMarker.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (markers != null)
		{
			for (int i = 0; i < markers.Count; i++)
			{
				markers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class AppMarker : IDisposable, IPooled, IProto<AppMarker>, IProto
{
	public class SellOrder : IDisposable, IPooled, IProto<SellOrder>, IProto
	{
		[NonSerialized]
		public int itemId;

		[NonSerialized]
		public int quantity;

		[NonSerialized]
		public int currencyId;

		[NonSerialized]
		public int costPerItem;

		[NonSerialized]
		public int amountInStock;

		[NonSerialized]
		public bool itemIsBlueprint;

		[NonSerialized]
		public bool currencyIsBlueprint;

		[NonSerialized]
		public float itemCondition;

		[NonSerialized]
		public float itemConditionMax;

		[NonSerialized]
		public float priceMultiplier;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SellOrder instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.currencyId = 0;
				instance.costPerItem = 0;
				instance.amountInStock = 0;
				instance.itemIsBlueprint = false;
				instance.currencyIsBlueprint = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.priceMultiplier = 0f;
				Pool.Free<SellOrder>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SellOrder with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SellOrder instance)
		{
			instance.itemId = itemId;
			instance.quantity = quantity;
			instance.currencyId = currencyId;
			instance.costPerItem = costPerItem;
			instance.amountInStock = amountInStock;
			instance.itemIsBlueprint = itemIsBlueprint;
			instance.currencyIsBlueprint = currencyIsBlueprint;
			instance.itemCondition = itemCondition;
			instance.itemConditionMax = itemConditionMax;
			instance.priceMultiplier = priceMultiplier;
		}

		public SellOrder Copy()
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			CopyTo(sellOrder);
			return sellOrder;
		}

		public static SellOrder Deserialize(BufferStream stream)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			Deserialize(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder DeserializeLengthDelimited(BufferStream stream)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			DeserializeLengthDelimited(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder DeserializeLength(BufferStream stream, int length)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			DeserializeLength(stream, length, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder Deserialize(byte[] buffer)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SellOrder previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SellOrder Deserialize(BufferStream stream, SellOrder instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.currencyId = 0;
				instance.costPerItem = 0;
				instance.amountInStock = 0;
				instance.itemIsBlueprint = false;
				instance.currencyIsBlueprint = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.priceMultiplier = 0f;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 85:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static SellOrder DeserializeLengthDelimited(BufferStream stream, SellOrder instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.currencyId = 0;
				instance.costPerItem = 0;
				instance.amountInStock = 0;
				instance.itemIsBlueprint = false;
				instance.currencyIsBlueprint = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.priceMultiplier = 0f;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 85:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SellOrder DeserializeLength(BufferStream stream, int length, SellOrder instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.currencyId = 0;
				instance.costPerItem = 0;
				instance.amountInStock = 0;
				instance.itemIsBlueprint = false;
				instance.currencyIsBlueprint = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.priceMultiplier = 0f;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 85:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SellOrder instance, SellOrder previous)
		{
			if (instance.itemId != previous.itemId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.quantity != previous.quantity)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
			}
			if (instance.currencyId != previous.currencyId)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
			}
			if (instance.costPerItem != previous.costPerItem)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
			}
			if (instance.amountInStock != previous.amountInStock)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
			if (instance.itemCondition != previous.itemCondition)
			{
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, instance.itemCondition);
			}
			if (instance.itemConditionMax != previous.itemConditionMax)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
			}
			if (instance.priceMultiplier != previous.priceMultiplier)
			{
				stream.WriteByte(85);
				ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
			}
		}

		public static void Serialize(BufferStream stream, SellOrder instance)
		{
			if (instance.itemId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.quantity != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
			}
			if (instance.currencyId != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
			}
			if (instance.costPerItem != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
			}
			if (instance.amountInStock != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
			}
			if (instance.itemIsBlueprint)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
			}
			if (instance.currencyIsBlueprint)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
			}
			if (instance.itemCondition != 0f)
			{
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, instance.itemCondition);
			}
			if (instance.itemConditionMax != 0f)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
			}
			if (instance.priceMultiplier != 0f)
			{
				stream.WriteByte(85);
				ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public NetworkableId id;

	[NonSerialized]
	public AppMarkerType type;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public float rotation;

	[NonSerialized]
	public float radius;

	[NonSerialized]
	public Vector4 color1;

	[NonSerialized]
	public Vector4 color2;

	[NonSerialized]
	public float alpha;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public bool outOfStock;

	[NonSerialized]
	public List<SellOrder> sellOrders;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppMarker instance)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.id = default(NetworkableId);
		instance.type = AppMarkerType.Undefined;
		instance.x = 0f;
		instance.y = 0f;
		instance.steamId = 0uL;
		instance.rotation = 0f;
		instance.radius = 0f;
		instance.color1 = default(Vector4);
		instance.color2 = default(Vector4);
		instance.alpha = 0f;
		instance.name = string.Empty;
		instance.outOfStock = false;
		if (instance.sellOrders != null)
		{
			for (int i = 0; i < instance.sellOrders.Count; i++)
			{
				if (instance.sellOrders[i] != null)
				{
					instance.sellOrders[i].ResetToPool();
					instance.sellOrders[i] = null;
				}
			}
			List<SellOrder> list = instance.sellOrders;
			Pool.Free<SellOrder>(ref list, false);
			instance.sellOrders = list;
		}
		Pool.Free<AppMarker>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppMarker with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppMarker instance)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		instance.id = id;
		instance.type = type;
		instance.x = x;
		instance.y = y;
		instance.steamId = steamId;
		instance.rotation = rotation;
		instance.radius = radius;
		instance.color1 = color1;
		instance.color2 = color2;
		instance.alpha = alpha;
		instance.name = name;
		instance.outOfStock = outOfStock;
		if (sellOrders != null)
		{
			instance.sellOrders = Pool.Get<List<SellOrder>>();
			for (int i = 0; i < sellOrders.Count; i++)
			{
				SellOrder item = sellOrders[i].Copy();
				instance.sellOrders.Add(item);
			}
		}
		else
		{
			instance.sellOrders = null;
		}
	}

	public AppMarker Copy()
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		CopyTo(appMarker);
		return appMarker;
	}

	public static AppMarker Deserialize(BufferStream stream)
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		Deserialize(stream, appMarker, isDelta: false);
		return appMarker;
	}

	public static AppMarker DeserializeLengthDelimited(BufferStream stream)
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		DeserializeLengthDelimited(stream, appMarker, isDelta: false);
		return appMarker;
	}

	public static AppMarker DeserializeLength(BufferStream stream, int length)
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		DeserializeLength(stream, length, appMarker, isDelta: false);
		return appMarker;
	}

	public static AppMarker Deserialize(byte[] buffer)
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appMarker, isDelta: false);
		return appMarker;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppMarker previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppMarker Deserialize(BufferStream stream, AppMarker instance, bool isDelta)
	{
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.steamId = 0uL;
			instance.rotation = 0f;
			instance.radius = 0f;
			instance.alpha = 0f;
			instance.outOfStock = false;
			if (instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (AppMarkerType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.rotation = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color1, isDelta);
				continue;
			case 74:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color2, isDelta);
				continue;
			case 85:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.outOfStock = ProtocolParser.ReadBool(stream);
				continue;
			case 106:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppMarker DeserializeLengthDelimited(BufferStream stream, AppMarker instance, bool isDelta)
	{
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.steamId = 0uL;
			instance.rotation = 0f;
			instance.radius = 0f;
			instance.alpha = 0f;
			instance.outOfStock = false;
			if (instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (AppMarkerType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.rotation = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color1, isDelta);
				continue;
			case 74:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color2, isDelta);
				continue;
			case 85:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.outOfStock = ProtocolParser.ReadBool(stream);
				continue;
			case 106:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppMarker DeserializeLength(BufferStream stream, int length, AppMarker instance, bool isDelta)
	{
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.steamId = 0uL;
			instance.rotation = 0f;
			instance.radius = 0f;
			instance.alpha = 0f;
			instance.outOfStock = false;
			if (instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (AppMarkerType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.rotation = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color1, isDelta);
				continue;
			case 74:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color2, isDelta);
				continue;
			case 85:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.outOfStock = ProtocolParser.ReadBool(stream);
				continue;
			case 106:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppMarker instance, AppMarker previous)
	{
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.id.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.x != previous.x)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.rotation);
		}
		if (instance.radius != previous.radius)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.radius);
		}
		if (instance.color1 != previous.color1)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.color1, previous.color1);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color1 (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.color2 != previous.color2)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.color2, previous.color2);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color2 (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.alpha != previous.alpha)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(96);
		ProtocolParser.WriteBool(stream, instance.outOfStock);
		if (instance.sellOrders == null)
		{
			return;
		}
		for (int i = 0; i < instance.sellOrders.Count; i++)
		{
			SellOrder sellOrder = instance.sellOrders[i];
			stream.WriteByte(106);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			SellOrder.SerializeDelta(stream, sellOrder, sellOrder);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.AppMarker.SellOrder)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public static void Serialize(BufferStream stream, AppMarker instance)
	{
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		if (instance.id != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.id.Value);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.x != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.steamId != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.rotation != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.rotation);
		}
		if (instance.radius != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.radius);
		}
		if (instance.color1 != default(Vector4))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.Serialize(stream, instance.color1);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color1 (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.color2 != default(Vector4))
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.color2);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color2 (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.alpha != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.name != null)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.outOfStock)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.outOfStock);
		}
		if (instance.sellOrders == null)
		{
			return;
		}
		for (int i = 0; i < instance.sellOrders.Count; i++)
		{
			SellOrder instance2 = instance.sellOrders[i];
			stream.WriteByte(106);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			SellOrder.Serialize(stream, instance2);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.AppMarker.SellOrder)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref id.Value);
		if (sellOrders != null)
		{
			for (int i = 0; i < sellOrders.Count; i++)
			{
				sellOrders[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppMessage : IDisposable, IPooled, IProto<AppMessage>, IProto
{
	[NonSerialized]
	public AppResponse response;

	[NonSerialized]
	public AppBroadcast broadcast;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppMessage instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.response != null)
			{
				instance.response.ResetToPool();
				instance.response = null;
			}
			if (instance.broadcast != null)
			{
				instance.broadcast.ResetToPool();
				instance.broadcast = null;
			}
			Pool.Free<AppMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppMessage instance)
	{
		if (response != null)
		{
			if (instance.response == null)
			{
				instance.response = response.Copy();
			}
			else
			{
				response.CopyTo(instance.response);
			}
		}
		else
		{
			instance.response = null;
		}
		if (broadcast != null)
		{
			if (instance.broadcast == null)
			{
				instance.broadcast = broadcast.Copy();
			}
			else
			{
				broadcast.CopyTo(instance.broadcast);
			}
		}
		else
		{
			instance.broadcast = null;
		}
	}

	public AppMessage Copy()
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		CopyTo(appMessage);
		return appMessage;
	}

	public static AppMessage Deserialize(BufferStream stream)
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		Deserialize(stream, appMessage, isDelta: false);
		return appMessage;
	}

	public static AppMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		DeserializeLengthDelimited(stream, appMessage, isDelta: false);
		return appMessage;
	}

	public static AppMessage DeserializeLength(BufferStream stream, int length)
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		DeserializeLength(stream, length, appMessage, isDelta: false);
		return appMessage;
	}

	public static AppMessage Deserialize(byte[] buffer)
	{
		AppMessage appMessage = Pool.Get<AppMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appMessage, isDelta: false);
		return appMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppMessage Deserialize(BufferStream stream, AppMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.response == null)
				{
					instance.response = AppResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppResponse.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			case 18:
				if (instance.broadcast == null)
				{
					instance.broadcast = AppBroadcast.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppBroadcast.DeserializeLengthDelimited(stream, instance.broadcast, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppMessage DeserializeLengthDelimited(BufferStream stream, AppMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.response == null)
				{
					instance.response = AppResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppResponse.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			case 18:
				if (instance.broadcast == null)
				{
					instance.broadcast = AppBroadcast.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppBroadcast.DeserializeLengthDelimited(stream, instance.broadcast, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppMessage DeserializeLength(BufferStream stream, int length, AppMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.response == null)
				{
					instance.response = AppResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppResponse.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			case 18:
				if (instance.broadcast == null)
				{
					instance.broadcast = AppBroadcast.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppBroadcast.DeserializeLengthDelimited(stream, instance.broadcast, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppMessage instance, AppMessage previous)
	{
		if (instance.response != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppResponse.SerializeDelta(stream, instance.response, previous.response);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.broadcast == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		AppBroadcast.SerializeDelta(stream, instance.broadcast, previous.broadcast);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppMessage instance)
	{
		if (instance.response != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppResponse.Serialize(stream, instance.response);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.broadcast == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		AppBroadcast.Serialize(stream, instance.broadcast);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		response?.InspectUids(action);
		broadcast?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppNewClanMessage : IDisposable, IPooled, IProto<AppNewClanMessage>, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public AppClanMessage message;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppNewClanMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			if (instance.message != null)
			{
				instance.message.ResetToPool();
				instance.message = null;
			}
			Pool.Free<AppNewClanMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppNewClanMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppNewClanMessage instance)
	{
		instance.clanId = clanId;
		if (message != null)
		{
			if (instance.message == null)
			{
				instance.message = message.Copy();
			}
			else
			{
				message.CopyTo(instance.message);
			}
		}
		else
		{
			instance.message = null;
		}
	}

	public AppNewClanMessage Copy()
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		CopyTo(appNewClanMessage);
		return appNewClanMessage;
	}

	public static AppNewClanMessage Deserialize(BufferStream stream)
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		Deserialize(stream, appNewClanMessage, isDelta: false);
		return appNewClanMessage;
	}

	public static AppNewClanMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		DeserializeLengthDelimited(stream, appNewClanMessage, isDelta: false);
		return appNewClanMessage;
	}

	public static AppNewClanMessage DeserializeLength(BufferStream stream, int length)
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		DeserializeLength(stream, length, appNewClanMessage, isDelta: false);
		return appNewClanMessage;
	}

	public static AppNewClanMessage Deserialize(byte[] buffer)
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appNewClanMessage, isDelta: false);
		return appNewClanMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppNewClanMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppNewClanMessage Deserialize(BufferStream stream, AppNewClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.message == null)
				{
					instance.message = AppClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppNewClanMessage DeserializeLengthDelimited(BufferStream stream, AppNewClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.message == null)
				{
					instance.message = AppClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppNewClanMessage DeserializeLength(BufferStream stream, int length, AppNewClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.message == null)
				{
					instance.message = AppClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppNewClanMessage instance, AppNewClanMessage previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppClanMessage.SerializeDelta(stream, instance.message, previous.message);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppNewClanMessage instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppClanMessage.Serialize(stream, instance.message);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		message?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppNewTeamMessage : IDisposable, IPooled, IProto<AppNewTeamMessage>, IProto
{
	[NonSerialized]
	public AppTeamMessage message;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppNewTeamMessage instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.message != null)
			{
				instance.message.ResetToPool();
				instance.message = null;
			}
			Pool.Free<AppNewTeamMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppNewTeamMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppNewTeamMessage instance)
	{
		if (message != null)
		{
			if (instance.message == null)
			{
				instance.message = message.Copy();
			}
			else
			{
				message.CopyTo(instance.message);
			}
		}
		else
		{
			instance.message = null;
		}
	}

	public AppNewTeamMessage Copy()
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		CopyTo(appNewTeamMessage);
		return appNewTeamMessage;
	}

	public static AppNewTeamMessage Deserialize(BufferStream stream)
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		Deserialize(stream, appNewTeamMessage, isDelta: false);
		return appNewTeamMessage;
	}

	public static AppNewTeamMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		DeserializeLengthDelimited(stream, appNewTeamMessage, isDelta: false);
		return appNewTeamMessage;
	}

	public static AppNewTeamMessage DeserializeLength(BufferStream stream, int length)
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		DeserializeLength(stream, length, appNewTeamMessage, isDelta: false);
		return appNewTeamMessage;
	}

	public static AppNewTeamMessage Deserialize(byte[] buffer)
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appNewTeamMessage, isDelta: false);
		return appNewTeamMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppNewTeamMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppNewTeamMessage Deserialize(BufferStream stream, AppNewTeamMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.message == null)
				{
					instance.message = AppTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppNewTeamMessage DeserializeLengthDelimited(BufferStream stream, AppNewTeamMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.message == null)
				{
					instance.message = AppTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppNewTeamMessage DeserializeLength(BufferStream stream, int length, AppNewTeamMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.message == null)
				{
					instance.message = AppTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppNewTeamMessage instance, AppNewTeamMessage previous)
	{
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppTeamMessage.SerializeDelta(stream, instance.message, previous.message);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppNewTeamMessage instance)
	{
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppTeamMessage.Serialize(stream, instance.message);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		message?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppNexusAuth : IDisposable, IPooled, IProto<AppNexusAuth>, IProto
{
	[NonSerialized]
	public string serverId;

	[NonSerialized]
	public int playerToken;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppNexusAuth instance)
	{
		if (instance.ShouldPool)
		{
			instance.serverId = string.Empty;
			instance.playerToken = 0;
			Pool.Free<AppNexusAuth>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppNexusAuth with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppNexusAuth instance)
	{
		instance.serverId = serverId;
		instance.playerToken = playerToken;
	}

	public AppNexusAuth Copy()
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		CopyTo(appNexusAuth);
		return appNexusAuth;
	}

	public static AppNexusAuth Deserialize(BufferStream stream)
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		Deserialize(stream, appNexusAuth, isDelta: false);
		return appNexusAuth;
	}

	public static AppNexusAuth DeserializeLengthDelimited(BufferStream stream)
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		DeserializeLengthDelimited(stream, appNexusAuth, isDelta: false);
		return appNexusAuth;
	}

	public static AppNexusAuth DeserializeLength(BufferStream stream, int length)
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		DeserializeLength(stream, length, appNexusAuth, isDelta: false);
		return appNexusAuth;
	}

	public static AppNexusAuth Deserialize(byte[] buffer)
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appNexusAuth, isDelta: false);
		return appNexusAuth;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppNexusAuth previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppNexusAuth Deserialize(BufferStream stream, AppNexusAuth instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerToken = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.serverId = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppNexusAuth DeserializeLengthDelimited(BufferStream stream, AppNexusAuth instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerToken = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.serverId = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppNexusAuth DeserializeLength(BufferStream stream, int length, AppNexusAuth instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerToken = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.serverId = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppNexusAuth instance, AppNexusAuth previous)
	{
		if (instance.serverId != previous.serverId)
		{
			if (instance.serverId == null)
			{
				throw new ArgumentNullException("serverId", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.serverId);
		}
		if (instance.playerToken != previous.playerToken)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerToken);
		}
	}

	public static void Serialize(BufferStream stream, AppNexusAuth instance)
	{
		if (instance.serverId == null)
		{
			throw new ArgumentNullException("serverId", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.serverId);
		if (instance.playerToken != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerToken);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppPromoteToLeader : IDisposable, IPooled, IProto<AppPromoteToLeader>, IProto
{
	[NonSerialized]
	public ulong steamId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppPromoteToLeader instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			Pool.Free<AppPromoteToLeader>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppPromoteToLeader with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppPromoteToLeader instance)
	{
		instance.steamId = steamId;
	}

	public AppPromoteToLeader Copy()
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		CopyTo(appPromoteToLeader);
		return appPromoteToLeader;
	}

	public static AppPromoteToLeader Deserialize(BufferStream stream)
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		Deserialize(stream, appPromoteToLeader, isDelta: false);
		return appPromoteToLeader;
	}

	public static AppPromoteToLeader DeserializeLengthDelimited(BufferStream stream)
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		DeserializeLengthDelimited(stream, appPromoteToLeader, isDelta: false);
		return appPromoteToLeader;
	}

	public static AppPromoteToLeader DeserializeLength(BufferStream stream, int length)
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		DeserializeLength(stream, length, appPromoteToLeader, isDelta: false);
		return appPromoteToLeader;
	}

	public static AppPromoteToLeader Deserialize(byte[] buffer)
	{
		AppPromoteToLeader appPromoteToLeader = Pool.Get<AppPromoteToLeader>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appPromoteToLeader, isDelta: false);
		return appPromoteToLeader;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppPromoteToLeader previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppPromoteToLeader Deserialize(BufferStream stream, AppPromoteToLeader instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppPromoteToLeader DeserializeLengthDelimited(BufferStream stream, AppPromoteToLeader instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppPromoteToLeader DeserializeLength(BufferStream stream, int length, AppPromoteToLeader instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppPromoteToLeader instance, AppPromoteToLeader previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
	}

	public static void Serialize(BufferStream stream, AppPromoteToLeader instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppRequest : IDisposable, IPooled, IProto<AppRequest>, IProto
{
	[NonSerialized]
	public uint seq;

	[NonSerialized]
	public ulong playerId;

	[NonSerialized]
	public int playerToken;

	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public AppEmpty getInfo;

	[NonSerialized]
	public AppEmpty getTime;

	[NonSerialized]
	public AppEmpty getMap;

	[NonSerialized]
	public AppEmpty getTeamInfo;

	[NonSerialized]
	public AppEmpty getTeamChat;

	[NonSerialized]
	public AppSendMessage sendTeamMessage;

	[NonSerialized]
	public AppEmpty getEntityInfo;

	[NonSerialized]
	public AppSetEntityValue setEntityValue;

	[NonSerialized]
	public AppEmpty checkSubscription;

	[NonSerialized]
	public AppFlag setSubscription;

	[NonSerialized]
	public AppEmpty getMapMarkers;

	[NonSerialized]
	public AppPromoteToLeader promoteToLeader;

	[NonSerialized]
	public AppEmpty getClanInfo;

	[NonSerialized]
	public AppSendMessage setClanMotd;

	[NonSerialized]
	public AppEmpty getClanChat;

	[NonSerialized]
	public AppSendMessage sendClanMessage;

	[NonSerialized]
	public AppGetNexusAuth getNexusAuth;

	[NonSerialized]
	public AppCameraSubscribe cameraSubscribe;

	[NonSerialized]
	public AppEmpty cameraUnsubscribe;

	[NonSerialized]
	public AppCameraInput cameraInput;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.seq = 0u;
			instance.playerId = 0uL;
			instance.playerToken = 0;
			instance.entityId = default(NetworkableId);
			if (instance.getInfo != null)
			{
				instance.getInfo.ResetToPool();
				instance.getInfo = null;
			}
			if (instance.getTime != null)
			{
				instance.getTime.ResetToPool();
				instance.getTime = null;
			}
			if (instance.getMap != null)
			{
				instance.getMap.ResetToPool();
				instance.getMap = null;
			}
			if (instance.getTeamInfo != null)
			{
				instance.getTeamInfo.ResetToPool();
				instance.getTeamInfo = null;
			}
			if (instance.getTeamChat != null)
			{
				instance.getTeamChat.ResetToPool();
				instance.getTeamChat = null;
			}
			if (instance.sendTeamMessage != null)
			{
				instance.sendTeamMessage.ResetToPool();
				instance.sendTeamMessage = null;
			}
			if (instance.getEntityInfo != null)
			{
				instance.getEntityInfo.ResetToPool();
				instance.getEntityInfo = null;
			}
			if (instance.setEntityValue != null)
			{
				instance.setEntityValue.ResetToPool();
				instance.setEntityValue = null;
			}
			if (instance.checkSubscription != null)
			{
				instance.checkSubscription.ResetToPool();
				instance.checkSubscription = null;
			}
			if (instance.setSubscription != null)
			{
				instance.setSubscription.ResetToPool();
				instance.setSubscription = null;
			}
			if (instance.getMapMarkers != null)
			{
				instance.getMapMarkers.ResetToPool();
				instance.getMapMarkers = null;
			}
			if (instance.promoteToLeader != null)
			{
				instance.promoteToLeader.ResetToPool();
				instance.promoteToLeader = null;
			}
			if (instance.getClanInfo != null)
			{
				instance.getClanInfo.ResetToPool();
				instance.getClanInfo = null;
			}
			if (instance.setClanMotd != null)
			{
				instance.setClanMotd.ResetToPool();
				instance.setClanMotd = null;
			}
			if (instance.getClanChat != null)
			{
				instance.getClanChat.ResetToPool();
				instance.getClanChat = null;
			}
			if (instance.sendClanMessage != null)
			{
				instance.sendClanMessage.ResetToPool();
				instance.sendClanMessage = null;
			}
			if (instance.getNexusAuth != null)
			{
				instance.getNexusAuth.ResetToPool();
				instance.getNexusAuth = null;
			}
			if (instance.cameraSubscribe != null)
			{
				instance.cameraSubscribe.ResetToPool();
				instance.cameraSubscribe = null;
			}
			if (instance.cameraUnsubscribe != null)
			{
				instance.cameraUnsubscribe.ResetToPool();
				instance.cameraUnsubscribe = null;
			}
			if (instance.cameraInput != null)
			{
				instance.cameraInput.ResetToPool();
				instance.cameraInput = null;
			}
			Pool.Free<AppRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppRequest instance)
	{
		instance.seq = seq;
		instance.playerId = playerId;
		instance.playerToken = playerToken;
		instance.entityId = entityId;
		if (getInfo != null)
		{
			if (instance.getInfo == null)
			{
				instance.getInfo = getInfo.Copy();
			}
			else
			{
				getInfo.CopyTo(instance.getInfo);
			}
		}
		else
		{
			instance.getInfo = null;
		}
		if (getTime != null)
		{
			if (instance.getTime == null)
			{
				instance.getTime = getTime.Copy();
			}
			else
			{
				getTime.CopyTo(instance.getTime);
			}
		}
		else
		{
			instance.getTime = null;
		}
		if (getMap != null)
		{
			if (instance.getMap == null)
			{
				instance.getMap = getMap.Copy();
			}
			else
			{
				getMap.CopyTo(instance.getMap);
			}
		}
		else
		{
			instance.getMap = null;
		}
		if (getTeamInfo != null)
		{
			if (instance.getTeamInfo == null)
			{
				instance.getTeamInfo = getTeamInfo.Copy();
			}
			else
			{
				getTeamInfo.CopyTo(instance.getTeamInfo);
			}
		}
		else
		{
			instance.getTeamInfo = null;
		}
		if (getTeamChat != null)
		{
			if (instance.getTeamChat == null)
			{
				instance.getTeamChat = getTeamChat.Copy();
			}
			else
			{
				getTeamChat.CopyTo(instance.getTeamChat);
			}
		}
		else
		{
			instance.getTeamChat = null;
		}
		if (sendTeamMessage != null)
		{
			if (instance.sendTeamMessage == null)
			{
				instance.sendTeamMessage = sendTeamMessage.Copy();
			}
			else
			{
				sendTeamMessage.CopyTo(instance.sendTeamMessage);
			}
		}
		else
		{
			instance.sendTeamMessage = null;
		}
		if (getEntityInfo != null)
		{
			if (instance.getEntityInfo == null)
			{
				instance.getEntityInfo = getEntityInfo.Copy();
			}
			else
			{
				getEntityInfo.CopyTo(instance.getEntityInfo);
			}
		}
		else
		{
			instance.getEntityInfo = null;
		}
		if (setEntityValue != null)
		{
			if (instance.setEntityValue == null)
			{
				instance.setEntityValue = setEntityValue.Copy();
			}
			else
			{
				setEntityValue.CopyTo(instance.setEntityValue);
			}
		}
		else
		{
			instance.setEntityValue = null;
		}
		if (checkSubscription != null)
		{
			if (instance.checkSubscription == null)
			{
				instance.checkSubscription = checkSubscription.Copy();
			}
			else
			{
				checkSubscription.CopyTo(instance.checkSubscription);
			}
		}
		else
		{
			instance.checkSubscription = null;
		}
		if (setSubscription != null)
		{
			if (instance.setSubscription == null)
			{
				instance.setSubscription = setSubscription.Copy();
			}
			else
			{
				setSubscription.CopyTo(instance.setSubscription);
			}
		}
		else
		{
			instance.setSubscription = null;
		}
		if (getMapMarkers != null)
		{
			if (instance.getMapMarkers == null)
			{
				instance.getMapMarkers = getMapMarkers.Copy();
			}
			else
			{
				getMapMarkers.CopyTo(instance.getMapMarkers);
			}
		}
		else
		{
			instance.getMapMarkers = null;
		}
		if (promoteToLeader != null)
		{
			if (instance.promoteToLeader == null)
			{
				instance.promoteToLeader = promoteToLeader.Copy();
			}
			else
			{
				promoteToLeader.CopyTo(instance.promoteToLeader);
			}
		}
		else
		{
			instance.promoteToLeader = null;
		}
		if (getClanInfo != null)
		{
			if (instance.getClanInfo == null)
			{
				instance.getClanInfo = getClanInfo.Copy();
			}
			else
			{
				getClanInfo.CopyTo(instance.getClanInfo);
			}
		}
		else
		{
			instance.getClanInfo = null;
		}
		if (setClanMotd != null)
		{
			if (instance.setClanMotd == null)
			{
				instance.setClanMotd = setClanMotd.Copy();
			}
			else
			{
				setClanMotd.CopyTo(instance.setClanMotd);
			}
		}
		else
		{
			instance.setClanMotd = null;
		}
		if (getClanChat != null)
		{
			if (instance.getClanChat == null)
			{
				instance.getClanChat = getClanChat.Copy();
			}
			else
			{
				getClanChat.CopyTo(instance.getClanChat);
			}
		}
		else
		{
			instance.getClanChat = null;
		}
		if (sendClanMessage != null)
		{
			if (instance.sendClanMessage == null)
			{
				instance.sendClanMessage = sendClanMessage.Copy();
			}
			else
			{
				sendClanMessage.CopyTo(instance.sendClanMessage);
			}
		}
		else
		{
			instance.sendClanMessage = null;
		}
		if (getNexusAuth != null)
		{
			if (instance.getNexusAuth == null)
			{
				instance.getNexusAuth = getNexusAuth.Copy();
			}
			else
			{
				getNexusAuth.CopyTo(instance.getNexusAuth);
			}
		}
		else
		{
			instance.getNexusAuth = null;
		}
		if (cameraSubscribe != null)
		{
			if (instance.cameraSubscribe == null)
			{
				instance.cameraSubscribe = cameraSubscribe.Copy();
			}
			else
			{
				cameraSubscribe.CopyTo(instance.cameraSubscribe);
			}
		}
		else
		{
			instance.cameraSubscribe = null;
		}
		if (cameraUnsubscribe != null)
		{
			if (instance.cameraUnsubscribe == null)
			{
				instance.cameraUnsubscribe = cameraUnsubscribe.Copy();
			}
			else
			{
				cameraUnsubscribe.CopyTo(instance.cameraUnsubscribe);
			}
		}
		else
		{
			instance.cameraUnsubscribe = null;
		}
		if (cameraInput != null)
		{
			if (instance.cameraInput == null)
			{
				instance.cameraInput = cameraInput.Copy();
			}
			else
			{
				cameraInput.CopyTo(instance.cameraInput);
			}
		}
		else
		{
			instance.cameraInput = null;
		}
	}

	public AppRequest Copy()
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		CopyTo(appRequest);
		return appRequest;
	}

	public static AppRequest Deserialize(BufferStream stream)
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		Deserialize(stream, appRequest, isDelta: false);
		return appRequest;
	}

	public static AppRequest DeserializeLengthDelimited(BufferStream stream)
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		DeserializeLengthDelimited(stream, appRequest, isDelta: false);
		return appRequest;
	}

	public static AppRequest DeserializeLength(BufferStream stream, int length)
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		DeserializeLength(stream, length, appRequest, isDelta: false);
		return appRequest;
	}

	public static AppRequest Deserialize(byte[] buffer)
	{
		AppRequest appRequest = Pool.Get<AppRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appRequest, isDelta: false);
		return appRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppRequest Deserialize(BufferStream stream, AppRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
			instance.playerId = 0uL;
			instance.playerToken = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 66:
				if (instance.getInfo == null)
				{
					instance.getInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getInfo, isDelta);
				}
				continue;
			case 74:
				if (instance.getTime == null)
				{
					instance.getTime = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTime, isDelta);
				}
				continue;
			case 82:
				if (instance.getMap == null)
				{
					instance.getMap = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getMap, isDelta);
				}
				continue;
			case 90:
				if (instance.getTeamInfo == null)
				{
					instance.getTeamInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.getTeamChat == null)
				{
					instance.getTeamChat = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamChat, isDelta);
				}
				continue;
			case 106:
				if (instance.sendTeamMessage == null)
				{
					instance.sendTeamMessage = AppSendMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSendMessage.DeserializeLengthDelimited(stream, instance.sendTeamMessage, isDelta);
				}
				continue;
			case 114:
				if (instance.getEntityInfo == null)
				{
					instance.getEntityInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getEntityInfo, isDelta);
				}
				continue;
			case 122:
				if (instance.setEntityValue == null)
				{
					instance.setEntityValue = AppSetEntityValue.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSetEntityValue.DeserializeLengthDelimited(stream, instance.setEntityValue, isDelta);
				}
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.checkSubscription == null)
					{
						instance.checkSubscription = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.checkSubscription, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setSubscription == null)
					{
						instance.setSubscription = AppFlag.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppFlag.DeserializeLengthDelimited(stream, instance.setSubscription, isDelta);
					}
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getMapMarkers == null)
					{
						instance.getMapMarkers = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getMapMarkers, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.promoteToLeader == null)
					{
						instance.promoteToLeader = AppPromoteToLeader.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppPromoteToLeader.DeserializeLengthDelimited(stream, instance.promoteToLeader, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanInfo == null)
					{
						instance.getClanInfo = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanInfo, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setClanMotd == null)
					{
						instance.setClanMotd = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.setClanMotd, isDelta);
					}
				}
				break;
			case 23u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanChat == null)
					{
						instance.getClanChat = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanChat, isDelta);
					}
				}
				break;
			case 24u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.sendClanMessage == null)
					{
						instance.sendClanMessage = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.sendClanMessage, isDelta);
					}
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getNexusAuth == null)
					{
						instance.getNexusAuth = AppGetNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppGetNexusAuth.DeserializeLengthDelimited(stream, instance.getNexusAuth, isDelta);
					}
				}
				break;
			case 30u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribe == null)
					{
						instance.cameraSubscribe = AppCameraSubscribe.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraSubscribe.DeserializeLengthDelimited(stream, instance.cameraSubscribe, isDelta);
					}
				}
				break;
			case 31u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraUnsubscribe == null)
					{
						instance.cameraUnsubscribe = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.cameraUnsubscribe, isDelta);
					}
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraInput == null)
					{
						instance.cameraInput = AppCameraInput.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInput.DeserializeLengthDelimited(stream, instance.cameraInput, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static AppRequest DeserializeLengthDelimited(BufferStream stream, AppRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
			instance.playerId = 0uL;
			instance.playerToken = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 66:
				if (instance.getInfo == null)
				{
					instance.getInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getInfo, isDelta);
				}
				continue;
			case 74:
				if (instance.getTime == null)
				{
					instance.getTime = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTime, isDelta);
				}
				continue;
			case 82:
				if (instance.getMap == null)
				{
					instance.getMap = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getMap, isDelta);
				}
				continue;
			case 90:
				if (instance.getTeamInfo == null)
				{
					instance.getTeamInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.getTeamChat == null)
				{
					instance.getTeamChat = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamChat, isDelta);
				}
				continue;
			case 106:
				if (instance.sendTeamMessage == null)
				{
					instance.sendTeamMessage = AppSendMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSendMessage.DeserializeLengthDelimited(stream, instance.sendTeamMessage, isDelta);
				}
				continue;
			case 114:
				if (instance.getEntityInfo == null)
				{
					instance.getEntityInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getEntityInfo, isDelta);
				}
				continue;
			case 122:
				if (instance.setEntityValue == null)
				{
					instance.setEntityValue = AppSetEntityValue.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSetEntityValue.DeserializeLengthDelimited(stream, instance.setEntityValue, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.checkSubscription == null)
					{
						instance.checkSubscription = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.checkSubscription, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setSubscription == null)
					{
						instance.setSubscription = AppFlag.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppFlag.DeserializeLengthDelimited(stream, instance.setSubscription, isDelta);
					}
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getMapMarkers == null)
					{
						instance.getMapMarkers = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getMapMarkers, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.promoteToLeader == null)
					{
						instance.promoteToLeader = AppPromoteToLeader.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppPromoteToLeader.DeserializeLengthDelimited(stream, instance.promoteToLeader, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanInfo == null)
					{
						instance.getClanInfo = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanInfo, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setClanMotd == null)
					{
						instance.setClanMotd = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.setClanMotd, isDelta);
					}
				}
				break;
			case 23u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanChat == null)
					{
						instance.getClanChat = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanChat, isDelta);
					}
				}
				break;
			case 24u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.sendClanMessage == null)
					{
						instance.sendClanMessage = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.sendClanMessage, isDelta);
					}
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getNexusAuth == null)
					{
						instance.getNexusAuth = AppGetNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppGetNexusAuth.DeserializeLengthDelimited(stream, instance.getNexusAuth, isDelta);
					}
				}
				break;
			case 30u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribe == null)
					{
						instance.cameraSubscribe = AppCameraSubscribe.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraSubscribe.DeserializeLengthDelimited(stream, instance.cameraSubscribe, isDelta);
					}
				}
				break;
			case 31u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraUnsubscribe == null)
					{
						instance.cameraUnsubscribe = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.cameraUnsubscribe, isDelta);
					}
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraInput == null)
					{
						instance.cameraInput = AppCameraInput.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInput.DeserializeLengthDelimited(stream, instance.cameraInput, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppRequest DeserializeLength(BufferStream stream, int length, AppRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
			instance.playerId = 0uL;
			instance.playerToken = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 66:
				if (instance.getInfo == null)
				{
					instance.getInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getInfo, isDelta);
				}
				continue;
			case 74:
				if (instance.getTime == null)
				{
					instance.getTime = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTime, isDelta);
				}
				continue;
			case 82:
				if (instance.getMap == null)
				{
					instance.getMap = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getMap, isDelta);
				}
				continue;
			case 90:
				if (instance.getTeamInfo == null)
				{
					instance.getTeamInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.getTeamChat == null)
				{
					instance.getTeamChat = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getTeamChat, isDelta);
				}
				continue;
			case 106:
				if (instance.sendTeamMessage == null)
				{
					instance.sendTeamMessage = AppSendMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSendMessage.DeserializeLengthDelimited(stream, instance.sendTeamMessage, isDelta);
				}
				continue;
			case 114:
				if (instance.getEntityInfo == null)
				{
					instance.getEntityInfo = AppEmpty.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEmpty.DeserializeLengthDelimited(stream, instance.getEntityInfo, isDelta);
				}
				continue;
			case 122:
				if (instance.setEntityValue == null)
				{
					instance.setEntityValue = AppSetEntityValue.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSetEntityValue.DeserializeLengthDelimited(stream, instance.setEntityValue, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.checkSubscription == null)
					{
						instance.checkSubscription = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.checkSubscription, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setSubscription == null)
					{
						instance.setSubscription = AppFlag.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppFlag.DeserializeLengthDelimited(stream, instance.setSubscription, isDelta);
					}
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getMapMarkers == null)
					{
						instance.getMapMarkers = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getMapMarkers, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.promoteToLeader == null)
					{
						instance.promoteToLeader = AppPromoteToLeader.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppPromoteToLeader.DeserializeLengthDelimited(stream, instance.promoteToLeader, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanInfo == null)
					{
						instance.getClanInfo = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanInfo, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.setClanMotd == null)
					{
						instance.setClanMotd = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.setClanMotd, isDelta);
					}
				}
				break;
			case 23u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getClanChat == null)
					{
						instance.getClanChat = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.getClanChat, isDelta);
					}
				}
				break;
			case 24u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.sendClanMessage == null)
					{
						instance.sendClanMessage = AppSendMessage.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppSendMessage.DeserializeLengthDelimited(stream, instance.sendClanMessage, isDelta);
					}
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.getNexusAuth == null)
					{
						instance.getNexusAuth = AppGetNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppGetNexusAuth.DeserializeLengthDelimited(stream, instance.getNexusAuth, isDelta);
					}
				}
				break;
			case 30u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribe == null)
					{
						instance.cameraSubscribe = AppCameraSubscribe.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraSubscribe.DeserializeLengthDelimited(stream, instance.cameraSubscribe, isDelta);
					}
				}
				break;
			case 31u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraUnsubscribe == null)
					{
						instance.cameraUnsubscribe = AppEmpty.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppEmpty.DeserializeLengthDelimited(stream, instance.cameraUnsubscribe, isDelta);
					}
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraInput == null)
					{
						instance.cameraInput = AppCameraInput.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInput.DeserializeLengthDelimited(stream, instance.cameraInput, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppRequest instance, AppRequest previous)
	{
		if (instance.seq != previous.seq)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seq);
		}
		if (instance.playerId != previous.playerId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.playerToken != previous.playerToken)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerToken);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		if (instance.getInfo != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getInfo, previous.getInfo);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.getTime != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getTime, previous.getTime);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTime (ProtoBuf.AppEmpty)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.getMap != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getMap, previous.getMap);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getMap (ProtoBuf.AppEmpty)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.getTeamInfo != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getTeamInfo, previous.getTeamInfo);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTeamInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.getTeamChat != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getTeamChat, previous.getTeamChat);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTeamChat (ProtoBuf.AppEmpty)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.sendTeamMessage != null)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			AppSendMessage.SerializeDelta(stream, instance.sendTeamMessage, previous.sendTeamMessage);
			int val = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val, span6, 0);
			if (num6 < 5)
			{
				span6[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span6[num6++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.getEntityInfo != null)
		{
			stream.WriteByte(114);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getEntityInfo, previous.getEntityInfo);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getEntityInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.setEntityValue != null)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			AppSetEntityValue.SerializeDelta(stream, instance.setEntityValue, previous.setEntityValue);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field setEntityValue (ProtoBuf.AppSetEntityValue)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
		if (instance.checkSubscription != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.checkSubscription, previous.checkSubscription);
			int num9 = stream.Position - position9;
			if (num9 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field checkSubscription (ProtoBuf.AppEmpty)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num9, span9, 0);
		}
		if (instance.setSubscription != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(1);
			BufferStream.RangeHandle range10 = stream.GetRange(1);
			int position10 = stream.Position;
			AppFlag.SerializeDelta(stream, instance.setSubscription, previous.setSubscription);
			int num10 = stream.Position - position10;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field setSubscription (ProtoBuf.AppFlag)");
			}
			Span<byte> span10 = range10.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		}
		if (instance.getMapMarkers != null)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			BufferStream.RangeHandle range11 = stream.GetRange(1);
			int position11 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getMapMarkers, previous.getMapMarkers);
			int num11 = stream.Position - position11;
			if (num11 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getMapMarkers (ProtoBuf.AppEmpty)");
			}
			Span<byte> span11 = range11.GetSpan();
			ProtocolParser.WriteUInt32((uint)num11, span11, 0);
		}
		if (instance.promoteToLeader != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range12 = stream.GetRange(1);
			int position12 = stream.Position;
			AppPromoteToLeader.SerializeDelta(stream, instance.promoteToLeader, previous.promoteToLeader);
			int num12 = stream.Position - position12;
			if (num12 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field promoteToLeader (ProtoBuf.AppPromoteToLeader)");
			}
			Span<byte> span12 = range12.GetSpan();
			ProtocolParser.WriteUInt32((uint)num12, span12, 0);
		}
		if (instance.getClanInfo != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range13 = stream.GetRange(1);
			int position13 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getClanInfo, previous.getClanInfo);
			int num13 = stream.Position - position13;
			if (num13 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getClanInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span13 = range13.GetSpan();
			ProtocolParser.WriteUInt32((uint)num13, span13, 0);
		}
		if (instance.setClanMotd != null)
		{
			stream.WriteByte(178);
			stream.WriteByte(1);
			BufferStream.RangeHandle range14 = stream.GetRange(5);
			int position14 = stream.Position;
			AppSendMessage.SerializeDelta(stream, instance.setClanMotd, previous.setClanMotd);
			int val2 = stream.Position - position14;
			Span<byte> span14 = range14.GetSpan();
			int num14 = ProtocolParser.WriteUInt32((uint)val2, span14, 0);
			if (num14 < 5)
			{
				span14[num14 - 1] |= 128;
				while (num14 < 4)
				{
					span14[num14++] = 128;
				}
				span14[4] = 0;
			}
		}
		if (instance.getClanChat != null)
		{
			stream.WriteByte(186);
			stream.WriteByte(1);
			BufferStream.RangeHandle range15 = stream.GetRange(1);
			int position15 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.getClanChat, previous.getClanChat);
			int num15 = stream.Position - position15;
			if (num15 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getClanChat (ProtoBuf.AppEmpty)");
			}
			Span<byte> span15 = range15.GetSpan();
			ProtocolParser.WriteUInt32((uint)num15, span15, 0);
		}
		if (instance.sendClanMessage != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(1);
			BufferStream.RangeHandle range16 = stream.GetRange(5);
			int position16 = stream.Position;
			AppSendMessage.SerializeDelta(stream, instance.sendClanMessage, previous.sendClanMessage);
			int val3 = stream.Position - position16;
			Span<byte> span16 = range16.GetSpan();
			int num16 = ProtocolParser.WriteUInt32((uint)val3, span16, 0);
			if (num16 < 5)
			{
				span16[num16 - 1] |= 128;
				while (num16 < 4)
				{
					span16[num16++] = 128;
				}
				span16[4] = 0;
			}
		}
		if (instance.getNexusAuth != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(1);
			BufferStream.RangeHandle range17 = stream.GetRange(5);
			int position17 = stream.Position;
			AppGetNexusAuth.SerializeDelta(stream, instance.getNexusAuth, previous.getNexusAuth);
			int val4 = stream.Position - position17;
			Span<byte> span17 = range17.GetSpan();
			int num17 = ProtocolParser.WriteUInt32((uint)val4, span17, 0);
			if (num17 < 5)
			{
				span17[num17 - 1] |= 128;
				while (num17 < 4)
				{
					span17[num17++] = 128;
				}
				span17[4] = 0;
			}
		}
		if (instance.cameraSubscribe != null)
		{
			stream.WriteByte(242);
			stream.WriteByte(1);
			BufferStream.RangeHandle range18 = stream.GetRange(5);
			int position18 = stream.Position;
			AppCameraSubscribe.SerializeDelta(stream, instance.cameraSubscribe, previous.cameraSubscribe);
			int val5 = stream.Position - position18;
			Span<byte> span18 = range18.GetSpan();
			int num18 = ProtocolParser.WriteUInt32((uint)val5, span18, 0);
			if (num18 < 5)
			{
				span18[num18 - 1] |= 128;
				while (num18 < 4)
				{
					span18[num18++] = 128;
				}
				span18[4] = 0;
			}
		}
		if (instance.cameraUnsubscribe != null)
		{
			stream.WriteByte(250);
			stream.WriteByte(1);
			BufferStream.RangeHandle range19 = stream.GetRange(1);
			int position19 = stream.Position;
			AppEmpty.SerializeDelta(stream, instance.cameraUnsubscribe, previous.cameraUnsubscribe);
			int num19 = stream.Position - position19;
			if (num19 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraUnsubscribe (ProtoBuf.AppEmpty)");
			}
			Span<byte> span19 = range19.GetSpan();
			ProtocolParser.WriteUInt32((uint)num19, span19, 0);
		}
		if (instance.cameraInput != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(2);
			BufferStream.RangeHandle range20 = stream.GetRange(1);
			int position20 = stream.Position;
			AppCameraInput.SerializeDelta(stream, instance.cameraInput, previous.cameraInput);
			int num20 = stream.Position - position20;
			if (num20 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraInput (ProtoBuf.AppCameraInput)");
			}
			Span<byte> span20 = range20.GetSpan();
			ProtocolParser.WriteUInt32((uint)num20, span20, 0);
		}
	}

	public static void Serialize(BufferStream stream, AppRequest instance)
	{
		if (instance.seq != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seq);
		}
		if (instance.playerId != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.playerToken != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerToken);
		}
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.getInfo != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			AppEmpty.Serialize(stream, instance.getInfo);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.getTime != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			AppEmpty.Serialize(stream, instance.getTime);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTime (ProtoBuf.AppEmpty)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.getMap != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			AppEmpty.Serialize(stream, instance.getMap);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getMap (ProtoBuf.AppEmpty)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.getTeamInfo != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			AppEmpty.Serialize(stream, instance.getTeamInfo);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTeamInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.getTeamChat != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			AppEmpty.Serialize(stream, instance.getTeamChat);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getTeamChat (ProtoBuf.AppEmpty)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.sendTeamMessage != null)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			AppSendMessage.Serialize(stream, instance.sendTeamMessage);
			int val = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val, span6, 0);
			if (num6 < 5)
			{
				span6[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span6[num6++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.getEntityInfo != null)
		{
			stream.WriteByte(114);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			AppEmpty.Serialize(stream, instance.getEntityInfo);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getEntityInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.setEntityValue != null)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			AppSetEntityValue.Serialize(stream, instance.setEntityValue);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field setEntityValue (ProtoBuf.AppSetEntityValue)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
		if (instance.checkSubscription != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AppEmpty.Serialize(stream, instance.checkSubscription);
			int num9 = stream.Position - position9;
			if (num9 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field checkSubscription (ProtoBuf.AppEmpty)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num9, span9, 0);
		}
		if (instance.setSubscription != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(1);
			BufferStream.RangeHandle range10 = stream.GetRange(1);
			int position10 = stream.Position;
			AppFlag.Serialize(stream, instance.setSubscription);
			int num10 = stream.Position - position10;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field setSubscription (ProtoBuf.AppFlag)");
			}
			Span<byte> span10 = range10.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		}
		if (instance.getMapMarkers != null)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			BufferStream.RangeHandle range11 = stream.GetRange(1);
			int position11 = stream.Position;
			AppEmpty.Serialize(stream, instance.getMapMarkers);
			int num11 = stream.Position - position11;
			if (num11 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getMapMarkers (ProtoBuf.AppEmpty)");
			}
			Span<byte> span11 = range11.GetSpan();
			ProtocolParser.WriteUInt32((uint)num11, span11, 0);
		}
		if (instance.promoteToLeader != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range12 = stream.GetRange(1);
			int position12 = stream.Position;
			AppPromoteToLeader.Serialize(stream, instance.promoteToLeader);
			int num12 = stream.Position - position12;
			if (num12 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field promoteToLeader (ProtoBuf.AppPromoteToLeader)");
			}
			Span<byte> span12 = range12.GetSpan();
			ProtocolParser.WriteUInt32((uint)num12, span12, 0);
		}
		if (instance.getClanInfo != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range13 = stream.GetRange(1);
			int position13 = stream.Position;
			AppEmpty.Serialize(stream, instance.getClanInfo);
			int num13 = stream.Position - position13;
			if (num13 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getClanInfo (ProtoBuf.AppEmpty)");
			}
			Span<byte> span13 = range13.GetSpan();
			ProtocolParser.WriteUInt32((uint)num13, span13, 0);
		}
		if (instance.setClanMotd != null)
		{
			stream.WriteByte(178);
			stream.WriteByte(1);
			BufferStream.RangeHandle range14 = stream.GetRange(5);
			int position14 = stream.Position;
			AppSendMessage.Serialize(stream, instance.setClanMotd);
			int val2 = stream.Position - position14;
			Span<byte> span14 = range14.GetSpan();
			int num14 = ProtocolParser.WriteUInt32((uint)val2, span14, 0);
			if (num14 < 5)
			{
				span14[num14 - 1] |= 128;
				while (num14 < 4)
				{
					span14[num14++] = 128;
				}
				span14[4] = 0;
			}
		}
		if (instance.getClanChat != null)
		{
			stream.WriteByte(186);
			stream.WriteByte(1);
			BufferStream.RangeHandle range15 = stream.GetRange(1);
			int position15 = stream.Position;
			AppEmpty.Serialize(stream, instance.getClanChat);
			int num15 = stream.Position - position15;
			if (num15 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field getClanChat (ProtoBuf.AppEmpty)");
			}
			Span<byte> span15 = range15.GetSpan();
			ProtocolParser.WriteUInt32((uint)num15, span15, 0);
		}
		if (instance.sendClanMessage != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(1);
			BufferStream.RangeHandle range16 = stream.GetRange(5);
			int position16 = stream.Position;
			AppSendMessage.Serialize(stream, instance.sendClanMessage);
			int val3 = stream.Position - position16;
			Span<byte> span16 = range16.GetSpan();
			int num16 = ProtocolParser.WriteUInt32((uint)val3, span16, 0);
			if (num16 < 5)
			{
				span16[num16 - 1] |= 128;
				while (num16 < 4)
				{
					span16[num16++] = 128;
				}
				span16[4] = 0;
			}
		}
		if (instance.getNexusAuth != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(1);
			BufferStream.RangeHandle range17 = stream.GetRange(5);
			int position17 = stream.Position;
			AppGetNexusAuth.Serialize(stream, instance.getNexusAuth);
			int val4 = stream.Position - position17;
			Span<byte> span17 = range17.GetSpan();
			int num17 = ProtocolParser.WriteUInt32((uint)val4, span17, 0);
			if (num17 < 5)
			{
				span17[num17 - 1] |= 128;
				while (num17 < 4)
				{
					span17[num17++] = 128;
				}
				span17[4] = 0;
			}
		}
		if (instance.cameraSubscribe != null)
		{
			stream.WriteByte(242);
			stream.WriteByte(1);
			BufferStream.RangeHandle range18 = stream.GetRange(5);
			int position18 = stream.Position;
			AppCameraSubscribe.Serialize(stream, instance.cameraSubscribe);
			int val5 = stream.Position - position18;
			Span<byte> span18 = range18.GetSpan();
			int num18 = ProtocolParser.WriteUInt32((uint)val5, span18, 0);
			if (num18 < 5)
			{
				span18[num18 - 1] |= 128;
				while (num18 < 4)
				{
					span18[num18++] = 128;
				}
				span18[4] = 0;
			}
		}
		if (instance.cameraUnsubscribe != null)
		{
			stream.WriteByte(250);
			stream.WriteByte(1);
			BufferStream.RangeHandle range19 = stream.GetRange(1);
			int position19 = stream.Position;
			AppEmpty.Serialize(stream, instance.cameraUnsubscribe);
			int num19 = stream.Position - position19;
			if (num19 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraUnsubscribe (ProtoBuf.AppEmpty)");
			}
			Span<byte> span19 = range19.GetSpan();
			ProtocolParser.WriteUInt32((uint)num19, span19, 0);
		}
		if (instance.cameraInput != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(2);
			BufferStream.RangeHandle range20 = stream.GetRange(1);
			int position20 = stream.Position;
			AppCameraInput.Serialize(stream, instance.cameraInput);
			int num20 = stream.Position - position20;
			if (num20 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraInput (ProtoBuf.AppCameraInput)");
			}
			Span<byte> span20 = range20.GetSpan();
			ProtocolParser.WriteUInt32((uint)num20, span20, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
		getInfo?.InspectUids(action);
		getTime?.InspectUids(action);
		getMap?.InspectUids(action);
		getTeamInfo?.InspectUids(action);
		getTeamChat?.InspectUids(action);
		sendTeamMessage?.InspectUids(action);
		getEntityInfo?.InspectUids(action);
		setEntityValue?.InspectUids(action);
		checkSubscription?.InspectUids(action);
		setSubscription?.InspectUids(action);
		getMapMarkers?.InspectUids(action);
		promoteToLeader?.InspectUids(action);
		getClanInfo?.InspectUids(action);
		setClanMotd?.InspectUids(action);
		getClanChat?.InspectUids(action);
		sendClanMessage?.InspectUids(action);
		getNexusAuth?.InspectUids(action);
		cameraSubscribe?.InspectUids(action);
		cameraUnsubscribe?.InspectUids(action);
		cameraInput?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppResponse : IDisposable, IPooled, IProto<AppResponse>, IProto
{
	[NonSerialized]
	public uint seq;

	[NonSerialized]
	public AppSuccess success;

	[NonSerialized]
	public AppError error;

	[NonSerialized]
	public AppInfo info;

	[NonSerialized]
	public AppTime time;

	[NonSerialized]
	public AppMap map;

	[NonSerialized]
	public AppTeamInfo teamInfo;

	[NonSerialized]
	public AppTeamChat teamChat;

	[NonSerialized]
	public AppEntityInfo entityInfo;

	[NonSerialized]
	public AppFlag flag;

	[NonSerialized]
	public AppMapMarkers mapMarkers;

	[NonSerialized]
	public AppClanInfo clanInfo;

	[NonSerialized]
	public AppClanChat clanChat;

	[NonSerialized]
	public AppNexusAuth nexusAuth;

	[NonSerialized]
	public AppCameraInfo cameraSubscribeInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppResponse instance)
	{
		if (instance.ShouldPool)
		{
			instance.seq = 0u;
			if (instance.success != null)
			{
				instance.success.ResetToPool();
				instance.success = null;
			}
			if (instance.error != null)
			{
				instance.error.ResetToPool();
				instance.error = null;
			}
			if (instance.info != null)
			{
				instance.info.ResetToPool();
				instance.info = null;
			}
			if (instance.time != null)
			{
				instance.time.ResetToPool();
				instance.time = null;
			}
			if (instance.map != null)
			{
				instance.map.ResetToPool();
				instance.map = null;
			}
			if (instance.teamInfo != null)
			{
				instance.teamInfo.ResetToPool();
				instance.teamInfo = null;
			}
			if (instance.teamChat != null)
			{
				instance.teamChat.ResetToPool();
				instance.teamChat = null;
			}
			if (instance.entityInfo != null)
			{
				instance.entityInfo.ResetToPool();
				instance.entityInfo = null;
			}
			if (instance.flag != null)
			{
				instance.flag.ResetToPool();
				instance.flag = null;
			}
			if (instance.mapMarkers != null)
			{
				instance.mapMarkers.ResetToPool();
				instance.mapMarkers = null;
			}
			if (instance.clanInfo != null)
			{
				instance.clanInfo.ResetToPool();
				instance.clanInfo = null;
			}
			if (instance.clanChat != null)
			{
				instance.clanChat.ResetToPool();
				instance.clanChat = null;
			}
			if (instance.nexusAuth != null)
			{
				instance.nexusAuth.ResetToPool();
				instance.nexusAuth = null;
			}
			if (instance.cameraSubscribeInfo != null)
			{
				instance.cameraSubscribeInfo.ResetToPool();
				instance.cameraSubscribeInfo = null;
			}
			Pool.Free<AppResponse>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppResponse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppResponse instance)
	{
		instance.seq = seq;
		if (success != null)
		{
			if (instance.success == null)
			{
				instance.success = success.Copy();
			}
			else
			{
				success.CopyTo(instance.success);
			}
		}
		else
		{
			instance.success = null;
		}
		if (error != null)
		{
			if (instance.error == null)
			{
				instance.error = error.Copy();
			}
			else
			{
				error.CopyTo(instance.error);
			}
		}
		else
		{
			instance.error = null;
		}
		if (info != null)
		{
			if (instance.info == null)
			{
				instance.info = info.Copy();
			}
			else
			{
				info.CopyTo(instance.info);
			}
		}
		else
		{
			instance.info = null;
		}
		if (time != null)
		{
			if (instance.time == null)
			{
				instance.time = time.Copy();
			}
			else
			{
				time.CopyTo(instance.time);
			}
		}
		else
		{
			instance.time = null;
		}
		if (map != null)
		{
			if (instance.map == null)
			{
				instance.map = map.Copy();
			}
			else
			{
				map.CopyTo(instance.map);
			}
		}
		else
		{
			instance.map = null;
		}
		if (teamInfo != null)
		{
			if (instance.teamInfo == null)
			{
				instance.teamInfo = teamInfo.Copy();
			}
			else
			{
				teamInfo.CopyTo(instance.teamInfo);
			}
		}
		else
		{
			instance.teamInfo = null;
		}
		if (teamChat != null)
		{
			if (instance.teamChat == null)
			{
				instance.teamChat = teamChat.Copy();
			}
			else
			{
				teamChat.CopyTo(instance.teamChat);
			}
		}
		else
		{
			instance.teamChat = null;
		}
		if (entityInfo != null)
		{
			if (instance.entityInfo == null)
			{
				instance.entityInfo = entityInfo.Copy();
			}
			else
			{
				entityInfo.CopyTo(instance.entityInfo);
			}
		}
		else
		{
			instance.entityInfo = null;
		}
		if (flag != null)
		{
			if (instance.flag == null)
			{
				instance.flag = flag.Copy();
			}
			else
			{
				flag.CopyTo(instance.flag);
			}
		}
		else
		{
			instance.flag = null;
		}
		if (mapMarkers != null)
		{
			if (instance.mapMarkers == null)
			{
				instance.mapMarkers = mapMarkers.Copy();
			}
			else
			{
				mapMarkers.CopyTo(instance.mapMarkers);
			}
		}
		else
		{
			instance.mapMarkers = null;
		}
		if (clanInfo != null)
		{
			if (instance.clanInfo == null)
			{
				instance.clanInfo = clanInfo.Copy();
			}
			else
			{
				clanInfo.CopyTo(instance.clanInfo);
			}
		}
		else
		{
			instance.clanInfo = null;
		}
		if (clanChat != null)
		{
			if (instance.clanChat == null)
			{
				instance.clanChat = clanChat.Copy();
			}
			else
			{
				clanChat.CopyTo(instance.clanChat);
			}
		}
		else
		{
			instance.clanChat = null;
		}
		if (nexusAuth != null)
		{
			if (instance.nexusAuth == null)
			{
				instance.nexusAuth = nexusAuth.Copy();
			}
			else
			{
				nexusAuth.CopyTo(instance.nexusAuth);
			}
		}
		else
		{
			instance.nexusAuth = null;
		}
		if (cameraSubscribeInfo != null)
		{
			if (instance.cameraSubscribeInfo == null)
			{
				instance.cameraSubscribeInfo = cameraSubscribeInfo.Copy();
			}
			else
			{
				cameraSubscribeInfo.CopyTo(instance.cameraSubscribeInfo);
			}
		}
		else
		{
			instance.cameraSubscribeInfo = null;
		}
	}

	public AppResponse Copy()
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		CopyTo(appResponse);
		return appResponse;
	}

	public static AppResponse Deserialize(BufferStream stream)
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		Deserialize(stream, appResponse, isDelta: false);
		return appResponse;
	}

	public static AppResponse DeserializeLengthDelimited(BufferStream stream)
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		DeserializeLengthDelimited(stream, appResponse, isDelta: false);
		return appResponse;
	}

	public static AppResponse DeserializeLength(BufferStream stream, int length)
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		DeserializeLength(stream, length, appResponse, isDelta: false);
		return appResponse;
	}

	public static AppResponse Deserialize(byte[] buffer)
	{
		AppResponse appResponse = Pool.Get<AppResponse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appResponse, isDelta: false);
		return appResponse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppResponse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppResponse Deserialize(BufferStream stream, AppResponse instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				if (instance.success == null)
				{
					instance.success = AppSuccess.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSuccess.DeserializeLengthDelimited(stream, instance.success, isDelta);
				}
				continue;
			case 42:
				if (instance.error == null)
				{
					instance.error = AppError.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppError.DeserializeLengthDelimited(stream, instance.error, isDelta);
				}
				continue;
			case 50:
				if (instance.info == null)
				{
					instance.info = AppInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				continue;
			case 58:
				if (instance.time == null)
				{
					instance.time = AppTime.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTime.DeserializeLengthDelimited(stream, instance.time, isDelta);
				}
				continue;
			case 66:
				if (instance.map == null)
				{
					instance.map = AppMap.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMap.DeserializeLengthDelimited(stream, instance.map, isDelta);
				}
				continue;
			case 74:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				continue;
			case 82:
				if (instance.teamChat == null)
				{
					instance.teamChat = AppTeamChat.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChat.DeserializeLengthDelimited(stream, instance.teamChat, isDelta);
				}
				continue;
			case 90:
				if (instance.entityInfo == null)
				{
					instance.entityInfo = AppEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityInfo.DeserializeLengthDelimited(stream, instance.entityInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.flag == null)
				{
					instance.flag = AppFlag.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppFlag.DeserializeLengthDelimited(stream, instance.flag, isDelta);
				}
				continue;
			case 106:
				if (instance.mapMarkers == null)
				{
					instance.mapMarkers = AppMapMarkers.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMapMarkers.DeserializeLengthDelimited(stream, instance.mapMarkers, isDelta);
				}
				continue;
			case 122:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = AppClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.clanChat == null)
					{
						instance.clanChat = AppClanChat.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppClanChat.DeserializeLengthDelimited(stream, instance.clanChat, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.nexusAuth == null)
					{
						instance.nexusAuth = AppNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppNexusAuth.DeserializeLengthDelimited(stream, instance.nexusAuth, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribeInfo == null)
					{
						instance.cameraSubscribeInfo = AppCameraInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInfo.DeserializeLengthDelimited(stream, instance.cameraSubscribeInfo, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static AppResponse DeserializeLengthDelimited(BufferStream stream, AppResponse instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				if (instance.success == null)
				{
					instance.success = AppSuccess.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSuccess.DeserializeLengthDelimited(stream, instance.success, isDelta);
				}
				continue;
			case 42:
				if (instance.error == null)
				{
					instance.error = AppError.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppError.DeserializeLengthDelimited(stream, instance.error, isDelta);
				}
				continue;
			case 50:
				if (instance.info == null)
				{
					instance.info = AppInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				continue;
			case 58:
				if (instance.time == null)
				{
					instance.time = AppTime.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTime.DeserializeLengthDelimited(stream, instance.time, isDelta);
				}
				continue;
			case 66:
				if (instance.map == null)
				{
					instance.map = AppMap.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMap.DeserializeLengthDelimited(stream, instance.map, isDelta);
				}
				continue;
			case 74:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				continue;
			case 82:
				if (instance.teamChat == null)
				{
					instance.teamChat = AppTeamChat.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChat.DeserializeLengthDelimited(stream, instance.teamChat, isDelta);
				}
				continue;
			case 90:
				if (instance.entityInfo == null)
				{
					instance.entityInfo = AppEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityInfo.DeserializeLengthDelimited(stream, instance.entityInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.flag == null)
				{
					instance.flag = AppFlag.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppFlag.DeserializeLengthDelimited(stream, instance.flag, isDelta);
				}
				continue;
			case 106:
				if (instance.mapMarkers == null)
				{
					instance.mapMarkers = AppMapMarkers.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMapMarkers.DeserializeLengthDelimited(stream, instance.mapMarkers, isDelta);
				}
				continue;
			case 122:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = AppClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.clanChat == null)
					{
						instance.clanChat = AppClanChat.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppClanChat.DeserializeLengthDelimited(stream, instance.clanChat, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.nexusAuth == null)
					{
						instance.nexusAuth = AppNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppNexusAuth.DeserializeLengthDelimited(stream, instance.nexusAuth, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribeInfo == null)
					{
						instance.cameraSubscribeInfo = AppCameraInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInfo.DeserializeLengthDelimited(stream, instance.cameraSubscribeInfo, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppResponse DeserializeLength(BufferStream stream, int length, AppResponse instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.seq = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seq = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				if (instance.success == null)
				{
					instance.success = AppSuccess.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppSuccess.DeserializeLengthDelimited(stream, instance.success, isDelta);
				}
				continue;
			case 42:
				if (instance.error == null)
				{
					instance.error = AppError.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppError.DeserializeLengthDelimited(stream, instance.error, isDelta);
				}
				continue;
			case 50:
				if (instance.info == null)
				{
					instance.info = AppInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				continue;
			case 58:
				if (instance.time == null)
				{
					instance.time = AppTime.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTime.DeserializeLengthDelimited(stream, instance.time, isDelta);
				}
				continue;
			case 66:
				if (instance.map == null)
				{
					instance.map = AppMap.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMap.DeserializeLengthDelimited(stream, instance.map, isDelta);
				}
				continue;
			case 74:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				continue;
			case 82:
				if (instance.teamChat == null)
				{
					instance.teamChat = AppTeamChat.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamChat.DeserializeLengthDelimited(stream, instance.teamChat, isDelta);
				}
				continue;
			case 90:
				if (instance.entityInfo == null)
				{
					instance.entityInfo = AppEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityInfo.DeserializeLengthDelimited(stream, instance.entityInfo, isDelta);
				}
				continue;
			case 98:
				if (instance.flag == null)
				{
					instance.flag = AppFlag.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppFlag.DeserializeLengthDelimited(stream, instance.flag, isDelta);
				}
				continue;
			case 106:
				if (instance.mapMarkers == null)
				{
					instance.mapMarkers = AppMapMarkers.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppMapMarkers.DeserializeLengthDelimited(stream, instance.mapMarkers, isDelta);
				}
				continue;
			case 122:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = AppClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.clanChat == null)
					{
						instance.clanChat = AppClanChat.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppClanChat.DeserializeLengthDelimited(stream, instance.clanChat, isDelta);
					}
				}
				break;
			case 17u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.nexusAuth == null)
					{
						instance.nexusAuth = AppNexusAuth.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppNexusAuth.DeserializeLengthDelimited(stream, instance.nexusAuth, isDelta);
					}
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.cameraSubscribeInfo == null)
					{
						instance.cameraSubscribeInfo = AppCameraInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						AppCameraInfo.DeserializeLengthDelimited(stream, instance.cameraSubscribeInfo, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppResponse instance, AppResponse previous)
	{
		if (instance.seq != previous.seq)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seq);
		}
		if (instance.success != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			AppSuccess.SerializeDelta(stream, instance.success, previous.success);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field success (ProtoBuf.AppSuccess)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.error != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			AppError.SerializeDelta(stream, instance.error, previous.error);
			int val = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.info != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			AppInfo.SerializeDelta(stream, instance.info, previous.info);
			int val2 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val2, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
		if (instance.time != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			AppTime.SerializeDelta(stream, instance.time, previous.time);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field time (ProtoBuf.AppTime)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.map != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			AppMap.SerializeDelta(stream, instance.map, previous.map);
			int val3 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)val3, span5, 0);
			if (num5 < 5)
			{
				span5[num5 - 1] |= 128;
				while (num5 < 4)
				{
					span5[num5++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.teamInfo != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			AppTeamInfo.SerializeDelta(stream, instance.teamInfo, previous.teamInfo);
			int val4 = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val4, span6, 0);
			if (num6 < 5)
			{
				span6[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span6[num6++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.teamChat != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range7 = stream.GetRange(5);
			int position7 = stream.Position;
			AppTeamChat.SerializeDelta(stream, instance.teamChat, previous.teamChat);
			int val5 = stream.Position - position7;
			Span<byte> span7 = range7.GetSpan();
			int num7 = ProtocolParser.WriteUInt32((uint)val5, span7, 0);
			if (num7 < 5)
			{
				span7[num7 - 1] |= 128;
				while (num7 < 4)
				{
					span7[num7++] = 128;
				}
				span7[4] = 0;
			}
		}
		if (instance.entityInfo != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range8 = stream.GetRange(3);
			int position8 = stream.Position;
			AppEntityInfo.SerializeDelta(stream, instance.entityInfo, previous.entityInfo);
			int num8 = stream.Position - position8;
			if (num8 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entityInfo (ProtoBuf.AppEntityInfo)");
			}
			Span<byte> span8 = range8.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)num8, span8, 0);
			if (num9 < 3)
			{
				span8[num9 - 1] |= 128;
				while (num9 < 2)
				{
					span8[num9++] = 128;
				}
				span8[2] = 0;
			}
		}
		if (instance.flag != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AppFlag.SerializeDelta(stream, instance.flag, previous.flag);
			int num10 = stream.Position - position9;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field flag (ProtoBuf.AppFlag)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span9, 0);
		}
		if (instance.mapMarkers != null)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range10 = stream.GetRange(5);
			int position10 = stream.Position;
			AppMapMarkers.SerializeDelta(stream, instance.mapMarkers, previous.mapMarkers);
			int val6 = stream.Position - position10;
			Span<byte> span10 = range10.GetSpan();
			int num11 = ProtocolParser.WriteUInt32((uint)val6, span10, 0);
			if (num11 < 5)
			{
				span10[num11 - 1] |= 128;
				while (num11 < 4)
				{
					span10[num11++] = 128;
				}
				span10[4] = 0;
			}
		}
		if (instance.clanInfo != null)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range11 = stream.GetRange(5);
			int position11 = stream.Position;
			AppClanInfo.SerializeDelta(stream, instance.clanInfo, previous.clanInfo);
			int val7 = stream.Position - position11;
			Span<byte> span11 = range11.GetSpan();
			int num12 = ProtocolParser.WriteUInt32((uint)val7, span11, 0);
			if (num12 < 5)
			{
				span11[num12 - 1] |= 128;
				while (num12 < 4)
				{
					span11[num12++] = 128;
				}
				span11[4] = 0;
			}
		}
		if (instance.clanChat != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range12 = stream.GetRange(5);
			int position12 = stream.Position;
			AppClanChat.SerializeDelta(stream, instance.clanChat, previous.clanChat);
			int val8 = stream.Position - position12;
			Span<byte> span12 = range12.GetSpan();
			int num13 = ProtocolParser.WriteUInt32((uint)val8, span12, 0);
			if (num13 < 5)
			{
				span12[num13 - 1] |= 128;
				while (num13 < 4)
				{
					span12[num13++] = 128;
				}
				span12[4] = 0;
			}
		}
		if (instance.nexusAuth != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(1);
			BufferStream.RangeHandle range13 = stream.GetRange(5);
			int position13 = stream.Position;
			AppNexusAuth.SerializeDelta(stream, instance.nexusAuth, previous.nexusAuth);
			int val9 = stream.Position - position13;
			Span<byte> span13 = range13.GetSpan();
			int num14 = ProtocolParser.WriteUInt32((uint)val9, span13, 0);
			if (num14 < 5)
			{
				span13[num14 - 1] |= 128;
				while (num14 < 4)
				{
					span13[num14++] = 128;
				}
				span13[4] = 0;
			}
		}
		if (instance.cameraSubscribeInfo != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range14 = stream.GetRange(1);
			int position14 = stream.Position;
			AppCameraInfo.SerializeDelta(stream, instance.cameraSubscribeInfo, previous.cameraSubscribeInfo);
			int num15 = stream.Position - position14;
			if (num15 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraSubscribeInfo (ProtoBuf.AppCameraInfo)");
			}
			Span<byte> span14 = range14.GetSpan();
			ProtocolParser.WriteUInt32((uint)num15, span14, 0);
		}
	}

	public static void Serialize(BufferStream stream, AppResponse instance)
	{
		if (instance.seq != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seq);
		}
		if (instance.success != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			AppSuccess.Serialize(stream, instance.success);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field success (ProtoBuf.AppSuccess)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.error != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			AppError.Serialize(stream, instance.error);
			int val = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.info != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			AppInfo.Serialize(stream, instance.info);
			int val2 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val2, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
		if (instance.time != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			AppTime.Serialize(stream, instance.time);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field time (ProtoBuf.AppTime)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.map != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			AppMap.Serialize(stream, instance.map);
			int val3 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)val3, span5, 0);
			if (num5 < 5)
			{
				span5[num5 - 1] |= 128;
				while (num5 < 4)
				{
					span5[num5++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.teamInfo != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			AppTeamInfo.Serialize(stream, instance.teamInfo);
			int val4 = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val4, span6, 0);
			if (num6 < 5)
			{
				span6[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span6[num6++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.teamChat != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range7 = stream.GetRange(5);
			int position7 = stream.Position;
			AppTeamChat.Serialize(stream, instance.teamChat);
			int val5 = stream.Position - position7;
			Span<byte> span7 = range7.GetSpan();
			int num7 = ProtocolParser.WriteUInt32((uint)val5, span7, 0);
			if (num7 < 5)
			{
				span7[num7 - 1] |= 128;
				while (num7 < 4)
				{
					span7[num7++] = 128;
				}
				span7[4] = 0;
			}
		}
		if (instance.entityInfo != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range8 = stream.GetRange(3);
			int position8 = stream.Position;
			AppEntityInfo.Serialize(stream, instance.entityInfo);
			int num8 = stream.Position - position8;
			if (num8 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entityInfo (ProtoBuf.AppEntityInfo)");
			}
			Span<byte> span8 = range8.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)num8, span8, 0);
			if (num9 < 3)
			{
				span8[num9 - 1] |= 128;
				while (num9 < 2)
				{
					span8[num9++] = 128;
				}
				span8[2] = 0;
			}
		}
		if (instance.flag != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AppFlag.Serialize(stream, instance.flag);
			int num10 = stream.Position - position9;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field flag (ProtoBuf.AppFlag)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span9, 0);
		}
		if (instance.mapMarkers != null)
		{
			stream.WriteByte(106);
			BufferStream.RangeHandle range10 = stream.GetRange(5);
			int position10 = stream.Position;
			AppMapMarkers.Serialize(stream, instance.mapMarkers);
			int val6 = stream.Position - position10;
			Span<byte> span10 = range10.GetSpan();
			int num11 = ProtocolParser.WriteUInt32((uint)val6, span10, 0);
			if (num11 < 5)
			{
				span10[num11 - 1] |= 128;
				while (num11 < 4)
				{
					span10[num11++] = 128;
				}
				span10[4] = 0;
			}
		}
		if (instance.clanInfo != null)
		{
			stream.WriteByte(122);
			BufferStream.RangeHandle range11 = stream.GetRange(5);
			int position11 = stream.Position;
			AppClanInfo.Serialize(stream, instance.clanInfo);
			int val7 = stream.Position - position11;
			Span<byte> span11 = range11.GetSpan();
			int num12 = ProtocolParser.WriteUInt32((uint)val7, span11, 0);
			if (num12 < 5)
			{
				span11[num12 - 1] |= 128;
				while (num12 < 4)
				{
					span11[num12++] = 128;
				}
				span11[4] = 0;
			}
		}
		if (instance.clanChat != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			BufferStream.RangeHandle range12 = stream.GetRange(5);
			int position12 = stream.Position;
			AppClanChat.Serialize(stream, instance.clanChat);
			int val8 = stream.Position - position12;
			Span<byte> span12 = range12.GetSpan();
			int num13 = ProtocolParser.WriteUInt32((uint)val8, span12, 0);
			if (num13 < 5)
			{
				span12[num13 - 1] |= 128;
				while (num13 < 4)
				{
					span12[num13++] = 128;
				}
				span12[4] = 0;
			}
		}
		if (instance.nexusAuth != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(1);
			BufferStream.RangeHandle range13 = stream.GetRange(5);
			int position13 = stream.Position;
			AppNexusAuth.Serialize(stream, instance.nexusAuth);
			int val9 = stream.Position - position13;
			Span<byte> span13 = range13.GetSpan();
			int num14 = ProtocolParser.WriteUInt32((uint)val9, span13, 0);
			if (num14 < 5)
			{
				span13[num14 - 1] |= 128;
				while (num14 < 4)
				{
					span13[num14++] = 128;
				}
				span13[4] = 0;
			}
		}
		if (instance.cameraSubscribeInfo != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range14 = stream.GetRange(1);
			int position14 = stream.Position;
			AppCameraInfo.Serialize(stream, instance.cameraSubscribeInfo);
			int num15 = stream.Position - position14;
			if (num15 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cameraSubscribeInfo (ProtoBuf.AppCameraInfo)");
			}
			Span<byte> span14 = range14.GetSpan();
			ProtocolParser.WriteUInt32((uint)num15, span14, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		success?.InspectUids(action);
		error?.InspectUids(action);
		info?.InspectUids(action);
		time?.InspectUids(action);
		map?.InspectUids(action);
		teamInfo?.InspectUids(action);
		teamChat?.InspectUids(action);
		entityInfo?.InspectUids(action);
		flag?.InspectUids(action);
		mapMarkers?.InspectUids(action);
		clanInfo?.InspectUids(action);
		clanChat?.InspectUids(action);
		nexusAuth?.InspectUids(action);
		cameraSubscribeInfo?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Approval : IDisposable, IPooled, IProto<Approval>, IProto
{
	[NonSerialized]
	public string level;

	[NonSerialized]
	public string hostname;

	[NonSerialized]
	public bool modded;

	[NonSerialized]
	public bool official;

	[NonSerialized]
	public ulong steamid;

	[NonSerialized]
	public uint ipaddress;

	[NonSerialized]
	public int port;

	[NonSerialized]
	public uint levelSeed;

	[NonSerialized]
	public uint levelSize;

	[NonSerialized]
	public string checksum;

	[NonSerialized]
	public uint encryption;

	[NonSerialized]
	public string levelUrl;

	[NonSerialized]
	public bool levelTransfer;

	[NonSerialized]
	public string version;

	[NonSerialized]
	public string levelConfig;

	[NonSerialized]
	public bool nexus;

	[NonSerialized]
	public string nexusEndpoint;

	[NonSerialized]
	public int nexusId;

	[NonSerialized]
	public string dnsEndpoint;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Approval instance)
	{
		if (instance.ShouldPool)
		{
			instance.level = string.Empty;
			instance.hostname = string.Empty;
			instance.modded = false;
			instance.official = false;
			instance.steamid = 0uL;
			instance.ipaddress = 0u;
			instance.port = 0;
			instance.levelSeed = 0u;
			instance.levelSize = 0u;
			instance.checksum = string.Empty;
			instance.encryption = 0u;
			instance.levelUrl = string.Empty;
			instance.levelTransfer = false;
			instance.version = string.Empty;
			instance.levelConfig = string.Empty;
			instance.nexus = false;
			instance.nexusEndpoint = string.Empty;
			instance.nexusId = 0;
			instance.dnsEndpoint = string.Empty;
			Pool.Free<Approval>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Approval with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Approval instance)
	{
		instance.level = level;
		instance.hostname = hostname;
		instance.modded = modded;
		instance.official = official;
		instance.steamid = steamid;
		instance.ipaddress = ipaddress;
		instance.port = port;
		instance.levelSeed = levelSeed;
		instance.levelSize = levelSize;
		instance.checksum = checksum;
		instance.encryption = encryption;
		instance.levelUrl = levelUrl;
		instance.levelTransfer = levelTransfer;
		instance.version = version;
		instance.levelConfig = levelConfig;
		instance.nexus = nexus;
		instance.nexusEndpoint = nexusEndpoint;
		instance.nexusId = nexusId;
		instance.dnsEndpoint = dnsEndpoint;
	}

	public Approval Copy()
	{
		Approval approval = Pool.Get<Approval>();
		CopyTo(approval);
		return approval;
	}

	public static Approval Deserialize(BufferStream stream)
	{
		Approval approval = Pool.Get<Approval>();
		Deserialize(stream, approval, isDelta: false);
		return approval;
	}

	public static Approval DeserializeLengthDelimited(BufferStream stream)
	{
		Approval approval = Pool.Get<Approval>();
		DeserializeLengthDelimited(stream, approval, isDelta: false);
		return approval;
	}

	public static Approval DeserializeLength(BufferStream stream, int length)
	{
		Approval approval = Pool.Get<Approval>();
		DeserializeLength(stream, length, approval, isDelta: false);
		return approval;
	}

	public static Approval Deserialize(byte[] buffer)
	{
		Approval approval = Pool.Get<Approval>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, approval, isDelta: false);
		return approval;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Approval previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Approval Deserialize(BufferStream stream, Approval instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.hostname = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.modded = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.official = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.ipaddress = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.port = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 90:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.encryption = ProtocolParser.ReadUInt32(stream);
				continue;
			case 106:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.levelTransfer = ProtocolParser.ReadBool(stream);
				continue;
			case 122:
				instance.version = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.levelConfig = ProtocolParser.ReadString(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexus = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.nexusEndpoint = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.dnsEndpoint = ProtocolParser.ReadString(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static Approval DeserializeLengthDelimited(BufferStream stream, Approval instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.hostname = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.modded = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.official = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.ipaddress = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.port = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 90:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.encryption = ProtocolParser.ReadUInt32(stream);
				continue;
			case 106:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.levelTransfer = ProtocolParser.ReadBool(stream);
				continue;
			case 122:
				instance.version = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.levelConfig = ProtocolParser.ReadString(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexus = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.nexusEndpoint = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.dnsEndpoint = ProtocolParser.ReadString(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Approval DeserializeLength(BufferStream stream, int length, Approval instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.hostname = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.modded = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.official = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.ipaddress = ProtocolParser.ReadUInt32(stream);
				continue;
			case 64:
				instance.port = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 90:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.encryption = ProtocolParser.ReadUInt32(stream);
				continue;
			case 106:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 112:
				instance.levelTransfer = ProtocolParser.ReadBool(stream);
				continue;
			case 122:
				instance.version = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.levelConfig = ProtocolParser.ReadString(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexus = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.nexusEndpoint = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.nexusId = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.dnsEndpoint = ProtocolParser.ReadString(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Approval instance, Approval previous)
	{
		if (instance.level != previous.level)
		{
			if (instance.level == null)
			{
				throw new ArgumentNullException("level", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.level);
		}
		if (instance.hostname != null && instance.hostname != previous.hostname)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.hostname);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.modded);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.official);
		if (instance.steamid != previous.steamid)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.steamid);
		}
		if (instance.ipaddress != previous.ipaddress)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.ipaddress);
		}
		if (instance.port != previous.port)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.port);
		}
		if (instance.levelSeed != previous.levelSeed)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.levelSeed);
		}
		if (instance.levelSize != previous.levelSize)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.levelSize);
		}
		if (instance.checksum != null && instance.checksum != previous.checksum)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.checksum);
		}
		if (instance.encryption != previous.encryption)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.encryption);
		}
		if (instance.levelUrl != null && instance.levelUrl != previous.levelUrl)
		{
			stream.WriteByte(106);
			ProtocolParser.WriteString(stream, instance.levelUrl);
		}
		stream.WriteByte(112);
		ProtocolParser.WriteBool(stream, instance.levelTransfer);
		if (instance.version != null && instance.version != previous.version)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.version);
		}
		if (instance.levelConfig != null && instance.levelConfig != previous.levelConfig)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.levelConfig);
		}
		stream.WriteByte(136);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.nexus);
		if (instance.nexusEndpoint != null && instance.nexusEndpoint != previous.nexusEndpoint)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.nexusEndpoint);
		}
		if (instance.nexusId != previous.nexusId)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nexusId);
		}
		if (instance.dnsEndpoint != null && instance.dnsEndpoint != previous.dnsEndpoint)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.dnsEndpoint);
		}
	}

	public static void Serialize(BufferStream stream, Approval instance)
	{
		if (instance.level == null)
		{
			throw new ArgumentNullException("level", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.level);
		if (instance.hostname != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.hostname);
		}
		if (instance.modded)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.modded);
		}
		if (instance.official)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.official);
		}
		if (instance.steamid != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.steamid);
		}
		if (instance.ipaddress != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.ipaddress);
		}
		if (instance.port != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.port);
		}
		if (instance.levelSeed != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.levelSeed);
		}
		if (instance.levelSize != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.levelSize);
		}
		if (instance.checksum != null)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.checksum);
		}
		if (instance.encryption != 0)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.encryption);
		}
		if (instance.levelUrl != null)
		{
			stream.WriteByte(106);
			ProtocolParser.WriteString(stream, instance.levelUrl);
		}
		if (instance.levelTransfer)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteBool(stream, instance.levelTransfer);
		}
		if (instance.version != null)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.version);
		}
		if (instance.levelConfig != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.levelConfig);
		}
		if (instance.nexus)
		{
			stream.WriteByte(136);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.nexus);
		}
		if (instance.nexusEndpoint != null)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.nexusEndpoint);
		}
		if (instance.nexusId != 0)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nexusId);
		}
		if (instance.dnsEndpoint != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.dnsEndpoint);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppSendMessage : IDisposable, IPooled, IProto<AppSendMessage>, IProto
{
	[NonSerialized]
	public string message;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppSendMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.message = string.Empty;
			Pool.Free<AppSendMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppSendMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppSendMessage instance)
	{
		instance.message = message;
	}

	public AppSendMessage Copy()
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		CopyTo(appSendMessage);
		return appSendMessage;
	}

	public static AppSendMessage Deserialize(BufferStream stream)
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		Deserialize(stream, appSendMessage, isDelta: false);
		return appSendMessage;
	}

	public static AppSendMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		DeserializeLengthDelimited(stream, appSendMessage, isDelta: false);
		return appSendMessage;
	}

	public static AppSendMessage DeserializeLength(BufferStream stream, int length)
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		DeserializeLength(stream, length, appSendMessage, isDelta: false);
		return appSendMessage;
	}

	public static AppSendMessage Deserialize(byte[] buffer)
	{
		AppSendMessage appSendMessage = Pool.Get<AppSendMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appSendMessage, isDelta: false);
		return appSendMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppSendMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppSendMessage Deserialize(BufferStream stream, AppSendMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppSendMessage DeserializeLengthDelimited(BufferStream stream, AppSendMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppSendMessage DeserializeLength(BufferStream stream, int length, AppSendMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppSendMessage instance, AppSendMessage previous)
	{
		if (instance.message != previous.message)
		{
			if (instance.message == null)
			{
				throw new ArgumentNullException("message", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.message);
		}
	}

	public static void Serialize(BufferStream stream, AppSendMessage instance)
	{
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.message);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppSetEntityValue : IDisposable, IPooled, IProto<AppSetEntityValue>, IProto
{
	[NonSerialized]
	public bool value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppSetEntityValue instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = false;
			Pool.Free<AppSetEntityValue>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppSetEntityValue with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppSetEntityValue instance)
	{
		instance.value = value;
	}

	public AppSetEntityValue Copy()
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		CopyTo(appSetEntityValue);
		return appSetEntityValue;
	}

	public static AppSetEntityValue Deserialize(BufferStream stream)
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		Deserialize(stream, appSetEntityValue, isDelta: false);
		return appSetEntityValue;
	}

	public static AppSetEntityValue DeserializeLengthDelimited(BufferStream stream)
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		DeserializeLengthDelimited(stream, appSetEntityValue, isDelta: false);
		return appSetEntityValue;
	}

	public static AppSetEntityValue DeserializeLength(BufferStream stream, int length)
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		DeserializeLength(stream, length, appSetEntityValue, isDelta: false);
		return appSetEntityValue;
	}

	public static AppSetEntityValue Deserialize(byte[] buffer)
	{
		AppSetEntityValue appSetEntityValue = Pool.Get<AppSetEntityValue>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appSetEntityValue, isDelta: false);
		return appSetEntityValue;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppSetEntityValue previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppSetEntityValue Deserialize(BufferStream stream, AppSetEntityValue instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppSetEntityValue DeserializeLengthDelimited(BufferStream stream, AppSetEntityValue instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppSetEntityValue DeserializeLength(BufferStream stream, int length, AppSetEntityValue instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.value = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppSetEntityValue instance, AppSetEntityValue previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.value);
	}

	public static void Serialize(BufferStream stream, AppSetEntityValue instance)
	{
		if (instance.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppSuccess : IDisposable, IPooled, IProto<AppSuccess>, IProto
{
	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppSuccess instance)
	{
		if (instance.ShouldPool)
		{
			Pool.Free<AppSuccess>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppSuccess with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppSuccess instance)
	{
	}

	public AppSuccess Copy()
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		CopyTo(appSuccess);
		return appSuccess;
	}

	public static AppSuccess Deserialize(BufferStream stream)
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		Deserialize(stream, appSuccess, isDelta: false);
		return appSuccess;
	}

	public static AppSuccess DeserializeLengthDelimited(BufferStream stream)
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		DeserializeLengthDelimited(stream, appSuccess, isDelta: false);
		return appSuccess;
	}

	public static AppSuccess DeserializeLength(BufferStream stream, int length)
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		DeserializeLength(stream, length, appSuccess, isDelta: false);
		return appSuccess;
	}

	public static AppSuccess Deserialize(byte[] buffer)
	{
		AppSuccess appSuccess = Pool.Get<AppSuccess>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appSuccess, isDelta: false);
		return appSuccess;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppSuccess previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppSuccess Deserialize(BufferStream stream, AppSuccess instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1 || num == 0)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static AppSuccess DeserializeLengthDelimited(BufferStream stream, AppSuccess instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static AppSuccess DeserializeLength(BufferStream stream, int length, AppSuccess instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppSuccess instance, AppSuccess previous)
	{
	}

	public static void Serialize(BufferStream stream, AppSuccess instance)
	{
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTeamChanged : IDisposable, IPooled, IProto<AppTeamChanged>, IProto
{
	[NonSerialized]
	public ulong playerId;

	[NonSerialized]
	public AppTeamInfo teamInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTeamChanged instance)
	{
		if (instance.ShouldPool)
		{
			instance.playerId = 0uL;
			if (instance.teamInfo != null)
			{
				instance.teamInfo.ResetToPool();
				instance.teamInfo = null;
			}
			Pool.Free<AppTeamChanged>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTeamChanged with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTeamChanged instance)
	{
		instance.playerId = playerId;
		if (teamInfo != null)
		{
			if (instance.teamInfo == null)
			{
				instance.teamInfo = teamInfo.Copy();
			}
			else
			{
				teamInfo.CopyTo(instance.teamInfo);
			}
		}
		else
		{
			instance.teamInfo = null;
		}
	}

	public AppTeamChanged Copy()
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		CopyTo(appTeamChanged);
		return appTeamChanged;
	}

	public static AppTeamChanged Deserialize(BufferStream stream)
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		Deserialize(stream, appTeamChanged, isDelta: false);
		return appTeamChanged;
	}

	public static AppTeamChanged DeserializeLengthDelimited(BufferStream stream)
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		DeserializeLengthDelimited(stream, appTeamChanged, isDelta: false);
		return appTeamChanged;
	}

	public static AppTeamChanged DeserializeLength(BufferStream stream, int length)
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		DeserializeLength(stream, length, appTeamChanged, isDelta: false);
		return appTeamChanged;
	}

	public static AppTeamChanged Deserialize(byte[] buffer)
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTeamChanged, isDelta: false);
		return appTeamChanged;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTeamChanged previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTeamChanged Deserialize(BufferStream stream, AppTeamChanged instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerId = 0uL;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static AppTeamChanged DeserializeLengthDelimited(BufferStream stream, AppTeamChanged instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerId = 0uL;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTeamChanged DeserializeLength(BufferStream stream, int length, AppTeamChanged instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerId = 0uL;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTeamChanged instance, AppTeamChanged previous)
	{
		if (instance.playerId != previous.playerId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.teamInfo == null)
		{
			throw new ArgumentNullException("teamInfo", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppTeamInfo.SerializeDelta(stream, instance.teamInfo, previous.teamInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppTeamChanged instance)
	{
		if (instance.playerId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.teamInfo == null)
		{
			throw new ArgumentNullException("teamInfo", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppTeamInfo.Serialize(stream, instance.teamInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		teamInfo?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTeamChat : IDisposable, IPooled, IProto<AppTeamChat>, IProto
{
	[NonSerialized]
	public List<AppTeamMessage> messages;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTeamChat instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.messages != null)
		{
			for (int i = 0; i < instance.messages.Count; i++)
			{
				if (instance.messages[i] != null)
				{
					instance.messages[i].ResetToPool();
					instance.messages[i] = null;
				}
			}
			List<AppTeamMessage> list = instance.messages;
			Pool.Free<AppTeamMessage>(ref list, false);
			instance.messages = list;
		}
		Pool.Free<AppTeamChat>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTeamChat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTeamChat instance)
	{
		if (messages != null)
		{
			instance.messages = Pool.Get<List<AppTeamMessage>>();
			for (int i = 0; i < messages.Count; i++)
			{
				AppTeamMessage item = messages[i].Copy();
				instance.messages.Add(item);
			}
		}
		else
		{
			instance.messages = null;
		}
	}

	public AppTeamChat Copy()
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		CopyTo(appTeamChat);
		return appTeamChat;
	}

	public static AppTeamChat Deserialize(BufferStream stream)
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		Deserialize(stream, appTeamChat, isDelta: false);
		return appTeamChat;
	}

	public static AppTeamChat DeserializeLengthDelimited(BufferStream stream)
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		DeserializeLengthDelimited(stream, appTeamChat, isDelta: false);
		return appTeamChat;
	}

	public static AppTeamChat DeserializeLength(BufferStream stream, int length)
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		DeserializeLength(stream, length, appTeamChat, isDelta: false);
		return appTeamChat;
	}

	public static AppTeamChat Deserialize(byte[] buffer)
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTeamChat, isDelta: false);
		return appTeamChat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTeamChat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTeamChat Deserialize(BufferStream stream, AppTeamChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppTeamMessage>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.messages.Add(AppTeamMessage.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppTeamChat DeserializeLengthDelimited(BufferStream stream, AppTeamChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppTeamMessage>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(AppTeamMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTeamChat DeserializeLength(BufferStream stream, int length, AppTeamChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppTeamMessage>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(AppTeamMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTeamChat instance, AppTeamChat previous)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			AppTeamMessage appTeamMessage = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppTeamMessage.SerializeDelta(stream, appTeamMessage, appTeamMessage);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AppTeamChat instance)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			AppTeamMessage instance2 = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppTeamMessage.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (messages != null)
		{
			for (int i = 0; i < messages.Count; i++)
			{
				messages[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTeamInfo : IDisposable, IPooled, IProto<AppTeamInfo>, IProto
{
	public class Member : IDisposable, IPooled, IProto<Member>, IProto
	{
		[NonSerialized]
		public ulong steamId;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public float x;

		[NonSerialized]
		public float y;

		[NonSerialized]
		public bool isOnline;

		[NonSerialized]
		public uint spawnTime;

		[NonSerialized]
		public bool isAlive;

		[NonSerialized]
		public uint deathTime;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Member instance)
		{
			if (instance.ShouldPool)
			{
				instance.steamId = 0uL;
				instance.name = string.Empty;
				instance.x = 0f;
				instance.y = 0f;
				instance.isOnline = false;
				instance.spawnTime = 0u;
				instance.isAlive = false;
				instance.deathTime = 0u;
				Pool.Free<Member>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Member with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Member instance)
		{
			instance.steamId = steamId;
			instance.name = name;
			instance.x = x;
			instance.y = y;
			instance.isOnline = isOnline;
			instance.spawnTime = spawnTime;
			instance.isAlive = isAlive;
			instance.deathTime = deathTime;
		}

		public Member Copy()
		{
			Member member = Pool.Get<Member>();
			CopyTo(member);
			return member;
		}

		public static Member Deserialize(BufferStream stream)
		{
			Member member = Pool.Get<Member>();
			Deserialize(stream, member, isDelta: false);
			return member;
		}

		public static Member DeserializeLengthDelimited(BufferStream stream)
		{
			Member member = Pool.Get<Member>();
			DeserializeLengthDelimited(stream, member, isDelta: false);
			return member;
		}

		public static Member DeserializeLength(BufferStream stream, int length)
		{
			Member member = Pool.Get<Member>();
			DeserializeLength(stream, length, member, isDelta: false);
			return member;
		}

		public static Member Deserialize(byte[] buffer)
		{
			Member member = Pool.Get<Member>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, member, isDelta: false);
			return member;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Member previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Member Deserialize(BufferStream stream, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.x = 0f;
				instance.y = 0f;
				instance.isOnline = false;
				instance.spawnTime = 0u;
				instance.isAlive = false;
				instance.deathTime = 0u;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.isOnline = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.spawnTime = ProtocolParser.ReadUInt32(stream);
					continue;
				case 56:
					instance.isAlive = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.deathTime = ProtocolParser.ReadUInt32(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Member DeserializeLengthDelimited(BufferStream stream, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.x = 0f;
				instance.y = 0f;
				instance.isOnline = false;
				instance.spawnTime = 0u;
				instance.isAlive = false;
				instance.deathTime = 0u;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.isOnline = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.spawnTime = ProtocolParser.ReadUInt32(stream);
					continue;
				case 56:
					instance.isAlive = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.deathTime = ProtocolParser.ReadUInt32(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Member DeserializeLength(BufferStream stream, int length, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.x = 0f;
				instance.y = 0f;
				instance.isOnline = false;
				instance.spawnTime = 0u;
				instance.isAlive = false;
				instance.deathTime = 0u;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.isOnline = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.spawnTime = ProtocolParser.ReadUInt32(stream);
					continue;
				case 56:
					instance.isAlive = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.deathTime = ProtocolParser.ReadUInt32(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Member instance, Member previous)
		{
			if (instance.steamId != previous.steamId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.x != previous.x)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != previous.y)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isOnline);
			if (instance.spawnTime != previous.spawnTime)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt32(stream, instance.spawnTime);
			}
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isAlive);
			if (instance.deathTime != previous.deathTime)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteUInt32(stream, instance.deathTime);
			}
		}

		public static void Serialize(BufferStream stream, Member instance)
		{
			if (instance.steamId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.x != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
			if (instance.isOnline)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.isOnline);
			}
			if (instance.spawnTime != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt32(stream, instance.spawnTime);
			}
			if (instance.isAlive)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.isAlive);
			}
			if (instance.deathTime != 0)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteUInt32(stream, instance.deathTime);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class Note : IDisposable, IPooled, IProto<Note>, IProto
	{
		[NonSerialized]
		public int type;

		[NonSerialized]
		public float x;

		[NonSerialized]
		public float y;

		[NonSerialized]
		public int icon;

		[NonSerialized]
		public int colourIndex;

		[NonSerialized]
		public string label;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Note instance)
		{
			if (instance.ShouldPool)
			{
				instance.type = 0;
				instance.x = 0f;
				instance.y = 0f;
				instance.icon = 0;
				instance.colourIndex = 0;
				instance.label = string.Empty;
				Pool.Free<Note>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Note with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Note instance)
		{
			instance.type = type;
			instance.x = x;
			instance.y = y;
			instance.icon = icon;
			instance.colourIndex = colourIndex;
			instance.label = label;
		}

		public Note Copy()
		{
			Note note = Pool.Get<Note>();
			CopyTo(note);
			return note;
		}

		public static Note Deserialize(BufferStream stream)
		{
			Note note = Pool.Get<Note>();
			Deserialize(stream, note, isDelta: false);
			return note;
		}

		public static Note DeserializeLengthDelimited(BufferStream stream)
		{
			Note note = Pool.Get<Note>();
			DeserializeLengthDelimited(stream, note, isDelta: false);
			return note;
		}

		public static Note DeserializeLength(BufferStream stream, int length)
		{
			Note note = Pool.Get<Note>();
			DeserializeLength(stream, length, note, isDelta: false);
			return note;
		}

		public static Note Deserialize(byte[] buffer)
		{
			Note note = Pool.Get<Note>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, note, isDelta: false);
			return note;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Note previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Note Deserialize(BufferStream stream, Note instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.type = 0;
				instance.x = 0f;
				instance.y = 0f;
				instance.icon = 0;
				instance.colourIndex = 0;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.icon = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 58:
					instance.label = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Note DeserializeLengthDelimited(BufferStream stream, Note instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.type = 0;
				instance.x = 0f;
				instance.y = 0f;
				instance.icon = 0;
				instance.colourIndex = 0;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.icon = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 58:
					instance.label = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Note DeserializeLength(BufferStream stream, int length, Note instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.type = 0;
				instance.x = 0f;
				instance.y = 0f;
				instance.icon = 0;
				instance.colourIndex = 0;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.icon = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 58:
					instance.label = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Note instance, Note previous)
		{
			if (instance.type != previous.type)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.x != previous.x)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != previous.y)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
			if (instance.icon != previous.icon)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
			}
			if (instance.colourIndex != previous.colourIndex)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
			}
			if (instance.label != null && instance.label != previous.label)
			{
				stream.WriteByte(58);
				ProtocolParser.WriteString(stream, instance.label);
			}
		}

		public static void Serialize(BufferStream stream, Note instance)
		{
			if (instance.type != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.x != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
			if (instance.icon != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
			}
			if (instance.colourIndex != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
			}
			if (instance.label != null)
			{
				stream.WriteByte(58);
				ProtocolParser.WriteString(stream, instance.label);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public ulong leaderSteamId;

	[NonSerialized]
	public List<Member> members;

	[NonSerialized]
	public List<Note> mapNotes;

	[NonSerialized]
	public List<Note> leaderMapNotes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTeamInfo instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.leaderSteamId = 0uL;
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				if (instance.members[i] != null)
				{
					instance.members[i].ResetToPool();
					instance.members[i] = null;
				}
			}
			List<Member> list = instance.members;
			Pool.Free<Member>(ref list, false);
			instance.members = list;
		}
		if (instance.mapNotes != null)
		{
			for (int j = 0; j < instance.mapNotes.Count; j++)
			{
				if (instance.mapNotes[j] != null)
				{
					instance.mapNotes[j].ResetToPool();
					instance.mapNotes[j] = null;
				}
			}
			List<Note> list2 = instance.mapNotes;
			Pool.Free<Note>(ref list2, false);
			instance.mapNotes = list2;
		}
		if (instance.leaderMapNotes != null)
		{
			for (int k = 0; k < instance.leaderMapNotes.Count; k++)
			{
				if (instance.leaderMapNotes[k] != null)
				{
					instance.leaderMapNotes[k].ResetToPool();
					instance.leaderMapNotes[k] = null;
				}
			}
			List<Note> list3 = instance.leaderMapNotes;
			Pool.Free<Note>(ref list3, false);
			instance.leaderMapNotes = list3;
		}
		Pool.Free<AppTeamInfo>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTeamInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTeamInfo instance)
	{
		instance.leaderSteamId = leaderSteamId;
		if (members != null)
		{
			instance.members = Pool.Get<List<Member>>();
			for (int i = 0; i < members.Count; i++)
			{
				Member item = members[i].Copy();
				instance.members.Add(item);
			}
		}
		else
		{
			instance.members = null;
		}
		if (mapNotes != null)
		{
			instance.mapNotes = Pool.Get<List<Note>>();
			for (int j = 0; j < mapNotes.Count; j++)
			{
				Note item2 = mapNotes[j].Copy();
				instance.mapNotes.Add(item2);
			}
		}
		else
		{
			instance.mapNotes = null;
		}
		if (leaderMapNotes != null)
		{
			instance.leaderMapNotes = Pool.Get<List<Note>>();
			for (int k = 0; k < leaderMapNotes.Count; k++)
			{
				Note item3 = leaderMapNotes[k].Copy();
				instance.leaderMapNotes.Add(item3);
			}
		}
		else
		{
			instance.leaderMapNotes = null;
		}
	}

	public AppTeamInfo Copy()
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		CopyTo(appTeamInfo);
		return appTeamInfo;
	}

	public static AppTeamInfo Deserialize(BufferStream stream)
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		Deserialize(stream, appTeamInfo, isDelta: false);
		return appTeamInfo;
	}

	public static AppTeamInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		DeserializeLengthDelimited(stream, appTeamInfo, isDelta: false);
		return appTeamInfo;
	}

	public static AppTeamInfo DeserializeLength(BufferStream stream, int length)
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		DeserializeLength(stream, length, appTeamInfo, isDelta: false);
		return appTeamInfo;
	}

	public static AppTeamInfo Deserialize(byte[] buffer)
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTeamInfo, isDelta: false);
		return appTeamInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTeamInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTeamInfo Deserialize(BufferStream stream, AppTeamInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.leaderSteamId = 0uL;
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.mapNotes == null)
			{
				instance.mapNotes = Pool.Get<List<Note>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<Note>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.leaderSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.mapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.leaderMapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppTeamInfo DeserializeLengthDelimited(BufferStream stream, AppTeamInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.leaderSteamId = 0uL;
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.mapNotes == null)
			{
				instance.mapNotes = Pool.Get<List<Note>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<Note>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.leaderSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.mapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.leaderMapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTeamInfo DeserializeLength(BufferStream stream, int length, AppTeamInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.leaderSteamId = 0uL;
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.mapNotes == null)
			{
				instance.mapNotes = Pool.Get<List<Note>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<Note>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.leaderSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.mapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.leaderMapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTeamInfo instance, AppTeamInfo previous)
	{
		if (instance.leaderSteamId != previous.leaderSteamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.leaderSteamId);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				Member member = instance.members[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Member.SerializeDelta(stream, member, member);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.mapNotes != null)
		{
			for (int j = 0; j < instance.mapNotes.Count; j++)
			{
				Note note = instance.mapNotes[j];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Note.SerializeDelta(stream, note, note);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.leaderMapNotes == null)
		{
			return;
		}
		for (int k = 0; k < instance.leaderMapNotes.Count; k++)
		{
			Note note2 = instance.leaderMapNotes[k];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			Note.SerializeDelta(stream, note2, note2);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AppTeamInfo instance)
	{
		if (instance.leaderSteamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.leaderSteamId);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				Member instance2 = instance.members[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Member.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.mapNotes != null)
		{
			for (int j = 0; j < instance.mapNotes.Count; j++)
			{
				Note instance3 = instance.mapNotes[j];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Note.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.leaderMapNotes == null)
		{
			return;
		}
		for (int k = 0; k < instance.leaderMapNotes.Count; k++)
		{
			Note instance4 = instance.leaderMapNotes[k];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			Note.Serialize(stream, instance4);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (members != null)
		{
			for (int i = 0; i < members.Count; i++)
			{
				members[i]?.InspectUids(action);
			}
		}
		if (mapNotes != null)
		{
			for (int j = 0; j < mapNotes.Count; j++)
			{
				mapNotes[j]?.InspectUids(action);
			}
		}
		if (leaderMapNotes != null)
		{
			for (int k = 0; k < leaderMapNotes.Count; k++)
			{
				leaderMapNotes[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTeamMessage : IDisposable, IPooled, IProto<AppTeamMessage>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public string message;

	[NonSerialized]
	public string color;

	[NonSerialized]
	public uint time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTeamMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.name = string.Empty;
			instance.message = string.Empty;
			instance.color = string.Empty;
			instance.time = 0u;
			Pool.Free<AppTeamMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTeamMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTeamMessage instance)
	{
		instance.steamId = steamId;
		instance.name = name;
		instance.message = message;
		instance.color = color;
		instance.time = time;
	}

	public AppTeamMessage Copy()
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		CopyTo(appTeamMessage);
		return appTeamMessage;
	}

	public static AppTeamMessage Deserialize(BufferStream stream)
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		Deserialize(stream, appTeamMessage, isDelta: false);
		return appTeamMessage;
	}

	public static AppTeamMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		DeserializeLengthDelimited(stream, appTeamMessage, isDelta: false);
		return appTeamMessage;
	}

	public static AppTeamMessage DeserializeLength(BufferStream stream, int length)
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		DeserializeLength(stream, length, appTeamMessage, isDelta: false);
		return appTeamMessage;
	}

	public static AppTeamMessage Deserialize(byte[] buffer)
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTeamMessage, isDelta: false);
		return appTeamMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTeamMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTeamMessage Deserialize(BufferStream stream, AppTeamMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.color = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.time = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppTeamMessage DeserializeLengthDelimited(BufferStream stream, AppTeamMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.color = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.time = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTeamMessage DeserializeLength(BufferStream stream, int length, AppTeamMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.color = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.time = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTeamMessage instance, AppTeamMessage previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.message != previous.message)
		{
			if (instance.message == null)
			{
				throw new ArgumentNullException("message", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.message);
		}
		if (instance.color != previous.color)
		{
			if (instance.color == null)
			{
				throw new ArgumentNullException("color", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.color);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.time);
		}
	}

	public static void Serialize(BufferStream stream, AppTeamMessage instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.message);
		if (instance.color == null)
		{
			throw new ArgumentNullException("color", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteString(stream, instance.color);
		if (instance.time != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTime : IDisposable, IPooled, IProto<AppTime>, IProto
{
	[NonSerialized]
	public float dayLengthMinutes;

	[NonSerialized]
	public float timeScale;

	[NonSerialized]
	public float sunrise;

	[NonSerialized]
	public float sunset;

	[NonSerialized]
	public float time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTime instance)
	{
		if (instance.ShouldPool)
		{
			instance.dayLengthMinutes = 0f;
			instance.timeScale = 0f;
			instance.sunrise = 0f;
			instance.sunset = 0f;
			instance.time = 0f;
			Pool.Free<AppTime>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTime with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTime instance)
	{
		instance.dayLengthMinutes = dayLengthMinutes;
		instance.timeScale = timeScale;
		instance.sunrise = sunrise;
		instance.sunset = sunset;
		instance.time = time;
	}

	public AppTime Copy()
	{
		AppTime appTime = Pool.Get<AppTime>();
		CopyTo(appTime);
		return appTime;
	}

	public static AppTime Deserialize(BufferStream stream)
	{
		AppTime appTime = Pool.Get<AppTime>();
		Deserialize(stream, appTime, isDelta: false);
		return appTime;
	}

	public static AppTime DeserializeLengthDelimited(BufferStream stream)
	{
		AppTime appTime = Pool.Get<AppTime>();
		DeserializeLengthDelimited(stream, appTime, isDelta: false);
		return appTime;
	}

	public static AppTime DeserializeLength(BufferStream stream, int length)
	{
		AppTime appTime = Pool.Get<AppTime>();
		DeserializeLength(stream, length, appTime, isDelta: false);
		return appTime;
	}

	public static AppTime Deserialize(byte[] buffer)
	{
		AppTime appTime = Pool.Get<AppTime>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTime, isDelta: false);
		return appTime;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTime previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTime Deserialize(BufferStream stream, AppTime instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.dayLengthMinutes = 0f;
			instance.timeScale = 0f;
			instance.sunrise = 0f;
			instance.sunset = 0f;
			instance.time = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.dayLengthMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.timeScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.sunrise = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunset = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppTime DeserializeLengthDelimited(BufferStream stream, AppTime instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.dayLengthMinutes = 0f;
			instance.timeScale = 0f;
			instance.sunrise = 0f;
			instance.sunset = 0f;
			instance.time = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.dayLengthMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.timeScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.sunrise = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunset = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTime DeserializeLength(BufferStream stream, int length, AppTime instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.dayLengthMinutes = 0f;
			instance.timeScale = 0f;
			instance.sunrise = 0f;
			instance.sunset = 0f;
			instance.time = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.dayLengthMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.timeScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.sunrise = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.sunset = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTime instance, AppTime previous)
	{
		if (instance.dayLengthMinutes != previous.dayLengthMinutes)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.dayLengthMinutes);
		}
		if (instance.timeScale != previous.timeScale)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeScale);
		}
		if (instance.sunrise != previous.sunrise)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.sunrise);
		}
		if (instance.sunset != previous.sunset)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.sunset);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public static void Serialize(BufferStream stream, AppTime instance)
	{
		if (instance.dayLengthMinutes != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.dayLengthMinutes);
		}
		if (instance.timeScale != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeScale);
		}
		if (instance.sunrise != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.sunrise);
		}
		if (instance.sunset != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.sunset);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ArcadeGame : IDisposable, IPooled, IProto<ArcadeGame>, IProto
{
	public class arcadeEnt : IDisposable, IPooled, IProto<arcadeEnt>, IProto
	{
		[NonSerialized]
		public uint id;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public uint spriteID;

		[NonSerialized]
		public uint soundID;

		[NonSerialized]
		public bool visible;

		[NonSerialized]
		public Vector3 position;

		[NonSerialized]
		public Vector3 heading;

		[NonSerialized]
		public bool enabled;

		[NonSerialized]
		public Vector3 scale;

		[NonSerialized]
		public Vector3 colliderScale;

		[NonSerialized]
		public float alpha;

		[NonSerialized]
		public uint prefabID;

		[NonSerialized]
		public uint parentID;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(arcadeEnt instance)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.id = 0u;
				instance.name = string.Empty;
				instance.spriteID = 0u;
				instance.soundID = 0u;
				instance.visible = false;
				instance.position = default(Vector3);
				instance.heading = default(Vector3);
				instance.enabled = false;
				instance.scale = default(Vector3);
				instance.colliderScale = default(Vector3);
				instance.alpha = 0f;
				instance.prefabID = 0u;
				instance.parentID = 0u;
				Pool.Free<arcadeEnt>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose arcadeEnt with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(arcadeEnt instance)
		{
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			instance.id = id;
			instance.name = name;
			instance.spriteID = spriteID;
			instance.soundID = soundID;
			instance.visible = visible;
			instance.position = position;
			instance.heading = heading;
			instance.enabled = enabled;
			instance.scale = scale;
			instance.colliderScale = colliderScale;
			instance.alpha = alpha;
			instance.prefabID = prefabID;
			instance.parentID = parentID;
		}

		public arcadeEnt Copy()
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			CopyTo(arcadeEnt);
			return arcadeEnt;
		}

		public static arcadeEnt Deserialize(BufferStream stream)
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			Deserialize(stream, arcadeEnt, isDelta: false);
			return arcadeEnt;
		}

		public static arcadeEnt DeserializeLengthDelimited(BufferStream stream)
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			DeserializeLengthDelimited(stream, arcadeEnt, isDelta: false);
			return arcadeEnt;
		}

		public static arcadeEnt DeserializeLength(BufferStream stream, int length)
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			DeserializeLength(stream, length, arcadeEnt, isDelta: false);
			return arcadeEnt;
		}

		public static arcadeEnt Deserialize(byte[] buffer)
		{
			arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, arcadeEnt, isDelta: false);
			return arcadeEnt;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, arcadeEnt previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static arcadeEnt Deserialize(BufferStream stream, arcadeEnt instance, bool isDelta)
		{
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0151: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.id = ProtocolParser.ReadUInt32(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.spriteID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 32:
					instance.soundID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 40:
					instance.visible = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 58:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
					continue;
				case 64:
					instance.enabled = ProtocolParser.ReadBool(stream);
					continue;
				case 74:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
					continue;
				case 82:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
					continue;
				case 93:
					instance.alpha = ProtocolParser.ReadSingle(stream);
					continue;
				case 96:
					instance.prefabID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 104:
					instance.parentID = ProtocolParser.ReadUInt32(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static arcadeEnt DeserializeLengthDelimited(BufferStream stream, arcadeEnt instance, bool isDelta)
		{
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0182: Unknown result type (might be due to invalid IL or missing references)
			//IL_016f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.id = ProtocolParser.ReadUInt32(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.spriteID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 32:
					instance.soundID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 40:
					instance.visible = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 58:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
					continue;
				case 64:
					instance.enabled = ProtocolParser.ReadBool(stream);
					continue;
				case 74:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
					continue;
				case 82:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
					continue;
				case 93:
					instance.alpha = ProtocolParser.ReadSingle(stream);
					continue;
				case 96:
					instance.prefabID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 104:
					instance.parentID = ProtocolParser.ReadUInt32(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static arcadeEnt DeserializeLength(BufferStream stream, int length, arcadeEnt instance, bool isDelta)
		{
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_017a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0167: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.id = ProtocolParser.ReadUInt32(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.spriteID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 32:
					instance.soundID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 40:
					instance.visible = ProtocolParser.ReadBool(stream);
					continue;
				case 50:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 58:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
					continue;
				case 64:
					instance.enabled = ProtocolParser.ReadBool(stream);
					continue;
				case 74:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
					continue;
				case 82:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
					continue;
				case 93:
					instance.alpha = ProtocolParser.ReadSingle(stream);
					continue;
				case 96:
					instance.prefabID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 104:
					instance.parentID = ProtocolParser.ReadUInt32(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, arcadeEnt instance, arcadeEnt previous)
		{
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0202: Unknown result type (might be due to invalid IL or missing references)
			//IL_0208: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_022f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0235: Unknown result type (might be due to invalid IL or missing references)
			if (instance.id != previous.id)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, instance.id);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.spriteID != previous.spriteID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt32(stream, instance.spriteID);
			}
			if (instance.soundID != previous.soundID)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, instance.soundID);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.visible);
			if (instance.position != previous.position)
			{
				stream.WriteByte(50);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.heading != previous.heading)
			{
				stream.WriteByte(58);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.heading, previous.heading);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heading (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.enabled);
			if (instance.scale != previous.scale)
			{
				stream.WriteByte(74);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int num5 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.scale, previous.scale);
				int num6 = stream.Position - num5;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span3, 0);
			}
			if (instance.colliderScale != previous.colliderScale)
			{
				stream.WriteByte(82);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int num7 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.colliderScale, previous.colliderScale);
				int num8 = stream.Position - num7;
				if (num8 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colliderScale (UnityEngine.Vector3)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num8, span4, 0);
			}
			if (instance.alpha != previous.alpha)
			{
				stream.WriteByte(93);
				ProtocolParser.WriteSingle(stream, instance.alpha);
			}
			if (instance.prefabID != previous.prefabID)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteUInt32(stream, instance.prefabID);
			}
			if (instance.parentID != previous.parentID)
			{
				stream.WriteByte(104);
				ProtocolParser.WriteUInt32(stream, instance.parentID);
			}
		}

		public static void Serialize(BufferStream stream, arcadeEnt instance)
		{
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018c: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01af: Unknown result type (might be due to invalid IL or missing references)
			//IL_0215: Unknown result type (might be due to invalid IL or missing references)
			if (instance.id != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, instance.id);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.spriteID != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt32(stream, instance.spriteID);
			}
			if (instance.soundID != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, instance.soundID);
			}
			if (instance.visible)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.visible);
			}
			if (instance.position != default(Vector3))
			{
				stream.WriteByte(50);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.Serialize(stream, instance.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.heading != default(Vector3))
			{
				stream.WriteByte(58);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.heading);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heading (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
			if (instance.enabled)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteBool(stream, instance.enabled);
			}
			if (instance.scale != default(Vector3))
			{
				stream.WriteByte(74);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int num5 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.scale);
				int num6 = stream.Position - num5;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span3, 0);
			}
			if (instance.colliderScale != default(Vector3))
			{
				stream.WriteByte(82);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int num7 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.colliderScale);
				int num8 = stream.Position - num7;
				if (num8 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colliderScale (UnityEngine.Vector3)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num8, span4, 0);
			}
			if (instance.alpha != 0f)
			{
				stream.WriteByte(93);
				ProtocolParser.WriteSingle(stream, instance.alpha);
			}
			if (instance.prefabID != 0)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteUInt32(stream, instance.prefabID);
			}
			if (instance.parentID != 0)
			{
				stream.WriteByte(104);
				ProtocolParser.WriteUInt32(stream, instance.parentID);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<arcadeEnt> arcadeEnts;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ArcadeGame instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.arcadeEnts != null)
		{
			for (int i = 0; i < instance.arcadeEnts.Count; i++)
			{
				if (instance.arcadeEnts[i] != null)
				{
					instance.arcadeEnts[i].ResetToPool();
					instance.arcadeEnts[i] = null;
				}
			}
			List<arcadeEnt> list = instance.arcadeEnts;
			Pool.Free<arcadeEnt>(ref list, false);
			instance.arcadeEnts = list;
		}
		Pool.Free<ArcadeGame>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ArcadeGame with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ArcadeGame instance)
	{
		if (arcadeEnts != null)
		{
			instance.arcadeEnts = Pool.Get<List<arcadeEnt>>();
			for (int i = 0; i < arcadeEnts.Count; i++)
			{
				arcadeEnt item = arcadeEnts[i].Copy();
				instance.arcadeEnts.Add(item);
			}
		}
		else
		{
			instance.arcadeEnts = null;
		}
	}

	public ArcadeGame Copy()
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		CopyTo(arcadeGame);
		return arcadeGame;
	}

	public static ArcadeGame Deserialize(BufferStream stream)
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		Deserialize(stream, arcadeGame, isDelta: false);
		return arcadeGame;
	}

	public static ArcadeGame DeserializeLengthDelimited(BufferStream stream)
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		DeserializeLengthDelimited(stream, arcadeGame, isDelta: false);
		return arcadeGame;
	}

	public static ArcadeGame DeserializeLength(BufferStream stream, int length)
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		DeserializeLength(stream, length, arcadeGame, isDelta: false);
		return arcadeGame;
	}

	public static ArcadeGame Deserialize(byte[] buffer)
	{
		ArcadeGame arcadeGame = Pool.Get<ArcadeGame>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, arcadeGame, isDelta: false);
		return arcadeGame;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ArcadeGame previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ArcadeGame Deserialize(BufferStream stream, ArcadeGame instance, bool isDelta)
	{
		if (!isDelta && instance.arcadeEnts == null)
		{
			instance.arcadeEnts = Pool.Get<List<arcadeEnt>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.arcadeEnts.Add(arcadeEnt.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ArcadeGame DeserializeLengthDelimited(BufferStream stream, ArcadeGame instance, bool isDelta)
	{
		if (!isDelta && instance.arcadeEnts == null)
		{
			instance.arcadeEnts = Pool.Get<List<arcadeEnt>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.arcadeEnts.Add(arcadeEnt.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ArcadeGame DeserializeLength(BufferStream stream, int length, ArcadeGame instance, bool isDelta)
	{
		if (!isDelta && instance.arcadeEnts == null)
		{
			instance.arcadeEnts = Pool.Get<List<arcadeEnt>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.arcadeEnts.Add(arcadeEnt.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ArcadeGame instance, ArcadeGame previous)
	{
		if (instance.arcadeEnts == null)
		{
			return;
		}
		for (int i = 0; i < instance.arcadeEnts.Count; i++)
		{
			arcadeEnt arcadeEnt = instance.arcadeEnts[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			arcadeEnt.SerializeDelta(stream, arcadeEnt, arcadeEnt);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ArcadeGame instance)
	{
		if (instance.arcadeEnts == null)
		{
			return;
		}
		for (int i = 0; i < instance.arcadeEnts.Count; i++)
		{
			arcadeEnt instance2 = instance.arcadeEnts[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			arcadeEnt.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (arcadeEnts != null)
		{
			for (int i = 0; i < arcadeEnts.Count; i++)
			{
				arcadeEnts[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ArcadeMachine : IDisposable, IPooled, IProto<ArcadeMachine>, IProto
{
	public class ScoreEntry : IDisposable, IPooled, IProto<ScoreEntry>, IProto
	{
		[NonSerialized]
		public ulong playerID;

		[NonSerialized]
		public string displayName;

		[NonSerialized]
		public int score;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ScoreEntry instance)
		{
			if (instance.ShouldPool)
			{
				instance.playerID = 0uL;
				instance.displayName = string.Empty;
				instance.score = 0;
				Pool.Free<ScoreEntry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ScoreEntry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ScoreEntry instance)
		{
			instance.playerID = playerID;
			instance.displayName = displayName;
			instance.score = score;
		}

		public ScoreEntry Copy()
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			CopyTo(scoreEntry);
			return scoreEntry;
		}

		public static ScoreEntry Deserialize(BufferStream stream)
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			Deserialize(stream, scoreEntry, isDelta: false);
			return scoreEntry;
		}

		public static ScoreEntry DeserializeLengthDelimited(BufferStream stream)
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			DeserializeLengthDelimited(stream, scoreEntry, isDelta: false);
			return scoreEntry;
		}

		public static ScoreEntry DeserializeLength(BufferStream stream, int length)
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			DeserializeLength(stream, length, scoreEntry, isDelta: false);
			return scoreEntry;
		}

		public static ScoreEntry Deserialize(byte[] buffer)
		{
			ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, scoreEntry, isDelta: false);
			return scoreEntry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ScoreEntry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ScoreEntry Deserialize(BufferStream stream, ScoreEntry instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ScoreEntry DeserializeLengthDelimited(BufferStream stream, ScoreEntry instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ScoreEntry DeserializeLength(BufferStream stream, int length, ScoreEntry instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ScoreEntry instance, ScoreEntry previous)
		{
			if (instance.playerID != previous.playerID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.displayName != null && instance.displayName != previous.displayName)
			{
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.score != previous.score)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public static void Serialize(BufferStream stream, ScoreEntry instance)
		{
			if (instance.playerID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.displayName != null)
			{
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.score != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<ScoreEntry> scores;

	[NonSerialized]
	public int genericInt1;

	[NonSerialized]
	public int genericInt2;

	[NonSerialized]
	public int genericInt3;

	[NonSerialized]
	public int genericInt4;

	[NonSerialized]
	public float genericFloat1;

	[NonSerialized]
	public float genericFloat2;

	[NonSerialized]
	public float genericFloat3;

	[NonSerialized]
	public float genericFloat4;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ArcadeMachine instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				if (instance.scores[i] != null)
				{
					instance.scores[i].ResetToPool();
					instance.scores[i] = null;
				}
			}
			List<ScoreEntry> list = instance.scores;
			Pool.Free<ScoreEntry>(ref list, false);
			instance.scores = list;
		}
		instance.genericInt1 = 0;
		instance.genericInt2 = 0;
		instance.genericInt3 = 0;
		instance.genericInt4 = 0;
		instance.genericFloat1 = 0f;
		instance.genericFloat2 = 0f;
		instance.genericFloat3 = 0f;
		instance.genericFloat4 = 0f;
		Pool.Free<ArcadeMachine>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ArcadeMachine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ArcadeMachine instance)
	{
		if (scores != null)
		{
			instance.scores = Pool.Get<List<ScoreEntry>>();
			for (int i = 0; i < scores.Count; i++)
			{
				ScoreEntry item = scores[i].Copy();
				instance.scores.Add(item);
			}
		}
		else
		{
			instance.scores = null;
		}
		instance.genericInt1 = genericInt1;
		instance.genericInt2 = genericInt2;
		instance.genericInt3 = genericInt3;
		instance.genericInt4 = genericInt4;
		instance.genericFloat1 = genericFloat1;
		instance.genericFloat2 = genericFloat2;
		instance.genericFloat3 = genericFloat3;
		instance.genericFloat4 = genericFloat4;
	}

	public ArcadeMachine Copy()
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		CopyTo(arcadeMachine);
		return arcadeMachine;
	}

	public static ArcadeMachine Deserialize(BufferStream stream)
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		Deserialize(stream, arcadeMachine, isDelta: false);
		return arcadeMachine;
	}

	public static ArcadeMachine DeserializeLengthDelimited(BufferStream stream)
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		DeserializeLengthDelimited(stream, arcadeMachine, isDelta: false);
		return arcadeMachine;
	}

	public static ArcadeMachine DeserializeLength(BufferStream stream, int length)
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		DeserializeLength(stream, length, arcadeMachine, isDelta: false);
		return arcadeMachine;
	}

	public static ArcadeMachine Deserialize(byte[] buffer)
	{
		ArcadeMachine arcadeMachine = Pool.Get<ArcadeMachine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, arcadeMachine, isDelta: false);
		return arcadeMachine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ArcadeMachine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ArcadeMachine Deserialize(BufferStream stream, ArcadeMachine instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<ScoreEntry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.scores.Add(ScoreEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.genericInt4 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.genericFloat3 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat4 = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ArcadeMachine DeserializeLengthDelimited(BufferStream stream, ArcadeMachine instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<ScoreEntry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.scores.Add(ScoreEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.genericInt4 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.genericFloat3 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat4 = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ArcadeMachine DeserializeLength(BufferStream stream, int length, ArcadeMachine instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<ScoreEntry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.scores.Add(ScoreEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.genericInt1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.genericInt2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.genericInt3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.genericInt4 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.genericFloat1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.genericFloat2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.genericFloat3 = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.genericFloat4 = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ArcadeMachine instance, ArcadeMachine previous)
	{
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				ScoreEntry scoreEntry = instance.scores[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ScoreEntry.SerializeDelta(stream, scoreEntry, scoreEntry);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.genericInt1 != previous.genericInt1)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt1);
		}
		if (instance.genericInt2 != previous.genericInt2)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt2);
		}
		if (instance.genericInt3 != previous.genericInt3)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt3);
		}
		if (instance.genericInt4 != previous.genericInt4)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt4);
		}
		if (instance.genericFloat1 != previous.genericFloat1)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.genericFloat1);
		}
		if (instance.genericFloat2 != previous.genericFloat2)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.genericFloat2);
		}
		if (instance.genericFloat3 != previous.genericFloat3)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.genericFloat3);
		}
		if (instance.genericFloat4 != previous.genericFloat4)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.genericFloat4);
		}
	}

	public static void Serialize(BufferStream stream, ArcadeMachine instance)
	{
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				ScoreEntry instance2 = instance.scores[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ScoreEntry.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.genericInt1 != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt1);
		}
		if (instance.genericInt2 != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt2);
		}
		if (instance.genericInt3 != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt3);
		}
		if (instance.genericInt4 != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.genericInt4);
		}
		if (instance.genericFloat1 != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.genericFloat1);
		}
		if (instance.genericFloat2 != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.genericFloat2);
		}
		if (instance.genericFloat3 != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.genericFloat3);
		}
		if (instance.genericFloat4 != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.genericFloat4);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (scores != null)
		{
			for (int i = 0; i < scores.Count; i++)
			{
				scores[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AssociatedFiles : IDisposable, IPooled, IProto<AssociatedFiles>, IProto
{
	public class AssociatedFile : IDisposable, IPooled, IProto<AssociatedFile>, IProto
	{
		[NonSerialized]
		public int type;

		[NonSerialized]
		public uint crc;

		[NonSerialized]
		public uint numID;

		[NonSerialized]
		public byte[] data;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(AssociatedFile instance)
		{
			if (instance.ShouldPool)
			{
				instance.type = 0;
				instance.crc = 0u;
				instance.numID = 0u;
				instance.data = null;
				Pool.Free<AssociatedFile>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose AssociatedFile with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(AssociatedFile instance)
		{
			instance.type = type;
			instance.crc = crc;
			instance.numID = numID;
			if (data == null)
			{
				instance.data = null;
				return;
			}
			instance.data = new byte[data.Length];
			Array.Copy(data, instance.data, instance.data.Length);
		}

		public AssociatedFile Copy()
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			CopyTo(associatedFile);
			return associatedFile;
		}

		public static AssociatedFile Deserialize(BufferStream stream)
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			Deserialize(stream, associatedFile, isDelta: false);
			return associatedFile;
		}

		public static AssociatedFile DeserializeLengthDelimited(BufferStream stream)
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			DeserializeLengthDelimited(stream, associatedFile, isDelta: false);
			return associatedFile;
		}

		public static AssociatedFile DeserializeLength(BufferStream stream, int length)
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			DeserializeLength(stream, length, associatedFile, isDelta: false);
			return associatedFile;
		}

		public static AssociatedFile Deserialize(byte[] buffer)
		{
			AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, associatedFile, isDelta: false);
			return associatedFile;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, AssociatedFile previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static AssociatedFile Deserialize(BufferStream stream, AssociatedFile instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.crc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 24:
					instance.numID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 34:
					instance.data = ProtocolParser.ReadBytes(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static AssociatedFile DeserializeLengthDelimited(BufferStream stream, AssociatedFile instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.crc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 24:
					instance.numID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 34:
					instance.data = ProtocolParser.ReadBytes(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static AssociatedFile DeserializeLength(BufferStream stream, int length, AssociatedFile instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.crc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 24:
					instance.numID = ProtocolParser.ReadUInt32(stream);
					continue;
				case 34:
					instance.data = ProtocolParser.ReadBytes(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, AssociatedFile instance, AssociatedFile previous)
		{
			if (instance.type != previous.type)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.crc != previous.crc)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt32(stream, instance.crc);
			}
			if (instance.numID != previous.numID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt32(stream, instance.numID);
			}
			if (instance.data == null)
			{
				throw new ArgumentNullException("data", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteBytes(stream, instance.data);
		}

		public static void Serialize(BufferStream stream, AssociatedFile instance)
		{
			if (instance.type != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.crc != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt32(stream, instance.crc);
			}
			if (instance.numID != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt32(stream, instance.numID);
			}
			if (instance.data == null)
			{
				throw new ArgumentNullException("data", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteBytes(stream, instance.data);
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<AssociatedFile> files;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AssociatedFiles instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.files != null)
		{
			for (int i = 0; i < instance.files.Count; i++)
			{
				if (instance.files[i] != null)
				{
					instance.files[i].ResetToPool();
					instance.files[i] = null;
				}
			}
			List<AssociatedFile> list = instance.files;
			Pool.Free<AssociatedFile>(ref list, false);
			instance.files = list;
		}
		Pool.Free<AssociatedFiles>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AssociatedFiles with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AssociatedFiles instance)
	{
		if (files != null)
		{
			instance.files = Pool.Get<List<AssociatedFile>>();
			for (int i = 0; i < files.Count; i++)
			{
				AssociatedFile item = files[i].Copy();
				instance.files.Add(item);
			}
		}
		else
		{
			instance.files = null;
		}
	}

	public AssociatedFiles Copy()
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		CopyTo(associatedFiles);
		return associatedFiles;
	}

	public static AssociatedFiles Deserialize(BufferStream stream)
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		Deserialize(stream, associatedFiles, isDelta: false);
		return associatedFiles;
	}

	public static AssociatedFiles DeserializeLengthDelimited(BufferStream stream)
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		DeserializeLengthDelimited(stream, associatedFiles, isDelta: false);
		return associatedFiles;
	}

	public static AssociatedFiles DeserializeLength(BufferStream stream, int length)
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		DeserializeLength(stream, length, associatedFiles, isDelta: false);
		return associatedFiles;
	}

	public static AssociatedFiles Deserialize(byte[] buffer)
	{
		AssociatedFiles associatedFiles = Pool.Get<AssociatedFiles>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, associatedFiles, isDelta: false);
		return associatedFiles;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AssociatedFiles previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AssociatedFiles Deserialize(BufferStream stream, AssociatedFiles instance, bool isDelta)
	{
		if (!isDelta && instance.files == null)
		{
			instance.files = Pool.Get<List<AssociatedFile>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.files.Add(AssociatedFile.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AssociatedFiles DeserializeLengthDelimited(BufferStream stream, AssociatedFiles instance, bool isDelta)
	{
		if (!isDelta && instance.files == null)
		{
			instance.files = Pool.Get<List<AssociatedFile>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.files.Add(AssociatedFile.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AssociatedFiles DeserializeLength(BufferStream stream, int length, AssociatedFiles instance, bool isDelta)
	{
		if (!isDelta && instance.files == null)
		{
			instance.files = Pool.Get<List<AssociatedFile>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.files.Add(AssociatedFile.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AssociatedFiles instance, AssociatedFiles previous)
	{
		if (instance.files == null)
		{
			return;
		}
		for (int i = 0; i < instance.files.Count; i++)
		{
			AssociatedFile associatedFile = instance.files[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AssociatedFile.SerializeDelta(stream, associatedFile, associatedFile);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AssociatedFiles instance)
	{
		if (instance.files == null)
		{
			return;
		}
		for (int i = 0; i < instance.files.Count; i++)
		{
			AssociatedFile instance2 = instance.files[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AssociatedFile.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (files != null)
		{
			for (int i = 0; i < files.Count; i++)
			{
				files[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Attack : IDisposable, IPooled, IProto<Attack>, IProto
{
	[NonSerialized]
	public Vector3 pointStart;

	[NonSerialized]
	public Vector3 pointEnd;

	[NonSerialized]
	public NetworkableId hitID;

	[NonSerialized]
	public uint hitBone;

	[NonSerialized]
	public Vector3 hitNormalLocal;

	[NonSerialized]
	public Vector3 hitPositionLocal;

	[NonSerialized]
	public Vector3 hitNormalWorld;

	[NonSerialized]
	public Vector3 hitPositionWorld;

	[NonSerialized]
	public uint hitPartID;

	[NonSerialized]
	public uint hitMaterialID;

	[NonSerialized]
	public NetworkableId srcParentID;

	[NonSerialized]
	public NetworkableId dstParentID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Attack instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.pointStart = default(Vector3);
			instance.pointEnd = default(Vector3);
			instance.hitID = default(NetworkableId);
			instance.hitBone = 0u;
			instance.hitNormalLocal = default(Vector3);
			instance.hitPositionLocal = default(Vector3);
			instance.hitNormalWorld = default(Vector3);
			instance.hitPositionWorld = default(Vector3);
			instance.hitPartID = 0u;
			instance.hitMaterialID = 0u;
			instance.srcParentID = default(NetworkableId);
			instance.dstParentID = default(NetworkableId);
			Pool.Free<Attack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Attack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Attack instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.pointStart = pointStart;
		instance.pointEnd = pointEnd;
		instance.hitID = hitID;
		instance.hitBone = hitBone;
		instance.hitNormalLocal = hitNormalLocal;
		instance.hitPositionLocal = hitPositionLocal;
		instance.hitNormalWorld = hitNormalWorld;
		instance.hitPositionWorld = hitPositionWorld;
		instance.hitPartID = hitPartID;
		instance.hitMaterialID = hitMaterialID;
		instance.srcParentID = srcParentID;
		instance.dstParentID = dstParentID;
	}

	public Attack Copy()
	{
		Attack attack = Pool.Get<Attack>();
		CopyTo(attack);
		return attack;
	}

	public static Attack Deserialize(BufferStream stream)
	{
		Attack attack = Pool.Get<Attack>();
		Deserialize(stream, attack, isDelta: false);
		return attack;
	}

	public static Attack DeserializeLengthDelimited(BufferStream stream)
	{
		Attack attack = Pool.Get<Attack>();
		DeserializeLengthDelimited(stream, attack, isDelta: false);
		return attack;
	}

	public static Attack DeserializeLength(BufferStream stream, int length)
	{
		Attack attack = Pool.Get<Attack>();
		DeserializeLength(stream, length, attack, isDelta: false);
		return attack;
	}

	public static Attack Deserialize(byte[] buffer)
	{
		Attack attack = Pool.Get<Attack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, attack, isDelta: false);
		return attack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Attack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Attack Deserialize(BufferStream stream, Attack instance, bool isDelta)
	{
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointStart, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointEnd, isDelta);
				continue;
			case 24:
				instance.hitID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.hitBone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalLocal, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionLocal, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalWorld, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionWorld, isDelta);
				continue;
			case 72:
				instance.hitPartID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.hitMaterialID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.srcParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.dstParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Attack DeserializeLengthDelimited(BufferStream stream, Attack instance, bool isDelta)
	{
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointStart, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointEnd, isDelta);
				continue;
			case 24:
				instance.hitID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.hitBone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalLocal, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionLocal, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalWorld, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionWorld, isDelta);
				continue;
			case 72:
				instance.hitPartID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.hitMaterialID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.srcParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.dstParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Attack DeserializeLength(BufferStream stream, int length, Attack instance, bool isDelta)
	{
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointStart, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pointEnd, isDelta);
				continue;
			case 24:
				instance.hitID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.hitBone = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalLocal, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionLocal, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormalWorld, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPositionWorld, isDelta);
				continue;
			case 72:
				instance.hitPartID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 80:
				instance.hitMaterialID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 88:
				instance.srcParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.dstParentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Attack instance, Attack previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pointStart != previous.pointStart)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.pointStart, previous.pointStart);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pointStart (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.pointEnd != previous.pointEnd)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.pointEnd, previous.pointEnd);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pointEnd (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.hitID.Value);
		if (instance.hitBone != previous.hitBone)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.hitBone);
		}
		if (instance.hitNormalLocal != previous.hitNormalLocal)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitNormalLocal, previous.hitNormalLocal);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormalLocal (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.hitPositionLocal != previous.hitPositionLocal)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitPositionLocal, previous.hitPositionLocal);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPositionLocal (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.hitNormalWorld != previous.hitNormalWorld)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitNormalWorld, previous.hitNormalWorld);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormalWorld (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.hitPositionWorld != previous.hitPositionWorld)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitPositionWorld, previous.hitPositionWorld);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPositionWorld (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.hitPartID != previous.hitPartID)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.hitPartID);
		}
		if (instance.hitMaterialID != previous.hitMaterialID)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.hitMaterialID);
		}
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, instance.srcParentID.Value);
		stream.WriteByte(96);
		ProtocolParser.WriteUInt64(stream, instance.dstParentID.Value);
	}

	public static void Serialize(BufferStream stream, Attack instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pointStart != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.pointStart);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pointStart (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.pointEnd != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.pointEnd);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pointEnd (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.hitID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.hitID.Value);
		}
		if (instance.hitBone != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.hitBone);
		}
		if (instance.hitNormalLocal != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitNormalLocal);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormalLocal (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.hitPositionLocal != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitPositionLocal);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPositionLocal (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.hitNormalWorld != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitNormalWorld);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormalWorld (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.hitPositionWorld != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitPositionWorld);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPositionWorld (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.hitPartID != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt32(stream, instance.hitPartID);
		}
		if (instance.hitMaterialID != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt32(stream, instance.hitMaterialID);
		}
		if (instance.srcParentID != default(NetworkableId))
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, instance.srcParentID.Value);
		}
		if (instance.dstParentID != default(NetworkableId))
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt64(stream, instance.dstParentID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref hitID.Value);
		action(UidType.NetworkableId, ref srcParentID.Value);
		action(UidType.NetworkableId, ref dstParentID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AttackHeli : IDisposable, IPooled, IProto<AttackHeli>, IProto
{
	[NonSerialized]
	public NetworkableId turretID;

	[NonSerialized]
	public NetworkableId rocketsID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AttackHeli instance)
	{
		if (instance.ShouldPool)
		{
			instance.turretID = default(NetworkableId);
			instance.rocketsID = default(NetworkableId);
			Pool.Free<AttackHeli>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AttackHeli with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AttackHeli instance)
	{
		instance.turretID = turretID;
		instance.rocketsID = rocketsID;
	}

	public AttackHeli Copy()
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		CopyTo(attackHeli);
		return attackHeli;
	}

	public static AttackHeli Deserialize(BufferStream stream)
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		Deserialize(stream, attackHeli, isDelta: false);
		return attackHeli;
	}

	public static AttackHeli DeserializeLengthDelimited(BufferStream stream)
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		DeserializeLengthDelimited(stream, attackHeli, isDelta: false);
		return attackHeli;
	}

	public static AttackHeli DeserializeLength(BufferStream stream, int length)
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		DeserializeLength(stream, length, attackHeli, isDelta: false);
		return attackHeli;
	}

	public static AttackHeli Deserialize(byte[] buffer)
	{
		AttackHeli attackHeli = Pool.Get<AttackHeli>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, attackHeli, isDelta: false);
		return attackHeli;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AttackHeli previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AttackHeli Deserialize(BufferStream stream, AttackHeli instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.turretID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.rocketsID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AttackHeli DeserializeLengthDelimited(BufferStream stream, AttackHeli instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.turretID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.rocketsID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AttackHeli DeserializeLength(BufferStream stream, int length, AttackHeli instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.turretID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.rocketsID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AttackHeli instance, AttackHeli previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.turretID.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.rocketsID.Value);
	}

	public static void Serialize(BufferStream stream, AttackHeli instance)
	{
		if (instance.turretID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.turretID.Value);
		}
		if (instance.rocketsID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.rocketsID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref turretID.Value);
		action(UidType.NetworkableId, ref rocketsID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AttackHeliRockets : IDisposable, IPooled, IProto<AttackHeliRockets>, IProto
{
	[NonSerialized]
	public int totalAmmo;

	[NonSerialized]
	public int rocketsSinceReload;

	[NonSerialized]
	public bool hasFlares;

	[NonSerialized]
	public int ammoItemID;

	[NonSerialized]
	public int preferredAmmoType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AttackHeliRockets instance)
	{
		if (instance.ShouldPool)
		{
			instance.totalAmmo = 0;
			instance.rocketsSinceReload = 0;
			instance.hasFlares = false;
			instance.ammoItemID = 0;
			instance.preferredAmmoType = 0;
			Pool.Free<AttackHeliRockets>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AttackHeliRockets with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AttackHeliRockets instance)
	{
		instance.totalAmmo = totalAmmo;
		instance.rocketsSinceReload = rocketsSinceReload;
		instance.hasFlares = hasFlares;
		instance.ammoItemID = ammoItemID;
		instance.preferredAmmoType = preferredAmmoType;
	}

	public AttackHeliRockets Copy()
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		CopyTo(attackHeliRockets);
		return attackHeliRockets;
	}

	public static AttackHeliRockets Deserialize(BufferStream stream)
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		Deserialize(stream, attackHeliRockets, isDelta: false);
		return attackHeliRockets;
	}

	public static AttackHeliRockets DeserializeLengthDelimited(BufferStream stream)
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		DeserializeLengthDelimited(stream, attackHeliRockets, isDelta: false);
		return attackHeliRockets;
	}

	public static AttackHeliRockets DeserializeLength(BufferStream stream, int length)
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		DeserializeLength(stream, length, attackHeliRockets, isDelta: false);
		return attackHeliRockets;
	}

	public static AttackHeliRockets Deserialize(byte[] buffer)
	{
		AttackHeliRockets attackHeliRockets = Pool.Get<AttackHeliRockets>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, attackHeliRockets, isDelta: false);
		return attackHeliRockets;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AttackHeliRockets previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AttackHeliRockets Deserialize(BufferStream stream, AttackHeliRockets instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rocketsSinceReload = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.hasFlares = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.ammoItemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.preferredAmmoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AttackHeliRockets DeserializeLengthDelimited(BufferStream stream, AttackHeliRockets instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rocketsSinceReload = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.hasFlares = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.ammoItemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.preferredAmmoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AttackHeliRockets DeserializeLength(BufferStream stream, int length, AttackHeliRockets instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rocketsSinceReload = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.hasFlares = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.ammoItemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.preferredAmmoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AttackHeliRockets instance, AttackHeliRockets previous)
	{
		if (instance.totalAmmo != previous.totalAmmo)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAmmo);
		}
		if (instance.rocketsSinceReload != previous.rocketsSinceReload)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rocketsSinceReload);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.hasFlares);
		if (instance.ammoItemID != previous.ammoItemID)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoItemID);
		}
		if (instance.preferredAmmoType != previous.preferredAmmoType)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.preferredAmmoType);
		}
	}

	public static void Serialize(BufferStream stream, AttackHeliRockets instance)
	{
		if (instance.totalAmmo != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAmmo);
		}
		if (instance.rocketsSinceReload != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rocketsSinceReload);
		}
		if (instance.hasFlares)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.hasFlares);
		}
		if (instance.ammoItemID != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoItemID);
		}
		if (instance.preferredAmmoType != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.preferredAmmoType);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AttackHeliTurret : IDisposable, IPooled, IProto<AttackHeliTurret>, IProto
{
	[NonSerialized]
	public int clipAmmo;

	[NonSerialized]
	public int totalAmmo;

	[NonSerialized]
	public int gunState;

	[NonSerialized]
	public float xRot;

	[NonSerialized]
	public float yRot;

	[NonSerialized]
	public NetworkableId heldEntityID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AttackHeliTurret instance)
	{
		if (instance.ShouldPool)
		{
			instance.clipAmmo = 0;
			instance.totalAmmo = 0;
			instance.gunState = 0;
			instance.xRot = 0f;
			instance.yRot = 0f;
			instance.heldEntityID = default(NetworkableId);
			Pool.Free<AttackHeliTurret>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AttackHeliTurret with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AttackHeliTurret instance)
	{
		instance.clipAmmo = clipAmmo;
		instance.totalAmmo = totalAmmo;
		instance.gunState = gunState;
		instance.xRot = xRot;
		instance.yRot = yRot;
		instance.heldEntityID = heldEntityID;
	}

	public AttackHeliTurret Copy()
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		CopyTo(attackHeliTurret);
		return attackHeliTurret;
	}

	public static AttackHeliTurret Deserialize(BufferStream stream)
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		Deserialize(stream, attackHeliTurret, isDelta: false);
		return attackHeliTurret;
	}

	public static AttackHeliTurret DeserializeLengthDelimited(BufferStream stream)
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		DeserializeLengthDelimited(stream, attackHeliTurret, isDelta: false);
		return attackHeliTurret;
	}

	public static AttackHeliTurret DeserializeLength(BufferStream stream, int length)
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		DeserializeLength(stream, length, attackHeliTurret, isDelta: false);
		return attackHeliTurret;
	}

	public static AttackHeliTurret Deserialize(byte[] buffer)
	{
		AttackHeliTurret attackHeliTurret = Pool.Get<AttackHeliTurret>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, attackHeliTurret, isDelta: false);
		return attackHeliTurret;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AttackHeliTurret previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AttackHeliTurret Deserialize(BufferStream stream, AttackHeliTurret instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clipAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.gunState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.xRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.heldEntityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AttackHeliTurret DeserializeLengthDelimited(BufferStream stream, AttackHeliTurret instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clipAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.gunState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.xRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.heldEntityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AttackHeliTurret DeserializeLength(BufferStream stream, int length, AttackHeliTurret instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clipAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.totalAmmo = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.gunState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.xRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.heldEntityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AttackHeliTurret instance, AttackHeliTurret previous)
	{
		if (instance.clipAmmo != previous.clipAmmo)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clipAmmo);
		}
		if (instance.totalAmmo != previous.totalAmmo)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAmmo);
		}
		if (instance.gunState != previous.gunState)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gunState);
		}
		if (instance.xRot != previous.xRot)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.xRot);
		}
		if (instance.yRot != previous.yRot)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.yRot);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, instance.heldEntityID.Value);
	}

	public static void Serialize(BufferStream stream, AttackHeliTurret instance)
	{
		if (instance.clipAmmo != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clipAmmo);
		}
		if (instance.totalAmmo != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAmmo);
		}
		if (instance.gunState != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gunState);
		}
		if (instance.xRot != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.xRot);
		}
		if (instance.yRot != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.yRot);
		}
		if (instance.heldEntityID != default(NetworkableId))
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.heldEntityID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref heldEntityID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AudioEntity : IDisposable, IPooled, IProto<AudioEntity>, IProto
{
	[NonSerialized]
	public int colourMode;

	[NonSerialized]
	public int volumeRange;

	[NonSerialized]
	public int speed;

	[NonSerialized]
	public int gradient;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AudioEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.colourMode = 0;
			instance.volumeRange = 0;
			instance.speed = 0;
			instance.gradient = 0;
			Pool.Free<AudioEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AudioEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AudioEntity instance)
	{
		instance.colourMode = colourMode;
		instance.volumeRange = volumeRange;
		instance.speed = speed;
		instance.gradient = gradient;
	}

	public AudioEntity Copy()
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		CopyTo(audioEntity);
		return audioEntity;
	}

	public static AudioEntity Deserialize(BufferStream stream)
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		Deserialize(stream, audioEntity, isDelta: false);
		return audioEntity;
	}

	public static AudioEntity DeserializeLengthDelimited(BufferStream stream)
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		DeserializeLengthDelimited(stream, audioEntity, isDelta: false);
		return audioEntity;
	}

	public static AudioEntity DeserializeLength(BufferStream stream, int length)
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		DeserializeLength(stream, length, audioEntity, isDelta: false);
		return audioEntity;
	}

	public static AudioEntity Deserialize(byte[] buffer)
	{
		AudioEntity audioEntity = Pool.Get<AudioEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, audioEntity, isDelta: false);
		return audioEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AudioEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AudioEntity Deserialize(BufferStream stream, AudioEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.colourMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.volumeRange = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.speed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.gradient = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AudioEntity DeserializeLengthDelimited(BufferStream stream, AudioEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.colourMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.volumeRange = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.speed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.gradient = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AudioEntity DeserializeLength(BufferStream stream, int length, AudioEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.colourMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.volumeRange = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.speed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.gradient = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AudioEntity instance, AudioEntity previous)
	{
		if (instance.colourMode != previous.colourMode)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourMode);
		}
		if (instance.volumeRange != previous.volumeRange)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.volumeRange);
		}
		if (instance.speed != previous.speed)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.speed);
		}
		if (instance.gradient != previous.gradient)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gradient);
		}
	}

	public static void Serialize(BufferStream stream, AudioEntity instance)
	{
		if (instance.colourMode != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourMode);
		}
		if (instance.volumeRange != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.volumeRange);
		}
		if (instance.speed != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.speed);
		}
		if (instance.gradient != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gradient);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class AutoTurret : IDisposable, IPooled, IProto<AutoTurret>, IProto
{
	[NonSerialized]
	public Vector3 aimPos;

	[NonSerialized]
	public Vector3 aimDir;

	[NonSerialized]
	public uint targetID;

	[NonSerialized]
	public List<PlayerNameID> users;

	[NonSerialized]
	public int powerOrder;

	[NonSerialized]
	public List<NetworkableId> interferenceList;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AutoTurret instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.aimPos = default(Vector3);
		instance.aimDir = default(Vector3);
		instance.targetID = 0u;
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				if (instance.users[i] != null)
				{
					instance.users[i].ResetToPool();
					instance.users[i] = null;
				}
			}
			List<PlayerNameID> list = instance.users;
			Pool.Free<PlayerNameID>(ref list, false);
			instance.users = list;
		}
		instance.powerOrder = 0;
		if (instance.interferenceList != null)
		{
			List<NetworkableId> list2 = instance.interferenceList;
			Pool.FreeUnmanaged<NetworkableId>(ref list2);
			instance.interferenceList = list2;
		}
		Pool.Free<AutoTurret>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AutoTurret with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AutoTurret instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.aimPos = aimPos;
		instance.aimDir = aimDir;
		instance.targetID = targetID;
		if (users != null)
		{
			instance.users = Pool.Get<List<PlayerNameID>>();
			for (int i = 0; i < users.Count; i++)
			{
				PlayerNameID item = users[i].Copy();
				instance.users.Add(item);
			}
		}
		else
		{
			instance.users = null;
		}
		instance.powerOrder = powerOrder;
		if (interferenceList != null)
		{
			instance.interferenceList = Pool.Get<List<NetworkableId>>();
			for (int j = 0; j < interferenceList.Count; j++)
			{
				NetworkableId item2 = interferenceList[j];
				instance.interferenceList.Add(item2);
			}
		}
		else
		{
			instance.interferenceList = null;
		}
	}

	public AutoTurret Copy()
	{
		AutoTurret autoTurret = Pool.Get<AutoTurret>();
		CopyTo(autoTurret);
		return autoTurret;
	}

	public static AutoTurret Deserialize(BufferStream stream)
	{
		AutoTurret autoTurret = Pool.Get<AutoTurret>();
		Deserialize(stream, autoTurret, isDelta: false);
		return autoTurret;
	}

	public static AutoTurret DeserializeLengthDelimited(BufferStream stream)
	{
		AutoTurret autoTurret = Pool.Get<AutoTurret>();
		DeserializeLengthDelimited(stream, autoTurret, isDelta: false);
		return autoTurret;
	}

	public static AutoTurret DeserializeLength(BufferStream stream, int length)
	{
		AutoTurret autoTurret = Pool.Get<AutoTurret>();
		DeserializeLength(stream, length, autoTurret, isDelta: false);
		return autoTurret;
	}

	public static AutoTurret Deserialize(byte[] buffer)
	{
		AutoTurret autoTurret = Pool.Get<AutoTurret>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, autoTurret, isDelta: false);
		return autoTurret;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AutoTurret previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AutoTurret Deserialize(BufferStream stream, AutoTurret instance, bool isDelta)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.users == null)
			{
				instance.users = Pool.Get<List<PlayerNameID>>();
			}
			if (instance.interferenceList == null)
			{
				instance.interferenceList = Pool.Get<List<NetworkableId>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				continue;
			case 24:
				instance.targetID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.users.Add(PlayerNameID.DeserializeLengthDelimited(stream));
				continue;
			case 40:
				instance.powerOrder = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.interferenceList.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AutoTurret DeserializeLengthDelimited(BufferStream stream, AutoTurret instance, bool isDelta)
	{
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.users == null)
			{
				instance.users = Pool.Get<List<PlayerNameID>>();
			}
			if (instance.interferenceList == null)
			{
				instance.interferenceList = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				continue;
			case 24:
				instance.targetID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.users.Add(PlayerNameID.DeserializeLengthDelimited(stream));
				continue;
			case 40:
				instance.powerOrder = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.interferenceList.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AutoTurret DeserializeLength(BufferStream stream, int length, AutoTurret instance, bool isDelta)
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.users == null)
			{
				instance.users = Pool.Get<List<PlayerNameID>>();
			}
			if (instance.interferenceList == null)
			{
				instance.interferenceList = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				continue;
			case 24:
				instance.targetID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.users.Add(PlayerNameID.DeserializeLengthDelimited(stream));
				continue;
			case 40:
				instance.powerOrder = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.interferenceList.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AutoTurret instance, AutoTurret previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aimPos != previous.aimPos)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aimPos, previous.aimPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.aimDir != previous.aimDir)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aimDir, previous.aimDir);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.targetID != previous.targetID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.targetID);
		}
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				PlayerNameID playerNameID = instance.users[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				PlayerNameID.SerializeDelta(stream, playerNameID, playerNameID);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.powerOrder != previous.powerOrder)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.powerOrder);
		}
		if (instance.interferenceList != null)
		{
			for (int j = 0; j < instance.interferenceList.Count; j++)
			{
				NetworkableId networkableId = instance.interferenceList[j];
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public static void Serialize(BufferStream stream, AutoTurret instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aimPos != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aimPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.aimDir != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aimDir);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.targetID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.targetID);
		}
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				PlayerNameID instance2 = instance.users[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				PlayerNameID.Serialize(stream, instance2);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.powerOrder != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.powerOrder);
		}
		if (instance.interferenceList != null)
		{
			for (int j = 0; j < instance.interferenceList.Count; j++)
			{
				NetworkableId networkableId = instance.interferenceList[j];
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (users != null)
		{
			for (int i = 0; i < users.Count; i++)
			{
				users[i]?.InspectUids(action);
			}
		}
		for (int j = 0; j < interferenceList.Count; j++)
		{
			NetworkableId value = interferenceList[j];
			action(UidType.NetworkableId, ref value.Value);
			interferenceList[j] = value;
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Ballista : IDisposable, IPooled, IProto<Ballista>, IProto
{
	[NonSerialized]
	public NetworkableId gunID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Ballista instance)
	{
		if (instance.ShouldPool)
		{
			instance.gunID = default(NetworkableId);
			Pool.Free<Ballista>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Ballista with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Ballista instance)
	{
		instance.gunID = gunID;
	}

	public Ballista Copy()
	{
		Ballista ballista = Pool.Get<Ballista>();
		CopyTo(ballista);
		return ballista;
	}

	public static Ballista Deserialize(BufferStream stream)
	{
		Ballista ballista = Pool.Get<Ballista>();
		Deserialize(stream, ballista, isDelta: false);
		return ballista;
	}

	public static Ballista DeserializeLengthDelimited(BufferStream stream)
	{
		Ballista ballista = Pool.Get<Ballista>();
		DeserializeLengthDelimited(stream, ballista, isDelta: false);
		return ballista;
	}

	public static Ballista DeserializeLength(BufferStream stream, int length)
	{
		Ballista ballista = Pool.Get<Ballista>();
		DeserializeLength(stream, length, ballista, isDelta: false);
		return ballista;
	}

	public static Ballista Deserialize(byte[] buffer)
	{
		Ballista ballista = Pool.Get<Ballista>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ballista, isDelta: false);
		return ballista;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Ballista previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Ballista Deserialize(BufferStream stream, Ballista instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.gunID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Ballista DeserializeLengthDelimited(BufferStream stream, Ballista instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.gunID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Ballista DeserializeLength(BufferStream stream, int length, Ballista instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.gunID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Ballista instance, Ballista previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.gunID.Value);
	}

	public static void Serialize(BufferStream stream, Ballista instance)
	{
		if (instance.gunID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.gunID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref gunID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class BallistaGun : IDisposable, IPooled, IProto<BallistaGun>, IProto
{
	[NonSerialized]
	public Magazine magazine;

	[NonSerialized]
	public float reloadProgress;

	[NonSerialized]
	public Vector3 aimDir;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BallistaGun instance)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			if (instance.magazine != null)
			{
				instance.magazine.ResetToPool();
				instance.magazine = null;
			}
			instance.reloadProgress = 0f;
			instance.aimDir = default(Vector3);
			Pool.Free<BallistaGun>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BallistaGun with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BallistaGun instance)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (magazine != null)
		{
			if (instance.magazine == null)
			{
				instance.magazine = magazine.Copy();
			}
			else
			{
				magazine.CopyTo(instance.magazine);
			}
		}
		else
		{
			instance.magazine = null;
		}
		instance.reloadProgress = reloadProgress;
		instance.aimDir = aimDir;
	}

	public BallistaGun Copy()
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		CopyTo(ballistaGun);
		return ballistaGun;
	}

	public static BallistaGun Deserialize(BufferStream stream)
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		Deserialize(stream, ballistaGun, isDelta: false);
		return ballistaGun;
	}

	public static BallistaGun DeserializeLengthDelimited(BufferStream stream)
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		DeserializeLengthDelimited(stream, ballistaGun, isDelta: false);
		return ballistaGun;
	}

	public static BallistaGun DeserializeLength(BufferStream stream, int length)
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		DeserializeLength(stream, length, ballistaGun, isDelta: false);
		return ballistaGun;
	}

	public static BallistaGun Deserialize(byte[] buffer)
	{
		BallistaGun ballistaGun = Pool.Get<BallistaGun>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ballistaGun, isDelta: false);
		return ballistaGun;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BallistaGun previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BallistaGun Deserialize(BufferStream stream, BallistaGun instance, bool isDelta)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.magazine == null)
				{
					instance.magazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.magazine, isDelta);
				}
				break;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				break;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static BallistaGun DeserializeLengthDelimited(BufferStream stream, BallistaGun instance, bool isDelta)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.magazine == null)
				{
					instance.magazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.magazine, isDelta);
				}
				break;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				break;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BallistaGun DeserializeLength(BufferStream stream, int length, BallistaGun instance, bool isDelta)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.magazine == null)
				{
					instance.magazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.magazine, isDelta);
				}
				break;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				break;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BallistaGun instance, BallistaGun previous)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (instance.magazine != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Magazine.SerializeDelta(stream, instance.magazine, previous.magazine);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field magazine (ProtoBuf.Magazine)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.reloadProgress != previous.reloadProgress)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.reloadProgress);
		}
		if (instance.aimDir != previous.aimDir)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aimDir, previous.aimDir);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, BallistaGun instance)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.magazine != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Magazine.Serialize(stream, instance.magazine);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field magazine (ProtoBuf.Magazine)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.reloadProgress != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.reloadProgress);
		}
		if (instance.aimDir != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aimDir);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		magazine?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseBoat : IDisposable, IPooled, IProto<BaseBoat>, IProto
{
	[NonSerialized]
	public float shoreDriftTimerValue;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseBoat instance)
	{
		if (instance.ShouldPool)
		{
			instance.shoreDriftTimerValue = 0f;
			Pool.Free<BaseBoat>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseBoat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseBoat instance)
	{
		instance.shoreDriftTimerValue = shoreDriftTimerValue;
	}

	public BaseBoat Copy()
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		CopyTo(baseBoat);
		return baseBoat;
	}

	public static BaseBoat Deserialize(BufferStream stream)
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		Deserialize(stream, baseBoat, isDelta: false);
		return baseBoat;
	}

	public static BaseBoat DeserializeLengthDelimited(BufferStream stream)
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		DeserializeLengthDelimited(stream, baseBoat, isDelta: false);
		return baseBoat;
	}

	public static BaseBoat DeserializeLength(BufferStream stream, int length)
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		DeserializeLength(stream, length, baseBoat, isDelta: false);
		return baseBoat;
	}

	public static BaseBoat Deserialize(byte[] buffer)
	{
		BaseBoat baseBoat = Pool.Get<BaseBoat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseBoat, isDelta: false);
		return baseBoat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseBoat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseBoat Deserialize(BufferStream stream, BaseBoat instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.shoreDriftTimerValue = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseBoat DeserializeLengthDelimited(BufferStream stream, BaseBoat instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.shoreDriftTimerValue = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseBoat DeserializeLength(BufferStream stream, int length, BaseBoat instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.shoreDriftTimerValue = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseBoat instance, BaseBoat previous)
	{
		if (instance.shoreDriftTimerValue != previous.shoreDriftTimerValue)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.shoreDriftTimerValue);
		}
	}

	public static void Serialize(BufferStream stream, BaseBoat instance)
	{
		if (instance.shoreDriftTimerValue != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.shoreDriftTimerValue);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseCombat : IDisposable, IPooled, IProto<BaseCombat>, IProto
{
	[NonSerialized]
	public int state;

	[NonSerialized]
	public float health;

	[NonSerialized]
	public float maxHealth;

	[NonSerialized]
	public float maxHealthOverride;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseCombat instance)
	{
		if (instance.ShouldPool)
		{
			instance.state = 0;
			instance.health = 0f;
			instance.maxHealth = 0f;
			instance.maxHealthOverride = 0f;
			Pool.Free<BaseCombat>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseCombat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseCombat instance)
	{
		instance.state = state;
		instance.health = health;
		instance.maxHealth = maxHealth;
		instance.maxHealthOverride = maxHealthOverride;
	}

	public BaseCombat Copy()
	{
		BaseCombat baseCombat = Pool.Get<BaseCombat>();
		CopyTo(baseCombat);
		return baseCombat;
	}

	public static BaseCombat Deserialize(BufferStream stream)
	{
		BaseCombat baseCombat = Pool.Get<BaseCombat>();
		Deserialize(stream, baseCombat, isDelta: false);
		return baseCombat;
	}

	public static BaseCombat DeserializeLengthDelimited(BufferStream stream)
	{
		BaseCombat baseCombat = Pool.Get<BaseCombat>();
		DeserializeLengthDelimited(stream, baseCombat, isDelta: false);
		return baseCombat;
	}

	public static BaseCombat DeserializeLength(BufferStream stream, int length)
	{
		BaseCombat baseCombat = Pool.Get<BaseCombat>();
		DeserializeLength(stream, length, baseCombat, isDelta: false);
		return baseCombat;
	}

	public static BaseCombat Deserialize(byte[] buffer)
	{
		BaseCombat baseCombat = Pool.Get<BaseCombat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseCombat, isDelta: false);
		return baseCombat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseCombat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseCombat Deserialize(BufferStream stream, BaseCombat instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.maxHealth = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.maxHealthOverride = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseCombat DeserializeLengthDelimited(BufferStream stream, BaseCombat instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.maxHealth = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.maxHealthOverride = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseCombat DeserializeLength(BufferStream stream, int length, BaseCombat instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.maxHealth = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.maxHealthOverride = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseCombat instance, BaseCombat previous)
	{
		if (instance.state != previous.state)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.health != previous.health)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.maxHealth != previous.maxHealth)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.maxHealth);
		}
		if (instance.maxHealthOverride != previous.maxHealthOverride)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.maxHealthOverride);
		}
	}

	public static void Serialize(BufferStream stream, BaseCombat instance)
	{
		if (instance.state != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.health != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.maxHealth != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.maxHealth);
		}
		if (instance.maxHealthOverride != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.maxHealthOverride);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class BaseEntity : IDisposable, IPooled, IProto<BaseEntity>, IProto
{
	[NonSerialized]
	public Vector3 pos;

	[NonSerialized]
	public Vector3 rot;

	[NonSerialized]
	public int flags;

	[NonSerialized]
	public float time;

	[NonSerialized]
	public ulong skinid;

	[NonSerialized]
	public float protection;

	[NonSerialized]
	public byte[] syncVars;

	[NonSerialized]
	public Vector3 scale;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseEntity instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.pos = default(Vector3);
			instance.rot = default(Vector3);
			instance.flags = 0;
			instance.time = 0f;
			instance.skinid = 0uL;
			instance.protection = 0f;
			instance.syncVars = null;
			instance.scale = default(Vector3);
			Pool.Free<BaseEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseEntity instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		instance.pos = pos;
		instance.rot = rot;
		instance.flags = flags;
		instance.time = time;
		instance.skinid = skinid;
		instance.protection = protection;
		if (syncVars == null)
		{
			instance.syncVars = null;
		}
		else
		{
			instance.syncVars = new byte[syncVars.Length];
			Array.Copy(syncVars, instance.syncVars, instance.syncVars.Length);
		}
		instance.scale = scale;
	}

	public BaseEntity Copy()
	{
		BaseEntity baseEntity = Pool.Get<BaseEntity>();
		CopyTo(baseEntity);
		return baseEntity;
	}

	public static BaseEntity Deserialize(BufferStream stream)
	{
		BaseEntity baseEntity = Pool.Get<BaseEntity>();
		Deserialize(stream, baseEntity, isDelta: false);
		return baseEntity;
	}

	public static BaseEntity DeserializeLengthDelimited(BufferStream stream)
	{
		BaseEntity baseEntity = Pool.Get<BaseEntity>();
		DeserializeLengthDelimited(stream, baseEntity, isDelta: false);
		return baseEntity;
	}

	public static BaseEntity DeserializeLength(BufferStream stream, int length)
	{
		BaseEntity baseEntity = Pool.Get<BaseEntity>();
		DeserializeLength(stream, length, baseEntity, isDelta: false);
		return baseEntity;
	}

	public static BaseEntity Deserialize(byte[] buffer)
	{
		BaseEntity baseEntity = Pool.Get<BaseEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseEntity, isDelta: false);
		return baseEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseEntity Deserialize(BufferStream stream, BaseEntity instance, bool isDelta)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rot, isDelta);
				continue;
			case 24:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.skinid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.protection = ProtocolParser.ReadSingle(stream);
				continue;
			case 58:
				instance.syncVars = ProtocolParser.ReadBytes(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseEntity DeserializeLengthDelimited(BufferStream stream, BaseEntity instance, bool isDelta)
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rot, isDelta);
				continue;
			case 24:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.skinid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.protection = ProtocolParser.ReadSingle(stream);
				continue;
			case 58:
				instance.syncVars = ProtocolParser.ReadBytes(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseEntity DeserializeLength(BufferStream stream, int length, BaseEntity instance, bool isDelta)
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rot, isDelta);
				continue;
			case 24:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.skinid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.protection = ProtocolParser.ReadSingle(stream);
				continue;
			case 58:
				instance.syncVars = ProtocolParser.ReadBytes(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseEntity instance, BaseEntity previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pos != previous.pos)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.pos, previous.pos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.rot != previous.rot)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rot, previous.rot);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rot (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.flags != previous.flags)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.skinid != previous.skinid)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.skinid);
		}
		if (instance.protection != previous.protection)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.protection);
		}
		if (instance.syncVars != null)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteBytes(stream, instance.syncVars);
		}
		if (instance.scale != previous.scale)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.scale, previous.scale);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public static void Serialize(BufferStream stream, BaseEntity instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pos != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.pos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.rot != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rot);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rot (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.flags != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.skinid != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.skinid);
		}
		if (instance.protection != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.protection);
		}
		if (instance.syncVars != null)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteBytes(stream, instance.syncVars);
		}
		if (instance.scale != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.scale);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseMelee : IDisposable, IPooled, IProto<BaseMelee>, IProto
{
	[NonSerialized]
	public bool canThrowAsProjectile;

	[NonSerialized]
	public bool onlyThrowAsProjectile;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseMelee instance)
	{
		if (instance.ShouldPool)
		{
			instance.canThrowAsProjectile = false;
			instance.onlyThrowAsProjectile = false;
			Pool.Free<BaseMelee>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseMelee with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseMelee instance)
	{
		instance.canThrowAsProjectile = canThrowAsProjectile;
		instance.onlyThrowAsProjectile = onlyThrowAsProjectile;
	}

	public BaseMelee Copy()
	{
		BaseMelee baseMelee = Pool.Get<BaseMelee>();
		CopyTo(baseMelee);
		return baseMelee;
	}

	public static BaseMelee Deserialize(BufferStream stream)
	{
		BaseMelee baseMelee = Pool.Get<BaseMelee>();
		Deserialize(stream, baseMelee, isDelta: false);
		return baseMelee;
	}

	public static BaseMelee DeserializeLengthDelimited(BufferStream stream)
	{
		BaseMelee baseMelee = Pool.Get<BaseMelee>();
		DeserializeLengthDelimited(stream, baseMelee, isDelta: false);
		return baseMelee;
	}

	public static BaseMelee DeserializeLength(BufferStream stream, int length)
	{
		BaseMelee baseMelee = Pool.Get<BaseMelee>();
		DeserializeLength(stream, length, baseMelee, isDelta: false);
		return baseMelee;
	}

	public static BaseMelee Deserialize(byte[] buffer)
	{
		BaseMelee baseMelee = Pool.Get<BaseMelee>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseMelee, isDelta: false);
		return baseMelee;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseMelee previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseMelee Deserialize(BufferStream stream, BaseMelee instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.canThrowAsProjectile = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.onlyThrowAsProjectile = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseMelee DeserializeLengthDelimited(BufferStream stream, BaseMelee instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.canThrowAsProjectile = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.onlyThrowAsProjectile = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseMelee DeserializeLength(BufferStream stream, int length, BaseMelee instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.canThrowAsProjectile = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.onlyThrowAsProjectile = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseMelee instance, BaseMelee previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.canThrowAsProjectile);
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.onlyThrowAsProjectile);
	}

	public static void Serialize(BufferStream stream, BaseMelee instance)
	{
		if (instance.canThrowAsProjectile)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.canThrowAsProjectile);
		}
		if (instance.onlyThrowAsProjectile)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.onlyThrowAsProjectile);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseNetworkable : IDisposable, IPooled, IProto<BaseNetworkable>, IProto
{
	[NonSerialized]
	public NetworkableId uid;

	[NonSerialized]
	public uint group;

	[NonSerialized]
	public uint prefabID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseNetworkable instance)
	{
		if (instance.ShouldPool)
		{
			instance.uid = default(NetworkableId);
			instance.group = 0u;
			instance.prefabID = 0u;
			Pool.Free<BaseNetworkable>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseNetworkable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseNetworkable instance)
	{
		instance.uid = uid;
		instance.group = group;
		instance.prefabID = prefabID;
	}

	public BaseNetworkable Copy()
	{
		BaseNetworkable baseNetworkable = Pool.Get<BaseNetworkable>();
		CopyTo(baseNetworkable);
		return baseNetworkable;
	}

	public static BaseNetworkable Deserialize(BufferStream stream)
	{
		BaseNetworkable baseNetworkable = Pool.Get<BaseNetworkable>();
		Deserialize(stream, baseNetworkable, isDelta: false);
		return baseNetworkable;
	}

	public static BaseNetworkable DeserializeLengthDelimited(BufferStream stream)
	{
		BaseNetworkable baseNetworkable = Pool.Get<BaseNetworkable>();
		DeserializeLengthDelimited(stream, baseNetworkable, isDelta: false);
		return baseNetworkable;
	}

	public static BaseNetworkable DeserializeLength(BufferStream stream, int length)
	{
		BaseNetworkable baseNetworkable = Pool.Get<BaseNetworkable>();
		DeserializeLength(stream, length, baseNetworkable, isDelta: false);
		return baseNetworkable;
	}

	public static BaseNetworkable Deserialize(byte[] buffer)
	{
		BaseNetworkable baseNetworkable = Pool.Get<BaseNetworkable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseNetworkable, isDelta: false);
		return baseNetworkable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseNetworkable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseNetworkable Deserialize(BufferStream stream, BaseNetworkable instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.group = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseNetworkable DeserializeLengthDelimited(BufferStream stream, BaseNetworkable instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.group = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseNetworkable DeserializeLength(BufferStream stream, int length, BaseNetworkable instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.group = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseNetworkable instance, BaseNetworkable previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		if (instance.group != previous.group)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.group);
		}
		if (instance.prefabID != previous.prefabID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.prefabID);
		}
	}

	public static void Serialize(BufferStream stream, BaseNetworkable instance)
	{
		if (instance.uid != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		}
		if (instance.group != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.group);
		}
		if (instance.prefabID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.prefabID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref uid.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseNPC : IDisposable, IPooled, IProto<BaseNPC>, IProto
{
	[NonSerialized]
	public int flags;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseNPC instance)
	{
		if (instance.ShouldPool)
		{
			instance.flags = 0;
			Pool.Free<BaseNPC>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseNPC with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseNPC instance)
	{
		instance.flags = flags;
	}

	public BaseNPC Copy()
	{
		BaseNPC baseNPC = Pool.Get<BaseNPC>();
		CopyTo(baseNPC);
		return baseNPC;
	}

	public static BaseNPC Deserialize(BufferStream stream)
	{
		BaseNPC baseNPC = Pool.Get<BaseNPC>();
		Deserialize(stream, baseNPC, isDelta: false);
		return baseNPC;
	}

	public static BaseNPC DeserializeLengthDelimited(BufferStream stream)
	{
		BaseNPC baseNPC = Pool.Get<BaseNPC>();
		DeserializeLengthDelimited(stream, baseNPC, isDelta: false);
		return baseNPC;
	}

	public static BaseNPC DeserializeLength(BufferStream stream, int length)
	{
		BaseNPC baseNPC = Pool.Get<BaseNPC>();
		DeserializeLength(stream, length, baseNPC, isDelta: false);
		return baseNPC;
	}

	public static BaseNPC Deserialize(byte[] buffer)
	{
		BaseNPC baseNPC = Pool.Get<BaseNPC>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseNPC, isDelta: false);
		return baseNPC;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseNPC previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseNPC Deserialize(BufferStream stream, BaseNPC instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 16:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseNPC DeserializeLengthDelimited(BufferStream stream, BaseNPC instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseNPC DeserializeLength(BufferStream stream, int length, BaseNPC instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseNPC instance, BaseNPC previous)
	{
		if (instance.flags != previous.flags)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
	}

	public static void Serialize(BufferStream stream, BaseNPC instance)
	{
		if (instance.flags != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


