using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseOven : IDisposable, IPooled, IProto<BaseOven>, IProto
{
	public class CookingItem : IDisposable, IPooled, IProto<CookingItem>, IProto
	{
		[NonSerialized]
		public int itemID;

		[NonSerialized]
		public int slotIndex;

		[NonSerialized]
		public int initialStackSize;

		[NonSerialized]
		public float cookingProgress;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(CookingItem instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemID = 0;
				instance.slotIndex = 0;
				instance.initialStackSize = 0;
				instance.cookingProgress = 0f;
				Pool.Free<CookingItem>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose CookingItem with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(CookingItem instance)
		{
			instance.itemID = itemID;
			instance.slotIndex = slotIndex;
			instance.initialStackSize = initialStackSize;
			instance.cookingProgress = cookingProgress;
		}

		public CookingItem Copy()
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			CopyTo(cookingItem);
			return cookingItem;
		}

		public static CookingItem Deserialize(BufferStream stream)
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			Deserialize(stream, cookingItem, isDelta: false);
			return cookingItem;
		}

		public static CookingItem DeserializeLengthDelimited(BufferStream stream)
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			DeserializeLengthDelimited(stream, cookingItem, isDelta: false);
			return cookingItem;
		}

		public static CookingItem DeserializeLength(BufferStream stream, int length)
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			DeserializeLength(stream, length, cookingItem, isDelta: false);
			return cookingItem;
		}

		public static CookingItem Deserialize(byte[] buffer)
		{
			CookingItem cookingItem = Pool.Get<CookingItem>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, cookingItem, isDelta: false);
			return cookingItem;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, CookingItem previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static CookingItem Deserialize(BufferStream stream, CookingItem instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 37:
					instance.cookingProgress = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static CookingItem DeserializeLengthDelimited(BufferStream stream, CookingItem instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 37:
					instance.cookingProgress = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static CookingItem DeserializeLength(BufferStream stream, int length, CookingItem instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 37:
					instance.cookingProgress = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, CookingItem instance, CookingItem previous)
		{
			if (instance.itemID != previous.itemID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
			}
			if (instance.slotIndex != previous.slotIndex)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
			}
			if (instance.initialStackSize != previous.initialStackSize)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.initialStackSize);
			}
			if (instance.cookingProgress != previous.cookingProgress)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.cookingProgress);
			}
		}

		public static void Serialize(BufferStream stream, CookingItem instance)
		{
			if (instance.itemID != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
			}
			if (instance.slotIndex != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
			}
			if (instance.initialStackSize != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.initialStackSize);
			}
			if (instance.cookingProgress != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.cookingProgress);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public float cookSpeed;

	[NonSerialized]
	public List<CookingItem> cookingItems;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseOven instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.cookSpeed = 0f;
		if (instance.cookingItems != null)
		{
			for (int i = 0; i < instance.cookingItems.Count; i++)
			{
				if (instance.cookingItems[i] != null)
				{
					instance.cookingItems[i].ResetToPool();
					instance.cookingItems[i] = null;
				}
			}
			List<CookingItem> list = instance.cookingItems;
			Pool.Free<CookingItem>(ref list, false);
			instance.cookingItems = list;
		}
		Pool.Free<BaseOven>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseOven with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseOven instance)
	{
		instance.cookSpeed = cookSpeed;
		if (cookingItems != null)
		{
			instance.cookingItems = Pool.Get<List<CookingItem>>();
			for (int i = 0; i < cookingItems.Count; i++)
			{
				CookingItem item = cookingItems[i].Copy();
				instance.cookingItems.Add(item);
			}
		}
		else
		{
			instance.cookingItems = null;
		}
	}

	public BaseOven Copy()
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		CopyTo(baseOven);
		return baseOven;
	}

	public static BaseOven Deserialize(BufferStream stream)
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		Deserialize(stream, baseOven, isDelta: false);
		return baseOven;
	}

	public static BaseOven DeserializeLengthDelimited(BufferStream stream)
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		DeserializeLengthDelimited(stream, baseOven, isDelta: false);
		return baseOven;
	}

	public static BaseOven DeserializeLength(BufferStream stream, int length)
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		DeserializeLength(stream, length, baseOven, isDelta: false);
		return baseOven;
	}

	public static BaseOven Deserialize(byte[] buffer)
	{
		BaseOven baseOven = Pool.Get<BaseOven>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseOven, isDelta: false);
		return baseOven;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseOven previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseOven Deserialize(BufferStream stream, BaseOven instance, bool isDelta)
	{
		if (!isDelta && instance.cookingItems == null)
		{
			instance.cookingItems = Pool.Get<List<CookingItem>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.cookSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				instance.cookingItems.Add(CookingItem.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseOven DeserializeLengthDelimited(BufferStream stream, BaseOven instance, bool isDelta)
	{
		if (!isDelta && instance.cookingItems == null)
		{
			instance.cookingItems = Pool.Get<List<CookingItem>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.cookSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				instance.cookingItems.Add(CookingItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseOven DeserializeLength(BufferStream stream, int length, BaseOven instance, bool isDelta)
	{
		if (!isDelta && instance.cookingItems == null)
		{
			instance.cookingItems = Pool.Get<List<CookingItem>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.cookSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				instance.cookingItems.Add(CookingItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseOven instance, BaseOven previous)
	{
		if (instance.cookSpeed != previous.cookSpeed)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.cookSpeed);
		}
		if (instance.cookingItems == null)
		{
			return;
		}
		for (int i = 0; i < instance.cookingItems.Count; i++)
		{
			CookingItem cookingItem = instance.cookingItems[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			CookingItem.SerializeDelta(stream, cookingItem, cookingItem);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cookingItems (ProtoBuf.BaseOven.CookingItem)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, BaseOven instance)
	{
		if (instance.cookSpeed != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.cookSpeed);
		}
		if (instance.cookingItems == null)
		{
			return;
		}
		for (int i = 0; i < instance.cookingItems.Count; i++)
		{
			CookingItem instance2 = instance.cookingItems[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			CookingItem.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cookingItems (ProtoBuf.BaseOven.CookingItem)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (cookingItems != null)
		{
			for (int i = 0; i < cookingItems.Count; i++)
			{
				cookingItems[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BasePlayer : IDisposable, IPooled, IProto<BasePlayer>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public ulong userid;

	[NonSerialized]
	public PlayerInventory inventory;

	[NonSerialized]
	public PlayerMetabolism metabolism;

	[NonSerialized]
	public float loadingTimeout;

	[NonSerialized]
	public ModelState modelState;

	[NonSerialized]
	public int playerFlags;

	[NonSerialized]
	public ItemId heldEntity;

	[NonSerialized]
	public float health;

	[NonSerialized]
	public PersistantPlayer persistantData;

	[NonSerialized]
	public float skinCol;

	[NonSerialized]
	public float skinTex;

	[NonSerialized]
	public float skinMesh;

	[NonSerialized]
	public PlayerLifeStory currentLife;

	[NonSerialized]
	public PlayerLifeStory previousLife;

	[NonSerialized]
	public NetworkableId mounted;

	[NonSerialized]
	public ulong currentTeam;

	[NonSerialized]
	public uint underwear;

	[NonSerialized]
	public PlayerModifiers modifiers;

	[NonSerialized]
	public int reputation;

	[NonSerialized]
	public uint loopingGesture;

	[NonSerialized]
	public Missions missions;

	[NonSerialized]
	public string respawnId;

	[NonSerialized]
	public int bagCount;

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public ItemCrafter itemCrafter;

	[NonSerialized]
	public int shelterCount;

	[NonSerialized]
	public int tutorialAllowance;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BasePlayer instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.userid = 0uL;
			if (instance.inventory != null)
			{
				instance.inventory.ResetToPool();
				instance.inventory = null;
			}
			if (instance.metabolism != null)
			{
				instance.metabolism.ResetToPool();
				instance.metabolism = null;
			}
			instance.loadingTimeout = 0f;
			if (instance.modelState != null)
			{
				instance.modelState.ResetToPool();
				instance.modelState = null;
			}
			instance.playerFlags = 0;
			instance.heldEntity = default(ItemId);
			instance.health = 0f;
			if (instance.persistantData != null)
			{
				instance.persistantData.ResetToPool();
				instance.persistantData = null;
			}
			instance.skinCol = 0f;
			instance.skinTex = 0f;
			instance.skinMesh = 0f;
			if (instance.currentLife != null)
			{
				instance.currentLife.ResetToPool();
				instance.currentLife = null;
			}
			if (instance.previousLife != null)
			{
				instance.previousLife.ResetToPool();
				instance.previousLife = null;
			}
			instance.mounted = default(NetworkableId);
			instance.currentTeam = 0uL;
			instance.underwear = 0u;
			if (instance.modifiers != null)
			{
				instance.modifiers.ResetToPool();
				instance.modifiers = null;
			}
			instance.reputation = 0;
			instance.loopingGesture = 0u;
			if (instance.missions != null)
			{
				instance.missions.ResetToPool();
				instance.missions = null;
			}
			instance.respawnId = string.Empty;
			instance.bagCount = 0;
			instance.clanId = 0L;
			if (instance.itemCrafter != null)
			{
				instance.itemCrafter.ResetToPool();
				instance.itemCrafter = null;
			}
			instance.shelterCount = 0;
			instance.tutorialAllowance = 0;
			Pool.Free<BasePlayer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BasePlayer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BasePlayer instance)
	{
		instance.name = name;
		instance.userid = userid;
		if (inventory != null)
		{
			if (instance.inventory == null)
			{
				instance.inventory = inventory.Copy();
			}
			else
			{
				inventory.CopyTo(instance.inventory);
			}
		}
		else
		{
			instance.inventory = null;
		}
		if (metabolism != null)
		{
			if (instance.metabolism == null)
			{
				instance.metabolism = metabolism.Copy();
			}
			else
			{
				metabolism.CopyTo(instance.metabolism);
			}
		}
		else
		{
			instance.metabolism = null;
		}
		instance.loadingTimeout = loadingTimeout;
		if (modelState != null)
		{
			if (instance.modelState == null)
			{
				instance.modelState = modelState.Copy();
			}
			else
			{
				modelState.CopyTo(instance.modelState);
			}
		}
		else
		{
			instance.modelState = null;
		}
		instance.playerFlags = playerFlags;
		instance.heldEntity = heldEntity;
		instance.health = health;
		if (persistantData != null)
		{
			if (instance.persistantData == null)
			{
				instance.persistantData = persistantData.Copy();
			}
			else
			{
				persistantData.CopyTo(instance.persistantData);
			}
		}
		else
		{
			instance.persistantData = null;
		}
		instance.skinCol = skinCol;
		instance.skinTex = skinTex;
		instance.skinMesh = skinMesh;
		if (currentLife != null)
		{
			if (instance.currentLife == null)
			{
				instance.currentLife = currentLife.Copy();
			}
			else
			{
				currentLife.CopyTo(instance.currentLife);
			}
		}
		else
		{
			instance.currentLife = null;
		}
		if (previousLife != null)
		{
			if (instance.previousLife == null)
			{
				instance.previousLife = previousLife.Copy();
			}
			else
			{
				previousLife.CopyTo(instance.previousLife);
			}
		}
		else
		{
			instance.previousLife = null;
		}
		instance.mounted = mounted;
		instance.currentTeam = currentTeam;
		instance.underwear = underwear;
		if (modifiers != null)
		{
			if (instance.modifiers == null)
			{
				instance.modifiers = modifiers.Copy();
			}
			else
			{
				modifiers.CopyTo(instance.modifiers);
			}
		}
		else
		{
			instance.modifiers = null;
		}
		instance.reputation = reputation;
		instance.loopingGesture = loopingGesture;
		if (missions != null)
		{
			if (instance.missions == null)
			{
				instance.missions = missions.Copy();
			}
			else
			{
				missions.CopyTo(instance.missions);
			}
		}
		else
		{
			instance.missions = null;
		}
		instance.respawnId = respawnId;
		instance.bagCount = bagCount;
		instance.clanId = clanId;
		if (itemCrafter != null)
		{
			if (instance.itemCrafter == null)
			{
				instance.itemCrafter = itemCrafter.Copy();
			}
			else
			{
				itemCrafter.CopyTo(instance.itemCrafter);
			}
		}
		else
		{
			instance.itemCrafter = null;
		}
		instance.shelterCount = shelterCount;
		instance.tutorialAllowance = tutorialAllowance;
	}

	public BasePlayer Copy()
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		CopyTo(basePlayer);
		return basePlayer;
	}

	public static BasePlayer Deserialize(BufferStream stream)
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		Deserialize(stream, basePlayer, isDelta: false);
		return basePlayer;
	}

	public static BasePlayer DeserializeLengthDelimited(BufferStream stream)
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		DeserializeLengthDelimited(stream, basePlayer, isDelta: false);
		return basePlayer;
	}

	public static BasePlayer DeserializeLength(BufferStream stream, int length)
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		DeserializeLength(stream, length, basePlayer, isDelta: false);
		return basePlayer;
	}

	public static BasePlayer Deserialize(byte[] buffer)
	{
		BasePlayer basePlayer = Pool.Get<BasePlayer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, basePlayer, isDelta: false);
		return basePlayer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BasePlayer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BasePlayer Deserialize(BufferStream stream, BasePlayer instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (instance.inventory == null)
				{
					instance.inventory = PlayerInventory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerInventory.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				continue;
			case 34:
				if (instance.metabolism == null)
				{
					instance.metabolism = PlayerMetabolism.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerMetabolism.DeserializeLengthDelimited(stream, instance.metabolism, isDelta);
				}
				continue;
			case 45:
				instance.loadingTimeout = ProtocolParser.ReadSingle(stream);
				continue;
			case 50:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				continue;
			case 56:
				instance.playerFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.heldEntity = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				if (instance.persistantData == null)
				{
					instance.persistantData = PersistantPlayer.DeserializeLengthDelimited(stream);
				}
				else
				{
					PersistantPlayer.DeserializeLengthDelimited(stream, instance.persistantData, isDelta);
				}
				continue;
			case 125:
				instance.skinCol = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinTex = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinMesh = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.currentLife == null)
					{
						instance.currentLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.currentLife, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.previousLife == null)
					{
						instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.Varint)
				{
					instance.mounted = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				}
				break;
			case 23u:
				if (key.WireType == Wire.Varint)
				{
					instance.currentTeam = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 24u:
				if (key.WireType == Wire.Varint)
				{
					instance.underwear = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.modifiers == null)
					{
						instance.modifiers = PlayerModifiers.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
					}
				}
				break;
			case 26u:
				if (key.WireType == Wire.Varint)
				{
					instance.reputation = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 27u:
				if (key.WireType == Wire.Varint)
				{
					instance.loopingGesture = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 28u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.missions == null)
					{
						instance.missions = Missions.DeserializeLengthDelimited(stream);
					}
					else
					{
						Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
					}
				}
				break;
			case 29u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.respawnId = ProtocolParser.ReadString(stream);
				}
				break;
			case 30u:
				if (key.WireType == Wire.Varint)
				{
					instance.bagCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 31u:
				if (key.WireType == Wire.Varint)
				{
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.itemCrafter == null)
					{
						instance.itemCrafter = ItemCrafter.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemCrafter.DeserializeLengthDelimited(stream, instance.itemCrafter, isDelta);
					}
				}
				break;
			case 33u:
				if (key.WireType == Wire.Varint)
				{
					instance.shelterCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 34u:
				if (key.WireType == Wire.Varint)
				{
					instance.tutorialAllowance = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static BasePlayer DeserializeLengthDelimited(BufferStream stream, BasePlayer instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (instance.inventory == null)
				{
					instance.inventory = PlayerInventory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerInventory.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				continue;
			case 34:
				if (instance.metabolism == null)
				{
					instance.metabolism = PlayerMetabolism.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerMetabolism.DeserializeLengthDelimited(stream, instance.metabolism, isDelta);
				}
				continue;
			case 45:
				instance.loadingTimeout = ProtocolParser.ReadSingle(stream);
				continue;
			case 50:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				continue;
			case 56:
				instance.playerFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.heldEntity = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				if (instance.persistantData == null)
				{
					instance.persistantData = PersistantPlayer.DeserializeLengthDelimited(stream);
				}
				else
				{
					PersistantPlayer.DeserializeLengthDelimited(stream, instance.persistantData, isDelta);
				}
				continue;
			case 125:
				instance.skinCol = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinTex = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinMesh = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.currentLife == null)
					{
						instance.currentLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.currentLife, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.previousLife == null)
					{
						instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.Varint)
				{
					instance.mounted = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				}
				break;
			case 23u:
				if (key.WireType == Wire.Varint)
				{
					instance.currentTeam = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 24u:
				if (key.WireType == Wire.Varint)
				{
					instance.underwear = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.modifiers == null)
					{
						instance.modifiers = PlayerModifiers.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
					}
				}
				break;
			case 26u:
				if (key.WireType == Wire.Varint)
				{
					instance.reputation = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 27u:
				if (key.WireType == Wire.Varint)
				{
					instance.loopingGesture = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 28u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.missions == null)
					{
						instance.missions = Missions.DeserializeLengthDelimited(stream);
					}
					else
					{
						Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
					}
				}
				break;
			case 29u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.respawnId = ProtocolParser.ReadString(stream);
				}
				break;
			case 30u:
				if (key.WireType == Wire.Varint)
				{
					instance.bagCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 31u:
				if (key.WireType == Wire.Varint)
				{
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.itemCrafter == null)
					{
						instance.itemCrafter = ItemCrafter.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemCrafter.DeserializeLengthDelimited(stream, instance.itemCrafter, isDelta);
					}
				}
				break;
			case 33u:
				if (key.WireType == Wire.Varint)
				{
					instance.shelterCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 34u:
				if (key.WireType == Wire.Varint)
				{
					instance.tutorialAllowance = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BasePlayer DeserializeLength(BufferStream stream, int length, BasePlayer instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (instance.inventory == null)
				{
					instance.inventory = PlayerInventory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerInventory.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				continue;
			case 34:
				if (instance.metabolism == null)
				{
					instance.metabolism = PlayerMetabolism.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerMetabolism.DeserializeLengthDelimited(stream, instance.metabolism, isDelta);
				}
				continue;
			case 45:
				instance.loadingTimeout = ProtocolParser.ReadSingle(stream);
				continue;
			case 50:
				if (instance.modelState == null)
				{
					instance.modelState = ModelState.DeserializeLengthDelimited(stream);
				}
				else
				{
					ModelState.DeserializeLengthDelimited(stream, instance.modelState, isDelta);
				}
				continue;
			case 56:
				instance.playerFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.heldEntity = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				if (instance.persistantData == null)
				{
					instance.persistantData = PersistantPlayer.DeserializeLengthDelimited(stream);
				}
				else
				{
					PersistantPlayer.DeserializeLengthDelimited(stream, instance.persistantData, isDelta);
				}
				continue;
			case 125:
				instance.skinCol = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinTex = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.skinMesh = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.currentLife == null)
					{
						instance.currentLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.currentLife, isDelta);
					}
				}
				break;
			case 21u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.previousLife == null)
					{
						instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
					}
				}
				break;
			case 22u:
				if (key.WireType == Wire.Varint)
				{
					instance.mounted = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				}
				break;
			case 23u:
				if (key.WireType == Wire.Varint)
				{
					instance.currentTeam = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 24u:
				if (key.WireType == Wire.Varint)
				{
					instance.underwear = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 25u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.modifiers == null)
					{
						instance.modifiers = PlayerModifiers.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerModifiers.DeserializeLengthDelimited(stream, instance.modifiers, isDelta);
					}
				}
				break;
			case 26u:
				if (key.WireType == Wire.Varint)
				{
					instance.reputation = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 27u:
				if (key.WireType == Wire.Varint)
				{
					instance.loopingGesture = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 28u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.missions == null)
					{
						instance.missions = Missions.DeserializeLengthDelimited(stream);
					}
					else
					{
						Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
					}
				}
				break;
			case 29u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.respawnId = ProtocolParser.ReadString(stream);
				}
				break;
			case 30u:
				if (key.WireType == Wire.Varint)
				{
					instance.bagCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 31u:
				if (key.WireType == Wire.Varint)
				{
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 32u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.itemCrafter == null)
					{
						instance.itemCrafter = ItemCrafter.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemCrafter.DeserializeLengthDelimited(stream, instance.itemCrafter, isDelta);
					}
				}
				break;
			case 33u:
				if (key.WireType == Wire.Varint)
				{
					instance.shelterCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 34u:
				if (key.WireType == Wire.Varint)
				{
					instance.tutorialAllowance = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BasePlayer instance, BasePlayer previous)
	{
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.userid != previous.userid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.inventory != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerInventory.SerializeDelta(stream, instance.inventory, previous.inventory);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.metabolism != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PlayerMetabolism.SerializeDelta(stream, instance.metabolism, previous.metabolism);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field metabolism (ProtoBuf.PlayerMetabolism)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.loadingTimeout != previous.loadingTimeout)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.loadingTimeout);
		}
		if (instance.modelState != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(2);
			int position3 = stream.Position;
			ModelState.SerializeDelta(stream, instance.modelState, previous.modelState);
			int num3 = stream.Position - position3;
			if (num3 > 16383)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modelState (global::ModelState)");
			}
			Span<byte> span3 = range3.GetSpan();
			if (ProtocolParser.WriteUInt32((uint)num3, span3, 0) < 2)
			{
				span3[0] |= 128;
				span3[1] = 0;
			}
		}
		if (instance.playerFlags != previous.playerFlags)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerFlags);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.heldEntity.Value);
		if (instance.health != previous.health)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.persistantData != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range4 = stream.GetRange(3);
			int position4 = stream.Position;
			PersistantPlayer.SerializeDelta(stream, instance.persistantData, previous.persistantData);
			int num4 = stream.Position - position4;
			if (num4 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field persistantData (ProtoBuf.PersistantPlayer)");
			}
			Span<byte> span4 = range4.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			if (num5 < 3)
			{
				span4[num5 - 1] |= 128;
				while (num5 < 2)
				{
					span4[num5++] = 128;
				}
				span4[2] = 0;
			}
		}
		if (instance.skinCol != previous.skinCol)
		{
			stream.WriteByte(125);
			ProtocolParser.WriteSingle(stream, instance.skinCol);
		}
		if (instance.skinTex != previous.skinTex)
		{
			stream.WriteByte(133);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.skinTex);
		}
		if (instance.skinMesh != previous.skinMesh)
		{
			stream.WriteByte(141);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.skinMesh);
		}
		if (instance.currentLife != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			PlayerLifeStory.SerializeDelta(stream, instance.currentLife, previous.currentLife);
			int val2 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val2, span5, 0);
			if (num6 < 5)
			{
				span5[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span5[num6++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.previousLife != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			PlayerLifeStory.SerializeDelta(stream, instance.previousLife, previous.previousLife);
			int val3 = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num7 = ProtocolParser.WriteUInt32((uint)val3, span6, 0);
			if (num7 < 5)
			{
				span6[num7 - 1] |= 128;
				while (num7 < 4)
				{
					span6[num7++] = 128;
				}
				span6[4] = 0;
			}
		}
		stream.WriteByte(176);
		stream.WriteByte(1);
		ProtocolParser.WriteUInt64(stream, instance.mounted.Value);
		if (instance.currentTeam != previous.currentTeam)
		{
			stream.WriteByte(184);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.currentTeam);
		}
		if (instance.underwear != previous.underwear)
		{
			stream.WriteByte(192);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.underwear);
		}
		if (instance.modifiers != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(1);
			BufferStream.RangeHandle range7 = stream.GetRange(3);
			int position7 = stream.Position;
			PlayerModifiers.SerializeDelta(stream, instance.modifiers, previous.modifiers);
			int num8 = stream.Position - position7;
			if (num8 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.PlayerModifiers)");
			}
			Span<byte> span7 = range7.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)num8, span7, 0);
			if (num9 < 3)
			{
				span7[num9 - 1] |= 128;
				while (num9 < 2)
				{
					span7[num9++] = 128;
				}
				span7[2] = 0;
			}
		}
		if (instance.reputation != previous.reputation)
		{
			stream.WriteByte(208);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.reputation);
		}
		if (instance.loopingGesture != previous.loopingGesture)
		{
			stream.WriteByte(216);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.loopingGesture);
		}
		if (instance.missions != null)
		{
			stream.WriteByte(226);
			stream.WriteByte(1);
			BufferStream.RangeHandle range8 = stream.GetRange(5);
			int position8 = stream.Position;
			Missions.SerializeDelta(stream, instance.missions, previous.missions);
			int val4 = stream.Position - position8;
			Span<byte> span8 = range8.GetSpan();
			int num10 = ProtocolParser.WriteUInt32((uint)val4, span8, 0);
			if (num10 < 5)
			{
				span8[num10 - 1] |= 128;
				while (num10 < 4)
				{
					span8[num10++] = 128;
				}
				span8[4] = 0;
			}
		}
		if (instance.respawnId != null && instance.respawnId != previous.respawnId)
		{
			stream.WriteByte(234);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.respawnId);
		}
		if (instance.bagCount != previous.bagCount)
		{
			stream.WriteByte(240);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bagCount);
		}
		stream.WriteByte(248);
		stream.WriteByte(1);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.itemCrafter != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(2);
			BufferStream.RangeHandle range9 = stream.GetRange(5);
			int position9 = stream.Position;
			ItemCrafter.SerializeDelta(stream, instance.itemCrafter, previous.itemCrafter);
			int val5 = stream.Position - position9;
			Span<byte> span9 = range9.GetSpan();
			int num11 = ProtocolParser.WriteUInt32((uint)val5, span9, 0);
			if (num11 < 5)
			{
				span9[num11 - 1] |= 128;
				while (num11 < 4)
				{
					span9[num11++] = 128;
				}
				span9[4] = 0;
			}
		}
		if (instance.shelterCount != previous.shelterCount)
		{
			stream.WriteByte(136);
			stream.WriteByte(2);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.shelterCount);
		}
		if (instance.tutorialAllowance != previous.tutorialAllowance)
		{
			stream.WriteByte(144);
			stream.WriteByte(2);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.tutorialAllowance);
		}
	}

	public static void Serialize(BufferStream stream, BasePlayer instance)
	{
		if (instance.name != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.userid != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.inventory != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerInventory.Serialize(stream, instance.inventory);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.metabolism != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PlayerMetabolism.Serialize(stream, instance.metabolism);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field metabolism (ProtoBuf.PlayerMetabolism)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.loadingTimeout != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.loadingTimeout);
		}
		if (instance.modelState != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(2);
			int position3 = stream.Position;
			ModelState.Serialize(stream, instance.modelState);
			int num3 = stream.Position - position3;
			if (num3 > 16383)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modelState (global::ModelState)");
			}
			Span<byte> span3 = range3.GetSpan();
			if (ProtocolParser.WriteUInt32((uint)num3, span3, 0) < 2)
			{
				span3[0] |= 128;
				span3[1] = 0;
			}
		}
		if (instance.playerFlags != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerFlags);
		}
		if (instance.heldEntity != default(ItemId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.heldEntity.Value);
		}
		if (instance.health != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.persistantData != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range4 = stream.GetRange(3);
			int position4 = stream.Position;
			PersistantPlayer.Serialize(stream, instance.persistantData);
			int num4 = stream.Position - position4;
			if (num4 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field persistantData (ProtoBuf.PersistantPlayer)");
			}
			Span<byte> span4 = range4.GetSpan();
			int num5 = ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			if (num5 < 3)
			{
				span4[num5 - 1] |= 128;
				while (num5 < 2)
				{
					span4[num5++] = 128;
				}
				span4[2] = 0;
			}
		}
		if (instance.skinCol != 0f)
		{
			stream.WriteByte(125);
			ProtocolParser.WriteSingle(stream, instance.skinCol);
		}
		if (instance.skinTex != 0f)
		{
			stream.WriteByte(133);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.skinTex);
		}
		if (instance.skinMesh != 0f)
		{
			stream.WriteByte(141);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.skinMesh);
		}
		if (instance.currentLife != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(1);
			BufferStream.RangeHandle range5 = stream.GetRange(5);
			int position5 = stream.Position;
			PlayerLifeStory.Serialize(stream, instance.currentLife);
			int val2 = stream.Position - position5;
			Span<byte> span5 = range5.GetSpan();
			int num6 = ProtocolParser.WriteUInt32((uint)val2, span5, 0);
			if (num6 < 5)
			{
				span5[num6 - 1] |= 128;
				while (num6 < 4)
				{
					span5[num6++] = 128;
				}
				span5[4] = 0;
			}
		}
		if (instance.previousLife != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(1);
			BufferStream.RangeHandle range6 = stream.GetRange(5);
			int position6 = stream.Position;
			PlayerLifeStory.Serialize(stream, instance.previousLife);
			int val3 = stream.Position - position6;
			Span<byte> span6 = range6.GetSpan();
			int num7 = ProtocolParser.WriteUInt32((uint)val3, span6, 0);
			if (num7 < 5)
			{
				span6[num7 - 1] |= 128;
				while (num7 < 4)
				{
					span6[num7++] = 128;
				}
				span6[4] = 0;
			}
		}
		if (instance.mounted != default(NetworkableId))
		{
			stream.WriteByte(176);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.mounted.Value);
		}
		if (instance.currentTeam != 0L)
		{
			stream.WriteByte(184);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.currentTeam);
		}
		if (instance.underwear != 0)
		{
			stream.WriteByte(192);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.underwear);
		}
		if (instance.modifiers != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(1);
			BufferStream.RangeHandle range7 = stream.GetRange(3);
			int position7 = stream.Position;
			PlayerModifiers.Serialize(stream, instance.modifiers);
			int num8 = stream.Position - position7;
			if (num8 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.PlayerModifiers)");
			}
			Span<byte> span7 = range7.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)num8, span7, 0);
			if (num9 < 3)
			{
				span7[num9 - 1] |= 128;
				while (num9 < 2)
				{
					span7[num9++] = 128;
				}
				span7[2] = 0;
			}
		}
		if (instance.reputation != 0)
		{
			stream.WriteByte(208);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.reputation);
		}
		if (instance.loopingGesture != 0)
		{
			stream.WriteByte(216);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.loopingGesture);
		}
		if (instance.missions != null)
		{
			stream.WriteByte(226);
			stream.WriteByte(1);
			BufferStream.RangeHandle range8 = stream.GetRange(5);
			int position8 = stream.Position;
			Missions.Serialize(stream, instance.missions);
			int val4 = stream.Position - position8;
			Span<byte> span8 = range8.GetSpan();
			int num10 = ProtocolParser.WriteUInt32((uint)val4, span8, 0);
			if (num10 < 5)
			{
				span8[num10 - 1] |= 128;
				while (num10 < 4)
				{
					span8[num10++] = 128;
				}
				span8[4] = 0;
			}
		}
		if (instance.respawnId != null)
		{
			stream.WriteByte(234);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.respawnId);
		}
		if (instance.bagCount != 0)
		{
			stream.WriteByte(240);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bagCount);
		}
		if (instance.clanId != 0L)
		{
			stream.WriteByte(248);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.itemCrafter != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(2);
			BufferStream.RangeHandle range9 = stream.GetRange(5);
			int position9 = stream.Position;
			ItemCrafter.Serialize(stream, instance.itemCrafter);
			int val5 = stream.Position - position9;
			Span<byte> span9 = range9.GetSpan();
			int num11 = ProtocolParser.WriteUInt32((uint)val5, span9, 0);
			if (num11 < 5)
			{
				span9[num11 - 1] |= 128;
				while (num11 < 4)
				{
					span9[num11++] = 128;
				}
				span9[4] = 0;
			}
		}
		if (instance.shelterCount != 0)
		{
			stream.WriteByte(136);
			stream.WriteByte(2);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.shelterCount);
		}
		if (instance.tutorialAllowance != 0)
		{
			stream.WriteByte(144);
			stream.WriteByte(2);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.tutorialAllowance);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		inventory?.InspectUids(action);
		metabolism?.InspectUids(action);
		modelState?.InspectUids(action);
		action(UidType.ItemId, ref heldEntity.Value);
		persistantData?.InspectUids(action);
		currentLife?.InspectUids(action);
		previousLife?.InspectUids(action);
		action(UidType.NetworkableId, ref mounted.Value);
		modifiers?.InspectUids(action);
		missions?.InspectUids(action);
		itemCrafter?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseProjectile : IDisposable, IPooled, IProto<BaseProjectile>, IProto
{
	[NonSerialized]
	public Magazine primaryMagazine;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseProjectile instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.primaryMagazine != null)
			{
				instance.primaryMagazine.ResetToPool();
				instance.primaryMagazine = null;
			}
			Pool.Free<BaseProjectile>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseProjectile with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseProjectile instance)
	{
		if (primaryMagazine != null)
		{
			if (instance.primaryMagazine == null)
			{
				instance.primaryMagazine = primaryMagazine.Copy();
			}
			else
			{
				primaryMagazine.CopyTo(instance.primaryMagazine);
			}
		}
		else
		{
			instance.primaryMagazine = null;
		}
	}

	public BaseProjectile Copy()
	{
		BaseProjectile baseProjectile = Pool.Get<BaseProjectile>();
		CopyTo(baseProjectile);
		return baseProjectile;
	}

	public static BaseProjectile Deserialize(BufferStream stream)
	{
		BaseProjectile baseProjectile = Pool.Get<BaseProjectile>();
		Deserialize(stream, baseProjectile, isDelta: false);
		return baseProjectile;
	}

	public static BaseProjectile DeserializeLengthDelimited(BufferStream stream)
	{
		BaseProjectile baseProjectile = Pool.Get<BaseProjectile>();
		DeserializeLengthDelimited(stream, baseProjectile, isDelta: false);
		return baseProjectile;
	}

	public static BaseProjectile DeserializeLength(BufferStream stream, int length)
	{
		BaseProjectile baseProjectile = Pool.Get<BaseProjectile>();
		DeserializeLength(stream, length, baseProjectile, isDelta: false);
		return baseProjectile;
	}

	public static BaseProjectile Deserialize(byte[] buffer)
	{
		BaseProjectile baseProjectile = Pool.Get<BaseProjectile>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseProjectile, isDelta: false);
		return baseProjectile;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseProjectile previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseProjectile Deserialize(BufferStream stream, BaseProjectile instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.primaryMagazine == null)
				{
					instance.primaryMagazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.primaryMagazine, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static BaseProjectile DeserializeLengthDelimited(BufferStream stream, BaseProjectile instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.primaryMagazine == null)
				{
					instance.primaryMagazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.primaryMagazine, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseProjectile DeserializeLength(BufferStream stream, int length, BaseProjectile instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.primaryMagazine == null)
				{
					instance.primaryMagazine = Magazine.DeserializeLengthDelimited(stream);
				}
				else
				{
					Magazine.DeserializeLengthDelimited(stream, instance.primaryMagazine, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseProjectile instance, BaseProjectile previous)
	{
		if (instance.primaryMagazine != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Magazine.SerializeDelta(stream, instance.primaryMagazine, previous.primaryMagazine);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field primaryMagazine (ProtoBuf.Magazine)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, BaseProjectile instance)
	{
		if (instance.primaryMagazine != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Magazine.Serialize(stream, instance.primaryMagazine);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field primaryMagazine (ProtoBuf.Magazine)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		primaryMagazine?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseResource : IDisposable, IPooled, IProto<BaseResource>, IProto
{
	[NonSerialized]
	public int stage;

	[NonSerialized]
	public float health;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseResource instance)
	{
		if (instance.ShouldPool)
		{
			instance.stage = 0;
			instance.health = 0f;
			Pool.Free<BaseResource>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseResource with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseResource instance)
	{
		instance.stage = stage;
		instance.health = health;
	}

	public BaseResource Copy()
	{
		BaseResource baseResource = Pool.Get<BaseResource>();
		CopyTo(baseResource);
		return baseResource;
	}

	public static BaseResource Deserialize(BufferStream stream)
	{
		BaseResource baseResource = Pool.Get<BaseResource>();
		Deserialize(stream, baseResource, isDelta: false);
		return baseResource;
	}

	public static BaseResource DeserializeLengthDelimited(BufferStream stream)
	{
		BaseResource baseResource = Pool.Get<BaseResource>();
		DeserializeLengthDelimited(stream, baseResource, isDelta: false);
		return baseResource;
	}

	public static BaseResource DeserializeLength(BufferStream stream, int length)
	{
		BaseResource baseResource = Pool.Get<BaseResource>();
		DeserializeLength(stream, length, baseResource, isDelta: false);
		return baseResource;
	}

	public static BaseResource Deserialize(byte[] buffer)
	{
		BaseResource baseResource = Pool.Get<BaseResource>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseResource, isDelta: false);
		return baseResource;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseResource previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseResource Deserialize(BufferStream stream, BaseResource instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.stage = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseResource DeserializeLengthDelimited(BufferStream stream, BaseResource instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.stage = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseResource DeserializeLength(BufferStream stream, int length, BaseResource instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.stage = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseResource instance, BaseResource previous)
	{
		if (instance.stage != previous.stage)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.stage);
		}
		if (instance.health != previous.health)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
	}

	public static void Serialize(BufferStream stream, BaseResource instance)
	{
		if (instance.stage != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.stage);
		}
		if (instance.health != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseSculpture : IDisposable, IPooled, IProto<BaseSculpture>, IProto
{
	[NonSerialized]
	public uint crc;

	[NonSerialized]
	public int colourSelection;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseSculpture instance)
	{
		if (instance.ShouldPool)
		{
			instance.crc = 0u;
			instance.colourSelection = 0;
			Pool.Free<BaseSculpture>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseSculpture with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseSculpture instance)
	{
		instance.crc = crc;
		instance.colourSelection = colourSelection;
	}

	public BaseSculpture Copy()
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		CopyTo(baseSculpture);
		return baseSculpture;
	}

	public static BaseSculpture Deserialize(BufferStream stream)
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		Deserialize(stream, baseSculpture, isDelta: false);
		return baseSculpture;
	}

	public static BaseSculpture DeserializeLengthDelimited(BufferStream stream)
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		DeserializeLengthDelimited(stream, baseSculpture, isDelta: false);
		return baseSculpture;
	}

	public static BaseSculpture DeserializeLength(BufferStream stream, int length)
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		DeserializeLength(stream, length, baseSculpture, isDelta: false);
		return baseSculpture;
	}

	public static BaseSculpture Deserialize(byte[] buffer)
	{
		BaseSculpture baseSculpture = Pool.Get<BaseSculpture>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseSculpture, isDelta: false);
		return baseSculpture;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseSculpture previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseSculpture Deserialize(BufferStream stream, BaseSculpture instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.colourSelection = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseSculpture DeserializeLengthDelimited(BufferStream stream, BaseSculpture instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.colourSelection = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseSculpture DeserializeLength(BufferStream stream, int length, BaseSculpture instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.colourSelection = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseSculpture instance, BaseSculpture previous)
	{
		if (instance.crc != previous.crc)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
		if (instance.colourSelection != previous.colourSelection)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourSelection);
		}
	}

	public static void Serialize(BufferStream stream, BaseSculpture instance)
	{
		if (instance.crc != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
		if (instance.colourSelection != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourSelection);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseTrain : IDisposable, IPooled, IProto<BaseTrain>, IProto
{
	[NonSerialized]
	public float time;

	[NonSerialized]
	public float frontBogieYRot;

	[NonSerialized]
	public float rearBogieYRot;

	[NonSerialized]
	public NetworkableId frontCouplingID;

	[NonSerialized]
	public bool frontCouplingToFront;

	[NonSerialized]
	public NetworkableId rearCouplingID;

	[NonSerialized]
	public bool rearCouplingToFront;

	[NonSerialized]
	public int lootTypeIndex;

	[NonSerialized]
	public float lootPercent;

	[NonSerialized]
	public NetworkableId itemStorageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseTrain instance)
	{
		if (instance.ShouldPool)
		{
			instance.time = 0f;
			instance.frontBogieYRot = 0f;
			instance.rearBogieYRot = 0f;
			instance.frontCouplingID = default(NetworkableId);
			instance.frontCouplingToFront = false;
			instance.rearCouplingID = default(NetworkableId);
			instance.rearCouplingToFront = false;
			instance.lootTypeIndex = 0;
			instance.lootPercent = 0f;
			instance.itemStorageID = default(NetworkableId);
			Pool.Free<BaseTrain>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseTrain with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseTrain instance)
	{
		instance.time = time;
		instance.frontBogieYRot = frontBogieYRot;
		instance.rearBogieYRot = rearBogieYRot;
		instance.frontCouplingID = frontCouplingID;
		instance.frontCouplingToFront = frontCouplingToFront;
		instance.rearCouplingID = rearCouplingID;
		instance.rearCouplingToFront = rearCouplingToFront;
		instance.lootTypeIndex = lootTypeIndex;
		instance.lootPercent = lootPercent;
		instance.itemStorageID = itemStorageID;
	}

	public BaseTrain Copy()
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		CopyTo(baseTrain);
		return baseTrain;
	}

	public static BaseTrain Deserialize(BufferStream stream)
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		Deserialize(stream, baseTrain, isDelta: false);
		return baseTrain;
	}

	public static BaseTrain DeserializeLengthDelimited(BufferStream stream)
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		DeserializeLengthDelimited(stream, baseTrain, isDelta: false);
		return baseTrain;
	}

	public static BaseTrain DeserializeLength(BufferStream stream, int length)
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		DeserializeLength(stream, length, baseTrain, isDelta: false);
		return baseTrain;
	}

	public static BaseTrain Deserialize(byte[] buffer)
	{
		BaseTrain baseTrain = Pool.Get<BaseTrain>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseTrain, isDelta: false);
		return baseTrain;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseTrain previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseTrain Deserialize(BufferStream stream, BaseTrain instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.frontBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rearBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.frontCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.frontCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.rearCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 56:
				instance.rearCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lootPercent = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseTrain DeserializeLengthDelimited(BufferStream stream, BaseTrain instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.frontBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rearBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.frontCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.frontCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.rearCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 56:
				instance.rearCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lootPercent = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseTrain DeserializeLength(BufferStream stream, int length, BaseTrain instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.frontBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rearBogieYRot = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.frontCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.frontCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.rearCouplingID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 56:
				instance.rearCouplingToFront = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lootPercent = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseTrain instance, BaseTrain previous)
	{
		if (instance.time != previous.time)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.frontBogieYRot != previous.frontBogieYRot)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.frontBogieYRot);
		}
		if (instance.rearBogieYRot != previous.rearBogieYRot)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.rearBogieYRot);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.frontCouplingID.Value);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.frontCouplingToFront);
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, instance.rearCouplingID.Value);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.rearCouplingToFront);
		if (instance.lootTypeIndex != previous.lootTypeIndex)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lootTypeIndex);
		}
		if (instance.lootPercent != previous.lootPercent)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lootPercent);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteUInt64(stream, instance.itemStorageID.Value);
	}

	public static void Serialize(BufferStream stream, BaseTrain instance)
	{
		if (instance.time != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.frontBogieYRot != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.frontBogieYRot);
		}
		if (instance.rearBogieYRot != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.rearBogieYRot);
		}
		if (instance.frontCouplingID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.frontCouplingID.Value);
		}
		if (instance.frontCouplingToFront)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.frontCouplingToFront);
		}
		if (instance.rearCouplingID != default(NetworkableId))
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.rearCouplingID.Value);
		}
		if (instance.rearCouplingToFront)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.rearCouplingToFront);
		}
		if (instance.lootTypeIndex != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lootTypeIndex);
		}
		if (instance.lootPercent != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lootPercent);
		}
		if (instance.itemStorageID != default(NetworkableId))
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, instance.itemStorageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref frontCouplingID.Value);
		action(UidType.NetworkableId, ref rearCouplingID.Value);
		action(UidType.NetworkableId, ref itemStorageID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BaseVehicle : IDisposable, IPooled, IProto<BaseVehicle>, IProto
{
	public class MountPoint : IDisposable, IPooled, IProto<MountPoint>, IProto
	{
		[NonSerialized]
		public int index;

		[NonSerialized]
		public NetworkableId mountableId;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(MountPoint instance)
		{
			if (instance.ShouldPool)
			{
				instance.index = 0;
				instance.mountableId = default(NetworkableId);
				Pool.Free<MountPoint>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose MountPoint with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(MountPoint instance)
		{
			instance.index = index;
			instance.mountableId = mountableId;
		}

		public MountPoint Copy()
		{
			MountPoint mountPoint = Pool.Get<MountPoint>();
			CopyTo(mountPoint);
			return mountPoint;
		}

		public static MountPoint Deserialize(BufferStream stream)
		{
			MountPoint mountPoint = Pool.Get<MountPoint>();
			Deserialize(stream, mountPoint, isDelta: false);
			return mountPoint;
		}

		public static MountPoint DeserializeLengthDelimited(BufferStream stream)
		{
			MountPoint mountPoint = Pool.Get<MountPoint>();
			DeserializeLengthDelimited(stream, mountPoint, isDelta: false);
			return mountPoint;
		}

		public static MountPoint DeserializeLength(BufferStream stream, int length)
		{
			MountPoint mountPoint = Pool.Get<MountPoint>();
			DeserializeLength(stream, length, mountPoint, isDelta: false);
			return mountPoint;
		}

		public static MountPoint Deserialize(byte[] buffer)
		{
			MountPoint mountPoint = Pool.Get<MountPoint>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, mountPoint, isDelta: false);
			return mountPoint;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, MountPoint previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static MountPoint Deserialize(BufferStream stream, MountPoint instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.index = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.mountableId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static MountPoint DeserializeLengthDelimited(BufferStream stream, MountPoint instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.index = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.mountableId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static MountPoint DeserializeLength(BufferStream stream, int length, MountPoint instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.index = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.mountableId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, MountPoint instance, MountPoint previous)
		{
			if (instance.index != previous.index)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
			}
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.mountableId.Value);
		}

		public static void Serialize(BufferStream stream, MountPoint instance)
		{
			if (instance.index != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
			}
			if (instance.mountableId != default(NetworkableId))
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.mountableId.Value);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref mountableId.Value);
		}
	}

	[NonSerialized]
	public List<MountPoint> mountPoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BaseVehicle instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.mountPoints != null)
		{
			for (int i = 0; i < instance.mountPoints.Count; i++)
			{
				if (instance.mountPoints[i] != null)
				{
					instance.mountPoints[i].ResetToPool();
					instance.mountPoints[i] = null;
				}
			}
			List<MountPoint> list = instance.mountPoints;
			Pool.Free<MountPoint>(ref list, false);
			instance.mountPoints = list;
		}
		Pool.Free<BaseVehicle>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BaseVehicle with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BaseVehicle instance)
	{
		if (mountPoints != null)
		{
			instance.mountPoints = Pool.Get<List<MountPoint>>();
			for (int i = 0; i < mountPoints.Count; i++)
			{
				MountPoint item = mountPoints[i].Copy();
				instance.mountPoints.Add(item);
			}
		}
		else
		{
			instance.mountPoints = null;
		}
	}

	public BaseVehicle Copy()
	{
		BaseVehicle baseVehicle = Pool.Get<BaseVehicle>();
		CopyTo(baseVehicle);
		return baseVehicle;
	}

	public static BaseVehicle Deserialize(BufferStream stream)
	{
		BaseVehicle baseVehicle = Pool.Get<BaseVehicle>();
		Deserialize(stream, baseVehicle, isDelta: false);
		return baseVehicle;
	}

	public static BaseVehicle DeserializeLengthDelimited(BufferStream stream)
	{
		BaseVehicle baseVehicle = Pool.Get<BaseVehicle>();
		DeserializeLengthDelimited(stream, baseVehicle, isDelta: false);
		return baseVehicle;
	}

	public static BaseVehicle DeserializeLength(BufferStream stream, int length)
	{
		BaseVehicle baseVehicle = Pool.Get<BaseVehicle>();
		DeserializeLength(stream, length, baseVehicle, isDelta: false);
		return baseVehicle;
	}

	public static BaseVehicle Deserialize(byte[] buffer)
	{
		BaseVehicle baseVehicle = Pool.Get<BaseVehicle>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, baseVehicle, isDelta: false);
		return baseVehicle;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BaseVehicle previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BaseVehicle Deserialize(BufferStream stream, BaseVehicle instance, bool isDelta)
	{
		if (!isDelta && instance.mountPoints == null)
		{
			instance.mountPoints = Pool.Get<List<MountPoint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.mountPoints.Add(MountPoint.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BaseVehicle DeserializeLengthDelimited(BufferStream stream, BaseVehicle instance, bool isDelta)
	{
		if (!isDelta && instance.mountPoints == null)
		{
			instance.mountPoints = Pool.Get<List<MountPoint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.mountPoints.Add(MountPoint.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BaseVehicle DeserializeLength(BufferStream stream, int length, BaseVehicle instance, bool isDelta)
	{
		if (!isDelta && instance.mountPoints == null)
		{
			instance.mountPoints = Pool.Get<List<MountPoint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.mountPoints.Add(MountPoint.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BaseVehicle instance, BaseVehicle previous)
	{
		if (instance.mountPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.mountPoints.Count; i++)
		{
			MountPoint mountPoint = instance.mountPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			MountPoint.SerializeDelta(stream, mountPoint, mountPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mountPoints (ProtoBuf.BaseVehicle.MountPoint)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, BaseVehicle instance)
	{
		if (instance.mountPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.mountPoints.Count; i++)
		{
			MountPoint instance2 = instance.mountPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			MountPoint.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mountPoints (ProtoBuf.BaseVehicle.MountPoint)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (mountPoints != null)
		{
			for (int i = 0; i < mountPoints.Count; i++)
			{
				mountPoints[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BatteringRam : IDisposable, IPooled, IProto<BatteringRam>, IProto
{
	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public NetworkableId headID;

	[NonSerialized]
	public float steerInput;

	[NonSerialized]
	public float driveWheelVel;

	[NonSerialized]
	public float throttleInput;

	[NonSerialized]
	public float brakeInput;

	[NonSerialized]
	public float fuelFraction;

	[NonSerialized]
	public float doorAngle;

	[NonSerialized]
	public float time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BatteringRam instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelStorageID = default(NetworkableId);
			instance.headID = default(NetworkableId);
			instance.steerInput = 0f;
			instance.driveWheelVel = 0f;
			instance.throttleInput = 0f;
			instance.brakeInput = 0f;
			instance.fuelFraction = 0f;
			instance.doorAngle = 0f;
			instance.time = 0f;
			Pool.Free<BatteringRam>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BatteringRam with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BatteringRam instance)
	{
		instance.fuelStorageID = fuelStorageID;
		instance.headID = headID;
		instance.steerInput = steerInput;
		instance.driveWheelVel = driveWheelVel;
		instance.throttleInput = throttleInput;
		instance.brakeInput = brakeInput;
		instance.fuelFraction = fuelFraction;
		instance.doorAngle = doorAngle;
		instance.time = time;
	}

	public BatteringRam Copy()
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		CopyTo(batteringRam);
		return batteringRam;
	}

	public static BatteringRam Deserialize(BufferStream stream)
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		Deserialize(stream, batteringRam, isDelta: false);
		return batteringRam;
	}

	public static BatteringRam DeserializeLengthDelimited(BufferStream stream)
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		DeserializeLengthDelimited(stream, batteringRam, isDelta: false);
		return batteringRam;
	}

	public static BatteringRam DeserializeLength(BufferStream stream, int length)
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		DeserializeLength(stream, length, batteringRam, isDelta: false);
		return batteringRam;
	}

	public static BatteringRam Deserialize(byte[] buffer)
	{
		BatteringRam batteringRam = Pool.Get<BatteringRam>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, batteringRam, isDelta: false);
		return batteringRam;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BatteringRam previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BatteringRam Deserialize(BufferStream stream, BatteringRam instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.headID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 29:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.doorAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BatteringRam DeserializeLengthDelimited(BufferStream stream, BatteringRam instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.headID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 29:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.doorAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BatteringRam DeserializeLength(BufferStream stream, int length, BatteringRam instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.headID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 29:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.doorAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BatteringRam instance, BatteringRam previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.headID.Value);
		if (instance.steerInput != previous.steerInput)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != previous.driveWheelVel)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != previous.throttleInput)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != previous.brakeInput)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.doorAngle != previous.doorAngle)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.doorAngle);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public static void Serialize(BufferStream stream, BatteringRam instance)
	{
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.headID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.headID.Value);
		}
		if (instance.steerInput != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.doorAngle != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.doorAngle);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
		action(UidType.NetworkableId, ref headID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Beehive : IDisposable, IPooled, IProto<Beehive>, IProto
{
	[NonSerialized]
	public float currentProgress;

	[NonSerialized]
	public float temperature;

	[NonSerialized]
	public bool inside;

	[NonSerialized]
	public float humidity;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Beehive instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentProgress = 0f;
			instance.temperature = 0f;
			instance.inside = false;
			instance.humidity = 0f;
			Pool.Free<Beehive>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Beehive with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Beehive instance)
	{
		instance.currentProgress = currentProgress;
		instance.temperature = temperature;
		instance.inside = inside;
		instance.humidity = humidity;
	}

	public Beehive Copy()
	{
		Beehive beehive = Pool.Get<Beehive>();
		CopyTo(beehive);
		return beehive;
	}

	public static Beehive Deserialize(BufferStream stream)
	{
		Beehive beehive = Pool.Get<Beehive>();
		Deserialize(stream, beehive, isDelta: false);
		return beehive;
	}

	public static Beehive DeserializeLengthDelimited(BufferStream stream)
	{
		Beehive beehive = Pool.Get<Beehive>();
		DeserializeLengthDelimited(stream, beehive, isDelta: false);
		return beehive;
	}

	public static Beehive DeserializeLength(BufferStream stream, int length)
	{
		Beehive beehive = Pool.Get<Beehive>();
		DeserializeLength(stream, length, beehive, isDelta: false);
		return beehive;
	}

	public static Beehive Deserialize(byte[] buffer)
	{
		Beehive beehive = Pool.Get<Beehive>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, beehive, isDelta: false);
		return beehive;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Beehive previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Beehive Deserialize(BufferStream stream, Beehive instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.currentProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.inside = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.humidity = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Beehive DeserializeLengthDelimited(BufferStream stream, Beehive instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.currentProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.inside = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.humidity = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Beehive DeserializeLength(BufferStream stream, int length, Beehive instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.currentProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.inside = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.humidity = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Beehive instance, Beehive previous)
	{
		if (instance.currentProgress != previous.currentProgress)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.currentProgress);
		}
		if (instance.temperature != previous.temperature)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.inside);
		if (instance.humidity != previous.humidity)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.humidity);
		}
	}

	public static void Serialize(BufferStream stream, Beehive instance)
	{
		if (instance.currentProgress != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.currentProgress);
		}
		if (instance.temperature != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.inside)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.inside);
		}
		if (instance.humidity != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.humidity);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BeeMasterSwarm : IDisposable, IPooled, IProto<BeeMasterSwarm>, IProto
{
	[NonSerialized]
	public float population;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BeeMasterSwarm instance)
	{
		if (instance.ShouldPool)
		{
			instance.population = 0f;
			Pool.Free<BeeMasterSwarm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BeeMasterSwarm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BeeMasterSwarm instance)
	{
		instance.population = population;
	}

	public BeeMasterSwarm Copy()
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		CopyTo(beeMasterSwarm);
		return beeMasterSwarm;
	}

	public static BeeMasterSwarm Deserialize(BufferStream stream)
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		Deserialize(stream, beeMasterSwarm, isDelta: false);
		return beeMasterSwarm;
	}

	public static BeeMasterSwarm DeserializeLengthDelimited(BufferStream stream)
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		DeserializeLengthDelimited(stream, beeMasterSwarm, isDelta: false);
		return beeMasterSwarm;
	}

	public static BeeMasterSwarm DeserializeLength(BufferStream stream, int length)
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		DeserializeLength(stream, length, beeMasterSwarm, isDelta: false);
		return beeMasterSwarm;
	}

	public static BeeMasterSwarm Deserialize(byte[] buffer)
	{
		BeeMasterSwarm beeMasterSwarm = Pool.Get<BeeMasterSwarm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, beeMasterSwarm, isDelta: false);
		return beeMasterSwarm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BeeMasterSwarm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BeeMasterSwarm Deserialize(BufferStream stream, BeeMasterSwarm instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.population = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BeeMasterSwarm DeserializeLengthDelimited(BufferStream stream, BeeMasterSwarm instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.population = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BeeMasterSwarm DeserializeLength(BufferStream stream, int length, BeeMasterSwarm instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.population = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BeeMasterSwarm instance, BeeMasterSwarm previous)
	{
		if (instance.population != previous.population)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.population);
		}
	}

	public static void Serialize(BufferStream stream, BeeMasterSwarm instance)
	{
		if (instance.population != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.population);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Bike : IDisposable, IPooled, IProto<Bike>, IProto
{
	[NonSerialized]
	public float steerInput;

	[NonSerialized]
	public float driveWheelVel;

	[NonSerialized]
	public float throttleInput;

	[NonSerialized]
	public float brakeInput;

	[NonSerialized]
	public NetworkableId storageID;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelFraction;

	[NonSerialized]
	public float sidecarAngle;

	[NonSerialized]
	public float time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Bike instance)
	{
		if (instance.ShouldPool)
		{
			instance.steerInput = 0f;
			instance.driveWheelVel = 0f;
			instance.throttleInput = 0f;
			instance.brakeInput = 0f;
			instance.storageID = default(NetworkableId);
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelFraction = 0f;
			instance.sidecarAngle = 0f;
			instance.time = 0f;
			Pool.Free<Bike>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Bike with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Bike instance)
	{
		instance.steerInput = steerInput;
		instance.driveWheelVel = driveWheelVel;
		instance.throttleInput = throttleInput;
		instance.brakeInput = brakeInput;
		instance.storageID = storageID;
		instance.fuelStorageID = fuelStorageID;
		instance.fuelFraction = fuelFraction;
		instance.sidecarAngle = sidecarAngle;
		instance.time = time;
	}

	public Bike Copy()
	{
		Bike bike = Pool.Get<Bike>();
		CopyTo(bike);
		return bike;
	}

	public static Bike Deserialize(BufferStream stream)
	{
		Bike bike = Pool.Get<Bike>();
		Deserialize(stream, bike, isDelta: false);
		return bike;
	}

	public static Bike DeserializeLengthDelimited(BufferStream stream)
	{
		Bike bike = Pool.Get<Bike>();
		DeserializeLengthDelimited(stream, bike, isDelta: false);
		return bike;
	}

	public static Bike DeserializeLength(BufferStream stream, int length)
	{
		Bike bike = Pool.Get<Bike>();
		DeserializeLength(stream, length, bike, isDelta: false);
		return bike;
	}

	public static Bike Deserialize(byte[] buffer)
	{
		Bike bike = Pool.Get<Bike>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, bike, isDelta: false);
		return bike;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Bike previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Bike Deserialize(BufferStream stream, Bike instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sidecarAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Bike DeserializeLengthDelimited(BufferStream stream, Bike instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sidecarAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Bike DeserializeLength(BufferStream stream, int length, Bike instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sidecarAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Bike instance, Bike previous)
	{
		if (instance.steerInput != previous.steerInput)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != previous.driveWheelVel)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != previous.throttleInput)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != previous.brakeInput)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.sidecarAngle != previous.sidecarAngle)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.sidecarAngle);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public static void Serialize(BufferStream stream, Bike instance)
	{
		if (instance.steerInput != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.storageID != default(NetworkableId))
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.sidecarAngle != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.sidecarAngle);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref storageID.Value);
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BoomBox : IDisposable, IPooled, IProto<BoomBox>, IProto
{
	[NonSerialized]
	public string radioIp;

	[NonSerialized]
	public ulong assignedRadioBy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BoomBox instance)
	{
		if (instance.ShouldPool)
		{
			instance.radioIp = string.Empty;
			instance.assignedRadioBy = 0uL;
			Pool.Free<BoomBox>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BoomBox with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BoomBox instance)
	{
		instance.radioIp = radioIp;
		instance.assignedRadioBy = assignedRadioBy;
	}

	public BoomBox Copy()
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		CopyTo(boomBox);
		return boomBox;
	}

	public static BoomBox Deserialize(BufferStream stream)
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		Deserialize(stream, boomBox, isDelta: false);
		return boomBox;
	}

	public static BoomBox DeserializeLengthDelimited(BufferStream stream)
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		DeserializeLengthDelimited(stream, boomBox, isDelta: false);
		return boomBox;
	}

	public static BoomBox DeserializeLength(BufferStream stream, int length)
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		DeserializeLength(stream, length, boomBox, isDelta: false);
		return boomBox;
	}

	public static BoomBox Deserialize(byte[] buffer)
	{
		BoomBox boomBox = Pool.Get<BoomBox>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, boomBox, isDelta: false);
		return boomBox;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BoomBox previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BoomBox Deserialize(BufferStream stream, BoomBox instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.radioIp = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.assignedRadioBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BoomBox DeserializeLengthDelimited(BufferStream stream, BoomBox instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.radioIp = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.assignedRadioBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BoomBox DeserializeLength(BufferStream stream, int length, BoomBox instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.radioIp = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.assignedRadioBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BoomBox instance, BoomBox previous)
	{
		if (instance.radioIp != null && instance.radioIp != previous.radioIp)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.radioIp);
		}
		if (instance.assignedRadioBy != previous.assignedRadioBy)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.assignedRadioBy);
		}
	}

	public static void Serialize(BufferStream stream, BoomBox instance)
	{
		if (instance.radioIp != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.radioIp);
		}
		if (instance.assignedRadioBy != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.assignedRadioBy);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class BradleyAPC : IDisposable, IPooled, IProto<BradleyAPC>, IProto
{
	[NonSerialized]
	public float engineThrottle;

	[NonSerialized]
	public float throttleLeft;

	[NonSerialized]
	public float throttleRight;

	[NonSerialized]
	public Vector3 mainGunVec;

	[NonSerialized]
	public Vector3 topTurretVec;

	[NonSerialized]
	public Vector3 rearGunVec;

	[NonSerialized]
	public Vector3 leftSideGun1;

	[NonSerialized]
	public Vector3 leftSideGun2;

	[NonSerialized]
	public Vector3 rightSideGun1;

	[NonSerialized]
	public Vector3 rightSideGun2;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BradleyAPC instance)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.engineThrottle = 0f;
			instance.throttleLeft = 0f;
			instance.throttleRight = 0f;
			instance.mainGunVec = default(Vector3);
			instance.topTurretVec = default(Vector3);
			instance.rearGunVec = default(Vector3);
			instance.leftSideGun1 = default(Vector3);
			instance.leftSideGun2 = default(Vector3);
			instance.rightSideGun1 = default(Vector3);
			instance.rightSideGun2 = default(Vector3);
			Pool.Free<BradleyAPC>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BradleyAPC with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BradleyAPC instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		instance.engineThrottle = engineThrottle;
		instance.throttleLeft = throttleLeft;
		instance.throttleRight = throttleRight;
		instance.mainGunVec = mainGunVec;
		instance.topTurretVec = topTurretVec;
		instance.rearGunVec = rearGunVec;
		instance.leftSideGun1 = leftSideGun1;
		instance.leftSideGun2 = leftSideGun2;
		instance.rightSideGun1 = rightSideGun1;
		instance.rightSideGun2 = rightSideGun2;
	}

	public BradleyAPC Copy()
	{
		BradleyAPC bradleyAPC = Pool.Get<BradleyAPC>();
		CopyTo(bradleyAPC);
		return bradleyAPC;
	}

	public static BradleyAPC Deserialize(BufferStream stream)
	{
		BradleyAPC bradleyAPC = Pool.Get<BradleyAPC>();
		Deserialize(stream, bradleyAPC, isDelta: false);
		return bradleyAPC;
	}

	public static BradleyAPC DeserializeLengthDelimited(BufferStream stream)
	{
		BradleyAPC bradleyAPC = Pool.Get<BradleyAPC>();
		DeserializeLengthDelimited(stream, bradleyAPC, isDelta: false);
		return bradleyAPC;
	}

	public static BradleyAPC DeserializeLength(BufferStream stream, int length)
	{
		BradleyAPC bradleyAPC = Pool.Get<BradleyAPC>();
		DeserializeLength(stream, length, bradleyAPC, isDelta: false);
		return bradleyAPC;
	}

	public static BradleyAPC Deserialize(byte[] buffer)
	{
		BradleyAPC bradleyAPC = Pool.Get<BradleyAPC>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, bradleyAPC, isDelta: false);
		return bradleyAPC;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BradleyAPC previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BradleyAPC Deserialize(BufferStream stream, BradleyAPC instance, bool isDelta)
	{
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.engineThrottle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.throttleLeft = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleRight = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mainGunVec, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.topTurretVec, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rearGunVec, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftSideGun1, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftSideGun2, isDelta);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightSideGun1, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightSideGun2, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BradleyAPC DeserializeLengthDelimited(BufferStream stream, BradleyAPC instance, bool isDelta)
	{
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.engineThrottle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.throttleLeft = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleRight = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mainGunVec, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.topTurretVec, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rearGunVec, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftSideGun1, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftSideGun2, isDelta);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightSideGun1, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightSideGun2, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BradleyAPC DeserializeLength(BufferStream stream, int length, BradleyAPC instance, bool isDelta)
	{
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.engineThrottle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.throttleLeft = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleRight = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mainGunVec, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.topTurretVec, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rearGunVec, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftSideGun1, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.leftSideGun2, isDelta);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightSideGun1, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rightSideGun2, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BradleyAPC instance, BradleyAPC previous)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.engineThrottle != previous.engineThrottle)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.engineThrottle);
		}
		if (instance.throttleLeft != previous.throttleLeft)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.throttleLeft);
		}
		if (instance.throttleRight != previous.throttleRight)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleRight);
		}
		if (instance.mainGunVec != previous.mainGunVec)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.mainGunVec, previous.mainGunVec);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mainGunVec (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.topTurretVec != previous.topTurretVec)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.topTurretVec, previous.topTurretVec);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topTurretVec (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rearGunVec != previous.rearGunVec)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rearGunVec, previous.rearGunVec);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rearGunVec (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.leftSideGun1 != previous.leftSideGun1)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.leftSideGun1, previous.leftSideGun1);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field leftSideGun1 (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.leftSideGun2 != previous.leftSideGun2)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.leftSideGun2, previous.leftSideGun2);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field leftSideGun2 (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.rightSideGun1 != previous.rightSideGun1)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rightSideGun1, previous.rightSideGun1);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rightSideGun1 (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.rightSideGun2 != previous.rightSideGun2)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rightSideGun2, previous.rightSideGun2);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rightSideGun2 (UnityEngine.Vector3)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
	}

	public static void Serialize(BufferStream stream, BradleyAPC instance)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		if (instance.engineThrottle != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.engineThrottle);
		}
		if (instance.throttleLeft != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.throttleLeft);
		}
		if (instance.throttleRight != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleRight);
		}
		if (instance.mainGunVec != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.mainGunVec);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mainGunVec (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.topTurretVec != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.topTurretVec);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topTurretVec (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rearGunVec != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rearGunVec);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rearGunVec (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.leftSideGun1 != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.leftSideGun1);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field leftSideGun1 (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.leftSideGun2 != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.leftSideGun2);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field leftSideGun2 (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.rightSideGun1 != default(Vector3))
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rightSideGun1);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rightSideGun1 (UnityEngine.Vector3)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.rightSideGun2 != default(Vector3))
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rightSideGun2);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rightSideGun2 (UnityEngine.Vector3)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BrainComponent : IDisposable, IPooled, IProto<BrainComponent>, IProto
{
	[NonSerialized]
	public int currentState;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BrainComponent instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentState = 0;
			Pool.Free<BrainComponent>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BrainComponent with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BrainComponent instance)
	{
		instance.currentState = currentState;
	}

	public BrainComponent Copy()
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		CopyTo(brainComponent);
		return brainComponent;
	}

	public static BrainComponent Deserialize(BufferStream stream)
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		Deserialize(stream, brainComponent, isDelta: false);
		return brainComponent;
	}

	public static BrainComponent DeserializeLengthDelimited(BufferStream stream)
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		DeserializeLengthDelimited(stream, brainComponent, isDelta: false);
		return brainComponent;
	}

	public static BrainComponent DeserializeLength(BufferStream stream, int length)
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		DeserializeLength(stream, length, brainComponent, isDelta: false);
		return brainComponent;
	}

	public static BrainComponent Deserialize(byte[] buffer)
	{
		BrainComponent brainComponent = Pool.Get<BrainComponent>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, brainComponent, isDelta: false);
		return brainComponent;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BrainComponent previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BrainComponent Deserialize(BufferStream stream, BrainComponent instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.currentState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BrainComponent DeserializeLengthDelimited(BufferStream stream, BrainComponent instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BrainComponent DeserializeLength(BufferStream stream, int length, BrainComponent instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BrainComponent instance, BrainComponent previous)
	{
		if (instance.currentState != previous.currentState)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentState);
		}
	}

	public static void Serialize(BufferStream stream, BrainComponent instance)
	{
		if (instance.currentState != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentState);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BuildingBlock : IDisposable, IPooled, IProto<BuildingBlock>, IProto
{
	[NonSerialized]
	public ulong model;

	[NonSerialized]
	public int grade;

	[NonSerialized]
	public bool beingDemolished;

	[NonSerialized]
	public ulong wallpaperID;

	[NonSerialized]
	public float wallpaperHealth;

	[NonSerialized]
	public ulong wallpaperID2;

	[NonSerialized]
	public float wallpaperHealth2;

	[NonSerialized]
	public float wallpaperRotation;

	[NonSerialized]
	public float wallpaperRotation2;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BuildingBlock instance)
	{
		if (instance.ShouldPool)
		{
			instance.model = 0uL;
			instance.grade = 0;
			instance.beingDemolished = false;
			instance.wallpaperID = 0uL;
			instance.wallpaperHealth = 0f;
			instance.wallpaperID2 = 0uL;
			instance.wallpaperHealth2 = 0f;
			instance.wallpaperRotation = 0f;
			instance.wallpaperRotation2 = 0f;
			Pool.Free<BuildingBlock>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BuildingBlock with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BuildingBlock instance)
	{
		instance.model = model;
		instance.grade = grade;
		instance.beingDemolished = beingDemolished;
		instance.wallpaperID = wallpaperID;
		instance.wallpaperHealth = wallpaperHealth;
		instance.wallpaperID2 = wallpaperID2;
		instance.wallpaperHealth2 = wallpaperHealth2;
		instance.wallpaperRotation = wallpaperRotation;
		instance.wallpaperRotation2 = wallpaperRotation2;
	}

	public BuildingBlock Copy()
	{
		BuildingBlock buildingBlock = Pool.Get<BuildingBlock>();
		CopyTo(buildingBlock);
		return buildingBlock;
	}

	public static BuildingBlock Deserialize(BufferStream stream)
	{
		BuildingBlock buildingBlock = Pool.Get<BuildingBlock>();
		Deserialize(stream, buildingBlock, isDelta: false);
		return buildingBlock;
	}

	public static BuildingBlock DeserializeLengthDelimited(BufferStream stream)
	{
		BuildingBlock buildingBlock = Pool.Get<BuildingBlock>();
		DeserializeLengthDelimited(stream, buildingBlock, isDelta: false);
		return buildingBlock;
	}

	public static BuildingBlock DeserializeLength(BufferStream stream, int length)
	{
		BuildingBlock buildingBlock = Pool.Get<BuildingBlock>();
		DeserializeLength(stream, length, buildingBlock, isDelta: false);
		return buildingBlock;
	}

	public static BuildingBlock Deserialize(byte[] buffer)
	{
		BuildingBlock buildingBlock = Pool.Get<BuildingBlock>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, buildingBlock, isDelta: false);
		return buildingBlock;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BuildingBlock previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BuildingBlock Deserialize(BufferStream stream, BuildingBlock instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.model = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.grade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.beingDemolished = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.wallpaperID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 45:
				instance.wallpaperHealth = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.wallpaperID2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.wallpaperHealth2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.wallpaperRotation = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.wallpaperRotation2 = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BuildingBlock DeserializeLengthDelimited(BufferStream stream, BuildingBlock instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.model = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.grade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.beingDemolished = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.wallpaperID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 45:
				instance.wallpaperHealth = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.wallpaperID2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.wallpaperHealth2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.wallpaperRotation = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.wallpaperRotation2 = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BuildingBlock DeserializeLength(BufferStream stream, int length, BuildingBlock instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.model = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.grade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.beingDemolished = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.wallpaperID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 45:
				instance.wallpaperHealth = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.wallpaperID2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.wallpaperHealth2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.wallpaperRotation = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.wallpaperRotation2 = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BuildingBlock instance, BuildingBlock previous)
	{
		if (instance.model != previous.model)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.model);
		}
		if (instance.grade != previous.grade)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.grade);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.beingDemolished);
		if (instance.wallpaperID != previous.wallpaperID)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.wallpaperID);
		}
		if (instance.wallpaperHealth != previous.wallpaperHealth)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.wallpaperHealth);
		}
		if (instance.wallpaperID2 != previous.wallpaperID2)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.wallpaperID2);
		}
		if (instance.wallpaperHealth2 != previous.wallpaperHealth2)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.wallpaperHealth2);
		}
		if (instance.wallpaperRotation != previous.wallpaperRotation)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.wallpaperRotation);
		}
		if (instance.wallpaperRotation2 != previous.wallpaperRotation2)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.wallpaperRotation2);
		}
	}

	public static void Serialize(BufferStream stream, BuildingBlock instance)
	{
		if (instance.model != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.model);
		}
		if (instance.grade != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.grade);
		}
		if (instance.beingDemolished)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.beingDemolished);
		}
		if (instance.wallpaperID != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.wallpaperID);
		}
		if (instance.wallpaperHealth != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.wallpaperHealth);
		}
		if (instance.wallpaperID2 != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.wallpaperID2);
		}
		if (instance.wallpaperHealth2 != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.wallpaperHealth2);
		}
		if (instance.wallpaperRotation != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.wallpaperRotation);
		}
		if (instance.wallpaperRotation2 != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.wallpaperRotation2);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BuildingPrivilege : IDisposable, IPooled, IProto<BuildingPrivilege>, IProto
{
	[NonSerialized]
	public List<PlayerNameID> users;

	[NonSerialized]
	public float upkeepPeriodMinutes;

	[NonSerialized]
	public float costFraction;

	[NonSerialized]
	public float protectedMinutes;

	[NonSerialized]
	public bool clientAuthed;

	[NonSerialized]
	public bool clientAnyAuthed;

	[NonSerialized]
	public float doorCostFraction;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BuildingPrivilege instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				if (instance.users[i] != null)
				{
					instance.users[i].ResetToPool();
					instance.users[i] = null;
				}
			}
			List<PlayerNameID> list = instance.users;
			Pool.Free<PlayerNameID>(ref list, false);
			instance.users = list;
		}
		instance.upkeepPeriodMinutes = 0f;
		instance.costFraction = 0f;
		instance.protectedMinutes = 0f;
		instance.clientAuthed = false;
		instance.clientAnyAuthed = false;
		instance.doorCostFraction = 0f;
		Pool.Free<BuildingPrivilege>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BuildingPrivilege with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BuildingPrivilege instance)
	{
		if (users != null)
		{
			instance.users = Pool.Get<List<PlayerNameID>>();
			for (int i = 0; i < users.Count; i++)
			{
				PlayerNameID item = users[i].Copy();
				instance.users.Add(item);
			}
		}
		else
		{
			instance.users = null;
		}
		instance.upkeepPeriodMinutes = upkeepPeriodMinutes;
		instance.costFraction = costFraction;
		instance.protectedMinutes = protectedMinutes;
		instance.clientAuthed = clientAuthed;
		instance.clientAnyAuthed = clientAnyAuthed;
		instance.doorCostFraction = doorCostFraction;
	}

	public BuildingPrivilege Copy()
	{
		BuildingPrivilege buildingPrivilege = Pool.Get<BuildingPrivilege>();
		CopyTo(buildingPrivilege);
		return buildingPrivilege;
	}

	public static BuildingPrivilege Deserialize(BufferStream stream)
	{
		BuildingPrivilege buildingPrivilege = Pool.Get<BuildingPrivilege>();
		Deserialize(stream, buildingPrivilege, isDelta: false);
		return buildingPrivilege;
	}

	public static BuildingPrivilege DeserializeLengthDelimited(BufferStream stream)
	{
		BuildingPrivilege buildingPrivilege = Pool.Get<BuildingPrivilege>();
		DeserializeLengthDelimited(stream, buildingPrivilege, isDelta: false);
		return buildingPrivilege;
	}

	public static BuildingPrivilege DeserializeLength(BufferStream stream, int length)
	{
		BuildingPrivilege buildingPrivilege = Pool.Get<BuildingPrivilege>();
		DeserializeLength(stream, length, buildingPrivilege, isDelta: false);
		return buildingPrivilege;
	}

	public static BuildingPrivilege Deserialize(byte[] buffer)
	{
		BuildingPrivilege buildingPrivilege = Pool.Get<BuildingPrivilege>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, buildingPrivilege, isDelta: false);
		return buildingPrivilege;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BuildingPrivilege previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BuildingPrivilege Deserialize(BufferStream stream, BuildingPrivilege instance, bool isDelta)
	{
		if (!isDelta && instance.users == null)
		{
			instance.users = Pool.Get<List<PlayerNameID>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.users.Add(PlayerNameID.DeserializeLengthDelimited(stream));
				continue;
			case 21:
				instance.upkeepPeriodMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.costFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.protectedMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.clientAuthed = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.clientAnyAuthed = ProtocolParser.ReadBool(stream);
				continue;
			case 61:
				instance.doorCostFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BuildingPrivilege DeserializeLengthDelimited(BufferStream stream, BuildingPrivilege instance, bool isDelta)
	{
		if (!isDelta && instance.users == null)
		{
			instance.users = Pool.Get<List<PlayerNameID>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.users.Add(PlayerNameID.DeserializeLengthDelimited(stream));
				continue;
			case 21:
				instance.upkeepPeriodMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.costFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.protectedMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.clientAuthed = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.clientAnyAuthed = ProtocolParser.ReadBool(stream);
				continue;
			case 61:
				instance.doorCostFraction = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BuildingPrivilege DeserializeLength(BufferStream stream, int length, BuildingPrivilege instance, bool isDelta)
	{
		if (!isDelta && instance.users == null)
		{
			instance.users = Pool.Get<List<PlayerNameID>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.users.Add(PlayerNameID.DeserializeLengthDelimited(stream));
				continue;
			case 21:
				instance.upkeepPeriodMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.costFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.protectedMinutes = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.clientAuthed = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.clientAnyAuthed = ProtocolParser.ReadBool(stream);
				continue;
			case 61:
				instance.doorCostFraction = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BuildingPrivilege instance, BuildingPrivilege previous)
	{
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				PlayerNameID playerNameID = instance.users[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerNameID.SerializeDelta(stream, playerNameID, playerNameID);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.upkeepPeriodMinutes != previous.upkeepPeriodMinutes)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.upkeepPeriodMinutes);
		}
		if (instance.costFraction != previous.costFraction)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.costFraction);
		}
		if (instance.protectedMinutes != previous.protectedMinutes)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.protectedMinutes);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.clientAuthed);
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.clientAnyAuthed);
		if (instance.doorCostFraction != previous.doorCostFraction)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.doorCostFraction);
		}
	}

	public static void Serialize(BufferStream stream, BuildingPrivilege instance)
	{
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				PlayerNameID instance2 = instance.users[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerNameID.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.upkeepPeriodMinutes != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.upkeepPeriodMinutes);
		}
		if (instance.costFraction != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.costFraction);
		}
		if (instance.protectedMinutes != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.protectedMinutes);
		}
		if (instance.clientAuthed)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.clientAuthed);
		}
		if (instance.clientAnyAuthed)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.clientAnyAuthed);
		}
		if (instance.doorCostFraction != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.doorCostFraction);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (users != null)
		{
			for (int i = 0; i < users.Count; i++)
			{
				users[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BuildingPrivilegeRetro : IDisposable, IPooled, IProto<BuildingPrivilegeRetro>, IProto
{
	[NonSerialized]
	public List<float> resources;

	[NonSerialized]
	public List<BuildingPrivilegeRetroTool> tools;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BuildingPrivilegeRetro instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.resources != null)
		{
			List<float> list = instance.resources;
			Pool.FreeUnmanaged<float>(ref list);
			instance.resources = list;
		}
		if (instance.tools != null)
		{
			for (int i = 0; i < instance.tools.Count; i++)
			{
				if (instance.tools[i] != null)
				{
					instance.tools[i].ResetToPool();
					instance.tools[i] = null;
				}
			}
			List<BuildingPrivilegeRetroTool> list2 = instance.tools;
			Pool.Free<BuildingPrivilegeRetroTool>(ref list2, false);
			instance.tools = list2;
		}
		Pool.Free<BuildingPrivilegeRetro>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BuildingPrivilegeRetro with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BuildingPrivilegeRetro instance)
	{
		if (resources != null)
		{
			instance.resources = Pool.Get<List<float>>();
			for (int i = 0; i < resources.Count; i++)
			{
				float item = resources[i];
				instance.resources.Add(item);
			}
		}
		else
		{
			instance.resources = null;
		}
		if (tools != null)
		{
			instance.tools = Pool.Get<List<BuildingPrivilegeRetroTool>>();
			for (int j = 0; j < tools.Count; j++)
			{
				BuildingPrivilegeRetroTool item2 = tools[j].Copy();
				instance.tools.Add(item2);
			}
		}
		else
		{
			instance.tools = null;
		}
	}

	public BuildingPrivilegeRetro Copy()
	{
		BuildingPrivilegeRetro buildingPrivilegeRetro = Pool.Get<BuildingPrivilegeRetro>();
		CopyTo(buildingPrivilegeRetro);
		return buildingPrivilegeRetro;
	}

	public static BuildingPrivilegeRetro Deserialize(BufferStream stream)
	{
		BuildingPrivilegeRetro buildingPrivilegeRetro = Pool.Get<BuildingPrivilegeRetro>();
		Deserialize(stream, buildingPrivilegeRetro, isDelta: false);
		return buildingPrivilegeRetro;
	}

	public static BuildingPrivilegeRetro DeserializeLengthDelimited(BufferStream stream)
	{
		BuildingPrivilegeRetro buildingPrivilegeRetro = Pool.Get<BuildingPrivilegeRetro>();
		DeserializeLengthDelimited(stream, buildingPrivilegeRetro, isDelta: false);
		return buildingPrivilegeRetro;
	}

	public static BuildingPrivilegeRetro DeserializeLength(BufferStream stream, int length)
	{
		BuildingPrivilegeRetro buildingPrivilegeRetro = Pool.Get<BuildingPrivilegeRetro>();
		DeserializeLength(stream, length, buildingPrivilegeRetro, isDelta: false);
		return buildingPrivilegeRetro;
	}

	public static BuildingPrivilegeRetro Deserialize(byte[] buffer)
	{
		BuildingPrivilegeRetro buildingPrivilegeRetro = Pool.Get<BuildingPrivilegeRetro>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, buildingPrivilegeRetro, isDelta: false);
		return buildingPrivilegeRetro;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BuildingPrivilegeRetro previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BuildingPrivilegeRetro Deserialize(BufferStream stream, BuildingPrivilegeRetro instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.resources == null)
			{
				instance.resources = Pool.Get<List<float>>();
			}
			if (instance.tools == null)
			{
				instance.tools = Pool.Get<List<BuildingPrivilegeRetroTool>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.resources.Add(ProtocolParser.ReadSingle(stream));
				continue;
			case 18:
				instance.tools.Add(BuildingPrivilegeRetroTool.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BuildingPrivilegeRetro DeserializeLengthDelimited(BufferStream stream, BuildingPrivilegeRetro instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.resources == null)
			{
				instance.resources = Pool.Get<List<float>>();
			}
			if (instance.tools == null)
			{
				instance.tools = Pool.Get<List<BuildingPrivilegeRetroTool>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.resources.Add(ProtocolParser.ReadSingle(stream));
				continue;
			case 18:
				instance.tools.Add(BuildingPrivilegeRetroTool.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BuildingPrivilegeRetro DeserializeLength(BufferStream stream, int length, BuildingPrivilegeRetro instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.resources == null)
			{
				instance.resources = Pool.Get<List<float>>();
			}
			if (instance.tools == null)
			{
				instance.tools = Pool.Get<List<BuildingPrivilegeRetroTool>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.resources.Add(ProtocolParser.ReadSingle(stream));
				continue;
			case 18:
				instance.tools.Add(BuildingPrivilegeRetroTool.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BuildingPrivilegeRetro instance, BuildingPrivilegeRetro previous)
	{
		if (instance.resources != null)
		{
			for (int i = 0; i < instance.resources.Count; i++)
			{
				float f = instance.resources[i];
				stream.WriteByte(13);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
		if (instance.tools == null)
		{
			return;
		}
		for (int j = 0; j < instance.tools.Count; j++)
		{
			BuildingPrivilegeRetroTool buildingPrivilegeRetroTool = instance.tools[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			BuildingPrivilegeRetroTool.SerializeDelta(stream, buildingPrivilegeRetroTool, buildingPrivilegeRetroTool);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field tools (ProtoBuf.BuildingPrivilegeRetroTool)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, BuildingPrivilegeRetro instance)
	{
		if (instance.resources != null)
		{
			for (int i = 0; i < instance.resources.Count; i++)
			{
				float f = instance.resources[i];
				stream.WriteByte(13);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
		if (instance.tools == null)
		{
			return;
		}
		for (int j = 0; j < instance.tools.Count; j++)
		{
			BuildingPrivilegeRetroTool instance2 = instance.tools[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			BuildingPrivilegeRetroTool.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field tools (ProtoBuf.BuildingPrivilegeRetroTool)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (tools != null)
		{
			for (int i = 0; i < tools.Count; i++)
			{
				tools[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class BuildingPrivilegeRetroTool : IDisposable, IPooled, IProto<BuildingPrivilegeRetroTool>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public ulong skinid;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BuildingPrivilegeRetroTool instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.skinid = 0uL;
			Pool.Free<BuildingPrivilegeRetroTool>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BuildingPrivilegeRetroTool with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BuildingPrivilegeRetroTool instance)
	{
		instance.itemID = itemID;
		instance.skinid = skinid;
	}

	public BuildingPrivilegeRetroTool Copy()
	{
		BuildingPrivilegeRetroTool buildingPrivilegeRetroTool = Pool.Get<BuildingPrivilegeRetroTool>();
		CopyTo(buildingPrivilegeRetroTool);
		return buildingPrivilegeRetroTool;
	}

	public static BuildingPrivilegeRetroTool Deserialize(BufferStream stream)
	{
		BuildingPrivilegeRetroTool buildingPrivilegeRetroTool = Pool.Get<BuildingPrivilegeRetroTool>();
		Deserialize(stream, buildingPrivilegeRetroTool, isDelta: false);
		return buildingPrivilegeRetroTool;
	}

	public static BuildingPrivilegeRetroTool DeserializeLengthDelimited(BufferStream stream)
	{
		BuildingPrivilegeRetroTool buildingPrivilegeRetroTool = Pool.Get<BuildingPrivilegeRetroTool>();
		DeserializeLengthDelimited(stream, buildingPrivilegeRetroTool, isDelta: false);
		return buildingPrivilegeRetroTool;
	}

	public static BuildingPrivilegeRetroTool DeserializeLength(BufferStream stream, int length)
	{
		BuildingPrivilegeRetroTool buildingPrivilegeRetroTool = Pool.Get<BuildingPrivilegeRetroTool>();
		DeserializeLength(stream, length, buildingPrivilegeRetroTool, isDelta: false);
		return buildingPrivilegeRetroTool;
	}

	public static BuildingPrivilegeRetroTool Deserialize(byte[] buffer)
	{
		BuildingPrivilegeRetroTool buildingPrivilegeRetroTool = Pool.Get<BuildingPrivilegeRetroTool>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, buildingPrivilegeRetroTool, isDelta: false);
		return buildingPrivilegeRetroTool;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BuildingPrivilegeRetroTool previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BuildingPrivilegeRetroTool Deserialize(BufferStream stream, BuildingPrivilegeRetroTool instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.skinid = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BuildingPrivilegeRetroTool DeserializeLengthDelimited(BufferStream stream, BuildingPrivilegeRetroTool instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.skinid = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BuildingPrivilegeRetroTool DeserializeLength(BufferStream stream, int length, BuildingPrivilegeRetroTool instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.skinid = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BuildingPrivilegeRetroTool instance, BuildingPrivilegeRetroTool previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.skinid != previous.skinid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.skinid);
		}
	}

	public static void Serialize(BufferStream stream, BuildingPrivilegeRetroTool instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.skinid != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.skinid);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class BuriedItems : IDisposable, IPooled, IProto<BuriedItems>, IProto
{
	public class StoredBuriedItem : IDisposable, IPooled, IProto<StoredBuriedItem>, IProto
	{
		[NonSerialized]
		public int itemId;

		[NonSerialized]
		public ItemOwnershipAmount ownership;

		[NonSerialized]
		public ulong skinId;

		[NonSerialized]
		public long expiryTimeDiff;

		[NonSerialized]
		public Vector2 location;

		[NonSerialized]
		public float condition;

		[NonSerialized]
		public ulong uid;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(StoredBuriedItem instance)
		{
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.itemId = 0;
				if (instance.ownership != null)
				{
					instance.ownership.ResetToPool();
					instance.ownership = null;
				}
				instance.skinId = 0uL;
				instance.expiryTimeDiff = 0L;
				instance.location = default(Vector2);
				instance.condition = 0f;
				instance.uid = 0uL;
				Pool.Free<StoredBuriedItem>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose StoredBuriedItem with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(StoredBuriedItem instance)
		{
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			instance.itemId = itemId;
			if (ownership != null)
			{
				if (instance.ownership == null)
				{
					instance.ownership = ownership.Copy();
				}
				else
				{
					ownership.CopyTo(instance.ownership);
				}
			}
			else
			{
				instance.ownership = null;
			}
			instance.skinId = skinId;
			instance.expiryTimeDiff = expiryTimeDiff;
			instance.location = location;
			instance.condition = condition;
			instance.uid = uid;
		}

		public StoredBuriedItem Copy()
		{
			StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
			CopyTo(storedBuriedItem);
			return storedBuriedItem;
		}

		public static StoredBuriedItem Deserialize(BufferStream stream)
		{
			StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
			Deserialize(stream, storedBuriedItem, isDelta: false);
			return storedBuriedItem;
		}

		public static StoredBuriedItem DeserializeLengthDelimited(BufferStream stream)
		{
			StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
			DeserializeLengthDelimited(stream, storedBuriedItem, isDelta: false);
			return storedBuriedItem;
		}

		public static StoredBuriedItem DeserializeLength(BufferStream stream, int length)
		{
			StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
			DeserializeLength(stream, length, storedBuriedItem, isDelta: false);
			return storedBuriedItem;
		}

		public static StoredBuriedItem Deserialize(byte[] buffer)
		{
			StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, storedBuriedItem, isDelta: false);
			return storedBuriedItem;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, StoredBuriedItem previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static StoredBuriedItem Deserialize(BufferStream stream, StoredBuriedItem instance, bool isDelta)
		{
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 18:
					if (instance.ownership == null)
					{
						instance.ownership = ItemOwnershipAmount.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemOwnershipAmount.DeserializeLengthDelimited(stream, instance.ownership, isDelta);
					}
					break;
				case 24:
					instance.skinId = ProtocolParser.ReadUInt64(stream);
					break;
				case 32:
					instance.expiryTimeDiff = (long)ProtocolParser.ReadUInt64(stream);
					break;
				case 42:
					Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
					break;
				case 53:
					instance.condition = ProtocolParser.ReadSingle(stream);
					break;
				case 56:
					instance.uid = ProtocolParser.ReadUInt64(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
				case 0:
					return instance;
				}
			}
		}

		public static StoredBuriedItem DeserializeLengthDelimited(BufferStream stream, StoredBuriedItem instance, bool isDelta)
		{
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 18:
					if (instance.ownership == null)
					{
						instance.ownership = ItemOwnershipAmount.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemOwnershipAmount.DeserializeLengthDelimited(stream, instance.ownership, isDelta);
					}
					break;
				case 24:
					instance.skinId = ProtocolParser.ReadUInt64(stream);
					break;
				case 32:
					instance.expiryTimeDiff = (long)ProtocolParser.ReadUInt64(stream);
					break;
				case 42:
					Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
					break;
				case 53:
					instance.condition = ProtocolParser.ReadSingle(stream);
					break;
				case 56:
					instance.uid = ProtocolParser.ReadUInt64(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static StoredBuriedItem DeserializeLength(BufferStream stream, int length, StoredBuriedItem instance, bool isDelta)
		{
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 18:
					if (instance.ownership == null)
					{
						instance.ownership = ItemOwnershipAmount.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemOwnershipAmount.DeserializeLengthDelimited(stream, instance.ownership, isDelta);
					}
					break;
				case 24:
					instance.skinId = ProtocolParser.ReadUInt64(stream);
					break;
				case 32:
					instance.expiryTimeDiff = (long)ProtocolParser.ReadUInt64(stream);
					break;
				case 42:
					Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
					break;
				case 53:
					instance.condition = ProtocolParser.ReadSingle(stream);
					break;
				case 56:
					instance.uid = ProtocolParser.ReadUInt64(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, StoredBuriedItem instance, StoredBuriedItem previous)
		{
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			if (instance.itemId != previous.itemId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.ownership != null)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ItemOwnershipAmount.SerializeDelta(stream, instance.ownership, previous.ownership);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
			if (instance.skinId != previous.skinId)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.skinId);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.expiryTimeDiff);
			if (instance.location != previous.location)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector2Serialized.SerializeDelta(stream, instance.location, previous.location);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field location (UnityEngine.Vector2)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.condition != previous.condition)
			{
				stream.WriteByte(53);
				ProtocolParser.WriteSingle(stream, instance.condition);
			}
			if (instance.uid != previous.uid)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, instance.uid);
			}
		}

		public static void Serialize(BufferStream stream, StoredBuriedItem instance)
		{
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00df: Unknown result type (might be due to invalid IL or missing references)
			//IL_0103: Unknown result type (might be due to invalid IL or missing references)
			if (instance.itemId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.ownership != null)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ItemOwnershipAmount.Serialize(stream, instance.ownership);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
			if (instance.skinId != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.skinId);
			}
			if (instance.expiryTimeDiff != 0L)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.expiryTimeDiff);
			}
			if (instance.location != default(Vector2))
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector2Serialized.Serialize(stream, instance.location);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field location (UnityEngine.Vector2)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.condition != 0f)
			{
				stream.WriteByte(53);
				ProtocolParser.WriteSingle(stream, instance.condition);
			}
			if (instance.uid != 0L)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, instance.uid);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			ownership?.InspectUids(action);
		}
	}

	[NonSerialized]
	public List<StoredBuriedItem> buriedItems;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BuriedItems instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.buriedItems != null)
		{
			for (int i = 0; i < instance.buriedItems.Count; i++)
			{
				if (instance.buriedItems[i] != null)
				{
					instance.buriedItems[i].ResetToPool();
					instance.buriedItems[i] = null;
				}
			}
			List<StoredBuriedItem> list = instance.buriedItems;
			Pool.Free<StoredBuriedItem>(ref list, false);
			instance.buriedItems = list;
		}
		Pool.Free<BuriedItems>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BuriedItems with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BuriedItems instance)
	{
		if (buriedItems != null)
		{
			instance.buriedItems = Pool.Get<List<StoredBuriedItem>>();
			for (int i = 0; i < buriedItems.Count; i++)
			{
				StoredBuriedItem item = buriedItems[i].Copy();
				instance.buriedItems.Add(item);
			}
		}
		else
		{
			instance.buriedItems = null;
		}
	}

	public BuriedItems Copy()
	{
		BuriedItems buriedItems = Pool.Get<BuriedItems>();
		CopyTo(buriedItems);
		return buriedItems;
	}

	public static BuriedItems Deserialize(BufferStream stream)
	{
		BuriedItems buriedItems = Pool.Get<BuriedItems>();
		Deserialize(stream, buriedItems, isDelta: false);
		return buriedItems;
	}

	public static BuriedItems DeserializeLengthDelimited(BufferStream stream)
	{
		BuriedItems buriedItems = Pool.Get<BuriedItems>();
		DeserializeLengthDelimited(stream, buriedItems, isDelta: false);
		return buriedItems;
	}

	public static BuriedItems DeserializeLength(BufferStream stream, int length)
	{
		BuriedItems buriedItems = Pool.Get<BuriedItems>();
		DeserializeLength(stream, length, buriedItems, isDelta: false);
		return buriedItems;
	}

	public static BuriedItems Deserialize(byte[] buffer)
	{
		BuriedItems buriedItems = Pool.Get<BuriedItems>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, buriedItems, isDelta: false);
		return buriedItems;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BuriedItems previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BuriedItems Deserialize(BufferStream stream, BuriedItems instance, bool isDelta)
	{
		if (!isDelta && instance.buriedItems == null)
		{
			instance.buriedItems = Pool.Get<List<StoredBuriedItem>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.buriedItems.Add(StoredBuriedItem.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BuriedItems DeserializeLengthDelimited(BufferStream stream, BuriedItems instance, bool isDelta)
	{
		if (!isDelta && instance.buriedItems == null)
		{
			instance.buriedItems = Pool.Get<List<StoredBuriedItem>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.buriedItems.Add(StoredBuriedItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BuriedItems DeserializeLength(BufferStream stream, int length, BuriedItems instance, bool isDelta)
	{
		if (!isDelta && instance.buriedItems == null)
		{
			instance.buriedItems = Pool.Get<List<StoredBuriedItem>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.buriedItems.Add(StoredBuriedItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BuriedItems instance, BuriedItems previous)
	{
		if (instance.buriedItems == null)
		{
			return;
		}
		for (int i = 0; i < instance.buriedItems.Count; i++)
		{
			StoredBuriedItem storedBuriedItem = instance.buriedItems[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			StoredBuriedItem.SerializeDelta(stream, storedBuriedItem, storedBuriedItem);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, BuriedItems instance)
	{
		if (instance.buriedItems == null)
		{
			return;
		}
		for (int i = 0; i < instance.buriedItems.Count; i++)
		{
			StoredBuriedItem instance2 = instance.buriedItems[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			StoredBuriedItem.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (buriedItems != null)
		{
			for (int i = 0; i < buriedItems.Count; i++)
			{
				buriedItems[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CamperModule : IDisposable, IPooled, IProto<CamperModule>, IProto
{
	[NonSerialized]
	public NetworkableId bbqId;

	[NonSerialized]
	public NetworkableId lockerId;

	[NonSerialized]
	public NetworkableId storageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CamperModule instance)
	{
		if (instance.ShouldPool)
		{
			instance.bbqId = default(NetworkableId);
			instance.lockerId = default(NetworkableId);
			instance.storageID = default(NetworkableId);
			Pool.Free<CamperModule>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CamperModule with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CamperModule instance)
	{
		instance.bbqId = bbqId;
		instance.lockerId = lockerId;
		instance.storageID = storageID;
	}

	public CamperModule Copy()
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		CopyTo(camperModule);
		return camperModule;
	}

	public static CamperModule Deserialize(BufferStream stream)
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		Deserialize(stream, camperModule, isDelta: false);
		return camperModule;
	}

	public static CamperModule DeserializeLengthDelimited(BufferStream stream)
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		DeserializeLengthDelimited(stream, camperModule, isDelta: false);
		return camperModule;
	}

	public static CamperModule DeserializeLength(BufferStream stream, int length)
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		DeserializeLength(stream, length, camperModule, isDelta: false);
		return camperModule;
	}

	public static CamperModule Deserialize(byte[] buffer)
	{
		CamperModule camperModule = Pool.Get<CamperModule>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, camperModule, isDelta: false);
		return camperModule;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CamperModule previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CamperModule Deserialize(BufferStream stream, CamperModule instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.bbqId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.lockerId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CamperModule DeserializeLengthDelimited(BufferStream stream, CamperModule instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.bbqId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.lockerId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CamperModule DeserializeLength(BufferStream stream, int length, CamperModule instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.bbqId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.lockerId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CamperModule instance, CamperModule previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.bbqId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.lockerId.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
	}

	public static void Serialize(BufferStream stream, CamperModule instance)
	{
		if (instance.bbqId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.bbqId.Value);
		}
		if (instance.lockerId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.lockerId.Value);
		}
		if (instance.storageID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref bbqId.Value);
		action(UidType.NetworkableId, ref lockerId.Value);
		action(UidType.NetworkableId, ref storageID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CardGame : IDisposable, IPooled, IProto<CardGame>, IProto
{
	public class Blackjack : IDisposable, IPooled, IProto<Blackjack>, IProto
	{
		[NonSerialized]
		public List<int> dealerCards;

		[NonSerialized]
		public List<BlackjackCardPlayer> players;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Blackjack instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.dealerCards != null)
			{
				List<int> list = instance.dealerCards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.dealerCards = list;
			}
			if (instance.players != null)
			{
				for (int i = 0; i < instance.players.Count; i++)
				{
					if (instance.players[i] != null)
					{
						instance.players[i].ResetToPool();
						instance.players[i] = null;
					}
				}
				List<BlackjackCardPlayer> list2 = instance.players;
				Pool.Free<BlackjackCardPlayer>(ref list2, false);
				instance.players = list2;
			}
			Pool.Free<Blackjack>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Blackjack with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Blackjack instance)
		{
			if (dealerCards != null)
			{
				instance.dealerCards = Pool.Get<List<int>>();
				for (int i = 0; i < dealerCards.Count; i++)
				{
					int item = dealerCards[i];
					instance.dealerCards.Add(item);
				}
			}
			else
			{
				instance.dealerCards = null;
			}
			if (players != null)
			{
				instance.players = Pool.Get<List<BlackjackCardPlayer>>();
				for (int j = 0; j < players.Count; j++)
				{
					BlackjackCardPlayer item2 = players[j].Copy();
					instance.players.Add(item2);
				}
			}
			else
			{
				instance.players = null;
			}
		}

		public Blackjack Copy()
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			CopyTo(blackjack);
			return blackjack;
		}

		public static Blackjack Deserialize(BufferStream stream)
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			Deserialize(stream, blackjack, isDelta: false);
			return blackjack;
		}

		public static Blackjack DeserializeLengthDelimited(BufferStream stream)
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			DeserializeLengthDelimited(stream, blackjack, isDelta: false);
			return blackjack;
		}

		public static Blackjack DeserializeLength(BufferStream stream, int length)
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			DeserializeLength(stream, length, blackjack, isDelta: false);
			return blackjack;
		}

		public static Blackjack Deserialize(byte[] buffer)
		{
			Blackjack blackjack = Pool.Get<Blackjack>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, blackjack, isDelta: false);
			return blackjack;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Blackjack previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Blackjack Deserialize(BufferStream stream, Blackjack instance, bool isDelta)
		{
			if (!isDelta)
			{
				if (instance.dealerCards == null)
				{
					instance.dealerCards = Pool.Get<List<int>>();
				}
				if (instance.players == null)
				{
					instance.players = Pool.Get<List<BlackjackCardPlayer>>();
				}
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Blackjack DeserializeLengthDelimited(BufferStream stream, Blackjack instance, bool isDelta)
		{
			if (!isDelta)
			{
				if (instance.dealerCards == null)
				{
					instance.dealerCards = Pool.Get<List<int>>();
				}
				if (instance.players == null)
				{
					instance.players = Pool.Get<List<BlackjackCardPlayer>>();
				}
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Blackjack DeserializeLength(BufferStream stream, int length, Blackjack instance, bool isDelta)
		{
			if (!isDelta)
			{
				if (instance.dealerCards == null)
				{
					instance.dealerCards = Pool.Get<List<int>>();
				}
				if (instance.players == null)
				{
					instance.players = Pool.Get<List<BlackjackCardPlayer>>();
				}
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 18:
					instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Blackjack instance, Blackjack previous)
		{
			if (instance.dealerCards != null)
			{
				for (int i = 0; i < instance.dealerCards.Count; i++)
				{
					int num = instance.dealerCards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.players == null)
			{
				return;
			}
			for (int j = 0; j < instance.players.Count; j++)
			{
				BlackjackCardPlayer blackjackCardPlayer = instance.players[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				BlackjackCardPlayer.SerializeDelta(stream, blackjackCardPlayer, blackjackCardPlayer);
				int num2 = stream.Position - position;
				if (num2 > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.BlackjackCardPlayer)");
				}
				Span<byte> span = range.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
				if (num3 < 3)
				{
					span[num3 - 1] |= 128;
					while (num3 < 2)
					{
						span[num3++] = 128;
					}
					span[2] = 0;
				}
			}
		}

		public static void Serialize(BufferStream stream, Blackjack instance)
		{
			if (instance.dealerCards != null)
			{
				for (int i = 0; i < instance.dealerCards.Count; i++)
				{
					int num = instance.dealerCards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.players == null)
			{
				return;
			}
			for (int j = 0; j < instance.players.Count; j++)
			{
				BlackjackCardPlayer instance2 = instance.players[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				BlackjackCardPlayer.Serialize(stream, instance2);
				int num2 = stream.Position - position;
				if (num2 > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.BlackjackCardPlayer)");
				}
				Span<byte> span = range.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
				if (num3 < 3)
				{
					span[num3 - 1] |= 128;
					while (num3 < 2)
					{
						span[num3++] = 128;
					}
					span[2] = 0;
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (players != null)
			{
				for (int i = 0; i < players.Count; i++)
				{
					players[i]?.InspectUids(action);
				}
			}
		}
	}

	public class BlackjackCardPlayer : IDisposable, IPooled, IProto<BlackjackCardPlayer>, IProto
	{
		[NonSerialized]
		public List<int> splitCards;

		[NonSerialized]
		public int splitBetThisRound;

		[NonSerialized]
		public int insuranceBetThisRound;

		[NonSerialized]
		public bool playingSplitCards;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(BlackjackCardPlayer instance)
		{
			if (instance.ShouldPool)
			{
				if (instance.splitCards != null)
				{
					List<int> list = instance.splitCards;
					Pool.FreeUnmanaged<int>(ref list);
					instance.splitCards = list;
				}
				instance.splitBetThisRound = 0;
				instance.insuranceBetThisRound = 0;
				instance.playingSplitCards = false;
				Pool.Free<BlackjackCardPlayer>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose BlackjackCardPlayer with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(BlackjackCardPlayer instance)
		{
			if (splitCards != null)
			{
				instance.splitCards = Pool.Get<List<int>>();
				for (int i = 0; i < splitCards.Count; i++)
				{
					int item = splitCards[i];
					instance.splitCards.Add(item);
				}
			}
			else
			{
				instance.splitCards = null;
			}
			instance.splitBetThisRound = splitBetThisRound;
			instance.insuranceBetThisRound = insuranceBetThisRound;
			instance.playingSplitCards = playingSplitCards;
		}

		public BlackjackCardPlayer Copy()
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			CopyTo(blackjackCardPlayer);
			return blackjackCardPlayer;
		}

		public static BlackjackCardPlayer Deserialize(BufferStream stream)
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			Deserialize(stream, blackjackCardPlayer, isDelta: false);
			return blackjackCardPlayer;
		}

		public static BlackjackCardPlayer DeserializeLengthDelimited(BufferStream stream)
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			DeserializeLengthDelimited(stream, blackjackCardPlayer, isDelta: false);
			return blackjackCardPlayer;
		}

		public static BlackjackCardPlayer DeserializeLength(BufferStream stream, int length)
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			DeserializeLength(stream, length, blackjackCardPlayer, isDelta: false);
			return blackjackCardPlayer;
		}

		public static BlackjackCardPlayer Deserialize(byte[] buffer)
		{
			BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, blackjackCardPlayer, isDelta: false);
			return blackjackCardPlayer;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, BlackjackCardPlayer previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static BlackjackCardPlayer Deserialize(BufferStream stream, BlackjackCardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.splitCards == null)
			{
				instance.splitCards = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.playingSplitCards = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static BlackjackCardPlayer DeserializeLengthDelimited(BufferStream stream, BlackjackCardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.splitCards == null)
			{
				instance.splitCards = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.playingSplitCards = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static BlackjackCardPlayer DeserializeLength(BufferStream stream, int length, BlackjackCardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.splitCards == null)
			{
				instance.splitCards = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.playingSplitCards = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, BlackjackCardPlayer instance, BlackjackCardPlayer previous)
		{
			if (instance.splitCards != null)
			{
				for (int i = 0; i < instance.splitCards.Count; i++)
				{
					int num = instance.splitCards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.splitBetThisRound != previous.splitBetThisRound)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.splitBetThisRound);
			}
			if (instance.insuranceBetThisRound != previous.insuranceBetThisRound)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.insuranceBetThisRound);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.playingSplitCards);
		}

		public static void Serialize(BufferStream stream, BlackjackCardPlayer instance)
		{
			if (instance.splitCards != null)
			{
				for (int i = 0; i < instance.splitCards.Count; i++)
				{
					int num = instance.splitCards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.splitBetThisRound != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.splitBetThisRound);
			}
			if (instance.insuranceBetThisRound != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.insuranceBetThisRound);
			}
			if (instance.playingSplitCards)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteBool(stream, instance.playingSplitCards);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class CardList : IDisposable, IPooled, IProto<CardList>, IProto
	{
		[NonSerialized]
		public List<int> cards;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(CardList instance)
		{
			if (instance.ShouldPool)
			{
				if (instance.cards != null)
				{
					List<int> list = instance.cards;
					Pool.FreeUnmanaged<int>(ref list);
					instance.cards = list;
				}
				Pool.Free<CardList>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose CardList with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(CardList instance)
		{
			if (cards != null)
			{
				instance.cards = Pool.Get<List<int>>();
				for (int i = 0; i < cards.Count; i++)
				{
					int item = cards[i];
					instance.cards.Add(item);
				}
			}
			else
			{
				instance.cards = null;
			}
		}

		public CardList Copy()
		{
			CardList cardList = Pool.Get<CardList>();
			CopyTo(cardList);
			return cardList;
		}

		public static CardList Deserialize(BufferStream stream)
		{
			CardList cardList = Pool.Get<CardList>();
			Deserialize(stream, cardList, isDelta: false);
			return cardList;
		}

		public static CardList DeserializeLengthDelimited(BufferStream stream)
		{
			CardList cardList = Pool.Get<CardList>();
			DeserializeLengthDelimited(stream, cardList, isDelta: false);
			return cardList;
		}

		public static CardList DeserializeLength(BufferStream stream, int length)
		{
			CardList cardList = Pool.Get<CardList>();
			DeserializeLength(stream, length, cardList, isDelta: false);
			return cardList;
		}

		public static CardList Deserialize(byte[] buffer)
		{
			CardList cardList = Pool.Get<CardList>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, cardList, isDelta: false);
			return cardList;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, CardList previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static CardList Deserialize(BufferStream stream, CardList instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static CardList DeserializeLengthDelimited(BufferStream stream, CardList instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static CardList DeserializeLength(BufferStream stream, int length, CardList instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, CardList instance, CardList previous)
		{
			if (instance.cards != null)
			{
				for (int i = 0; i < instance.cards.Count; i++)
				{
					int num = instance.cards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
		}

		public static void Serialize(BufferStream stream, CardList instance)
		{
			if (instance.cards != null)
			{
				for (int i = 0; i < instance.cards.Count; i++)
				{
					int num = instance.cards[i];
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class CardPlayer : IDisposable, IPooled, IProto<CardPlayer>, IProto
	{
		[NonSerialized]
		public ulong userid;

		[NonSerialized]
		public List<int> cards;

		[NonSerialized]
		public int scrap;

		[NonSerialized]
		public int state;

		[NonSerialized]
		public int availableInputs;

		[NonSerialized]
		public int betThisRound;

		[NonSerialized]
		public int betThisTurn;

		[NonSerialized]
		public bool leftRoundEarly;

		[NonSerialized]
		public bool sendCardDetails;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(CardPlayer instance)
		{
			if (instance.ShouldPool)
			{
				instance.userid = 0uL;
				if (instance.cards != null)
				{
					List<int> list = instance.cards;
					Pool.FreeUnmanaged<int>(ref list);
					instance.cards = list;
				}
				instance.scrap = 0;
				instance.state = 0;
				instance.availableInputs = 0;
				instance.betThisRound = 0;
				instance.betThisTurn = 0;
				instance.leftRoundEarly = false;
				instance.sendCardDetails = false;
				Pool.Free<CardPlayer>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose CardPlayer with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(CardPlayer instance)
		{
			instance.userid = userid;
			if (cards != null)
			{
				instance.cards = Pool.Get<List<int>>();
				for (int i = 0; i < cards.Count; i++)
				{
					int item = cards[i];
					instance.cards.Add(item);
				}
			}
			else
			{
				instance.cards = null;
			}
			instance.scrap = scrap;
			instance.state = state;
			instance.availableInputs = availableInputs;
			instance.betThisRound = betThisRound;
			instance.betThisTurn = betThisTurn;
			instance.leftRoundEarly = leftRoundEarly;
			instance.sendCardDetails = sendCardDetails;
		}

		public CardPlayer Copy()
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			CopyTo(cardPlayer);
			return cardPlayer;
		}

		public static CardPlayer Deserialize(BufferStream stream)
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			Deserialize(stream, cardPlayer, isDelta: false);
			return cardPlayer;
		}

		public static CardPlayer DeserializeLengthDelimited(BufferStream stream)
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			DeserializeLengthDelimited(stream, cardPlayer, isDelta: false);
			return cardPlayer;
		}

		public static CardPlayer DeserializeLength(BufferStream stream, int length)
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			DeserializeLength(stream, length, cardPlayer, isDelta: false);
			return cardPlayer;
		}

		public static CardPlayer Deserialize(byte[] buffer)
		{
			CardPlayer cardPlayer = Pool.Get<CardPlayer>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, cardPlayer, isDelta: false);
			return cardPlayer;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, CardPlayer previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static CardPlayer Deserialize(BufferStream stream, CardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.state = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 64:
					instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.sendCardDetails = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static CardPlayer DeserializeLengthDelimited(BufferStream stream, CardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.state = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 64:
					instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.sendCardDetails = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static CardPlayer DeserializeLength(BufferStream stream, int length, CardPlayer instance, bool isDelta)
		{
			if (!isDelta && instance.cards == null)
			{
				instance.cards = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.state = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 64:
					instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.sendCardDetails = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, CardPlayer instance, CardPlayer previous)
		{
			if (instance.userid != previous.userid)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.cards != null)
			{
				for (int i = 0; i < instance.cards.Count; i++)
				{
					int num = instance.cards[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.scrap != previous.scrap)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.scrap);
			}
			if (instance.state != previous.state)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
			}
			if (instance.availableInputs != previous.availableInputs)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.availableInputs);
			}
			if (instance.betThisRound != previous.betThisRound)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisRound);
			}
			if (instance.betThisTurn != previous.betThisTurn)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisTurn);
			}
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.leftRoundEarly);
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.sendCardDetails);
		}

		public static void Serialize(BufferStream stream, CardPlayer instance)
		{
			if (instance.userid != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.cards != null)
			{
				for (int i = 0; i < instance.cards.Count; i++)
				{
					int num = instance.cards[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.scrap != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.scrap);
			}
			if (instance.state != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
			}
			if (instance.availableInputs != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.availableInputs);
			}
			if (instance.betThisRound != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisRound);
			}
			if (instance.betThisTurn != 0)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisTurn);
			}
			if (instance.leftRoundEarly)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteBool(stream, instance.leftRoundEarly);
			}
			if (instance.sendCardDetails)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteBool(stream, instance.sendCardDetails);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class RoundResults : IDisposable, IPooled, IProto<RoundResults>, IProto
	{
		public class Result : IDisposable, IPooled, IProto<Result>, IProto
		{
			[NonSerialized]
			public ulong ID;

			[NonSerialized]
			public int winnings;

			[NonSerialized]
			public int resultCode;

			public bool ShouldPool = true;

			private bool _disposed;

			public static void ResetToPool(Result instance)
			{
				if (instance.ShouldPool)
				{
					instance.ID = 0uL;
					instance.winnings = 0;
					instance.resultCode = 0;
					Pool.Free<Result>(ref instance);
				}
			}

			public void ResetToPool()
			{
				ResetToPool(this);
			}

			public virtual void Dispose()
			{
				if (!ShouldPool)
				{
					throw new Exception("Trying to dispose Result with ShouldPool set to false!");
				}
				if (!_disposed)
				{
					ResetToPool();
					_disposed = true;
				}
			}

			public virtual void EnterPool()
			{
				_disposed = true;
			}

			public virtual void LeavePool()
			{
				_disposed = false;
			}

			public void CopyTo(Result instance)
			{
				instance.ID = ID;
				instance.winnings = winnings;
				instance.resultCode = resultCode;
			}

			public Result Copy()
			{
				Result result = Pool.Get<Result>();
				CopyTo(result);
				return result;
			}

			public static Result Deserialize(BufferStream stream)
			{
				Result result = Pool.Get<Result>();
				Deserialize(stream, result, isDelta: false);
				return result;
			}

			public static Result DeserializeLengthDelimited(BufferStream stream)
			{
				Result result = Pool.Get<Result>();
				DeserializeLengthDelimited(stream, result, isDelta: false);
				return result;
			}

			public static Result DeserializeLength(BufferStream stream, int length)
			{
				Result result = Pool.Get<Result>();
				DeserializeLength(stream, length, result, isDelta: false);
				return result;
			}

			public static Result Deserialize(byte[] buffer)
			{
				Result result = Pool.Get<Result>();
				using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
				Deserialize(stream, result, isDelta: false);
				return result;
			}

			public void FromProto(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void WriteToStream(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public virtual void WriteToStreamDelta(BufferStream stream, Result previous)
			{
				if (previous == null)
				{
					Serialize(stream, this);
				}
				else
				{
					SerializeDelta(stream, this, previous);
				}
			}

			public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
			{
				DeserializeLength(stream, size, this, isDelta);
			}

			public static Result Deserialize(BufferStream stream, Result instance, bool isDelta)
			{
				while (true)
				{
					int num = stream.ReadByte();
					switch (num)
					{
					case 8:
						instance.ID = ProtocolParser.ReadUInt64(stream);
						continue;
					case 16:
						instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					case 24:
						instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					case -1:
					case 0:
						return instance;
					}
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
			}

			public static Result DeserializeLengthDelimited(BufferStream stream, Result instance, bool isDelta)
			{
				long num = ProtocolParser.ReadUInt32(stream);
				num += stream.Position;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 8:
						instance.ID = ProtocolParser.ReadUInt64(stream);
						continue;
					case 16:
						instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					case 24:
						instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static Result DeserializeLength(BufferStream stream, int length, Result instance, bool isDelta)
			{
				long num = stream.Position + length;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 8:
						instance.ID = ProtocolParser.ReadUInt64(stream);
						continue;
					case 16:
						instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					case 24:
						instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static void SerializeDelta(BufferStream stream, Result instance, Result previous)
			{
				if (instance.ID != previous.ID)
				{
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, instance.ID);
				}
				if (instance.winnings != previous.winnings)
				{
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
				}
				if (instance.resultCode != previous.resultCode)
				{
					stream.WriteByte(24);
					ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
				}
			}

			public static void Serialize(BufferStream stream, Result instance)
			{
				if (instance.ID != 0L)
				{
					stream.WriteByte(8);
					ProtocolParser.WriteUInt64(stream, instance.ID);
				}
				if (instance.winnings != 0)
				{
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
				}
				if (instance.resultCode != 0)
				{
					stream.WriteByte(24);
					ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
				}
			}

			public void ToProto(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public void InspectUids(UidInspector<ulong> action)
			{
			}
		}

		[NonSerialized]
		public List<Result> results;

		[NonSerialized]
		public int winningScore;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(RoundResults instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.results != null)
			{
				for (int i = 0; i < instance.results.Count; i++)
				{
					if (instance.results[i] != null)
					{
						instance.results[i].ResetToPool();
						instance.results[i] = null;
					}
				}
				List<Result> list = instance.results;
				Pool.Free<Result>(ref list, false);
				instance.results = list;
			}
			instance.winningScore = 0;
			Pool.Free<RoundResults>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose RoundResults with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(RoundResults instance)
		{
			if (results != null)
			{
				instance.results = Pool.Get<List<Result>>();
				for (int i = 0; i < results.Count; i++)
				{
					Result item = results[i].Copy();
					instance.results.Add(item);
				}
			}
			else
			{
				instance.results = null;
			}
			instance.winningScore = winningScore;
		}

		public RoundResults Copy()
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			CopyTo(roundResults);
			return roundResults;
		}

		public static RoundResults Deserialize(BufferStream stream)
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			Deserialize(stream, roundResults, isDelta: false);
			return roundResults;
		}

		public static RoundResults DeserializeLengthDelimited(BufferStream stream)
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			DeserializeLengthDelimited(stream, roundResults, isDelta: false);
			return roundResults;
		}

		public static RoundResults DeserializeLength(BufferStream stream, int length)
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			DeserializeLength(stream, length, roundResults, isDelta: false);
			return roundResults;
		}

		public static RoundResults Deserialize(byte[] buffer)
		{
			RoundResults roundResults = Pool.Get<RoundResults>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, roundResults, isDelta: false);
			return roundResults;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, RoundResults previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static RoundResults Deserialize(BufferStream stream, RoundResults instance, bool isDelta)
		{
			if (!isDelta && instance.results == null)
			{
				instance.results = Pool.Get<List<Result>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.results.Add(Result.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static RoundResults DeserializeLengthDelimited(BufferStream stream, RoundResults instance, bool isDelta)
		{
			if (!isDelta && instance.results == null)
			{
				instance.results = Pool.Get<List<Result>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.results.Add(Result.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static RoundResults DeserializeLength(BufferStream stream, int length, RoundResults instance, bool isDelta)
		{
			if (!isDelta && instance.results == null)
			{
				instance.results = Pool.Get<List<Result>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.results.Add(Result.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, RoundResults instance, RoundResults previous)
		{
			if (instance.results != null)
			{
				for (int i = 0; i < instance.results.Count; i++)
				{
					Result result = instance.results[i];
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Result.SerializeDelta(stream, result, result);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field results (ProtoBuf.CardGame.RoundResults.Result)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.winningScore != previous.winningScore)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.winningScore);
			}
		}

		public static void Serialize(BufferStream stream, RoundResults instance)
		{
			if (instance.results != null)
			{
				for (int i = 0; i < instance.results.Count; i++)
				{
					Result instance2 = instance.results[i];
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Result.Serialize(stream, instance2);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field results (ProtoBuf.CardGame.RoundResults.Result)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.winningScore != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.winningScore);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (results != null)
			{
				for (int i = 0; i < results.Count; i++)
				{
					results[i]?.InspectUids(action);
				}
			}
		}
	}

	public class TexasHoldEm : IDisposable, IPooled, IProto<TexasHoldEm>, IProto
	{
		[NonSerialized]
		public int dealerIndex;

		[NonSerialized]
		public List<int> communityCards;

		[NonSerialized]
		public int biggestRaiseThisTurn;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(TexasHoldEm instance)
		{
			if (instance.ShouldPool)
			{
				instance.dealerIndex = 0;
				if (instance.communityCards != null)
				{
					List<int> list = instance.communityCards;
					Pool.FreeUnmanaged<int>(ref list);
					instance.communityCards = list;
				}
				instance.biggestRaiseThisTurn = 0;
				Pool.Free<TexasHoldEm>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose TexasHoldEm with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(TexasHoldEm instance)
		{
			instance.dealerIndex = dealerIndex;
			if (communityCards != null)
			{
				instance.communityCards = Pool.Get<List<int>>();
				for (int i = 0; i < communityCards.Count; i++)
				{
					int item = communityCards[i];
					instance.communityCards.Add(item);
				}
			}
			else
			{
				instance.communityCards = null;
			}
			instance.biggestRaiseThisTurn = biggestRaiseThisTurn;
		}

		public TexasHoldEm Copy()
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			CopyTo(texasHoldEm);
			return texasHoldEm;
		}

		public static TexasHoldEm Deserialize(BufferStream stream)
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			Deserialize(stream, texasHoldEm, isDelta: false);
			return texasHoldEm;
		}

		public static TexasHoldEm DeserializeLengthDelimited(BufferStream stream)
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			DeserializeLengthDelimited(stream, texasHoldEm, isDelta: false);
			return texasHoldEm;
		}

		public static TexasHoldEm DeserializeLength(BufferStream stream, int length)
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			DeserializeLength(stream, length, texasHoldEm, isDelta: false);
			return texasHoldEm;
		}

		public static TexasHoldEm Deserialize(byte[] buffer)
		{
			TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, texasHoldEm, isDelta: false);
			return texasHoldEm;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, TexasHoldEm previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static TexasHoldEm Deserialize(BufferStream stream, TexasHoldEm instance, bool isDelta)
		{
			if (!isDelta && instance.communityCards == null)
			{
				instance.communityCards = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static TexasHoldEm DeserializeLengthDelimited(BufferStream stream, TexasHoldEm instance, bool isDelta)
		{
			if (!isDelta && instance.communityCards == null)
			{
				instance.communityCards = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static TexasHoldEm DeserializeLength(BufferStream stream, int length, TexasHoldEm instance, bool isDelta)
		{
			if (!isDelta && instance.communityCards == null)
			{
				instance.communityCards = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, TexasHoldEm instance, TexasHoldEm previous)
		{
			if (instance.dealerIndex != previous.dealerIndex)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.dealerIndex);
			}
			if (instance.communityCards != null)
			{
				for (int i = 0; i < instance.communityCards.Count; i++)
				{
					int num = instance.communityCards[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.biggestRaiseThisTurn != previous.biggestRaiseThisTurn)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.biggestRaiseThisTurn);
			}
		}

		public static void Serialize(BufferStream stream, TexasHoldEm instance)
		{
			if (instance.dealerIndex != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.dealerIndex);
			}
			if (instance.communityCards != null)
			{
				for (int i = 0; i < instance.communityCards.Count; i++)
				{
					int num = instance.communityCards[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.biggestRaiseThisTurn != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.biggestRaiseThisTurn);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<CardPlayer> players;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public int activePlayerIndex;

	[NonSerialized]
	public int pot;

	[NonSerialized]
	public int lastActionId;

	[NonSerialized]
	public ulong lastActionTarget;

	[NonSerialized]
	public int lastActionValue;

	[NonSerialized]
	public NetworkableId potRef;

	[NonSerialized]
	public TexasHoldEm texasHoldEm;

	[NonSerialized]
	public Blackjack blackjack;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CardGame instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.players != null)
		{
			for (int i = 0; i < instance.players.Count; i++)
			{
				if (instance.players[i] != null)
				{
					instance.players[i].ResetToPool();
					instance.players[i] = null;
				}
			}
			List<CardPlayer> list = instance.players;
			Pool.Free<CardPlayer>(ref list, false);
			instance.players = list;
		}
		instance.state = 0;
		instance.activePlayerIndex = 0;
		instance.pot = 0;
		instance.lastActionId = 0;
		instance.lastActionTarget = 0uL;
		instance.lastActionValue = 0;
		instance.potRef = default(NetworkableId);
		if (instance.texasHoldEm != null)
		{
			instance.texasHoldEm.ResetToPool();
			instance.texasHoldEm = null;
		}
		if (instance.blackjack != null)
		{
			instance.blackjack.ResetToPool();
			instance.blackjack = null;
		}
		Pool.Free<CardGame>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CardGame with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CardGame instance)
	{
		if (players != null)
		{
			instance.players = Pool.Get<List<CardPlayer>>();
			for (int i = 0; i < players.Count; i++)
			{
				CardPlayer item = players[i].Copy();
				instance.players.Add(item);
			}
		}
		else
		{
			instance.players = null;
		}
		instance.state = state;
		instance.activePlayerIndex = activePlayerIndex;
		instance.pot = pot;
		instance.lastActionId = lastActionId;
		instance.lastActionTarget = lastActionTarget;
		instance.lastActionValue = lastActionValue;
		instance.potRef = potRef;
		if (texasHoldEm != null)
		{
			if (instance.texasHoldEm == null)
			{
				instance.texasHoldEm = texasHoldEm.Copy();
			}
			else
			{
				texasHoldEm.CopyTo(instance.texasHoldEm);
			}
		}
		else
		{
			instance.texasHoldEm = null;
		}
		if (blackjack != null)
		{
			if (instance.blackjack == null)
			{
				instance.blackjack = blackjack.Copy();
			}
			else
			{
				blackjack.CopyTo(instance.blackjack);
			}
		}
		else
		{
			instance.blackjack = null;
		}
	}

	public CardGame Copy()
	{
		CardGame cardGame = Pool.Get<CardGame>();
		CopyTo(cardGame);
		return cardGame;
	}

	public static CardGame Deserialize(BufferStream stream)
	{
		CardGame cardGame = Pool.Get<CardGame>();
		Deserialize(stream, cardGame, isDelta: false);
		return cardGame;
	}

	public static CardGame DeserializeLengthDelimited(BufferStream stream)
	{
		CardGame cardGame = Pool.Get<CardGame>();
		DeserializeLengthDelimited(stream, cardGame, isDelta: false);
		return cardGame;
	}

	public static CardGame DeserializeLength(BufferStream stream, int length)
	{
		CardGame cardGame = Pool.Get<CardGame>();
		DeserializeLength(stream, length, cardGame, isDelta: false);
		return cardGame;
	}

	public static CardGame Deserialize(byte[] buffer)
	{
		CardGame cardGame = Pool.Get<CardGame>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cardGame, isDelta: false);
		return cardGame;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CardGame previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CardGame Deserialize(BufferStream stream, CardGame instance, bool isDelta)
	{
		if (!isDelta && instance.players == null)
		{
			instance.players = Pool.Get<List<CardPlayer>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.players.Add(CardPlayer.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.activePlayerIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.pot = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.lastActionId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.lastActionTarget = ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.lastActionValue = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 64:
				instance.potRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 74:
				if (instance.texasHoldEm == null)
				{
					instance.texasHoldEm = TexasHoldEm.DeserializeLengthDelimited(stream);
				}
				else
				{
					TexasHoldEm.DeserializeLengthDelimited(stream, instance.texasHoldEm, isDelta);
				}
				break;
			case 82:
				if (instance.blackjack == null)
				{
					instance.blackjack = Blackjack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Blackjack.DeserializeLengthDelimited(stream, instance.blackjack, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static CardGame DeserializeLengthDelimited(BufferStream stream, CardGame instance, bool isDelta)
	{
		if (!isDelta && instance.players == null)
		{
			instance.players = Pool.Get<List<CardPlayer>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.players.Add(CardPlayer.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.activePlayerIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.pot = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.lastActionId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.lastActionTarget = ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.lastActionValue = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 64:
				instance.potRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 74:
				if (instance.texasHoldEm == null)
				{
					instance.texasHoldEm = TexasHoldEm.DeserializeLengthDelimited(stream);
				}
				else
				{
					TexasHoldEm.DeserializeLengthDelimited(stream, instance.texasHoldEm, isDelta);
				}
				break;
			case 82:
				if (instance.blackjack == null)
				{
					instance.blackjack = Blackjack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Blackjack.DeserializeLengthDelimited(stream, instance.blackjack, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CardGame DeserializeLength(BufferStream stream, int length, CardGame instance, bool isDelta)
	{
		if (!isDelta && instance.players == null)
		{
			instance.players = Pool.Get<List<CardPlayer>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.players.Add(CardPlayer.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.activePlayerIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.pot = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.lastActionId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 48:
				instance.lastActionTarget = ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.lastActionValue = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 64:
				instance.potRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 74:
				if (instance.texasHoldEm == null)
				{
					instance.texasHoldEm = TexasHoldEm.DeserializeLengthDelimited(stream);
				}
				else
				{
					TexasHoldEm.DeserializeLengthDelimited(stream, instance.texasHoldEm, isDelta);
				}
				break;
			case 82:
				if (instance.blackjack == null)
				{
					instance.blackjack = Blackjack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Blackjack.DeserializeLengthDelimited(stream, instance.blackjack, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CardGame instance, CardGame previous)
	{
		if (instance.players != null)
		{
			for (int i = 0; i < instance.players.Count; i++)
			{
				CardPlayer cardPlayer = instance.players[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				CardPlayer.SerializeDelta(stream, cardPlayer, cardPlayer);
				int num = stream.Position - position;
				if (num > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.CardPlayer)");
				}
				Span<byte> span = range.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
				if (num2 < 3)
				{
					span[num2 - 1] |= 128;
					while (num2 < 2)
					{
						span[num2++] = 128;
					}
					span[2] = 0;
				}
			}
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.activePlayerIndex != previous.activePlayerIndex)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.activePlayerIndex);
		}
		if (instance.pot != previous.pot)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.pot);
		}
		if (instance.lastActionId != previous.lastActionId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastActionId);
		}
		if (instance.lastActionTarget != previous.lastActionTarget)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.lastActionTarget);
		}
		if (instance.lastActionValue != previous.lastActionValue)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastActionValue);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.potRef.Value);
		if (instance.texasHoldEm != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(3);
			int position2 = stream.Position;
			TexasHoldEm.SerializeDelta(stream, instance.texasHoldEm, previous.texasHoldEm);
			int num3 = stream.Position - position2;
			if (num3 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field texasHoldEm (ProtoBuf.CardGame.TexasHoldEm)");
			}
			Span<byte> span2 = range2.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)num3, span2, 0);
			if (num4 < 3)
			{
				span2[num4 - 1] |= 128;
				while (num4 < 2)
				{
					span2[num4++] = 128;
				}
				span2[2] = 0;
			}
		}
		if (instance.blackjack == null)
		{
			return;
		}
		stream.WriteByte(82);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		Blackjack.SerializeDelta(stream, instance.blackjack, previous.blackjack);
		int num5 = stream.Position - position3;
		if (num5 > int.MaxValue)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field blackjack (ProtoBuf.CardGame.Blackjack)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num6 = ProtocolParser.WriteUInt32((uint)num5, span3, 0);
		if (num6 < 5)
		{
			span3[num6 - 1] |= 128;
			while (num6 < 4)
			{
				span3[num6++] = 128;
			}
			span3[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, CardGame instance)
	{
		if (instance.players != null)
		{
			for (int i = 0; i < instance.players.Count; i++)
			{
				CardPlayer instance2 = instance.players[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				CardPlayer.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.CardPlayer)");
				}
				Span<byte> span = range.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
				if (num2 < 3)
				{
					span[num2 - 1] |= 128;
					while (num2 < 2)
					{
						span[num2++] = 128;
					}
					span[2] = 0;
				}
			}
		}
		if (instance.state != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.activePlayerIndex != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.activePlayerIndex);
		}
		if (instance.pot != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.pot);
		}
		if (instance.lastActionId != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastActionId);
		}
		if (instance.lastActionTarget != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.lastActionTarget);
		}
		if (instance.lastActionValue != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastActionValue);
		}
		if (instance.potRef != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.potRef.Value);
		}
		if (instance.texasHoldEm != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(3);
			int position2 = stream.Position;
			TexasHoldEm.Serialize(stream, instance.texasHoldEm);
			int num3 = stream.Position - position2;
			if (num3 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field texasHoldEm (ProtoBuf.CardGame.TexasHoldEm)");
			}
			Span<byte> span2 = range2.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)num3, span2, 0);
			if (num4 < 3)
			{
				span2[num4 - 1] |= 128;
				while (num4 < 2)
				{
					span2[num4++] = 128;
				}
				span2[2] = 0;
			}
		}
		if (instance.blackjack == null)
		{
			return;
		}
		stream.WriteByte(82);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		Blackjack.Serialize(stream, instance.blackjack);
		int num5 = stream.Position - position3;
		if (num5 > int.MaxValue)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field blackjack (ProtoBuf.CardGame.Blackjack)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num6 = ProtocolParser.WriteUInt32((uint)num5, span3, 0);
		if (num6 < 5)
		{
			span3[num6 - 1] |= 128;
			while (num6 < 4)
			{
				span3[num6++] = 128;
			}
			span3[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (players != null)
		{
			for (int i = 0; i < players.Count; i++)
			{
				players[i]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref potRef.Value);
		texasHoldEm?.InspectUids(action);
		blackjack?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class CargoPlane : IDisposable, IPooled, IProto<CargoPlane>, IProto
{
	[NonSerialized]
	public Vector3 startPos;

	[NonSerialized]
	public Vector3 endPos;

	[NonSerialized]
	public float secondsToTake;

	[NonSerialized]
	public float secondsTaken;

	[NonSerialized]
	public bool dropped;

	[NonSerialized]
	public Vector3 dropPosition;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CargoPlane instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.startPos = default(Vector3);
			instance.endPos = default(Vector3);
			instance.secondsToTake = 0f;
			instance.secondsTaken = 0f;
			instance.dropped = false;
			instance.dropPosition = default(Vector3);
			Pool.Free<CargoPlane>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CargoPlane with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CargoPlane instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		instance.startPos = startPos;
		instance.endPos = endPos;
		instance.secondsToTake = secondsToTake;
		instance.secondsTaken = secondsTaken;
		instance.dropped = dropped;
		instance.dropPosition = dropPosition;
	}

	public CargoPlane Copy()
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		CopyTo(cargoPlane);
		return cargoPlane;
	}

	public static CargoPlane Deserialize(BufferStream stream)
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		Deserialize(stream, cargoPlane, isDelta: false);
		return cargoPlane;
	}

	public static CargoPlane DeserializeLengthDelimited(BufferStream stream)
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		DeserializeLengthDelimited(stream, cargoPlane, isDelta: false);
		return cargoPlane;
	}

	public static CargoPlane DeserializeLength(BufferStream stream, int length)
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		DeserializeLength(stream, length, cargoPlane, isDelta: false);
		return cargoPlane;
	}

	public static CargoPlane Deserialize(byte[] buffer)
	{
		CargoPlane cargoPlane = Pool.Get<CargoPlane>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cargoPlane, isDelta: false);
		return cargoPlane;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CargoPlane previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CargoPlane Deserialize(BufferStream stream, CargoPlane instance, bool isDelta)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPos, isDelta);
				continue;
			case 29:
				instance.secondsToTake = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.secondsTaken = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.dropped = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.dropPosition, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CargoPlane DeserializeLengthDelimited(BufferStream stream, CargoPlane instance, bool isDelta)
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPos, isDelta);
				continue;
			case 29:
				instance.secondsToTake = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.secondsTaken = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.dropped = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.dropPosition, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CargoPlane DeserializeLength(BufferStream stream, int length, CargoPlane instance, bool isDelta)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPos, isDelta);
				continue;
			case 29:
				instance.secondsToTake = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.secondsTaken = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.dropped = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.dropPosition, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CargoPlane instance, CargoPlane previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		if (instance.startPos != previous.startPos)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.startPos, previous.startPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.endPos != previous.endPos)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.endPos, previous.endPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field endPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.secondsToTake != previous.secondsToTake)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.secondsToTake);
		}
		if (instance.secondsTaken != previous.secondsTaken)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.secondsTaken);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.dropped);
		if (instance.dropPosition != previous.dropPosition)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.dropPosition, previous.dropPosition);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field dropPosition (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public static void Serialize(BufferStream stream, CargoPlane instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		if (instance.startPos != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.startPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.endPos != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.endPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field endPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.secondsToTake != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.secondsToTake);
		}
		if (instance.secondsTaken != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.secondsTaken);
		}
		if (instance.dropped)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.dropped);
		}
		if (instance.dropPosition != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.dropPosition);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field dropPosition (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CargoShip : IDisposable, IPooled, IProto<CargoShip>, IProto
{
	[NonSerialized]
	public int currentHarborApproachNode;

	[NonSerialized]
	public bool isDoingHarborApproach;

	[NonSerialized]
	public bool shouldLookAhead;

	[NonSerialized]
	public bool isEgressing;

	[NonSerialized]
	public uint layout;

	[NonSerialized]
	public List<ulong> playerIds;

	[NonSerialized]
	public int dockCount;

	[NonSerialized]
	public float lifetime;

	[NonSerialized]
	public int harborIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CargoShip instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentHarborApproachNode = 0;
			instance.isDoingHarborApproach = false;
			instance.shouldLookAhead = false;
			instance.isEgressing = false;
			instance.layout = 0u;
			if (instance.playerIds != null)
			{
				List<ulong> list = instance.playerIds;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.playerIds = list;
			}
			instance.dockCount = 0;
			instance.lifetime = 0f;
			instance.harborIndex = 0;
			Pool.Free<CargoShip>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CargoShip with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CargoShip instance)
	{
		instance.currentHarborApproachNode = currentHarborApproachNode;
		instance.isDoingHarborApproach = isDoingHarborApproach;
		instance.shouldLookAhead = shouldLookAhead;
		instance.isEgressing = isEgressing;
		instance.layout = layout;
		if (playerIds != null)
		{
			instance.playerIds = Pool.Get<List<ulong>>();
			for (int i = 0; i < playerIds.Count; i++)
			{
				ulong item = playerIds[i];
				instance.playerIds.Add(item);
			}
		}
		else
		{
			instance.playerIds = null;
		}
		instance.dockCount = dockCount;
		instance.lifetime = lifetime;
		instance.harborIndex = harborIndex;
	}

	public CargoShip Copy()
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		CopyTo(cargoShip);
		return cargoShip;
	}

	public static CargoShip Deserialize(BufferStream stream)
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		Deserialize(stream, cargoShip, isDelta: false);
		return cargoShip;
	}

	public static CargoShip DeserializeLengthDelimited(BufferStream stream)
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		DeserializeLengthDelimited(stream, cargoShip, isDelta: false);
		return cargoShip;
	}

	public static CargoShip DeserializeLength(BufferStream stream, int length)
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		DeserializeLength(stream, length, cargoShip, isDelta: false);
		return cargoShip;
	}

	public static CargoShip Deserialize(byte[] buffer)
	{
		CargoShip cargoShip = Pool.Get<CargoShip>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cargoShip, isDelta: false);
		return cargoShip;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CargoShip previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CargoShip Deserialize(BufferStream stream, CargoShip instance, bool isDelta)
	{
		if (!isDelta && instance.playerIds == null)
		{
			instance.playerIds = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.currentHarborApproachNode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isDoingHarborApproach = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.shouldLookAhead = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.isEgressing = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.layout = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.playerIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.dockCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.harborIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CargoShip DeserializeLengthDelimited(BufferStream stream, CargoShip instance, bool isDelta)
	{
		if (!isDelta && instance.playerIds == null)
		{
			instance.playerIds = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentHarborApproachNode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isDoingHarborApproach = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.shouldLookAhead = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.isEgressing = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.layout = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.playerIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.dockCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.harborIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CargoShip DeserializeLength(BufferStream stream, int length, CargoShip instance, bool isDelta)
	{
		if (!isDelta && instance.playerIds == null)
		{
			instance.playerIds = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.currentHarborApproachNode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isDoingHarborApproach = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.shouldLookAhead = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.isEgressing = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.layout = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.playerIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.dockCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 77:
				instance.lifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.harborIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CargoShip instance, CargoShip previous)
	{
		if (instance.currentHarborApproachNode != previous.currentHarborApproachNode)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentHarborApproachNode);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.isDoingHarborApproach);
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.shouldLookAhead);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.isEgressing);
		if (instance.layout != previous.layout)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.layout);
		}
		if (instance.playerIds != null)
		{
			for (int i = 0; i < instance.playerIds.Count; i++)
			{
				ulong val = instance.playerIds[i];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.dockCount != previous.dockCount)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dockCount);
		}
		if (instance.lifetime != previous.lifetime)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lifetime);
		}
		if (instance.harborIndex != previous.harborIndex)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.harborIndex);
		}
	}

	public static void Serialize(BufferStream stream, CargoShip instance)
	{
		if (instance.currentHarborApproachNode != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentHarborApproachNode);
		}
		if (instance.isDoingHarborApproach)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.isDoingHarborApproach);
		}
		if (instance.shouldLookAhead)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.shouldLookAhead);
		}
		if (instance.isEgressing)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isEgressing);
		}
		if (instance.layout != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.layout);
		}
		if (instance.playerIds != null)
		{
			for (int i = 0; i < instance.playerIds.Count; i++)
			{
				ulong val = instance.playerIds[i];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.dockCount != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dockCount);
		}
		if (instance.lifetime != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lifetime);
		}
		if (instance.harborIndex != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.harborIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CargoShipContainer : IDisposable, IPooled, IProto<CargoShipContainer>, IProto
{
	[NonSerialized]
	public int dressingVariant;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CargoShipContainer instance)
	{
		if (instance.ShouldPool)
		{
			instance.dressingVariant = 0;
			Pool.Free<CargoShipContainer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CargoShipContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CargoShipContainer instance)
	{
		instance.dressingVariant = dressingVariant;
	}

	public CargoShipContainer Copy()
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		CopyTo(cargoShipContainer);
		return cargoShipContainer;
	}

	public static CargoShipContainer Deserialize(BufferStream stream)
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		Deserialize(stream, cargoShipContainer, isDelta: false);
		return cargoShipContainer;
	}

	public static CargoShipContainer DeserializeLengthDelimited(BufferStream stream)
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		DeserializeLengthDelimited(stream, cargoShipContainer, isDelta: false);
		return cargoShipContainer;
	}

	public static CargoShipContainer DeserializeLength(BufferStream stream, int length)
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		DeserializeLength(stream, length, cargoShipContainer, isDelta: false);
		return cargoShipContainer;
	}

	public static CargoShipContainer Deserialize(byte[] buffer)
	{
		CargoShipContainer cargoShipContainer = Pool.Get<CargoShipContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cargoShipContainer, isDelta: false);
		return cargoShipContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CargoShipContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CargoShipContainer Deserialize(BufferStream stream, CargoShipContainer instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.dressingVariant = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CargoShipContainer DeserializeLengthDelimited(BufferStream stream, CargoShipContainer instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dressingVariant = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CargoShipContainer DeserializeLength(BufferStream stream, int length, CargoShipContainer instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dressingVariant = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CargoShipContainer instance, CargoShipContainer previous)
	{
		if (instance.dressingVariant != previous.dressingVariant)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dressingVariant);
		}
	}

	public static void Serialize(BufferStream stream, CargoShipContainer instance)
	{
		if (instance.dressingVariant != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dressingVariant);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Cassette : IDisposable, IPooled, IProto<Cassette>, IProto
{
	[NonSerialized]
	public uint audioId;

	[NonSerialized]
	public NetworkableId holder;

	[NonSerialized]
	public ulong creatorSteamId;

	[NonSerialized]
	public int preloadAudioId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Cassette instance)
	{
		if (instance.ShouldPool)
		{
			instance.audioId = 0u;
			instance.holder = default(NetworkableId);
			instance.creatorSteamId = 0uL;
			instance.preloadAudioId = 0;
			Pool.Free<Cassette>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Cassette with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Cassette instance)
	{
		instance.audioId = audioId;
		instance.holder = holder;
		instance.creatorSteamId = creatorSteamId;
		instance.preloadAudioId = preloadAudioId;
	}

	public Cassette Copy()
	{
		Cassette cassette = Pool.Get<Cassette>();
		CopyTo(cassette);
		return cassette;
	}

	public static Cassette Deserialize(BufferStream stream)
	{
		Cassette cassette = Pool.Get<Cassette>();
		Deserialize(stream, cassette, isDelta: false);
		return cassette;
	}

	public static Cassette DeserializeLengthDelimited(BufferStream stream)
	{
		Cassette cassette = Pool.Get<Cassette>();
		DeserializeLengthDelimited(stream, cassette, isDelta: false);
		return cassette;
	}

	public static Cassette DeserializeLength(BufferStream stream, int length)
	{
		Cassette cassette = Pool.Get<Cassette>();
		DeserializeLength(stream, length, cassette, isDelta: false);
		return cassette;
	}

	public static Cassette Deserialize(byte[] buffer)
	{
		Cassette cassette = Pool.Get<Cassette>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cassette, isDelta: false);
		return cassette;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Cassette previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Cassette Deserialize(BufferStream stream, Cassette instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 24:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.holder = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.creatorSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.preloadAudioId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Cassette DeserializeLengthDelimited(BufferStream stream, Cassette instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.holder = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.creatorSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.preloadAudioId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Cassette DeserializeLength(BufferStream stream, int length, Cassette instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.holder = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.creatorSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.preloadAudioId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Cassette instance, Cassette previous)
	{
		if (instance.audioId != previous.audioId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.audioId);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.holder.Value);
		if (instance.creatorSteamId != previous.creatorSteamId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.creatorSteamId);
		}
		if (instance.preloadAudioId != previous.preloadAudioId)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.preloadAudioId);
		}
	}

	public static void Serialize(BufferStream stream, Cassette instance)
	{
		if (instance.audioId != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.audioId);
		}
		if (instance.holder != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.holder.Value);
		}
		if (instance.creatorSteamId != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.creatorSteamId);
		}
		if (instance.preloadAudioId != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.preloadAudioId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref holder.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Catapult : IDisposable, IPooled, IProto<Catapult>, IProto
{
	[NonSerialized]
	public NetworkableId ammoStorageID;

	[NonSerialized]
	public float reloadProgress;

	[NonSerialized]
	public int ammoType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Catapult instance)
	{
		if (instance.ShouldPool)
		{
			instance.ammoStorageID = default(NetworkableId);
			instance.reloadProgress = 0f;
			instance.ammoType = 0;
			Pool.Free<Catapult>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Catapult with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Catapult instance)
	{
		instance.ammoStorageID = ammoStorageID;
		instance.reloadProgress = reloadProgress;
		instance.ammoType = ammoType;
	}

	public Catapult Copy()
	{
		Catapult catapult = Pool.Get<Catapult>();
		CopyTo(catapult);
		return catapult;
	}

	public static Catapult Deserialize(BufferStream stream)
	{
		Catapult catapult = Pool.Get<Catapult>();
		Deserialize(stream, catapult, isDelta: false);
		return catapult;
	}

	public static Catapult DeserializeLengthDelimited(BufferStream stream)
	{
		Catapult catapult = Pool.Get<Catapult>();
		DeserializeLengthDelimited(stream, catapult, isDelta: false);
		return catapult;
	}

	public static Catapult DeserializeLength(BufferStream stream, int length)
	{
		Catapult catapult = Pool.Get<Catapult>();
		DeserializeLength(stream, length, catapult, isDelta: false);
		return catapult;
	}

	public static Catapult Deserialize(byte[] buffer)
	{
		Catapult catapult = Pool.Get<Catapult>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, catapult, isDelta: false);
		return catapult;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Catapult previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Catapult Deserialize(BufferStream stream, Catapult instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.ammoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Catapult DeserializeLengthDelimited(BufferStream stream, Catapult instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Catapult DeserializeLength(BufferStream stream, int length, Catapult instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.reloadProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Catapult instance, Catapult previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.ammoStorageID.Value);
		if (instance.reloadProgress != previous.reloadProgress)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.reloadProgress);
		}
		if (instance.ammoType != previous.ammoType)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
	}

	public static void Serialize(BufferStream stream, Catapult instance)
	{
		if (instance.ammoStorageID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.ammoStorageID.Value);
		}
		if (instance.reloadProgress != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.reloadProgress);
		}
		if (instance.ammoType != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref ammoStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ChanceAIEventData : IDisposable, IPooled, IProto<ChanceAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ChanceAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<ChanceAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ChanceAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ChanceAIEventData instance)
	{
		instance.value = value;
	}

	public ChanceAIEventData Copy()
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		CopyTo(chanceAIEventData);
		return chanceAIEventData;
	}

	public static ChanceAIEventData Deserialize(BufferStream stream)
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		Deserialize(stream, chanceAIEventData, isDelta: false);
		return chanceAIEventData;
	}

	public static ChanceAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		DeserializeLengthDelimited(stream, chanceAIEventData, isDelta: false);
		return chanceAIEventData;
	}

	public static ChanceAIEventData DeserializeLength(BufferStream stream, int length)
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		DeserializeLength(stream, length, chanceAIEventData, isDelta: false);
		return chanceAIEventData;
	}

	public static ChanceAIEventData Deserialize(byte[] buffer)
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, chanceAIEventData, isDelta: false);
		return chanceAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ChanceAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ChanceAIEventData Deserialize(BufferStream stream, ChanceAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ChanceAIEventData DeserializeLengthDelimited(BufferStream stream, ChanceAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ChanceAIEventData DeserializeLength(BufferStream stream, int length, ChanceAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ChanceAIEventData instance, ChanceAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, ChanceAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ChickenCoop : IDisposable, IPooled, IProto<ChickenCoop>, IProto
{
	[NonSerialized]
	public List<ChickenStatus> chickens;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ChickenCoop instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.chickens != null)
		{
			for (int i = 0; i < instance.chickens.Count; i++)
			{
				if (instance.chickens[i] != null)
				{
					instance.chickens[i].ResetToPool();
					instance.chickens[i] = null;
				}
			}
			List<ChickenStatus> list = instance.chickens;
			Pool.Free<ChickenStatus>(ref list, false);
			instance.chickens = list;
		}
		Pool.Free<ChickenCoop>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ChickenCoop with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ChickenCoop instance)
	{
		if (chickens != null)
		{
			instance.chickens = Pool.Get<List<ChickenStatus>>();
			for (int i = 0; i < chickens.Count; i++)
			{
				ChickenStatus item = chickens[i].Copy();
				instance.chickens.Add(item);
			}
		}
		else
		{
			instance.chickens = null;
		}
	}

	public ChickenCoop Copy()
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		CopyTo(chickenCoop);
		return chickenCoop;
	}

	public static ChickenCoop Deserialize(BufferStream stream)
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		Deserialize(stream, chickenCoop, isDelta: false);
		return chickenCoop;
	}

	public static ChickenCoop DeserializeLengthDelimited(BufferStream stream)
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		DeserializeLengthDelimited(stream, chickenCoop, isDelta: false);
		return chickenCoop;
	}

	public static ChickenCoop DeserializeLength(BufferStream stream, int length)
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		DeserializeLength(stream, length, chickenCoop, isDelta: false);
		return chickenCoop;
	}

	public static ChickenCoop Deserialize(byte[] buffer)
	{
		ChickenCoop chickenCoop = Pool.Get<ChickenCoop>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, chickenCoop, isDelta: false);
		return chickenCoop;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ChickenCoop previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ChickenCoop Deserialize(BufferStream stream, ChickenCoop instance, bool isDelta)
	{
		if (!isDelta && instance.chickens == null)
		{
			instance.chickens = Pool.Get<List<ChickenStatus>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.chickens.Add(ChickenStatus.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ChickenCoop DeserializeLengthDelimited(BufferStream stream, ChickenCoop instance, bool isDelta)
	{
		if (!isDelta && instance.chickens == null)
		{
			instance.chickens = Pool.Get<List<ChickenStatus>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.chickens.Add(ChickenStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ChickenCoop DeserializeLength(BufferStream stream, int length, ChickenCoop instance, bool isDelta)
	{
		if (!isDelta && instance.chickens == null)
		{
			instance.chickens = Pool.Get<List<ChickenStatus>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.chickens.Add(ChickenStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ChickenCoop instance, ChickenCoop previous)
	{
		if (instance.chickens == null)
		{
			return;
		}
		for (int i = 0; i < instance.chickens.Count; i++)
		{
			ChickenStatus chickenStatus = instance.chickens[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ChickenStatus.SerializeDelta(stream, chickenStatus, chickenStatus);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field chickens (ProtoBuf.ChickenStatus)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ChickenCoop instance)
	{
		if (instance.chickens == null)
		{
			return;
		}
		for (int i = 0; i < instance.chickens.Count; i++)
		{
			ChickenStatus instance2 = instance.chickens[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ChickenStatus.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field chickens (ProtoBuf.ChickenStatus)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (chickens != null)
		{
			for (int i = 0; i < chickens.Count; i++)
			{
				chickens[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ChickenCoopStatusUpdate : IDisposable, IPooled, IProto<ChickenCoopStatusUpdate>, IProto
{
	[NonSerialized]
	public List<FarmableAnimalStatus> animals;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ChickenCoopStatusUpdate instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.animals != null)
		{
			for (int i = 0; i < instance.animals.Count; i++)
			{
				if (instance.animals[i] != null)
				{
					instance.animals[i].ResetToPool();
					instance.animals[i] = null;
				}
			}
			List<FarmableAnimalStatus> list = instance.animals;
			Pool.Free<FarmableAnimalStatus>(ref list, false);
			instance.animals = list;
		}
		Pool.Free<ChickenCoopStatusUpdate>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ChickenCoopStatusUpdate with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ChickenCoopStatusUpdate instance)
	{
		if (animals != null)
		{
			instance.animals = Pool.Get<List<FarmableAnimalStatus>>();
			for (int i = 0; i < animals.Count; i++)
			{
				FarmableAnimalStatus item = animals[i].Copy();
				instance.animals.Add(item);
			}
		}
		else
		{
			instance.animals = null;
		}
	}

	public ChickenCoopStatusUpdate Copy()
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		CopyTo(chickenCoopStatusUpdate);
		return chickenCoopStatusUpdate;
	}

	public static ChickenCoopStatusUpdate Deserialize(BufferStream stream)
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		Deserialize(stream, chickenCoopStatusUpdate, isDelta: false);
		return chickenCoopStatusUpdate;
	}

	public static ChickenCoopStatusUpdate DeserializeLengthDelimited(BufferStream stream)
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		DeserializeLengthDelimited(stream, chickenCoopStatusUpdate, isDelta: false);
		return chickenCoopStatusUpdate;
	}

	public static ChickenCoopStatusUpdate DeserializeLength(BufferStream stream, int length)
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		DeserializeLength(stream, length, chickenCoopStatusUpdate, isDelta: false);
		return chickenCoopStatusUpdate;
	}

	public static ChickenCoopStatusUpdate Deserialize(byte[] buffer)
	{
		ChickenCoopStatusUpdate chickenCoopStatusUpdate = Pool.Get<ChickenCoopStatusUpdate>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, chickenCoopStatusUpdate, isDelta: false);
		return chickenCoopStatusUpdate;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ChickenCoopStatusUpdate previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ChickenCoopStatusUpdate Deserialize(BufferStream stream, ChickenCoopStatusUpdate instance, bool isDelta)
	{
		if (!isDelta && instance.animals == null)
		{
			instance.animals = Pool.Get<List<FarmableAnimalStatus>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.animals.Add(FarmableAnimalStatus.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ChickenCoopStatusUpdate DeserializeLengthDelimited(BufferStream stream, ChickenCoopStatusUpdate instance, bool isDelta)
	{
		if (!isDelta && instance.animals == null)
		{
			instance.animals = Pool.Get<List<FarmableAnimalStatus>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.animals.Add(FarmableAnimalStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ChickenCoopStatusUpdate DeserializeLength(BufferStream stream, int length, ChickenCoopStatusUpdate instance, bool isDelta)
	{
		if (!isDelta && instance.animals == null)
		{
			instance.animals = Pool.Get<List<FarmableAnimalStatus>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.animals.Add(FarmableAnimalStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ChickenCoopStatusUpdate instance, ChickenCoopStatusUpdate previous)
	{
		if (instance.animals == null)
		{
			return;
		}
		for (int i = 0; i < instance.animals.Count; i++)
		{
			FarmableAnimalStatus farmableAnimalStatus = instance.animals[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			FarmableAnimalStatus.SerializeDelta(stream, farmableAnimalStatus, farmableAnimalStatus);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ChickenCoopStatusUpdate instance)
	{
		if (instance.animals == null)
		{
			return;
		}
		for (int i = 0; i < instance.animals.Count; i++)
		{
			FarmableAnimalStatus instance2 = instance.animals[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			FarmableAnimalStatus.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (animals != null)
		{
			for (int i = 0; i < animals.Count; i++)
			{
				animals[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ChickenStatus : IDisposable, IPooled, IProto<ChickenStatus>, IProto
{
	[NonSerialized]
	public NetworkableId spawnedChicken;

	[NonSerialized]
	public float timeUntilHatch;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ChickenStatus instance)
	{
		if (instance.ShouldPool)
		{
			instance.spawnedChicken = default(NetworkableId);
			instance.timeUntilHatch = 0f;
			Pool.Free<ChickenStatus>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ChickenStatus with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ChickenStatus instance)
	{
		instance.spawnedChicken = spawnedChicken;
		instance.timeUntilHatch = timeUntilHatch;
	}

	public ChickenStatus Copy()
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		CopyTo(chickenStatus);
		return chickenStatus;
	}

	public static ChickenStatus Deserialize(BufferStream stream)
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		Deserialize(stream, chickenStatus, isDelta: false);
		return chickenStatus;
	}

	public static ChickenStatus DeserializeLengthDelimited(BufferStream stream)
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		DeserializeLengthDelimited(stream, chickenStatus, isDelta: false);
		return chickenStatus;
	}

	public static ChickenStatus DeserializeLength(BufferStream stream, int length)
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		DeserializeLength(stream, length, chickenStatus, isDelta: false);
		return chickenStatus;
	}

	public static ChickenStatus Deserialize(byte[] buffer)
	{
		ChickenStatus chickenStatus = Pool.Get<ChickenStatus>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, chickenStatus, isDelta: false);
		return chickenStatus;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ChickenStatus previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ChickenStatus Deserialize(BufferStream stream, ChickenStatus instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.spawnedChicken = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeUntilHatch = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ChickenStatus DeserializeLengthDelimited(BufferStream stream, ChickenStatus instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.spawnedChicken = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeUntilHatch = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ChickenStatus DeserializeLength(BufferStream stream, int length, ChickenStatus instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.spawnedChicken = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeUntilHatch = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ChickenStatus instance, ChickenStatus previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.spawnedChicken.Value);
		if (instance.timeUntilHatch != previous.timeUntilHatch)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeUntilHatch);
		}
	}

	public static void Serialize(BufferStream stream, ChickenStatus instance)
	{
		if (instance.spawnedChicken != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.spawnedChicken.Value);
		}
		if (instance.timeUntilHatch != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeUntilHatch);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref spawnedChicken.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CinematicEntity : IDisposable, IPooled, IProto<CinematicEntity>, IProto
{
	[NonSerialized]
	public NetworkableId targetPlayer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CinematicEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.targetPlayer = default(NetworkableId);
			Pool.Free<CinematicEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CinematicEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CinematicEntity instance)
	{
		instance.targetPlayer = targetPlayer;
	}

	public CinematicEntity Copy()
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		CopyTo(cinematicEntity);
		return cinematicEntity;
	}

	public static CinematicEntity Deserialize(BufferStream stream)
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		Deserialize(stream, cinematicEntity, isDelta: false);
		return cinematicEntity;
	}

	public static CinematicEntity DeserializeLengthDelimited(BufferStream stream)
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		DeserializeLengthDelimited(stream, cinematicEntity, isDelta: false);
		return cinematicEntity;
	}

	public static CinematicEntity DeserializeLength(BufferStream stream, int length)
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		DeserializeLength(stream, length, cinematicEntity, isDelta: false);
		return cinematicEntity;
	}

	public static CinematicEntity Deserialize(byte[] buffer)
	{
		CinematicEntity cinematicEntity = Pool.Get<CinematicEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cinematicEntity, isDelta: false);
		return cinematicEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CinematicEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CinematicEntity Deserialize(BufferStream stream, CinematicEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CinematicEntity DeserializeLengthDelimited(BufferStream stream, CinematicEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CinematicEntity DeserializeLength(BufferStream stream, int length, CinematicEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CinematicEntity instance, CinematicEntity previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetPlayer.Value);
	}

	public static void Serialize(BufferStream stream, CinematicEntity instance)
	{
		if (instance.targetPlayer != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetPlayer.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetPlayer.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanActionResult : IDisposable, IPooled, IProto<ClanActionResult>, IProto
{
	[NonSerialized]
	public int requestId;

	[NonSerialized]
	public int result;

	[NonSerialized]
	public bool hasClanInfo;

	[NonSerialized]
	public ClanInfo clanInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanActionResult instance)
	{
		if (instance.ShouldPool)
		{
			instance.requestId = 0;
			instance.result = 0;
			instance.hasClanInfo = false;
			if (instance.clanInfo != null)
			{
				instance.clanInfo.ResetToPool();
				instance.clanInfo = null;
			}
			Pool.Free<ClanActionResult>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanActionResult with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanActionResult instance)
	{
		instance.requestId = requestId;
		instance.result = result;
		instance.hasClanInfo = hasClanInfo;
		if (clanInfo != null)
		{
			if (instance.clanInfo == null)
			{
				instance.clanInfo = clanInfo.Copy();
			}
			else
			{
				clanInfo.CopyTo(instance.clanInfo);
			}
		}
		else
		{
			instance.clanInfo = null;
		}
	}

	public ClanActionResult Copy()
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		CopyTo(instance);
		return instance;
	}

	public static ClanActionResult Deserialize(BufferStream stream)
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		Deserialize(stream, instance, isDelta: false);
		return instance;
	}

	public static ClanActionResult DeserializeLengthDelimited(BufferStream stream)
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		DeserializeLengthDelimited(stream, instance, isDelta: false);
		return instance;
	}

	public static ClanActionResult DeserializeLength(BufferStream stream, int length)
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		DeserializeLength(stream, length, instance, isDelta: false);
		return instance;
	}

	public static ClanActionResult Deserialize(byte[] buffer)
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanActionResult previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanActionResult Deserialize(BufferStream stream, ClanActionResult instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.requestId = 0;
			instance.result = 0;
			instance.hasClanInfo = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.requestId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.result = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.hasClanInfo = ProtocolParser.ReadBool(stream);
				break;
			case 34:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static ClanActionResult DeserializeLengthDelimited(BufferStream stream, ClanActionResult instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.requestId = 0;
			instance.result = 0;
			instance.hasClanInfo = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.requestId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.result = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.hasClanInfo = ProtocolParser.ReadBool(stream);
				break;
			case 34:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanActionResult DeserializeLength(BufferStream stream, int length, ClanActionResult instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.requestId = 0;
			instance.result = 0;
			instance.hasClanInfo = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.requestId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.result = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.hasClanInfo = ProtocolParser.ReadBool(stream);
				break;
			case 34:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanActionResult instance, ClanActionResult previous)
	{
		if (instance.requestId != previous.requestId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.requestId);
		}
		if (instance.result != previous.result)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.result);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.hasClanInfo);
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.SerializeDelta(stream, instance.clanInfo, previous.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, ClanActionResult instance)
	{
		if (instance.requestId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.requestId);
		}
		if (instance.result != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.result);
		}
		if (instance.hasClanInfo)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.hasClanInfo);
		}
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.Serialize(stream, instance.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		clanInfo?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanInfo : IDisposable, IPooled, IProto<ClanInfo>, IProto
{
	public class Invite : IDisposable, IPooled, IProto<Invite>, IProto
	{
		[NonSerialized]
		public ulong steamId;

		[NonSerialized]
		public ulong recruiter;

		[NonSerialized]
		public long timestamp;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Invite instance)
		{
			if (instance.ShouldPool)
			{
				instance.steamId = 0uL;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
				Pool.Free<Invite>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Invite with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Invite instance)
		{
			instance.steamId = steamId;
			instance.recruiter = recruiter;
			instance.timestamp = timestamp;
		}

		public Invite Copy()
		{
			Invite invite = Pool.Get<Invite>();
			CopyTo(invite);
			return invite;
		}

		public static Invite Deserialize(BufferStream stream)
		{
			Invite invite = Pool.Get<Invite>();
			Deserialize(stream, invite, isDelta: false);
			return invite;
		}

		public static Invite DeserializeLengthDelimited(BufferStream stream)
		{
			Invite invite = Pool.Get<Invite>();
			DeserializeLengthDelimited(stream, invite, isDelta: false);
			return invite;
		}

		public static Invite DeserializeLength(BufferStream stream, int length)
		{
			Invite invite = Pool.Get<Invite>();
			DeserializeLength(stream, length, invite, isDelta: false);
			return invite;
		}

		public static Invite Deserialize(byte[] buffer)
		{
			Invite invite = Pool.Get<Invite>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, invite, isDelta: false);
			return invite;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Invite previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Invite Deserialize(BufferStream stream, Invite instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Invite DeserializeLengthDelimited(BufferStream stream, Invite instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Invite DeserializeLength(BufferStream stream, int length, Invite instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Invite instance, Invite previous)
		{
			if (instance.steamId != previous.steamId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.recruiter != previous.recruiter)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.recruiter);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}

		public static void Serialize(BufferStream stream, Invite instance)
		{
			if (instance.steamId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.recruiter != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.recruiter);
			}
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class Member : IDisposable, IPooled, IProto<Member>, IProto
	{
		[NonSerialized]
		public ulong steamId;

		[NonSerialized]
		public int roleId;

		[NonSerialized]
		public long joined;

		[NonSerialized]
		public long lastSeen;

		[NonSerialized]
		public string notes;

		[NonSerialized]
		public bool online;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Member instance)
		{
			if (instance.ShouldPool)
			{
				instance.steamId = 0uL;
				instance.roleId = 0;
				instance.joined = 0L;
				instance.lastSeen = 0L;
				instance.notes = string.Empty;
				instance.online = false;
				Pool.Free<Member>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Member with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Member instance)
		{
			instance.steamId = steamId;
			instance.roleId = roleId;
			instance.joined = joined;
			instance.lastSeen = lastSeen;
			instance.notes = notes;
			instance.online = online;
		}

		public Member Copy()
		{
			Member member = Pool.Get<Member>();
			CopyTo(member);
			return member;
		}

		public static Member Deserialize(BufferStream stream)
		{
			Member member = Pool.Get<Member>();
			Deserialize(stream, member, isDelta: false);
			return member;
		}

		public static Member DeserializeLengthDelimited(BufferStream stream)
		{
			Member member = Pool.Get<Member>();
			DeserializeLengthDelimited(stream, member, isDelta: false);
			return member;
		}

		public static Member DeserializeLength(BufferStream stream, int length)
		{
			Member member = Pool.Get<Member>();
			DeserializeLength(stream, length, member, isDelta: false);
			return member;
		}

		public static Member Deserialize(byte[] buffer)
		{
			Member member = Pool.Get<Member>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, member, isDelta: false);
			return member;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Member previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Member Deserialize(BufferStream stream, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.roleId = 0;
				instance.joined = 0L;
				instance.lastSeen = 0L;
				instance.online = false;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.joined = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 42:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 48:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Member DeserializeLengthDelimited(BufferStream stream, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.roleId = 0;
				instance.joined = 0L;
				instance.lastSeen = 0L;
				instance.online = false;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.joined = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 42:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 48:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Member DeserializeLength(BufferStream stream, int length, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.roleId = 0;
				instance.joined = 0L;
				instance.lastSeen = 0L;
				instance.online = false;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.joined = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 42:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 48:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Member instance, Member previous)
		{
			if (instance.steamId != previous.steamId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.roleId != previous.roleId)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
			if (instance.notes != null && instance.notes != previous.notes)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.notes);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.online);
		}

		public static void Serialize(BufferStream stream, Member instance)
		{
			if (instance.steamId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.roleId != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
			}
			if (instance.joined != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
			}
			if (instance.lastSeen != 0L)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
			}
			if (instance.notes != null)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.notes);
			}
			if (instance.online)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.online);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class Role : IDisposable, IPooled, IProto<Role>, IProto
	{
		[NonSerialized]
		public int roleId;

		[NonSerialized]
		public int rank;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public bool canSetMotd;

		[NonSerialized]
		public bool canSetLogo;

		[NonSerialized]
		public bool canInvite;

		[NonSerialized]
		public bool canKick;

		[NonSerialized]
		public bool canPromote;

		[NonSerialized]
		public bool canDemote;

		[NonSerialized]
		public bool canSetPlayerNotes;

		[NonSerialized]
		public bool canAccessLogs;

		[NonSerialized]
		public bool canAccessScoreEvents;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Role instance)
		{
			if (instance.ShouldPool)
			{
				instance.roleId = 0;
				instance.rank = 0;
				instance.name = string.Empty;
				instance.canSetMotd = false;
				instance.canSetLogo = false;
				instance.canInvite = false;
				instance.canKick = false;
				instance.canPromote = false;
				instance.canDemote = false;
				instance.canSetPlayerNotes = false;
				instance.canAccessLogs = false;
				instance.canAccessScoreEvents = false;
				Pool.Free<Role>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Role with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Role instance)
		{
			instance.roleId = roleId;
			instance.rank = rank;
			instance.name = name;
			instance.canSetMotd = canSetMotd;
			instance.canSetLogo = canSetLogo;
			instance.canInvite = canInvite;
			instance.canKick = canKick;
			instance.canPromote = canPromote;
			instance.canDemote = canDemote;
			instance.canSetPlayerNotes = canSetPlayerNotes;
			instance.canAccessLogs = canAccessLogs;
			instance.canAccessScoreEvents = canAccessScoreEvents;
		}

		public Role Copy()
		{
			Role role = Pool.Get<Role>();
			CopyTo(role);
			return role;
		}

		public static Role Deserialize(BufferStream stream)
		{
			Role role = Pool.Get<Role>();
			Deserialize(stream, role, isDelta: false);
			return role;
		}

		public static Role DeserializeLengthDelimited(BufferStream stream)
		{
			Role role = Pool.Get<Role>();
			DeserializeLengthDelimited(stream, role, isDelta: false);
			return role;
		}

		public static Role DeserializeLength(BufferStream stream, int length)
		{
			Role role = Pool.Get<Role>();
			DeserializeLength(stream, length, role, isDelta: false);
			return role;
		}

		public static Role Deserialize(byte[] buffer)
		{
			Role role = Pool.Get<Role>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, role, isDelta: false);
			return role;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Role previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Role Deserialize(BufferStream stream, Role instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.roleId = 0;
				instance.rank = 0;
				instance.canSetMotd = false;
				instance.canSetLogo = false;
				instance.canInvite = false;
				instance.canKick = false;
				instance.canPromote = false;
				instance.canDemote = false;
				instance.canSetPlayerNotes = false;
				instance.canAccessLogs = false;
				instance.canAccessScoreEvents = false;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.rank = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 32:
					instance.canSetMotd = ProtocolParser.ReadBool(stream);
					continue;
				case 40:
					instance.canSetLogo = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.canInvite = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.canKick = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.canPromote = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.canDemote = ProtocolParser.ReadBool(stream);
					continue;
				case 80:
					instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
					continue;
				case 88:
					instance.canAccessLogs = ProtocolParser.ReadBool(stream);
					continue;
				case 96:
					instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Role DeserializeLengthDelimited(BufferStream stream, Role instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.roleId = 0;
				instance.rank = 0;
				instance.canSetMotd = false;
				instance.canSetLogo = false;
				instance.canInvite = false;
				instance.canKick = false;
				instance.canPromote = false;
				instance.canDemote = false;
				instance.canSetPlayerNotes = false;
				instance.canAccessLogs = false;
				instance.canAccessScoreEvents = false;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.rank = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 32:
					instance.canSetMotd = ProtocolParser.ReadBool(stream);
					continue;
				case 40:
					instance.canSetLogo = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.canInvite = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.canKick = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.canPromote = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.canDemote = ProtocolParser.ReadBool(stream);
					continue;
				case 80:
					instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
					continue;
				case 88:
					instance.canAccessLogs = ProtocolParser.ReadBool(stream);
					continue;
				case 96:
					instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Role DeserializeLength(BufferStream stream, int length, Role instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.roleId = 0;
				instance.rank = 0;
				instance.canSetMotd = false;
				instance.canSetLogo = false;
				instance.canInvite = false;
				instance.canKick = false;
				instance.canPromote = false;
				instance.canDemote = false;
				instance.canSetPlayerNotes = false;
				instance.canAccessLogs = false;
				instance.canAccessScoreEvents = false;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.rank = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 32:
					instance.canSetMotd = ProtocolParser.ReadBool(stream);
					continue;
				case 40:
					instance.canSetLogo = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.canInvite = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.canKick = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.canPromote = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.canDemote = ProtocolParser.ReadBool(stream);
					continue;
				case 80:
					instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
					continue;
				case 88:
					instance.canAccessLogs = ProtocolParser.ReadBool(stream);
					continue;
				case 96:
					instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Role instance, Role previous)
		{
			if (instance.roleId != previous.roleId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
			}
			if (instance.rank != previous.rank)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.name);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.canSetMotd);
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.canSetLogo);
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.canInvite);
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.canKick);
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.canPromote);
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.canDemote);
			stream.WriteByte(80);
			ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
			stream.WriteByte(88);
			ProtocolParser.WriteBool(stream, instance.canAccessLogs);
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
		}

		public static void Serialize(BufferStream stream, Role instance)
		{
			if (instance.roleId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
			}
			if (instance.rank != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.canSetMotd)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteBool(stream, instance.canSetMotd);
			}
			if (instance.canSetLogo)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.canSetLogo);
			}
			if (instance.canInvite)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.canInvite);
			}
			if (instance.canKick)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.canKick);
			}
			if (instance.canPromote)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteBool(stream, instance.canPromote);
			}
			if (instance.canDemote)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteBool(stream, instance.canDemote);
			}
			if (instance.canSetPlayerNotes)
			{
				stream.WriteByte(80);
				ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
			}
			if (instance.canAccessLogs)
			{
				stream.WriteByte(88);
				ProtocolParser.WriteBool(stream, instance.canAccessLogs);
			}
			if (instance.canAccessScoreEvents)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public long created;

	[NonSerialized]
	public ulong creator;

	[NonSerialized]
	public string motd;

	[NonSerialized]
	public long motdTimestamp;

	[NonSerialized]
	public ulong motdAuthor;

	[NonSerialized]
	public byte[] logo;

	[NonSerialized]
	public int color;

	[NonSerialized]
	public List<Role> roles;

	[NonSerialized]
	public List<Member> members;

	[NonSerialized]
	public List<Invite> invites;

	[NonSerialized]
	public int maxMemberCount;

	[NonSerialized]
	public long score;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanInfo instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.clanId = 0L;
		instance.name = string.Empty;
		instance.created = 0L;
		instance.creator = 0uL;
		instance.motd = string.Empty;
		instance.motdTimestamp = 0L;
		instance.motdAuthor = 0uL;
		instance.logo = null;
		instance.color = 0;
		if (instance.roles != null)
		{
			for (int i = 0; i < instance.roles.Count; i++)
			{
				if (instance.roles[i] != null)
				{
					instance.roles[i].ResetToPool();
					instance.roles[i] = null;
				}
			}
			List<Role> list = instance.roles;
			Pool.Free<Role>(ref list, false);
			instance.roles = list;
		}
		if (instance.members != null)
		{
			for (int j = 0; j < instance.members.Count; j++)
			{
				if (instance.members[j] != null)
				{
					instance.members[j].ResetToPool();
					instance.members[j] = null;
				}
			}
			List<Member> list2 = instance.members;
			Pool.Free<Member>(ref list2, false);
			instance.members = list2;
		}
		if (instance.invites != null)
		{
			for (int k = 0; k < instance.invites.Count; k++)
			{
				if (instance.invites[k] != null)
				{
					instance.invites[k].ResetToPool();
					instance.invites[k] = null;
				}
			}
			List<Invite> list3 = instance.invites;
			Pool.Free<Invite>(ref list3, false);
			instance.invites = list3;
		}
		instance.maxMemberCount = 0;
		instance.score = 0L;
		Pool.Free<ClanInfo>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanInfo instance)
	{
		instance.clanId = clanId;
		instance.name = name;
		instance.created = created;
		instance.creator = creator;
		instance.motd = motd;
		instance.motdTimestamp = motdTimestamp;
		instance.motdAuthor = motdAuthor;
		if (logo == null)
		{
			instance.logo = null;
		}
		else
		{
			instance.logo = new byte[logo.Length];
			Array.Copy(logo, instance.logo, instance.logo.Length);
		}
		instance.color = color;
		if (roles != null)
		{
			instance.roles = Pool.Get<List<Role>>();
			for (int i = 0; i < roles.Count; i++)
			{
				Role item = roles[i].Copy();
				instance.roles.Add(item);
			}
		}
		else
		{
			instance.roles = null;
		}
		if (members != null)
		{
			instance.members = Pool.Get<List<Member>>();
			for (int j = 0; j < members.Count; j++)
			{
				Member item2 = members[j].Copy();
				instance.members.Add(item2);
			}
		}
		else
		{
			instance.members = null;
		}
		if (invites != null)
		{
			instance.invites = Pool.Get<List<Invite>>();
			for (int k = 0; k < invites.Count; k++)
			{
				Invite item3 = invites[k].Copy();
				instance.invites.Add(item3);
			}
		}
		else
		{
			instance.invites = null;
		}
		instance.maxMemberCount = maxMemberCount;
		instance.score = score;
	}

	public ClanInfo Copy()
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		CopyTo(clanInfo);
		return clanInfo;
	}

	public static ClanInfo Deserialize(BufferStream stream)
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		Deserialize(stream, clanInfo, isDelta: false);
		return clanInfo;
	}

	public static ClanInfo DeserializeLengthDelimited(BufferStream stream)
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		DeserializeLengthDelimited(stream, clanInfo, isDelta: false);
		return clanInfo;
	}

	public static ClanInfo DeserializeLength(BufferStream stream, int length)
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		DeserializeLength(stream, length, clanInfo, isDelta: false);
		return clanInfo;
	}

	public static ClanInfo Deserialize(byte[] buffer)
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanInfo, isDelta: false);
		return clanInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanInfo Deserialize(BufferStream stream, ClanInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.created = 0L;
			instance.creator = 0uL;
			instance.motdTimestamp = 0L;
			instance.motdAuthor = 0uL;
			instance.color = 0;
			if (instance.roles == null)
			{
				instance.roles = Pool.Get<List<Role>>();
			}
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<Invite>>();
			}
			instance.maxMemberCount = 0;
			instance.score = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.created = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.creator = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.motd = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.motdTimestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.motdAuthor = ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.logo = ProtocolParser.ReadBytes(stream);
				continue;
			case 72:
				instance.color = ProtocolParser.ReadZInt32(stream);
				continue;
			case 82:
				instance.roles.Add(Role.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 98:
				instance.invites.Add(Invite.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.maxMemberCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanInfo DeserializeLengthDelimited(BufferStream stream, ClanInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.created = 0L;
			instance.creator = 0uL;
			instance.motdTimestamp = 0L;
			instance.motdAuthor = 0uL;
			instance.color = 0;
			if (instance.roles == null)
			{
				instance.roles = Pool.Get<List<Role>>();
			}
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<Invite>>();
			}
			instance.maxMemberCount = 0;
			instance.score = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.created = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.creator = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.motd = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.motdTimestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.motdAuthor = ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.logo = ProtocolParser.ReadBytes(stream);
				continue;
			case 72:
				instance.color = ProtocolParser.ReadZInt32(stream);
				continue;
			case 82:
				instance.roles.Add(Role.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 98:
				instance.invites.Add(Invite.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.maxMemberCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanInfo DeserializeLength(BufferStream stream, int length, ClanInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.created = 0L;
			instance.creator = 0uL;
			instance.motdTimestamp = 0L;
			instance.motdAuthor = 0uL;
			instance.color = 0;
			if (instance.roles == null)
			{
				instance.roles = Pool.Get<List<Role>>();
			}
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<Invite>>();
			}
			instance.maxMemberCount = 0;
			instance.score = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.created = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.creator = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.motd = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.motdTimestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.motdAuthor = ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.logo = ProtocolParser.ReadBytes(stream);
				continue;
			case 72:
				instance.color = ProtocolParser.ReadZInt32(stream);
				continue;
			case 82:
				instance.roles.Add(Role.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 98:
				instance.invites.Add(Invite.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.maxMemberCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanInfo instance, ClanInfo previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.created);
		if (instance.creator != previous.creator)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.creator);
		}
		if (instance.motd != null && instance.motd != previous.motd)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.motd);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.motdTimestamp);
		if (instance.motdAuthor != previous.motdAuthor)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.motdAuthor);
		}
		if (instance.logo != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteBytes(stream, instance.logo);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteZInt32(stream, instance.color);
		if (instance.roles != null)
		{
			for (int i = 0; i < instance.roles.Count; i++)
			{
				Role role = instance.roles[i];
				stream.WriteByte(82);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Role.SerializeDelta(stream, role, role);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.members != null)
		{
			for (int j = 0; j < instance.members.Count; j++)
			{
				Member member = instance.members[j];
				stream.WriteByte(90);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Member.SerializeDelta(stream, member, member);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.invites != null)
		{
			for (int k = 0; k < instance.invites.Count; k++)
			{
				Invite invite = instance.invites[k];
				stream.WriteByte(98);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				Invite.SerializeDelta(stream, invite, invite);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field invites (ProtoBuf.ClanInfo.Invite)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.maxMemberCount != previous.maxMemberCount)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxMemberCount);
		}
		stream.WriteByte(112);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
	}

	public static void Serialize(BufferStream stream, ClanInfo instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.created != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.created);
		}
		if (instance.creator != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.creator);
		}
		if (instance.motd != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.motd);
		}
		if (instance.motdTimestamp != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.motdTimestamp);
		}
		if (instance.motdAuthor != 0L)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.motdAuthor);
		}
		if (instance.logo != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteBytes(stream, instance.logo);
		}
		if (instance.color != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteZInt32(stream, instance.color);
		}
		if (instance.roles != null)
		{
			for (int i = 0; i < instance.roles.Count; i++)
			{
				Role instance2 = instance.roles[i];
				stream.WriteByte(82);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Role.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.members != null)
		{
			for (int j = 0; j < instance.members.Count; j++)
			{
				Member instance3 = instance.members[j];
				stream.WriteByte(90);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Member.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.invites != null)
		{
			for (int k = 0; k < instance.invites.Count; k++)
			{
				Invite instance4 = instance.invites[k];
				stream.WriteByte(98);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				Invite.Serialize(stream, instance4);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field invites (ProtoBuf.ClanInfo.Invite)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.maxMemberCount != 0)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxMemberCount);
		}
		if (instance.score != 0L)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (roles != null)
		{
			for (int i = 0; i < roles.Count; i++)
			{
				roles[i]?.InspectUids(action);
			}
		}
		if (members != null)
		{
			for (int j = 0; j < members.Count; j++)
			{
				members[j]?.InspectUids(action);
			}
		}
		if (invites != null)
		{
			for (int k = 0; k < invites.Count; k++)
			{
				invites[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanInvitations : IDisposable, IPooled, IProto<ClanInvitations>, IProto
{
	public class Invitation : IDisposable, IPooled, IProto<Invitation>, IProto
	{
		[NonSerialized]
		public long clanId;

		[NonSerialized]
		public ulong recruiter;

		[NonSerialized]
		public long timestamp;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Invitation instance)
		{
			if (instance.ShouldPool)
			{
				instance.clanId = 0L;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
				Pool.Free<Invitation>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Invitation with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Invitation instance)
		{
			instance.clanId = clanId;
			instance.recruiter = recruiter;
			instance.timestamp = timestamp;
		}

		public Invitation Copy()
		{
			Invitation invitation = Pool.Get<Invitation>();
			CopyTo(invitation);
			return invitation;
		}

		public static Invitation Deserialize(BufferStream stream)
		{
			Invitation invitation = Pool.Get<Invitation>();
			Deserialize(stream, invitation, isDelta: false);
			return invitation;
		}

		public static Invitation DeserializeLengthDelimited(BufferStream stream)
		{
			Invitation invitation = Pool.Get<Invitation>();
			DeserializeLengthDelimited(stream, invitation, isDelta: false);
			return invitation;
		}

		public static Invitation DeserializeLength(BufferStream stream, int length)
		{
			Invitation invitation = Pool.Get<Invitation>();
			DeserializeLength(stream, length, invitation, isDelta: false);
			return invitation;
		}

		public static Invitation Deserialize(byte[] buffer)
		{
			Invitation invitation = Pool.Get<Invitation>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, invitation, isDelta: false);
			return invitation;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Invitation previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Invitation Deserialize(BufferStream stream, Invitation instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Invitation DeserializeLengthDelimited(BufferStream stream, Invitation instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Invitation DeserializeLength(BufferStream stream, int length, Invitation instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Invitation instance, Invitation previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			if (instance.recruiter != previous.recruiter)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.recruiter);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}

		public static void Serialize(BufferStream stream, Invitation instance)
		{
			if (instance.clanId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			}
			if (instance.recruiter != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.recruiter);
			}
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Invitation> invitations;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanInvitations instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.invitations != null)
		{
			for (int i = 0; i < instance.invitations.Count; i++)
			{
				if (instance.invitations[i] != null)
				{
					instance.invitations[i].ResetToPool();
					instance.invitations[i] = null;
				}
			}
			List<Invitation> list = instance.invitations;
			Pool.Free<Invitation>(ref list, false);
			instance.invitations = list;
		}
		Pool.Free<ClanInvitations>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanInvitations with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanInvitations instance)
	{
		if (invitations != null)
		{
			instance.invitations = Pool.Get<List<Invitation>>();
			for (int i = 0; i < invitations.Count; i++)
			{
				Invitation item = invitations[i].Copy();
				instance.invitations.Add(item);
			}
		}
		else
		{
			instance.invitations = null;
		}
	}

	public ClanInvitations Copy()
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		CopyTo(clanInvitations);
		return clanInvitations;
	}

	public static ClanInvitations Deserialize(BufferStream stream)
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		Deserialize(stream, clanInvitations, isDelta: false);
		return clanInvitations;
	}

	public static ClanInvitations DeserializeLengthDelimited(BufferStream stream)
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		DeserializeLengthDelimited(stream, clanInvitations, isDelta: false);
		return clanInvitations;
	}

	public static ClanInvitations DeserializeLength(BufferStream stream, int length)
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		DeserializeLength(stream, length, clanInvitations, isDelta: false);
		return clanInvitations;
	}

	public static ClanInvitations Deserialize(byte[] buffer)
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanInvitations, isDelta: false);
		return clanInvitations;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanInvitations previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanInvitations Deserialize(BufferStream stream, ClanInvitations instance, bool isDelta)
	{
		if (!isDelta && instance.invitations == null)
		{
			instance.invitations = Pool.Get<List<Invitation>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.invitations.Add(Invitation.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanInvitations DeserializeLengthDelimited(BufferStream stream, ClanInvitations instance, bool isDelta)
	{
		if (!isDelta && instance.invitations == null)
		{
			instance.invitations = Pool.Get<List<Invitation>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.invitations.Add(Invitation.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanInvitations DeserializeLength(BufferStream stream, int length, ClanInvitations instance, bool isDelta)
	{
		if (!isDelta && instance.invitations == null)
		{
			instance.invitations = Pool.Get<List<Invitation>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.invitations.Add(Invitation.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanInvitations instance, ClanInvitations previous)
	{
		if (instance.invitations == null)
		{
			return;
		}
		for (int i = 0; i < instance.invitations.Count; i++)
		{
			Invitation invitation = instance.invitations[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Invitation.SerializeDelta(stream, invitation, invitation);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field invitations (ProtoBuf.ClanInvitations.Invitation)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ClanInvitations instance)
	{
		if (instance.invitations == null)
		{
			return;
		}
		for (int i = 0; i < instance.invitations.Count; i++)
		{
			Invitation instance2 = instance.invitations[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Invitation.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field invitations (ProtoBuf.ClanInvitations.Invitation)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (invitations != null)
		{
			for (int i = 0; i < invitations.Count; i++)
			{
				invitations[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanLeaderboard : IDisposable, IPooled, IProto<ClanLeaderboard>, IProto
{
	public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
	{
		[NonSerialized]
		public long clanId;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public long score;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Entry instance)
		{
			if (instance.ShouldPool)
			{
				instance.clanId = 0L;
				instance.name = string.Empty;
				instance.score = 0L;
				Pool.Free<Entry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Entry instance)
		{
			instance.clanId = clanId;
			instance.name = name;
			instance.score = score;
		}

		public Entry Copy()
		{
			Entry entry = Pool.Get<Entry>();
			CopyTo(entry);
			return entry;
		}

		public static Entry Deserialize(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLengthDelimited(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLength(BufferStream stream, int length)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLength(stream, length, entry, isDelta: false);
			return entry;
		}

		public static Entry Deserialize(byte[] buffer)
		{
			Entry entry = Pool.Get<Entry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.score = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.score = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.score = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.name);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}

		public static void Serialize(BufferStream stream, Entry instance)
		{
			if (instance.clanId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.score != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Entry> entries;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanLeaderboard instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entries != null)
		{
			for (int i = 0; i < instance.entries.Count; i++)
			{
				if (instance.entries[i] != null)
				{
					instance.entries[i].ResetToPool();
					instance.entries[i] = null;
				}
			}
			List<Entry> list = instance.entries;
			Pool.Free<Entry>(ref list, false);
			instance.entries = list;
		}
		Pool.Free<ClanLeaderboard>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanLeaderboard with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanLeaderboard instance)
	{
		if (entries != null)
		{
			instance.entries = Pool.Get<List<Entry>>();
			for (int i = 0; i < entries.Count; i++)
			{
				Entry item = entries[i].Copy();
				instance.entries.Add(item);
			}
		}
		else
		{
			instance.entries = null;
		}
	}

	public ClanLeaderboard Copy()
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		CopyTo(clanLeaderboard);
		return clanLeaderboard;
	}

	public static ClanLeaderboard Deserialize(BufferStream stream)
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		Deserialize(stream, clanLeaderboard, isDelta: false);
		return clanLeaderboard;
	}

	public static ClanLeaderboard DeserializeLengthDelimited(BufferStream stream)
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		DeserializeLengthDelimited(stream, clanLeaderboard, isDelta: false);
		return clanLeaderboard;
	}

	public static ClanLeaderboard DeserializeLength(BufferStream stream, int length)
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		DeserializeLength(stream, length, clanLeaderboard, isDelta: false);
		return clanLeaderboard;
	}

	public static ClanLeaderboard Deserialize(byte[] buffer)
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanLeaderboard, isDelta: false);
		return clanLeaderboard;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanLeaderboard previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanLeaderboard Deserialize(BufferStream stream, ClanLeaderboard instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<Entry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanLeaderboard DeserializeLengthDelimited(BufferStream stream, ClanLeaderboard instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<Entry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanLeaderboard DeserializeLength(BufferStream stream, int length, ClanLeaderboard instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<Entry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanLeaderboard instance, ClanLeaderboard previous)
	{
		if (instance.entries == null)
		{
			return;
		}
		for (int i = 0; i < instance.entries.Count; i++)
		{
			Entry entry = instance.entries[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.SerializeDelta(stream, entry, entry);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ClanLeaderboard instance)
	{
		if (instance.entries == null)
		{
			return;
		}
		for (int i = 0; i < instance.entries.Count; i++)
		{
			Entry instance2 = instance.entries[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entries != null)
		{
			for (int i = 0; i < entries.Count; i++)
			{
				entries[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanLog : IDisposable, IPooled, IProto<ClanLog>, IProto
{
	public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
	{
		[NonSerialized]
		public long timestamp;

		[NonSerialized]
		public string eventKey;

		[NonSerialized]
		public string arg1;

		[NonSerialized]
		public string arg2;

		[NonSerialized]
		public string arg3;

		[NonSerialized]
		public string arg4;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Entry instance)
		{
			if (instance.ShouldPool)
			{
				instance.timestamp = 0L;
				instance.eventKey = string.Empty;
				instance.arg1 = string.Empty;
				instance.arg2 = string.Empty;
				instance.arg3 = string.Empty;
				instance.arg4 = string.Empty;
				Pool.Free<Entry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Entry instance)
		{
			instance.timestamp = timestamp;
			instance.eventKey = eventKey;
			instance.arg1 = arg1;
			instance.arg2 = arg2;
			instance.arg3 = arg3;
			instance.arg4 = arg4;
		}

		public Entry Copy()
		{
			Entry entry = Pool.Get<Entry>();
			CopyTo(entry);
			return entry;
		}

		public static Entry Deserialize(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLengthDelimited(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLength(BufferStream stream, int length)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLength(stream, length, entry, isDelta: false);
			return entry;
		}

		public static Entry Deserialize(byte[] buffer)
		{
			Entry entry = Pool.Get<Entry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.eventKey = ProtocolParser.ReadString(stream);
					continue;
				case 26:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				case 42:
					instance.arg3 = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.arg4 = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.eventKey = ProtocolParser.ReadString(stream);
					continue;
				case 26:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				case 42:
					instance.arg3 = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.arg4 = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.eventKey = ProtocolParser.ReadString(stream);
					continue;
				case 26:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				case 42:
					instance.arg3 = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.arg4 = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			if (instance.eventKey != previous.eventKey)
			{
				if (instance.eventKey == null)
				{
					throw new ArgumentNullException("eventKey", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.eventKey);
			}
			if (instance.arg1 != null && instance.arg1 != previous.arg1)
			{
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.arg1);
			}
			if (instance.arg2 != null && instance.arg2 != previous.arg2)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.arg2);
			}
			if (instance.arg3 != null && instance.arg3 != previous.arg3)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.arg3);
			}
			if (instance.arg4 != null && instance.arg4 != previous.arg4)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.arg4);
			}
		}

		public static void Serialize(BufferStream stream, Entry instance)
		{
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
			if (instance.eventKey == null)
			{
				throw new ArgumentNullException("eventKey", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.eventKey);
			if (instance.arg1 != null)
			{
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.arg1);
			}
			if (instance.arg2 != null)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.arg2);
			}
			if (instance.arg3 != null)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.arg3);
			}
			if (instance.arg4 != null)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.arg4);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public List<Entry> logEntries;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanLog instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.clanId = 0L;
		if (instance.logEntries != null)
		{
			for (int i = 0; i < instance.logEntries.Count; i++)
			{
				if (instance.logEntries[i] != null)
				{
					instance.logEntries[i].ResetToPool();
					instance.logEntries[i] = null;
				}
			}
			List<Entry> list = instance.logEntries;
			Pool.Free<Entry>(ref list, false);
			instance.logEntries = list;
		}
		Pool.Free<ClanLog>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanLog with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanLog instance)
	{
		instance.clanId = clanId;
		if (logEntries != null)
		{
			instance.logEntries = Pool.Get<List<Entry>>();
			for (int i = 0; i < logEntries.Count; i++)
			{
				Entry item = logEntries[i].Copy();
				instance.logEntries.Add(item);
			}
		}
		else
		{
			instance.logEntries = null;
		}
	}

	public ClanLog Copy()
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		CopyTo(clanLog);
		return clanLog;
	}

	public static ClanLog Deserialize(BufferStream stream)
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		Deserialize(stream, clanLog, isDelta: false);
		return clanLog;
	}

	public static ClanLog DeserializeLengthDelimited(BufferStream stream)
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		DeserializeLengthDelimited(stream, clanLog, isDelta: false);
		return clanLog;
	}

	public static ClanLog DeserializeLength(BufferStream stream, int length)
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		DeserializeLength(stream, length, clanLog, isDelta: false);
		return clanLog;
	}

	public static ClanLog Deserialize(byte[] buffer)
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanLog, isDelta: false);
		return clanLog;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanLog previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanLog Deserialize(BufferStream stream, ClanLog instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.logEntries == null)
			{
				instance.logEntries = Pool.Get<List<Entry>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.logEntries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanLog DeserializeLengthDelimited(BufferStream stream, ClanLog instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.logEntries == null)
			{
				instance.logEntries = Pool.Get<List<Entry>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.logEntries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanLog DeserializeLength(BufferStream stream, int length, ClanLog instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.logEntries == null)
			{
				instance.logEntries = Pool.Get<List<Entry>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.logEntries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanLog instance, ClanLog previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.logEntries == null)
		{
			return;
		}
		for (int i = 0; i < instance.logEntries.Count; i++)
		{
			Entry entry = instance.logEntries[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.SerializeDelta(stream, entry, entry);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ClanLog instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.logEntries == null)
		{
			return;
		}
		for (int i = 0; i < instance.logEntries.Count; i++)
		{
			Entry instance2 = instance.logEntries[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (logEntries != null)
		{
			for (int i = 0; i < logEntries.Count; i++)
			{
				logEntries[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanManager : IDisposable, IPooled, IProto<ClanManager>, IProto
{
	[NonSerialized]
	public string backendType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanManager instance)
	{
		if (instance.ShouldPool)
		{
			instance.backendType = string.Empty;
			Pool.Free<ClanManager>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanManager with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanManager instance)
	{
		instance.backendType = backendType;
	}

	public ClanManager Copy()
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		CopyTo(clanManager);
		return clanManager;
	}

	public static ClanManager Deserialize(BufferStream stream)
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		Deserialize(stream, clanManager, isDelta: false);
		return clanManager;
	}

	public static ClanManager DeserializeLengthDelimited(BufferStream stream)
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		DeserializeLengthDelimited(stream, clanManager, isDelta: false);
		return clanManager;
	}

	public static ClanManager DeserializeLength(BufferStream stream, int length)
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		DeserializeLength(stream, length, clanManager, isDelta: false);
		return clanManager;
	}

	public static ClanManager Deserialize(byte[] buffer)
	{
		ClanManager clanManager = Pool.Get<ClanManager>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanManager, isDelta: false);
		return clanManager;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanManager previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanManager Deserialize(BufferStream stream, ClanManager instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.backendType = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanManager DeserializeLengthDelimited(BufferStream stream, ClanManager instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.backendType = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanManager DeserializeLength(BufferStream stream, int length, ClanManager instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.backendType = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanManager instance, ClanManager previous)
	{
		if (instance.backendType != previous.backendType)
		{
			if (instance.backendType == null)
			{
				throw new ArgumentNullException("backendType", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.backendType);
		}
	}

	public static void Serialize(BufferStream stream, ClanManager instance)
	{
		if (instance.backendType == null)
		{
			throw new ArgumentNullException("backendType", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.backendType);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanScoreEvents : IDisposable, IPooled, IProto<ClanScoreEvents>, IProto
{
	public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
	{
		[NonSerialized]
		public long timestamp;

		[NonSerialized]
		public int type;

		[NonSerialized]
		public int score;

		[NonSerialized]
		public int multiplier;

		[NonSerialized]
		public ulong steamId;

		[NonSerialized]
		public ulong otherSteamId;

		[NonSerialized]
		public long otherClanId;

		[NonSerialized]
		public string arg1;

		[NonSerialized]
		public string arg2;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Entry instance)
		{
			if (instance.ShouldPool)
			{
				instance.timestamp = 0L;
				instance.type = 0;
				instance.score = 0;
				instance.multiplier = 0;
				instance.steamId = 0uL;
				instance.otherSteamId = 0uL;
				instance.otherClanId = 0L;
				instance.arg1 = string.Empty;
				instance.arg2 = string.Empty;
				Pool.Free<Entry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Entry instance)
		{
			instance.timestamp = timestamp;
			instance.type = type;
			instance.score = score;
			instance.multiplier = multiplier;
			instance.steamId = steamId;
			instance.otherSteamId = otherSteamId;
			instance.otherClanId = otherClanId;
			instance.arg1 = arg1;
			instance.arg2 = arg2;
		}

		public Entry Copy()
		{
			Entry entry = Pool.Get<Entry>();
			CopyTo(entry);
			return entry;
		}

		public static Entry Deserialize(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLengthDelimited(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLength(BufferStream stream, int length)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLength(stream, length, entry, isDelta: false);
			return entry;
		}

		public static Entry Deserialize(byte[] buffer)
		{
			Entry entry = Pool.Get<Entry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
				instance.type = 0;
				instance.score = 0;
				instance.multiplier = 0;
				instance.steamId = 0uL;
				instance.otherSteamId = 0uL;
				instance.otherClanId = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 74:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
				instance.type = 0;
				instance.score = 0;
				instance.multiplier = 0;
				instance.steamId = 0uL;
				instance.otherSteamId = 0uL;
				instance.otherClanId = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 74:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
				instance.type = 0;
				instance.score = 0;
				instance.multiplier = 0;
				instance.steamId = 0uL;
				instance.otherSteamId = 0uL;
				instance.otherClanId = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 74:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			if (instance.type != previous.type)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.score != previous.score)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
			if (instance.multiplier != previous.multiplier)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
			}
			if (instance.steamId != previous.steamId)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.otherSteamId != previous.otherSteamId)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
			}
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
			if (instance.arg1 != null && instance.arg1 != previous.arg1)
			{
				stream.WriteByte(66);
				ProtocolParser.WriteString(stream, instance.arg1);
			}
			if (instance.arg2 != null && instance.arg2 != previous.arg2)
			{
				stream.WriteByte(74);
				ProtocolParser.WriteString(stream, instance.arg2);
			}
		}

		public static void Serialize(BufferStream stream, Entry instance)
		{
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
			if (instance.type != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.score != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
			if (instance.multiplier != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
			}
			if (instance.steamId != 0L)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.otherSteamId != 0L)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
			}
			if (instance.otherClanId != 0L)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
			}
			if (instance.arg1 != null)
			{
				stream.WriteByte(66);
				ProtocolParser.WriteString(stream, instance.arg1);
			}
			if (instance.arg2 != null)
			{
				stream.WriteByte(74);
				ProtocolParser.WriteString(stream, instance.arg2);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public List<Entry> scoreEvents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanScoreEvents instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.clanId = 0L;
		if (instance.scoreEvents != null)
		{
			for (int i = 0; i < instance.scoreEvents.Count; i++)
			{
				if (instance.scoreEvents[i] != null)
				{
					instance.scoreEvents[i].ResetToPool();
					instance.scoreEvents[i] = null;
				}
			}
			List<Entry> list = instance.scoreEvents;
			Pool.Free<Entry>(ref list, false);
			instance.scoreEvents = list;
		}
		Pool.Free<ClanScoreEvents>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanScoreEvents with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanScoreEvents instance)
	{
		instance.clanId = clanId;
		if (scoreEvents != null)
		{
			instance.scoreEvents = Pool.Get<List<Entry>>();
			for (int i = 0; i < scoreEvents.Count; i++)
			{
				Entry item = scoreEvents[i].Copy();
				instance.scoreEvents.Add(item);
			}
		}
		else
		{
			instance.scoreEvents = null;
		}
	}

	public ClanScoreEvents Copy()
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		CopyTo(clanScoreEvents);
		return clanScoreEvents;
	}

	public static ClanScoreEvents Deserialize(BufferStream stream)
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		Deserialize(stream, clanScoreEvents, isDelta: false);
		return clanScoreEvents;
	}

	public static ClanScoreEvents DeserializeLengthDelimited(BufferStream stream)
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		DeserializeLengthDelimited(stream, clanScoreEvents, isDelta: false);
		return clanScoreEvents;
	}

	public static ClanScoreEvents DeserializeLength(BufferStream stream, int length)
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		DeserializeLength(stream, length, clanScoreEvents, isDelta: false);
		return clanScoreEvents;
	}

	public static ClanScoreEvents Deserialize(byte[] buffer)
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanScoreEvents, isDelta: false);
		return clanScoreEvents;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanScoreEvents previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanScoreEvents Deserialize(BufferStream stream, ClanScoreEvents instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.scoreEvents == null)
			{
				instance.scoreEvents = Pool.Get<List<Entry>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.scoreEvents.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanScoreEvents DeserializeLengthDelimited(BufferStream stream, ClanScoreEvents instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.scoreEvents == null)
			{
				instance.scoreEvents = Pool.Get<List<Entry>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.scoreEvents.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanScoreEvents DeserializeLength(BufferStream stream, int length, ClanScoreEvents instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.scoreEvents == null)
			{
				instance.scoreEvents = Pool.Get<List<Entry>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.scoreEvents.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanScoreEvents instance, ClanScoreEvents previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.scoreEvents == null)
		{
			return;
		}
		for (int i = 0; i < instance.scoreEvents.Count; i++)
		{
			Entry entry = instance.scoreEvents[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.SerializeDelta(stream, entry, entry);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ClanScoreEvents instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.scoreEvents == null)
		{
			return;
		}
		for (int i = 0; i < instance.scoreEvents.Count; i++)
		{
			Entry instance2 = instance.scoreEvents[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (scoreEvents != null)
		{
			for (int i = 0; i < scoreEvents.Count; i++)
			{
				scoreEvents[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClientReady : IDisposable, IPooled, IProto<ClientReady>, IProto
{
	public class ClientInfo : IDisposable, IPooled, IProto<ClientInfo>, IProto
	{
		[NonSerialized]
		public string name;

		[NonSerialized]
		public string value;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ClientInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.name = string.Empty;
				instance.value = string.Empty;
				Pool.Free<ClientInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ClientInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ClientInfo instance)
		{
			instance.name = name;
			instance.value = value;
		}

		public ClientInfo Copy()
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			CopyTo(clientInfo);
			return clientInfo;
		}

		public static ClientInfo Deserialize(BufferStream stream)
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			Deserialize(stream, clientInfo, isDelta: false);
			return clientInfo;
		}

		public static ClientInfo DeserializeLengthDelimited(BufferStream stream)
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			DeserializeLengthDelimited(stream, clientInfo, isDelta: false);
			return clientInfo;
		}

		public static ClientInfo DeserializeLength(BufferStream stream, int length)
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			DeserializeLength(stream, length, clientInfo, isDelta: false);
			return clientInfo;
		}

		public static ClientInfo Deserialize(byte[] buffer)
		{
			ClientInfo clientInfo = Pool.Get<ClientInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, clientInfo, isDelta: false);
			return clientInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ClientInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ClientInfo Deserialize(BufferStream stream, ClientInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.value = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ClientInfo DeserializeLengthDelimited(BufferStream stream, ClientInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.value = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ClientInfo DeserializeLength(BufferStream stream, int length, ClientInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.value = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ClientInfo instance, ClientInfo previous)
		{
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.value != previous.value)
			{
				if (instance.value == null)
				{
					throw new ArgumentNullException("value", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.value);
			}
		}

		public static void Serialize(BufferStream stream, ClientInfo instance)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.value == null)
			{
				throw new ArgumentNullException("value", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.value);
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<ClientInfo> clientInfo;

	[NonSerialized]
	public bool globalNetworking;

	[NonSerialized]
	public PartyData party;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClientReady instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.clientInfo != null)
		{
			for (int i = 0; i < instance.clientInfo.Count; i++)
			{
				if (instance.clientInfo[i] != null)
				{
					instance.clientInfo[i].ResetToPool();
					instance.clientInfo[i] = null;
				}
			}
			List<ClientInfo> list = instance.clientInfo;
			Pool.Free<ClientInfo>(ref list, false);
			instance.clientInfo = list;
		}
		instance.globalNetworking = false;
		if (instance.party != null)
		{
			instance.party.ResetToPool();
			instance.party = null;
		}
		Pool.Free<ClientReady>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClientReady with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClientReady instance)
	{
		if (clientInfo != null)
		{
			instance.clientInfo = Pool.Get<List<ClientInfo>>();
			for (int i = 0; i < clientInfo.Count; i++)
			{
				ClientInfo item = clientInfo[i].Copy();
				instance.clientInfo.Add(item);
			}
		}
		else
		{
			instance.clientInfo = null;
		}
		instance.globalNetworking = globalNetworking;
		if (party != null)
		{
			if (instance.party == null)
			{
				instance.party = party.Copy();
			}
			else
			{
				party.CopyTo(instance.party);
			}
		}
		else
		{
			instance.party = null;
		}
	}

	public ClientReady Copy()
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		CopyTo(clientReady);
		return clientReady;
	}

	public static ClientReady Deserialize(BufferStream stream)
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		Deserialize(stream, clientReady, isDelta: false);
		return clientReady;
	}

	public static ClientReady DeserializeLengthDelimited(BufferStream stream)
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		DeserializeLengthDelimited(stream, clientReady, isDelta: false);
		return clientReady;
	}

	public static ClientReady DeserializeLength(BufferStream stream, int length)
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		DeserializeLength(stream, length, clientReady, isDelta: false);
		return clientReady;
	}

	public static ClientReady Deserialize(byte[] buffer)
	{
		ClientReady clientReady = Pool.Get<ClientReady>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clientReady, isDelta: false);
		return clientReady;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClientReady previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClientReady Deserialize(BufferStream stream, ClientReady instance, bool isDelta)
	{
		if (!isDelta && instance.clientInfo == null)
		{
			instance.clientInfo = Pool.Get<List<ClientInfo>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.clientInfo.Add(ClientInfo.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.globalNetworking = ProtocolParser.ReadBool(stream);
				break;
			case 26:
				if (instance.party == null)
				{
					instance.party = PartyData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PartyData.DeserializeLengthDelimited(stream, instance.party, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static ClientReady DeserializeLengthDelimited(BufferStream stream, ClientReady instance, bool isDelta)
	{
		if (!isDelta && instance.clientInfo == null)
		{
			instance.clientInfo = Pool.Get<List<ClientInfo>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.clientInfo.Add(ClientInfo.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.globalNetworking = ProtocolParser.ReadBool(stream);
				break;
			case 26:
				if (instance.party == null)
				{
					instance.party = PartyData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PartyData.DeserializeLengthDelimited(stream, instance.party, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClientReady DeserializeLength(BufferStream stream, int length, ClientReady instance, bool isDelta)
	{
		if (!isDelta && instance.clientInfo == null)
		{
			instance.clientInfo = Pool.Get<List<ClientInfo>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.clientInfo.Add(ClientInfo.DeserializeLengthDelimited(stream));
				break;
			case 16:
				instance.globalNetworking = ProtocolParser.ReadBool(stream);
				break;
			case 26:
				if (instance.party == null)
				{
					instance.party = PartyData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PartyData.DeserializeLengthDelimited(stream, instance.party, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClientReady instance, ClientReady previous)
	{
		if (instance.clientInfo != null)
		{
			for (int i = 0; i < instance.clientInfo.Count; i++)
			{
				ClientInfo clientInfo = instance.clientInfo[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ClientInfo.SerializeDelta(stream, clientInfo, clientInfo);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.globalNetworking);
		if (instance.party == null)
		{
			return;
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		PartyData.SerializeDelta(stream, instance.party, previous.party);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, ClientReady instance)
	{
		if (instance.clientInfo != null)
		{
			for (int i = 0; i < instance.clientInfo.Count; i++)
			{
				ClientInfo instance2 = instance.clientInfo[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ClientInfo.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.globalNetworking)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.globalNetworking);
		}
		if (instance.party == null)
		{
			return;
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		PartyData.Serialize(stream, instance.party);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (clientInfo != null)
		{
			for (int i = 0; i < clientInfo.Count; i++)
			{
				clientInfo[i]?.InspectUids(action);
			}
		}
		party?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CoalingTower : IDisposable, IPooled, IProto<CoalingTower>, IProto
{
	[NonSerialized]
	public int lootTypeIndex;

	[NonSerialized]
	public NetworkableId oreStorageID;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public NetworkableId activeUnloadableID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CoalingTower instance)
	{
		if (instance.ShouldPool)
		{
			instance.lootTypeIndex = 0;
			instance.oreStorageID = default(NetworkableId);
			instance.fuelStorageID = default(NetworkableId);
			instance.activeUnloadableID = default(NetworkableId);
			Pool.Free<CoalingTower>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CoalingTower with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CoalingTower instance)
	{
		instance.lootTypeIndex = lootTypeIndex;
		instance.oreStorageID = oreStorageID;
		instance.fuelStorageID = fuelStorageID;
		instance.activeUnloadableID = activeUnloadableID;
	}

	public CoalingTower Copy()
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		CopyTo(coalingTower);
		return coalingTower;
	}

	public static CoalingTower Deserialize(BufferStream stream)
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		Deserialize(stream, coalingTower, isDelta: false);
		return coalingTower;
	}

	public static CoalingTower DeserializeLengthDelimited(BufferStream stream)
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		DeserializeLengthDelimited(stream, coalingTower, isDelta: false);
		return coalingTower;
	}

	public static CoalingTower DeserializeLength(BufferStream stream, int length)
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		DeserializeLength(stream, length, coalingTower, isDelta: false);
		return coalingTower;
	}

	public static CoalingTower Deserialize(byte[] buffer)
	{
		CoalingTower coalingTower = Pool.Get<CoalingTower>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, coalingTower, isDelta: false);
		return coalingTower;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CoalingTower previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CoalingTower Deserialize(BufferStream stream, CoalingTower instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oreStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.activeUnloadableID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CoalingTower DeserializeLengthDelimited(BufferStream stream, CoalingTower instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oreStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.activeUnloadableID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CoalingTower DeserializeLength(BufferStream stream, int length, CoalingTower instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lootTypeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oreStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.activeUnloadableID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CoalingTower instance, CoalingTower previous)
	{
		if (instance.lootTypeIndex != previous.lootTypeIndex)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lootTypeIndex);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.oreStorageID.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.activeUnloadableID.Value);
	}

	public static void Serialize(BufferStream stream, CoalingTower instance)
	{
		if (instance.lootTypeIndex != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lootTypeIndex);
		}
		if (instance.oreStorageID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.oreStorageID.Value);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.activeUnloadableID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.activeUnloadableID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref oreStorageID.Value);
		action(UidType.NetworkableId, ref fuelStorageID.Value);
		action(UidType.NetworkableId, ref activeUnloadableID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CodeLock : IDisposable, IPooled, IProto<CodeLock>, IProto
{
	public class Private : IDisposable, IPooled, IProto<Private>, IProto
	{
		[NonSerialized]
		public string code;

		[NonSerialized]
		public List<ulong> users;

		[NonSerialized]
		public string guestCode;

		[NonSerialized]
		public List<ulong> guestUsers;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Private instance)
		{
			if (instance.ShouldPool)
			{
				instance.code = string.Empty;
				if (instance.users != null)
				{
					List<ulong> list = instance.users;
					Pool.FreeUnmanaged<ulong>(ref list);
					instance.users = list;
				}
				instance.guestCode = string.Empty;
				if (instance.guestUsers != null)
				{
					List<ulong> list2 = instance.guestUsers;
					Pool.FreeUnmanaged<ulong>(ref list2);
					instance.guestUsers = list2;
				}
				Pool.Free<Private>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Private with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Private instance)
		{
			instance.code = code;
			if (users != null)
			{
				instance.users = Pool.Get<List<ulong>>();
				for (int i = 0; i < users.Count; i++)
				{
					ulong item = users[i];
					instance.users.Add(item);
				}
			}
			else
			{
				instance.users = null;
			}
			instance.guestCode = guestCode;
			if (guestUsers != null)
			{
				instance.guestUsers = Pool.Get<List<ulong>>();
				for (int j = 0; j < guestUsers.Count; j++)
				{
					ulong item2 = guestUsers[j];
					instance.guestUsers.Add(item2);
				}
			}
			else
			{
				instance.guestUsers = null;
			}
		}

		public Private Copy()
		{
			Private @private = Pool.Get<Private>();
			CopyTo(@private);
			return @private;
		}

		public static Private Deserialize(BufferStream stream)
		{
			Private @private = Pool.Get<Private>();
			Deserialize(stream, @private, isDelta: false);
			return @private;
		}

		public static Private DeserializeLengthDelimited(BufferStream stream)
		{
			Private @private = Pool.Get<Private>();
			DeserializeLengthDelimited(stream, @private, isDelta: false);
			return @private;
		}

		public static Private DeserializeLength(BufferStream stream, int length)
		{
			Private @private = Pool.Get<Private>();
			DeserializeLength(stream, length, @private, isDelta: false);
			return @private;
		}

		public static Private Deserialize(byte[] buffer)
		{
			Private @private = Pool.Get<Private>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, @private, isDelta: false);
			return @private;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Private previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Private Deserialize(BufferStream stream, Private instance, bool isDelta)
		{
			if (!isDelta)
			{
				if (instance.users == null)
				{
					instance.users = Pool.Get<List<ulong>>();
				}
				if (instance.guestUsers == null)
				{
					instance.guestUsers = Pool.Get<List<ulong>>();
				}
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.code = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.users.Add(ProtocolParser.ReadUInt64(stream));
					continue;
				case 34:
					instance.guestCode = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.guestUsers.Add(ProtocolParser.ReadUInt64(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Private DeserializeLengthDelimited(BufferStream stream, Private instance, bool isDelta)
		{
			if (!isDelta)
			{
				if (instance.users == null)
				{
					instance.users = Pool.Get<List<ulong>>();
				}
				if (instance.guestUsers == null)
				{
					instance.guestUsers = Pool.Get<List<ulong>>();
				}
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.code = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.users.Add(ProtocolParser.ReadUInt64(stream));
					continue;
				case 34:
					instance.guestCode = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.guestUsers.Add(ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Private DeserializeLength(BufferStream stream, int length, Private instance, bool isDelta)
		{
			if (!isDelta)
			{
				if (instance.users == null)
				{
					instance.users = Pool.Get<List<ulong>>();
				}
				if (instance.guestUsers == null)
				{
					instance.guestUsers = Pool.Get<List<ulong>>();
				}
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.code = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.users.Add(ProtocolParser.ReadUInt64(stream));
					continue;
				case 34:
					instance.guestCode = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.guestUsers.Add(ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Private instance, Private previous)
		{
			if (instance.code != null && instance.code != previous.code)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.code);
			}
			if (instance.users != null)
			{
				for (int i = 0; i < instance.users.Count; i++)
				{
					ulong val = instance.users[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, val);
				}
			}
			if (instance.guestCode != null && instance.guestCode != previous.guestCode)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.guestCode);
			}
			if (instance.guestUsers != null)
			{
				for (int j = 0; j < instance.guestUsers.Count; j++)
				{
					ulong val2 = instance.guestUsers[j];
					stream.WriteByte(40);
					ProtocolParser.WriteUInt64(stream, val2);
				}
			}
		}

		public static void Serialize(BufferStream stream, Private instance)
		{
			if (instance.code != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.code);
			}
			if (instance.users != null)
			{
				for (int i = 0; i < instance.users.Count; i++)
				{
					ulong val = instance.users[i];
					stream.WriteByte(16);
					ProtocolParser.WriteUInt64(stream, val);
				}
			}
			if (instance.guestCode != null)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.guestCode);
			}
			if (instance.guestUsers != null)
			{
				for (int j = 0; j < instance.guestUsers.Count; j++)
				{
					ulong val2 = instance.guestUsers[j];
					stream.WriteByte(40);
					ProtocolParser.WriteUInt64(stream, val2);
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public Private pv;

	[NonSerialized]
	public bool hasCode;

	[NonSerialized]
	public bool hasGuestCode;

	[NonSerialized]
	public bool hasAuth;

	[NonSerialized]
	public bool hasGuestAuth;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CodeLock instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.pv != null)
			{
				instance.pv.ResetToPool();
				instance.pv = null;
			}
			instance.hasCode = false;
			instance.hasGuestCode = false;
			instance.hasAuth = false;
			instance.hasGuestAuth = false;
			Pool.Free<CodeLock>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CodeLock with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CodeLock instance)
	{
		if (pv != null)
		{
			if (instance.pv == null)
			{
				instance.pv = pv.Copy();
			}
			else
			{
				pv.CopyTo(instance.pv);
			}
		}
		else
		{
			instance.pv = null;
		}
		instance.hasCode = hasCode;
		instance.hasGuestCode = hasGuestCode;
		instance.hasAuth = hasAuth;
		instance.hasGuestAuth = hasGuestAuth;
	}

	public CodeLock Copy()
	{
		CodeLock codeLock = Pool.Get<CodeLock>();
		CopyTo(codeLock);
		return codeLock;
	}

	public static CodeLock Deserialize(BufferStream stream)
	{
		CodeLock codeLock = Pool.Get<CodeLock>();
		Deserialize(stream, codeLock, isDelta: false);
		return codeLock;
	}

	public static CodeLock DeserializeLengthDelimited(BufferStream stream)
	{
		CodeLock codeLock = Pool.Get<CodeLock>();
		DeserializeLengthDelimited(stream, codeLock, isDelta: false);
		return codeLock;
	}

	public static CodeLock DeserializeLength(BufferStream stream, int length)
	{
		CodeLock codeLock = Pool.Get<CodeLock>();
		DeserializeLength(stream, length, codeLock, isDelta: false);
		return codeLock;
	}

	public static CodeLock Deserialize(byte[] buffer)
	{
		CodeLock codeLock = Pool.Get<CodeLock>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, codeLock, isDelta: false);
		return codeLock;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CodeLock previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CodeLock Deserialize(BufferStream stream, CodeLock instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.pv == null)
				{
					instance.pv = Private.DeserializeLengthDelimited(stream);
				}
				else
				{
					Private.DeserializeLengthDelimited(stream, instance.pv, isDelta);
				}
				break;
			case 16:
				instance.hasCode = ProtocolParser.ReadBool(stream);
				break;
			case 24:
				instance.hasGuestCode = ProtocolParser.ReadBool(stream);
				break;
			case 32:
				instance.hasAuth = ProtocolParser.ReadBool(stream);
				break;
			case 40:
				instance.hasGuestAuth = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static CodeLock DeserializeLengthDelimited(BufferStream stream, CodeLock instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.pv == null)
				{
					instance.pv = Private.DeserializeLengthDelimited(stream);
				}
				else
				{
					Private.DeserializeLengthDelimited(stream, instance.pv, isDelta);
				}
				break;
			case 16:
				instance.hasCode = ProtocolParser.ReadBool(stream);
				break;
			case 24:
				instance.hasGuestCode = ProtocolParser.ReadBool(stream);
				break;
			case 32:
				instance.hasAuth = ProtocolParser.ReadBool(stream);
				break;
			case 40:
				instance.hasGuestAuth = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CodeLock DeserializeLength(BufferStream stream, int length, CodeLock instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.pv == null)
				{
					instance.pv = Private.DeserializeLengthDelimited(stream);
				}
				else
				{
					Private.DeserializeLengthDelimited(stream, instance.pv, isDelta);
				}
				break;
			case 16:
				instance.hasCode = ProtocolParser.ReadBool(stream);
				break;
			case 24:
				instance.hasGuestCode = ProtocolParser.ReadBool(stream);
				break;
			case 32:
				instance.hasAuth = ProtocolParser.ReadBool(stream);
				break;
			case 40:
				instance.hasGuestAuth = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CodeLock instance, CodeLock previous)
	{
		if (instance.pv != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Private.SerializeDelta(stream, instance.pv, previous.pv);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.hasCode);
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.hasGuestCode);
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.hasAuth);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.hasGuestAuth);
	}

	public static void Serialize(BufferStream stream, CodeLock instance)
	{
		if (instance.pv != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Private.Serialize(stream, instance.pv);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.hasCode)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.hasCode);
		}
		if (instance.hasGuestCode)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.hasGuestCode);
		}
		if (instance.hasAuth)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.hasAuth);
		}
		if (instance.hasGuestAuth)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.hasGuestAuth);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		pv?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CommandBlock : IDisposable, IPooled, IProto<CommandBlock>, IProto
{
	[NonSerialized]
	public string currentCommand;

	[NonSerialized]
	public ulong lastPlayerID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CommandBlock instance)
	{
		if (instance.ShouldPool)
		{
			instance.currentCommand = string.Empty;
			instance.lastPlayerID = 0uL;
			Pool.Free<CommandBlock>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CommandBlock with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CommandBlock instance)
	{
		instance.currentCommand = currentCommand;
		instance.lastPlayerID = lastPlayerID;
	}

	public CommandBlock Copy()
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		CopyTo(commandBlock);
		return commandBlock;
	}

	public static CommandBlock Deserialize(BufferStream stream)
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		Deserialize(stream, commandBlock, isDelta: false);
		return commandBlock;
	}

	public static CommandBlock DeserializeLengthDelimited(BufferStream stream)
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		DeserializeLengthDelimited(stream, commandBlock, isDelta: false);
		return commandBlock;
	}

	public static CommandBlock DeserializeLength(BufferStream stream, int length)
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		DeserializeLength(stream, length, commandBlock, isDelta: false);
		return commandBlock;
	}

	public static CommandBlock Deserialize(byte[] buffer)
	{
		CommandBlock commandBlock = Pool.Get<CommandBlock>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, commandBlock, isDelta: false);
		return commandBlock;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CommandBlock previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CommandBlock Deserialize(BufferStream stream, CommandBlock instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.currentCommand = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.lastPlayerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CommandBlock DeserializeLengthDelimited(BufferStream stream, CommandBlock instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.currentCommand = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.lastPlayerID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CommandBlock DeserializeLength(BufferStream stream, int length, CommandBlock instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.currentCommand = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.lastPlayerID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CommandBlock instance, CommandBlock previous)
	{
		if (instance.currentCommand != previous.currentCommand)
		{
			if (instance.currentCommand == null)
			{
				throw new ArgumentNullException("currentCommand", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.currentCommand);
		}
		if (instance.lastPlayerID != previous.lastPlayerID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.lastPlayerID);
		}
	}

	public static void Serialize(BufferStream stream, CommandBlock instance)
	{
		if (instance.currentCommand == null)
		{
			throw new ArgumentNullException("currentCommand", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.currentCommand);
		if (instance.lastPlayerID != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.lastPlayerID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Composter : IDisposable, IPooled, IProto<Composter>, IProto
{
	[NonSerialized]
	public float fertilizerProductionProgress;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Composter instance)
	{
		if (instance.ShouldPool)
		{
			instance.fertilizerProductionProgress = 0f;
			Pool.Free<Composter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Composter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Composter instance)
	{
		instance.fertilizerProductionProgress = fertilizerProductionProgress;
	}

	public Composter Copy()
	{
		Composter composter = Pool.Get<Composter>();
		CopyTo(composter);
		return composter;
	}

	public static Composter Deserialize(BufferStream stream)
	{
		Composter composter = Pool.Get<Composter>();
		Deserialize(stream, composter, isDelta: false);
		return composter;
	}

	public static Composter DeserializeLengthDelimited(BufferStream stream)
	{
		Composter composter = Pool.Get<Composter>();
		DeserializeLengthDelimited(stream, composter, isDelta: false);
		return composter;
	}

	public static Composter DeserializeLength(BufferStream stream, int length)
	{
		Composter composter = Pool.Get<Composter>();
		DeserializeLength(stream, length, composter, isDelta: false);
		return composter;
	}

	public static Composter Deserialize(byte[] buffer)
	{
		Composter composter = Pool.Get<Composter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, composter, isDelta: false);
		return composter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Composter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Composter Deserialize(BufferStream stream, Composter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.fertilizerProductionProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Composter DeserializeLengthDelimited(BufferStream stream, Composter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fertilizerProductionProgress = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Composter DeserializeLength(BufferStream stream, int length, Composter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fertilizerProductionProgress = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Composter instance, Composter previous)
	{
		if (instance.fertilizerProductionProgress != previous.fertilizerProductionProgress)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fertilizerProductionProgress);
		}
	}

	public static void Serialize(BufferStream stream, Composter instance)
	{
		if (instance.fertilizerProductionProgress != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fertilizerProductionProgress);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ComputerStation : IDisposable, IPooled, IProto<ComputerStation>, IProto
{
	[NonSerialized]
	public string bookmarks;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ComputerStation instance)
	{
		if (instance.ShouldPool)
		{
			instance.bookmarks = string.Empty;
			Pool.Free<ComputerStation>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ComputerStation with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ComputerStation instance)
	{
		instance.bookmarks = bookmarks;
	}

	public ComputerStation Copy()
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		CopyTo(computerStation);
		return computerStation;
	}

	public static ComputerStation Deserialize(BufferStream stream)
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		Deserialize(stream, computerStation, isDelta: false);
		return computerStation;
	}

	public static ComputerStation DeserializeLengthDelimited(BufferStream stream)
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		DeserializeLengthDelimited(stream, computerStation, isDelta: false);
		return computerStation;
	}

	public static ComputerStation DeserializeLength(BufferStream stream, int length)
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		DeserializeLength(stream, length, computerStation, isDelta: false);
		return computerStation;
	}

	public static ComputerStation Deserialize(byte[] buffer)
	{
		ComputerStation computerStation = Pool.Get<ComputerStation>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, computerStation, isDelta: false);
		return computerStation;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ComputerStation previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ComputerStation Deserialize(BufferStream stream, ComputerStation instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.bookmarks = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ComputerStation DeserializeLengthDelimited(BufferStream stream, ComputerStation instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.bookmarks = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ComputerStation DeserializeLength(BufferStream stream, int length, ComputerStation instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.bookmarks = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ComputerStation instance, ComputerStation previous)
	{
		if (instance.bookmarks != null && instance.bookmarks != previous.bookmarks)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.bookmarks);
		}
	}

	public static void Serialize(BufferStream stream, ComputerStation instance)
	{
		if (instance.bookmarks != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.bookmarks);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ConnectedSpeaker : IDisposable, IPooled, IProto<ConnectedSpeaker>, IProto
{
	[NonSerialized]
	public NetworkableId connectedTo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ConnectedSpeaker instance)
	{
		if (instance.ShouldPool)
		{
			instance.connectedTo = default(NetworkableId);
			Pool.Free<ConnectedSpeaker>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ConnectedSpeaker with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ConnectedSpeaker instance)
	{
		instance.connectedTo = connectedTo;
	}

	public ConnectedSpeaker Copy()
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		CopyTo(connectedSpeaker);
		return connectedSpeaker;
	}

	public static ConnectedSpeaker Deserialize(BufferStream stream)
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		Deserialize(stream, connectedSpeaker, isDelta: false);
		return connectedSpeaker;
	}

	public static ConnectedSpeaker DeserializeLengthDelimited(BufferStream stream)
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		DeserializeLengthDelimited(stream, connectedSpeaker, isDelta: false);
		return connectedSpeaker;
	}

	public static ConnectedSpeaker DeserializeLength(BufferStream stream, int length)
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		DeserializeLength(stream, length, connectedSpeaker, isDelta: false);
		return connectedSpeaker;
	}

	public static ConnectedSpeaker Deserialize(byte[] buffer)
	{
		ConnectedSpeaker connectedSpeaker = Pool.Get<ConnectedSpeaker>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, connectedSpeaker, isDelta: false);
		return connectedSpeaker;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ConnectedSpeaker previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ConnectedSpeaker Deserialize(BufferStream stream, ConnectedSpeaker instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.connectedTo = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ConnectedSpeaker DeserializeLengthDelimited(BufferStream stream, ConnectedSpeaker instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.connectedTo = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ConnectedSpeaker DeserializeLength(BufferStream stream, int length, ConnectedSpeaker instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.connectedTo = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ConnectedSpeaker instance, ConnectedSpeaker previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.connectedTo.Value);
	}

	public static void Serialize(BufferStream stream, ConnectedSpeaker instance)
	{
		if (instance.connectedTo != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.connectedTo.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref connectedTo.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ConstructableEntity : IDisposable, IPooled, IProto<ConstructableEntity>, IProto
{
	[NonSerialized]
	public List<int> addedResources;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ConstructableEntity instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.addedResources != null)
			{
				List<int> list = instance.addedResources;
				Pool.FreeUnmanaged<int>(ref list);
				instance.addedResources = list;
			}
			Pool.Free<ConstructableEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ConstructableEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ConstructableEntity instance)
	{
		if (addedResources != null)
		{
			instance.addedResources = Pool.Get<List<int>>();
			for (int i = 0; i < addedResources.Count; i++)
			{
				int item = addedResources[i];
				instance.addedResources.Add(item);
			}
		}
		else
		{
			instance.addedResources = null;
		}
	}

	public ConstructableEntity Copy()
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		CopyTo(constructableEntity);
		return constructableEntity;
	}

	public static ConstructableEntity Deserialize(BufferStream stream)
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		Deserialize(stream, constructableEntity, isDelta: false);
		return constructableEntity;
	}

	public static ConstructableEntity DeserializeLengthDelimited(BufferStream stream)
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		DeserializeLengthDelimited(stream, constructableEntity, isDelta: false);
		return constructableEntity;
	}

	public static ConstructableEntity DeserializeLength(BufferStream stream, int length)
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		DeserializeLength(stream, length, constructableEntity, isDelta: false);
		return constructableEntity;
	}

	public static ConstructableEntity Deserialize(byte[] buffer)
	{
		ConstructableEntity constructableEntity = Pool.Get<ConstructableEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, constructableEntity, isDelta: false);
		return constructableEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ConstructableEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ConstructableEntity Deserialize(BufferStream stream, ConstructableEntity instance, bool isDelta)
	{
		if (!isDelta && instance.addedResources == null)
		{
			instance.addedResources = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.addedResources.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ConstructableEntity DeserializeLengthDelimited(BufferStream stream, ConstructableEntity instance, bool isDelta)
	{
		if (!isDelta && instance.addedResources == null)
		{
			instance.addedResources = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.addedResources.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ConstructableEntity DeserializeLength(BufferStream stream, int length, ConstructableEntity instance, bool isDelta)
	{
		if (!isDelta && instance.addedResources == null)
		{
			instance.addedResources = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.addedResources.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ConstructableEntity instance, ConstructableEntity previous)
	{
		if (instance.addedResources != null)
		{
			for (int i = 0; i < instance.addedResources.Count; i++)
			{
				int num = instance.addedResources[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public static void Serialize(BufferStream stream, ConstructableEntity instance)
	{
		if (instance.addedResources != null)
		{
			for (int i = 0; i < instance.addedResources.Count; i++)
			{
				int num = instance.addedResources[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ContainerCorpseData : IDisposable, IPooled, IProto<ContainerCorpseData>, IProto
{
	[NonSerialized]
	public ulong lockOwnerId;

	[NonSerialized]
	public CodeLock codeLock;

	[NonSerialized]
	public KeyLock keyLock;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ContainerCorpseData instance)
	{
		if (instance.ShouldPool)
		{
			instance.lockOwnerId = 0uL;
			if (instance.codeLock != null)
			{
				instance.codeLock.ResetToPool();
				instance.codeLock = null;
			}
			if (instance.keyLock != null)
			{
				instance.keyLock.ResetToPool();
				instance.keyLock = null;
			}
			Pool.Free<ContainerCorpseData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ContainerCorpseData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ContainerCorpseData instance)
	{
		instance.lockOwnerId = lockOwnerId;
		if (codeLock != null)
		{
			if (instance.codeLock == null)
			{
				instance.codeLock = codeLock.Copy();
			}
			else
			{
				codeLock.CopyTo(instance.codeLock);
			}
		}
		else
		{
			instance.codeLock = null;
		}
		if (keyLock != null)
		{
			if (instance.keyLock == null)
			{
				instance.keyLock = keyLock.Copy();
			}
			else
			{
				keyLock.CopyTo(instance.keyLock);
			}
		}
		else
		{
			instance.keyLock = null;
		}
	}

	public ContainerCorpseData Copy()
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		CopyTo(containerCorpseData);
		return containerCorpseData;
	}

	public static ContainerCorpseData Deserialize(BufferStream stream)
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		Deserialize(stream, containerCorpseData, isDelta: false);
		return containerCorpseData;
	}

	public static ContainerCorpseData DeserializeLengthDelimited(BufferStream stream)
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		DeserializeLengthDelimited(stream, containerCorpseData, isDelta: false);
		return containerCorpseData;
	}

	public static ContainerCorpseData DeserializeLength(BufferStream stream, int length)
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		DeserializeLength(stream, length, containerCorpseData, isDelta: false);
		return containerCorpseData;
	}

	public static ContainerCorpseData Deserialize(byte[] buffer)
	{
		ContainerCorpseData containerCorpseData = Pool.Get<ContainerCorpseData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, containerCorpseData, isDelta: false);
		return containerCorpseData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ContainerCorpseData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ContainerCorpseData Deserialize(BufferStream stream, ContainerCorpseData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lockOwnerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.codeLock == null)
				{
					instance.codeLock = CodeLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					CodeLock.DeserializeLengthDelimited(stream, instance.codeLock, isDelta);
				}
				break;
			case 26:
				if (instance.keyLock == null)
				{
					instance.keyLock = KeyLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					KeyLock.DeserializeLengthDelimited(stream, instance.keyLock, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static ContainerCorpseData DeserializeLengthDelimited(BufferStream stream, ContainerCorpseData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lockOwnerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.codeLock == null)
				{
					instance.codeLock = CodeLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					CodeLock.DeserializeLengthDelimited(stream, instance.codeLock, isDelta);
				}
				break;
			case 26:
				if (instance.keyLock == null)
				{
					instance.keyLock = KeyLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					KeyLock.DeserializeLengthDelimited(stream, instance.keyLock, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ContainerCorpseData DeserializeLength(BufferStream stream, int length, ContainerCorpseData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lockOwnerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.codeLock == null)
				{
					instance.codeLock = CodeLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					CodeLock.DeserializeLengthDelimited(stream, instance.codeLock, isDelta);
				}
				break;
			case 26:
				if (instance.keyLock == null)
				{
					instance.keyLock = KeyLock.DeserializeLengthDelimited(stream);
				}
				else
				{
					KeyLock.DeserializeLengthDelimited(stream, instance.keyLock, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ContainerCorpseData instance, ContainerCorpseData previous)
	{
		if (instance.lockOwnerId != previous.lockOwnerId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lockOwnerId);
		}
		if (instance.codeLock != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CodeLock.SerializeDelta(stream, instance.codeLock, previous.codeLock);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.keyLock != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			KeyLock.SerializeDelta(stream, instance.keyLock, previous.keyLock);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyLock (ProtoBuf.KeyLock)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, ContainerCorpseData instance)
	{
		if (instance.lockOwnerId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lockOwnerId);
		}
		if (instance.codeLock != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CodeLock.Serialize(stream, instance.codeLock);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.keyLock != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			KeyLock.Serialize(stream, instance.keyLock);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyLock (ProtoBuf.KeyLock)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		codeLock?.InspectUids(action);
		keyLock?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CopyPasteEntityInfo : IDisposable, IPooled, IProto<CopyPasteEntityInfo>, IProto
{
	[NonSerialized]
	public List<Entity> entities;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CopyPasteEntityInfo instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				if (instance.entities[i] != null)
				{
					instance.entities[i].ResetToPool();
					instance.entities[i] = null;
				}
			}
			List<Entity> list = instance.entities;
			Pool.Free<Entity>(ref list, false);
			instance.entities = list;
		}
		Pool.Free<CopyPasteEntityInfo>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CopyPasteEntityInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CopyPasteEntityInfo instance)
	{
		if (entities != null)
		{
			instance.entities = Pool.Get<List<Entity>>();
			for (int i = 0; i < entities.Count; i++)
			{
				Entity item = entities[i].Copy();
				instance.entities.Add(item);
			}
		}
		else
		{
			instance.entities = null;
		}
	}

	public CopyPasteEntityInfo Copy()
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		CopyTo(copyPasteEntityInfo);
		return copyPasteEntityInfo;
	}

	public static CopyPasteEntityInfo Deserialize(BufferStream stream)
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		Deserialize(stream, copyPasteEntityInfo, isDelta: false);
		return copyPasteEntityInfo;
	}

	public static CopyPasteEntityInfo DeserializeLengthDelimited(BufferStream stream)
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		DeserializeLengthDelimited(stream, copyPasteEntityInfo, isDelta: false);
		return copyPasteEntityInfo;
	}

	public static CopyPasteEntityInfo DeserializeLength(BufferStream stream, int length)
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		DeserializeLength(stream, length, copyPasteEntityInfo, isDelta: false);
		return copyPasteEntityInfo;
	}

	public static CopyPasteEntityInfo Deserialize(byte[] buffer)
	{
		CopyPasteEntityInfo copyPasteEntityInfo = Pool.Get<CopyPasteEntityInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, copyPasteEntityInfo, isDelta: false);
		return copyPasteEntityInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CopyPasteEntityInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CopyPasteEntityInfo Deserialize(BufferStream stream, CopyPasteEntityInfo instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<Entity>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CopyPasteEntityInfo DeserializeLengthDelimited(BufferStream stream, CopyPasteEntityInfo instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<Entity>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CopyPasteEntityInfo DeserializeLength(BufferStream stream, int length, CopyPasteEntityInfo instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<Entity>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CopyPasteEntityInfo instance, CopyPasteEntityInfo previous)
	{
		if (instance.entities == null)
		{
			return;
		}
		for (int i = 0; i < instance.entities.Count; i++)
		{
			Entity entity = instance.entities[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entity.SerializeDelta(stream, entity, entity);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, CopyPasteEntityInfo instance)
	{
		if (instance.entities == null)
		{
			return;
		}
		for (int i = 0; i < instance.entities.Count; i++)
		{
			Entity instance2 = instance.entities[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entity.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entities != null)
		{
			for (int i = 0; i < entities.Count; i++)
			{
				entities[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Corpse : IDisposable, IPooled, IProto<Corpse>, IProto
{
	[NonSerialized]
	public NetworkableId parentID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Corpse instance)
	{
		if (instance.ShouldPool)
		{
			instance.parentID = default(NetworkableId);
			Pool.Free<Corpse>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Corpse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Corpse instance)
	{
		instance.parentID = parentID;
	}

	public Corpse Copy()
	{
		Corpse corpse = Pool.Get<Corpse>();
		CopyTo(corpse);
		return corpse;
	}

	public static Corpse Deserialize(BufferStream stream)
	{
		Corpse corpse = Pool.Get<Corpse>();
		Deserialize(stream, corpse, isDelta: false);
		return corpse;
	}

	public static Corpse DeserializeLengthDelimited(BufferStream stream)
	{
		Corpse corpse = Pool.Get<Corpse>();
		DeserializeLengthDelimited(stream, corpse, isDelta: false);
		return corpse;
	}

	public static Corpse DeserializeLength(BufferStream stream, int length)
	{
		Corpse corpse = Pool.Get<Corpse>();
		DeserializeLength(stream, length, corpse, isDelta: false);
		return corpse;
	}

	public static Corpse Deserialize(byte[] buffer)
	{
		Corpse corpse = Pool.Get<Corpse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, corpse, isDelta: false);
		return corpse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Corpse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Corpse Deserialize(BufferStream stream, Corpse instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Corpse DeserializeLengthDelimited(BufferStream stream, Corpse instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Corpse DeserializeLength(BufferStream stream, int length, Corpse instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Corpse instance, Corpse previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
	}

	public static void Serialize(BufferStream stream, Corpse instance)
	{
		if (instance.parentID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref parentID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Crane : IDisposable, IPooled, IProto<Crane>, IProto
{
	[NonSerialized]
	public float yaw;

	[NonSerialized]
	public float arm1;

	[NonSerialized]
	public float arm2;

	[NonSerialized]
	public float magnet;

	[NonSerialized]
	public float time;

	[NonSerialized]
	public int treadInput;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Crane instance)
	{
		if (instance.ShouldPool)
		{
			instance.yaw = 0f;
			instance.arm1 = 0f;
			instance.arm2 = 0f;
			instance.magnet = 0f;
			instance.time = 0f;
			instance.treadInput = 0;
			Pool.Free<Crane>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Crane with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Crane instance)
	{
		instance.yaw = yaw;
		instance.arm1 = arm1;
		instance.arm2 = arm2;
		instance.magnet = magnet;
		instance.time = time;
		instance.treadInput = treadInput;
	}

	public Crane Copy()
	{
		Crane crane = Pool.Get<Crane>();
		CopyTo(crane);
		return crane;
	}

	public static Crane Deserialize(BufferStream stream)
	{
		Crane crane = Pool.Get<Crane>();
		Deserialize(stream, crane, isDelta: false);
		return crane;
	}

	public static Crane DeserializeLengthDelimited(BufferStream stream)
	{
		Crane crane = Pool.Get<Crane>();
		DeserializeLengthDelimited(stream, crane, isDelta: false);
		return crane;
	}

	public static Crane DeserializeLength(BufferStream stream, int length)
	{
		Crane crane = Pool.Get<Crane>();
		DeserializeLength(stream, length, crane, isDelta: false);
		return crane;
	}

	public static Crane Deserialize(byte[] buffer)
	{
		Crane crane = Pool.Get<Crane>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, crane, isDelta: false);
		return crane;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Crane previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Crane Deserialize(BufferStream stream, Crane instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.arm1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.arm2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.magnet = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.treadInput = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Crane DeserializeLengthDelimited(BufferStream stream, Crane instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.arm1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.arm2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.magnet = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.treadInput = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Crane DeserializeLength(BufferStream stream, int length, Crane instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.arm1 = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.arm2 = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.magnet = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.treadInput = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Crane instance, Crane previous)
	{
		if (instance.yaw != previous.yaw)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
		if (instance.arm1 != previous.arm1)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.arm1);
		}
		if (instance.arm2 != previous.arm2)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.arm2);
		}
		if (instance.magnet != previous.magnet)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.magnet);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.treadInput != previous.treadInput)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.treadInput);
		}
	}

	public static void Serialize(BufferStream stream, Crane instance)
	{
		if (instance.yaw != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
		if (instance.arm1 != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.arm1);
		}
		if (instance.arm2 != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.arm2);
		}
		if (instance.magnet != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.magnet);
		}
		if (instance.time != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.treadInput != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.treadInput);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class CreateBuilding : IDisposable, IPooled, IProto<CreateBuilding>, IProto
{
	[NonSerialized]
	public NetworkableId entity;

	[NonSerialized]
	public uint socket;

	[NonSerialized]
	public bool onterrain;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 normal;

	[NonSerialized]
	public Ray ray;

	[NonSerialized]
	public uint blockID;

	[NonSerialized]
	public Vector3 rotation;

	[NonSerialized]
	public bool isHoldingShift;

	[NonSerialized]
	public int setToGrade;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CreateBuilding instance)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.entity = default(NetworkableId);
			instance.socket = 0u;
			instance.onterrain = false;
			instance.position = default(Vector3);
			instance.normal = default(Vector3);
			instance.ray = default(Ray);
			instance.blockID = 0u;
			instance.rotation = default(Vector3);
			instance.isHoldingShift = false;
			instance.setToGrade = 0;
			Pool.Free<CreateBuilding>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CreateBuilding with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CreateBuilding instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.entity = entity;
		instance.socket = socket;
		instance.onterrain = onterrain;
		instance.position = position;
		instance.normal = normal;
		instance.ray = ray;
		instance.blockID = blockID;
		instance.rotation = rotation;
		instance.isHoldingShift = isHoldingShift;
		instance.setToGrade = setToGrade;
	}

	public CreateBuilding Copy()
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		CopyTo(createBuilding);
		return createBuilding;
	}

	public static CreateBuilding Deserialize(BufferStream stream)
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		Deserialize(stream, createBuilding, isDelta: false);
		return createBuilding;
	}

	public static CreateBuilding DeserializeLengthDelimited(BufferStream stream)
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		DeserializeLengthDelimited(stream, createBuilding, isDelta: false);
		return createBuilding;
	}

	public static CreateBuilding DeserializeLength(BufferStream stream, int length)
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		DeserializeLength(stream, length, createBuilding, isDelta: false);
		return createBuilding;
	}

	public static CreateBuilding Deserialize(byte[] buffer)
	{
		CreateBuilding createBuilding = Pool.Get<CreateBuilding>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, createBuilding, isDelta: false);
		return createBuilding;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CreateBuilding previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CreateBuilding Deserialize(BufferStream stream, CreateBuilding instance, bool isDelta)
	{
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.socket = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.onterrain = ProtocolParser.ReadBool(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 50:
				RaySerialized.DeserializeLengthDelimited(stream, ref instance.ray, isDelta);
				continue;
			case 56:
				instance.blockID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 72:
				instance.isHoldingShift = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.setToGrade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CreateBuilding DeserializeLengthDelimited(BufferStream stream, CreateBuilding instance, bool isDelta)
	{
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.socket = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.onterrain = ProtocolParser.ReadBool(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 50:
				RaySerialized.DeserializeLengthDelimited(stream, ref instance.ray, isDelta);
				continue;
			case 56:
				instance.blockID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 72:
				instance.isHoldingShift = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.setToGrade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CreateBuilding DeserializeLength(BufferStream stream, int length, CreateBuilding instance, bool isDelta)
	{
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.socket = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.onterrain = ProtocolParser.ReadBool(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 50:
				RaySerialized.DeserializeLengthDelimited(stream, ref instance.ray, isDelta);
				continue;
			case 56:
				instance.blockID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 72:
				instance.isHoldingShift = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.setToGrade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CreateBuilding instance, CreateBuilding previous)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entity.Value);
		if (instance.socket != previous.socket)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.socket);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.onterrain);
		if (instance.position != previous.position)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.normal != previous.normal)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range3 = stream.GetRange(1);
		int num5 = stream.Position;
		RaySerialized.SerializeDelta(stream, instance.ray, previous.ray);
		int num6 = stream.Position - num5;
		if (num6 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ray (UnityEngine.Ray)");
		}
		Span<byte> span3 = range3.GetSpan();
		ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		if (instance.blockID != previous.blockID)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.blockID);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rotation, previous.rotation);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.isHoldingShift);
		if (instance.setToGrade != previous.setToGrade)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.setToGrade);
		}
	}

	public static void Serialize(BufferStream stream, CreateBuilding instance)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entity != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entity.Value);
		}
		if (instance.socket != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.socket);
		}
		if (instance.onterrain)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.onterrain);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.normal != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.normal);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (((Ray)(ref instance.ray)).origin != default(Vector3) && ((Ray)(ref instance.ray)).direction != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			RaySerialized.Serialize(stream, instance.ray);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ray (UnityEngine.Ray)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
		if (instance.blockID != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt32(stream, instance.blockID);
		}
		if (instance.rotation != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int num7 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rotation);
			int num8 = stream.Position - num7;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span4, 0);
		}
		if (instance.isHoldingShift)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.isHoldingShift);
		}
		if (instance.setToGrade != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.setToGrade);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class CustomVitalInfo : IDisposable, IPooled, IProto<CustomVitalInfo>, IProto
{
	[NonSerialized]
	public Color backgroundColor;

	[NonSerialized]
	public Color leftTextColor;

	[NonSerialized]
	public Color rightTextColor;

	[NonSerialized]
	public Color iconColor;

	[NonSerialized]
	public string leftText;

	[NonSerialized]
	public string rightText;

	[NonSerialized]
	public string icon;

	[NonSerialized]
	public bool active;

	[NonSerialized]
	public int timeLeft;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CustomVitalInfo instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.backgroundColor = default(Color);
			instance.leftTextColor = default(Color);
			instance.rightTextColor = default(Color);
			instance.iconColor = default(Color);
			instance.leftText = string.Empty;
			instance.rightText = string.Empty;
			instance.icon = string.Empty;
			instance.active = false;
			instance.timeLeft = 0;
			Pool.Free<CustomVitalInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CustomVitalInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CustomVitalInfo instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.backgroundColor = backgroundColor;
		instance.leftTextColor = leftTextColor;
		instance.rightTextColor = rightTextColor;
		instance.iconColor = iconColor;
		instance.leftText = leftText;
		instance.rightText = rightText;
		instance.icon = icon;
		instance.active = active;
		instance.timeLeft = timeLeft;
	}

	public CustomVitalInfo Copy()
	{
		CustomVitalInfo customVitalInfo = Pool.Get<CustomVitalInfo>();
		CopyTo(customVitalInfo);
		return customVitalInfo;
	}

	public static CustomVitalInfo Deserialize(BufferStream stream)
	{
		CustomVitalInfo customVitalInfo = Pool.Get<CustomVitalInfo>();
		Deserialize(stream, customVitalInfo, isDelta: false);
		return customVitalInfo;
	}

	public static CustomVitalInfo DeserializeLengthDelimited(BufferStream stream)
	{
		CustomVitalInfo customVitalInfo = Pool.Get<CustomVitalInfo>();
		DeserializeLengthDelimited(stream, customVitalInfo, isDelta: false);
		return customVitalInfo;
	}

	public static CustomVitalInfo DeserializeLength(BufferStream stream, int length)
	{
		CustomVitalInfo customVitalInfo = Pool.Get<CustomVitalInfo>();
		DeserializeLength(stream, length, customVitalInfo, isDelta: false);
		return customVitalInfo;
	}

	public static CustomVitalInfo Deserialize(byte[] buffer)
	{
		CustomVitalInfo customVitalInfo = Pool.Get<CustomVitalInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, customVitalInfo, isDelta: false);
		return customVitalInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CustomVitalInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CustomVitalInfo Deserialize(BufferStream stream, CustomVitalInfo instance, bool isDelta)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.backgroundColor, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.leftTextColor, isDelta);
				continue;
			case 26:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.rightTextColor, isDelta);
				continue;
			case 34:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.iconColor, isDelta);
				continue;
			case 42:
				instance.leftText = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.rightText = ProtocolParser.ReadString(stream);
				continue;
			case 58:
				instance.icon = ProtocolParser.ReadString(stream);
				continue;
			case 64:
				instance.active = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.timeLeft = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CustomVitalInfo DeserializeLengthDelimited(BufferStream stream, CustomVitalInfo instance, bool isDelta)
	{
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.backgroundColor, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.leftTextColor, isDelta);
				continue;
			case 26:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.rightTextColor, isDelta);
				continue;
			case 34:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.iconColor, isDelta);
				continue;
			case 42:
				instance.leftText = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.rightText = ProtocolParser.ReadString(stream);
				continue;
			case 58:
				instance.icon = ProtocolParser.ReadString(stream);
				continue;
			case 64:
				instance.active = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.timeLeft = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CustomVitalInfo DeserializeLength(BufferStream stream, int length, CustomVitalInfo instance, bool isDelta)
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.backgroundColor, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.leftTextColor, isDelta);
				continue;
			case 26:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.rightTextColor, isDelta);
				continue;
			case 34:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.iconColor, isDelta);
				continue;
			case 42:
				instance.leftText = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.rightText = ProtocolParser.ReadString(stream);
				continue;
			case 58:
				instance.icon = ProtocolParser.ReadString(stream);
				continue;
			case 64:
				instance.active = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.timeLeft = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CustomVitalInfo instance, CustomVitalInfo previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		if (instance.backgroundColor != previous.backgroundColor)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.backgroundColor, previous.backgroundColor);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field backgroundColor (UnityEngine.Color)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.leftTextColor != previous.leftTextColor)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.leftTextColor, previous.leftTextColor);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field leftTextColor (UnityEngine.Color)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rightTextColor != previous.rightTextColor)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.rightTextColor, previous.rightTextColor);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rightTextColor (UnityEngine.Color)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.iconColor != previous.iconColor)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.iconColor, previous.iconColor);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field iconColor (UnityEngine.Color)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.leftText != null && instance.leftText != previous.leftText)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.leftText);
		}
		if (instance.rightText != null && instance.rightText != previous.rightText)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.rightText);
		}
		if (instance.icon != null && instance.icon != previous.icon)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteString(stream, instance.icon);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.active);
		if (instance.timeLeft != previous.timeLeft)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timeLeft);
		}
	}

	public static void Serialize(BufferStream stream, CustomVitalInfo instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.backgroundColor != default(Color))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ColorSerialized.Serialize(stream, instance.backgroundColor);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field backgroundColor (UnityEngine.Color)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.leftTextColor != default(Color))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			ColorSerialized.Serialize(stream, instance.leftTextColor);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field leftTextColor (UnityEngine.Color)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rightTextColor != default(Color))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			ColorSerialized.Serialize(stream, instance.rightTextColor);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rightTextColor (UnityEngine.Color)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.iconColor != default(Color))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			ColorSerialized.Serialize(stream, instance.iconColor);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field iconColor (UnityEngine.Color)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.leftText != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.leftText);
		}
		if (instance.rightText != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.rightText);
		}
		if (instance.icon != null)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteString(stream, instance.icon);
		}
		if (instance.active)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.active);
		}
		if (instance.timeLeft != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timeLeft);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class CustomVitals : IDisposable, IPooled, IProto<CustomVitals>, IProto
{
	[NonSerialized]
	public List<CustomVitalInfo> vitals;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CustomVitals instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.vitals != null)
		{
			for (int i = 0; i < instance.vitals.Count; i++)
			{
				if (instance.vitals[i] != null)
				{
					instance.vitals[i].ResetToPool();
					instance.vitals[i] = null;
				}
			}
			List<CustomVitalInfo> list = instance.vitals;
			Pool.Free<CustomVitalInfo>(ref list, false);
			instance.vitals = list;
		}
		Pool.Free<CustomVitals>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CustomVitals with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CustomVitals instance)
	{
		if (vitals != null)
		{
			instance.vitals = Pool.Get<List<CustomVitalInfo>>();
			for (int i = 0; i < vitals.Count; i++)
			{
				CustomVitalInfo item = vitals[i].Copy();
				instance.vitals.Add(item);
			}
		}
		else
		{
			instance.vitals = null;
		}
	}

	public CustomVitals Copy()
	{
		CustomVitals customVitals = Pool.Get<CustomVitals>();
		CopyTo(customVitals);
		return customVitals;
	}

	public static CustomVitals Deserialize(BufferStream stream)
	{
		CustomVitals customVitals = Pool.Get<CustomVitals>();
		Deserialize(stream, customVitals, isDelta: false);
		return customVitals;
	}

	public static CustomVitals DeserializeLengthDelimited(BufferStream stream)
	{
		CustomVitals customVitals = Pool.Get<CustomVitals>();
		DeserializeLengthDelimited(stream, customVitals, isDelta: false);
		return customVitals;
	}

	public static CustomVitals DeserializeLength(BufferStream stream, int length)
	{
		CustomVitals customVitals = Pool.Get<CustomVitals>();
		DeserializeLength(stream, length, customVitals, isDelta: false);
		return customVitals;
	}

	public static CustomVitals Deserialize(byte[] buffer)
	{
		CustomVitals customVitals = Pool.Get<CustomVitals>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, customVitals, isDelta: false);
		return customVitals;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CustomVitals previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CustomVitals Deserialize(BufferStream stream, CustomVitals instance, bool isDelta)
	{
		if (!isDelta && instance.vitals == null)
		{
			instance.vitals = Pool.Get<List<CustomVitalInfo>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.vitals.Add(CustomVitalInfo.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CustomVitals DeserializeLengthDelimited(BufferStream stream, CustomVitals instance, bool isDelta)
	{
		if (!isDelta && instance.vitals == null)
		{
			instance.vitals = Pool.Get<List<CustomVitalInfo>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.vitals.Add(CustomVitalInfo.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CustomVitals DeserializeLength(BufferStream stream, int length, CustomVitals instance, bool isDelta)
	{
		if (!isDelta && instance.vitals == null)
		{
			instance.vitals = Pool.Get<List<CustomVitalInfo>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.vitals.Add(CustomVitalInfo.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CustomVitals instance, CustomVitals previous)
	{
		if (instance.vitals == null)
		{
			return;
		}
		for (int i = 0; i < instance.vitals.Count; i++)
		{
			CustomVitalInfo customVitalInfo = instance.vitals[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CustomVitalInfo.SerializeDelta(stream, customVitalInfo, customVitalInfo);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, CustomVitals instance)
	{
		if (instance.vitals == null)
		{
			return;
		}
		for (int i = 0; i < instance.vitals.Count; i++)
		{
			CustomVitalInfo instance2 = instance.vitals[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CustomVitalInfo.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (vitals != null)
		{
			for (int i = 0; i < vitals.Count; i++)
			{
				vitals[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DecayEntity : IDisposable, IPooled, IProto<DecayEntity>, IProto
{
	[NonSerialized]
	public float decayTimer;

	[NonSerialized]
	public uint buildingID;

	[NonSerialized]
	public float upkeepTimer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DecayEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.decayTimer = 0f;
			instance.buildingID = 0u;
			instance.upkeepTimer = 0f;
			Pool.Free<DecayEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DecayEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DecayEntity instance)
	{
		instance.decayTimer = decayTimer;
		instance.buildingID = buildingID;
		instance.upkeepTimer = upkeepTimer;
	}

	public DecayEntity Copy()
	{
		DecayEntity decayEntity = Pool.Get<DecayEntity>();
		CopyTo(decayEntity);
		return decayEntity;
	}

	public static DecayEntity Deserialize(BufferStream stream)
	{
		DecayEntity decayEntity = Pool.Get<DecayEntity>();
		Deserialize(stream, decayEntity, isDelta: false);
		return decayEntity;
	}

	public static DecayEntity DeserializeLengthDelimited(BufferStream stream)
	{
		DecayEntity decayEntity = Pool.Get<DecayEntity>();
		DeserializeLengthDelimited(stream, decayEntity, isDelta: false);
		return decayEntity;
	}

	public static DecayEntity DeserializeLength(BufferStream stream, int length)
	{
		DecayEntity decayEntity = Pool.Get<DecayEntity>();
		DeserializeLength(stream, length, decayEntity, isDelta: false);
		return decayEntity;
	}

	public static DecayEntity Deserialize(byte[] buffer)
	{
		DecayEntity decayEntity = Pool.Get<DecayEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, decayEntity, isDelta: false);
		return decayEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DecayEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DecayEntity Deserialize(BufferStream stream, DecayEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.decayTimer = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.buildingID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 29:
				instance.upkeepTimer = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DecayEntity DeserializeLengthDelimited(BufferStream stream, DecayEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.decayTimer = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.buildingID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 29:
				instance.upkeepTimer = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DecayEntity DeserializeLength(BufferStream stream, int length, DecayEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.decayTimer = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.buildingID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 29:
				instance.upkeepTimer = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DecayEntity instance, DecayEntity previous)
	{
		if (instance.decayTimer != previous.decayTimer)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.decayTimer);
		}
		if (instance.buildingID != previous.buildingID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.buildingID);
		}
		if (instance.upkeepTimer != previous.upkeepTimer)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.upkeepTimer);
		}
	}

	public static void Serialize(BufferStream stream, DecayEntity instance)
	{
		if (instance.decayTimer != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.decayTimer);
		}
		if (instance.buildingID != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.buildingID);
		}
		if (instance.upkeepTimer != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.upkeepTimer);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DeliveryDrone : IDisposable, IPooled, IProto<DeliveryDrone>, IProto
{
	[NonSerialized]
	public NetworkableId marketplaceId;

	[NonSerialized]
	public NetworkableId terminalId;

	[NonSerialized]
	public NetworkableId vendingMachineId;

	[NonSerialized]
	public int state;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DeliveryDrone instance)
	{
		if (instance.ShouldPool)
		{
			instance.marketplaceId = default(NetworkableId);
			instance.terminalId = default(NetworkableId);
			instance.vendingMachineId = default(NetworkableId);
			instance.state = 0;
			Pool.Free<DeliveryDrone>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DeliveryDrone with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DeliveryDrone instance)
	{
		instance.marketplaceId = marketplaceId;
		instance.terminalId = terminalId;
		instance.vendingMachineId = vendingMachineId;
		instance.state = state;
	}

	public DeliveryDrone Copy()
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		CopyTo(deliveryDrone);
		return deliveryDrone;
	}

	public static DeliveryDrone Deserialize(BufferStream stream)
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		Deserialize(stream, deliveryDrone, isDelta: false);
		return deliveryDrone;
	}

	public static DeliveryDrone DeserializeLengthDelimited(BufferStream stream)
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		DeserializeLengthDelimited(stream, deliveryDrone, isDelta: false);
		return deliveryDrone;
	}

	public static DeliveryDrone DeserializeLength(BufferStream stream, int length)
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		DeserializeLength(stream, length, deliveryDrone, isDelta: false);
		return deliveryDrone;
	}

	public static DeliveryDrone Deserialize(byte[] buffer)
	{
		DeliveryDrone deliveryDrone = Pool.Get<DeliveryDrone>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, deliveryDrone, isDelta: false);
		return deliveryDrone;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DeliveryDrone previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DeliveryDrone Deserialize(BufferStream stream, DeliveryDrone instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.terminalId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DeliveryDrone DeserializeLengthDelimited(BufferStream stream, DeliveryDrone instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.terminalId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DeliveryDrone DeserializeLength(BufferStream stream, int length, DeliveryDrone instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.terminalId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DeliveryDrone instance, DeliveryDrone previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.marketplaceId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.terminalId.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
		if (instance.state != previous.state)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
	}

	public static void Serialize(BufferStream stream, DeliveryDrone instance)
	{
		if (instance.marketplaceId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.marketplaceId.Value);
		}
		if (instance.terminalId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.terminalId.Value);
		}
		if (instance.vendingMachineId != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref marketplaceId.Value);
		action(UidType.NetworkableId, ref terminalId.Value);
		action(UidType.NetworkableId, ref vendingMachineId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class DemoHeader : IDisposable, IPooled, IProto<DemoHeader>, IProto
{
	[NonSerialized]
	public uint version;

	[NonSerialized]
	public string level;

	[NonSerialized]
	public uint levelSeed;

	[NonSerialized]
	public uint levelSize;

	[NonSerialized]
	public string checksum;

	[NonSerialized]
	public ulong localclient;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 rotation;

	[NonSerialized]
	public string levelUrl;

	[NonSerialized]
	public long recordedTime;

	[NonSerialized]
	public long length;

	[NonSerialized]
	public List<FileStorageCacheData> fileStorage;

	[NonSerialized]
	public bool nexus;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoHeader instance)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.version = 0u;
		instance.level = string.Empty;
		instance.levelSeed = 0u;
		instance.levelSize = 0u;
		instance.checksum = string.Empty;
		instance.localclient = 0uL;
		instance.position = default(Vector3);
		instance.rotation = default(Vector3);
		instance.levelUrl = string.Empty;
		instance.recordedTime = 0L;
		instance.length = 0L;
		if (instance.fileStorage != null)
		{
			for (int i = 0; i < instance.fileStorage.Count; i++)
			{
				if (instance.fileStorage[i] != null)
				{
					instance.fileStorage[i].ResetToPool();
					instance.fileStorage[i] = null;
				}
			}
			List<FileStorageCacheData> list = instance.fileStorage;
			Pool.Free<FileStorageCacheData>(ref list, false);
			instance.fileStorage = list;
		}
		instance.nexus = false;
		Pool.Free<DemoHeader>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoHeader with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoHeader instance)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.version = version;
		instance.level = level;
		instance.levelSeed = levelSeed;
		instance.levelSize = levelSize;
		instance.checksum = checksum;
		instance.localclient = localclient;
		instance.position = position;
		instance.rotation = rotation;
		instance.levelUrl = levelUrl;
		instance.recordedTime = recordedTime;
		instance.length = length;
		if (fileStorage != null)
		{
			instance.fileStorage = Pool.Get<List<FileStorageCacheData>>();
			for (int i = 0; i < fileStorage.Count; i++)
			{
				FileStorageCacheData item = fileStorage[i].Copy();
				instance.fileStorage.Add(item);
			}
		}
		else
		{
			instance.fileStorage = null;
		}
		instance.nexus = nexus;
	}

	public DemoHeader Copy()
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		CopyTo(demoHeader);
		return demoHeader;
	}

	public static DemoHeader Deserialize(BufferStream stream)
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		Deserialize(stream, demoHeader, isDelta: false);
		return demoHeader;
	}

	public static DemoHeader DeserializeLengthDelimited(BufferStream stream)
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		DeserializeLengthDelimited(stream, demoHeader, isDelta: false);
		return demoHeader;
	}

	public static DemoHeader DeserializeLength(BufferStream stream, int length)
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		DeserializeLength(stream, length, demoHeader, isDelta: false);
		return demoHeader;
	}

	public static DemoHeader Deserialize(byte[] buffer)
	{
		DemoHeader demoHeader = Pool.Get<DemoHeader>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoHeader, isDelta: false);
		return demoHeader;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoHeader previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoHeader Deserialize(BufferStream stream, DemoHeader instance, bool isDelta)
	{
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.fileStorage == null)
		{
			instance.fileStorage = Pool.Get<List<FileStorageCacheData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.version = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.localclient = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 74:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.recordedTime = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.length = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 98:
				instance.fileStorage.Add(FileStorageCacheData.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.nexus = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoHeader DeserializeLengthDelimited(BufferStream stream, DemoHeader instance, bool isDelta)
	{
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.fileStorage == null)
		{
			instance.fileStorage = Pool.Get<List<FileStorageCacheData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.version = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.localclient = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 74:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.recordedTime = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.length = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 98:
				instance.fileStorage.Add(FileStorageCacheData.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.nexus = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoHeader DeserializeLength(BufferStream stream, int length, DemoHeader instance, bool isDelta)
	{
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.fileStorage == null)
		{
			instance.fileStorage = Pool.Get<List<FileStorageCacheData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.version = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.level = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.levelSeed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.levelSize = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.checksum = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.localclient = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 74:
				instance.levelUrl = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.recordedTime = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.length = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 98:
				instance.fileStorage.Add(FileStorageCacheData.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.nexus = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoHeader instance, DemoHeader previous)
	{
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		if (instance.version != previous.version)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.version);
		}
		if (instance.level != previous.level)
		{
			if (instance.level == null)
			{
				throw new ArgumentNullException("level", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.level);
		}
		if (instance.levelSeed != previous.levelSeed)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.levelSeed);
		}
		if (instance.levelSize != previous.levelSize)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.levelSize);
		}
		if (instance.checksum != null && instance.checksum != previous.checksum)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.checksum);
		}
		if (instance.localclient != previous.localclient)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.localclient);
		}
		if (instance.position != previous.position)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rotation, previous.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.levelUrl != previous.levelUrl)
		{
			if (instance.levelUrl == null)
			{
				throw new ArgumentNullException("levelUrl", "Required by proto specification.");
			}
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.levelUrl);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.recordedTime);
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.length);
		if (instance.fileStorage != null)
		{
			for (int i = 0; i < instance.fileStorage.Count; i++)
			{
				FileStorageCacheData fileStorageCacheData = instance.fileStorage[i];
				stream.WriteByte(98);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int num5 = stream.Position;
				FileStorageCacheData.SerializeDelta(stream, fileStorageCacheData, fileStorageCacheData);
				int val = stream.Position - num5;
				Span<byte> span3 = range3.GetSpan();
				int num6 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num6 < 5)
				{
					span3[num6 - 1] |= 128;
					while (num6 < 4)
					{
						span3[num6++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		stream.WriteByte(104);
		ProtocolParser.WriteBool(stream, instance.nexus);
	}

	public static void Serialize(BufferStream stream, DemoHeader instance)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if (instance.version != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.version);
		}
		if (instance.level == null)
		{
			throw new ArgumentNullException("level", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.level);
		if (instance.levelSeed != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.levelSeed);
		}
		if (instance.levelSize != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.levelSize);
		}
		if (instance.checksum != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.checksum);
		}
		if (instance.localclient != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.localclient);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.levelUrl == null)
		{
			throw new ArgumentNullException("levelUrl", "Required by proto specification.");
		}
		stream.WriteByte(74);
		ProtocolParser.WriteString(stream, instance.levelUrl);
		if (instance.recordedTime != 0L)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.recordedTime);
		}
		if (instance.length != 0L)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.length);
		}
		if (instance.fileStorage != null)
		{
			for (int i = 0; i < instance.fileStorage.Count; i++)
			{
				FileStorageCacheData instance2 = instance.fileStorage[i];
				stream.WriteByte(98);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int num5 = stream.Position;
				FileStorageCacheData.Serialize(stream, instance2);
				int val = stream.Position - num5;
				Span<byte> span3 = range3.GetSpan();
				int num6 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num6 < 5)
				{
					span3[num6 - 1] |= 128;
					while (num6 < 4)
					{
						span3[num6++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.nexus)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteBool(stream, instance.nexus);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (fileStorage != null)
		{
			for (int i = 0; i < fileStorage.Count; i++)
			{
				fileStorage[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShot : IDisposable, IPooled, IProto<DemoShot>, IProto
{
	[NonSerialized]
	public string shotName;

	[NonSerialized]
	public string demoName;

	[NonSerialized]
	public float shotStart;

	[NonSerialized]
	public float shotLength;

	[NonSerialized]
	public DemoShotVectorTrack camPos;

	[NonSerialized]
	public DemoShotQuaternionTrack camRot;

	[NonSerialized]
	public DemoShotFloatTrack camFov;

	[NonSerialized]
	public DemoShotFloatTrack camDofDist;

	[NonSerialized]
	public DemoShotFloatTrack camDofFocalSize;

	[NonSerialized]
	public DemoShotFloatTrack camDofAperture;

	[NonSerialized]
	public DemoShotParentTrack camParent;

	[NonSerialized]
	public string folderName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShot instance)
	{
		if (instance.ShouldPool)
		{
			instance.shotName = string.Empty;
			instance.demoName = string.Empty;
			instance.shotStart = 0f;
			instance.shotLength = 0f;
			if (instance.camPos != null)
			{
				instance.camPos.ResetToPool();
				instance.camPos = null;
			}
			if (instance.camRot != null)
			{
				instance.camRot.ResetToPool();
				instance.camRot = null;
			}
			if (instance.camFov != null)
			{
				instance.camFov.ResetToPool();
				instance.camFov = null;
			}
			if (instance.camDofDist != null)
			{
				instance.camDofDist.ResetToPool();
				instance.camDofDist = null;
			}
			if (instance.camDofFocalSize != null)
			{
				instance.camDofFocalSize.ResetToPool();
				instance.camDofFocalSize = null;
			}
			if (instance.camDofAperture != null)
			{
				instance.camDofAperture.ResetToPool();
				instance.camDofAperture = null;
			}
			if (instance.camParent != null)
			{
				instance.camParent.ResetToPool();
				instance.camParent = null;
			}
			instance.folderName = string.Empty;
			Pool.Free<DemoShot>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShot with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShot instance)
	{
		instance.shotName = shotName;
		instance.demoName = demoName;
		instance.shotStart = shotStart;
		instance.shotLength = shotLength;
		if (camPos != null)
		{
			if (instance.camPos == null)
			{
				instance.camPos = camPos.Copy();
			}
			else
			{
				camPos.CopyTo(instance.camPos);
			}
		}
		else
		{
			instance.camPos = null;
		}
		if (camRot != null)
		{
			if (instance.camRot == null)
			{
				instance.camRot = camRot.Copy();
			}
			else
			{
				camRot.CopyTo(instance.camRot);
			}
		}
		else
		{
			instance.camRot = null;
		}
		if (camFov != null)
		{
			if (instance.camFov == null)
			{
				instance.camFov = camFov.Copy();
			}
			else
			{
				camFov.CopyTo(instance.camFov);
			}
		}
		else
		{
			instance.camFov = null;
		}
		if (camDofDist != null)
		{
			if (instance.camDofDist == null)
			{
				instance.camDofDist = camDofDist.Copy();
			}
			else
			{
				camDofDist.CopyTo(instance.camDofDist);
			}
		}
		else
		{
			instance.camDofDist = null;
		}
		if (camDofFocalSize != null)
		{
			if (instance.camDofFocalSize == null)
			{
				instance.camDofFocalSize = camDofFocalSize.Copy();
			}
			else
			{
				camDofFocalSize.CopyTo(instance.camDofFocalSize);
			}
		}
		else
		{
			instance.camDofFocalSize = null;
		}
		if (camDofAperture != null)
		{
			if (instance.camDofAperture == null)
			{
				instance.camDofAperture = camDofAperture.Copy();
			}
			else
			{
				camDofAperture.CopyTo(instance.camDofAperture);
			}
		}
		else
		{
			instance.camDofAperture = null;
		}
		if (camParent != null)
		{
			if (instance.camParent == null)
			{
				instance.camParent = camParent.Copy();
			}
			else
			{
				camParent.CopyTo(instance.camParent);
			}
		}
		else
		{
			instance.camParent = null;
		}
		instance.folderName = folderName;
	}

	public DemoShot Copy()
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		CopyTo(demoShot);
		return demoShot;
	}

	public static DemoShot Deserialize(BufferStream stream)
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		Deserialize(stream, demoShot, isDelta: false);
		return demoShot;
	}

	public static DemoShot DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		DeserializeLengthDelimited(stream, demoShot, isDelta: false);
		return demoShot;
	}

	public static DemoShot DeserializeLength(BufferStream stream, int length)
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		DeserializeLength(stream, length, demoShot, isDelta: false);
		return demoShot;
	}

	public static DemoShot Deserialize(byte[] buffer)
	{
		DemoShot demoShot = Pool.Get<DemoShot>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShot, isDelta: false);
		return demoShot;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShot previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShot Deserialize(BufferStream stream, DemoShot instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.shotName = ProtocolParser.ReadString(stream);
				break;
			case 18:
				instance.demoName = ProtocolParser.ReadString(stream);
				break;
			case 29:
				instance.shotStart = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.shotLength = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.camPos == null)
				{
					instance.camPos = DemoShotVectorTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotVectorTrack.DeserializeLengthDelimited(stream, instance.camPos, isDelta);
				}
				break;
			case 50:
				if (instance.camRot == null)
				{
					instance.camRot = DemoShotQuaternionTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotQuaternionTrack.DeserializeLengthDelimited(stream, instance.camRot, isDelta);
				}
				break;
			case 58:
				if (instance.camFov == null)
				{
					instance.camFov = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camFov, isDelta);
				}
				break;
			case 74:
				if (instance.camDofDist == null)
				{
					instance.camDofDist = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofDist, isDelta);
				}
				break;
			case 82:
				if (instance.camDofFocalSize == null)
				{
					instance.camDofFocalSize = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofFocalSize, isDelta);
				}
				break;
			case 90:
				if (instance.camDofAperture == null)
				{
					instance.camDofAperture = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofAperture, isDelta);
				}
				break;
			case 98:
				if (instance.camParent == null)
				{
					instance.camParent = DemoShotParentTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotParentTrack.DeserializeLengthDelimited(stream, instance.camParent, isDelta);
				}
				break;
			case 66:
				instance.folderName = ProtocolParser.ReadString(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static DemoShot DeserializeLengthDelimited(BufferStream stream, DemoShot instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shotName = ProtocolParser.ReadString(stream);
				break;
			case 18:
				instance.demoName = ProtocolParser.ReadString(stream);
				break;
			case 29:
				instance.shotStart = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.shotLength = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.camPos == null)
				{
					instance.camPos = DemoShotVectorTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotVectorTrack.DeserializeLengthDelimited(stream, instance.camPos, isDelta);
				}
				break;
			case 50:
				if (instance.camRot == null)
				{
					instance.camRot = DemoShotQuaternionTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotQuaternionTrack.DeserializeLengthDelimited(stream, instance.camRot, isDelta);
				}
				break;
			case 58:
				if (instance.camFov == null)
				{
					instance.camFov = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camFov, isDelta);
				}
				break;
			case 74:
				if (instance.camDofDist == null)
				{
					instance.camDofDist = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofDist, isDelta);
				}
				break;
			case 82:
				if (instance.camDofFocalSize == null)
				{
					instance.camDofFocalSize = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofFocalSize, isDelta);
				}
				break;
			case 90:
				if (instance.camDofAperture == null)
				{
					instance.camDofAperture = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofAperture, isDelta);
				}
				break;
			case 98:
				if (instance.camParent == null)
				{
					instance.camParent = DemoShotParentTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotParentTrack.DeserializeLengthDelimited(stream, instance.camParent, isDelta);
				}
				break;
			case 66:
				instance.folderName = ProtocolParser.ReadString(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShot DeserializeLength(BufferStream stream, int length, DemoShot instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shotName = ProtocolParser.ReadString(stream);
				break;
			case 18:
				instance.demoName = ProtocolParser.ReadString(stream);
				break;
			case 29:
				instance.shotStart = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.shotLength = ProtocolParser.ReadSingle(stream);
				break;
			case 42:
				if (instance.camPos == null)
				{
					instance.camPos = DemoShotVectorTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotVectorTrack.DeserializeLengthDelimited(stream, instance.camPos, isDelta);
				}
				break;
			case 50:
				if (instance.camRot == null)
				{
					instance.camRot = DemoShotQuaternionTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotQuaternionTrack.DeserializeLengthDelimited(stream, instance.camRot, isDelta);
				}
				break;
			case 58:
				if (instance.camFov == null)
				{
					instance.camFov = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camFov, isDelta);
				}
				break;
			case 74:
				if (instance.camDofDist == null)
				{
					instance.camDofDist = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofDist, isDelta);
				}
				break;
			case 82:
				if (instance.camDofFocalSize == null)
				{
					instance.camDofFocalSize = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofFocalSize, isDelta);
				}
				break;
			case 90:
				if (instance.camDofAperture == null)
				{
					instance.camDofAperture = DemoShotFloatTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotFloatTrack.DeserializeLengthDelimited(stream, instance.camDofAperture, isDelta);
				}
				break;
			case 98:
				if (instance.camParent == null)
				{
					instance.camParent = DemoShotParentTrack.DeserializeLengthDelimited(stream);
				}
				else
				{
					DemoShotParentTrack.DeserializeLengthDelimited(stream, instance.camParent, isDelta);
				}
				break;
			case 66:
				instance.folderName = ProtocolParser.ReadString(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShot instance, DemoShot previous)
	{
		if (instance.shotName != previous.shotName)
		{
			if (instance.shotName == null)
			{
				throw new ArgumentNullException("shotName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.shotName);
		}
		if (instance.demoName != previous.demoName)
		{
			if (instance.demoName == null)
			{
				throw new ArgumentNullException("demoName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.demoName);
		}
		if (instance.shotStart != previous.shotStart)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.shotStart);
		}
		if (instance.shotLength != previous.shotLength)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.shotLength);
		}
		if (instance.camPos == null)
		{
			throw new ArgumentNullException("camPos", "Required by proto specification.");
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		DemoShotVectorTrack.SerializeDelta(stream, instance.camPos, previous.camPos);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camPos (ProtoBuf.DemoShotVectorTrack)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
		if (instance.camRot == null)
		{
			throw new ArgumentNullException("camRot", "Required by proto specification.");
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range2 = stream.GetRange(3);
		int position2 = stream.Position;
		DemoShotQuaternionTrack.SerializeDelta(stream, instance.camRot, previous.camRot);
		int num3 = stream.Position - position2;
		if (num3 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camRot (ProtoBuf.DemoShotQuaternionTrack)");
		}
		Span<byte> span2 = range2.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)num3, span2, 0);
		if (num4 < 3)
		{
			span2[num4 - 1] |= 128;
			while (num4 < 2)
			{
				span2[num4++] = 128;
			}
			span2[2] = 0;
		}
		if (instance.camFov == null)
		{
			throw new ArgumentNullException("camFov", "Required by proto specification.");
		}
		stream.WriteByte(58);
		BufferStream.RangeHandle range3 = stream.GetRange(3);
		int position3 = stream.Position;
		DemoShotFloatTrack.SerializeDelta(stream, instance.camFov, previous.camFov);
		int num5 = stream.Position - position3;
		if (num5 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camFov (ProtoBuf.DemoShotFloatTrack)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num6 = ProtocolParser.WriteUInt32((uint)num5, span3, 0);
		if (num6 < 3)
		{
			span3[num6 - 1] |= 128;
			while (num6 < 2)
			{
				span3[num6++] = 128;
			}
			span3[2] = 0;
		}
		if (instance.camDofDist != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range4 = stream.GetRange(3);
			int position4 = stream.Position;
			DemoShotFloatTrack.SerializeDelta(stream, instance.camDofDist, previous.camDofDist);
			int num7 = stream.Position - position4;
			if (num7 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofDist (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span4 = range4.GetSpan();
			int num8 = ProtocolParser.WriteUInt32((uint)num7, span4, 0);
			if (num8 < 3)
			{
				span4[num8 - 1] |= 128;
				while (num8 < 2)
				{
					span4[num8++] = 128;
				}
				span4[2] = 0;
			}
		}
		if (instance.camDofFocalSize != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range5 = stream.GetRange(3);
			int position5 = stream.Position;
			DemoShotFloatTrack.SerializeDelta(stream, instance.camDofFocalSize, previous.camDofFocalSize);
			int num9 = stream.Position - position5;
			if (num9 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofFocalSize (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span5 = range5.GetSpan();
			int num10 = ProtocolParser.WriteUInt32((uint)num9, span5, 0);
			if (num10 < 3)
			{
				span5[num10 - 1] |= 128;
				while (num10 < 2)
				{
					span5[num10++] = 128;
				}
				span5[2] = 0;
			}
		}
		if (instance.camDofAperture != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range6 = stream.GetRange(3);
			int position6 = stream.Position;
			DemoShotFloatTrack.SerializeDelta(stream, instance.camDofAperture, previous.camDofAperture);
			int num11 = stream.Position - position6;
			if (num11 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofAperture (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span6 = range6.GetSpan();
			int num12 = ProtocolParser.WriteUInt32((uint)num11, span6, 0);
			if (num12 < 3)
			{
				span6[num12 - 1] |= 128;
				while (num12 < 2)
				{
					span6[num12++] = 128;
				}
				span6[2] = 0;
			}
		}
		if (instance.camParent != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range7 = stream.GetRange(5);
			int position7 = stream.Position;
			DemoShotParentTrack.SerializeDelta(stream, instance.camParent, previous.camParent);
			int val = stream.Position - position7;
			Span<byte> span7 = range7.GetSpan();
			int num13 = ProtocolParser.WriteUInt32((uint)val, span7, 0);
			if (num13 < 5)
			{
				span7[num13 - 1] |= 128;
				while (num13 < 4)
				{
					span7[num13++] = 128;
				}
				span7[4] = 0;
			}
		}
		if (instance.folderName != null && instance.folderName != previous.folderName)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.folderName);
		}
	}

	public static void Serialize(BufferStream stream, DemoShot instance)
	{
		if (instance.shotName == null)
		{
			throw new ArgumentNullException("shotName", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.shotName);
		if (instance.demoName == null)
		{
			throw new ArgumentNullException("demoName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.demoName);
		if (instance.shotStart != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.shotStart);
		}
		if (instance.shotLength != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.shotLength);
		}
		if (instance.camPos == null)
		{
			throw new ArgumentNullException("camPos", "Required by proto specification.");
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		DemoShotVectorTrack.Serialize(stream, instance.camPos);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camPos (ProtoBuf.DemoShotVectorTrack)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
		if (instance.camRot == null)
		{
			throw new ArgumentNullException("camRot", "Required by proto specification.");
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range2 = stream.GetRange(3);
		int position2 = stream.Position;
		DemoShotQuaternionTrack.Serialize(stream, instance.camRot);
		int num3 = stream.Position - position2;
		if (num3 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camRot (ProtoBuf.DemoShotQuaternionTrack)");
		}
		Span<byte> span2 = range2.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)num3, span2, 0);
		if (num4 < 3)
		{
			span2[num4 - 1] |= 128;
			while (num4 < 2)
			{
				span2[num4++] = 128;
			}
			span2[2] = 0;
		}
		if (instance.camFov == null)
		{
			throw new ArgumentNullException("camFov", "Required by proto specification.");
		}
		stream.WriteByte(58);
		BufferStream.RangeHandle range3 = stream.GetRange(3);
		int position3 = stream.Position;
		DemoShotFloatTrack.Serialize(stream, instance.camFov);
		int num5 = stream.Position - position3;
		if (num5 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camFov (ProtoBuf.DemoShotFloatTrack)");
		}
		Span<byte> span3 = range3.GetSpan();
		int num6 = ProtocolParser.WriteUInt32((uint)num5, span3, 0);
		if (num6 < 3)
		{
			span3[num6 - 1] |= 128;
			while (num6 < 2)
			{
				span3[num6++] = 128;
			}
			span3[2] = 0;
		}
		if (instance.camDofDist != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range4 = stream.GetRange(3);
			int position4 = stream.Position;
			DemoShotFloatTrack.Serialize(stream, instance.camDofDist);
			int num7 = stream.Position - position4;
			if (num7 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofDist (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span4 = range4.GetSpan();
			int num8 = ProtocolParser.WriteUInt32((uint)num7, span4, 0);
			if (num8 < 3)
			{
				span4[num8 - 1] |= 128;
				while (num8 < 2)
				{
					span4[num8++] = 128;
				}
				span4[2] = 0;
			}
		}
		if (instance.camDofFocalSize != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range5 = stream.GetRange(3);
			int position5 = stream.Position;
			DemoShotFloatTrack.Serialize(stream, instance.camDofFocalSize);
			int num9 = stream.Position - position5;
			if (num9 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofFocalSize (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span5 = range5.GetSpan();
			int num10 = ProtocolParser.WriteUInt32((uint)num9, span5, 0);
			if (num10 < 3)
			{
				span5[num10 - 1] |= 128;
				while (num10 < 2)
				{
					span5[num10++] = 128;
				}
				span5[2] = 0;
			}
		}
		if (instance.camDofAperture != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range6 = stream.GetRange(3);
			int position6 = stream.Position;
			DemoShotFloatTrack.Serialize(stream, instance.camDofAperture);
			int num11 = stream.Position - position6;
			if (num11 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field camDofAperture (ProtoBuf.DemoShotFloatTrack)");
			}
			Span<byte> span6 = range6.GetSpan();
			int num12 = ProtocolParser.WriteUInt32((uint)num11, span6, 0);
			if (num12 < 3)
			{
				span6[num12 - 1] |= 128;
				while (num12 < 2)
				{
					span6[num12++] = 128;
				}
				span6[2] = 0;
			}
		}
		if (instance.camParent != null)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range7 = stream.GetRange(5);
			int position7 = stream.Position;
			DemoShotParentTrack.Serialize(stream, instance.camParent);
			int val = stream.Position - position7;
			Span<byte> span7 = range7.GetSpan();
			int num13 = ProtocolParser.WriteUInt32((uint)val, span7, 0);
			if (num13 < 5)
			{
				span7[num13 - 1] |= 128;
				while (num13 < 4)
				{
					span7[num13++] = 128;
				}
				span7[4] = 0;
			}
		}
		if (instance.folderName != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.folderName);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		camPos?.InspectUids(action);
		camRot?.InspectUids(action);
		camFov?.InspectUids(action);
		camDofDist?.InspectUids(action);
		camDofFocalSize?.InspectUids(action);
		camDofAperture?.InspectUids(action);
		camParent?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public struct DemoShotFloatKeyframe : IProto<DemoShotFloatKeyframe>, IProto
{
	[NonSerialized]
	public float keyframeTime;

	[NonSerialized]
	public float keyFrameValue;

	public static void ResetToPool(DemoShotFloatKeyframe instance)
	{
		instance.keyframeTime = 0f;
		instance.keyFrameValue = 0f;
	}

	public void CopyTo(DemoShotFloatKeyframe instance)
	{
		instance.keyframeTime = keyframeTime;
		instance.keyFrameValue = keyFrameValue;
	}

	public DemoShotFloatKeyframe Copy()
	{
		DemoShotFloatKeyframe demoShotFloatKeyframe = default(DemoShotFloatKeyframe);
		CopyTo(demoShotFloatKeyframe);
		return demoShotFloatKeyframe;
	}

	public static DemoShotFloatKeyframe Deserialize(BufferStream stream)
	{
		DemoShotFloatKeyframe instance = default(DemoShotFloatKeyframe);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotFloatKeyframe DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotFloatKeyframe instance = default(DemoShotFloatKeyframe);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotFloatKeyframe DeserializeLength(BufferStream stream, int length)
	{
		DemoShotFloatKeyframe instance = default(DemoShotFloatKeyframe);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotFloatKeyframe Deserialize(byte[] buffer)
	{
		DemoShotFloatKeyframe instance = default(DemoShotFloatKeyframe);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, DemoShotFloatKeyframe previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static DemoShotFloatKeyframe Deserialize(BufferStream stream, ref DemoShotFloatKeyframe instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValue = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoShotFloatKeyframe DeserializeLengthDelimited(BufferStream stream, ref DemoShotFloatKeyframe instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValue = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotFloatKeyframe DeserializeLength(BufferStream stream, int length, ref DemoShotFloatKeyframe instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValue = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotFloatKeyframe instance, DemoShotFloatKeyframe previous)
	{
		if (instance.keyframeTime != previous.keyframeTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValue != previous.keyFrameValue)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValue);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotFloatKeyframe instance)
	{
		if (instance.keyframeTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValue != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValue);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShotFloatTrack : IDisposable, IPooled, IProto<DemoShotFloatTrack>, IProto
{
	[NonSerialized]
	public long trackType;

	[NonSerialized]
	public List<DemoShotFloatKeyframe> keyframes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShotFloatTrack instance)
	{
		if (instance.ShouldPool)
		{
			instance.trackType = 0L;
			if (instance.keyframes != null)
			{
				List<DemoShotFloatKeyframe> list = instance.keyframes;
				Pool.FreeUnmanaged<DemoShotFloatKeyframe>(ref list);
				instance.keyframes = list;
			}
			Pool.Free<DemoShotFloatTrack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShotFloatTrack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShotFloatTrack instance)
	{
		instance.trackType = trackType;
		if (keyframes != null)
		{
			instance.keyframes = Pool.Get<List<DemoShotFloatKeyframe>>();
			for (int i = 0; i < keyframes.Count; i++)
			{
				DemoShotFloatKeyframe item = keyframes[i];
				instance.keyframes.Add(item);
			}
		}
		else
		{
			instance.keyframes = null;
		}
	}

	public DemoShotFloatTrack Copy()
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		CopyTo(demoShotFloatTrack);
		return demoShotFloatTrack;
	}

	public static DemoShotFloatTrack Deserialize(BufferStream stream)
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		Deserialize(stream, demoShotFloatTrack, isDelta: false);
		return demoShotFloatTrack;
	}

	public static DemoShotFloatTrack DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		DeserializeLengthDelimited(stream, demoShotFloatTrack, isDelta: false);
		return demoShotFloatTrack;
	}

	public static DemoShotFloatTrack DeserializeLength(BufferStream stream, int length)
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		DeserializeLength(stream, length, demoShotFloatTrack, isDelta: false);
		return demoShotFloatTrack;
	}

	public static DemoShotFloatTrack Deserialize(byte[] buffer)
	{
		DemoShotFloatTrack demoShotFloatTrack = Pool.Get<DemoShotFloatTrack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShotFloatTrack, isDelta: false);
		return demoShotFloatTrack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShotFloatTrack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShotFloatTrack Deserialize(BufferStream stream, DemoShotFloatTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotFloatKeyframe>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotFloatKeyframe instance2 = default(DemoShotFloatKeyframe);
				DemoShotFloatKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static DemoShotFloatTrack DeserializeLengthDelimited(BufferStream stream, DemoShotFloatTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotFloatKeyframe>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotFloatKeyframe instance2 = default(DemoShotFloatKeyframe);
				DemoShotFloatKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotFloatTrack DeserializeLength(BufferStream stream, int length, DemoShotFloatTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotFloatKeyframe>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotFloatKeyframe instance2 = default(DemoShotFloatKeyframe);
				DemoShotFloatKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotFloatTrack instance, DemoShotFloatTrack previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotFloatKeyframe demoShotFloatKeyframe = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotFloatKeyframe.SerializeDelta(stream, demoShotFloatKeyframe, demoShotFloatKeyframe);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotFloatKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotFloatTrack instance)
	{
		if (instance.trackType != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotFloatKeyframe instance2 = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotFloatKeyframe.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotFloatKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (keyframes != null)
		{
			for (int i = 0; i < keyframes.Count; i++)
			{
				keyframes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public struct DemoShotParentKeyframe : IProto<DemoShotParentKeyframe>, IProto
{
	[NonSerialized]
	public float keyframeTime;

	[NonSerialized]
	public NetworkableId keyFrameParentId;

	[NonSerialized]
	public string keyFrameParentName;

	public static void ResetToPool(DemoShotParentKeyframe instance)
	{
		instance.keyframeTime = 0f;
		instance.keyFrameParentId = default(NetworkableId);
		instance.keyFrameParentName = string.Empty;
	}

	public void CopyTo(DemoShotParentKeyframe instance)
	{
		instance.keyframeTime = keyframeTime;
		instance.keyFrameParentId = keyFrameParentId;
		instance.keyFrameParentName = keyFrameParentName;
	}

	public DemoShotParentKeyframe Copy()
	{
		DemoShotParentKeyframe demoShotParentKeyframe = default(DemoShotParentKeyframe);
		CopyTo(demoShotParentKeyframe);
		return demoShotParentKeyframe;
	}

	public static DemoShotParentKeyframe Deserialize(BufferStream stream)
	{
		DemoShotParentKeyframe instance = default(DemoShotParentKeyframe);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotParentKeyframe DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotParentKeyframe instance = default(DemoShotParentKeyframe);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotParentKeyframe DeserializeLength(BufferStream stream, int length)
	{
		DemoShotParentKeyframe instance = default(DemoShotParentKeyframe);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotParentKeyframe Deserialize(byte[] buffer)
	{
		DemoShotParentKeyframe instance = default(DemoShotParentKeyframe);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, DemoShotParentKeyframe previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static DemoShotParentKeyframe Deserialize(BufferStream stream, ref DemoShotParentKeyframe instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.keyFrameParentId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.keyFrameParentName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoShotParentKeyframe DeserializeLengthDelimited(BufferStream stream, ref DemoShotParentKeyframe instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.keyFrameParentId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.keyFrameParentName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotParentKeyframe DeserializeLength(BufferStream stream, int length, ref DemoShotParentKeyframe instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.keyFrameParentId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.keyFrameParentName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotParentKeyframe instance, DemoShotParentKeyframe previous)
	{
		if (instance.keyframeTime != previous.keyframeTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.keyFrameParentId.Value);
		if (instance.keyFrameParentName != previous.keyFrameParentName)
		{
			if (instance.keyFrameParentName == null)
			{
				throw new ArgumentNullException("keyFrameParentName", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.keyFrameParentName);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotParentKeyframe instance)
	{
		if (instance.keyframeTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameParentId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.keyFrameParentId.Value);
		}
		if (instance.keyFrameParentName == null)
		{
			throw new ArgumentNullException("keyFrameParentName", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.keyFrameParentName);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref keyFrameParentId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShotParentTrack : IDisposable, IPooled, IProto<DemoShotParentTrack>, IProto
{
	[NonSerialized]
	public ulong parentId;

	[NonSerialized]
	public List<DemoShotParentKeyframe> keyframes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShotParentTrack instance)
	{
		if (instance.ShouldPool)
		{
			instance.parentId = 0uL;
			if (instance.keyframes != null)
			{
				List<DemoShotParentKeyframe> list = instance.keyframes;
				Pool.FreeUnmanaged<DemoShotParentKeyframe>(ref list);
				instance.keyframes = list;
			}
			Pool.Free<DemoShotParentTrack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShotParentTrack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShotParentTrack instance)
	{
		instance.parentId = parentId;
		if (keyframes != null)
		{
			instance.keyframes = Pool.Get<List<DemoShotParentKeyframe>>();
			for (int i = 0; i < keyframes.Count; i++)
			{
				DemoShotParentKeyframe item = keyframes[i];
				instance.keyframes.Add(item);
			}
		}
		else
		{
			instance.keyframes = null;
		}
	}

	public DemoShotParentTrack Copy()
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		CopyTo(demoShotParentTrack);
		return demoShotParentTrack;
	}

	public static DemoShotParentTrack Deserialize(BufferStream stream)
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		Deserialize(stream, demoShotParentTrack, isDelta: false);
		return demoShotParentTrack;
	}

	public static DemoShotParentTrack DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		DeserializeLengthDelimited(stream, demoShotParentTrack, isDelta: false);
		return demoShotParentTrack;
	}

	public static DemoShotParentTrack DeserializeLength(BufferStream stream, int length)
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		DeserializeLength(stream, length, demoShotParentTrack, isDelta: false);
		return demoShotParentTrack;
	}

	public static DemoShotParentTrack Deserialize(byte[] buffer)
	{
		DemoShotParentTrack demoShotParentTrack = Pool.Get<DemoShotParentTrack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShotParentTrack, isDelta: false);
		return demoShotParentTrack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShotParentTrack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShotParentTrack Deserialize(BufferStream stream, DemoShotParentTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotParentKeyframe>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotParentKeyframe instance2 = default(DemoShotParentKeyframe);
				DemoShotParentKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static DemoShotParentTrack DeserializeLengthDelimited(BufferStream stream, DemoShotParentTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotParentKeyframe>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotParentKeyframe instance2 = default(DemoShotParentKeyframe);
				DemoShotParentKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotParentTrack DeserializeLength(BufferStream stream, int length, DemoShotParentTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotParentKeyframe>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotParentKeyframe instance2 = default(DemoShotParentKeyframe);
				DemoShotParentKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotParentTrack instance, DemoShotParentTrack previous)
	{
		if (instance.parentId != previous.parentId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentId);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotParentKeyframe demoShotParentKeyframe = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			DemoShotParentKeyframe.SerializeDelta(stream, demoShotParentKeyframe, demoShotParentKeyframe);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, DemoShotParentTrack instance)
	{
		if (instance.parentId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentId);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotParentKeyframe instance2 = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			DemoShotParentKeyframe.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (keyframes != null)
		{
			for (int i = 0; i < keyframes.Count; i++)
			{
				keyframes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public struct DemoShotQuaternionKeyframe : IProto<DemoShotQuaternionKeyframe>, IProto
{
	[NonSerialized]
	public float keyframeTime;

	[NonSerialized]
	public float keyFrameValueX;

	[NonSerialized]
	public float keyFrameValueY;

	[NonSerialized]
	public float keyFrameValueZ;

	[NonSerialized]
	public float keyFrameValueW;

	public static void ResetToPool(DemoShotQuaternionKeyframe instance)
	{
		instance.keyframeTime = 0f;
		instance.keyFrameValueX = 0f;
		instance.keyFrameValueY = 0f;
		instance.keyFrameValueZ = 0f;
		instance.keyFrameValueW = 0f;
	}

	public void CopyTo(DemoShotQuaternionKeyframe instance)
	{
		instance.keyframeTime = keyframeTime;
		instance.keyFrameValueX = keyFrameValueX;
		instance.keyFrameValueY = keyFrameValueY;
		instance.keyFrameValueZ = keyFrameValueZ;
		instance.keyFrameValueW = keyFrameValueW;
	}

	public DemoShotQuaternionKeyframe Copy()
	{
		DemoShotQuaternionKeyframe demoShotQuaternionKeyframe = default(DemoShotQuaternionKeyframe);
		CopyTo(demoShotQuaternionKeyframe);
		return demoShotQuaternionKeyframe;
	}

	public static DemoShotQuaternionKeyframe Deserialize(BufferStream stream)
	{
		DemoShotQuaternionKeyframe instance = default(DemoShotQuaternionKeyframe);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotQuaternionKeyframe DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotQuaternionKeyframe instance = default(DemoShotQuaternionKeyframe);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotQuaternionKeyframe DeserializeLength(BufferStream stream, int length)
	{
		DemoShotQuaternionKeyframe instance = default(DemoShotQuaternionKeyframe);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotQuaternionKeyframe Deserialize(byte[] buffer)
	{
		DemoShotQuaternionKeyframe instance = default(DemoShotQuaternionKeyframe);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, DemoShotQuaternionKeyframe previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static DemoShotQuaternionKeyframe Deserialize(BufferStream stream, ref DemoShotQuaternionKeyframe instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValueX = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.keyFrameValueY = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.keyFrameValueZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.keyFrameValueW = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoShotQuaternionKeyframe DeserializeLengthDelimited(BufferStream stream, ref DemoShotQuaternionKeyframe instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValueX = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.keyFrameValueY = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.keyFrameValueZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.keyFrameValueW = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotQuaternionKeyframe DeserializeLength(BufferStream stream, int length, ref DemoShotQuaternionKeyframe instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.keyFrameValueX = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.keyFrameValueY = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.keyFrameValueZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.keyFrameValueW = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotQuaternionKeyframe instance, DemoShotQuaternionKeyframe previous)
	{
		if (instance.keyframeTime != previous.keyframeTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValueX != previous.keyFrameValueX)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueX);
		}
		if (instance.keyFrameValueY != previous.keyFrameValueY)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueY);
		}
		if (instance.keyFrameValueZ != previous.keyFrameValueZ)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueZ);
		}
		if (instance.keyFrameValueW != previous.keyFrameValueW)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueW);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotQuaternionKeyframe instance)
	{
		if (instance.keyframeTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValueX != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueX);
		}
		if (instance.keyFrameValueY != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueY);
		}
		if (instance.keyFrameValueZ != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueZ);
		}
		if (instance.keyFrameValueW != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.keyFrameValueW);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShotQuaternionTrack : IDisposable, IPooled, IProto<DemoShotQuaternionTrack>, IProto
{
	[NonSerialized]
	public long trackType;

	[NonSerialized]
	public List<DemoShotQuaternionKeyframe> keyframes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShotQuaternionTrack instance)
	{
		if (instance.ShouldPool)
		{
			instance.trackType = 0L;
			if (instance.keyframes != null)
			{
				List<DemoShotQuaternionKeyframe> list = instance.keyframes;
				Pool.FreeUnmanaged<DemoShotQuaternionKeyframe>(ref list);
				instance.keyframes = list;
			}
			Pool.Free<DemoShotQuaternionTrack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShotQuaternionTrack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShotQuaternionTrack instance)
	{
		instance.trackType = trackType;
		if (keyframes != null)
		{
			instance.keyframes = Pool.Get<List<DemoShotQuaternionKeyframe>>();
			for (int i = 0; i < keyframes.Count; i++)
			{
				DemoShotQuaternionKeyframe item = keyframes[i];
				instance.keyframes.Add(item);
			}
		}
		else
		{
			instance.keyframes = null;
		}
	}

	public DemoShotQuaternionTrack Copy()
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		CopyTo(demoShotQuaternionTrack);
		return demoShotQuaternionTrack;
	}

	public static DemoShotQuaternionTrack Deserialize(BufferStream stream)
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		Deserialize(stream, demoShotQuaternionTrack, isDelta: false);
		return demoShotQuaternionTrack;
	}

	public static DemoShotQuaternionTrack DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		DeserializeLengthDelimited(stream, demoShotQuaternionTrack, isDelta: false);
		return demoShotQuaternionTrack;
	}

	public static DemoShotQuaternionTrack DeserializeLength(BufferStream stream, int length)
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		DeserializeLength(stream, length, demoShotQuaternionTrack, isDelta: false);
		return demoShotQuaternionTrack;
	}

	public static DemoShotQuaternionTrack Deserialize(byte[] buffer)
	{
		DemoShotQuaternionTrack demoShotQuaternionTrack = Pool.Get<DemoShotQuaternionTrack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShotQuaternionTrack, isDelta: false);
		return demoShotQuaternionTrack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShotQuaternionTrack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShotQuaternionTrack Deserialize(BufferStream stream, DemoShotQuaternionTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotQuaternionKeyframe>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotQuaternionKeyframe instance2 = default(DemoShotQuaternionKeyframe);
				DemoShotQuaternionKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static DemoShotQuaternionTrack DeserializeLengthDelimited(BufferStream stream, DemoShotQuaternionTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotQuaternionKeyframe>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotQuaternionKeyframe instance2 = default(DemoShotQuaternionKeyframe);
				DemoShotQuaternionKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotQuaternionTrack DeserializeLength(BufferStream stream, int length, DemoShotQuaternionTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotQuaternionKeyframe>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotQuaternionKeyframe instance2 = default(DemoShotQuaternionKeyframe);
				DemoShotQuaternionKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotQuaternionTrack instance, DemoShotQuaternionTrack previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotQuaternionKeyframe demoShotQuaternionKeyframe = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotQuaternionKeyframe.SerializeDelta(stream, demoShotQuaternionKeyframe, demoShotQuaternionKeyframe);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotQuaternionKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotQuaternionTrack instance)
	{
		if (instance.trackType != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotQuaternionKeyframe instance2 = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotQuaternionKeyframe.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotQuaternionKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (keyframes != null)
		{
			for (int i = 0; i < keyframes.Count; i++)
			{
				keyframes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public struct DemoShotVectorKeyframe : IProto<DemoShotVectorKeyframe>, IProto
{
	[NonSerialized]
	public float keyframeTime;

	[NonSerialized]
	public Vector3 keyFrameValue;

	public static void ResetToPool(DemoShotVectorKeyframe instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.keyframeTime = 0f;
		instance.keyFrameValue = default(Vector3);
	}

	public void CopyTo(DemoShotVectorKeyframe instance)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		instance.keyframeTime = keyframeTime;
		instance.keyFrameValue = keyFrameValue;
	}

	public DemoShotVectorKeyframe Copy()
	{
		DemoShotVectorKeyframe demoShotVectorKeyframe = default(DemoShotVectorKeyframe);
		CopyTo(demoShotVectorKeyframe);
		return demoShotVectorKeyframe;
	}

	public static DemoShotVectorKeyframe Deserialize(BufferStream stream)
	{
		DemoShotVectorKeyframe instance = default(DemoShotVectorKeyframe);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotVectorKeyframe DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotVectorKeyframe instance = default(DemoShotVectorKeyframe);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotVectorKeyframe DeserializeLength(BufferStream stream, int length)
	{
		DemoShotVectorKeyframe instance = default(DemoShotVectorKeyframe);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static DemoShotVectorKeyframe Deserialize(byte[] buffer)
	{
		DemoShotVectorKeyframe instance = default(DemoShotVectorKeyframe);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, DemoShotVectorKeyframe previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static DemoShotVectorKeyframe Deserialize(BufferStream stream, ref DemoShotVectorKeyframe instance, bool isDelta)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.keyFrameValue, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DemoShotVectorKeyframe DeserializeLengthDelimited(BufferStream stream, ref DemoShotVectorKeyframe instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.keyFrameValue, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotVectorKeyframe DeserializeLength(BufferStream stream, int length, ref DemoShotVectorKeyframe instance, bool isDelta)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.keyframeTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.keyFrameValue, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotVectorKeyframe instance, DemoShotVectorKeyframe previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.keyframeTime != previous.keyframeTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValue != previous.keyFrameValue)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.keyFrameValue, previous.keyFrameValue);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyFrameValue (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotVectorKeyframe instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (instance.keyframeTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.keyframeTime);
		}
		if (instance.keyFrameValue != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.keyFrameValue);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyFrameValue (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DemoShotVectorTrack : IDisposable, IPooled, IProto<DemoShotVectorTrack>, IProto
{
	[NonSerialized]
	public long trackType;

	[NonSerialized]
	public List<DemoShotVectorKeyframe> keyframes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DemoShotVectorTrack instance)
	{
		if (instance.ShouldPool)
		{
			instance.trackType = 0L;
			if (instance.keyframes != null)
			{
				List<DemoShotVectorKeyframe> list = instance.keyframes;
				Pool.FreeUnmanaged<DemoShotVectorKeyframe>(ref list);
				instance.keyframes = list;
			}
			Pool.Free<DemoShotVectorTrack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DemoShotVectorTrack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DemoShotVectorTrack instance)
	{
		instance.trackType = trackType;
		if (keyframes != null)
		{
			instance.keyframes = Pool.Get<List<DemoShotVectorKeyframe>>();
			for (int i = 0; i < keyframes.Count; i++)
			{
				DemoShotVectorKeyframe item = keyframes[i];
				instance.keyframes.Add(item);
			}
		}
		else
		{
			instance.keyframes = null;
		}
	}

	public DemoShotVectorTrack Copy()
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		CopyTo(demoShotVectorTrack);
		return demoShotVectorTrack;
	}

	public static DemoShotVectorTrack Deserialize(BufferStream stream)
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		Deserialize(stream, demoShotVectorTrack, isDelta: false);
		return demoShotVectorTrack;
	}

	public static DemoShotVectorTrack DeserializeLengthDelimited(BufferStream stream)
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		DeserializeLengthDelimited(stream, demoShotVectorTrack, isDelta: false);
		return demoShotVectorTrack;
	}

	public static DemoShotVectorTrack DeserializeLength(BufferStream stream, int length)
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		DeserializeLength(stream, length, demoShotVectorTrack, isDelta: false);
		return demoShotVectorTrack;
	}

	public static DemoShotVectorTrack Deserialize(byte[] buffer)
	{
		DemoShotVectorTrack demoShotVectorTrack = Pool.Get<DemoShotVectorTrack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, demoShotVectorTrack, isDelta: false);
		return demoShotVectorTrack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DemoShotVectorTrack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DemoShotVectorTrack Deserialize(BufferStream stream, DemoShotVectorTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotVectorKeyframe>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotVectorKeyframe instance2 = default(DemoShotVectorKeyframe);
				DemoShotVectorKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static DemoShotVectorTrack DeserializeLengthDelimited(BufferStream stream, DemoShotVectorTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotVectorKeyframe>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotVectorKeyframe instance2 = default(DemoShotVectorKeyframe);
				DemoShotVectorKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DemoShotVectorTrack DeserializeLength(BufferStream stream, int length, DemoShotVectorTrack instance, bool isDelta)
	{
		if (!isDelta && instance.keyframes == null)
		{
			instance.keyframes = Pool.Get<List<DemoShotVectorKeyframe>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.trackType = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
			{
				DemoShotVectorKeyframe instance2 = default(DemoShotVectorKeyframe);
				DemoShotVectorKeyframe.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.keyframes.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DemoShotVectorTrack instance, DemoShotVectorTrack previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotVectorKeyframe demoShotVectorKeyframe = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotVectorKeyframe.SerializeDelta(stream, demoShotVectorKeyframe, demoShotVectorKeyframe);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotVectorKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, DemoShotVectorTrack instance)
	{
		if (instance.trackType != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.trackType);
		}
		if (instance.keyframes == null)
		{
			return;
		}
		for (int i = 0; i < instance.keyframes.Count; i++)
		{
			DemoShotVectorKeyframe instance2 = instance.keyframes[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			DemoShotVectorKeyframe.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field keyframes (ProtoBuf.DemoShotVectorKeyframe)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (keyframes != null)
		{
			for (int i = 0; i < keyframes.Count; i++)
			{
				keyframes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DieselEngine : IDisposable, IPooled, IProto<DieselEngine>, IProto
{
	[NonSerialized]
	public float fuelTime;

	[NonSerialized]
	public ulong startedByPlayer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DieselEngine instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelTime = 0f;
			instance.startedByPlayer = 0uL;
			Pool.Free<DieselEngine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DieselEngine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DieselEngine instance)
	{
		instance.fuelTime = fuelTime;
		instance.startedByPlayer = startedByPlayer;
	}

	public DieselEngine Copy()
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		CopyTo(dieselEngine);
		return dieselEngine;
	}

	public static DieselEngine Deserialize(BufferStream stream)
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		Deserialize(stream, dieselEngine, isDelta: false);
		return dieselEngine;
	}

	public static DieselEngine DeserializeLengthDelimited(BufferStream stream)
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		DeserializeLengthDelimited(stream, dieselEngine, isDelta: false);
		return dieselEngine;
	}

	public static DieselEngine DeserializeLength(BufferStream stream, int length)
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		DeserializeLength(stream, length, dieselEngine, isDelta: false);
		return dieselEngine;
	}

	public static DieselEngine Deserialize(byte[] buffer)
	{
		DieselEngine dieselEngine = Pool.Get<DieselEngine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, dieselEngine, isDelta: false);
		return dieselEngine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DieselEngine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DieselEngine Deserialize(BufferStream stream, DieselEngine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.fuelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.startedByPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DieselEngine DeserializeLengthDelimited(BufferStream stream, DieselEngine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fuelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.startedByPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DieselEngine DeserializeLength(BufferStream stream, int length, DieselEngine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fuelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.startedByPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DieselEngine instance, DieselEngine previous)
	{
		if (instance.fuelTime != previous.fuelTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fuelTime);
		}
		if (instance.startedByPlayer != previous.startedByPlayer)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.startedByPlayer);
		}
	}

	public static void Serialize(BufferStream stream, DieselEngine instance)
	{
		if (instance.fuelTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fuelTime);
		}
		if (instance.startedByPlayer != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.startedByPlayer);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DigitalClock : IDisposable, IPooled, IProto<DigitalClock>, IProto
{
	[NonSerialized]
	public List<DigitalClockAlarm> alarms;

	[NonSerialized]
	public bool muted;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DigitalClock instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				if (instance.alarms[i] != null)
				{
					instance.alarms[i].ResetToPool();
					instance.alarms[i] = null;
				}
			}
			List<DigitalClockAlarm> list = instance.alarms;
			Pool.Free<DigitalClockAlarm>(ref list, false);
			instance.alarms = list;
		}
		instance.muted = false;
		Pool.Free<DigitalClock>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DigitalClock with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DigitalClock instance)
	{
		if (alarms != null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
			for (int i = 0; i < alarms.Count; i++)
			{
				DigitalClockAlarm item = alarms[i].Copy();
				instance.alarms.Add(item);
			}
		}
		else
		{
			instance.alarms = null;
		}
		instance.muted = muted;
	}

	public DigitalClock Copy()
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		CopyTo(digitalClock);
		return digitalClock;
	}

	public static DigitalClock Deserialize(BufferStream stream)
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		Deserialize(stream, digitalClock, isDelta: false);
		return digitalClock;
	}

	public static DigitalClock DeserializeLengthDelimited(BufferStream stream)
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		DeserializeLengthDelimited(stream, digitalClock, isDelta: false);
		return digitalClock;
	}

	public static DigitalClock DeserializeLength(BufferStream stream, int length)
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		DeserializeLength(stream, length, digitalClock, isDelta: false);
		return digitalClock;
	}

	public static DigitalClock Deserialize(byte[] buffer)
	{
		DigitalClock digitalClock = Pool.Get<DigitalClock>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, digitalClock, isDelta: false);
		return digitalClock;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DigitalClock previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DigitalClock Deserialize(BufferStream stream, DigitalClock instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DigitalClock DeserializeLengthDelimited(BufferStream stream, DigitalClock instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DigitalClock DeserializeLength(BufferStream stream, int length, DigitalClock instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DigitalClock instance, DigitalClock previous)
	{
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				DigitalClockAlarm digitalClockAlarm = instance.alarms[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				DigitalClockAlarm.SerializeDelta(stream, digitalClockAlarm, digitalClockAlarm);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field alarms (ProtoBuf.DigitalClockAlarm)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.muted);
	}

	public static void Serialize(BufferStream stream, DigitalClock instance)
	{
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				DigitalClockAlarm instance2 = instance.alarms[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				DigitalClockAlarm.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field alarms (ProtoBuf.DigitalClockAlarm)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.muted)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.muted);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (alarms != null)
		{
			for (int i = 0; i < alarms.Count; i++)
			{
				alarms[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DigitalClockAlarm : IDisposable, IPooled, IProto<DigitalClockAlarm>, IProto
{
	[NonSerialized]
	public float time;

	[NonSerialized]
	public bool active;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DigitalClockAlarm instance)
	{
		if (instance.ShouldPool)
		{
			instance.time = 0f;
			instance.active = false;
			Pool.Free<DigitalClockAlarm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DigitalClockAlarm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DigitalClockAlarm instance)
	{
		instance.time = time;
		instance.active = active;
	}

	public DigitalClockAlarm Copy()
	{
		DigitalClockAlarm digitalClockAlarm = Pool.Get<DigitalClockAlarm>();
		CopyTo(digitalClockAlarm);
		return digitalClockAlarm;
	}

	public static DigitalClockAlarm Deserialize(BufferStream stream)
	{
		DigitalClockAlarm digitalClockAlarm = Pool.Get<DigitalClockAlarm>();
		Deserialize(stream, digitalClockAlarm, isDelta: false);
		return digitalClockAlarm;
	}

	public static DigitalClockAlarm DeserializeLengthDelimited(BufferStream stream)
	{
		DigitalClockAlarm digitalClockAlarm = Pool.Get<DigitalClockAlarm>();
		DeserializeLengthDelimited(stream, digitalClockAlarm, isDelta: false);
		return digitalClockAlarm;
	}

	public static DigitalClockAlarm DeserializeLength(BufferStream stream, int length)
	{
		DigitalClockAlarm digitalClockAlarm = Pool.Get<DigitalClockAlarm>();
		DeserializeLength(stream, length, digitalClockAlarm, isDelta: false);
		return digitalClockAlarm;
	}

	public static DigitalClockAlarm Deserialize(byte[] buffer)
	{
		DigitalClockAlarm digitalClockAlarm = Pool.Get<DigitalClockAlarm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, digitalClockAlarm, isDelta: false);
		return digitalClockAlarm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DigitalClockAlarm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DigitalClockAlarm Deserialize(BufferStream stream, DigitalClockAlarm instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.active = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DigitalClockAlarm DeserializeLengthDelimited(BufferStream stream, DigitalClockAlarm instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.active = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DigitalClockAlarm DeserializeLength(BufferStream stream, int length, DigitalClockAlarm instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.active = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DigitalClockAlarm instance, DigitalClockAlarm previous)
	{
		if (instance.time != previous.time)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.active);
	}

	public static void Serialize(BufferStream stream, DigitalClockAlarm instance)
	{
		if (instance.time != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.active)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.active);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DigitalClockMessage : IDisposable, IPooled, IProto<DigitalClockMessage>, IProto
{
	[NonSerialized]
	public List<DigitalClockAlarm> alarms;

	[NonSerialized]
	public bool muted;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DigitalClockMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				if (instance.alarms[i] != null)
				{
					instance.alarms[i].ResetToPool();
					instance.alarms[i] = null;
				}
			}
			List<DigitalClockAlarm> list = instance.alarms;
			Pool.Free<DigitalClockAlarm>(ref list, false);
			instance.alarms = list;
		}
		instance.muted = false;
		Pool.Free<DigitalClockMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DigitalClockMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DigitalClockMessage instance)
	{
		if (alarms != null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
			for (int i = 0; i < alarms.Count; i++)
			{
				DigitalClockAlarm item = alarms[i].Copy();
				instance.alarms.Add(item);
			}
		}
		else
		{
			instance.alarms = null;
		}
		instance.muted = muted;
	}

	public DigitalClockMessage Copy()
	{
		DigitalClockMessage digitalClockMessage = Pool.Get<DigitalClockMessage>();
		CopyTo(digitalClockMessage);
		return digitalClockMessage;
	}

	public static DigitalClockMessage Deserialize(BufferStream stream)
	{
		DigitalClockMessage digitalClockMessage = Pool.Get<DigitalClockMessage>();
		Deserialize(stream, digitalClockMessage, isDelta: false);
		return digitalClockMessage;
	}

	public static DigitalClockMessage DeserializeLengthDelimited(BufferStream stream)
	{
		DigitalClockMessage digitalClockMessage = Pool.Get<DigitalClockMessage>();
		DeserializeLengthDelimited(stream, digitalClockMessage, isDelta: false);
		return digitalClockMessage;
	}

	public static DigitalClockMessage DeserializeLength(BufferStream stream, int length)
	{
		DigitalClockMessage digitalClockMessage = Pool.Get<DigitalClockMessage>();
		DeserializeLength(stream, length, digitalClockMessage, isDelta: false);
		return digitalClockMessage;
	}

	public static DigitalClockMessage Deserialize(byte[] buffer)
	{
		DigitalClockMessage digitalClockMessage = Pool.Get<DigitalClockMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, digitalClockMessage, isDelta: false);
		return digitalClockMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DigitalClockMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DigitalClockMessage Deserialize(BufferStream stream, DigitalClockMessage instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DigitalClockMessage DeserializeLengthDelimited(BufferStream stream, DigitalClockMessage instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DigitalClockMessage DeserializeLength(BufferStream stream, int length, DigitalClockMessage instance, bool isDelta)
	{
		if (!isDelta && instance.alarms == null)
		{
			instance.alarms = Pool.Get<List<DigitalClockAlarm>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.alarms.Add(DigitalClockAlarm.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.muted = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DigitalClockMessage instance, DigitalClockMessage previous)
	{
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				DigitalClockAlarm digitalClockAlarm = instance.alarms[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				DigitalClockAlarm.SerializeDelta(stream, digitalClockAlarm, digitalClockAlarm);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field alarms (ProtoBuf.DigitalClockAlarm)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.muted);
	}

	public static void Serialize(BufferStream stream, DigitalClockMessage instance)
	{
		if (instance.alarms != null)
		{
			for (int i = 0; i < instance.alarms.Count; i++)
			{
				DigitalClockAlarm instance2 = instance.alarms[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				DigitalClockAlarm.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field alarms (ProtoBuf.DigitalClockAlarm)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.muted)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.muted);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (alarms != null)
		{
			for (int i = 0; i < alarms.Count; i++)
			{
				alarms[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DiverPropulsionVehicle : IDisposable, IPooled, IProto<DiverPropulsionVehicle>, IProto
{
	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public int fuelAmount;

	[NonSerialized]
	public int fuelTicks;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DiverPropulsionVehicle instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelAmount = 0;
			instance.fuelTicks = 0;
			Pool.Free<DiverPropulsionVehicle>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DiverPropulsionVehicle with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DiverPropulsionVehicle instance)
	{
		instance.fuelStorageID = fuelStorageID;
		instance.fuelAmount = fuelAmount;
		instance.fuelTicks = fuelTicks;
	}

	public DiverPropulsionVehicle Copy()
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		CopyTo(diverPropulsionVehicle);
		return diverPropulsionVehicle;
	}

	public static DiverPropulsionVehicle Deserialize(BufferStream stream)
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		Deserialize(stream, diverPropulsionVehicle, isDelta: false);
		return diverPropulsionVehicle;
	}

	public static DiverPropulsionVehicle DeserializeLengthDelimited(BufferStream stream)
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		DeserializeLengthDelimited(stream, diverPropulsionVehicle, isDelta: false);
		return diverPropulsionVehicle;
	}

	public static DiverPropulsionVehicle DeserializeLength(BufferStream stream, int length)
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		DeserializeLength(stream, length, diverPropulsionVehicle, isDelta: false);
		return diverPropulsionVehicle;
	}

	public static DiverPropulsionVehicle Deserialize(byte[] buffer)
	{
		DiverPropulsionVehicle diverPropulsionVehicle = Pool.Get<DiverPropulsionVehicle>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, diverPropulsionVehicle, isDelta: false);
		return diverPropulsionVehicle;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DiverPropulsionVehicle previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DiverPropulsionVehicle Deserialize(BufferStream stream, DiverPropulsionVehicle instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.fuelTicks = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DiverPropulsionVehicle DeserializeLengthDelimited(BufferStream stream, DiverPropulsionVehicle instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.fuelTicks = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DiverPropulsionVehicle DeserializeLength(BufferStream stream, int length, DiverPropulsionVehicle instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.fuelAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.fuelTicks = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DiverPropulsionVehicle instance, DiverPropulsionVehicle previous)
	{
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelAmount != previous.fuelAmount)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.fuelAmount);
		}
		if (instance.fuelTicks != previous.fuelTicks)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.fuelTicks);
		}
	}

	public static void Serialize(BufferStream stream, DiverPropulsionVehicle instance)
	{
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelAmount != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.fuelAmount);
		}
		if (instance.fuelTicks != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.fuelTicks);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Door : IDisposable, IPooled, IProto<Door>, IProto
{
	[NonSerialized]
	public bool canNpcOpen;

	[NonSerialized]
	public bool canHandOpen;

	[NonSerialized]
	public bool isSecurityDoor;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Door instance)
	{
		if (instance.ShouldPool)
		{
			instance.canNpcOpen = false;
			instance.canHandOpen = false;
			instance.isSecurityDoor = false;
			Pool.Free<Door>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Door with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Door instance)
	{
		instance.canNpcOpen = canNpcOpen;
		instance.canHandOpen = canHandOpen;
		instance.isSecurityDoor = isSecurityDoor;
	}

	public Door Copy()
	{
		Door door = Pool.Get<Door>();
		CopyTo(door);
		return door;
	}

	public static Door Deserialize(BufferStream stream)
	{
		Door door = Pool.Get<Door>();
		Deserialize(stream, door, isDelta: false);
		return door;
	}

	public static Door DeserializeLengthDelimited(BufferStream stream)
	{
		Door door = Pool.Get<Door>();
		DeserializeLengthDelimited(stream, door, isDelta: false);
		return door;
	}

	public static Door DeserializeLength(BufferStream stream, int length)
	{
		Door door = Pool.Get<Door>();
		DeserializeLength(stream, length, door, isDelta: false);
		return door;
	}

	public static Door Deserialize(byte[] buffer)
	{
		Door door = Pool.Get<Door>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, door, isDelta: false);
		return door;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Door previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Door Deserialize(BufferStream stream, Door instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.canNpcOpen = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.canHandOpen = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.isSecurityDoor = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Door DeserializeLengthDelimited(BufferStream stream, Door instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.canNpcOpen = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.canHandOpen = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.isSecurityDoor = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Door DeserializeLength(BufferStream stream, int length, Door instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.canNpcOpen = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.canHandOpen = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.isSecurityDoor = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Door instance, Door previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.canNpcOpen);
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.canHandOpen);
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.isSecurityDoor);
	}

	public static void Serialize(BufferStream stream, Door instance)
	{
		if (instance.canNpcOpen)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.canNpcOpen);
		}
		if (instance.canHandOpen)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.canHandOpen);
		}
		if (instance.isSecurityDoor)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.isSecurityDoor);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Drone : IDisposable, IPooled, IProto<Drone>, IProto
{
	[NonSerialized]
	public float pitch;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Drone instance)
	{
		if (instance.ShouldPool)
		{
			instance.pitch = 0f;
			Pool.Free<Drone>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Drone with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Drone instance)
	{
		instance.pitch = pitch;
	}

	public Drone Copy()
	{
		Drone drone = Pool.Get<Drone>();
		CopyTo(drone);
		return drone;
	}

	public static Drone Deserialize(BufferStream stream)
	{
		Drone drone = Pool.Get<Drone>();
		Deserialize(stream, drone, isDelta: false);
		return drone;
	}

	public static Drone DeserializeLengthDelimited(BufferStream stream)
	{
		Drone drone = Pool.Get<Drone>();
		DeserializeLengthDelimited(stream, drone, isDelta: false);
		return drone;
	}

	public static Drone DeserializeLength(BufferStream stream, int length)
	{
		Drone drone = Pool.Get<Drone>();
		DeserializeLength(stream, length, drone, isDelta: false);
		return drone;
	}

	public static Drone Deserialize(byte[] buffer)
	{
		Drone drone = Pool.Get<Drone>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, drone, isDelta: false);
		return drone;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Drone previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Drone Deserialize(BufferStream stream, Drone instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Drone DeserializeLengthDelimited(BufferStream stream, Drone instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Drone DeserializeLength(BufferStream stream, int length, Drone instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Drone instance, Drone previous)
	{
		if (instance.pitch != previous.pitch)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
	}

	public static void Serialize(BufferStream stream, Drone instance)
	{
		if (instance.pitch != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class DudExplosive : IDisposable, IPooled, IProto<DudExplosive>, IProto
{
	[NonSerialized]
	public float fuseTimeLeft;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DudExplosive instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuseTimeLeft = 0f;
			Pool.Free<DudExplosive>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DudExplosive with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DudExplosive instance)
	{
		instance.fuseTimeLeft = fuseTimeLeft;
	}

	public DudExplosive Copy()
	{
		DudExplosive dudExplosive = Pool.Get<DudExplosive>();
		CopyTo(dudExplosive);
		return dudExplosive;
	}

	public static DudExplosive Deserialize(BufferStream stream)
	{
		DudExplosive dudExplosive = Pool.Get<DudExplosive>();
		Deserialize(stream, dudExplosive, isDelta: false);
		return dudExplosive;
	}

	public static DudExplosive DeserializeLengthDelimited(BufferStream stream)
	{
		DudExplosive dudExplosive = Pool.Get<DudExplosive>();
		DeserializeLengthDelimited(stream, dudExplosive, isDelta: false);
		return dudExplosive;
	}

	public static DudExplosive DeserializeLength(BufferStream stream, int length)
	{
		DudExplosive dudExplosive = Pool.Get<DudExplosive>();
		DeserializeLength(stream, length, dudExplosive, isDelta: false);
		return dudExplosive;
	}

	public static DudExplosive Deserialize(byte[] buffer)
	{
		DudExplosive dudExplosive = Pool.Get<DudExplosive>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, dudExplosive, isDelta: false);
		return dudExplosive;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, DudExplosive previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DudExplosive Deserialize(BufferStream stream, DudExplosive instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.fuseTimeLeft = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DudExplosive DeserializeLengthDelimited(BufferStream stream, DudExplosive instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fuseTimeLeft = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DudExplosive DeserializeLength(BufferStream stream, int length, DudExplosive instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fuseTimeLeft = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, DudExplosive instance, DudExplosive previous)
	{
		if (instance.fuseTimeLeft != previous.fuseTimeLeft)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fuseTimeLeft);
		}
	}

	public static void Serialize(BufferStream stream, DudExplosive instance)
	{
		if (instance.fuseTimeLeft != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fuseTimeLeft);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class EggHunt : IDisposable, IPooled, IProto<EggHunt>, IProto
{
	public class EggHunter : IDisposable, IPooled, IProto<EggHunter>, IProto
	{
		[NonSerialized]
		public string displayName;

		[NonSerialized]
		public int numEggs;

		[NonSerialized]
		public ulong playerID;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(EggHunter instance)
		{
			if (instance.ShouldPool)
			{
				instance.displayName = string.Empty;
				instance.numEggs = 0;
				instance.playerID = 0uL;
				Pool.Free<EggHunter>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose EggHunter with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(EggHunter instance)
		{
			instance.displayName = displayName;
			instance.numEggs = numEggs;
			instance.playerID = playerID;
		}

		public EggHunter Copy()
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			CopyTo(eggHunter);
			return eggHunter;
		}

		public static EggHunter Deserialize(BufferStream stream)
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			Deserialize(stream, eggHunter, isDelta: false);
			return eggHunter;
		}

		public static EggHunter DeserializeLengthDelimited(BufferStream stream)
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			DeserializeLengthDelimited(stream, eggHunter, isDelta: false);
			return eggHunter;
		}

		public static EggHunter DeserializeLength(BufferStream stream, int length)
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			DeserializeLength(stream, length, eggHunter, isDelta: false);
			return eggHunter;
		}

		public static EggHunter Deserialize(byte[] buffer)
		{
			EggHunter eggHunter = Pool.Get<EggHunter>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, eggHunter, isDelta: false);
			return eggHunter;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, EggHunter previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static EggHunter Deserialize(BufferStream stream, EggHunter instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static EggHunter DeserializeLengthDelimited(BufferStream stream, EggHunter instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static EggHunter DeserializeLength(BufferStream stream, int length, EggHunter instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, EggHunter instance, EggHunter previous)
		{
			if (instance.displayName != null && instance.displayName != previous.displayName)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.numEggs != previous.numEggs)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.numEggs);
			}
			if (instance.playerID != previous.playerID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
		}

		public static void Serialize(BufferStream stream, EggHunter instance)
		{
			if (instance.displayName != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.numEggs != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.numEggs);
			}
			if (instance.playerID != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<EggHunter> hunters;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EggHunt instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.hunters != null)
		{
			for (int i = 0; i < instance.hunters.Count; i++)
			{
				if (instance.hunters[i] != null)
				{
					instance.hunters[i].ResetToPool();
					instance.hunters[i] = null;
				}
			}
			List<EggHunter> list = instance.hunters;
			Pool.Free<EggHunter>(ref list, false);
			instance.hunters = list;
		}
		Pool.Free<EggHunt>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EggHunt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EggHunt instance)
	{
		if (hunters != null)
		{
			instance.hunters = Pool.Get<List<EggHunter>>();
			for (int i = 0; i < hunters.Count; i++)
			{
				EggHunter item = hunters[i].Copy();
				instance.hunters.Add(item);
			}
		}
		else
		{
			instance.hunters = null;
		}
	}

	public EggHunt Copy()
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		CopyTo(eggHunt);
		return eggHunt;
	}

	public static EggHunt Deserialize(BufferStream stream)
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		Deserialize(stream, eggHunt, isDelta: false);
		return eggHunt;
	}

	public static EggHunt DeserializeLengthDelimited(BufferStream stream)
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		DeserializeLengthDelimited(stream, eggHunt, isDelta: false);
		return eggHunt;
	}

	public static EggHunt DeserializeLength(BufferStream stream, int length)
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		DeserializeLength(stream, length, eggHunt, isDelta: false);
		return eggHunt;
	}

	public static EggHunt Deserialize(byte[] buffer)
	{
		EggHunt eggHunt = Pool.Get<EggHunt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, eggHunt, isDelta: false);
		return eggHunt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EggHunt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EggHunt Deserialize(BufferStream stream, EggHunt instance, bool isDelta)
	{
		if (!isDelta && instance.hunters == null)
		{
			instance.hunters = Pool.Get<List<EggHunter>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.hunters.Add(EggHunter.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EggHunt DeserializeLengthDelimited(BufferStream stream, EggHunt instance, bool isDelta)
	{
		if (!isDelta && instance.hunters == null)
		{
			instance.hunters = Pool.Get<List<EggHunter>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.hunters.Add(EggHunter.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EggHunt DeserializeLength(BufferStream stream, int length, EggHunt instance, bool isDelta)
	{
		if (!isDelta && instance.hunters == null)
		{
			instance.hunters = Pool.Get<List<EggHunter>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.hunters.Add(EggHunter.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EggHunt instance, EggHunt previous)
	{
		if (instance.hunters == null)
		{
			return;
		}
		for (int i = 0; i < instance.hunters.Count; i++)
		{
			EggHunter eggHunter = instance.hunters[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			EggHunter.SerializeDelta(stream, eggHunter, eggHunter);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, EggHunt instance)
	{
		if (instance.hunters == null)
		{
			return;
		}
		for (int i = 0; i < instance.hunters.Count; i++)
		{
			EggHunter instance2 = instance.hunters[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			EggHunter.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (hunters != null)
		{
			for (int i = 0; i < hunters.Count; i++)
			{
				hunters[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Elevator : IDisposable, IPooled, IProto<Elevator>, IProto
{
	[NonSerialized]
	public int floor;

	[NonSerialized]
	public NetworkableId spawnedLift;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Elevator instance)
	{
		if (instance.ShouldPool)
		{
			instance.floor = 0;
			instance.spawnedLift = default(NetworkableId);
			Pool.Free<Elevator>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Elevator with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Elevator instance)
	{
		instance.floor = floor;
		instance.spawnedLift = spawnedLift;
	}

	public Elevator Copy()
	{
		Elevator elevator = Pool.Get<Elevator>();
		CopyTo(elevator);
		return elevator;
	}

	public static Elevator Deserialize(BufferStream stream)
	{
		Elevator elevator = Pool.Get<Elevator>();
		Deserialize(stream, elevator, isDelta: false);
		return elevator;
	}

	public static Elevator DeserializeLengthDelimited(BufferStream stream)
	{
		Elevator elevator = Pool.Get<Elevator>();
		DeserializeLengthDelimited(stream, elevator, isDelta: false);
		return elevator;
	}

	public static Elevator DeserializeLength(BufferStream stream, int length)
	{
		Elevator elevator = Pool.Get<Elevator>();
		DeserializeLength(stream, length, elevator, isDelta: false);
		return elevator;
	}

	public static Elevator Deserialize(byte[] buffer)
	{
		Elevator elevator = Pool.Get<Elevator>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, elevator, isDelta: false);
		return elevator;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Elevator previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Elevator Deserialize(BufferStream stream, Elevator instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.spawnedLift = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Elevator DeserializeLengthDelimited(BufferStream stream, Elevator instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.spawnedLift = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Elevator DeserializeLength(BufferStream stream, int length, Elevator instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.spawnedLift = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Elevator instance, Elevator previous)
	{
		if (instance.floor != previous.floor)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.floor);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.spawnedLift.Value);
	}

	public static void Serialize(BufferStream stream, Elevator instance)
	{
		if (instance.floor != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.floor);
		}
		if (instance.spawnedLift != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.spawnedLift.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref spawnedLift.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ElevatorLift : IDisposable, IPooled, IProto<ElevatorLift>, IProto
{
	[NonSerialized]
	public NetworkableId owner;

	[NonSerialized]
	public float topElevatorHeight;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ElevatorLift instance)
	{
		if (instance.ShouldPool)
		{
			instance.owner = default(NetworkableId);
			instance.topElevatorHeight = 0f;
			Pool.Free<ElevatorLift>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ElevatorLift with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ElevatorLift instance)
	{
		instance.owner = owner;
		instance.topElevatorHeight = topElevatorHeight;
	}

	public ElevatorLift Copy()
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		CopyTo(elevatorLift);
		return elevatorLift;
	}

	public static ElevatorLift Deserialize(BufferStream stream)
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		Deserialize(stream, elevatorLift, isDelta: false);
		return elevatorLift;
	}

	public static ElevatorLift DeserializeLengthDelimited(BufferStream stream)
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		DeserializeLengthDelimited(stream, elevatorLift, isDelta: false);
		return elevatorLift;
	}

	public static ElevatorLift DeserializeLength(BufferStream stream, int length)
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		DeserializeLength(stream, length, elevatorLift, isDelta: false);
		return elevatorLift;
	}

	public static ElevatorLift Deserialize(byte[] buffer)
	{
		ElevatorLift elevatorLift = Pool.Get<ElevatorLift>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, elevatorLift, isDelta: false);
		return elevatorLift;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ElevatorLift previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ElevatorLift Deserialize(BufferStream stream, ElevatorLift instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.owner = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.topElevatorHeight = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ElevatorLift DeserializeLengthDelimited(BufferStream stream, ElevatorLift instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.owner = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.topElevatorHeight = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ElevatorLift DeserializeLength(BufferStream stream, int length, ElevatorLift instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.owner = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.topElevatorHeight = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ElevatorLift instance, ElevatorLift previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.owner.Value);
		if (instance.topElevatorHeight != previous.topElevatorHeight)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.topElevatorHeight);
		}
	}

	public static void Serialize(BufferStream stream, ElevatorLift instance)
	{
		if (instance.owner != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.owner.Value);
		}
		if (instance.topElevatorHeight != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.topElevatorHeight);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref owner.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class EngineStorage : IDisposable, IPooled, IProto<EngineStorage>, IProto
{
	[NonSerialized]
	public bool isUsable;

	[NonSerialized]
	public float accelerationBoost;

	[NonSerialized]
	public float topSpeedBoost;

	[NonSerialized]
	public float fuelEconomyBoost;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EngineStorage instance)
	{
		if (instance.ShouldPool)
		{
			instance.isUsable = false;
			instance.accelerationBoost = 0f;
			instance.topSpeedBoost = 0f;
			instance.fuelEconomyBoost = 0f;
			Pool.Free<EngineStorage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EngineStorage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EngineStorage instance)
	{
		instance.isUsable = isUsable;
		instance.accelerationBoost = accelerationBoost;
		instance.topSpeedBoost = topSpeedBoost;
		instance.fuelEconomyBoost = fuelEconomyBoost;
	}

	public EngineStorage Copy()
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		CopyTo(engineStorage);
		return engineStorage;
	}

	public static EngineStorage Deserialize(BufferStream stream)
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		Deserialize(stream, engineStorage, isDelta: false);
		return engineStorage;
	}

	public static EngineStorage DeserializeLengthDelimited(BufferStream stream)
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		DeserializeLengthDelimited(stream, engineStorage, isDelta: false);
		return engineStorage;
	}

	public static EngineStorage DeserializeLength(BufferStream stream, int length)
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		DeserializeLength(stream, length, engineStorage, isDelta: false);
		return engineStorage;
	}

	public static EngineStorage Deserialize(byte[] buffer)
	{
		EngineStorage engineStorage = Pool.Get<EngineStorage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, engineStorage, isDelta: false);
		return engineStorage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EngineStorage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EngineStorage Deserialize(BufferStream stream, EngineStorage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.isUsable = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.accelerationBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.topSpeedBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.fuelEconomyBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EngineStorage DeserializeLengthDelimited(BufferStream stream, EngineStorage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.isUsable = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.accelerationBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.topSpeedBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.fuelEconomyBoost = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EngineStorage DeserializeLength(BufferStream stream, int length, EngineStorage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.isUsable = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.accelerationBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.topSpeedBoost = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.fuelEconomyBoost = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EngineStorage instance, EngineStorage previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.isUsable);
		if (instance.accelerationBoost != previous.accelerationBoost)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.accelerationBoost);
		}
		if (instance.topSpeedBoost != previous.topSpeedBoost)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.topSpeedBoost);
		}
		if (instance.fuelEconomyBoost != previous.fuelEconomyBoost)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.fuelEconomyBoost);
		}
	}

	public static void Serialize(BufferStream stream, EngineStorage instance)
	{
		if (instance.isUsable)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.isUsable);
		}
		if (instance.accelerationBoost != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.accelerationBoost);
		}
		if (instance.topSpeedBoost != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.topSpeedBoost);
		}
		if (instance.fuelEconomyBoost != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.fuelEconomyBoost);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


